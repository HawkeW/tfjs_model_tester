const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/browserAll-aB6VSaJW.js","assets/webworkerAll-Bznaa_Tn.js","assets/colorToUniform-C2GHuDhf.js","assets/CanvasPool-CyL6rUCF.js","assets/index-CU9N_oBu.js","assets/index-o16NAz4V.css","assets/tfjs-DSq-hcCs.js","assets/WebGPURenderer-l4WKkicU.js","assets/SharedSystems-CSUfS5EN.js","assets/WebGLRenderer-9JhWnSmC.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { h as Hi, c as Gj, _ as Wl, d as vF, e as zS, r as ot, s as Wj, a as St, w as nn, i as gF, b as ht, g as jn, F as Bf, f as mF, o as Oc, j as Lm, k as at, T as Hj, n as bo, u as Q, t as Id, l as Wt, m as Me, p as Tt, q as Uj, v as yF, x as Yj, y as _M, C as qj, z as Ln, A as Xj, B as _F, D as dt, E as jj, G as jh, H as bF, I as zf, J as FS, K as VS, L as Kj, M as Hl, N as Zj, O as Qj, P as Jj, Q as eK, R as tK, S as Zn, U as tn, V as Ie, W as qv, X as Q1, Y as it, Z as Rr, $ as bM, a0 as rK, a1 as nK, __tla as __tla_0 } from "./index-CU9N_oBu.js";
import { e as hp, s as xF, r as wF, t as iK, g as xM, a as GS } from "./tfjs-DSq-hcCs.js";
let jC, mq, En, du, Xi, qt, Zi, Sy, H1e, kB, kc, gxe, Cxe, $t, wr, Vr, rn, Dxe, gS, jxe, Lv, dS, LB, T1, RB, q1e, an, G9, Fa, yq, Jt, fr, $xe, twe, bwe, wwe, Iwe, Dwe, Ewe, GC, tu, PSe, LSe, Mm, TS, Ju, ISe, Pq, ZB, jB, f1e, Em, p1e, Rq, jMe, xd, _g, zC, Ti, KB, Yxe, pq, Q9, ta, dq, _we, xwe, _B, Cwe, Mwe, wq, I1e, FC, Kt, uq, d1e, Xn, Pwe, lo, z9;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })()
]).then(async () => {
  var J1 = function(t, e) {
    return J1 = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(r, n) {
      r.__proto__ = n;
    } || function(r, n) {
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
    }, J1(t, e);
  };
  function K(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    J1(t, e);
    function r() {
      this.constructor = t;
    }
    t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
  }
  var aK = /* @__PURE__ */ function() {
    function t() {
      this.firefox = false, this.ie = false, this.edge = false, this.newEdge = false, this.weChat = false;
    }
    return t;
  }(), oK = /* @__PURE__ */ function() {
    function t() {
      this.browser = new aK(), this.node = false, this.wxa = false, this.worker = false, this.svgSupported = false, this.touchEventsSupported = false, this.pointerEventsSupported = false, this.domSupported = false, this.transformSupported = false, this.transform3dSupported = false, this.hasGlobalWindow = typeof window < "u";
    }
    return t;
  }(), ct = new oK();
  typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (ct.wxa = true, ct.touchEventsSupported = true) : typeof document > "u" && typeof self < "u" ? ct.worker = true : !ct.hasGlobalWindow || "Deno" in window ? (ct.node = true, ct.svgSupported = true) : sK(navigator.userAgent, ct);
  function sK(t, e) {
    var r = e.browser, n = t.match(/Firefox\/([\d.]+)/), i = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/), a = t.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(t);
    n && (r.firefox = true, r.version = n[1]), i && (r.ie = true, r.version = i[1]), a && (r.edge = true, r.version = a[1], r.newEdge = +a[1].split(".")[0] > 18), o && (r.weChat = true), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !r.ie && !r.edge, e.pointerEventsSupported = "onpointerdown" in window && (r.edge || r.ie && +r.version >= 11), e.domSupported = typeof document < "u";
    var s = document.documentElement.style;
    e.transform3dSupported = (r.ie && "transition" in s || r.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), e.transformSupported = e.transform3dSupported || r.ie && +r.version >= 9;
  }
  var WS = 12, SF = "sans-serif", cs = WS + "px " + SF, lK = 20, uK = 100, cK = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
  function hK(t) {
    var e = {};
    if (typeof JSON > "u") return e;
    for (var r = 0; r < t.length; r++) {
      var n = String.fromCharCode(r + 32), i = (t.charCodeAt(r) - lK) / uK;
      e[n] = i;
    }
    return e;
  }
  var fK = hK(cK), hs = {
    createCanvas: function() {
      return typeof document < "u" && document.createElement("canvas");
    },
    measureText: /* @__PURE__ */ function() {
      var t, e;
      return function(r, n) {
        if (!t) {
          var i = hs.createCanvas();
          t = i && i.getContext("2d");
        }
        if (t) return e !== n && (e = t.font = n || cs), t.measureText(r);
        r = r || "", n = n || cs;
        var a = /((?:\d+)?\.?\d*)px/.exec(n), o = a && +a[1] || WS, s = 0;
        if (n.indexOf("mono") >= 0) s = o * r.length;
        else for (var l = 0; l < r.length; l++) {
          var u = fK[r[l]];
          s += u == null ? o : u * o;
        }
        return {
          width: s
        };
      };
    }(),
    loadImage: function(t, e, r) {
      var n = new Image();
      return n.onload = e, n.onerror = r, n.src = t, n;
    }
  }, TF = ka([
    "Function",
    "RegExp",
    "Date",
    "Error",
    "CanvasGradient",
    "CanvasPattern",
    "Image",
    "Canvas"
  ], function(t, e) {
    return t["[object " + e + "]"] = true, t;
  }, {}), CF = ka([
    "Int8",
    "Uint8",
    "Uint8Clamped",
    "Int16",
    "Uint16",
    "Int32",
    "Uint32",
    "Float32",
    "Float64"
  ], function(t, e) {
    return t["[object " + e + "Array]"] = true, t;
  }, {}), Nc = Object.prototype.toString, $m = Array.prototype, dK = $m.forEach, pK = $m.filter, HS = $m.slice, vK = $m.map, wM = (function() {
  }).constructor, fp = wM ? wM.prototype : null, US = "__proto__", gK = 2311;
  function AF() {
    return gK++;
  }
  function YS() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    typeof console < "u" && console.error.apply(console, t);
  }
  function Oe(t) {
    if (t == null || typeof t != "object") return t;
    var e = t, r = Nc.call(t);
    if (r === "[object Array]") {
      if (!mf(t)) {
        e = [];
        for (var n = 0, i = t.length; n < i; n++) e[n] = Oe(t[n]);
      }
    } else if (CF[r]) {
      if (!mf(t)) {
        var a = t.constructor;
        if (a.from) e = a.from(t);
        else {
          e = new a(t.length);
          for (var n = 0, i = t.length; n < i; n++) e[n] = t[n];
        }
      }
    } else if (!TF[r] && !mf(t) && !gc(t)) {
      e = {};
      for (var o in t) t.hasOwnProperty(o) && o !== US && (e[o] = Oe(t[o]));
    }
    return e;
  }
  function je(t, e, r) {
    if (!Le(e) || !Le(t)) return r ? Oe(e) : t;
    for (var n in e) if (e.hasOwnProperty(n) && n !== US) {
      var i = t[n], a = e[n];
      Le(a) && Le(i) && !ae(a) && !ae(i) && !gc(a) && !gc(i) && !SM(a) && !SM(i) && !mf(a) && !mf(i) ? je(i, a, r) : (r || !(n in t)) && (t[n] = Oe(e[n]));
    }
    return t;
  }
  function qS(t, e) {
    for (var r = t[0], n = 1, i = t.length; n < i; n++) r = je(r, t[n], e);
    return r;
  }
  function te(t, e) {
    if (Object.assign) Object.assign(t, e);
    else for (var r in e) e.hasOwnProperty(r) && r !== US && (t[r] = e[r]);
    return t;
  }
  function Ee(t, e, r) {
    for (var n = gt(e), i = 0, a = n.length; i < a; i++) {
      var o = n[i];
      (r ? e[o] != null : t[o] == null) && (t[o] = e[o]);
    }
    return t;
  }
  function et(t, e) {
    if (t) {
      if (t.indexOf) return t.indexOf(e);
      for (var r = 0, n = t.length; r < n; r++) if (t[r] === e) return r;
    }
    return -1;
  }
  function mK(t, e) {
    var r = t.prototype;
    function n() {
    }
    n.prototype = e.prototype, t.prototype = new n();
    for (var i in r) r.hasOwnProperty(i) && (t.prototype[i] = r[i]);
    t.prototype.constructor = t, t.superClass = e;
  }
  function yr(t, e, r) {
    if (t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames) for (var n = Object.getOwnPropertyNames(e), i = 0; i < n.length; i++) {
      var a = n[i];
      a !== "constructor" && (r ? e[a] != null : t[a] == null) && (t[a] = e[a]);
    }
    else Ee(t, e, r);
  }
  function on(t) {
    return !t || typeof t == "string" ? false : typeof t.length == "number";
  }
  function $(t, e, r) {
    if (t && e) if (t.forEach && t.forEach === dK) t.forEach(e, r);
    else if (t.length === +t.length) for (var n = 0, i = t.length; n < i; n++) e.call(r, t[n], n, t);
    else for (var a in t) t.hasOwnProperty(a) && e.call(r, t[a], a, t);
  }
  function oe(t, e, r) {
    if (!t) return [];
    if (!e) return XS(t);
    if (t.map && t.map === vK) return t.map(e, r);
    for (var n = [], i = 0, a = t.length; i < a; i++) n.push(e.call(r, t[i], i, t));
    return n;
  }
  function ka(t, e, r, n) {
    if (t && e) {
      for (var i = 0, a = t.length; i < a; i++) r = e.call(n, r, t[i], i, t);
      return r;
    }
  }
  function Dt(t, e, r) {
    if (!t) return [];
    if (!e) return XS(t);
    if (t.filter && t.filter === pK) return t.filter(e, r);
    for (var n = [], i = 0, a = t.length; i < a; i++) e.call(r, t[i], i, t) && n.push(t[i]);
    return n;
  }
  function yK(t, e, r) {
    if (t && e) {
      for (var n = 0, i = t.length; n < i; n++) if (e.call(r, t[n], n, t)) return t[n];
    }
  }
  function gt(t) {
    if (!t) return [];
    if (Object.keys) return Object.keys(t);
    var e = [];
    for (var r in t) t.hasOwnProperty(r) && e.push(r);
    return e;
  }
  function _K(t, e) {
    for (var r = [], n = 2; n < arguments.length; n++) r[n - 2] = arguments[n];
    return function() {
      return t.apply(e, r.concat(HS.call(arguments)));
    };
  }
  var _e = fp && De(fp.bind) ? fp.call.bind(fp.bind) : _K;
  function Ye(t) {
    for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
    return function() {
      return t.apply(this, e.concat(HS.call(arguments)));
    };
  }
  function ae(t) {
    return Array.isArray ? Array.isArray(t) : Nc.call(t) === "[object Array]";
  }
  function De(t) {
    return typeof t == "function";
  }
  function me(t) {
    return typeof t == "string";
  }
  function ex(t) {
    return Nc.call(t) === "[object String]";
  }
  function xt(t) {
    return typeof t == "number";
  }
  function Le(t) {
    var e = typeof t;
    return e === "function" || !!t && e === "object";
  }
  function SM(t) {
    return !!TF[Nc.call(t)];
  }
  function $n(t) {
    return !!CF[Nc.call(t)];
  }
  function gc(t) {
    return typeof t == "object" && typeof t.nodeType == "number" && typeof t.ownerDocument == "object";
  }
  function Rm(t) {
    return t.colorStops != null;
  }
  function bK(t) {
    return t.image != null;
  }
  function xK(t) {
    return Nc.call(t) === "[object RegExp]";
  }
  function Ff(t) {
    return t !== t;
  }
  function Fr() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    for (var r = 0, n = t.length; r < n; r++) if (t[r] != null) return t[r];
  }
  function We(t, e) {
    return t ?? e;
  }
  function Aa(t, e, r) {
    return t ?? e ?? r;
  }
  function XS(t) {
    for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
    return HS.apply(t, e);
  }
  function jS(t) {
    if (typeof t == "number") return [
      t,
      t,
      t,
      t
    ];
    var e = t.length;
    return e === 2 ? [
      t[0],
      t[1],
      t[0],
      t[1]
    ] : e === 3 ? [
      t[0],
      t[1],
      t[2],
      t[1]
    ] : t;
  }
  function bn(t, e) {
    if (!t) throw new Error(e);
  }
  function Vi(t) {
    return t == null ? null : typeof t.trim == "function" ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
  var IF = "__ec_primitive__";
  function wg(t) {
    t[IF] = true;
  }
  function mf(t) {
    return t[IF];
  }
  var wK = function() {
    function t() {
      this.data = {};
    }
    return t.prototype.delete = function(e) {
      var r = this.has(e);
      return r && delete this.data[e], r;
    }, t.prototype.has = function(e) {
      return this.data.hasOwnProperty(e);
    }, t.prototype.get = function(e) {
      return this.data[e];
    }, t.prototype.set = function(e, r) {
      return this.data[e] = r, this;
    }, t.prototype.keys = function() {
      return gt(this.data);
    }, t.prototype.forEach = function(e) {
      var r = this.data;
      for (var n in r) r.hasOwnProperty(n) && e(r[n], n);
    }, t;
  }(), MF = typeof Map == "function";
  function SK() {
    return MF ? /* @__PURE__ */ new Map() : new wK();
  }
  var TK = function() {
    function t(e) {
      var r = ae(e);
      this.data = SK();
      var n = this;
      e instanceof t ? e.each(i) : e && $(e, i);
      function i(a, o) {
        r ? n.set(a, o) : n.set(o, a);
      }
    }
    return t.prototype.hasKey = function(e) {
      return this.data.has(e);
    }, t.prototype.get = function(e) {
      return this.data.get(e);
    }, t.prototype.set = function(e, r) {
      return this.data.set(e, r), r;
    }, t.prototype.each = function(e, r) {
      this.data.forEach(function(n, i) {
        e.call(r, n, i);
      });
    }, t.prototype.keys = function() {
      var e = this.data.keys();
      return MF ? Array.from(e) : e;
    }, t.prototype.removeKey = function(e) {
      this.data.delete(e);
    }, t;
  }();
  function Ce(t) {
    return new TK(t);
  }
  function Vf(t, e) {
    for (var r = new t.constructor(t.length + e.length), n = 0; n < t.length; n++) r[n] = t[n];
    for (var i = t.length, n = 0; n < e.length; n++) r[n + i] = e[n];
    return r;
  }
  function Om(t, e) {
    var r;
    if (Object.create) r = Object.create(t);
    else {
      var n = function() {
      };
      n.prototype = t, r = new n();
    }
    return e && te(r, e), r;
  }
  function DF(t) {
    var e = t.style;
    e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none";
  }
  function xe(t, e) {
    return t.hasOwnProperty(e);
  }
  function dr() {
  }
  var Xv = 180 / Math.PI;
  function ru(t, e) {
    return t == null && (t = 0), e == null && (e = 0), [
      t,
      e
    ];
  }
  function fn(t, e) {
    return t[0] = e[0], t[1] = e[1], t;
  }
  function no(t) {
    return [
      t[0],
      t[1]
    ];
  }
  function CK(t, e, r) {
    return t[0] = e, t[1] = r, t;
  }
  function TM(t, e, r) {
    return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t;
  }
  function tx(t, e, r, n) {
    return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t;
  }
  function wl(t, e, r) {
    return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t;
  }
  function rx(t) {
    return Math.sqrt(AK(t));
  }
  function AK(t) {
    return t[0] * t[0] + t[1] * t[1];
  }
  function jv(t, e, r) {
    return t[0] = e[0] * r, t[1] = e[1] * r, t;
  }
  function Bc(t, e) {
    var r = rx(e);
    return r === 0 ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / r, t[1] = e[1] / r), t;
  }
  function nx(t, e) {
    return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]));
  }
  var jo = nx;
  function IK(t, e) {
    return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]);
  }
  var Ll = IK;
  function Kv(t, e, r, n) {
    return t[0] = e[0] + n * (r[0] - e[0]), t[1] = e[1] + n * (r[1] - e[1]), t;
  }
  function Ur(t, e, r) {
    var n = e[0], i = e[1];
    return t[0] = r[0] * n + r[2] * i + r[4], t[1] = r[1] * n + r[3] * i + r[5], t;
  }
  function Ko(t, e, r) {
    return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t;
  }
  function Zo(t, e, r) {
    return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t;
  }
  var mu = /* @__PURE__ */ function() {
    function t(e, r) {
      this.target = e, this.topTarget = r && r.topTarget;
    }
    return t;
  }(), MK = function() {
    function t(e) {
      this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this);
    }
    return t.prototype._dragStart = function(e) {
      for (var r = e.target; r && !r.draggable; ) r = r.parent || r.__hostTarget;
      r && (this._draggingTarget = r, r.dragging = true, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new mu(r, e), "dragstart", e.event));
    }, t.prototype._drag = function(e) {
      var r = this._draggingTarget;
      if (r) {
        var n = e.offsetX, i = e.offsetY, a = n - this._x, o = i - this._y;
        this._x = n, this._y = i, r.drift(a, o, e), this.handler.dispatchToElement(new mu(r, e), "drag", e.event);
        var s = this.handler.findHover(n, i, r).target, l = this._dropTarget;
        this._dropTarget = s, r !== s && (l && s !== l && this.handler.dispatchToElement(new mu(l, e), "dragleave", e.event), s && s !== l && this.handler.dispatchToElement(new mu(s, e), "dragenter", e.event));
      }
    }, t.prototype._dragEnd = function(e) {
      var r = this._draggingTarget;
      r && (r.dragging = false), this.handler.dispatchToElement(new mu(r, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new mu(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null;
    }, t;
  }(), xi = function() {
    function t(e) {
      e && (this._$eventProcessor = e);
    }
    return t.prototype.on = function(e, r, n, i) {
      this._$handlers || (this._$handlers = {});
      var a = this._$handlers;
      if (typeof r == "function" && (i = n, n = r, r = null), !n || !e) return this;
      var o = this._$eventProcessor;
      r != null && o && o.normalizeQuery && (r = o.normalizeQuery(r)), a[e] || (a[e] = []);
      for (var s = 0; s < a[e].length; s++) if (a[e][s].h === n) return this;
      var l = {
        h: n,
        query: r,
        ctx: i || this,
        callAtLast: n.zrEventfulCallAtLast
      }, u = a[e].length - 1, c = a[e][u];
      return c && c.callAtLast ? a[e].splice(u, 0, l) : a[e].push(l), this;
    }, t.prototype.isSilent = function(e) {
      var r = this._$handlers;
      return !r || !r[e] || !r[e].length;
    }, t.prototype.off = function(e, r) {
      var n = this._$handlers;
      if (!n) return this;
      if (!e) return this._$handlers = {}, this;
      if (r) {
        if (n[e]) {
          for (var i = [], a = 0, o = n[e].length; a < o; a++) n[e][a].h !== r && i.push(n[e][a]);
          n[e] = i;
        }
        n[e] && n[e].length === 0 && delete n[e];
      } else delete n[e];
      return this;
    }, t.prototype.trigger = function(e) {
      for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n];
      if (!this._$handlers) return this;
      var i = this._$handlers[e], a = this._$eventProcessor;
      if (i) for (var o = r.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(a && a.filter && u.query != null && !a.filter(e, u.query))) switch (o) {
          case 0:
            u.h.call(u.ctx);
            break;
          case 1:
            u.h.call(u.ctx, r[0]);
            break;
          case 2:
            u.h.call(u.ctx, r[0], r[1]);
            break;
          default:
            u.h.apply(u.ctx, r);
            break;
        }
      }
      return a && a.afterTrigger && a.afterTrigger(e), this;
    }, t.prototype.triggerWithContext = function(e) {
      for (var r = [], n = 1; n < arguments.length; n++) r[n - 1] = arguments[n];
      if (!this._$handlers) return this;
      var i = this._$handlers[e], a = this._$eventProcessor;
      if (i) for (var o = r.length, s = r[o - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(a && a.filter && c.query != null && !a.filter(e, c.query))) switch (o) {
          case 0:
            c.h.call(s);
            break;
          case 1:
            c.h.call(s, r[0]);
            break;
          case 2:
            c.h.call(s, r[0], r[1]);
            break;
          default:
            c.h.apply(s, r.slice(1, o - 1));
            break;
        }
      }
      return a && a.afterTrigger && a.afterTrigger(e), this;
    }, t;
  }(), DK = Math.log(2);
  function ix(t, e, r, n, i, a) {
    var o = n + "-" + i, s = t.length;
    if (a.hasOwnProperty(o)) return a[o];
    if (e === 1) {
      var l = Math.round(Math.log((1 << s) - 1 & ~i) / DK);
      return t[r][l];
    }
    for (var u = n | 1 << r, c = r + 1; n & 1 << c; ) c++;
    for (var h = 0, f = 0, d = 0; f < s; f++) {
      var p = 1 << f;
      p & i || (h += (d % 2 ? -1 : 1) * t[r][f] * ix(t, e - 1, c, u, i | p, a), d++);
    }
    return a[o] = h, h;
  }
  function CM(t, e) {
    var r = [
      [
        t[0],
        t[1],
        1,
        0,
        0,
        0,
        -e[0] * t[0],
        -e[0] * t[1]
      ],
      [
        0,
        0,
        0,
        t[0],
        t[1],
        1,
        -e[1] * t[0],
        -e[1] * t[1]
      ],
      [
        t[2],
        t[3],
        1,
        0,
        0,
        0,
        -e[2] * t[2],
        -e[2] * t[3]
      ],
      [
        0,
        0,
        0,
        t[2],
        t[3],
        1,
        -e[3] * t[2],
        -e[3] * t[3]
      ],
      [
        t[4],
        t[5],
        1,
        0,
        0,
        0,
        -e[4] * t[4],
        -e[4] * t[5]
      ],
      [
        0,
        0,
        0,
        t[4],
        t[5],
        1,
        -e[5] * t[4],
        -e[5] * t[5]
      ],
      [
        t[6],
        t[7],
        1,
        0,
        0,
        0,
        -e[6] * t[6],
        -e[6] * t[7]
      ],
      [
        0,
        0,
        0,
        t[6],
        t[7],
        1,
        -e[7] * t[6],
        -e[7] * t[7]
      ]
    ], n = {}, i = ix(r, 8, 0, 0, 0, n);
    if (i !== 0) {
      for (var a = [], o = 0; o < 8; o++) for (var s = 0; s < 8; s++) a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * ix(r, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, n) / i * e[o];
      return function(l, u, c) {
        var h = u * a[6] + c * a[7] + 1;
        l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
      };
    }
  }
  var AM = "___zrEVENTSAVED", qy = [];
  function EK(t, e, r, n, i) {
    return ax(qy, e, n, i, true) && ax(t, r, qy[0], qy[1]);
  }
  function ax(t, e, r, n, i) {
    if (e.getBoundingClientRect && ct.domSupported && !EF(e)) {
      var a = e[AM] || (e[AM] = {}), o = kK(e, a), s = PK(o, a, i);
      if (s) return s(t, r, n), true;
    }
    return false;
  }
  function kK(t, e) {
    var r = e.markers;
    if (r) return r;
    r = e.markers = [];
    for (var n = [
      "left",
      "right"
    ], i = [
      "top",
      "bottom"
    ], a = 0; a < 4; a++) {
      var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
      s.cssText = [
        "position: absolute",
        "visibility: hidden",
        "padding: 0",
        "margin: 0",
        "border-width: 0",
        "user-select: none",
        "width:0",
        "height:0",
        n[l] + ":0",
        i[u] + ":0",
        n[1 - l] + ":auto",
        i[1 - u] + ":auto",
        ""
      ].join("!important;"), t.appendChild(o), r.push(o);
    }
    return r;
  }
  function PK(t, e, r) {
    for (var n = r ? "invTrans" : "trans", i = e[n], a = e.srcCoords, o = [], s = [], l = true, u = 0; u < 4; u++) {
      var c = t[u].getBoundingClientRect(), h = 2 * u, f = c.left, d = c.top;
      o.push(f, d), l = l && a && f === a[h] && d === a[h + 1], s.push(t[u].offsetLeft, t[u].offsetTop);
    }
    return l && i ? i : (e.srcCoords = o, e[n] = r ? CM(s, o) : CM(o, s));
  }
  function EF(t) {
    return t.nodeName.toUpperCase() === "CANVAS";
  }
  var LK = /([&<>"'])/g, $K = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function vn(t) {
    return t == null ? "" : (t + "").replace(LK, function(e, r) {
      return $K[r];
    });
  }
  var RK = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Xy = [], OK = ct.browser.firefox && +ct.browser.version.split(".")[0] < 39;
  function ox(t, e, r, n) {
    return r = r || {}, n ? IM(t, e, r) : OK && e.layerX != null && e.layerX !== e.offsetX ? (r.zrX = e.layerX, r.zrY = e.layerY) : e.offsetX != null ? (r.zrX = e.offsetX, r.zrY = e.offsetY) : IM(t, e, r), r;
  }
  function IM(t, e, r) {
    if (ct.domSupported && t.getBoundingClientRect) {
      var n = e.clientX, i = e.clientY;
      if (EF(t)) {
        var a = t.getBoundingClientRect();
        r.zrX = n - a.left, r.zrY = i - a.top;
        return;
      } else if (ax(Xy, t, n, i)) {
        r.zrX = Xy[0], r.zrY = Xy[1];
        return;
      }
    }
    r.zrX = r.zrY = 0;
  }
  function KS(t) {
    return t || window.event;
  }
  function si(t, e, r) {
    if (e = KS(e), e.zrX != null) return e;
    var n = e.type, i = n && n.indexOf("touch") >= 0;
    if (i) {
      var o = n !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
      o && ox(t, o, e, r);
    } else {
      ox(t, e, e, r);
      var a = NK(e);
      e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3;
    }
    var s = e.button;
    return e.which == null && s !== void 0 && RK.test(e.type) && (e.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), e;
  }
  function NK(t) {
    var e = t.wheelDelta;
    if (e) return e;
    var r = t.deltaX, n = t.deltaY;
    if (r == null || n == null) return e;
    var i = Math.abs(n !== 0 ? n : r), a = n > 0 ? -1 : n < 0 ? 1 : r > 0 ? -1 : 1;
    return 3 * i * a;
  }
  function sx(t, e, r, n) {
    t.addEventListener(e, r, n);
  }
  function BK(t, e, r, n) {
    t.removeEventListener(e, r, n);
  }
  var co = function(t) {
    t.preventDefault(), t.stopPropagation(), t.cancelBubble = true;
  };
  function MM(t) {
    return t.which === 2 || t.which === 3;
  }
  var zK = function() {
    function t() {
      this._track = [];
    }
    return t.prototype.recognize = function(e, r, n) {
      return this._doTrack(e, r, n), this._recognize(e);
    }, t.prototype.clear = function() {
      return this._track.length = 0, this;
    }, t.prototype._doTrack = function(e, r, n) {
      var i = e.touches;
      if (i) {
        for (var a = {
          points: [],
          touches: [],
          target: r,
          event: e
        }, o = 0, s = i.length; o < s; o++) {
          var l = i[o], u = ox(n, l, {});
          a.points.push([
            u.zrX,
            u.zrY
          ]), a.touches.push(l);
        }
        this._track.push(a);
      }
    }, t.prototype._recognize = function(e) {
      for (var r in jy) if (jy.hasOwnProperty(r)) {
        var n = jy[r](this._track, e);
        if (n) return n;
      }
    }, t;
  }();
  function DM(t) {
    var e = t[1][0] - t[0][0], r = t[1][1] - t[0][1];
    return Math.sqrt(e * e + r * r);
  }
  function FK(t) {
    return [
      (t[0][0] + t[1][0]) / 2,
      (t[0][1] + t[1][1]) / 2
    ];
  }
  var jy = {
    pinch: function(t, e) {
      var r = t.length;
      if (r) {
        var n = (t[r - 1] || {}).points, i = (t[r - 2] || {}).points || n;
        if (i && i.length > 1 && n && n.length > 1) {
          var a = DM(n) / DM(i);
          !isFinite(a) && (a = 1), e.pinchScale = a;
          var o = FK(n);
          return e.pinchX = o[0], e.pinchY = o[1], {
            type: "pinch",
            target: t[0].target,
            event: e
          };
        }
      }
    }
  };
  function Hn() {
    return [
      1,
      0,
      0,
      1,
      0,
      0
    ];
  }
  function Nm(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
  }
  function ZS(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
  }
  function io(t, e, r) {
    var n = e[0] * r[0] + e[2] * r[1], i = e[1] * r[0] + e[3] * r[1], a = e[0] * r[2] + e[2] * r[3], o = e[1] * r[2] + e[3] * r[3], s = e[0] * r[4] + e[2] * r[5] + e[4], l = e[1] * r[4] + e[3] * r[5] + e[5];
    return t[0] = n, t[1] = i, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t;
  }
  function Pa(t, e, r) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + r[0], t[5] = e[5] + r[1], t;
  }
  function nu(t, e, r, n) {
    n === void 0 && (n = [
      0,
      0
    ]);
    var i = e[0], a = e[2], o = e[4], s = e[1], l = e[3], u = e[5], c = Math.sin(r), h = Math.cos(r);
    return t[0] = i * h + s * c, t[1] = -i * c + s * h, t[2] = a * h + l * c, t[3] = -a * c + h * l, t[4] = h * (o - n[0]) + c * (u - n[1]) + n[0], t[5] = h * (u - n[1]) - c * (o - n[0]) + n[1], t;
  }
  function QS(t, e, r) {
    var n = r[0], i = r[1];
    return t[0] = e[0] * n, t[1] = e[1] * i, t[2] = e[2] * n, t[3] = e[3] * i, t[4] = e[4] * n, t[5] = e[5] * i, t;
  }
  function zc(t, e) {
    var r = e[0], n = e[2], i = e[4], a = e[1], o = e[3], s = e[5], l = r * o - a * n;
    return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = r * l, t[4] = (n * s - o * i) * l, t[5] = (a * i - r * s) * l, t) : null;
  }
  function VK(t) {
    var e = Hn();
    return ZS(e, t), e;
  }
  var Ke = function() {
    function t(e, r) {
      this.x = e || 0, this.y = r || 0;
    }
    return t.prototype.copy = function(e) {
      return this.x = e.x, this.y = e.y, this;
    }, t.prototype.clone = function() {
      return new t(this.x, this.y);
    }, t.prototype.set = function(e, r) {
      return this.x = e, this.y = r, this;
    }, t.prototype.equal = function(e) {
      return e.x === this.x && e.y === this.y;
    }, t.prototype.add = function(e) {
      return this.x += e.x, this.y += e.y, this;
    }, t.prototype.scale = function(e) {
      this.x *= e, this.y *= e;
    }, t.prototype.scaleAndAdd = function(e, r) {
      this.x += e.x * r, this.y += e.y * r;
    }, t.prototype.sub = function(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }, t.prototype.dot = function(e) {
      return this.x * e.x + this.y * e.y;
    }, t.prototype.len = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }, t.prototype.lenSquare = function() {
      return this.x * this.x + this.y * this.y;
    }, t.prototype.normalize = function() {
      var e = this.len();
      return this.x /= e, this.y /= e, this;
    }, t.prototype.distance = function(e) {
      var r = this.x - e.x, n = this.y - e.y;
      return Math.sqrt(r * r + n * n);
    }, t.prototype.distanceSquare = function(e) {
      var r = this.x - e.x, n = this.y - e.y;
      return r * r + n * n;
    }, t.prototype.negate = function() {
      return this.x = -this.x, this.y = -this.y, this;
    }, t.prototype.transform = function(e) {
      if (e) {
        var r = this.x, n = this.y;
        return this.x = e[0] * r + e[2] * n + e[4], this.y = e[1] * r + e[3] * n + e[5], this;
      }
    }, t.prototype.toArray = function(e) {
      return e[0] = this.x, e[1] = this.y, e;
    }, t.prototype.fromArray = function(e) {
      this.x = e[0], this.y = e[1];
    }, t.set = function(e, r, n) {
      e.x = r, e.y = n;
    }, t.copy = function(e, r) {
      e.x = r.x, e.y = r.y;
    }, t.len = function(e) {
      return Math.sqrt(e.x * e.x + e.y * e.y);
    }, t.lenSquare = function(e) {
      return e.x * e.x + e.y * e.y;
    }, t.dot = function(e, r) {
      return e.x * r.x + e.y * r.y;
    }, t.add = function(e, r, n) {
      e.x = r.x + n.x, e.y = r.y + n.y;
    }, t.sub = function(e, r, n) {
      e.x = r.x - n.x, e.y = r.y - n.y;
    }, t.scale = function(e, r, n) {
      e.x = r.x * n, e.y = r.y * n;
    }, t.scaleAndAdd = function(e, r, n, i) {
      e.x = r.x + n.x * i, e.y = r.y + n.y * i;
    }, t.lerp = function(e, r, n, i) {
      var a = 1 - i;
      e.x = a * r.x + i * n.x, e.y = a * r.y + i * n.y;
    }, t;
  }(), dp = Math.min, pp = Math.max, Is = new Ke(), Ms = new Ke(), Ds = new Ke(), Es = new Ke(), ah = new Ke(), oh = new Ke(), Ze = function() {
    function t(e, r, n, i) {
      n < 0 && (e = e + n, n = -n), i < 0 && (r = r + i, i = -i), this.x = e, this.y = r, this.width = n, this.height = i;
    }
    return t.prototype.union = function(e) {
      var r = dp(e.x, this.x), n = dp(e.y, this.y);
      isFinite(this.x) && isFinite(this.width) ? this.width = pp(e.x + e.width, this.x + this.width) - r : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = pp(e.y + e.height, this.y + this.height) - n : this.height = e.height, this.x = r, this.y = n;
    }, t.prototype.applyTransform = function(e) {
      t.applyTransform(this, this, e);
    }, t.prototype.calculateTransform = function(e) {
      var r = this, n = e.width / r.width, i = e.height / r.height, a = Hn();
      return Pa(a, a, [
        -r.x,
        -r.y
      ]), QS(a, a, [
        n,
        i
      ]), Pa(a, a, [
        e.x,
        e.y
      ]), a;
    }, t.prototype.intersect = function(e, r) {
      if (!e) return false;
      e instanceof t || (e = t.create(e));
      var n = this, i = n.x, a = n.x + n.width, o = n.y, s = n.y + n.height, l = e.x, u = e.x + e.width, c = e.y, h = e.y + e.height, f = !(a < l || u < i || s < c || h < o);
      if (r) {
        var d = 1 / 0, p = 0, v = Math.abs(a - l), g = Math.abs(u - i), m = Math.abs(s - c), y = Math.abs(h - o), _ = Math.min(v, g), b = Math.min(m, y);
        a < l || u < i ? _ > p && (p = _, v < g ? Ke.set(oh, -v, 0) : Ke.set(oh, g, 0)) : _ < d && (d = _, v < g ? Ke.set(ah, v, 0) : Ke.set(ah, -g, 0)), s < c || h < o ? b > p && (p = b, m < y ? Ke.set(oh, 0, -m) : Ke.set(oh, 0, y)) : _ < d && (d = _, m < y ? Ke.set(ah, 0, m) : Ke.set(ah, 0, -y));
      }
      return r && Ke.copy(r, f ? ah : oh), f;
    }, t.prototype.contain = function(e, r) {
      var n = this;
      return e >= n.x && e <= n.x + n.width && r >= n.y && r <= n.y + n.height;
    }, t.prototype.clone = function() {
      return new t(this.x, this.y, this.width, this.height);
    }, t.prototype.copy = function(e) {
      t.copy(this, e);
    }, t.prototype.plain = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    }, t.prototype.isFinite = function() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    }, t.prototype.isZero = function() {
      return this.width === 0 || this.height === 0;
    }, t.create = function(e) {
      return new t(e.x, e.y, e.width, e.height);
    }, t.copy = function(e, r) {
      e.x = r.x, e.y = r.y, e.width = r.width, e.height = r.height;
    }, t.applyTransform = function(e, r, n) {
      if (!n) {
        e !== r && t.copy(e, r);
        return;
      }
      if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
        var i = n[0], a = n[3], o = n[4], s = n[5];
        e.x = r.x * i + o, e.y = r.y * a + s, e.width = r.width * i, e.height = r.height * a, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
        return;
      }
      Is.x = Ds.x = r.x, Is.y = Es.y = r.y, Ms.x = Es.x = r.x + r.width, Ms.y = Ds.y = r.y + r.height, Is.transform(n), Es.transform(n), Ms.transform(n), Ds.transform(n), e.x = dp(Is.x, Ms.x, Ds.x, Es.x), e.y = dp(Is.y, Ms.y, Ds.y, Es.y);
      var l = pp(Is.x, Ms.x, Ds.x, Es.x), u = pp(Is.y, Ms.y, Ds.y, Es.y);
      e.width = l - e.x, e.height = u - e.y;
    }, t;
  }(), kF = "silent";
  function GK(t, e, r) {
    return {
      type: t,
      event: r,
      target: e.target,
      topTarget: e.topTarget,
      cancelBubble: false,
      offsetX: r.zrX,
      offsetY: r.zrY,
      gestureEvent: r.gestureEvent,
      pinchX: r.pinchX,
      pinchY: r.pinchY,
      pinchScale: r.pinchScale,
      wheelDelta: r.zrDelta,
      zrByTouch: r.zrByTouch,
      which: r.which,
      stop: WK
    };
  }
  function WK() {
    co(this.event);
  }
  var HK = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.handler = null, r;
    }
    return e.prototype.dispose = function() {
    }, e.prototype.setCursor = function() {
    }, e;
  }(xi), sh = /* @__PURE__ */ function() {
    function t(e, r) {
      this.x = e, this.y = r;
    }
    return t;
  }(), UK = [
    "click",
    "dblclick",
    "mousewheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], Ky = new Ze(0, 0, 0, 0), PF = function(t) {
    K(e, t);
    function e(r, n, i, a, o) {
      var s = t.call(this) || this;
      return s._hovered = new sh(0, 0), s.storage = r, s.painter = n, s.painterRoot = a, s._pointerSize = o, i = i || new HK(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new MK(s), s;
    }
    return e.prototype.setHandlerProxy = function(r) {
      this.proxy && this.proxy.dispose(), r && ($(UK, function(n) {
        r.on && r.on(n, this[n], this);
      }, this), r.handler = this), this.proxy = r;
    }, e.prototype.mousemove = function(r) {
      var n = r.zrX, i = r.zrY, a = LF(this, n, i), o = this._hovered, s = o.target;
      s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
      var l = this._hovered = a ? new sh(n, i) : this.findHover(n, i), u = l.target, c = this.proxy;
      c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", r), this.dispatchToElement(l, "mousemove", r), u && u !== s && this.dispatchToElement(l, "mouseover", r);
    }, e.prototype.mouseout = function(r) {
      var n = r.zrEventControl;
      n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", r), n !== "no_globalout" && this.trigger("globalout", {
        type: "globalout",
        event: r
      });
    }, e.prototype.resize = function() {
      this._hovered = new sh(0, 0);
    }, e.prototype.dispatch = function(r, n) {
      var i = this[r];
      i && i.call(this, n);
    }, e.prototype.dispose = function() {
      this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
    }, e.prototype.setCursorStyle = function(r) {
      var n = this.proxy;
      n.setCursor && n.setCursor(r);
    }, e.prototype.dispatchToElement = function(r, n, i) {
      r = r || {};
      var a = r.target;
      if (!(a && a.silent)) {
        for (var o = "on" + n, s = GK(n, r, i); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(n, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); ) ;
        s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
          typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(n, s);
        }));
      }
    }, e.prototype.findHover = function(r, n, i) {
      var a = this.storage.getDisplayList(), o = new sh(r, n);
      if (EM(a, o, r, n, i), this._pointerSize && !o.target) {
        for (var s = [], l = this._pointerSize, u = l / 2, c = new Ze(r - u, n - u, l, l), h = a.length - 1; h >= 0; h--) {
          var f = a[h];
          f !== i && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (Ky.copy(f.getBoundingRect()), f.transform && Ky.applyTransform(f.transform), Ky.intersect(c) && s.push(f));
        }
        if (s.length) for (var d = 4, p = Math.PI / 12, v = Math.PI * 2, g = 0; g < u; g += d) for (var m = 0; m < v; m += p) {
          var y = r + g * Math.cos(m), _ = n + g * Math.sin(m);
          if (EM(s, o, y, _, i), o.target) return o;
        }
      }
      return o;
    }, e.prototype.processGesture = function(r, n) {
      this._gestureMgr || (this._gestureMgr = new zK());
      var i = this._gestureMgr;
      n === "start" && i.clear();
      var a = i.recognize(r, this.findHover(r.zrX, r.zrY, null).target, this.proxy.dom);
      if (n === "end" && i.clear(), a) {
        var o = a.type;
        r.gestureEvent = o;
        var s = new sh();
        s.target = a.target, this.dispatchToElement(s, o, a.event);
      }
    }, e;
  }(xi);
  $([
    "click",
    "mousedown",
    "mouseup",
    "mousewheel",
    "dblclick",
    "contextmenu"
  ], function(t) {
    PF.prototype[t] = function(e) {
      var r = e.zrX, n = e.zrY, i = LF(this, r, n), a, o;
      if ((t !== "mouseup" || !i) && (a = this.findHover(r, n), o = a.target), t === "mousedown") this._downEl = o, this._downPoint = [
        e.zrX,
        e.zrY
      ], this._upEl = o;
      else if (t === "mouseup") this._upEl = o;
      else if (t === "click") {
        if (this._downEl !== this._upEl || !this._downPoint || jo(this._downPoint, [
          e.zrX,
          e.zrY
        ]) > 4) return;
        this._downPoint = null;
      }
      this.dispatchToElement(a, t, e);
    };
  });
  function YK(t, e, r) {
    if (t[t.rectHover ? "rectContain" : "contain"](e, r)) {
      for (var n = t, i = void 0, a = false; n; ) {
        if (n.ignoreClip && (a = true), !a) {
          var o = n.getClipPath();
          if (o && !o.contain(e, r)) return false;
        }
        n.silent && (i = true);
        var s = n.__hostTarget;
        n = s || n.parent;
      }
      return i ? kF : true;
    }
    return false;
  }
  function EM(t, e, r, n, i) {
    for (var a = t.length - 1; a >= 0; a--) {
      var o = t[a], s = void 0;
      if (o !== i && !o.ignore && (s = YK(o, r, n)) && (!e.topTarget && (e.topTarget = o), s !== kF)) {
        e.target = o;
        break;
      }
    }
  }
  function LF(t, e, r) {
    var n = t.painter;
    return e < 0 || e > n.getWidth() || r < 0 || r > n.getHeight();
  }
  var $F = 32, lh = 7;
  function qK(t) {
    for (var e = 0; t >= $F; ) e |= t & 1, t >>= 1;
    return t + e;
  }
  function kM(t, e, r, n) {
    var i = e + 1;
    if (i === r) return 1;
    if (n(t[i++], t[e]) < 0) {
      for (; i < r && n(t[i], t[i - 1]) < 0; ) i++;
      XK(t, e, i);
    } else for (; i < r && n(t[i], t[i - 1]) >= 0; ) i++;
    return i - e;
  }
  function XK(t, e, r) {
    for (r--; e < r; ) {
      var n = t[e];
      t[e++] = t[r], t[r--] = n;
    }
  }
  function PM(t, e, r, n, i) {
    for (n === e && n++; n < r; n++) {
      for (var a = t[n], o = e, s = n, l; o < s; ) l = o + s >>> 1, i(a, t[l]) < 0 ? s = l : o = l + 1;
      var u = n - o;
      switch (u) {
        case 3:
          t[o + 3] = t[o + 2];
        case 2:
          t[o + 2] = t[o + 1];
        case 1:
          t[o + 1] = t[o];
          break;
        default:
          for (; u > 0; ) t[o + u] = t[o + u - 1], u--;
      }
      t[o] = a;
    }
  }
  function Zy(t, e, r, n, i, a) {
    var o = 0, s = 0, l = 1;
    if (a(t, e[r + i]) > 0) {
      for (s = n - i; l < s && a(t, e[r + i + l]) > 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
      l > s && (l = s), o += i, l += i;
    } else {
      for (s = i + 1; l < s && a(t, e[r + i - l]) <= 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
      l > s && (l = s);
      var u = o;
      o = i - l, l = i - u;
    }
    for (o++; o < l; ) {
      var c = o + (l - o >>> 1);
      a(t, e[r + c]) > 0 ? o = c + 1 : l = c;
    }
    return l;
  }
  function Qy(t, e, r, n, i, a) {
    var o = 0, s = 0, l = 1;
    if (a(t, e[r + i]) < 0) {
      for (s = i + 1; l < s && a(t, e[r + i - l]) < 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
      l > s && (l = s);
      var u = o;
      o = i - l, l = i - u;
    } else {
      for (s = n - i; l < s && a(t, e[r + i + l]) >= 0; ) o = l, l = (l << 1) + 1, l <= 0 && (l = s);
      l > s && (l = s), o += i, l += i;
    }
    for (o++; o < l; ) {
      var c = o + (l - o >>> 1);
      a(t, e[r + c]) < 0 ? l = c : o = c + 1;
    }
    return l;
  }
  function jK(t, e) {
    var r = lh, n, i, a = 0, o = [];
    n = [], i = [];
    function s(d, p) {
      n[a] = d, i[a] = p, a += 1;
    }
    function l() {
      for (; a > 1; ) {
        var d = a - 2;
        if (d >= 1 && i[d - 1] <= i[d] + i[d + 1] || d >= 2 && i[d - 2] <= i[d] + i[d - 1]) i[d - 1] < i[d + 1] && d--;
        else if (i[d] > i[d + 1]) break;
        c(d);
      }
    }
    function u() {
      for (; a > 1; ) {
        var d = a - 2;
        d > 0 && i[d - 1] < i[d + 1] && d--, c(d);
      }
    }
    function c(d) {
      var p = n[d], v = i[d], g = n[d + 1], m = i[d + 1];
      i[d] = v + m, d === a - 3 && (n[d + 1] = n[d + 2], i[d + 1] = i[d + 2]), a--;
      var y = Qy(t[g], t, p, v, 0, e);
      p += y, v -= y, v !== 0 && (m = Zy(t[p + v - 1], t, g, m, m - 1, e), m !== 0 && (v <= m ? h(p, v, g, m) : f(p, v, g, m)));
    }
    function h(d, p, v, g) {
      var m = 0;
      for (m = 0; m < p; m++) o[m] = t[d + m];
      var y = 0, _ = v, b = d;
      if (t[b++] = t[_++], --g === 0) {
        for (m = 0; m < p; m++) t[b + m] = o[y + m];
        return;
      }
      if (p === 1) {
        for (m = 0; m < g; m++) t[b + m] = t[_ + m];
        t[b + g] = o[y];
        return;
      }
      for (var w = r, x, T, A; ; ) {
        x = 0, T = 0, A = false;
        do
          if (e(t[_], o[y]) < 0) {
            if (t[b++] = t[_++], T++, x = 0, --g === 0) {
              A = true;
              break;
            }
          } else if (t[b++] = o[y++], x++, T = 0, --p === 1) {
            A = true;
            break;
          }
        while ((x | T) < w);
        if (A) break;
        do {
          if (x = Qy(t[_], o, y, p, 0, e), x !== 0) {
            for (m = 0; m < x; m++) t[b + m] = o[y + m];
            if (b += x, y += x, p -= x, p <= 1) {
              A = true;
              break;
            }
          }
          if (t[b++] = t[_++], --g === 0) {
            A = true;
            break;
          }
          if (T = Zy(o[y], t, _, g, 0, e), T !== 0) {
            for (m = 0; m < T; m++) t[b + m] = t[_ + m];
            if (b += T, _ += T, g -= T, g === 0) {
              A = true;
              break;
            }
          }
          if (t[b++] = o[y++], --p === 1) {
            A = true;
            break;
          }
          w--;
        } while (x >= lh || T >= lh);
        if (A) break;
        w < 0 && (w = 0), w += 2;
      }
      if (r = w, r < 1 && (r = 1), p === 1) {
        for (m = 0; m < g; m++) t[b + m] = t[_ + m];
        t[b + g] = o[y];
      } else {
        if (p === 0) throw new Error();
        for (m = 0; m < p; m++) t[b + m] = o[y + m];
      }
    }
    function f(d, p, v, g) {
      var m = 0;
      for (m = 0; m < g; m++) o[m] = t[v + m];
      var y = d + p - 1, _ = g - 1, b = v + g - 1, w = 0, x = 0;
      if (t[b--] = t[y--], --p === 0) {
        for (w = b - (g - 1), m = 0; m < g; m++) t[w + m] = o[m];
        return;
      }
      if (g === 1) {
        for (b -= p, y -= p, x = b + 1, w = y + 1, m = p - 1; m >= 0; m--) t[x + m] = t[w + m];
        t[b] = o[_];
        return;
      }
      for (var T = r; ; ) {
        var A = 0, I = 0, M = false;
        do
          if (e(o[_], t[y]) < 0) {
            if (t[b--] = t[y--], A++, I = 0, --p === 0) {
              M = true;
              break;
            }
          } else if (t[b--] = o[_--], I++, A = 0, --g === 1) {
            M = true;
            break;
          }
        while ((A | I) < T);
        if (M) break;
        do {
          if (A = p - Qy(o[_], t, d, p, p - 1, e), A !== 0) {
            for (b -= A, y -= A, p -= A, x = b + 1, w = y + 1, m = A - 1; m >= 0; m--) t[x + m] = t[w + m];
            if (p === 0) {
              M = true;
              break;
            }
          }
          if (t[b--] = o[_--], --g === 1) {
            M = true;
            break;
          }
          if (I = g - Zy(t[y], o, 0, g, g - 1, e), I !== 0) {
            for (b -= I, _ -= I, g -= I, x = b + 1, w = _ + 1, m = 0; m < I; m++) t[x + m] = o[w + m];
            if (g <= 1) {
              M = true;
              break;
            }
          }
          if (t[b--] = t[y--], --p === 0) {
            M = true;
            break;
          }
          T--;
        } while (A >= lh || I >= lh);
        if (M) break;
        T < 0 && (T = 0), T += 2;
      }
      if (r = T, r < 1 && (r = 1), g === 1) {
        for (b -= p, y -= p, x = b + 1, w = y + 1, m = p - 1; m >= 0; m--) t[x + m] = t[w + m];
        t[b] = o[_];
      } else {
        if (g === 0) throw new Error();
        for (w = b - (g - 1), m = 0; m < g; m++) t[w + m] = o[m];
      }
    }
    return {
      mergeRuns: l,
      forceMergeRuns: u,
      pushRun: s
    };
  }
  function Zv(t, e, r, n) {
    r || (r = 0), n || (n = t.length);
    var i = n - r;
    if (!(i < 2)) {
      var a = 0;
      if (i < $F) {
        a = kM(t, r, n, e), PM(t, r, n, r + a, e);
        return;
      }
      var o = jK(t, e), s = qK(i);
      do {
        if (a = kM(t, r, n, e), a < s) {
          var l = i;
          l > s && (l = s), PM(t, r, r + l, r + a, e), a = l;
        }
        o.pushRun(r, a), o.mergeRuns(), i -= a, r += a;
      } while (i !== 0);
      o.forceMergeRuns();
    }
  }
  var Ia = 1, Qv = 2, Kh = 4, LM = false;
  function Jy() {
    LM || (LM = true, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
  }
  function $M(t, e) {
    return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel;
  }
  var KK = function() {
    function t() {
      this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = $M;
    }
    return t.prototype.traverse = function(e, r) {
      for (var n = 0; n < this._roots.length; n++) this._roots[n].traverse(e, r);
    }, t.prototype.getDisplayList = function(e, r) {
      r = r || false;
      var n = this._displayList;
      return (e || !n.length) && this.updateDisplayList(r), n;
    }, t.prototype.updateDisplayList = function(e) {
      this._displayListLen = 0;
      for (var r = this._roots, n = this._displayList, i = 0, a = r.length; i < a; i++) this._updateAndAddDisplayable(r[i], null, e);
      n.length = this._displayListLen, Zv(n, $M);
    }, t.prototype._updateAndAddDisplayable = function(e, r, n) {
      if (!(e.ignore && !n)) {
        e.beforeUpdate(), e.update(), e.afterUpdate();
        var i = e.getClipPath();
        if (e.ignoreClip) r = null;
        else if (i) {
          r ? r = r.slice() : r = [];
          for (var a = i, o = e; a; ) a.parent = o, a.updateTransform(), r.push(a), o = a, a = a.getClipPath();
        }
        if (e.childrenRef) {
          for (var s = e.childrenRef(), l = 0; l < s.length; l++) {
            var u = s[l];
            e.__dirty && (u.__dirty |= Ia), this._updateAndAddDisplayable(u, r, n);
          }
          e.__dirty = 0;
        } else {
          var c = e;
          r && r.length ? c.__clipPaths = r : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (Jy(), c.z = 0), isNaN(c.z2) && (Jy(), c.z2 = 0), isNaN(c.zlevel) && (Jy(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
        }
        var h = e.getDecalElement && e.getDecalElement();
        h && this._updateAndAddDisplayable(h, r, n);
        var f = e.getTextGuideLine();
        f && this._updateAndAddDisplayable(f, r, n);
        var d = e.getTextContent();
        d && this._updateAndAddDisplayable(d, r, n);
      }
    }, t.prototype.addRoot = function(e) {
      e.__zr && e.__zr.storage === this || this._roots.push(e);
    }, t.prototype.delRoot = function(e) {
      if (e instanceof Array) {
        for (var r = 0, n = e.length; r < n; r++) this.delRoot(e[r]);
        return;
      }
      var i = et(this._roots, e);
      i >= 0 && this._roots.splice(i, 1);
    }, t.prototype.delAllRoots = function() {
      this._roots = [], this._displayList = [], this._displayListLen = 0;
    }, t.prototype.getRoots = function() {
      return this._roots;
    }, t.prototype.dispose = function() {
      this._displayList = null, this._roots = null;
    }, t;
  }(), Sg;
  Sg = ct.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) {
    return setTimeout(t, 16);
  };
  var yf = {
    linear: function(t) {
      return t;
    },
    quadraticIn: function(t) {
      return t * t;
    },
    quadraticOut: function(t) {
      return t * (2 - t);
    },
    quadraticInOut: function(t) {
      return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1);
    },
    cubicIn: function(t) {
      return t * t * t;
    },
    cubicOut: function(t) {
      return --t * t * t + 1;
    },
    cubicInOut: function(t) {
      return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2);
    },
    quarticIn: function(t) {
      return t * t * t * t;
    },
    quarticOut: function(t) {
      return 1 - --t * t * t * t;
    },
    quarticInOut: function(t) {
      return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2);
    },
    quinticIn: function(t) {
      return t * t * t * t * t;
    },
    quinticOut: function(t) {
      return --t * t * t * t * t + 1;
    },
    quinticInOut: function(t) {
      return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2);
    },
    sinusoidalIn: function(t) {
      return 1 - Math.cos(t * Math.PI / 2);
    },
    sinusoidalOut: function(t) {
      return Math.sin(t * Math.PI / 2);
    },
    sinusoidalInOut: function(t) {
      return 0.5 * (1 - Math.cos(Math.PI * t));
    },
    exponentialIn: function(t) {
      return t === 0 ? 0 : Math.pow(1024, t - 1);
    },
    exponentialOut: function(t) {
      return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    },
    exponentialInOut: function(t) {
      return t === 0 ? 0 : t === 1 ? 1 : (t *= 2) < 1 ? 0.5 * Math.pow(1024, t - 1) : 0.5 * (-Math.pow(2, -10 * (t - 1)) + 2);
    },
    circularIn: function(t) {
      return 1 - Math.sqrt(1 - t * t);
    },
    circularOut: function(t) {
      return Math.sqrt(1 - --t * t);
    },
    circularInOut: function(t) {
      return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    },
    elasticIn: function(t) {
      var e, r = 0.1, n = 0.4;
      return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, e = n / 4) : e = n * Math.asin(1 / r) / (2 * Math.PI), -(r * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)));
    },
    elasticOut: function(t) {
      var e, r = 0.1, n = 0.4;
      return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, e = n / 4) : e = n * Math.asin(1 / r) / (2 * Math.PI), r * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / n) + 1);
    },
    elasticInOut: function(t) {
      var e, r = 0.1, n = 0.4;
      return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, e = n / 4) : e = n * Math.asin(1 / r) / (2 * Math.PI), (t *= 2) < 1 ? -0.5 * (r * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n)) : r * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * 0.5 + 1);
    },
    backIn: function(t) {
      var e = 1.70158;
      return t * t * ((e + 1) * t - e);
    },
    backOut: function(t) {
      var e = 1.70158;
      return --t * t * ((e + 1) * t + e) + 1;
    },
    backInOut: function(t) {
      var e = 2.5949095;
      return (t *= 2) < 1 ? 0.5 * (t * t * ((e + 1) * t - e)) : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2);
    },
    bounceIn: function(t) {
      return 1 - yf.bounceOut(1 - t);
    },
    bounceOut: function(t) {
      return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    },
    bounceInOut: function(t) {
      return t < 0.5 ? yf.bounceIn(t * 2) * 0.5 : yf.bounceOut(t * 2 - 1) * 0.5 + 0.5;
    }
  }, vp = Math.pow, as = Math.sqrt, RF = 1e-8, OF = 1e-4, RM = as(3), gp = 1 / 3, ya = ru(), fi = ru(), cc = ru();
  function Qo(t) {
    return t > -1e-8 && t < RF;
  }
  function NF(t) {
    return t > RF || t < -1e-8;
  }
  function Ar(t, e, r, n, i) {
    var a = 1 - i;
    return a * a * (a * t + 3 * i * e) + i * i * (i * n + 3 * a * r);
  }
  function OM(t, e, r, n, i) {
    var a = 1 - i;
    return 3 * (((e - t) * a + 2 * (r - e) * i) * a + (n - r) * i * i);
  }
  function Tg(t, e, r, n, i, a) {
    var o = n + 3 * (e - r) - t, s = 3 * (r - e * 2 + t), l = 3 * (e - t), u = t - i, c = s * s - 3 * o * l, h = s * l - 9 * o * u, f = l * l - 3 * s * u, d = 0;
    if (Qo(c) && Qo(h)) if (Qo(s)) a[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (a[d++] = p);
    }
    else {
      var v = h * h - 4 * c * f;
      if (Qo(v)) {
        var g = h / c, p = -s / o + g, m = -g / 2;
        p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m);
      } else if (v > 0) {
        var y = as(v), _ = c * s + 1.5 * o * (-h + y), b = c * s + 1.5 * o * (-h - y);
        _ < 0 ? _ = -vp(-_, gp) : _ = vp(_, gp), b < 0 ? b = -vp(-b, gp) : b = vp(b, gp);
        var p = (-s - (_ + b)) / (3 * o);
        p >= 0 && p <= 1 && (a[d++] = p);
      } else {
        var w = (2 * c * s - 3 * o * h) / (2 * as(c * c * c)), x = Math.acos(w) / 3, T = as(c), A = Math.cos(x), p = (-s - 2 * T * A) / (3 * o), m = (-s + T * (A + RM * Math.sin(x))) / (3 * o), I = (-s + T * (A - RM * Math.sin(x))) / (3 * o);
        p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m), I >= 0 && I <= 1 && (a[d++] = I);
      }
    }
    return d;
  }
  function BF(t, e, r, n, i) {
    var a = 6 * r - 12 * e + 6 * t, o = 9 * e + 3 * n - 3 * t - 9 * r, s = 3 * e - 3 * t, l = 0;
    if (Qo(o)) {
      if (NF(a)) {
        var u = -s / a;
        u >= 0 && u <= 1 && (i[l++] = u);
      }
    } else {
      var c = a * a - 4 * o * s;
      if (Qo(c)) i[0] = -a / (2 * o);
      else if (c > 0) {
        var h = as(c), u = (-a + h) / (2 * o), f = (-a - h) / (2 * o);
        u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
      }
    }
    return l;
  }
  function fs(t, e, r, n, i, a) {
    var o = (e - t) * i + t, s = (r - e) * i + e, l = (n - r) * i + r, u = (s - o) * i + o, c = (l - s) * i + s, h = (c - u) * i + u;
    a[0] = t, a[1] = o, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = n;
  }
  function zF(t, e, r, n, i, a, o, s, l, u, c) {
    var h, f = 5e-3, d = 1 / 0, p, v, g, m;
    ya[0] = l, ya[1] = u;
    for (var y = 0; y < 1; y += 0.05) fi[0] = Ar(t, r, i, o, y), fi[1] = Ar(e, n, a, s, y), g = Ll(ya, fi), g < d && (h = y, d = g);
    d = 1 / 0;
    for (var _ = 0; _ < 32 && !(f < OF); _++) p = h - f, v = h + f, fi[0] = Ar(t, r, i, o, p), fi[1] = Ar(e, n, a, s, p), g = Ll(fi, ya), p >= 0 && g < d ? (h = p, d = g) : (cc[0] = Ar(t, r, i, o, v), cc[1] = Ar(e, n, a, s, v), m = Ll(cc, ya), v <= 1 && m < d ? (h = v, d = m) : f *= 0.5);
    return c && (c[0] = Ar(t, r, i, o, h), c[1] = Ar(e, n, a, s, h)), as(d);
  }
  function ZK(t, e, r, n, i, a, o, s, l) {
    for (var u = t, c = e, h = 0, f = 1 / l, d = 1; d <= l; d++) {
      var p = d * f, v = Ar(t, r, i, o, p), g = Ar(e, n, a, s, p), m = v - u, y = g - c;
      h += Math.sqrt(m * m + y * y), u = v, c = g;
    }
    return h;
  }
  function Br(t, e, r, n) {
    var i = 1 - n;
    return i * (i * t + 2 * n * e) + n * n * r;
  }
  function lx(t, e, r, n) {
    return 2 * ((1 - n) * (e - t) + n * (r - e));
  }
  function QK(t, e, r, n, i) {
    var a = t - 2 * e + r, o = 2 * (e - t), s = t - n, l = 0;
    if (Qo(a)) {
      if (NF(o)) {
        var u = -s / o;
        u >= 0 && u <= 1 && (i[l++] = u);
      }
    } else {
      var c = o * o - 4 * a * s;
      if (Qo(c)) {
        var u = -o / (2 * a);
        u >= 0 && u <= 1 && (i[l++] = u);
      } else if (c > 0) {
        var h = as(c), u = (-o + h) / (2 * a), f = (-o - h) / (2 * a);
        u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f);
      }
    }
    return l;
  }
  function FF(t, e, r) {
    var n = t + r - 2 * e;
    return n === 0 ? 0.5 : (t - e) / n;
  }
  function Gf(t, e, r, n, i) {
    var a = (e - t) * n + t, o = (r - e) * n + e, s = (o - a) * n + a;
    i[0] = t, i[1] = a, i[2] = s, i[3] = s, i[4] = o, i[5] = r;
  }
  function VF(t, e, r, n, i, a, o, s, l) {
    var u, c = 5e-3, h = 1 / 0;
    ya[0] = o, ya[1] = s;
    for (var f = 0; f < 1; f += 0.05) {
      fi[0] = Br(t, r, i, f), fi[1] = Br(e, n, a, f);
      var d = Ll(ya, fi);
      d < h && (u = f, h = d);
    }
    h = 1 / 0;
    for (var p = 0; p < 32 && !(c < OF); p++) {
      var v = u - c, g = u + c;
      fi[0] = Br(t, r, i, v), fi[1] = Br(e, n, a, v);
      var d = Ll(fi, ya);
      if (v >= 0 && d < h) u = v, h = d;
      else {
        cc[0] = Br(t, r, i, g), cc[1] = Br(e, n, a, g);
        var m = Ll(cc, ya);
        g <= 1 && m < h ? (u = g, h = m) : c *= 0.5;
      }
    }
    return l && (l[0] = Br(t, r, i, u), l[1] = Br(e, n, a, u)), as(h);
  }
  function JK(t, e, r, n, i, a, o) {
    for (var s = t, l = e, u = 0, c = 1 / o, h = 1; h <= o; h++) {
      var f = h * c, d = Br(t, r, i, f), p = Br(e, n, a, f), v = d - s, g = p - l;
      u += Math.sqrt(v * v + g * g), s = d, l = p;
    }
    return u;
  }
  var eZ = /cubic-bezier\(([0-9,\.e ]+)\)/;
  function JS(t) {
    var e = t && eZ.exec(t);
    if (e) {
      var r = e[1].split(","), n = +Vi(r[0]), i = +Vi(r[1]), a = +Vi(r[2]), o = +Vi(r[3]);
      if (isNaN(n + i + a + o)) return;
      var s = [];
      return function(l) {
        return l <= 0 ? 0 : l >= 1 ? 1 : Tg(0, n, a, 1, l, s) && Ar(0, i, o, 1, s[0]);
      };
    }
  }
  var tZ = function() {
    function t(e) {
      this._inited = false, this._startTime = 0, this._pausedTime = 0, this._paused = false, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || false, this.onframe = e.onframe || dr, this.ondestroy = e.ondestroy || dr, this.onrestart = e.onrestart || dr, e.easing && this.setEasing(e.easing);
    }
    return t.prototype.step = function(e, r) {
      if (this._inited || (this._startTime = e + this._delay, this._inited = true), this._paused) {
        this._pausedTime += r;
        return;
      }
      var n = this._life, i = e - this._startTime - this._pausedTime, a = i / n;
      a < 0 && (a = 0), a = Math.min(a, 1);
      var o = this.easingFunc, s = o ? o(a) : a;
      if (this.onframe(s), a === 1) if (this.loop) {
        var l = i % n;
        this._startTime = e - l, this._pausedTime = 0, this.onrestart();
      } else return true;
      return false;
    }, t.prototype.pause = function() {
      this._paused = true;
    }, t.prototype.resume = function() {
      this._paused = false;
    }, t.prototype.setEasing = function(e) {
      this.easing = e, this.easingFunc = De(e) ? e : yf[e] || JS(e);
    }, t;
  }(), GF = /* @__PURE__ */ function() {
    function t(e) {
      this.value = e;
    }
    return t;
  }(), rZ = function() {
    function t() {
      this._len = 0;
    }
    return t.prototype.insert = function(e) {
      var r = new GF(e);
      return this.insertEntry(r), r;
    }, t.prototype.insertEntry = function(e) {
      this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
    }, t.prototype.remove = function(e) {
      var r = e.prev, n = e.next;
      r ? r.next = n : this.head = n, n ? n.prev = r : this.tail = r, e.next = e.prev = null, this._len--;
    }, t.prototype.len = function() {
      return this._len;
    }, t.prototype.clear = function() {
      this.head = this.tail = null, this._len = 0;
    }, t;
  }(), Md = function() {
    function t(e) {
      this._list = new rZ(), this._maxSize = 10, this._map = {}, this._maxSize = e;
    }
    return t.prototype.put = function(e, r) {
      var n = this._list, i = this._map, a = null;
      if (i[e] == null) {
        var o = n.len(), s = this._lastRemovedEntry;
        if (o >= this._maxSize && o > 0) {
          var l = n.head;
          n.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l;
        }
        s ? s.value = r : s = new GF(r), s.key = e, n.insertEntry(s), i[e] = s;
      }
      return a;
    }, t.prototype.get = function(e) {
      var r = this._map[e], n = this._list;
      if (r != null) return r !== n.tail && (n.remove(r), n.insertEntry(r)), r.value;
    }, t.prototype.clear = function() {
      this._list.clear(), this._map = {};
    }, t.prototype.len = function() {
      return this._list.len();
    }, t;
  }(), NM = {
    transparent: [
      0,
      0,
      0,
      0
    ],
    aliceblue: [
      240,
      248,
      255,
      1
    ],
    antiquewhite: [
      250,
      235,
      215,
      1
    ],
    aqua: [
      0,
      255,
      255,
      1
    ],
    aquamarine: [
      127,
      255,
      212,
      1
    ],
    azure: [
      240,
      255,
      255,
      1
    ],
    beige: [
      245,
      245,
      220,
      1
    ],
    bisque: [
      255,
      228,
      196,
      1
    ],
    black: [
      0,
      0,
      0,
      1
    ],
    blanchedalmond: [
      255,
      235,
      205,
      1
    ],
    blue: [
      0,
      0,
      255,
      1
    ],
    blueviolet: [
      138,
      43,
      226,
      1
    ],
    brown: [
      165,
      42,
      42,
      1
    ],
    burlywood: [
      222,
      184,
      135,
      1
    ],
    cadetblue: [
      95,
      158,
      160,
      1
    ],
    chartreuse: [
      127,
      255,
      0,
      1
    ],
    chocolate: [
      210,
      105,
      30,
      1
    ],
    coral: [
      255,
      127,
      80,
      1
    ],
    cornflowerblue: [
      100,
      149,
      237,
      1
    ],
    cornsilk: [
      255,
      248,
      220,
      1
    ],
    crimson: [
      220,
      20,
      60,
      1
    ],
    cyan: [
      0,
      255,
      255,
      1
    ],
    darkblue: [
      0,
      0,
      139,
      1
    ],
    darkcyan: [
      0,
      139,
      139,
      1
    ],
    darkgoldenrod: [
      184,
      134,
      11,
      1
    ],
    darkgray: [
      169,
      169,
      169,
      1
    ],
    darkgreen: [
      0,
      100,
      0,
      1
    ],
    darkgrey: [
      169,
      169,
      169,
      1
    ],
    darkkhaki: [
      189,
      183,
      107,
      1
    ],
    darkmagenta: [
      139,
      0,
      139,
      1
    ],
    darkolivegreen: [
      85,
      107,
      47,
      1
    ],
    darkorange: [
      255,
      140,
      0,
      1
    ],
    darkorchid: [
      153,
      50,
      204,
      1
    ],
    darkred: [
      139,
      0,
      0,
      1
    ],
    darksalmon: [
      233,
      150,
      122,
      1
    ],
    darkseagreen: [
      143,
      188,
      143,
      1
    ],
    darkslateblue: [
      72,
      61,
      139,
      1
    ],
    darkslategray: [
      47,
      79,
      79,
      1
    ],
    darkslategrey: [
      47,
      79,
      79,
      1
    ],
    darkturquoise: [
      0,
      206,
      209,
      1
    ],
    darkviolet: [
      148,
      0,
      211,
      1
    ],
    deeppink: [
      255,
      20,
      147,
      1
    ],
    deepskyblue: [
      0,
      191,
      255,
      1
    ],
    dimgray: [
      105,
      105,
      105,
      1
    ],
    dimgrey: [
      105,
      105,
      105,
      1
    ],
    dodgerblue: [
      30,
      144,
      255,
      1
    ],
    firebrick: [
      178,
      34,
      34,
      1
    ],
    floralwhite: [
      255,
      250,
      240,
      1
    ],
    forestgreen: [
      34,
      139,
      34,
      1
    ],
    fuchsia: [
      255,
      0,
      255,
      1
    ],
    gainsboro: [
      220,
      220,
      220,
      1
    ],
    ghostwhite: [
      248,
      248,
      255,
      1
    ],
    gold: [
      255,
      215,
      0,
      1
    ],
    goldenrod: [
      218,
      165,
      32,
      1
    ],
    gray: [
      128,
      128,
      128,
      1
    ],
    green: [
      0,
      128,
      0,
      1
    ],
    greenyellow: [
      173,
      255,
      47,
      1
    ],
    grey: [
      128,
      128,
      128,
      1
    ],
    honeydew: [
      240,
      255,
      240,
      1
    ],
    hotpink: [
      255,
      105,
      180,
      1
    ],
    indianred: [
      205,
      92,
      92,
      1
    ],
    indigo: [
      75,
      0,
      130,
      1
    ],
    ivory: [
      255,
      255,
      240,
      1
    ],
    khaki: [
      240,
      230,
      140,
      1
    ],
    lavender: [
      230,
      230,
      250,
      1
    ],
    lavenderblush: [
      255,
      240,
      245,
      1
    ],
    lawngreen: [
      124,
      252,
      0,
      1
    ],
    lemonchiffon: [
      255,
      250,
      205,
      1
    ],
    lightblue: [
      173,
      216,
      230,
      1
    ],
    lightcoral: [
      240,
      128,
      128,
      1
    ],
    lightcyan: [
      224,
      255,
      255,
      1
    ],
    lightgoldenrodyellow: [
      250,
      250,
      210,
      1
    ],
    lightgray: [
      211,
      211,
      211,
      1
    ],
    lightgreen: [
      144,
      238,
      144,
      1
    ],
    lightgrey: [
      211,
      211,
      211,
      1
    ],
    lightpink: [
      255,
      182,
      193,
      1
    ],
    lightsalmon: [
      255,
      160,
      122,
      1
    ],
    lightseagreen: [
      32,
      178,
      170,
      1
    ],
    lightskyblue: [
      135,
      206,
      250,
      1
    ],
    lightslategray: [
      119,
      136,
      153,
      1
    ],
    lightslategrey: [
      119,
      136,
      153,
      1
    ],
    lightsteelblue: [
      176,
      196,
      222,
      1
    ],
    lightyellow: [
      255,
      255,
      224,
      1
    ],
    lime: [
      0,
      255,
      0,
      1
    ],
    limegreen: [
      50,
      205,
      50,
      1
    ],
    linen: [
      250,
      240,
      230,
      1
    ],
    magenta: [
      255,
      0,
      255,
      1
    ],
    maroon: [
      128,
      0,
      0,
      1
    ],
    mediumaquamarine: [
      102,
      205,
      170,
      1
    ],
    mediumblue: [
      0,
      0,
      205,
      1
    ],
    mediumorchid: [
      186,
      85,
      211,
      1
    ],
    mediumpurple: [
      147,
      112,
      219,
      1
    ],
    mediumseagreen: [
      60,
      179,
      113,
      1
    ],
    mediumslateblue: [
      123,
      104,
      238,
      1
    ],
    mediumspringgreen: [
      0,
      250,
      154,
      1
    ],
    mediumturquoise: [
      72,
      209,
      204,
      1
    ],
    mediumvioletred: [
      199,
      21,
      133,
      1
    ],
    midnightblue: [
      25,
      25,
      112,
      1
    ],
    mintcream: [
      245,
      255,
      250,
      1
    ],
    mistyrose: [
      255,
      228,
      225,
      1
    ],
    moccasin: [
      255,
      228,
      181,
      1
    ],
    navajowhite: [
      255,
      222,
      173,
      1
    ],
    navy: [
      0,
      0,
      128,
      1
    ],
    oldlace: [
      253,
      245,
      230,
      1
    ],
    olive: [
      128,
      128,
      0,
      1
    ],
    olivedrab: [
      107,
      142,
      35,
      1
    ],
    orange: [
      255,
      165,
      0,
      1
    ],
    orangered: [
      255,
      69,
      0,
      1
    ],
    orchid: [
      218,
      112,
      214,
      1
    ],
    palegoldenrod: [
      238,
      232,
      170,
      1
    ],
    palegreen: [
      152,
      251,
      152,
      1
    ],
    paleturquoise: [
      175,
      238,
      238,
      1
    ],
    palevioletred: [
      219,
      112,
      147,
      1
    ],
    papayawhip: [
      255,
      239,
      213,
      1
    ],
    peachpuff: [
      255,
      218,
      185,
      1
    ],
    peru: [
      205,
      133,
      63,
      1
    ],
    pink: [
      255,
      192,
      203,
      1
    ],
    plum: [
      221,
      160,
      221,
      1
    ],
    powderblue: [
      176,
      224,
      230,
      1
    ],
    purple: [
      128,
      0,
      128,
      1
    ],
    red: [
      255,
      0,
      0,
      1
    ],
    rosybrown: [
      188,
      143,
      143,
      1
    ],
    royalblue: [
      65,
      105,
      225,
      1
    ],
    saddlebrown: [
      139,
      69,
      19,
      1
    ],
    salmon: [
      250,
      128,
      114,
      1
    ],
    sandybrown: [
      244,
      164,
      96,
      1
    ],
    seagreen: [
      46,
      139,
      87,
      1
    ],
    seashell: [
      255,
      245,
      238,
      1
    ],
    sienna: [
      160,
      82,
      45,
      1
    ],
    silver: [
      192,
      192,
      192,
      1
    ],
    skyblue: [
      135,
      206,
      235,
      1
    ],
    slateblue: [
      106,
      90,
      205,
      1
    ],
    slategray: [
      112,
      128,
      144,
      1
    ],
    slategrey: [
      112,
      128,
      144,
      1
    ],
    snow: [
      255,
      250,
      250,
      1
    ],
    springgreen: [
      0,
      255,
      127,
      1
    ],
    steelblue: [
      70,
      130,
      180,
      1
    ],
    tan: [
      210,
      180,
      140,
      1
    ],
    teal: [
      0,
      128,
      128,
      1
    ],
    thistle: [
      216,
      191,
      216,
      1
    ],
    tomato: [
      255,
      99,
      71,
      1
    ],
    turquoise: [
      64,
      224,
      208,
      1
    ],
    violet: [
      238,
      130,
      238,
      1
    ],
    wheat: [
      245,
      222,
      179,
      1
    ],
    white: [
      255,
      255,
      255,
      1
    ],
    whitesmoke: [
      245,
      245,
      245,
      1
    ],
    yellow: [
      255,
      255,
      0,
      1
    ],
    yellowgreen: [
      154,
      205,
      50,
      1
    ]
  };
  function Ui(t) {
    return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t;
  }
  function nZ(t) {
    return t = Math.round(t), t < 0 ? 0 : t > 360 ? 360 : t;
  }
  function Wf(t) {
    return t < 0 ? 0 : t > 1 ? 1 : t;
  }
  function e0(t) {
    var e = t;
    return e.length && e.charAt(e.length - 1) === "%" ? Ui(parseFloat(e) / 100 * 255) : Ui(parseInt(e, 10));
  }
  function $l(t) {
    var e = t;
    return e.length && e.charAt(e.length - 1) === "%" ? Wf(parseFloat(e) / 100) : Wf(parseFloat(e));
  }
  function t0(t, e, r) {
    return r < 0 ? r += 1 : r > 1 && (r -= 1), r * 6 < 1 ? t + (e - t) * r * 6 : r * 2 < 1 ? e : r * 3 < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;
  }
  function Jo(t, e, r) {
    return t + (e - t) * r;
  }
  function oi(t, e, r, n, i) {
    return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t;
  }
  function ux(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;
  }
  var WF = new Md(20), mp = null;
  function yu(t, e) {
    mp && ux(mp, e), mp = WF.put(t, mp || e.slice());
  }
  function Un(t, e) {
    if (t) {
      e = e || [];
      var r = WF.get(t);
      if (r) return ux(e, r);
      t = t + "";
      var n = t.replace(/ /g, "").toLowerCase();
      if (n in NM) return ux(e, NM[n]), yu(t, e), e;
      var i = n.length;
      if (n.charAt(0) === "#") {
        if (i === 4 || i === 5) {
          var a = parseInt(n.slice(1, 4), 16);
          if (!(a >= 0 && a <= 4095)) {
            oi(e, 0, 0, 0, 1);
            return;
          }
          return oi(e, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(n.slice(4), 16) / 15 : 1), yu(t, e), e;
        } else if (i === 7 || i === 9) {
          var a = parseInt(n.slice(1, 7), 16);
          if (!(a >= 0 && a <= 16777215)) {
            oi(e, 0, 0, 0, 1);
            return;
          }
          return oi(e, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(n.slice(7), 16) / 255 : 1), yu(t, e), e;
        }
        return;
      }
      var o = n.indexOf("("), s = n.indexOf(")");
      if (o !== -1 && s + 1 === i) {
        var l = n.substr(0, o), u = n.substr(o + 1, s - (o + 1)).split(","), c = 1;
        switch (l) {
          case "rgba":
            if (u.length !== 4) return u.length === 3 ? oi(e, +u[0], +u[1], +u[2], 1) : oi(e, 0, 0, 0, 1);
            c = $l(u.pop());
          case "rgb":
            if (u.length >= 3) return oi(e, e0(u[0]), e0(u[1]), e0(u[2]), u.length === 3 ? c : $l(u[3])), yu(t, e), e;
            oi(e, 0, 0, 0, 1);
            return;
          case "hsla":
            if (u.length !== 4) {
              oi(e, 0, 0, 0, 1);
              return;
            }
            return u[3] = $l(u[3]), cx(u, e), yu(t, e), e;
          case "hsl":
            if (u.length !== 3) {
              oi(e, 0, 0, 0, 1);
              return;
            }
            return cx(u, e), yu(t, e), e;
          default:
            return;
        }
      }
      oi(e, 0, 0, 0, 1);
    }
  }
  function cx(t, e) {
    var r = (parseFloat(t[0]) % 360 + 360) % 360 / 360, n = $l(t[1]), i = $l(t[2]), a = i <= 0.5 ? i * (n + 1) : i + n - i * n, o = i * 2 - a;
    return e = e || [], oi(e, Ui(t0(o, a, r + 1 / 3) * 255), Ui(t0(o, a, r) * 255), Ui(t0(o, a, r - 1 / 3) * 255), 1), t.length === 4 && (e[3] = t[3]), e;
  }
  function iZ(t) {
    if (t) {
      var e = t[0] / 255, r = t[1] / 255, n = t[2] / 255, i = Math.min(e, r, n), a = Math.max(e, r, n), o = a - i, s = (a + i) / 2, l, u;
      if (o === 0) l = 0, u = 0;
      else {
        s < 0.5 ? u = o / (a + i) : u = o / (2 - a - i);
        var c = ((a - e) / 6 + o / 2) / o, h = ((a - r) / 6 + o / 2) / o, f = ((a - n) / 6 + o / 2) / o;
        e === a ? l = f - h : r === a ? l = 1 / 3 + c - f : n === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
      }
      var d = [
        l * 360,
        u,
        s
      ];
      return t[3] != null && d.push(t[3]), d;
    }
  }
  function hx(t, e) {
    var r = Un(t);
    if (r) {
      for (var n = 0; n < 3; n++) e < 0 ? r[n] = r[n] * (1 - e) | 0 : r[n] = (255 - r[n]) * e + r[n] | 0, r[n] > 255 ? r[n] = 255 : r[n] < 0 && (r[n] = 0);
      return ao(r, r.length === 4 ? "rgba" : "rgb");
    }
  }
  function r0(t, e, r) {
    if (!(!(e && e.length) || !(t >= 0 && t <= 1))) {
      r = r || [];
      var n = t * (e.length - 1), i = Math.floor(n), a = Math.ceil(n), o = e[i], s = e[a], l = n - i;
      return r[0] = Ui(Jo(o[0], s[0], l)), r[1] = Ui(Jo(o[1], s[1], l)), r[2] = Ui(Jo(o[2], s[2], l)), r[3] = Wf(Jo(o[3], s[3], l)), r;
    }
  }
  function aZ(t, e, r) {
    if (!(!(e && e.length) || !(t >= 0 && t <= 1))) {
      var n = t * (e.length - 1), i = Math.floor(n), a = Math.ceil(n), o = Un(e[i]), s = Un(e[a]), l = n - i, u = ao([
        Ui(Jo(o[0], s[0], l)),
        Ui(Jo(o[1], s[1], l)),
        Ui(Jo(o[2], s[2], l)),
        Wf(Jo(o[3], s[3], l))
      ], "rgba");
      return r ? {
        color: u,
        leftIndex: i,
        rightIndex: a,
        value: n
      } : u;
    }
  }
  function _f(t, e, r, n) {
    var i = Un(t);
    if (t) return i = iZ(i), e != null && (i[0] = nZ(e)), r != null && (i[1] = $l(r)), n != null && (i[2] = $l(n)), ao(cx(i), "rgba");
  }
  function Cg(t, e) {
    var r = Un(t);
    if (r && e != null) return r[3] = Wf(e), ao(r, "rgba");
  }
  function ao(t, e) {
    if (!(!t || !t.length)) {
      var r = t[0] + "," + t[1] + "," + t[2];
      return (e === "rgba" || e === "hsva" || e === "hsla") && (r += "," + t[3]), e + "(" + r + ")";
    }
  }
  function Ag(t, e) {
    var r = Un(t);
    return r ? (0.299 * r[0] + 0.587 * r[1] + 0.114 * r[2]) * r[3] / 255 + (1 - r[3]) * e : 0;
  }
  var BM = new Md(100);
  function fx(t) {
    if (me(t)) {
      var e = BM.get(t);
      return e || (e = hx(t, -0.1), BM.put(t, e)), e;
    } else if (Rm(t)) {
      var r = te({}, t);
      return r.colorStops = oe(t.colorStops, function(n) {
        return {
          offset: n.offset,
          color: hx(n.color, -0.1)
        };
      }), r;
    }
    return t;
  }
  var Ig = Math.round;
  function Hf(t) {
    var e;
    if (!t || t === "transparent") t = "none";
    else if (typeof t == "string" && t.indexOf("rgba") > -1) {
      var r = Un(t);
      r && (t = "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")", e = r[3]);
    }
    return {
      color: t,
      opacity: e ?? 1
    };
  }
  var oZ = 1e-4;
  function es(t) {
    return t < oZ && t > -1e-4;
  }
  function yp(t) {
    return Ig(t * 1e3) / 1e3;
  }
  function dx(t) {
    return Ig(t * 1e4) / 1e4;
  }
  function sZ(t) {
    return "matrix(" + yp(t[0]) + "," + yp(t[1]) + "," + yp(t[2]) + "," + yp(t[3]) + "," + dx(t[4]) + "," + dx(t[5]) + ")";
  }
  var lZ = {
    left: "start",
    right: "end",
    center: "middle",
    middle: "middle"
  };
  function uZ(t, e, r) {
    return r === "top" ? t += e / 2 : r === "bottom" && (t -= e / 2), t;
  }
  function cZ(t) {
    return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY);
  }
  function hZ(t) {
    var e = t.style, r = t.getGlobalScale();
    return [
      e.shadowColor,
      (e.shadowBlur || 0).toFixed(2),
      (e.shadowOffsetX || 0).toFixed(2),
      (e.shadowOffsetY || 0).toFixed(2),
      r[0],
      r[1]
    ].join(",");
  }
  function HF(t) {
    return t && !!t.image;
  }
  function fZ(t) {
    return t && !!t.svgElement;
  }
  function eT(t) {
    return HF(t) || fZ(t);
  }
  function UF(t) {
    return t.type === "linear";
  }
  function YF(t) {
    return t.type === "radial";
  }
  function qF(t) {
    return t && (t.type === "linear" || t.type === "radial");
  }
  function Bm(t) {
    return "url(#" + t + ")";
  }
  function XF(t) {
    var e = t.getGlobalScale(), r = Math.max(e[0], e[1]);
    return Math.max(Math.ceil(Math.log(r) / Math.log(10)), 1);
  }
  function jF(t) {
    var e = t.x || 0, r = t.y || 0, n = (t.rotation || 0) * Xv, i = We(t.scaleX, 1), a = We(t.scaleY, 1), o = t.skewX || 0, s = t.skewY || 0, l = [];
    return (e || r) && l.push("translate(" + e + "px," + r + "px)"), n && l.push("rotate(" + n + ")"), (i !== 1 || a !== 1) && l.push("scale(" + i + "," + a + ")"), (o || s) && l.push("skew(" + Ig(o * Xv) + "deg, " + Ig(s * Xv) + "deg)"), l.join(" ");
  }
  var dZ = function() {
    return ct.hasGlobalWindow && De(window.btoa) ? function(t) {
      return window.btoa(unescape(encodeURIComponent(t)));
    } : typeof Buffer < "u" ? function(t) {
      return Buffer.from(t).toString("base64");
    } : function(t) {
      return null;
    };
  }(), px = Array.prototype.slice;
  function Ka(t, e, r) {
    return (e - t) * r + t;
  }
  function n0(t, e, r, n) {
    for (var i = e.length, a = 0; a < i; a++) t[a] = Ka(e[a], r[a], n);
    return t;
  }
  function pZ(t, e, r, n) {
    for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) {
      t[o] || (t[o] = []);
      for (var s = 0; s < a; s++) t[o][s] = Ka(e[o][s], r[o][s], n);
    }
    return t;
  }
  function _p(t, e, r, n) {
    for (var i = e.length, a = 0; a < i; a++) t[a] = e[a] + r[a] * n;
    return t;
  }
  function zM(t, e, r, n) {
    for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) {
      t[o] || (t[o] = []);
      for (var s = 0; s < a; s++) t[o][s] = e[o][s] + r[o][s] * n;
    }
    return t;
  }
  function vZ(t, e) {
    for (var r = t.length, n = e.length, i = r > n ? e : t, a = Math.min(r, n), o = i[a - 1] || {
      color: [
        0,
        0,
        0,
        0
      ],
      offset: 0
    }, s = a; s < Math.max(r, n); s++) i.push({
      offset: o.offset,
      color: o.color.slice()
    });
  }
  function gZ(t, e, r) {
    var n = t, i = e;
    if (!(!n.push || !i.push)) {
      var a = n.length, o = i.length;
      if (a !== o) {
        var s = a > o;
        if (s) n.length = o;
        else for (var l = a; l < o; l++) n.push(r === 1 ? i[l] : px.call(i[l]));
      }
      for (var u = n[0] && n[0].length, l = 0; l < n.length; l++) if (r === 1) isNaN(n[l]) && (n[l] = i[l]);
      else for (var c = 0; c < u; c++) isNaN(n[l][c]) && (n[l][c] = i[l][c]);
    }
  }
  function bf(t) {
    if (on(t)) {
      var e = t.length;
      if (on(t[0])) {
        for (var r = [], n = 0; n < e; n++) r.push(px.call(t[n]));
        return r;
      }
      return px.call(t);
    }
    return t;
  }
  function Jv(t) {
    return t[0] = Math.floor(t[0]) || 0, t[1] = Math.floor(t[1]) || 0, t[2] = Math.floor(t[2]) || 0, t[3] = t[3] == null ? 1 : t[3], "rgba(" + t.join(",") + ")";
  }
  function mZ(t) {
    return on(t && t[0]) ? 2 : 1;
  }
  var bp = 0, eg = 1, KF = 2, Zh = 3, vx = 4, gx = 5, FM = 6;
  function VM(t) {
    return t === vx || t === gx;
  }
  function xp(t) {
    return t === eg || t === KF;
  }
  var uh = [
    0,
    0,
    0,
    0
  ], yZ = function() {
    function t(e) {
      this.keyframes = [], this.discrete = false, this._invalid = false, this._needsSort = false, this._lastFr = 0, this._lastFrP = 0, this.propName = e;
    }
    return t.prototype.isFinished = function() {
      return this._finished;
    }, t.prototype.setFinished = function() {
      this._finished = true, this._additiveTrack && this._additiveTrack.setFinished();
    }, t.prototype.needsAnimate = function() {
      return this.keyframes.length >= 1;
    }, t.prototype.getAdditiveTrack = function() {
      return this._additiveTrack;
    }, t.prototype.addKeyframe = function(e, r, n) {
      this._needsSort = true;
      var i = this.keyframes, a = i.length, o = false, s = FM, l = r;
      if (on(r)) {
        var u = mZ(r);
        s = u, (u === 1 && !xt(r[0]) || u === 2 && !xt(r[0][0])) && (o = true);
      } else if (xt(r) && !Ff(r)) s = bp;
      else if (me(r)) if (!isNaN(+r)) s = bp;
      else {
        var c = Un(r);
        c && (l = c, s = Zh);
      }
      else if (Rm(r)) {
        var h = te({}, l);
        h.colorStops = oe(r.colorStops, function(d) {
          return {
            offset: d.offset,
            color: Un(d.color)
          };
        }), UF(r) ? s = vx : YF(r) && (s = gx), l = h;
      }
      a === 0 ? this.valType = s : (s !== this.valType || s === FM) && (o = true), this.discrete = this.discrete || o;
      var f = {
        time: e,
        value: l,
        rawValue: r,
        percent: 0
      };
      return n && (f.easing = n, f.easingFunc = De(n) ? n : yf[n] || JS(n)), i.push(f), f;
    }, t.prototype.prepare = function(e, r) {
      var n = this.keyframes;
      this._needsSort && n.sort(function(v, g) {
        return v.time - g.time;
      });
      for (var i = this.valType, a = n.length, o = n[a - 1], s = this.discrete, l = xp(i), u = VM(i), c = 0; c < a; c++) {
        var h = n[c], f = h.value, d = o.value;
        h.percent = h.time / e, s || (l && c !== a - 1 ? gZ(f, d, i) : u && vZ(f.colorStops, d.colorStops));
      }
      if (!s && i !== gx && r && this.needsAnimate() && r.needsAnimate() && i === r.valType && !r._finished) {
        this._additiveTrack = r;
        for (var p = n[0].value, c = 0; c < a; c++) i === bp ? n[c].additiveValue = n[c].value - p : i === Zh ? n[c].additiveValue = _p([], n[c].value, p, -1) : xp(i) && (n[c].additiveValue = i === eg ? _p([], n[c].value, p, -1) : zM([], n[c].value, p, -1));
      }
    }, t.prototype.step = function(e, r) {
      if (!this._finished) {
        this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
        var n = this._additiveTrack != null, i = n ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === Zh, c, h = this._lastFr, f = Math.min, d, p;
        if (s === 1) d = p = o[0];
        else {
          if (r < 0) c = 0;
          else if (r < this._lastFrP) {
            var v = f(h + 1, s - 1);
            for (c = v; c >= 0 && !(o[c].percent <= r); c--) ;
            c = f(c, s - 2);
          } else {
            for (c = h; c < s && !(o[c].percent > r); c++) ;
            c = f(c - 1, s - 2);
          }
          p = o[c + 1], d = o[c];
        }
        if (d && p) {
          this._lastFr = c, this._lastFrP = r;
          var g = p.percent - d.percent, m = g === 0 ? 1 : f((r - d.percent) / g, 1);
          p.easingFunc && (m = p.easingFunc(m));
          var y = n ? this._additiveValue : u ? uh : e[l];
          if ((xp(a) || u) && !y && (y = this._additiveValue = []), this.discrete) e[l] = m < 1 ? d.rawValue : p.rawValue;
          else if (xp(a)) a === eg ? n0(y, d[i], p[i], m) : pZ(y, d[i], p[i], m);
          else if (VM(a)) {
            var _ = d[i], b = p[i], w = a === vx;
            e[l] = {
              type: w ? "linear" : "radial",
              x: Ka(_.x, b.x, m),
              y: Ka(_.y, b.y, m),
              colorStops: oe(_.colorStops, function(T, A) {
                var I = b.colorStops[A];
                return {
                  offset: Ka(T.offset, I.offset, m),
                  color: Jv(n0([], T.color, I.color, m))
                };
              }),
              global: b.global
            }, w ? (e[l].x2 = Ka(_.x2, b.x2, m), e[l].y2 = Ka(_.y2, b.y2, m)) : e[l].r = Ka(_.r, b.r, m);
          } else if (u) n0(y, d[i], p[i], m), n || (e[l] = Jv(y));
          else {
            var x = Ka(d[i], p[i], m);
            n ? this._additiveValue = x : e[l] = x;
          }
          n && this._addToTarget(e);
        }
      }
    }, t.prototype._addToTarget = function(e) {
      var r = this.valType, n = this.propName, i = this._additiveValue;
      r === bp ? e[n] = e[n] + i : r === Zh ? (Un(e[n], uh), _p(uh, uh, i, 1), e[n] = Jv(uh)) : r === eg ? _p(e[n], e[n], i, 1) : r === KF && zM(e[n], e[n], i, 1);
    }, t;
  }(), tT = function() {
    function t(e, r, n, i) {
      if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = r, r && i) {
        YS("Can' use additive animation on looped animation.");
        return;
      }
      this._additiveAnimators = i, this._allowDiscrete = n;
    }
    return t.prototype.getMaxTime = function() {
      return this._maxTime;
    }, t.prototype.getDelay = function() {
      return this._delay;
    }, t.prototype.getLoop = function() {
      return this._loop;
    }, t.prototype.getTarget = function() {
      return this._target;
    }, t.prototype.changeTarget = function(e) {
      this._target = e;
    }, t.prototype.when = function(e, r, n) {
      return this.whenWithKeys(e, r, gt(r), n);
    }, t.prototype.whenWithKeys = function(e, r, n, i) {
      for (var a = this._tracks, o = 0; o < n.length; o++) {
        var s = n[o], l = a[s];
        if (!l) {
          l = a[s] = new yZ(s);
          var u = void 0, c = this._getAdditiveTrack(s);
          if (c) {
            var h = c.keyframes, f = h[h.length - 1];
            u = f && f.value, c.valType === Zh && u && (u = Jv(u));
          } else u = this._target[s];
          if (u == null) continue;
          e > 0 && l.addKeyframe(0, bf(u), i), this._trackKeys.push(s);
        }
        l.addKeyframe(e, bf(r[s]), i);
      }
      return this._maxTime = Math.max(this._maxTime, e), this;
    }, t.prototype.pause = function() {
      this._clip.pause(), this._paused = true;
    }, t.prototype.resume = function() {
      this._clip.resume(), this._paused = false;
    }, t.prototype.isPaused = function() {
      return !!this._paused;
    }, t.prototype.duration = function(e) {
      return this._maxTime = e, this._force = true, this;
    }, t.prototype._doneCallback = function() {
      this._setTracksFinished(), this._clip = null;
      var e = this._doneCbs;
      if (e) for (var r = e.length, n = 0; n < r; n++) e[n].call(this);
    }, t.prototype._abortedCallback = function() {
      this._setTracksFinished();
      var e = this.animation, r = this._abortedCbs;
      if (e && e.removeClip(this._clip), this._clip = null, r) for (var n = 0; n < r.length; n++) r[n].call(this);
    }, t.prototype._setTracksFinished = function() {
      for (var e = this._tracks, r = this._trackKeys, n = 0; n < r.length; n++) e[r[n]].setFinished();
    }, t.prototype._getAdditiveTrack = function(e) {
      var r, n = this._additiveAnimators;
      if (n) for (var i = 0; i < n.length; i++) {
        var a = n[i].getTrack(e);
        a && (r = a);
      }
      return r;
    }, t.prototype.start = function(e) {
      if (!(this._started > 0)) {
        this._started = 1;
        for (var r = this, n = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
          var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, c = u.length;
          if (s.prepare(i, l), s.needsAnimate()) if (!this._allowDiscrete && s.discrete) {
            var h = u[c - 1];
            h && (r._target[s.propName] = h.rawValue), s.setFinished();
          } else n.push(s);
        }
        if (n.length || this._force) {
          var f = new tZ({
            life: i,
            loop: this._loop,
            delay: this._delay || 0,
            onframe: function(d) {
              r._started = 2;
              var p = r._additiveAnimators;
              if (p) {
                for (var v = false, g = 0; g < p.length; g++) if (p[g]._clip) {
                  v = true;
                  break;
                }
                v || (r._additiveAnimators = null);
              }
              for (var g = 0; g < n.length; g++) n[g].step(r._target, d);
              var m = r._onframeCbs;
              if (m) for (var g = 0; g < m.length; g++) m[g](r._target, d);
            },
            ondestroy: function() {
              r._doneCallback();
            }
          });
          this._clip = f, this.animation && this.animation.addClip(f), e && f.setEasing(e);
        } else this._doneCallback();
        return this;
      }
    }, t.prototype.stop = function(e) {
      if (this._clip) {
        var r = this._clip;
        e && r.onframe(1), this._abortedCallback();
      }
    }, t.prototype.delay = function(e) {
      return this._delay = e, this;
    }, t.prototype.during = function(e) {
      return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this;
    }, t.prototype.done = function(e) {
      return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this;
    }, t.prototype.aborted = function(e) {
      return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this;
    }, t.prototype.getClip = function() {
      return this._clip;
    }, t.prototype.getTrack = function(e) {
      return this._tracks[e];
    }, t.prototype.getTracks = function() {
      var e = this;
      return oe(this._trackKeys, function(r) {
        return e._tracks[r];
      });
    }, t.prototype.stopTracks = function(e, r) {
      if (!e.length || !this._clip) return true;
      for (var n = this._tracks, i = this._trackKeys, a = 0; a < e.length; a++) {
        var o = n[e[a]];
        o && !o.isFinished() && (r ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
      }
      for (var s = true, a = 0; a < i.length; a++) if (!n[i[a]].isFinished()) {
        s = false;
        break;
      }
      return s && this._abortedCallback(), s;
    }, t.prototype.saveTo = function(e, r, n) {
      if (e) {
        r = r || this._trackKeys;
        for (var i = 0; i < r.length; i++) {
          var a = r[i], o = this._tracks[a];
          if (!(!o || o.isFinished())) {
            var s = o.keyframes, l = s[n ? 0 : s.length - 1];
            l && (e[a] = bf(l.rawValue));
          }
        }
      }
    }, t.prototype.__changeFinalValue = function(e, r) {
      r = r || gt(e);
      for (var n = 0; n < r.length; n++) {
        var i = r[n], a = this._tracks[i];
        if (a) {
          var o = a.keyframes;
          if (o.length > 1) {
            var s = o.pop();
            a.addKeyframe(s.time, e[i]), a.prepare(this._maxTime, a.getAdditiveTrack());
          }
        }
      }
    }, t;
  }();
  function rc() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  var _Z = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this) || this;
      return n._running = false, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = false, r = r || {}, n.stage = r.stage || {}, n;
    }
    return e.prototype.addClip = function(r) {
      r.animation && this.removeClip(r), this._head ? (this._tail.next = r, r.prev = this._tail, r.next = null, this._tail = r) : this._head = this._tail = r, r.animation = this;
    }, e.prototype.addAnimator = function(r) {
      r.animation = this;
      var n = r.getClip();
      n && this.addClip(n);
    }, e.prototype.removeClip = function(r) {
      if (r.animation) {
        var n = r.prev, i = r.next;
        n ? n.next = i : this._head = i, i ? i.prev = n : this._tail = n, r.next = r.prev = r.animation = null;
      }
    }, e.prototype.removeAnimator = function(r) {
      var n = r.getClip();
      n && this.removeClip(n), r.animation = null;
    }, e.prototype.update = function(r) {
      for (var n = rc() - this._pausedTime, i = n - this._time, a = this._head; a; ) {
        var o = a.next, s = a.step(n, i);
        s && (a.ondestroy(), this.removeClip(a)), a = o;
      }
      this._time = n, r || (this.trigger("frame", i), this.stage.update && this.stage.update());
    }, e.prototype._startLoop = function() {
      var r = this;
      this._running = true;
      function n() {
        r._running && (Sg(n), !r._paused && r.update());
      }
      Sg(n);
    }, e.prototype.start = function() {
      this._running || (this._time = rc(), this._pausedTime = 0, this._startLoop());
    }, e.prototype.stop = function() {
      this._running = false;
    }, e.prototype.pause = function() {
      this._paused || (this._pauseStart = rc(), this._paused = true);
    }, e.prototype.resume = function() {
      this._paused && (this._pausedTime += rc() - this._pauseStart, this._paused = false);
    }, e.prototype.clear = function() {
      for (var r = this._head; r; ) {
        var n = r.next;
        r.prev = r.next = r.animation = null, r = n;
      }
      this._head = this._tail = null;
    }, e.prototype.isFinished = function() {
      return this._head == null;
    }, e.prototype.animate = function(r, n) {
      n = n || {}, this.start();
      var i = new tT(r, n.loop);
      return this.addAnimator(i), i;
    }, e;
  }(xi), bZ = 300, i0 = ct.domSupported, a0 = function() {
    var t = [
      "click",
      "dblclick",
      "mousewheel",
      "wheel",
      "mouseout",
      "mouseup",
      "mousedown",
      "mousemove",
      "contextmenu"
    ], e = [
      "touchstart",
      "touchend",
      "touchmove"
    ], r = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    }, n = oe(t, function(i) {
      var a = i.replace("mouse", "pointer");
      return r.hasOwnProperty(a) ? a : i;
    });
    return {
      mouse: t,
      touch: e,
      pointer: n
    };
  }(), GM = {
    mouse: [
      "mousemove",
      "mouseup"
    ],
    pointer: [
      "pointermove",
      "pointerup"
    ]
  }, WM = false;
  function mx(t) {
    var e = t.pointerType;
    return e === "pen" || e === "touch";
  }
  function xZ(t) {
    t.touching = true, t.touchTimer != null && (clearTimeout(t.touchTimer), t.touchTimer = null), t.touchTimer = setTimeout(function() {
      t.touching = false, t.touchTimer = null;
    }, 700);
  }
  function o0(t) {
    t && (t.zrByTouch = true);
  }
  function wZ(t, e) {
    return si(t.dom, new SZ(t, e), true);
  }
  function ZF(t, e) {
    for (var r = e, n = false; r && r.nodeType !== 9 && !(n = r.domBelongToZr || r !== e && r === t.painterRoot); ) r = r.parentNode;
    return n;
  }
  var SZ = /* @__PURE__ */ function() {
    function t(e, r) {
      this.stopPropagation = dr, this.stopImmediatePropagation = dr, this.preventDefault = dr, this.type = r.type, this.target = this.currentTarget = e.dom, this.pointerType = r.pointerType, this.clientX = r.clientX, this.clientY = r.clientY;
    }
    return t;
  }(), Ni = {
    mousedown: function(t) {
      t = si(this.dom, t), this.__mayPointerCapture = [
        t.zrX,
        t.zrY
      ], this.trigger("mousedown", t);
    },
    mousemove: function(t) {
      t = si(this.dom, t);
      var e = this.__mayPointerCapture;
      e && (t.zrX !== e[0] || t.zrY !== e[1]) && this.__togglePointerCapture(true), this.trigger("mousemove", t);
    },
    mouseup: function(t) {
      t = si(this.dom, t), this.__togglePointerCapture(false), this.trigger("mouseup", t);
    },
    mouseout: function(t) {
      t = si(this.dom, t);
      var e = t.toElement || t.relatedTarget;
      ZF(this, e) || (this.__pointerCapturing && (t.zrEventControl = "no_globalout"), this.trigger("mouseout", t));
    },
    wheel: function(t) {
      WM = true, t = si(this.dom, t), this.trigger("mousewheel", t);
    },
    mousewheel: function(t) {
      WM || (t = si(this.dom, t), this.trigger("mousewheel", t));
    },
    touchstart: function(t) {
      t = si(this.dom, t), o0(t), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(t, "start"), Ni.mousemove.call(this, t), Ni.mousedown.call(this, t);
    },
    touchmove: function(t) {
      t = si(this.dom, t), o0(t), this.handler.processGesture(t, "change"), Ni.mousemove.call(this, t);
    },
    touchend: function(t) {
      t = si(this.dom, t), o0(t), this.handler.processGesture(t, "end"), Ni.mouseup.call(this, t), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < bZ && Ni.click.call(this, t);
    },
    pointerdown: function(t) {
      Ni.mousedown.call(this, t);
    },
    pointermove: function(t) {
      mx(t) || Ni.mousemove.call(this, t);
    },
    pointerup: function(t) {
      Ni.mouseup.call(this, t);
    },
    pointerout: function(t) {
      mx(t) || Ni.mouseout.call(this, t);
    }
  };
  $([
    "click",
    "dblclick",
    "contextmenu"
  ], function(t) {
    Ni[t] = function(e) {
      e = si(this.dom, e), this.trigger(t, e);
    };
  });
  var yx = {
    pointermove: function(t) {
      mx(t) || yx.mousemove.call(this, t);
    },
    pointerup: function(t) {
      yx.mouseup.call(this, t);
    },
    mousemove: function(t) {
      this.trigger("mousemove", t);
    },
    mouseup: function(t) {
      var e = this.__pointerCapturing;
      this.__togglePointerCapture(false), this.trigger("mouseup", t), e && (t.zrEventControl = "only_globalout", this.trigger("mouseout", t));
    }
  };
  function TZ(t, e) {
    var r = e.domHandlers;
    ct.pointerEventsSupported ? $(a0.pointer, function(n) {
      tg(e, n, function(i) {
        r[n].call(t, i);
      });
    }) : (ct.touchEventsSupported && $(a0.touch, function(n) {
      tg(e, n, function(i) {
        r[n].call(t, i), xZ(e);
      });
    }), $(a0.mouse, function(n) {
      tg(e, n, function(i) {
        i = KS(i), e.touching || r[n].call(t, i);
      });
    }));
  }
  function CZ(t, e) {
    ct.pointerEventsSupported ? $(GM.pointer, r) : ct.touchEventsSupported || $(GM.mouse, r);
    function r(n) {
      function i(a) {
        a = KS(a), ZF(t, a.target) || (a = wZ(t, a), e.domHandlers[n].call(t, a));
      }
      tg(e, n, i, {
        capture: true
      });
    }
  }
  function tg(t, e, r, n) {
    t.mounted[e] = r, t.listenerOpts[e] = n, sx(t.domTarget, e, r, n);
  }
  function s0(t) {
    var e = t.mounted;
    for (var r in e) e.hasOwnProperty(r) && BK(t.domTarget, r, e[r], t.listenerOpts[r]);
    t.mounted = {};
  }
  var HM = /* @__PURE__ */ function() {
    function t(e, r) {
      this.mounted = {}, this.listenerOpts = {}, this.touching = false, this.domTarget = e, this.domHandlers = r;
    }
    return t;
  }(), AZ = function(t) {
    K(e, t);
    function e(r, n) {
      var i = t.call(this) || this;
      return i.__pointerCapturing = false, i.dom = r, i.painterRoot = n, i._localHandlerScope = new HM(r, Ni), i0 && (i._globalHandlerScope = new HM(document, yx)), TZ(i, i._localHandlerScope), i;
    }
    return e.prototype.dispose = function() {
      s0(this._localHandlerScope), i0 && s0(this._globalHandlerScope);
    }, e.prototype.setCursor = function(r) {
      this.dom.style && (this.dom.style.cursor = r || "default");
    }, e.prototype.__togglePointerCapture = function(r) {
      if (this.__mayPointerCapture = null, i0 && +this.__pointerCapturing ^ +r) {
        this.__pointerCapturing = r;
        var n = this._globalHandlerScope;
        r ? CZ(this, n) : s0(n);
      }
    }, e;
  }(xi), QF = 1;
  ct.hasGlobalWindow && (QF = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
  var Mg = QF, _x = 0.4, bx = "#333", xx = "#ccc", IZ = "#eee", UM = Nm, MZ = 5e-5;
  function ks(t) {
    return t > MZ || t < -5e-5;
  }
  var Ps = [], _u = [], l0 = Hn(), u0 = Math.abs, Qa = function() {
    function t() {
    }
    return t.prototype.getLocalTransform = function(e) {
      return t.getLocalTransform(this, e);
    }, t.prototype.setPosition = function(e) {
      this.x = e[0], this.y = e[1];
    }, t.prototype.setScale = function(e) {
      this.scaleX = e[0], this.scaleY = e[1];
    }, t.prototype.setSkew = function(e) {
      this.skewX = e[0], this.skewY = e[1];
    }, t.prototype.setOrigin = function(e) {
      this.originX = e[0], this.originY = e[1];
    }, t.prototype.needLocalTransform = function() {
      return ks(this.rotation) || ks(this.x) || ks(this.y) || ks(this.scaleX - 1) || ks(this.scaleY - 1) || ks(this.skewX) || ks(this.skewY);
    }, t.prototype.updateTransform = function() {
      var e = this.parent && this.parent.transform, r = this.needLocalTransform(), n = this.transform;
      if (!(r || e)) {
        n && (UM(n), this.invTransform = null);
        return;
      }
      n = n || Hn(), r ? this.getLocalTransform(n) : UM(n), e && (r ? io(n, e, n) : ZS(n, e)), this.transform = n, this._resolveGlobalScaleRatio(n);
    }, t.prototype._resolveGlobalScaleRatio = function(e) {
      var r = this.globalScaleRatio;
      if (r != null && r !== 1) {
        this.getGlobalScale(Ps);
        var n = Ps[0] < 0 ? -1 : 1, i = Ps[1] < 0 ? -1 : 1, a = ((Ps[0] - n) * r + n) / Ps[0] || 0, o = ((Ps[1] - i) * r + i) / Ps[1] || 0;
        e[0] *= a, e[1] *= a, e[2] *= o, e[3] *= o;
      }
      this.invTransform = this.invTransform || Hn(), zc(this.invTransform, e);
    }, t.prototype.getComputedTransform = function() {
      for (var e = this, r = []; e; ) r.push(e), e = e.parent;
      for (; e = r.pop(); ) e.updateTransform();
      return this.transform;
    }, t.prototype.setLocalTransform = function(e) {
      if (e) {
        var r = e[0] * e[0] + e[1] * e[1], n = e[2] * e[2] + e[3] * e[3], i = Math.atan2(e[1], e[0]), a = Math.PI / 2 + i - Math.atan2(e[3], e[2]);
        n = Math.sqrt(n) * Math.cos(a), r = Math.sqrt(r), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +e[4], this.y = +e[5], this.scaleX = r, this.scaleY = n, this.originX = 0, this.originY = 0;
      }
    }, t.prototype.decomposeTransform = function() {
      if (this.transform) {
        var e = this.parent, r = this.transform;
        e && e.transform && (e.invTransform = e.invTransform || Hn(), io(_u, e.invTransform, r), r = _u);
        var n = this.originX, i = this.originY;
        (n || i) && (l0[4] = n, l0[5] = i, io(_u, r, l0), _u[4] -= n, _u[5] -= i, r = _u), this.setLocalTransform(r);
      }
    }, t.prototype.getGlobalScale = function(e) {
      var r = this.transform;
      return e = e || [], r ? (e[0] = Math.sqrt(r[0] * r[0] + r[1] * r[1]), e[1] = Math.sqrt(r[2] * r[2] + r[3] * r[3]), r[0] < 0 && (e[0] = -e[0]), r[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e);
    }, t.prototype.transformCoordToLocal = function(e, r) {
      var n = [
        e,
        r
      ], i = this.invTransform;
      return i && Ur(n, n, i), n;
    }, t.prototype.transformCoordToGlobal = function(e, r) {
      var n = [
        e,
        r
      ], i = this.transform;
      return i && Ur(n, n, i), n;
    }, t.prototype.getLineScale = function() {
      var e = this.transform;
      return e && u0(e[0] - 1) > 1e-10 && u0(e[3] - 1) > 1e-10 ? Math.sqrt(u0(e[0] * e[3] - e[2] * e[1])) : 1;
    }, t.prototype.copyTransform = function(e) {
      JF(this, e);
    }, t.getLocalTransform = function(e, r) {
      r = r || [];
      var n = e.originX || 0, i = e.originY || 0, a = e.scaleX, o = e.scaleY, s = e.anchorX, l = e.anchorY, u = e.rotation || 0, c = e.x, h = e.y, f = e.skewX ? Math.tan(e.skewX) : 0, d = e.skewY ? Math.tan(-e.skewY) : 0;
      if (n || i || s || l) {
        var p = n + s, v = i + l;
        r[4] = -p * a - f * v * o, r[5] = -v * o - d * p * a;
      } else r[4] = r[5] = 0;
      return r[0] = a, r[3] = o, r[1] = d * a, r[2] = f * o, u && nu(r, r, u), r[4] += n + c, r[5] += i + h, r;
    }, t.initDefaultProps = function() {
      var e = t.prototype;
      e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0;
    }(), t;
  }(), La = [
    "x",
    "y",
    "originX",
    "originY",
    "anchorX",
    "anchorY",
    "rotation",
    "scaleX",
    "scaleY",
    "skewX",
    "skewY"
  ];
  function JF(t, e) {
    for (var r = 0; r < La.length; r++) {
      var n = La[r];
      t[n] = e[n];
    }
  }
  var YM = {};
  function Yn(t, e) {
    e = e || cs;
    var r = YM[e];
    r || (r = YM[e] = new Md(500));
    var n = r.get(t);
    return n == null && (n = hs.measureText(t, e).width, r.put(t, n)), n;
  }
  function qM(t, e, r, n) {
    var i = Yn(t, e), a = zm(e), o = Qh(0, i, r), s = Yu(0, a, n), l = new Ze(o, s, i, a);
    return l;
  }
  function Dd(t, e, r, n) {
    var i = ((t || "") + "").split(`
`), a = i.length;
    if (a === 1) return qM(i[0], e, r, n);
    for (var o = new Ze(0, 0, 0, 0), s = 0; s < i.length; s++) {
      var l = qM(i[s], e, r, n);
      s === 0 ? o.copy(l) : o.union(l);
    }
    return o;
  }
  function Qh(t, e, r) {
    return r === "right" ? t -= e : r === "center" && (t -= e / 2), t;
  }
  function Yu(t, e, r) {
    return r === "middle" ? t -= e / 2 : r === "bottom" && (t -= e), t;
  }
  function zm(t) {
    return Yn("\u56FD", t);
  }
  function ji(t, e) {
    return typeof t == "string" ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t;
  }
  function Dg(t, e, r) {
    var n = e.position || "inside", i = e.distance != null ? e.distance : 5, a = r.height, o = r.width, s = a / 2, l = r.x, u = r.y, c = "left", h = "top";
    if (n instanceof Array) l += ji(n[0], r.width), u += ji(n[1], r.height), c = null, h = null;
    else switch (n) {
      case "left":
        l -= i, u += s, c = "right", h = "middle";
        break;
      case "right":
        l += i + o, u += s, h = "middle";
        break;
      case "top":
        l += o / 2, u -= i, c = "center", h = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + i, c = "center";
        break;
      case "inside":
        l += o / 2, u += s, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += i, u += s, h = "middle";
        break;
      case "insideRight":
        l += o - i, u += s, c = "right", h = "middle";
        break;
      case "insideTop":
        l += o / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - i, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += o - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += a - i, h = "bottom";
        break;
      case "insideBottomRight":
        l += o - i, u += a - i, c = "right", h = "bottom";
        break;
    }
    return t = t || {}, t.x = l, t.y = u, t.align = c, t.verticalAlign = h, t;
  }
  var c0 = "__zr_normal__", h0 = La.concat([
    "ignore"
  ]), DZ = ka(La, function(t, e) {
    return t[e] = true, t;
  }, {
    ignore: false
  }), bu = {}, EZ = new Ze(0, 0, 0, 0), Fm = function() {
    function t(e) {
      this.id = AF(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e);
    }
    return t.prototype._init = function(e) {
      this.attr(e);
    }, t.prototype.drift = function(e, r, n) {
      switch (this.draggable) {
        case "horizontal":
          r = 0;
          break;
        case "vertical":
          e = 0;
          break;
      }
      var i = this.transform;
      i || (i = this.transform = [
        1,
        0,
        0,
        1,
        0,
        0
      ]), i[4] += e, i[5] += r, this.decomposeTransform(), this.markRedraw();
    }, t.prototype.beforeUpdate = function() {
    }, t.prototype.afterUpdate = function() {
    }, t.prototype.update = function() {
      this.updateTransform(), this.__dirty && this.updateInnerText();
    }, t.prototype.updateInnerText = function(e) {
      var r = this._textContent;
      if (r && (!r.ignore || e)) {
        this.textConfig || (this.textConfig = {});
        var n = this.textConfig, i = n.local, a = r.innerTransformable, o = void 0, s = void 0, l = false;
        a.parent = i ? this : null;
        var u = false;
        if (a.copyTransform(r), n.position != null) {
          var c = EZ;
          n.layoutRect ? c.copy(n.layoutRect) : c.copy(this.getBoundingRect()), i || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(bu, n, c) : Dg(bu, n, c), a.x = bu.x, a.y = bu.y, o = bu.align, s = bu.verticalAlign;
          var h = n.origin;
          if (h && n.rotation != null) {
            var f = void 0, d = void 0;
            h === "center" ? (f = c.width * 0.5, d = c.height * 0.5) : (f = ji(h[0], c.width), d = ji(h[1], c.height)), u = true, a.originX = -a.x + f + (i ? 0 : c.x), a.originY = -a.y + d + (i ? 0 : c.y);
          }
        }
        n.rotation != null && (a.rotation = n.rotation);
        var p = n.offset;
        p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
        var v = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, g = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), m = void 0, y = void 0, _ = void 0;
        v && this.canBeInsideText() ? (m = n.insideFill, y = n.insideStroke, (m == null || m === "auto") && (m = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(m), _ = true)) : (m = n.outsideFill, y = n.outsideStroke, (m == null || m === "auto") && (m = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(m), _ = true)), m = m || "#000", (m !== g.fill || y !== g.stroke || _ !== g.autoStroke || o !== g.align || s !== g.verticalAlign) && (l = true, g.fill = m, g.stroke = y, g.autoStroke = _, g.align = o, g.verticalAlign = s, r.setDefaultTextStyle(g)), r.__dirty |= Ia, l && r.dirtyStyle(true);
      }
    }, t.prototype.canBeInsideText = function() {
      return true;
    }, t.prototype.getInsideTextFill = function() {
      return "#fff";
    }, t.prototype.getInsideTextStroke = function(e) {
      return "#000";
    }, t.prototype.getOutsideFill = function() {
      return this.__zr && this.__zr.isDarkMode() ? xx : bx;
    }, t.prototype.getOutsideStroke = function(e) {
      var r = this.__zr && this.__zr.getBackgroundColor(), n = typeof r == "string" && Un(r);
      n || (n = [
        255,
        255,
        255,
        1
      ]);
      for (var i = n[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++) n[o] = n[o] * i + (a ? 0 : 255) * (1 - i);
      return n[3] = 1, ao(n, "rgba");
    }, t.prototype.traverse = function(e, r) {
    }, t.prototype.attrKV = function(e, r) {
      e === "textConfig" ? this.setTextConfig(r) : e === "textContent" ? this.setTextContent(r) : e === "clipPath" ? this.setClipPath(r) : e === "extra" ? (this.extra = this.extra || {}, te(this.extra, r)) : this[e] = r;
    }, t.prototype.hide = function() {
      this.ignore = true, this.markRedraw();
    }, t.prototype.show = function() {
      this.ignore = false, this.markRedraw();
    }, t.prototype.attr = function(e, r) {
      if (typeof e == "string") this.attrKV(e, r);
      else if (Le(e)) for (var n = e, i = gt(n), a = 0; a < i.length; a++) {
        var o = i[a];
        this.attrKV(o, e[o]);
      }
      return this.markRedraw(), this;
    }, t.prototype.saveCurrentToNormalState = function(e) {
      this._innerSaveToNormal(e);
      for (var r = this._normalState, n = 0; n < this.animators.length; n++) {
        var i = this.animators[n], a = i.__fromStateTransition;
        if (!(i.getLoop() || a && a !== c0)) {
          var o = i.targetName, s = o ? r[o] : r;
          i.saveTo(s);
        }
      }
    }, t.prototype._innerSaveToNormal = function(e) {
      var r = this._normalState;
      r || (r = this._normalState = {}), e.textConfig && !r.textConfig && (r.textConfig = this.textConfig), this._savePrimaryToNormal(e, r, h0);
    }, t.prototype._savePrimaryToNormal = function(e, r, n) {
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        e[a] != null && !(a in r) && (r[a] = this[a]);
      }
    }, t.prototype.hasState = function() {
      return this.currentStates.length > 0;
    }, t.prototype.getState = function(e) {
      return this.states[e];
    }, t.prototype.ensureState = function(e) {
      var r = this.states;
      return r[e] || (r[e] = {}), r[e];
    }, t.prototype.clearStates = function(e) {
      this.useState(c0, false, e);
    }, t.prototype.useState = function(e, r, n, i) {
      var a = e === c0, o = this.hasState();
      if (!(!o && a)) {
        var s = this.currentStates, l = this.stateTransition;
        if (!(et(s, e) >= 0 && (r || s.length === 1))) {
          var u;
          if (this.stateProxy && !a && (u = this.stateProxy(e)), u || (u = this.states && this.states[e]), !u && !a) {
            YS("State " + e + " not exists.");
            return;
          }
          a || this.saveCurrentToNormalState(u);
          var c = !!(u && u.hoverLayer || i);
          c && this._toggleHoverLayerFlag(true), this._applyStateObj(e, u, this._normalState, r, !n && !this.__inHover && l && l.duration > 0, l);
          var h = this._textContent, f = this._textGuide;
          return h && h.useState(e, r, n, c), f && f.useState(e, r, n, c), a ? (this.currentStates = [], this._normalState = {}) : r ? this.currentStates.push(e) : this.currentStates = [
            e
          ], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= -2), u;
        }
      }
    }, t.prototype.useStates = function(e, r, n) {
      if (!e.length) this.clearStates();
      else {
        var i = [], a = this.currentStates, o = e.length, s = o === a.length;
        if (s) {
          for (var l = 0; l < o; l++) if (e[l] !== a[l]) {
            s = false;
            break;
          }
        }
        if (s) return;
        for (var l = 0; l < o; l++) {
          var u = e[l], c = void 0;
          this.stateProxy && (c = this.stateProxy(u, e)), c || (c = this.states[u]), c && i.push(c);
        }
        var h = i[o - 1], f = !!(h && h.hoverLayer || n);
        f && this._toggleHoverLayerFlag(true);
        var d = this._mergeStates(i), p = this.stateTransition;
        this.saveCurrentToNormalState(d), this._applyStateObj(e.join(","), d, this._normalState, false, !r && !this.__inHover && p && p.duration > 0, p);
        var v = this._textContent, g = this._textGuide;
        v && v.useStates(e, r, f), g && g.useStates(e, r, f), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= -2);
      }
    }, t.prototype.isSilent = function() {
      for (var e = this.silent, r = this.parent; !e && r; ) {
        if (r.silent) {
          e = true;
          break;
        }
        r = r.parent;
      }
      return e;
    }, t.prototype._updateAnimationTargets = function() {
      for (var e = 0; e < this.animators.length; e++) {
        var r = this.animators[e];
        r.targetName && r.changeTarget(this[r.targetName]);
      }
    }, t.prototype.removeState = function(e) {
      var r = et(this.currentStates, e);
      if (r >= 0) {
        var n = this.currentStates.slice();
        n.splice(r, 1), this.useStates(n);
      }
    }, t.prototype.replaceState = function(e, r, n) {
      var i = this.currentStates.slice(), a = et(i, e), o = et(i, r) >= 0;
      a >= 0 ? o ? i.splice(a, 1) : i[a] = r : n && !o && i.push(r), this.useStates(i);
    }, t.prototype.toggleState = function(e, r) {
      r ? this.useState(e, true) : this.removeState(e);
    }, t.prototype._mergeStates = function(e) {
      for (var r = {}, n, i = 0; i < e.length; i++) {
        var a = e[i];
        te(r, a), a.textConfig && (n = n || {}, te(n, a.textConfig));
      }
      return n && (r.textConfig = n), r;
    }, t.prototype._applyStateObj = function(e, r, n, i, a, o) {
      var s = !(r && i);
      r && r.textConfig ? (this.textConfig = te({}, i ? this.textConfig : n.textConfig), te(this.textConfig, r.textConfig)) : s && n.textConfig && (this.textConfig = n.textConfig);
      for (var l = {}, u = false, c = 0; c < h0.length; c++) {
        var h = h0[c], f = a && DZ[h];
        r && r[h] != null ? f ? (u = true, l[h] = r[h]) : this[h] = r[h] : s && n[h] != null && (f ? (u = true, l[h] = n[h]) : this[h] = n[h]);
      }
      if (!a) for (var c = 0; c < this.animators.length; c++) {
        var d = this.animators[c], p = d.targetName;
        d.getLoop() || d.__changeFinalValue(p ? (r || n)[p] : r || n);
      }
      u && this._transitionState(e, l, o);
    }, t.prototype._attachComponent = function(e) {
      if (!(e.__zr && !e.__hostTarget) && e !== this) {
        var r = this.__zr;
        r && e.addSelfToZr(r), e.__zr = r, e.__hostTarget = this;
      }
    }, t.prototype._detachComponent = function(e) {
      e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null;
    }, t.prototype.getClipPath = function() {
      return this._clipPath;
    }, t.prototype.setClipPath = function(e) {
      this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw();
    }, t.prototype.removeClipPath = function() {
      var e = this._clipPath;
      e && (this._detachComponent(e), this._clipPath = null, this.markRedraw());
    }, t.prototype.getTextContent = function() {
      return this._textContent;
    }, t.prototype.setTextContent = function(e) {
      var r = this._textContent;
      r !== e && (r && r !== e && this.removeTextContent(), e.innerTransformable = new Qa(), this._attachComponent(e), this._textContent = e, this.markRedraw());
    }, t.prototype.setTextConfig = function(e) {
      this.textConfig || (this.textConfig = {}), te(this.textConfig, e), this.markRedraw();
    }, t.prototype.removeTextConfig = function() {
      this.textConfig = null, this.markRedraw();
    }, t.prototype.removeTextContent = function() {
      var e = this._textContent;
      e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
    }, t.prototype.getTextGuideLine = function() {
      return this._textGuide;
    }, t.prototype.setTextGuideLine = function(e) {
      this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw();
    }, t.prototype.removeTextGuideLine = function() {
      var e = this._textGuide;
      e && (this._detachComponent(e), this._textGuide = null, this.markRedraw());
    }, t.prototype.markRedraw = function() {
      this.__dirty |= Ia;
      var e = this.__zr;
      e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
    }, t.prototype.dirty = function() {
      this.markRedraw();
    }, t.prototype._toggleHoverLayerFlag = function(e) {
      this.__inHover = e;
      var r = this._textContent, n = this._textGuide;
      r && (r.__inHover = e), n && (n.__inHover = e);
    }, t.prototype.addSelfToZr = function(e) {
      if (this.__zr !== e) {
        this.__zr = e;
        var r = this.animators;
        if (r) for (var n = 0; n < r.length; n++) e.animation.addAnimator(r[n]);
        this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e);
      }
    }, t.prototype.removeSelfFromZr = function(e) {
      if (this.__zr) {
        this.__zr = null;
        var r = this.animators;
        if (r) for (var n = 0; n < r.length; n++) e.animation.removeAnimator(r[n]);
        this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e);
      }
    }, t.prototype.animate = function(e, r, n) {
      var i = e ? this[e] : this, a = new tT(i, r, n);
      return e && (a.targetName = e), this.addAnimator(a, e), a;
    }, t.prototype.addAnimator = function(e, r) {
      var n = this.__zr, i = this;
      e.during(function() {
        i.updateDuringAnimation(r);
      }).done(function() {
        var a = i.animators, o = et(a, e);
        o >= 0 && a.splice(o, 1);
      }), this.animators.push(e), n && n.animation.addAnimator(e), n && n.wakeUp();
    }, t.prototype.updateDuringAnimation = function(e) {
      this.markRedraw();
    }, t.prototype.stopAnimation = function(e, r) {
      for (var n = this.animators, i = n.length, a = [], o = 0; o < i; o++) {
        var s = n[o];
        !e || e === s.scope ? s.stop(r) : a.push(s);
      }
      return this.animators = a, this;
    }, t.prototype.animateTo = function(e, r, n) {
      f0(this, e, r, n);
    }, t.prototype.animateFrom = function(e, r, n) {
      f0(this, e, r, n, true);
    }, t.prototype._transitionState = function(e, r, n, i) {
      for (var a = f0(this, r, n, i), o = 0; o < a.length; o++) a[o].__fromStateTransition = e;
    }, t.prototype.getBoundingRect = function() {
      return null;
    }, t.prototype.getPaintRect = function() {
      return null;
    }, t.initDefaultProps = function() {
      var e = t.prototype;
      e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = false, e.__dirty = Ia;
      function r(n, i, a, o) {
        Object.defineProperty(e, n, {
          get: function() {
            if (!this[i]) {
              var l = this[i] = [];
              s(this, l);
            }
            return this[i];
          },
          set: function(l) {
            this[a] = l[0], this[o] = l[1], this[i] = l, s(this, l);
          }
        });
        function s(l, u) {
          Object.defineProperty(u, 0, {
            get: function() {
              return l[a];
            },
            set: function(c) {
              l[a] = c;
            }
          }), Object.defineProperty(u, 1, {
            get: function() {
              return l[o];
            },
            set: function(c) {
              l[o] = c;
            }
          });
        }
      }
      Object.defineProperty && (r("position", "_legacyPos", "x", "y"), r("scale", "_legacyScale", "scaleX", "scaleY"), r("origin", "_legacyOrigin", "originX", "originY"));
    }(), t;
  }();
  yr(Fm, xi);
  yr(Fm, Qa);
  function f0(t, e, r, n, i) {
    r = r || {};
    var a = [];
    e4(t, "", t, e, r, n, a, i);
    var o = a.length, s = false, l = r.done, u = r.aborted, c = function() {
      s = true, o--, o <= 0 && (s ? l && l() : u && u());
    }, h = function() {
      o--, o <= 0 && (s ? l && l() : u && u());
    };
    o || l && l(), a.length > 0 && r.during && a[0].during(function(p, v) {
      r.during(v);
    });
    for (var f = 0; f < a.length; f++) {
      var d = a[f];
      c && d.done(c), h && d.aborted(h), r.force && d.duration(r.duration), d.start(r.easing);
    }
    return a;
  }
  function d0(t, e, r) {
    for (var n = 0; n < r; n++) t[n] = e[n];
  }
  function kZ(t) {
    return on(t[0]);
  }
  function PZ(t, e, r) {
    if (on(e[r])) if (on(t[r]) || (t[r] = []), $n(e[r])) {
      var n = e[r].length;
      t[r].length !== n && (t[r] = new e[r].constructor(n), d0(t[r], e[r], n));
    } else {
      var i = e[r], a = t[r], o = i.length;
      if (kZ(i)) for (var s = i[0].length, l = 0; l < o; l++) a[l] ? d0(a[l], i[l], s) : a[l] = Array.prototype.slice.call(i[l]);
      else d0(a, i, o);
      a.length = i.length;
    }
    else t[r] = e[r];
  }
  function LZ(t, e) {
    return t === e || on(t) && on(e) && $Z(t, e);
  }
  function $Z(t, e) {
    var r = t.length;
    if (r !== e.length) return false;
    for (var n = 0; n < r; n++) if (t[n] !== e[n]) return false;
    return true;
  }
  function e4(t, e, r, n, i, a, o, s) {
    for (var l = gt(n), u = i.duration, c = i.delay, h = i.additive, f = i.setToFinal, d = !Le(a), p = t.animators, v = [], g = 0; g < l.length; g++) {
      var m = l[g], y = n[m];
      if (y != null && r[m] != null && (d || a[m])) if (Le(y) && !on(y) && !Rm(y)) {
        if (e) {
          s || (r[m] = y, t.updateDuringAnimation(e));
          continue;
        }
        e4(t, m, r[m], y, i, a && a[m], o, s);
      } else v.push(m);
      else s || (r[m] = y, t.updateDuringAnimation(e), v.push(m));
    }
    var _ = v.length;
    if (!h && _) for (var b = 0; b < p.length; b++) {
      var w = p[b];
      if (w.targetName === e) {
        var x = w.stopTracks(v);
        if (x) {
          var T = et(p, w);
          p.splice(T, 1);
        }
      }
    }
    if (i.force || (v = Dt(v, function(k) {
      return !LZ(n[k], r[k]);
    }), _ = v.length), _ > 0 || i.force && !o.length) {
      var A = void 0, I = void 0, M = void 0;
      if (s) {
        I = {}, f && (A = {});
        for (var b = 0; b < _; b++) {
          var m = v[b];
          I[m] = r[m], f ? A[m] = n[m] : r[m] = n[m];
        }
      } else if (f) {
        M = {};
        for (var b = 0; b < _; b++) {
          var m = v[b];
          M[m] = bf(r[m]), PZ(r, n, m);
        }
      }
      var w = new tT(r, false, false, h ? Dt(p, function(B) {
        return B.targetName === e;
      }) : null);
      w.targetName = e, i.scope && (w.scope = i.scope), f && A && w.whenWithKeys(0, A, v), M && w.whenWithKeys(0, M, v), w.whenWithKeys(u ?? 500, s ? I : n, v).delay(c || 0), t.addAnimator(w, e), o.push(w);
    }
  }
  var Be = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this) || this;
      return n.isGroup = true, n._children = [], n.attr(r), n;
    }
    return e.prototype.childrenRef = function() {
      return this._children;
    }, e.prototype.children = function() {
      return this._children.slice();
    }, e.prototype.childAt = function(r) {
      return this._children[r];
    }, e.prototype.childOfName = function(r) {
      for (var n = this._children, i = 0; i < n.length; i++) if (n[i].name === r) return n[i];
    }, e.prototype.childCount = function() {
      return this._children.length;
    }, e.prototype.add = function(r) {
      return r && r !== this && r.parent !== this && (this._children.push(r), this._doAdd(r)), this;
    }, e.prototype.addBefore = function(r, n) {
      if (r && r !== this && r.parent !== this && n && n.parent === this) {
        var i = this._children, a = i.indexOf(n);
        a >= 0 && (i.splice(a, 0, r), this._doAdd(r));
      }
      return this;
    }, e.prototype.replace = function(r, n) {
      var i = et(this._children, r);
      return i >= 0 && this.replaceAt(n, i), this;
    }, e.prototype.replaceAt = function(r, n) {
      var i = this._children, a = i[n];
      if (r && r !== this && r.parent !== this && r !== a) {
        i[n] = r, a.parent = null;
        var o = this.__zr;
        o && a.removeSelfFromZr(o), this._doAdd(r);
      }
      return this;
    }, e.prototype._doAdd = function(r) {
      r.parent && r.parent.remove(r), r.parent = this;
      var n = this.__zr;
      n && n !== r.__zr && r.addSelfToZr(n), n && n.refresh();
    }, e.prototype.remove = function(r) {
      var n = this.__zr, i = this._children, a = et(i, r);
      return a < 0 ? this : (i.splice(a, 1), r.parent = null, n && r.removeSelfFromZr(n), n && n.refresh(), this);
    }, e.prototype.removeAll = function() {
      for (var r = this._children, n = this.__zr, i = 0; i < r.length; i++) {
        var a = r[i];
        n && a.removeSelfFromZr(n), a.parent = null;
      }
      return r.length = 0, this;
    }, e.prototype.eachChild = function(r, n) {
      for (var i = this._children, a = 0; a < i.length; a++) {
        var o = i[a];
        r.call(n, o, a);
      }
      return this;
    }, e.prototype.traverse = function(r, n) {
      for (var i = 0; i < this._children.length; i++) {
        var a = this._children[i], o = r.call(n, a);
        a.isGroup && !o && a.traverse(r, n);
      }
      return this;
    }, e.prototype.addSelfToZr = function(r) {
      t.prototype.addSelfToZr.call(this, r);
      for (var n = 0; n < this._children.length; n++) {
        var i = this._children[n];
        i.addSelfToZr(r);
      }
    }, e.prototype.removeSelfFromZr = function(r) {
      t.prototype.removeSelfFromZr.call(this, r);
      for (var n = 0; n < this._children.length; n++) {
        var i = this._children[n];
        i.removeSelfFromZr(r);
      }
    }, e.prototype.getBoundingRect = function(r) {
      for (var n = new Ze(0, 0, 0, 0), i = r || this._children, a = [], o = null, s = 0; s < i.length; s++) {
        var l = i[s];
        if (!(l.ignore || l.invisible)) {
          var u = l.getBoundingRect(), c = l.getLocalTransform(a);
          c ? (Ze.applyTransform(n, u, c), o = o || n.clone(), o.union(n)) : (o = o || u.clone(), o.union(u));
        }
      }
      return o || n;
    }, e;
  }(Fm);
  Be.prototype.type = "group";
  var rg = {}, t4 = {};
  function RZ(t) {
    delete t4[t];
  }
  function OZ(t) {
    if (!t) return false;
    if (typeof t == "string") return Ag(t, 1) < _x;
    if (t.colorStops) {
      for (var e = t.colorStops, r = 0, n = e.length, i = 0; i < n; i++) r += Ag(e[i].color, 1);
      return r /= n, r < _x;
    }
    return false;
  }
  var NZ = function() {
    function t(e, r, n) {
      var i = this;
      this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = true, this._needsRefreshHover = true, this._darkMode = false, n = n || {}, this.dom = r, this.id = e;
      var a = new KK(), o = n.renderer || "canvas";
      rg[o] || (o = gt(rg)[0]), n.useDirtyRect = n.useDirtyRect == null ? false : n.useDirtyRect;
      var s = new rg[o](r, a, n, e), l = n.ssr || s.ssrOnly;
      this.storage = a, this.painter = s;
      var u = !ct.node && !ct.worker && !l ? new AZ(s.getViewportRoot(), s.root) : null, c = n.useCoarsePointer, h = c == null || c === "auto" ? ct.touchEventsSupported : !!c, f = 44, d;
      h && (d = We(n.pointerSize, f)), this.handler = new PF(a, s, u, s.root, d), this.animation = new _Z({
        stage: {
          update: l ? null : function() {
            return i._flush(true);
          }
        }
      }), l || this.animation.start();
    }
    return t.prototype.add = function(e) {
      this._disposed || !e || (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh());
    }, t.prototype.remove = function(e) {
      this._disposed || !e || (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh());
    }, t.prototype.configLayer = function(e, r) {
      this._disposed || (this.painter.configLayer && this.painter.configLayer(e, r), this.refresh());
    }, t.prototype.setBackgroundColor = function(e) {
      this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = OZ(e));
    }, t.prototype.getBackgroundColor = function() {
      return this._backgroundColor;
    }, t.prototype.setDarkMode = function(e) {
      this._darkMode = e;
    }, t.prototype.isDarkMode = function() {
      return this._darkMode;
    }, t.prototype.refreshImmediately = function(e) {
      this._disposed || (e || this.animation.update(true), this._needsRefresh = false, this.painter.refresh(), this._needsRefresh = false);
    }, t.prototype.refresh = function() {
      this._disposed || (this._needsRefresh = true, this.animation.start());
    }, t.prototype.flush = function() {
      this._disposed || this._flush(false);
    }, t.prototype._flush = function(e) {
      var r, n = rc();
      this._needsRefresh && (r = true, this.refreshImmediately(e)), this._needsRefreshHover && (r = true, this.refreshHoverImmediately());
      var i = rc();
      r ? (this._stillFrameAccum = 0, this.trigger("rendered", {
        elapsedTime: i - n
      })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
    }, t.prototype.setSleepAfterStill = function(e) {
      this._sleepAfterStill = e;
    }, t.prototype.wakeUp = function() {
      this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
    }, t.prototype.refreshHover = function() {
      this._needsRefreshHover = true;
    }, t.prototype.refreshHoverImmediately = function() {
      this._disposed || (this._needsRefreshHover = false, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
    }, t.prototype.resize = function(e) {
      this._disposed || (e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize());
    }, t.prototype.clearAnimation = function() {
      this._disposed || this.animation.clear();
    }, t.prototype.getWidth = function() {
      if (!this._disposed) return this.painter.getWidth();
    }, t.prototype.getHeight = function() {
      if (!this._disposed) return this.painter.getHeight();
    }, t.prototype.setCursorStyle = function(e) {
      this._disposed || this.handler.setCursorStyle(e);
    }, t.prototype.findHover = function(e, r) {
      if (!this._disposed) return this.handler.findHover(e, r);
    }, t.prototype.on = function(e, r, n) {
      return this._disposed || this.handler.on(e, r, n), this;
    }, t.prototype.off = function(e, r) {
      this._disposed || this.handler.off(e, r);
    }, t.prototype.trigger = function(e, r) {
      this._disposed || this.handler.trigger(e, r);
    }, t.prototype.clear = function() {
      if (!this._disposed) {
        for (var e = this.storage.getRoots(), r = 0; r < e.length; r++) e[r] instanceof Be && e[r].removeSelfFromZr(this);
        this.storage.delAllRoots(), this.painter.clear();
      }
    }, t.prototype.dispose = function() {
      this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = true, RZ(this.id));
    }, t;
  }();
  function XM(t, e) {
    var r = new NZ(AF(), t, e);
    return t4[r.id] = r, r;
  }
  function BZ(t, e) {
    rg[t] = e;
  }
  var Sx;
  function zZ(t) {
    if (typeof Sx == "function") return Sx(t);
  }
  function FZ(t) {
    Sx = t;
  }
  var VZ = 1e-4, r4 = 20;
  function GZ(t) {
    return t.replace(/^\s+|\s+$/g, "");
  }
  function Et(t, e, r, n) {
    var i = e[0], a = e[1], o = r[0], s = r[1], l = a - i, u = s - o;
    if (l === 0) return u === 0 ? o : (o + s) / 2;
    if (n) if (l > 0) {
      if (t <= i) return o;
      if (t >= a) return s;
    } else {
      if (t >= i) return o;
      if (t <= a) return s;
    }
    else {
      if (t === i) return o;
      if (t === a) return s;
    }
    return (t - i) / l * u + o;
  }
  function pe(t, e) {
    switch (t) {
      case "center":
      case "middle":
        t = "50%";
        break;
      case "left":
      case "top":
        t = "0%";
        break;
      case "right":
      case "bottom":
        t = "100%";
        break;
    }
    return me(t) ? GZ(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : t == null ? NaN : +t;
  }
  function lr(t, e, r) {
    return e == null && (e = 10), e = Math.min(Math.max(0, e), r4), t = (+t).toFixed(e), r ? t : +t;
  }
  function mi(t) {
    return t.sort(function(e, r) {
      return e - r;
    }), t;
  }
  function wa(t) {
    if (t = +t, isNaN(t)) return 0;
    if (t > 1e-14) {
      for (var e = 1, r = 0; r < 15; r++, e *= 10) if (Math.round(t * e) / e === t) return r;
    }
    return WZ(t);
  }
  function WZ(t) {
    var e = t.toString().toLowerCase(), r = e.indexOf("e"), n = r > 0 ? +e.slice(r + 1) : 0, i = r > 0 ? r : e.length, a = e.indexOf("."), o = a < 0 ? 0 : i - 1 - a;
    return Math.max(0, o - n);
  }
  function n4(t, e) {
    var r = Math.log, n = Math.LN10, i = Math.floor(r(t[1] - t[0]) / n), a = Math.round(r(Math.abs(e[1] - e[0])) / n), o = Math.min(Math.max(-i + a, 0), 20);
    return isFinite(o) ? o : 20;
  }
  function HZ(t, e) {
    var r = ka(t, function(d, p) {
      return d + (isNaN(p) ? 0 : p);
    }, 0);
    if (r === 0) return [];
    for (var n = Math.pow(10, e), i = oe(t, function(d) {
      return (isNaN(d) ? 0 : d) / r * n * 100;
    }), a = n * 100, o = oe(i, function(d) {
      return Math.floor(d);
    }), s = ka(o, function(d, p) {
      return d + p;
    }, 0), l = oe(i, function(d, p) {
      return d - o[p];
    }); s < a; ) {
      for (var u = Number.NEGATIVE_INFINITY, c = null, h = 0, f = l.length; h < f; ++h) l[h] > u && (u = l[h], c = h);
      ++o[c], l[c] = 0, ++s;
    }
    return oe(o, function(d) {
      return d / n;
    });
  }
  function UZ(t, e) {
    var r = Math.max(wa(t), wa(e)), n = t + e;
    return r > r4 ? n : lr(n, r);
  }
  var jM = 9007199254740991;
  function i4(t) {
    var e = Math.PI * 2;
    return (t % e + e) % e;
  }
  function Uf(t) {
    return t > -1e-4 && t < VZ;
  }
  var YZ = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function $a(t) {
    if (t instanceof Date) return t;
    if (me(t)) {
      var e = YZ.exec(t);
      if (!e) return /* @__PURE__ */ new Date(NaN);
      if (e[8]) {
        var r = +e[4] || 0;
        return e[8].toUpperCase() !== "Z" && (r -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, r, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0));
      } else return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0);
    } else if (t == null) return /* @__PURE__ */ new Date(NaN);
    return new Date(Math.round(t));
  }
  function qZ(t) {
    return Math.pow(10, rT(t));
  }
  function rT(t) {
    if (t === 0) return 0;
    var e = Math.floor(Math.log(t) / Math.LN10);
    return t / Math.pow(10, e) >= 10 && e++, e;
  }
  function a4(t, e) {
    var r = rT(t), n = Math.pow(10, r), i = t / n, a;
    return i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10, t = a * n, r >= -20 ? +t.toFixed(r < 0 ? -r : 0) : t;
  }
  function p0(t, e) {
    var r = (t.length - 1) * e + 1, n = Math.floor(r), i = +t[n - 1], a = r - n;
    return a ? i + a * (t[n] - i) : i;
  }
  function KM(t) {
    t.sort(function(l, u) {
      return s(l, u, 0) ? -1 : 1;
    });
    for (var e = -1 / 0, r = 1, n = 0; n < t.length; ) {
      for (var i = t[n].interval, a = t[n].close, o = 0; o < 2; o++) i[o] <= e && (i[o] = e, a[o] = o ? 1 : 1 - r), e = i[o], r = a[o];
      i[0] === i[1] && a[0] * a[1] !== 1 ? t.splice(n, 1) : n++;
    }
    return t;
    function s(l, u, c) {
      return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
    }
  }
  function ho(t) {
    var e = parseFloat(t);
    return e == t && (e !== 0 || !me(t) || t.indexOf("x") <= 0) ? e : NaN;
  }
  function o4(t) {
    return !isNaN(ho(t));
  }
  function s4() {
    return Math.round(Math.random() * 9);
  }
  function l4(t, e) {
    return e === 0 ? t : l4(e, t % e);
  }
  function ZM(t, e) {
    return t == null ? e : e == null ? t : t * e / l4(t, e);
  }
  function It(t) {
    throw new Error(t);
  }
  function QM(t, e, r) {
    return (e - t) * r + t;
  }
  var u4 = "series\0", c4 = "\0_ec_\0";
  function Ot(t) {
    return t instanceof Array ? t : t == null ? [] : [
      t
    ];
  }
  function Ul(t, e, r) {
    if (t) {
      t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {};
      for (var n = 0, i = r.length; n < i; n++) {
        var a = r[n];
        !t.emphasis[e].hasOwnProperty(a) && t[e].hasOwnProperty(a) && (t.emphasis[e][a] = t[e][a]);
      }
    }
  }
  var JM = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "rich",
    "tag",
    "color",
    "textBorderColor",
    "textBorderWidth",
    "width",
    "height",
    "lineHeight",
    "align",
    "verticalAlign",
    "baseline",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "textShadowColor",
    "textShadowBlur",
    "textShadowOffsetX",
    "textShadowOffsetY",
    "backgroundColor",
    "borderColor",
    "borderWidth",
    "borderRadius",
    "padding"
  ];
  function Fc(t) {
    return Le(t) && !ae(t) && !(t instanceof Date) ? t.value : t;
  }
  function XZ(t) {
    return Le(t) && !(t instanceof Array);
  }
  function h4(t, e, r) {
    var n = r === "normalMerge", i = r === "replaceMerge", a = r === "replaceAll";
    t = t || [], e = (e || []).slice();
    var o = Ce();
    $(e, function(l, u) {
      if (!Le(l)) {
        e[u] = null;
        return;
      }
    });
    var s = jZ(t, o, r);
    return (n || i) && KZ(s, t, o, e), n && ZZ(s, e), n || i ? QZ(s, e, i) : a && JZ(s, e), eQ(s), s;
  }
  function jZ(t, e, r) {
    var n = [];
    if (r === "replaceAll") return n;
    for (var i = 0; i < t.length; i++) {
      var a = t[i];
      a && a.id != null && e.set(a.id, i), n.push({
        existing: r === "replaceMerge" || Yf(a) ? null : a,
        newOption: null,
        keyInfo: null,
        brandNew: null
      });
    }
    return n;
  }
  function KZ(t, e, r, n) {
    $(n, function(i, a) {
      if (!(!i || i.id == null)) {
        var o = xf(i.id), s = r.get(o);
        if (s != null) {
          var l = t[s];
          bn(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = i, l.existing = e[s], n[a] = null;
        }
      }
    });
  }
  function ZZ(t, e) {
    $(e, function(r, n) {
      if (!(!r || r.name == null)) for (var i = 0; i < t.length; i++) {
        var a = t[i].existing;
        if (!t[i].newOption && a && (a.id == null || r.id == null) && !Yf(r) && !Yf(a) && f4("name", a, r)) {
          t[i].newOption = r, e[n] = null;
          return;
        }
      }
    });
  }
  function QZ(t, e, r) {
    $(e, function(n) {
      if (n) {
        for (var i, a = 0; (i = t[a]) && (i.newOption || Yf(i.existing) || i.existing && n.id != null && !f4("id", n, i.existing)); ) a++;
        i ? (i.newOption = n, i.brandNew = r) : t.push({
          newOption: n,
          brandNew: r,
          existing: null,
          keyInfo: null
        }), a++;
      }
    });
  }
  function JZ(t, e) {
    $(e, function(r) {
      t.push({
        newOption: r,
        brandNew: true,
        existing: null,
        keyInfo: null
      });
    });
  }
  function eQ(t) {
    var e = Ce();
    $(t, function(r) {
      var n = r.existing;
      n && e.set(n.id, r);
    }), $(t, function(r) {
      var n = r.newOption;
      bn(!n || n.id == null || !e.get(n.id) || e.get(n.id) === r, "id duplicates: " + (n && n.id)), n && n.id != null && e.set(n.id, r), !r.keyInfo && (r.keyInfo = {});
    }), $(t, function(r, n) {
      var i = r.existing, a = r.newOption, o = r.keyInfo;
      if (Le(a)) {
        if (o.name = a.name != null ? xf(a.name) : i ? i.name : u4 + n, i) o.id = xf(i.id);
        else if (a.id != null) o.id = xf(a.id);
        else {
          var s = 0;
          do
            o.id = "\0" + o.name + "\0" + s++;
          while (e.get(o.id));
        }
        e.set(o.id, r);
      }
    });
  }
  function f4(t, e, r) {
    var n = xr(e[t], null), i = xr(r[t], null);
    return n != null && i != null && n === i;
  }
  function xf(t) {
    return xr(t, "");
  }
  function xr(t, e) {
    return t == null ? e : me(t) ? t : xt(t) || ex(t) ? t + "" : e;
  }
  function nT(t) {
    var e = t.name;
    return !!(e && e.indexOf(u4));
  }
  function Yf(t) {
    return t && t.id != null && xf(t.id).indexOf(c4) === 0;
  }
  function tQ(t) {
    return c4 + t;
  }
  function rQ(t, e, r) {
    $(t, function(n) {
      var i = n.newOption;
      Le(i) && (n.keyInfo.mainType = e, n.keyInfo.subType = nQ(e, i, n.existing, r));
    });
  }
  function nQ(t, e, r, n) {
    var i = e.type ? e.type : r ? r.subType : n.determineSubType(t, e);
    return i;
  }
  function iQ(t, e) {
    var r = {}, n = {};
    return i(t || [], r), i(e || [], n, r), [
      a(r),
      a(n)
    ];
    function i(o, s, l) {
      for (var u = 0, c = o.length; u < c; u++) {
        var h = xr(o[u].seriesId, null);
        if (h == null) return;
        for (var f = Ot(o[u].dataIndex), d = l && l[h], p = 0, v = f.length; p < v; p++) {
          var g = f[p];
          d && d[g] ? d[g] = null : (s[h] || (s[h] = {}))[g] = 1;
        }
      }
    }
    function a(o, s) {
      var l = [];
      for (var u in o) if (o.hasOwnProperty(u) && o[u] != null) if (s) l.push(+u);
      else {
        var c = a(o[u], true);
        c.length && l.push({
          seriesId: u,
          dataIndex: c
        });
      }
      return l;
    }
  }
  function Yl(t, e) {
    if (e.dataIndexInside != null) return e.dataIndexInside;
    if (e.dataIndex != null) return ae(e.dataIndex) ? oe(e.dataIndex, function(r) {
      return t.indexOfRawIndex(r);
    }) : t.indexOfRawIndex(e.dataIndex);
    if (e.name != null) return ae(e.name) ? oe(e.name, function(r) {
      return t.indexOfName(r);
    }) : t.indexOfName(e.name);
  }
  function _t() {
    var t = "__ec_inner_" + aQ++;
    return function(e) {
      return e[t] || (e[t] = {});
    };
  }
  var aQ = s4();
  function wf(t, e, r) {
    var n = iT(e, r), i = n.mainTypeSpecified, a = n.queryOptionMap, o = n.others, s = o, l = r ? r.defaultMainType : null;
    return !i && l && a.set(l, {}), a.each(function(u, c) {
      var h = Ed(t, c, u, {
        useDefault: l === c,
        enableAll: r && r.enableAll != null ? r.enableAll : true,
        enableNone: r && r.enableNone != null ? r.enableNone : true
      });
      s[c + "Models"] = h.models, s[c + "Model"] = h.models[0];
    }), s;
  }
  function iT(t, e) {
    var r;
    if (me(t)) {
      var n = {};
      n[t + "Index"] = 0, r = n;
    } else r = t;
    var i = Ce(), a = {}, o = false;
    return $(r, function(s, l) {
      if (l === "dataIndex" || l === "dataIndexInside") {
        a[l] = s;
        return;
      }
      var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
      if (!(!c || !h || e && e.includeMainTypes && et(e.includeMainTypes, c) < 0)) {
        o = o || !!c;
        var f = i.get(c) || i.set(c, {});
        f[h] = s;
      }
    }), {
      mainTypeSpecified: o,
      queryOptionMap: i,
      others: a
    };
  }
  var gr = {
    useDefault: true,
    enableAll: false,
    enableNone: false
  }, oQ = {
    useDefault: false,
    enableAll: true,
    enableNone: true
  };
  function Ed(t, e, r, n) {
    n = n || gr;
    var i = r.index, a = r.id, o = r.name, s = {
      models: null,
      specified: i != null || a != null || o != null
    };
    if (!s.specified) {
      var l = void 0;
      return s.models = n.useDefault && (l = t.getComponent(e)) ? [
        l
      ] : [], s;
    }
    return i === "none" || i === false ? (bn(n.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (i === "all" && (bn(n.enableAll, '`"all"` is not a valid value on index option.'), i = a = o = null), s.models = t.queryComponents({
      mainType: e,
      index: i,
      id: a,
      name: o
    }), s);
  }
  function d4(t, e, r) {
    t.setAttribute ? t.setAttribute(e, r) : t[e] = r;
  }
  function sQ(t, e) {
    return t.getAttribute ? t.getAttribute(e) : t[e];
  }
  function lQ(t) {
    return t === "auto" ? ct.domSupported ? "html" : "richText" : t || "html";
  }
  function Tx(t, e) {
    var r = Ce(), n = [];
    return $(t, function(i) {
      var a = e(i);
      (r.get(a) || (n.push(a), r.set(a, []))).push(i);
    }), {
      keys: n,
      buckets: r
    };
  }
  function p4(t, e, r, n, i) {
    var a = e == null || e === "auto";
    if (n == null) return n;
    if (xt(n)) {
      var o = QM(r || 0, n, i);
      return lr(o, a ? Math.max(wa(r || 0), wa(n)) : e);
    } else {
      if (me(n)) return i < 1 ? r : n;
      for (var s = [], l = r, u = n, c = Math.max(l ? l.length : 0, u.length), h = 0; h < c; ++h) {
        var f = t.getDimensionInfo(h);
        if (f && f.type === "ordinal") s[h] = (i < 1 && l ? l : u)[h];
        else {
          var d = l && l[h] ? l[h] : 0, p = u[h], o = QM(d, p, i);
          s[h] = lr(o, a ? Math.max(wa(d), wa(p)) : e);
        }
      }
      return s;
    }
  }
  var uQ = ".", Ls = "___EC__COMPONENT__CONTAINER___", v4 = "___EC__EXTENDED_CLASS___";
  function Sa(t) {
    var e = {
      main: "",
      sub: ""
    };
    if (t) {
      var r = t.split(uQ);
      e.main = r[0] || "", e.sub = r[1] || "";
    }
    return e;
  }
  function cQ(t) {
    bn(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal');
  }
  function hQ(t) {
    return !!(t && t[v4]);
  }
  function aT(t, e) {
    t.$constructor = t, t.extend = function(r) {
      var n = this, i;
      return fQ(n) ? i = function(a) {
        K(o, a);
        function o() {
          return a.apply(this, arguments) || this;
        }
        return o;
      }(n) : (i = function() {
        (r.$constructor || n).apply(this, arguments);
      }, mK(i, this)), te(i.prototype, r), i[v4] = true, i.extend = this.extend, i.superCall = vQ, i.superApply = gQ, i.superClass = n, i;
    };
  }
  function fQ(t) {
    return De(t) && /^class\s/.test(Function.prototype.toString.call(t));
  }
  function g4(t, e) {
    t.extend = e.extend;
  }
  var dQ = Math.round(Math.random() * 10);
  function pQ(t) {
    var e = [
      "__\0is_clz",
      dQ++
    ].join("_");
    t.prototype[e] = true, t.isInstance = function(r) {
      return !!(r && r[e]);
    };
  }
  function vQ(t, e) {
    for (var r = [], n = 2; n < arguments.length; n++) r[n - 2] = arguments[n];
    return this.superClass.prototype[e].apply(t, r);
  }
  function gQ(t, e, r) {
    return this.superClass.prototype[e].apply(t, r);
  }
  function Vm(t) {
    var e = {};
    t.registerClass = function(n) {
      var i = n.type || n.prototype.type;
      if (i) {
        cQ(i), n.prototype.type = i;
        var a = Sa(i);
        if (!a.sub) e[a.main] = n;
        else if (a.sub !== Ls) {
          var o = r(a);
          o[a.sub] = n;
        }
      }
      return n;
    }, t.getClass = function(n, i, a) {
      var o = e[n];
      if (o && o[Ls] && (o = i ? o[i] : null), a && !o) throw new Error(i ? "Component " + n + "." + (i || "") + " is used but not imported." : n + ".type should be specified.");
      return o;
    }, t.getClassesByMainType = function(n) {
      var i = Sa(n), a = [], o = e[i.main];
      return o && o[Ls] ? $(o, function(s, l) {
        l !== Ls && a.push(s);
      }) : a.push(o), a;
    }, t.hasClass = function(n) {
      var i = Sa(n);
      return !!e[i.main];
    }, t.getAllClassMainTypes = function() {
      var n = [];
      return $(e, function(i, a) {
        n.push(a);
      }), n;
    }, t.hasSubTypes = function(n) {
      var i = Sa(n), a = e[i.main];
      return a && a[Ls];
    };
    function r(n) {
      var i = e[n.main];
      return (!i || !i[Ls]) && (i = e[n.main] = {}, i[Ls] = true), i;
    }
  }
  function ql(t, e) {
    for (var r = 0; r < t.length; r++) t[r][1] || (t[r][1] = t[r][0]);
    return e = e || false, function(n, i, a) {
      for (var o = {}, s = 0; s < t.length; s++) {
        var l = t[s][1];
        if (!(i && et(i, l) >= 0 || a && et(a, l) < 0)) {
          var u = n.getShallow(l, e);
          u != null && (o[t[s][0]] = u);
        }
      }
      return o;
    };
  }
  var mQ = [
    [
      "fill",
      "color"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "opacity"
    ],
    [
      "shadowColor"
    ]
  ], yQ = ql(mQ), _Q = function() {
    function t() {
    }
    return t.prototype.getAreaStyle = function(e, r) {
      return yQ(this, e, r);
    }, t;
  }(), Cx = new Md(50);
  function bQ(t) {
    if (typeof t == "string") {
      var e = Cx.get(t);
      return e && e.image;
    } else return t;
  }
  function oT(t, e, r, n, i) {
    if (t) if (typeof t == "string") {
      if (e && e.__zrImageSrc === t || !r) return e;
      var a = Cx.get(t), o = {
        hostEl: r,
        cb: n,
        cbPayload: i
      };
      return a ? (e = a.image, !Gm(e) && a.pending.push(o)) : (e = hs.loadImage(t, eD, eD), e.__zrImageSrc = t, Cx.put(t, e.__cachedImgObj = {
        image: e,
        pending: [
          o
        ]
      })), e;
    } else return t;
    else return e;
  }
  function eD() {
    var t = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;
    for (var e = 0; e < t.pending.length; e++) {
      var r = t.pending[e], n = r.cb;
      n && n(this, r.cbPayload), r.hostEl.dirty();
    }
    t.pending.length = 0;
  }
  function Gm(t) {
    return t && t.width && t.height;
  }
  var v0 = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
  function xQ(t, e, r, n, i, a) {
    if (!r) {
      t.text = "", t.isTruncated = false;
      return;
    }
    var o = (e + "").split(`
`);
    a = m4(r, n, i, a);
    for (var s = false, l = {}, u = 0, c = o.length; u < c; u++) y4(l, o[u], a), o[u] = l.textLine, s = s || l.isTruncated;
    t.text = o.join(`
`), t.isTruncated = s;
  }
  function m4(t, e, r, n) {
    n = n || {};
    var i = te({}, n);
    i.font = e, r = We(r, "..."), i.maxIterations = We(n.maxIterations, 2);
    var a = i.minChar = We(n.minChar, 0);
    i.cnCharWidth = Yn("\u56FD", e);
    var o = i.ascCharWidth = Yn("a", e);
    i.placeholder = We(n.placeholder, "");
    for (var s = t = Math.max(0, t - 1), l = 0; l < a && s >= o; l++) s -= o;
    var u = Yn(r, e);
    return u > s && (r = "", u = 0), s = t - u, i.ellipsis = r, i.ellipsisWidth = u, i.contentWidth = s, i.containerWidth = t, i;
  }
  function y4(t, e, r) {
    var n = r.containerWidth, i = r.font, a = r.contentWidth;
    if (!n) {
      t.textLine = "", t.isTruncated = false;
      return;
    }
    var o = Yn(e, i);
    if (o <= n) {
      t.textLine = e, t.isTruncated = false;
      return;
    }
    for (var s = 0; ; s++) {
      if (o <= a || s >= r.maxIterations) {
        e += r.ellipsis;
        break;
      }
      var l = s === 0 ? wQ(e, a, r.ascCharWidth, r.cnCharWidth) : o > 0 ? Math.floor(e.length * a / o) : 0;
      e = e.substr(0, l), o = Yn(e, i);
    }
    e === "" && (e = r.placeholder), t.textLine = e, t.isTruncated = true;
  }
  function wQ(t, e, r, n) {
    for (var i = 0, a = 0, o = t.length; a < o && i < e; a++) {
      var s = t.charCodeAt(a);
      i += 0 <= s && s <= 127 ? r : n;
    }
    return a;
  }
  function SQ(t, e) {
    t != null && (t += "");
    var r = e.overflow, n = e.padding, i = e.font, a = r === "truncate", o = zm(i), s = We(e.lineHeight, o), l = !!e.backgroundColor, u = e.lineOverflow === "truncate", c = false, h = e.width, f;
    h != null && (r === "break" || r === "breakAll") ? f = t ? _4(t, e.font, h, r === "breakAll", 0).lines : [] : f = t ? t.split(`
`) : [];
    var d = f.length * s, p = We(e.height, d);
    if (d > p && u) {
      var v = Math.floor(p / s);
      c = c || f.length > v, f = f.slice(0, v);
    }
    if (t && a && h != null) for (var g = m4(h, i, e.ellipsis, {
      minChar: e.truncateMinChar,
      placeholder: e.placeholder
    }), m = {}, y = 0; y < f.length; y++) y4(m, f[y], g), f[y] = m.textLine, c = c || m.isTruncated;
    for (var _ = p, b = 0, y = 0; y < f.length; y++) b = Math.max(Yn(f[y], i), b);
    h == null && (h = b);
    var w = b;
    return n && (_ += n[0] + n[2], w += n[1] + n[3], h += n[1] + n[3]), l && (w = h), {
      lines: f,
      height: p,
      outerWidth: w,
      outerHeight: _,
      lineHeight: s,
      calculatedLineHeight: o,
      contentWidth: b,
      contentHeight: d,
      width: h,
      isTruncated: c
    };
  }
  var TQ = /* @__PURE__ */ function() {
    function t() {
    }
    return t;
  }(), tD = /* @__PURE__ */ function() {
    function t(e) {
      this.tokens = [], e && (this.tokens = e);
    }
    return t;
  }(), CQ = /* @__PURE__ */ function() {
    function t() {
      this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = false;
    }
    return t;
  }();
  function AQ(t, e) {
    var r = new CQ();
    if (t != null && (t += ""), !t) return r;
    for (var n = e.width, i = e.height, a = e.overflow, o = (a === "break" || a === "breakAll") && n != null ? {
      width: n,
      accumWidth: 0,
      breakAll: a === "breakAll"
    } : null, s = v0.lastIndex = 0, l; (l = v0.exec(t)) != null; ) {
      var u = l.index;
      u > s && g0(r, t.substring(s, u), e, o), g0(r, l[2], e, o, l[1]), s = v0.lastIndex;
    }
    s < t.length && g0(r, t.substring(s, t.length), e, o);
    var c = [], h = 0, f = 0, d = e.padding, p = a === "truncate", v = e.lineOverflow === "truncate", g = {};
    function m(H, G, Y) {
      H.width = G, H.lineHeight = Y, h += Y, f = Math.max(f, G);
    }
    e: for (var y = 0; y < r.lines.length; y++) {
      for (var _ = r.lines[y], b = 0, w = 0, x = 0; x < _.tokens.length; x++) {
        var T = _.tokens[x], A = T.styleName && e.rich[T.styleName] || {}, I = T.textPadding = A.padding, M = I ? I[1] + I[3] : 0, k = T.font = A.font || e.font;
        T.contentHeight = zm(k);
        var B = We(A.height, T.contentHeight);
        if (T.innerHeight = B, I && (B += I[0] + I[2]), T.height = B, T.lineHeight = Aa(A.lineHeight, e.lineHeight, B), T.align = A && A.align || e.align, T.verticalAlign = A && A.verticalAlign || "middle", v && i != null && h + T.lineHeight > i) {
          var L = r.lines.length;
          x > 0 ? (_.tokens = _.tokens.slice(0, x), m(_, w, b), r.lines = r.lines.slice(0, y + 1)) : r.lines = r.lines.slice(0, y), r.isTruncated = r.isTruncated || r.lines.length < L;
          break e;
        }
        var z = A.width, F = z == null || z === "auto";
        if (typeof z == "string" && z.charAt(z.length - 1) === "%") T.percentWidth = z, c.push(T), T.contentWidth = Yn(T.text, k);
        else {
          if (F) {
            var E = A.backgroundColor, O = E && E.image;
            O && (O = bQ(O), Gm(O) && (T.width = Math.max(T.width, O.width * B / O.height)));
          }
          var N = p && n != null ? n - w : null;
          N != null && N < T.width ? !F || N < M ? (T.text = "", T.width = T.contentWidth = 0) : (xQ(g, T.text, N - M, k, e.ellipsis, {
            minChar: e.truncateMinChar
          }), T.text = g.text, r.isTruncated = r.isTruncated || g.isTruncated, T.width = T.contentWidth = Yn(T.text, k)) : T.contentWidth = Yn(T.text, k);
        }
        T.width += M, w += T.width, A && (b = Math.max(b, T.lineHeight));
      }
      m(_, w, b);
    }
    r.outerWidth = r.width = We(n, f), r.outerHeight = r.height = We(i, h), r.contentHeight = h, r.contentWidth = f, d && (r.outerWidth += d[1] + d[3], r.outerHeight += d[0] + d[2]);
    for (var y = 0; y < c.length; y++) {
      var T = c[y], V = T.percentWidth;
      T.width = parseInt(V, 10) / 100 * r.width;
    }
    return r;
  }
  function g0(t, e, r, n, i) {
    var a = e === "", o = i && r.rich[i] || {}, s = t.lines, l = o.font || r.font, u = false, c, h;
    if (n) {
      var f = o.padding, d = f ? f[1] + f[3] : 0;
      if (o.width != null && o.width !== "auto") {
        var p = ji(o.width, n.width) + d;
        s.length > 0 && p + n.accumWidth > n.width && (c = e.split(`
`), u = true), n.accumWidth = p;
      } else {
        var v = _4(e, l, n.width, n.breakAll, n.accumWidth);
        n.accumWidth = v.accumWidth + d, h = v.linesWidths, c = v.lines;
      }
    } else c = e.split(`
`);
    for (var g = 0; g < c.length; g++) {
      var m = c[g], y = new TQ();
      if (y.styleName = i, y.text = m, y.isLineHolder = !m && !a, typeof o.width == "number" ? y.width = o.width : y.width = h ? h[g] : Yn(m, l), !g && !u) {
        var _ = (s[s.length - 1] || (s[0] = new tD())).tokens, b = _.length;
        b === 1 && _[0].isLineHolder ? _[0] = y : (m || !b || a) && _.push(y);
      } else s.push(new tD([
        y
      ]));
    }
  }
  function IQ(t) {
    var e = t.charCodeAt(0);
    return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303;
  }
  var MQ = ka(",&?/;] ".split(""), function(t, e) {
    return t[e] = true, t;
  }, {});
  function DQ(t) {
    return IQ(t) ? !!MQ[t] : true;
  }
  function _4(t, e, r, n, i) {
    for (var a = [], o = [], s = "", l = "", u = 0, c = 0, h = 0; h < t.length; h++) {
      var f = t.charAt(h);
      if (f === `
`) {
        l && (s += l, c += u), a.push(s), o.push(c), s = "", l = "", u = 0, c = 0;
        continue;
      }
      var d = Yn(f, e), p = n ? false : !DQ(f);
      if (a.length ? c + d > r : i + c + d > r) {
        c ? (s || l) && (p ? (s || (s = l, l = "", u = 0, c = u), a.push(s), o.push(c - u), l += f, u += d, s = "", c = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(c), s = f, c = d)) : p ? (a.push(l), o.push(u), l = f, u = d) : (a.push(f), o.push(d));
        continue;
      }
      c += d, p ? (l += f, u += d) : (l && (s += l, l = "", u = 0), s += f);
    }
    return !a.length && !s && (s = t, l = "", u = 0), l && (s += l), s && (a.push(s), o.push(c)), a.length === 1 && (c += i), {
      accumWidth: c,
      lines: a,
      linesWidths: o
    };
  }
  var Ax = "__zr_style_" + Math.round(Math.random() * 10), Rl = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    opacity: 1,
    blend: "source-over"
  }, Wm = {
    style: {
      shadowBlur: true,
      shadowOffsetX: true,
      shadowOffsetY: true,
      shadowColor: true,
      opacity: true
    }
  };
  Rl[Ax] = true;
  var rD = [
    "z",
    "z2",
    "invisible"
  ], EQ = [
    "invisible"
  ], bi = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype._init = function(r) {
      for (var n = gt(r), i = 0; i < n.length; i++) {
        var a = n[i];
        a === "style" ? this.useStyle(r[a]) : t.prototype.attrKV.call(this, a, r[a]);
      }
      this.style || this.useStyle({});
    }, e.prototype.beforeBrush = function() {
    }, e.prototype.afterBrush = function() {
    }, e.prototype.innerBeforeBrush = function() {
    }, e.prototype.innerAfterBrush = function() {
    }, e.prototype.shouldBePainted = function(r, n, i, a) {
      var o = this.transform;
      if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && kQ(this, r, n) || o && !o[0] && !o[3]) return false;
      if (i && this.__clipPaths) {
        for (var s = 0; s < this.__clipPaths.length; ++s) if (this.__clipPaths[s].isZeroArea()) return false;
      }
      if (a && this.parent) for (var l = this.parent; l; ) {
        if (l.ignore) return false;
        l = l.parent;
      }
      return true;
    }, e.prototype.contain = function(r, n) {
      return this.rectContain(r, n);
    }, e.prototype.traverse = function(r, n) {
      r.call(n, this);
    }, e.prototype.rectContain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), a = this.getBoundingRect();
      return a.contain(i[0], i[1]);
    }, e.prototype.getPaintRect = function() {
      var r = this._paintRect;
      if (!this._paintRect || this.__dirty) {
        var n = this.transform, i = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
        r = this._paintRect || (this._paintRect = new Ze(0, 0, 0, 0)), n ? Ze.applyTransform(r, i, n) : r.copy(i), (o || s || l) && (r.width += o * 2 + Math.abs(s), r.height += o * 2 + Math.abs(l), r.x = Math.min(r.x, r.x + s - o), r.y = Math.min(r.y, r.y + l - o));
        var u = this.dirtyRectTolerance;
        r.isZero() || (r.x = Math.floor(r.x - u), r.y = Math.floor(r.y - u), r.width = Math.ceil(r.width + 1 + u * 2), r.height = Math.ceil(r.height + 1 + u * 2));
      }
      return r;
    }, e.prototype.setPrevPaintRect = function(r) {
      r ? (this._prevPaintRect = this._prevPaintRect || new Ze(0, 0, 0, 0), this._prevPaintRect.copy(r)) : this._prevPaintRect = null;
    }, e.prototype.getPrevPaintRect = function() {
      return this._prevPaintRect;
    }, e.prototype.animateStyle = function(r) {
      return this.animate("style", r);
    }, e.prototype.updateDuringAnimation = function(r) {
      r === "style" ? this.dirtyStyle() : this.markRedraw();
    }, e.prototype.attrKV = function(r, n) {
      r !== "style" ? t.prototype.attrKV.call(this, r, n) : this.style ? this.setStyle(n) : this.useStyle(n);
    }, e.prototype.setStyle = function(r, n) {
      return typeof r == "string" ? this.style[r] = n : te(this.style, r), this.dirtyStyle(), this;
    }, e.prototype.dirtyStyle = function(r) {
      r || this.markRedraw(), this.__dirty |= Qv, this._rect && (this._rect = null);
    }, e.prototype.dirty = function() {
      this.dirtyStyle();
    }, e.prototype.styleChanged = function() {
      return !!(this.__dirty & Qv);
    }, e.prototype.styleUpdated = function() {
      this.__dirty &= -3;
    }, e.prototype.createStyle = function(r) {
      return Om(Rl, r);
    }, e.prototype.useStyle = function(r) {
      r[Ax] || (r = this.createStyle(r)), this.__inHover ? this.__hoverStyle = r : this.style = r, this.dirtyStyle();
    }, e.prototype.isStyleObject = function(r) {
      return r[Ax];
    }, e.prototype._innerSaveToNormal = function(r) {
      t.prototype._innerSaveToNormal.call(this, r);
      var n = this._normalState;
      r.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(r, n, rD);
    }, e.prototype._applyStateObj = function(r, n, i, a, o, s) {
      t.prototype._applyStateObj.call(this, r, n, i, a, o, s);
      var l = !(n && a), u;
      if (n && n.style ? o ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(u, n.style)) : l && (u = i.style), u) if (o) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l) for (var h = gt(c), f = 0; f < h.length; f++) {
          var d = h[f];
          d in u && (u[d] = u[d], this.style[d] = c[d]);
        }
        for (var p = gt(u), f = 0; f < p.length; f++) {
          var d = p[f];
          this.style[d] = this.style[d];
        }
        this._transitionState(r, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else this.useStyle(u);
      for (var v = this.__inHover ? EQ : rD, f = 0; f < v.length; f++) {
        var d = v[f];
        n && n[d] != null ? this[d] = n[d] : l && i[d] != null && (this[d] = i[d]);
      }
    }, e.prototype._mergeStates = function(r) {
      for (var n = t.prototype._mergeStates.call(this, r), i, a = 0; a < r.length; a++) {
        var o = r[a];
        o.style && (i = i || {}, this._mergeStyle(i, o.style));
      }
      return i && (n.style = i), n;
    }, e.prototype._mergeStyle = function(r, n) {
      return te(r, n), r;
    }, e.prototype.getAnimationStyleProps = function() {
      return Wm;
    }, e.initDefaultProps = function() {
      var r = e.prototype;
      r.type = "displayable", r.invisible = false, r.z = 0, r.z2 = 0, r.zlevel = 0, r.culling = false, r.cursor = "pointer", r.rectHover = false, r.incremental = false, r._rect = null, r.dirtyRectTolerance = 0, r.__dirty = Ia | Qv;
    }(), e;
  }(Fm), m0 = new Ze(0, 0, 0, 0), y0 = new Ze(0, 0, 0, 0);
  function kQ(t, e, r) {
    return m0.copy(t.getBoundingRect()), t.transform && m0.applyTransform(t.transform), y0.width = e, y0.height = r, !m0.intersect(y0);
  }
  var Mn = Math.min, Dn = Math.max, _0 = Math.sin, b0 = Math.cos, $s = Math.PI * 2, wp = ru(), Sp = ru(), Tp = ru();
  function Hm(t, e, r) {
    if (t.length !== 0) {
      for (var n = t[0], i = n[0], a = n[0], o = n[1], s = n[1], l = 1; l < t.length; l++) n = t[l], i = Mn(i, n[0]), a = Dn(a, n[0]), o = Mn(o, n[1]), s = Dn(s, n[1]);
      e[0] = i, e[1] = o, r[0] = a, r[1] = s;
    }
  }
  function nD(t, e, r, n, i, a) {
    i[0] = Mn(t, r), i[1] = Mn(e, n), a[0] = Dn(t, r), a[1] = Dn(e, n);
  }
  var iD = [], aD = [];
  function PQ(t, e, r, n, i, a, o, s, l, u) {
    var c = BF, h = Ar, f = c(t, r, i, o, iD);
    l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
    for (var d = 0; d < f; d++) {
      var p = h(t, r, i, o, iD[d]);
      l[0] = Mn(p, l[0]), u[0] = Dn(p, u[0]);
    }
    f = c(e, n, a, s, aD);
    for (var d = 0; d < f; d++) {
      var v = h(e, n, a, s, aD[d]);
      l[1] = Mn(v, l[1]), u[1] = Dn(v, u[1]);
    }
    l[0] = Mn(t, l[0]), u[0] = Dn(t, u[0]), l[0] = Mn(o, l[0]), u[0] = Dn(o, u[0]), l[1] = Mn(e, l[1]), u[1] = Dn(e, u[1]), l[1] = Mn(s, l[1]), u[1] = Dn(s, u[1]);
  }
  function LQ(t, e, r, n, i, a, o, s) {
    var l = FF, u = Br, c = Dn(Mn(l(t, r, i), 1), 0), h = Dn(Mn(l(e, n, a), 1), 0), f = u(t, r, i, c), d = u(e, n, a, h);
    o[0] = Mn(t, i, f), o[1] = Mn(e, a, d), s[0] = Dn(t, i, f), s[1] = Dn(e, a, d);
  }
  function $Q(t, e, r, n, i, a, o, s, l) {
    var u = Ko, c = Zo, h = Math.abs(i - a);
    if (h % $s < 1e-4 && h > 1e-4) {
      s[0] = t - r, s[1] = e - n, l[0] = t + r, l[1] = e + n;
      return;
    }
    if (wp[0] = b0(i) * r + t, wp[1] = _0(i) * n + e, Sp[0] = b0(a) * r + t, Sp[1] = _0(a) * n + e, u(s, wp, Sp), c(l, wp, Sp), i = i % $s, i < 0 && (i = i + $s), a = a % $s, a < 0 && (a = a + $s), i > a && !o ? a += $s : i < a && o && (i += $s), o) {
      var f = a;
      a = i, i = f;
    }
    for (var d = 0; d < a; d += Math.PI / 2) d > i && (Tp[0] = b0(d) * r + t, Tp[1] = _0(d) * n + e, u(s, Tp, s), c(l, Tp, l));
  }
  var Gt = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  }, Rs = [], Os = [], oa = [], Do = [], sa = [], la = [], x0 = Math.min, w0 = Math.max, Ns = Math.cos, Bs = Math.sin, Wa = Math.abs, Ix = Math.PI, Ho = Ix * 2, S0 = typeof Float32Array < "u", ch = [];
  function T0(t) {
    var e = Math.round(t / Ix * 1e8) / 1e8;
    return e % 2 * Ix;
  }
  function sT(t, e) {
    var r = T0(t[0]);
    r < 0 && (r += Ho);
    var n = r - t[0], i = t[1];
    i += n, !e && i - r >= Ho ? i = r + Ho : e && r - i >= Ho ? i = r - Ho : !e && r > i ? i = r + (Ho - T0(r - i)) : e && r < i && (i = r - (Ho - T0(i - r))), t[0] = r, t[1] = i;
  }
  var Ra = function() {
    function t(e) {
      this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = false), this._saveData && (this.data = []);
    }
    return t.prototype.increaseVersion = function() {
      this._version++;
    }, t.prototype.getVersion = function() {
      return this._version;
    }, t.prototype.setScale = function(e, r, n) {
      n = n || 0, n > 0 && (this._ux = Wa(n / Mg / e) || 0, this._uy = Wa(n / Mg / r) || 0);
    }, t.prototype.setDPR = function(e) {
      this.dpr = e;
    }, t.prototype.setContext = function(e) {
      this._ctx = e;
    }, t.prototype.getContext = function() {
      return this._ctx;
    }, t.prototype.beginPath = function() {
      return this._ctx && this._ctx.beginPath(), this.reset(), this;
    }, t.prototype.reset = function() {
      this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
    }, t.prototype.moveTo = function(e, r) {
      return this._drawPendingPt(), this.addData(Gt.M, e, r), this._ctx && this._ctx.moveTo(e, r), this._x0 = e, this._y0 = r, this._xi = e, this._yi = r, this;
    }, t.prototype.lineTo = function(e, r) {
      var n = Wa(e - this._xi), i = Wa(r - this._yi), a = n > this._ux || i > this._uy;
      if (this.addData(Gt.L, e, r), this._ctx && a && this._ctx.lineTo(e, r), a) this._xi = e, this._yi = r, this._pendingPtDist = 0;
      else {
        var o = n * n + i * i;
        o > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = r, this._pendingPtDist = o);
      }
      return this;
    }, t.prototype.bezierCurveTo = function(e, r, n, i, a, o) {
      return this._drawPendingPt(), this.addData(Gt.C, e, r, n, i, a, o), this._ctx && this._ctx.bezierCurveTo(e, r, n, i, a, o), this._xi = a, this._yi = o, this;
    }, t.prototype.quadraticCurveTo = function(e, r, n, i) {
      return this._drawPendingPt(), this.addData(Gt.Q, e, r, n, i), this._ctx && this._ctx.quadraticCurveTo(e, r, n, i), this._xi = n, this._yi = i, this;
    }, t.prototype.arc = function(e, r, n, i, a, o) {
      this._drawPendingPt(), ch[0] = i, ch[1] = a, sT(ch, o), i = ch[0], a = ch[1];
      var s = a - i;
      return this.addData(Gt.A, e, r, n, n, i, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(e, r, n, i, a, o), this._xi = Ns(a) * n + e, this._yi = Bs(a) * n + r, this;
    }, t.prototype.arcTo = function(e, r, n, i, a) {
      return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, r, n, i, a), this;
    }, t.prototype.rect = function(e, r, n, i) {
      return this._drawPendingPt(), this._ctx && this._ctx.rect(e, r, n, i), this.addData(Gt.R, e, r, n, i), this;
    }, t.prototype.closePath = function() {
      this._drawPendingPt(), this.addData(Gt.Z);
      var e = this._ctx, r = this._x0, n = this._y0;
      return e && e.closePath(), this._xi = r, this._yi = n, this;
    }, t.prototype.fill = function(e) {
      e && e.fill(), this.toStatic();
    }, t.prototype.stroke = function(e) {
      e && e.stroke(), this.toStatic();
    }, t.prototype.len = function() {
      return this._len;
    }, t.prototype.setData = function(e) {
      var r = e.length;
      !(this.data && this.data.length === r) && S0 && (this.data = new Float32Array(r));
      for (var n = 0; n < r; n++) this.data[n] = e[n];
      this._len = r;
    }, t.prototype.appendPath = function(e) {
      e instanceof Array || (e = [
        e
      ]);
      for (var r = e.length, n = 0, i = this._len, a = 0; a < r; a++) n += e[a].len();
      S0 && this.data instanceof Float32Array && (this.data = new Float32Array(i + n));
      for (var a = 0; a < r; a++) for (var o = e[a].data, s = 0; s < o.length; s++) this.data[i++] = o[s];
      this._len = i;
    }, t.prototype.addData = function(e, r, n, i, a, o, s, l, u) {
      if (this._saveData) {
        var c = this.data;
        this._len + arguments.length > c.length && (this._expandData(), c = this.data);
        for (var h = 0; h < arguments.length; h++) c[this._len++] = arguments[h];
      }
    }, t.prototype._drawPendingPt = function() {
      this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
    }, t.prototype._expandData = function() {
      if (!(this.data instanceof Array)) {
        for (var e = [], r = 0; r < this._len; r++) e[r] = this.data[r];
        this.data = e;
      }
    }, t.prototype.toStatic = function() {
      if (this._saveData) {
        this._drawPendingPt();
        var e = this.data;
        e instanceof Array && (e.length = this._len, S0 && this._len > 11 && (this.data = new Float32Array(e)));
      }
    }, t.prototype.getBoundingRect = function() {
      oa[0] = oa[1] = sa[0] = sa[1] = Number.MAX_VALUE, Do[0] = Do[1] = la[0] = la[1] = -Number.MAX_VALUE;
      var e = this.data, r = 0, n = 0, i = 0, a = 0, o;
      for (o = 0; o < this._len; ) {
        var s = e[o++], l = o === 1;
        switch (l && (r = e[o], n = e[o + 1], i = r, a = n), s) {
          case Gt.M:
            r = i = e[o++], n = a = e[o++], sa[0] = i, sa[1] = a, la[0] = i, la[1] = a;
            break;
          case Gt.L:
            nD(r, n, e[o], e[o + 1], sa, la), r = e[o++], n = e[o++];
            break;
          case Gt.C:
            PQ(r, n, e[o++], e[o++], e[o++], e[o++], e[o], e[o + 1], sa, la), r = e[o++], n = e[o++];
            break;
          case Gt.Q:
            LQ(r, n, e[o++], e[o++], e[o], e[o + 1], sa, la), r = e[o++], n = e[o++];
            break;
          case Gt.A:
            var u = e[o++], c = e[o++], h = e[o++], f = e[o++], d = e[o++], p = e[o++] + d;
            o += 1;
            var v = !e[o++];
            l && (i = Ns(d) * h + u, a = Bs(d) * f + c), $Q(u, c, h, f, d, p, v, sa, la), r = Ns(p) * h + u, n = Bs(p) * f + c;
            break;
          case Gt.R:
            i = r = e[o++], a = n = e[o++];
            var g = e[o++], m = e[o++];
            nD(i, a, i + g, a + m, sa, la);
            break;
          case Gt.Z:
            r = i, n = a;
            break;
        }
        Ko(oa, oa, sa), Zo(Do, Do, la);
      }
      return o === 0 && (oa[0] = oa[1] = Do[0] = Do[1] = 0), new Ze(oa[0], oa[1], Do[0] - oa[0], Do[1] - oa[1]);
    }, t.prototype._calculateLength = function() {
      var e = this.data, r = this._len, n = this._ux, i = this._uy, a = 0, o = 0, s = 0, l = 0;
      this._pathSegLen || (this._pathSegLen = []);
      for (var u = this._pathSegLen, c = 0, h = 0, f = 0; f < r; ) {
        var d = e[f++], p = f === 1;
        p && (a = e[f], o = e[f + 1], s = a, l = o);
        var v = -1;
        switch (d) {
          case Gt.M:
            a = s = e[f++], o = l = e[f++];
            break;
          case Gt.L: {
            var g = e[f++], m = e[f++], y = g - a, _ = m - o;
            (Wa(y) > n || Wa(_) > i || f === r - 1) && (v = Math.sqrt(y * y + _ * _), a = g, o = m);
            break;
          }
          case Gt.C: {
            var b = e[f++], w = e[f++], g = e[f++], m = e[f++], x = e[f++], T = e[f++];
            v = ZK(a, o, b, w, g, m, x, T, 10), a = x, o = T;
            break;
          }
          case Gt.Q: {
            var b = e[f++], w = e[f++], g = e[f++], m = e[f++];
            v = JK(a, o, b, w, g, m, 10), a = g, o = m;
            break;
          }
          case Gt.A:
            var A = e[f++], I = e[f++], M = e[f++], k = e[f++], B = e[f++], L = e[f++], z = L + B;
            f += 1, p && (s = Ns(B) * M + A, l = Bs(B) * k + I), v = w0(M, k) * x0(Ho, Math.abs(L)), a = Ns(z) * M + A, o = Bs(z) * k + I;
            break;
          case Gt.R: {
            s = a = e[f++], l = o = e[f++];
            var F = e[f++], E = e[f++];
            v = F * 2 + E * 2;
            break;
          }
          case Gt.Z: {
            var y = s - a, _ = l - o;
            v = Math.sqrt(y * y + _ * _), a = s, o = l;
            break;
          }
        }
        v >= 0 && (u[h++] = v, c += v);
      }
      return this._pathLen = c, c;
    }, t.prototype.rebuildPath = function(e, r) {
      var n = this.data, i = this._ux, a = this._uy, o = this._len, s, l, u, c, h, f, d = r < 1, p, v, g = 0, m = 0, y, _ = 0, b, w;
      if (!(d && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, v = this._pathLen, y = r * v, !y))) e: for (var x = 0; x < o; ) {
        var T = n[x++], A = x === 1;
        switch (A && (u = n[x], c = n[x + 1], s = u, l = c), T !== Gt.L && _ > 0 && (e.lineTo(b, w), _ = 0), T) {
          case Gt.M:
            s = u = n[x++], l = c = n[x++], e.moveTo(u, c);
            break;
          case Gt.L: {
            h = n[x++], f = n[x++];
            var I = Wa(h - u), M = Wa(f - c);
            if (I > i || M > a) {
              if (d) {
                var k = p[m++];
                if (g + k > y) {
                  var B = (y - g) / k;
                  e.lineTo(u * (1 - B) + h * B, c * (1 - B) + f * B);
                  break e;
                }
                g += k;
              }
              e.lineTo(h, f), u = h, c = f, _ = 0;
            } else {
              var L = I * I + M * M;
              L > _ && (b = h, w = f, _ = L);
            }
            break;
          }
          case Gt.C: {
            var z = n[x++], F = n[x++], E = n[x++], O = n[x++], N = n[x++], V = n[x++];
            if (d) {
              var k = p[m++];
              if (g + k > y) {
                var B = (y - g) / k;
                fs(u, z, E, N, B, Rs), fs(c, F, O, V, B, Os), e.bezierCurveTo(Rs[1], Os[1], Rs[2], Os[2], Rs[3], Os[3]);
                break e;
              }
              g += k;
            }
            e.bezierCurveTo(z, F, E, O, N, V), u = N, c = V;
            break;
          }
          case Gt.Q: {
            var z = n[x++], F = n[x++], E = n[x++], O = n[x++];
            if (d) {
              var k = p[m++];
              if (g + k > y) {
                var B = (y - g) / k;
                Gf(u, z, E, B, Rs), Gf(c, F, O, B, Os), e.quadraticCurveTo(Rs[1], Os[1], Rs[2], Os[2]);
                break e;
              }
              g += k;
            }
            e.quadraticCurveTo(z, F, E, O), u = E, c = O;
            break;
          }
          case Gt.A:
            var H = n[x++], G = n[x++], Y = n[x++], U = n[x++], Z = n[x++], ee = n[x++], we = n[x++], Te = !n[x++], le = Y > U ? Y : U, ue = Wa(Y - U) > 1e-3, ye = Z + ee, ve = false;
            if (d) {
              var k = p[m++];
              g + k > y && (ye = Z + ee * (y - g) / k, ve = true), g += k;
            }
            if (ue && e.ellipse ? e.ellipse(H, G, Y, U, we, Z, ye, Te) : e.arc(H, G, le, Z, ye, Te), ve) break e;
            A && (s = Ns(Z) * Y + H, l = Bs(Z) * U + G), u = Ns(ye) * Y + H, c = Bs(ye) * U + G;
            break;
          case Gt.R:
            s = u = n[x], l = c = n[x + 1], h = n[x++], f = n[x++];
            var Se = n[x++], Qe = n[x++];
            if (d) {
              var k = p[m++];
              if (g + k > y) {
                var Xe = y - g;
                e.moveTo(h, f), e.lineTo(h + x0(Xe, Se), f), Xe -= Se, Xe > 0 && e.lineTo(h + Se, f + x0(Xe, Qe)), Xe -= Qe, Xe > 0 && e.lineTo(h + w0(Se - Xe, 0), f + Qe), Xe -= Se, Xe > 0 && e.lineTo(h, f + w0(Qe - Xe, 0));
                break e;
              }
              g += k;
            }
            e.rect(h, f, Se, Qe);
            break;
          case Gt.Z:
            if (d) {
              var k = p[m++];
              if (g + k > y) {
                var B = (y - g) / k;
                e.lineTo(u * (1 - B) + s * B, c * (1 - B) + l * B);
                break e;
              }
              g += k;
            }
            e.closePath(), u = s, c = l;
        }
      }
    }, t.prototype.clone = function() {
      var e = new t(), r = this.data;
      return e.data = r.slice ? r.slice() : Array.prototype.slice.call(r), e._len = this._len, e;
    }, t.CMD = Gt, t.initDefaultProps = function() {
      var e = t.prototype;
      e._saveData = true, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
    }(), t;
  }();
  function qo(t, e, r, n, i, a, o) {
    if (i === 0) return false;
    var s = i, l = 0, u = t;
    if (o > e + s && o > n + s || o < e - s && o < n - s || a > t + s && a > r + s || a < t - s && a < r - s) return false;
    if (t !== r) l = (e - n) / (t - r), u = (t * n - r * e) / (t - r);
    else return Math.abs(a - t) <= s / 2;
    var c = l * a - o + u, h = c * c / (l * l + 1);
    return h <= s / 2 * s / 2;
  }
  function RQ(t, e, r, n, i, a, o, s, l, u, c) {
    if (l === 0) return false;
    var h = l;
    if (c > e + h && c > n + h && c > a + h && c > s + h || c < e - h && c < n - h && c < a - h && c < s - h || u > t + h && u > r + h && u > i + h && u > o + h || u < t - h && u < r - h && u < i - h && u < o - h) return false;
    var f = zF(t, e, r, n, i, a, o, s, u, c, null);
    return f <= h / 2;
  }
  function b4(t, e, r, n, i, a, o, s, l) {
    if (o === 0) return false;
    var u = o;
    if (l > e + u && l > n + u && l > a + u || l < e - u && l < n - u && l < a - u || s > t + u && s > r + u && s > i + u || s < t - u && s < r - u && s < i - u) return false;
    var c = VF(t, e, r, n, i, a, s, l, null);
    return c <= u / 2;
  }
  var oD = Math.PI * 2;
  function Wn(t) {
    return t %= oD, t < 0 && (t += oD), t;
  }
  var hh = Math.PI * 2;
  function OQ(t, e, r, n, i, a, o, s, l) {
    if (o === 0) return false;
    var u = o;
    s -= t, l -= e;
    var c = Math.sqrt(s * s + l * l);
    if (c - u > r || c + u < r) return false;
    if (Math.abs(n - i) % hh < 1e-4) return true;
    if (a) {
      var h = n;
      n = Wn(i), i = Wn(h);
    } else n = Wn(n), i = Wn(i);
    n > i && (i += hh);
    var f = Math.atan2(l, s);
    return f < 0 && (f += hh), f >= n && f <= i || f + hh >= n && f + hh <= i;
  }
  function Za(t, e, r, n, i, a) {
    if (a > e && a > n || a < e && a < n || n === e) return 0;
    var o = (a - e) / (n - e), s = n < e ? 1 : -1;
    (o === 1 || o === 0) && (s = n < e ? 0.5 : -0.5);
    var l = o * (r - t) + t;
    return l === i ? 1 / 0 : l > i ? s : 0;
  }
  var Eo = Ra.CMD, zs = Math.PI * 2, NQ = 1e-4;
  function BQ(t, e) {
    return Math.abs(t - e) < NQ;
  }
  var dn = [
    -1,
    -1,
    -1
  ], ci = [
    -1,
    -1
  ];
  function zQ() {
    var t = ci[0];
    ci[0] = ci[1], ci[1] = t;
  }
  function FQ(t, e, r, n, i, a, o, s, l, u) {
    if (u > e && u > n && u > a && u > s || u < e && u < n && u < a && u < s) return 0;
    var c = Tg(e, n, a, s, u, dn);
    if (c === 0) return 0;
    for (var h = 0, f = -1, d = void 0, p = void 0, v = 0; v < c; v++) {
      var g = dn[v], m = g === 0 || g === 1 ? 0.5 : 1, y = Ar(t, r, i, o, g);
      y < l || (f < 0 && (f = BF(e, n, a, s, ci), ci[1] < ci[0] && f > 1 && zQ(), d = Ar(e, n, a, s, ci[0]), f > 1 && (p = Ar(e, n, a, s, ci[1]))), f === 2 ? g < ci[0] ? h += d < e ? m : -m : g < ci[1] ? h += p < d ? m : -m : h += s < p ? m : -m : g < ci[0] ? h += d < e ? m : -m : h += s < d ? m : -m);
    }
    return h;
  }
  function VQ(t, e, r, n, i, a, o, s) {
    if (s > e && s > n && s > a || s < e && s < n && s < a) return 0;
    var l = QK(e, n, a, s, dn);
    if (l === 0) return 0;
    var u = FF(e, n, a);
    if (u >= 0 && u <= 1) {
      for (var c = 0, h = Br(e, n, a, u), f = 0; f < l; f++) {
        var d = dn[f] === 0 || dn[f] === 1 ? 0.5 : 1, p = Br(t, r, i, dn[f]);
        p < o || (dn[f] < u ? c += h < e ? d : -d : c += a < h ? d : -d);
      }
      return c;
    } else {
      var d = dn[0] === 0 || dn[0] === 1 ? 0.5 : 1, p = Br(t, r, i, dn[0]);
      return p < o ? 0 : a < e ? d : -d;
    }
  }
  function GQ(t, e, r, n, i, a, o, s) {
    if (s -= e, s > r || s < -r) return 0;
    var l = Math.sqrt(r * r - s * s);
    dn[0] = -l, dn[1] = l;
    var u = Math.abs(n - i);
    if (u < 1e-4) return 0;
    if (u >= zs - 1e-4) {
      n = 0, i = zs;
      var c = a ? 1 : -1;
      return o >= dn[0] + t && o <= dn[1] + t ? c : 0;
    }
    if (n > i) {
      var h = n;
      n = i, i = h;
    }
    n < 0 && (n += zs, i += zs);
    for (var f = 0, d = 0; d < 2; d++) {
      var p = dn[d];
      if (p + t > o) {
        var v = Math.atan2(s, p), c = a ? 1 : -1;
        v < 0 && (v = zs + v), (v >= n && v <= i || v + zs >= n && v + zs <= i) && (v > Math.PI / 2 && v < Math.PI * 1.5 && (c = -c), f += c);
      }
    }
    return f;
  }
  function x4(t, e, r, n, i) {
    for (var a = t.data, o = t.len(), s = 0, l = 0, u = 0, c = 0, h = 0, f, d, p = 0; p < o; ) {
      var v = a[p++], g = p === 1;
      switch (v === Eo.M && p > 1 && (r || (s += Za(l, u, c, h, n, i))), g && (l = a[p], u = a[p + 1], c = l, h = u), v) {
        case Eo.M:
          c = a[p++], h = a[p++], l = c, u = h;
          break;
        case Eo.L:
          if (r) {
            if (qo(l, u, a[p], a[p + 1], e, n, i)) return true;
          } else s += Za(l, u, a[p], a[p + 1], n, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case Eo.C:
          if (r) {
            if (RQ(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], e, n, i)) return true;
          } else s += FQ(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], n, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case Eo.Q:
          if (r) {
            if (b4(l, u, a[p++], a[p++], a[p], a[p + 1], e, n, i)) return true;
          } else s += VQ(l, u, a[p++], a[p++], a[p], a[p + 1], n, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case Eo.A:
          var m = a[p++], y = a[p++], _ = a[p++], b = a[p++], w = a[p++], x = a[p++];
          p += 1;
          var T = !!(1 - a[p++]);
          f = Math.cos(w) * _ + m, d = Math.sin(w) * b + y, g ? (c = f, h = d) : s += Za(l, u, f, d, n, i);
          var A = (n - m) * b / _ + m;
          if (r) {
            if (OQ(m, y, b, w, w + x, T, e, A, i)) return true;
          } else s += GQ(m, y, b, w, w + x, T, A, i);
          l = Math.cos(w + x) * _ + m, u = Math.sin(w + x) * b + y;
          break;
        case Eo.R:
          c = l = a[p++], h = u = a[p++];
          var I = a[p++], M = a[p++];
          if (f = c + I, d = h + M, r) {
            if (qo(c, h, f, h, e, n, i) || qo(f, h, f, d, e, n, i) || qo(f, d, c, d, e, n, i) || qo(c, d, c, h, e, n, i)) return true;
          } else s += Za(f, h, f, d, n, i), s += Za(c, d, c, h, n, i);
          break;
        case Eo.Z:
          if (r) {
            if (qo(l, u, c, h, e, n, i)) return true;
          } else s += Za(l, u, c, h, n, i);
          l = c, u = h;
          break;
      }
    }
    return !r && !BQ(u, h) && (s += Za(l, u, c, h, n, i) || 0), s !== 0;
  }
  function WQ(t, e, r) {
    return x4(t, 0, false, e, r);
  }
  function HQ(t, e, r, n) {
    return x4(t, e, true, r, n);
  }
  var Eg = Ee({
    fill: "#000",
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
  }, Rl), UQ = {
    style: Ee({
      fill: true,
      stroke: true,
      strokePercent: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineDashOffset: true,
      lineWidth: true,
      miterLimit: true
    }, Wm.style)
  }, C0 = La.concat([
    "invisible",
    "culling",
    "z",
    "z2",
    "zlevel",
    "parent"
  ]), st = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.update = function() {
      var r = this;
      t.prototype.update.call(this);
      var n = this.style;
      if (n.decal) {
        var i = this._decalEl = this._decalEl || new e();
        i.buildPath === e.prototype.buildPath && (i.buildPath = function(l) {
          r.buildPath(l, r.shape);
        }), i.silent = true;
        var a = i.style;
        for (var o in n) a[o] !== n[o] && (a[o] = n[o]);
        a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
        for (var s = 0; s < C0.length; ++s) i[C0[s]] = this[C0[s]];
        i.__dirty |= Ia;
      } else this._decalEl && (this._decalEl = null);
    }, e.prototype.getDecalElement = function() {
      return this._decalEl;
    }, e.prototype._init = function(r) {
      var n = gt(r);
      this.shape = this.getDefaultShape();
      var i = this.getDefaultStyle();
      i && this.useStyle(i);
      for (var a = 0; a < n.length; a++) {
        var o = n[a], s = r[o];
        o === "style" ? this.style ? te(this.style, s) : this.useStyle(s) : o === "shape" ? te(this.shape, s) : t.prototype.attrKV.call(this, o, s);
      }
      this.style || this.useStyle({});
    }, e.prototype.getDefaultStyle = function() {
      return null;
    }, e.prototype.getDefaultShape = function() {
      return {};
    }, e.prototype.canBeInsideText = function() {
      return this.hasFill();
    }, e.prototype.getInsideTextFill = function() {
      var r = this.style.fill;
      if (r !== "none") {
        if (me(r)) {
          var n = Ag(r, 0);
          return n > 0.5 ? bx : n > 0.2 ? IZ : xx;
        } else if (r) return xx;
      }
      return bx;
    }, e.prototype.getInsideTextStroke = function(r) {
      var n = this.style.fill;
      if (me(n)) {
        var i = this.__zr, a = !!(i && i.isDarkMode()), o = Ag(r, 0) < _x;
        if (a === o) return n;
      }
    }, e.prototype.buildPath = function(r, n, i) {
    }, e.prototype.pathUpdated = function() {
      this.__dirty &= -5;
    }, e.prototype.getUpdatedPathProxy = function(r) {
      return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, r), this.path;
    }, e.prototype.createPathProxy = function() {
      this.path = new Ra(false);
    }, e.prototype.hasStroke = function() {
      var r = this.style, n = r.stroke;
      return !(n == null || n === "none" || !(r.lineWidth > 0));
    }, e.prototype.hasFill = function() {
      var r = this.style, n = r.fill;
      return n != null && n !== "none";
    }, e.prototype.getBoundingRect = function() {
      var r = this._rect, n = this.style, i = !r;
      if (i) {
        var a = false;
        this.path || (a = true, this.createPathProxy());
        var o = this.path;
        (a || this.__dirty & Kh) && (o.beginPath(), this.buildPath(o, this.shape, false), this.pathUpdated()), r = o.getBoundingRect();
      }
      if (this._rect = r, this.hasStroke() && this.path && this.path.len() > 0) {
        var s = this._rectStroke || (this._rectStroke = r.clone());
        if (this.__dirty || i) {
          s.copy(r);
          var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
          if (!this.hasFill()) {
            var c = this.strokeContainThreshold;
            u = Math.max(u, c ?? 4);
          }
          l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
        }
        return s;
      }
      return r;
    }, e.prototype.contain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), a = this.getBoundingRect(), o = this.style;
      if (r = i[0], n = i[1], a.contain(r, n)) {
        var s = this.path;
        if (this.hasStroke()) {
          var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
          if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), HQ(s, l / u, r, n))) return true;
        }
        if (this.hasFill()) return WQ(s, r, n);
      }
      return false;
    }, e.prototype.dirtyShape = function() {
      this.__dirty |= Kh, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
    }, e.prototype.dirty = function() {
      this.dirtyStyle(), this.dirtyShape();
    }, e.prototype.animateShape = function(r) {
      return this.animate("shape", r);
    }, e.prototype.updateDuringAnimation = function(r) {
      r === "style" ? this.dirtyStyle() : r === "shape" ? this.dirtyShape() : this.markRedraw();
    }, e.prototype.attrKV = function(r, n) {
      r === "shape" ? this.setShape(n) : t.prototype.attrKV.call(this, r, n);
    }, e.prototype.setShape = function(r, n) {
      var i = this.shape;
      return i || (i = this.shape = {}), typeof r == "string" ? i[r] = n : te(i, r), this.dirtyShape(), this;
    }, e.prototype.shapeChanged = function() {
      return !!(this.__dirty & Kh);
    }, e.prototype.createStyle = function(r) {
      return Om(Eg, r);
    }, e.prototype._innerSaveToNormal = function(r) {
      t.prototype._innerSaveToNormal.call(this, r);
      var n = this._normalState;
      r.shape && !n.shape && (n.shape = te({}, this.shape));
    }, e.prototype._applyStateObj = function(r, n, i, a, o, s) {
      t.prototype._applyStateObj.call(this, r, n, i, a, o, s);
      var l = !(n && a), u;
      if (n && n.shape ? o ? a ? u = n.shape : (u = te({}, i.shape), te(u, n.shape)) : (u = te({}, a ? this.shape : i.shape), te(u, n.shape)) : l && (u = i.shape), u) if (o) {
        this.shape = te({}, this.shape);
        for (var c = {}, h = gt(u), f = 0; f < h.length; f++) {
          var d = h[f];
          typeof u[d] == "object" ? this.shape[d] = u[d] : c[d] = u[d];
        }
        this._transitionState(r, {
          shape: c
        }, s);
      } else this.shape = u, this.dirtyShape();
    }, e.prototype._mergeStates = function(r) {
      for (var n = t.prototype._mergeStates.call(this, r), i, a = 0; a < r.length; a++) {
        var o = r[a];
        o.shape && (i = i || {}, this._mergeStyle(i, o.shape));
      }
      return i && (n.shape = i), n;
    }, e.prototype.getAnimationStyleProps = function() {
      return UQ;
    }, e.prototype.isZeroArea = function() {
      return false;
    }, e.extend = function(r) {
      var n = function(a) {
        K(o, a);
        function o(s) {
          var l = a.call(this, s) || this;
          return r.init && r.init.call(l, s), l;
        }
        return o.prototype.getDefaultStyle = function() {
          return Oe(r.style);
        }, o.prototype.getDefaultShape = function() {
          return Oe(r.shape);
        }, o;
      }(e);
      for (var i in r) typeof r[i] == "function" && (n.prototype[i] = r[i]);
      return n;
    }, e.initDefaultProps = function() {
      var r = e.prototype;
      r.type = "path", r.strokeContainThreshold = 5, r.segmentIgnoreThreshold = 0, r.subPixelOptimize = false, r.autoBatch = false, r.__dirty = Ia | Qv | Kh;
    }(), e;
  }(bi), YQ = Ee({
    strokeFirst: true,
    font: cs,
    x: 0,
    y: 0,
    textAlign: "left",
    textBaseline: "top",
    miterLimit: 2
  }, Eg), mc = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.hasStroke = function() {
      var r = this.style, n = r.stroke;
      return n != null && n !== "none" && r.lineWidth > 0;
    }, e.prototype.hasFill = function() {
      var r = this.style, n = r.fill;
      return n != null && n !== "none";
    }, e.prototype.createStyle = function(r) {
      return Om(YQ, r);
    }, e.prototype.setBoundingRect = function(r) {
      this._rect = r;
    }, e.prototype.getBoundingRect = function() {
      var r = this.style;
      if (!this._rect) {
        var n = r.text;
        n != null ? n += "" : n = "";
        var i = Dd(n, r.font, r.textAlign, r.textBaseline);
        if (i.x += r.x || 0, i.y += r.y || 0, this.hasStroke()) {
          var a = r.lineWidth;
          i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a;
        }
        this._rect = i;
      }
      return this._rect;
    }, e.initDefaultProps = function() {
      var r = e.prototype;
      r.dirtyRectTolerance = 10;
    }(), e;
  }(bi);
  mc.prototype.type = "tspan";
  var qQ = Ee({
    x: 0,
    y: 0
  }, Rl), XQ = {
    style: Ee({
      x: true,
      y: true,
      width: true,
      height: true,
      sx: true,
      sy: true,
      sWidth: true,
      sHeight: true
    }, Wm.style)
  };
  function jQ(t) {
    return !!(t && typeof t != "string" && t.width && t.height);
  }
  var Gr = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.createStyle = function(r) {
      return Om(qQ, r);
    }, e.prototype._getSize = function(r) {
      var n = this.style, i = n[r];
      if (i != null) return i;
      var a = jQ(n.image) ? n.image : this.__image;
      if (!a) return 0;
      var o = r === "width" ? "height" : "width", s = n[o];
      return s == null ? a[r] : a[r] / a[o] * s;
    }, e.prototype.getWidth = function() {
      return this._getSize("width");
    }, e.prototype.getHeight = function() {
      return this._getSize("height");
    }, e.prototype.getAnimationStyleProps = function() {
      return XQ;
    }, e.prototype.getBoundingRect = function() {
      var r = this.style;
      return this._rect || (this._rect = new Ze(r.x || 0, r.y || 0, this.getWidth(), this.getHeight())), this._rect;
    }, e;
  }(bi);
  Gr.prototype.type = "image";
  function KQ(t, e) {
    var r = e.x, n = e.y, i = e.width, a = e.height, o = e.r, s, l, u, c;
    i < 0 && (r = r + i, i = -i), a < 0 && (n = n + a, a = -a), typeof o == "number" ? s = l = u = c = o : o instanceof Array ? o.length === 1 ? s = l = u = c = o[0] : o.length === 2 ? (s = u = o[0], l = c = o[1]) : o.length === 3 ? (s = o[0], l = c = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], c = o[3]) : s = l = u = c = 0;
    var h;
    s + l > i && (h = s + l, s *= i / h, l *= i / h), u + c > i && (h = u + c, u *= i / h, c *= i / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), s + c > a && (h = s + c, s *= a / h, c *= a / h), t.moveTo(r + s, n), t.lineTo(r + i - l, n), l !== 0 && t.arc(r + i - l, n + l, l, -Math.PI / 2, 0), t.lineTo(r + i, n + a - u), u !== 0 && t.arc(r + i - u, n + a - u, u, 0, Math.PI / 2), t.lineTo(r + c, n + a), c !== 0 && t.arc(r + c, n + a - c, c, Math.PI / 2, Math.PI), t.lineTo(r, n + s), s !== 0 && t.arc(r + s, n + s, s, Math.PI, Math.PI * 1.5);
  }
  var nc = Math.round;
  function w4(t, e, r) {
    if (e) {
      var n = e.x1, i = e.x2, a = e.y1, o = e.y2;
      t.x1 = n, t.x2 = i, t.y1 = a, t.y2 = o;
      var s = r && r.lineWidth;
      return s && (nc(n * 2) === nc(i * 2) && (t.x1 = t.x2 = Sl(n, s, true)), nc(a * 2) === nc(o * 2) && (t.y1 = t.y2 = Sl(a, s, true))), t;
    }
  }
  function S4(t, e, r) {
    if (e) {
      var n = e.x, i = e.y, a = e.width, o = e.height;
      t.x = n, t.y = i, t.width = a, t.height = o;
      var s = r && r.lineWidth;
      return s && (t.x = Sl(n, s, true), t.y = Sl(i, s, true), t.width = Math.max(Sl(n + a, s, false) - t.x, a === 0 ? 0 : 1), t.height = Math.max(Sl(i + o, s, false) - t.y, o === 0 ? 0 : 1)), t;
    }
  }
  function Sl(t, e, r) {
    if (!e) return t;
    var n = nc(t * 2);
    return (n + nc(e)) % 2 === 0 ? n / 2 : (n + (r ? 1 : -1)) / 2;
  }
  var ZQ = /* @__PURE__ */ function() {
    function t() {
      this.x = 0, this.y = 0, this.width = 0, this.height = 0;
    }
    return t;
  }(), QQ = {}, yt = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new ZQ();
    }, e.prototype.buildPath = function(r, n) {
      var i, a, o, s;
      if (this.subPixelOptimize) {
        var l = S4(QQ, n, this.style);
        i = l.x, a = l.y, o = l.width, s = l.height, l.r = n.r, n = l;
      } else i = n.x, a = n.y, o = n.width, s = n.height;
      n.r ? KQ(r, n) : r.rect(i, a, o, s);
    }, e.prototype.isZeroArea = function() {
      return !this.shape.width || !this.shape.height;
    }, e;
  }(st);
  yt.prototype.type = "rect";
  var sD = {
    fill: "#000"
  }, lD = 2, JQ = {
    style: Ee({
      fill: true,
      stroke: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineWidth: true,
      fontSize: true,
      lineHeight: true,
      width: true,
      height: true,
      textShadowColor: true,
      textShadowBlur: true,
      textShadowOffsetX: true,
      textShadowOffsetY: true,
      backgroundColor: true,
      padding: true,
      borderColor: true,
      borderWidth: true,
      borderRadius: true
    }, Wm.style)
  }, bt = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this) || this;
      return n.type = "text", n._children = [], n._defaultStyle = sD, n.attr(r), n;
    }
    return e.prototype.childrenRef = function() {
      return this._children;
    }, e.prototype.update = function() {
      t.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
      for (var r = 0; r < this._children.length; r++) {
        var n = this._children[r];
        n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
      }
    }, e.prototype.updateTransform = function() {
      var r = this.innerTransformable;
      r ? (r.updateTransform(), r.transform && (this.transform = r.transform)) : t.prototype.updateTransform.call(this);
    }, e.prototype.getLocalTransform = function(r) {
      var n = this.innerTransformable;
      return n ? n.getLocalTransform(r) : t.prototype.getLocalTransform.call(this, r);
    }, e.prototype.getComputedTransform = function() {
      return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(true)), t.prototype.getComputedTransform.call(this);
    }, e.prototype._updateSubTexts = function() {
      this._childCursor = 0, rJ(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
    }, e.prototype.addSelfToZr = function(r) {
      t.prototype.addSelfToZr.call(this, r);
      for (var n = 0; n < this._children.length; n++) this._children[n].__zr = r;
    }, e.prototype.removeSelfFromZr = function(r) {
      t.prototype.removeSelfFromZr.call(this, r);
      for (var n = 0; n < this._children.length; n++) this._children[n].__zr = null;
    }, e.prototype.getBoundingRect = function() {
      if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
        for (var r = new Ze(0, 0, 0, 0), n = this._children, i = [], a = null, o = 0; o < n.length; o++) {
          var s = n[o], l = s.getBoundingRect(), u = s.getLocalTransform(i);
          u ? (r.copy(l), r.applyTransform(u), a = a || r.clone(), a.union(r)) : (a = a || l.clone(), a.union(l));
        }
        this._rect = a || r;
      }
      return this._rect;
    }, e.prototype.setDefaultTextStyle = function(r) {
      this._defaultStyle = r || sD;
    }, e.prototype.setTextContent = function(r) {
    }, e.prototype._mergeStyle = function(r, n) {
      if (!n) return r;
      var i = n.rich, a = r.rich || i && {};
      return te(r, n), i && a ? (this._mergeRich(a, i), r.rich = a) : a && (r.rich = a), r;
    }, e.prototype._mergeRich = function(r, n) {
      for (var i = gt(n), a = 0; a < i.length; a++) {
        var o = i[a];
        r[o] = r[o] || {}, te(r[o], n[o]);
      }
    }, e.prototype.getAnimationStyleProps = function() {
      return JQ;
    }, e.prototype._getOrCreateChild = function(r) {
      var n = this._children[this._childCursor];
      return (!n || !(n instanceof r)) && (n = new r()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
    }, e.prototype._updatePlainTexts = function() {
      var r = this.style, n = r.font || cs, i = r.padding, a = vD(r), o = SQ(a, r), s = A0(r), l = !!r.backgroundColor, u = o.outerHeight, c = o.outerWidth, h = o.contentWidth, f = o.lines, d = o.lineHeight, p = this._defaultStyle;
      this.isTruncated = !!o.isTruncated;
      var v = r.x || 0, g = r.y || 0, m = r.align || p.align || "left", y = r.verticalAlign || p.verticalAlign || "top", _ = v, b = Yu(g, o.contentHeight, y);
      if (s || i) {
        var w = Qh(v, c, m), x = Yu(g, u, y);
        s && this._renderBackground(r, r, w, x, c, u);
      }
      b += d / 2, i && (_ = pD(v, m, i), y === "top" ? b += i[0] : y === "bottom" && (b -= i[2]));
      for (var T = 0, A = false, I = dD("fill" in r ? r.fill : (A = true, p.fill)), M = fD("stroke" in r ? r.stroke : !l && (!p.autoStroke || A) ? (T = lD, p.stroke) : null), k = r.textShadowBlur > 0, B = r.width != null && (r.overflow === "truncate" || r.overflow === "break" || r.overflow === "breakAll"), L = o.calculatedLineHeight, z = 0; z < f.length; z++) {
        var F = this._getOrCreateChild(mc), E = F.createStyle();
        F.useStyle(E), E.text = f[z], E.x = _, E.y = b, E.textAlign = m, E.textBaseline = "middle", E.opacity = r.opacity, E.strokeFirst = true, k && (E.shadowBlur = r.textShadowBlur || 0, E.shadowColor = r.textShadowColor || "transparent", E.shadowOffsetX = r.textShadowOffsetX || 0, E.shadowOffsetY = r.textShadowOffsetY || 0), E.stroke = M, E.fill = I, M && (E.lineWidth = r.lineWidth || T, E.lineDash = r.lineDash, E.lineDashOffset = r.lineDashOffset || 0), E.font = n, cD(E, r), b += d, B && F.setBoundingRect(new Ze(Qh(E.x, h, E.textAlign), Yu(E.y, L, E.textBaseline), h, L));
      }
    }, e.prototype._updateRichTexts = function() {
      var r = this.style, n = vD(r), i = AQ(n, r), a = i.width, o = i.outerWidth, s = i.outerHeight, l = r.padding, u = r.x || 0, c = r.y || 0, h = this._defaultStyle, f = r.align || h.align, d = r.verticalAlign || h.verticalAlign;
      this.isTruncated = !!i.isTruncated;
      var p = Qh(u, o, f), v = Yu(c, s, d), g = p, m = v;
      l && (g += l[3], m += l[0]);
      var y = g + a;
      A0(r) && this._renderBackground(r, r, p, v, o, s);
      for (var _ = !!r.backgroundColor, b = 0; b < i.lines.length; b++) {
        for (var w = i.lines[b], x = w.tokens, T = x.length, A = w.lineHeight, I = w.width, M = 0, k = g, B = y, L = T - 1, z = void 0; M < T && (z = x[M], !z.align || z.align === "left"); ) this._placeToken(z, r, A, m, k, "left", _), I -= z.width, k += z.width, M++;
        for (; L >= 0 && (z = x[L], z.align === "right"); ) this._placeToken(z, r, A, m, B, "right", _), I -= z.width, B -= z.width, L--;
        for (k += (a - (k - g) - (y - B) - I) / 2; M <= L; ) z = x[M], this._placeToken(z, r, A, m, k + z.width / 2, "center", _), k += z.width, M++;
        m += A;
      }
    }, e.prototype._placeToken = function(r, n, i, a, o, s, l) {
      var u = n.rich[r.styleName] || {};
      u.text = r.text;
      var c = r.verticalAlign, h = a + i / 2;
      c === "top" ? h = a + r.height / 2 : c === "bottom" && (h = a + i - r.height / 2);
      var f = !r.isLineHolder && A0(u);
      f && this._renderBackground(u, n, s === "right" ? o - r.width : s === "center" ? o - r.width / 2 : o, h - r.height / 2, r.width, r.height);
      var d = !!u.backgroundColor, p = r.textPadding;
      p && (o = pD(o, s, p), h -= r.height / 2 - p[0] - r.innerHeight / 2);
      var v = this._getOrCreateChild(mc), g = v.createStyle();
      v.useStyle(g);
      var m = this._defaultStyle, y = false, _ = 0, b = dD("fill" in u ? u.fill : "fill" in n ? n.fill : (y = true, m.fill)), w = fD("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !d && !l && (!m.autoStroke || y) ? (_ = lD, m.stroke) : null), x = u.textShadowBlur > 0 || n.textShadowBlur > 0;
      g.text = r.text, g.x = o, g.y = h, x && (g.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, g.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", g.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, g.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), g.textAlign = s, g.textBaseline = "middle", g.font = r.font || cs, g.opacity = Aa(u.opacity, n.opacity, 1), cD(g, u), w && (g.lineWidth = Aa(u.lineWidth, n.lineWidth, _), g.lineDash = We(u.lineDash, n.lineDash), g.lineDashOffset = n.lineDashOffset || 0, g.stroke = w), b && (g.fill = b);
      var T = r.contentWidth, A = r.contentHeight;
      v.setBoundingRect(new Ze(Qh(g.x, T, g.textAlign), Yu(g.y, A, g.textBaseline), T, A));
    }, e.prototype._renderBackground = function(r, n, i, a, o, s) {
      var l = r.backgroundColor, u = r.borderWidth, c = r.borderColor, h = l && l.image, f = l && !h, d = r.borderRadius, p = this, v, g;
      if (f || r.lineHeight || u && c) {
        v = this._getOrCreateChild(yt), v.useStyle(v.createStyle()), v.style.fill = null;
        var m = v.shape;
        m.x = i, m.y = a, m.width = o, m.height = s, m.r = d, v.dirtyShape();
      }
      if (f) {
        var y = v.style;
        y.fill = l || null, y.fillOpacity = We(r.fillOpacity, 1);
      } else if (h) {
        g = this._getOrCreateChild(Gr), g.onload = function() {
          p.dirtyStyle();
        };
        var _ = g.style;
        _.image = l.image, _.x = i, _.y = a, _.width = o, _.height = s;
      }
      if (u && c) {
        var y = v.style;
        y.lineWidth = u, y.stroke = c, y.strokeOpacity = We(r.strokeOpacity, 1), y.lineDash = r.borderDash, y.lineDashOffset = r.borderDashOffset || 0, v.strokeContainThreshold = 0, v.hasFill() && v.hasStroke() && (y.strokeFirst = true, y.lineWidth *= 2);
      }
      var b = (v || g).style;
      b.shadowBlur = r.shadowBlur || 0, b.shadowColor = r.shadowColor || "transparent", b.shadowOffsetX = r.shadowOffsetX || 0, b.shadowOffsetY = r.shadowOffsetY || 0, b.opacity = Aa(r.opacity, n.opacity, 1);
    }, e.makeFont = function(r) {
      var n = "";
      return C4(r) && (n = [
        r.fontStyle,
        r.fontWeight,
        T4(r.fontSize),
        r.fontFamily || "sans-serif"
      ].join(" ")), n && Vi(n) || r.textFont || r.font;
    }, e;
  }(bi), eJ = {
    left: true,
    right: 1,
    center: 1
  }, tJ = {
    top: 1,
    bottom: 1,
    middle: 1
  }, uD = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily"
  ];
  function T4(t) {
    return typeof t == "string" && (t.indexOf("px") !== -1 || t.indexOf("rem") !== -1 || t.indexOf("em") !== -1) ? t : isNaN(+t) ? WS + "px" : t + "px";
  }
  function cD(t, e) {
    for (var r = 0; r < uD.length; r++) {
      var n = uD[r], i = e[n];
      i != null && (t[n] = i);
    }
  }
  function C4(t) {
    return t.fontSize != null || t.fontFamily || t.fontWeight;
  }
  function rJ(t) {
    return hD(t), $(t.rich, hD), t;
  }
  function hD(t) {
    if (t) {
      t.font = bt.makeFont(t);
      var e = t.align;
      e === "middle" && (e = "center"), t.align = e == null || eJ[e] ? e : "left";
      var r = t.verticalAlign;
      r === "center" && (r = "middle"), t.verticalAlign = r == null || tJ[r] ? r : "top";
      var n = t.padding;
      n && (t.padding = jS(t.padding));
    }
  }
  function fD(t, e) {
    return t == null || e <= 0 || t === "transparent" || t === "none" ? null : t.image || t.colorStops ? "#000" : t;
  }
  function dD(t) {
    return t == null || t === "none" ? null : t.image || t.colorStops ? "#000" : t;
  }
  function pD(t, e, r) {
    return e === "right" ? t - r[1] : e === "center" ? t + r[3] / 2 - r[1] / 2 : t + r[3];
  }
  function vD(t) {
    var e = t.text;
    return e != null && (e += ""), e;
  }
  function A0(t) {
    return !!(t.backgroundColor || t.lineHeight || t.borderWidth && t.borderColor);
  }
  var Ge = _t(), Mx = function(t, e, r, n) {
    if (n) {
      var i = Ge(n);
      i.dataIndex = r, i.dataType = e, i.seriesIndex = t, i.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
        var o = Ge(a);
        o.seriesIndex = t, o.dataIndex = r, o.dataType = e, o.ssrType = "chart";
      });
    }
  }, gD = 1, mD = {}, A4 = _t(), lT = _t(), uT = 0, kd = 1, Um = 2, xn = [
    "emphasis",
    "blur",
    "select"
  ], qf = [
    "normal",
    "emphasis",
    "blur",
    "select"
  ], Vc = 10, nJ = 9, Ol = "highlight", ng = "downplay", Sf = "select", ig = "unselect", Tf = "toggleSelect";
  function xu(t) {
    return t != null && t !== "none";
  }
  function Ym(t, e, r) {
    t.onHoverStateChange && (t.hoverState || 0) !== r && t.onHoverStateChange(e), t.hoverState = r;
  }
  function I4(t) {
    Ym(t, "emphasis", Um);
  }
  function M4(t) {
    t.hoverState === Um && Ym(t, "normal", uT);
  }
  function cT(t) {
    Ym(t, "blur", kd);
  }
  function D4(t) {
    t.hoverState === kd && Ym(t, "normal", uT);
  }
  function iJ(t) {
    t.selected = true;
  }
  function aJ(t) {
    t.selected = false;
  }
  function yD(t, e, r) {
    e(t, r);
  }
  function xo(t, e, r) {
    yD(t, e, r), t.isGroup && t.traverse(function(n) {
      yD(n, e, r);
    });
  }
  function kg(t, e) {
    switch (e) {
      case "emphasis":
        t.hoverState = Um;
        break;
      case "normal":
        t.hoverState = uT;
        break;
      case "blur":
        t.hoverState = kd;
        break;
      case "select":
        t.selected = true;
    }
  }
  function oJ(t, e, r, n) {
    for (var i = t.style, a = {}, o = 0; o < e.length; o++) {
      var s = e[o], l = i[s];
      a[s] = l ?? (n && n[s]);
    }
    for (var o = 0; o < t.animators.length; o++) {
      var u = t.animators[o];
      u.__fromStateTransition && u.__fromStateTransition.indexOf(r) < 0 && u.targetName === "style" && u.saveTo(a, e);
    }
    return a;
  }
  function sJ(t, e, r, n) {
    var i = r && et(r, "select") >= 0, a = false;
    if (t instanceof st) {
      var o = A4(t), s = i && o.selectFill || o.normalFill, l = i && o.selectStroke || o.normalStroke;
      if (xu(s) || xu(l)) {
        n = n || {};
        var u = n.style || {};
        u.fill === "inherit" ? (a = true, n = te({}, n), u = te({}, u), u.fill = s) : !xu(u.fill) && xu(s) ? (a = true, n = te({}, n), u = te({}, u), u.fill = fx(s)) : !xu(u.stroke) && xu(l) && (a || (n = te({}, n), u = te({}, u)), u.stroke = fx(l)), n.style = u;
      }
    }
    if (n && n.z2 == null) {
      a || (n = te({}, n));
      var c = t.z2EmphasisLift;
      n.z2 = t.z2 + (c ?? Vc);
    }
    return n;
  }
  function lJ(t, e, r) {
    if (r && r.z2 == null) {
      r = te({}, r);
      var n = t.z2SelectLift;
      r.z2 = t.z2 + (n ?? nJ);
    }
    return r;
  }
  function uJ(t, e, r) {
    var n = et(t.currentStates, e) >= 0, i = t.style.opacity, a = n ? null : oJ(t, [
      "opacity"
    ], e, {
      opacity: 1
    });
    r = r || {};
    var o = r.style || {};
    return o.opacity == null && (r = te({}, r), o = te({
      opacity: n ? i : a.opacity * 0.1
    }, o), r.style = o), r;
  }
  function I0(t, e) {
    var r = this.states[t];
    if (this.style) {
      if (t === "emphasis") return sJ(this, t, e, r);
      if (t === "blur") return uJ(this, t, r);
      if (t === "select") return lJ(this, t, r);
    }
    return r;
  }
  function Xl(t) {
    t.stateProxy = I0;
    var e = t.getTextContent(), r = t.getTextGuideLine();
    e && (e.stateProxy = I0), r && (r.stateProxy = I0);
  }
  function _D(t, e) {
    !L4(t, e) && !t.__highByOuter && xo(t, I4);
  }
  function bD(t, e) {
    !L4(t, e) && !t.__highByOuter && xo(t, M4);
  }
  function fo(t, e) {
    t.__highByOuter |= 1 << (e || 0), xo(t, I4);
  }
  function po(t, e) {
    !(t.__highByOuter &= ~(1 << (e || 0))) && xo(t, M4);
  }
  function E4(t) {
    xo(t, cT);
  }
  function hT(t) {
    xo(t, D4);
  }
  function k4(t) {
    xo(t, iJ);
  }
  function P4(t) {
    xo(t, aJ);
  }
  function L4(t, e) {
    return t.__highDownSilentOnTouch && e.zrByTouch;
  }
  function $4(t) {
    var e = t.getModel(), r = [], n = [];
    e.eachComponent(function(i, a) {
      var o = lT(a), s = i === "series", l = s ? t.getViewOfSeriesModel(a) : t.getViewOfComponentModel(a);
      !s && n.push(l), o.isBlured && (l.group.traverse(function(u) {
        D4(u);
      }), s && r.push(a)), o.isBlured = false;
    }), $(n, function(i) {
      i && i.toggleBlurSeries && i.toggleBlurSeries(r, false, e);
    });
  }
  function Dx(t, e, r, n) {
    var i = n.getModel();
    r = r || "coordinateSystem";
    function a(u, c) {
      for (var h = 0; h < c.length; h++) {
        var f = u.getItemGraphicEl(c[h]);
        f && hT(f);
      }
    }
    if (t != null && !(!e || e === "none")) {
      var o = i.getSeriesByIndex(t), s = o.coordinateSystem;
      s && s.master && (s = s.master);
      var l = [];
      i.eachSeries(function(u) {
        var c = o === u, h = u.coordinateSystem;
        h && h.master && (h = h.master);
        var f = h && s ? h === s : c;
        if (!(r === "series" && !c || r === "coordinateSystem" && !f || e === "series" && c)) {
          var d = n.getViewOfSeriesModel(u);
          if (d.group.traverse(function(g) {
            g.__highByOuter && c && e === "self" || cT(g);
          }), on(e)) a(u.getData(), e);
          else if (Le(e)) for (var p = gt(e), v = 0; v < p.length; v++) a(u.getData(p[v]), e[p[v]]);
          l.push(u), lT(u).isBlured = true;
        }
      }), i.eachComponent(function(u, c) {
        if (u !== "series") {
          var h = n.getViewOfComponentModel(c);
          h && h.toggleBlurSeries && h.toggleBlurSeries(l, true, i);
        }
      });
    }
  }
  function Ex(t, e, r) {
    if (!(t == null || e == null)) {
      var n = r.getModel().getComponent(t, e);
      if (n) {
        lT(n).isBlured = true;
        var i = r.getViewOfComponentModel(n);
        !i || !i.focusBlurEnabled || i.group.traverse(function(a) {
          cT(a);
        });
      }
    }
  }
  function cJ(t, e, r) {
    var n = t.seriesIndex, i = t.getData(e.dataType);
    if (i) {
      var a = Yl(i, e);
      a = (ae(a) ? a[0] : a) || 0;
      var o = i.getItemGraphicEl(a);
      if (!o) for (var s = i.count(), l = 0; !o && l < s; ) o = i.getItemGraphicEl(l++);
      if (o) {
        var u = Ge(o);
        Dx(n, u.focus, u.blurScope, r);
      } else {
        var c = t.get([
          "emphasis",
          "focus"
        ]), h = t.get([
          "emphasis",
          "blurScope"
        ]);
        c != null && Dx(n, c, h, r);
      }
    }
  }
  function fT(t, e, r, n) {
    var i = {
      focusSelf: false,
      dispatchers: null
    };
    if (t == null || t === "series" || e == null || r == null) return i;
    var a = n.getModel().getComponent(t, e);
    if (!a) return i;
    var o = n.getViewOfComponentModel(a);
    if (!o || !o.findHighDownDispatchers) return i;
    for (var s = o.findHighDownDispatchers(r), l, u = 0; u < s.length; u++) if (Ge(s[u]).focus === "self") {
      l = true;
      break;
    }
    return {
      focusSelf: l,
      dispatchers: s
    };
  }
  function hJ(t, e, r) {
    var n = Ge(t), i = fT(n.componentMainType, n.componentIndex, n.componentHighDownName, r), a = i.dispatchers, o = i.focusSelf;
    a ? (o && Ex(n.componentMainType, n.componentIndex, r), $(a, function(s) {
      return _D(s, e);
    })) : (Dx(n.seriesIndex, n.focus, n.blurScope, r), n.focus === "self" && Ex(n.componentMainType, n.componentIndex, r), _D(t, e));
  }
  function fJ(t, e, r) {
    $4(r);
    var n = Ge(t), i = fT(n.componentMainType, n.componentIndex, n.componentHighDownName, r).dispatchers;
    i ? $(i, function(a) {
      return bD(a, e);
    }) : bD(t, e);
  }
  function dJ(t, e, r) {
    if (Px(e)) {
      var n = e.dataType, i = t.getData(n), a = Yl(i, e);
      ae(a) || (a = [
        a
      ]), t[e.type === Tf ? "toggleSelect" : e.type === Sf ? "select" : "unselect"](a, n);
    }
  }
  function xD(t) {
    var e = t.getAllData();
    $(e, function(r) {
      var n = r.data, i = r.type;
      n.eachItemGraphicEl(function(a, o) {
        t.isSelected(o, i) ? k4(a) : P4(a);
      });
    });
  }
  function pJ(t) {
    var e = [];
    return t.eachSeries(function(r) {
      var n = r.getAllData();
      $(n, function(i) {
        i.data;
        var a = i.type, o = r.getSelectedDataIndices();
        if (o.length > 0) {
          var s = {
            dataIndex: o,
            seriesIndex: r.seriesIndex
          };
          a != null && (s.dataType = a), e.push(s);
        }
      });
    }), e;
  }
  function Nl(t, e, r) {
    Tl(t, true), xo(t, Xl), kx(t, e, r);
  }
  function vJ(t) {
    Tl(t, false);
  }
  function ir(t, e, r, n) {
    n ? vJ(t) : Nl(t, e, r);
  }
  function kx(t, e, r) {
    var n = Ge(t);
    e != null ? (n.focus = e, n.blurScope = r) : n.focus && (n.focus = null);
  }
  var wD = [
    "emphasis",
    "blur",
    "select"
  ], gJ = {
    itemStyle: "getItemStyle",
    lineStyle: "getLineStyle",
    areaStyle: "getAreaStyle"
  };
  function qr(t, e, r, n) {
    r = r || "itemStyle";
    for (var i = 0; i < wD.length; i++) {
      var a = wD[i], o = e.getModel([
        a,
        r
      ]), s = t.ensureState(a);
      s.style = n ? n(o) : o[gJ[r]]();
    }
  }
  function Tl(t, e) {
    var r = e === false, n = t;
    t.highDownSilentOnTouch && (n.__highDownSilentOnTouch = t.highDownSilentOnTouch), (!r || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !r);
  }
  function Xf(t) {
    return !!(t && t.__highDownDispatcher);
  }
  function mJ(t, e, r) {
    var n = Ge(t);
    n.componentMainType = e.mainType, n.componentIndex = e.componentIndex, n.componentHighDownName = r;
  }
  function yJ(t) {
    var e = mD[t];
    return e == null && gD <= 32 && (e = mD[t] = gD++), e;
  }
  function Px(t) {
    var e = t.type;
    return e === Sf || e === ig || e === Tf;
  }
  function SD(t) {
    var e = t.type;
    return e === Ol || e === ng;
  }
  function _J(t) {
    var e = A4(t);
    e.normalFill = t.style.fill, e.normalStroke = t.style.stroke;
    var r = t.states.select || {};
    e.selectFill = r.style && r.style.fill || null, e.selectStroke = r.style && r.style.stroke || null;
  }
  var wu = Ra.CMD, bJ = [
    [],
    [],
    []
  ], TD = Math.sqrt, xJ = Math.atan2;
  function R4(t, e) {
    if (e) {
      var r = t.data, n = t.len(), i, a, o, s, l, u, c = wu.M, h = wu.C, f = wu.L, d = wu.R, p = wu.A, v = wu.Q;
      for (o = 0, s = 0; o < n; ) {
        switch (i = r[o++], s = o, a = 0, i) {
          case c:
            a = 1;
            break;
          case f:
            a = 1;
            break;
          case h:
            a = 3;
            break;
          case v:
            a = 2;
            break;
          case p:
            var g = e[4], m = e[5], y = TD(e[0] * e[0] + e[1] * e[1]), _ = TD(e[2] * e[2] + e[3] * e[3]), b = xJ(-e[1] / _, e[0] / y);
            r[o] *= y, r[o++] += g, r[o] *= _, r[o++] += m, r[o++] *= y, r[o++] *= _, r[o++] += b, r[o++] += b, o += 2, s = o;
            break;
          case d:
            u[0] = r[o++], u[1] = r[o++], Ur(u, u, e), r[s++] = u[0], r[s++] = u[1], u[0] += r[o++], u[1] += r[o++], Ur(u, u, e), r[s++] = u[0], r[s++] = u[1];
        }
        for (l = 0; l < a; l++) {
          var w = bJ[l];
          w[0] = r[o++], w[1] = r[o++], Ur(w, w, e), r[s++] = w[0], r[s++] = w[1];
        }
      }
      t.increaseVersion();
    }
  }
  var M0 = Math.sqrt, Cp = Math.sin, Ap = Math.cos, fh = Math.PI;
  function CD(t) {
    return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
  }
  function Lx(t, e) {
    return (t[0] * e[0] + t[1] * e[1]) / (CD(t) * CD(e));
  }
  function AD(t, e) {
    return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(Lx(t, e));
  }
  function ID(t, e, r, n, i, a, o, s, l, u, c) {
    var h = l * (fh / 180), f = Ap(h) * (t - r) / 2 + Cp(h) * (e - n) / 2, d = -1 * Cp(h) * (t - r) / 2 + Ap(h) * (e - n) / 2, p = f * f / (o * o) + d * d / (s * s);
    p > 1 && (o *= M0(p), s *= M0(p));
    var v = (i === a ? -1 : 1) * M0((o * o * (s * s) - o * o * (d * d) - s * s * (f * f)) / (o * o * (d * d) + s * s * (f * f))) || 0, g = v * o * d / s, m = v * -s * f / o, y = (t + r) / 2 + Ap(h) * g - Cp(h) * m, _ = (e + n) / 2 + Cp(h) * g + Ap(h) * m, b = AD([
      1,
      0
    ], [
      (f - g) / o,
      (d - m) / s
    ]), w = [
      (f - g) / o,
      (d - m) / s
    ], x = [
      (-1 * f - g) / o,
      (-1 * d - m) / s
    ], T = AD(w, x);
    if (Lx(w, x) <= -1 && (T = fh), Lx(w, x) >= 1 && (T = 0), T < 0) {
      var A = Math.round(T / fh * 1e6) / 1e6;
      T = fh * 2 + A % 2 * fh;
    }
    c.addData(u, y, _, o, s, b, T, h, a);
  }
  var wJ = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, SJ = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function TJ(t) {
    var e = new Ra();
    if (!t) return e;
    var r = 0, n = 0, i = r, a = n, o, s = Ra.CMD, l = t.match(wJ);
    if (!l) return e;
    for (var u = 0; u < l.length; u++) {
      for (var c = l[u], h = c.charAt(0), f = void 0, d = c.match(SJ) || [], p = d.length, v = 0; v < p; v++) d[v] = parseFloat(d[v]);
      for (var g = 0; g < p; ) {
        var m = void 0, y = void 0, _ = void 0, b = void 0, w = void 0, x = void 0, T = void 0, A = r, I = n, M = void 0, k = void 0;
        switch (h) {
          case "l":
            r += d[g++], n += d[g++], f = s.L, e.addData(f, r, n);
            break;
          case "L":
            r = d[g++], n = d[g++], f = s.L, e.addData(f, r, n);
            break;
          case "m":
            r += d[g++], n += d[g++], f = s.M, e.addData(f, r, n), i = r, a = n, h = "l";
            break;
          case "M":
            r = d[g++], n = d[g++], f = s.M, e.addData(f, r, n), i = r, a = n, h = "L";
            break;
          case "h":
            r += d[g++], f = s.L, e.addData(f, r, n);
            break;
          case "H":
            r = d[g++], f = s.L, e.addData(f, r, n);
            break;
          case "v":
            n += d[g++], f = s.L, e.addData(f, r, n);
            break;
          case "V":
            n = d[g++], f = s.L, e.addData(f, r, n);
            break;
          case "C":
            f = s.C, e.addData(f, d[g++], d[g++], d[g++], d[g++], d[g++], d[g++]), r = d[g - 2], n = d[g - 1];
            break;
          case "c":
            f = s.C, e.addData(f, d[g++] + r, d[g++] + n, d[g++] + r, d[g++] + n, d[g++] + r, d[g++] + n), r += d[g - 2], n += d[g - 1];
            break;
          case "S":
            m = r, y = n, M = e.len(), k = e.data, o === s.C && (m += r - k[M - 4], y += n - k[M - 3]), f = s.C, A = d[g++], I = d[g++], r = d[g++], n = d[g++], e.addData(f, m, y, A, I, r, n);
            break;
          case "s":
            m = r, y = n, M = e.len(), k = e.data, o === s.C && (m += r - k[M - 4], y += n - k[M - 3]), f = s.C, A = r + d[g++], I = n + d[g++], r += d[g++], n += d[g++], e.addData(f, m, y, A, I, r, n);
            break;
          case "Q":
            A = d[g++], I = d[g++], r = d[g++], n = d[g++], f = s.Q, e.addData(f, A, I, r, n);
            break;
          case "q":
            A = d[g++] + r, I = d[g++] + n, r += d[g++], n += d[g++], f = s.Q, e.addData(f, A, I, r, n);
            break;
          case "T":
            m = r, y = n, M = e.len(), k = e.data, o === s.Q && (m += r - k[M - 4], y += n - k[M - 3]), r = d[g++], n = d[g++], f = s.Q, e.addData(f, m, y, r, n);
            break;
          case "t":
            m = r, y = n, M = e.len(), k = e.data, o === s.Q && (m += r - k[M - 4], y += n - k[M - 3]), r += d[g++], n += d[g++], f = s.Q, e.addData(f, m, y, r, n);
            break;
          case "A":
            _ = d[g++], b = d[g++], w = d[g++], x = d[g++], T = d[g++], A = r, I = n, r = d[g++], n = d[g++], f = s.A, ID(A, I, r, n, x, T, _, b, w, f, e);
            break;
          case "a":
            _ = d[g++], b = d[g++], w = d[g++], x = d[g++], T = d[g++], A = r, I = n, r += d[g++], n += d[g++], f = s.A, ID(A, I, r, n, x, T, _, b, w, f, e);
            break;
        }
      }
      (h === "z" || h === "Z") && (f = s.Z, e.addData(f), r = i, n = a), o = f;
    }
    return e.toStatic(), e;
  }
  var O4 = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.applyTransform = function(r) {
    }, e;
  }(st);
  function N4(t) {
    return t.setData != null;
  }
  function B4(t, e) {
    var r = TJ(t), n = te({}, e);
    return n.buildPath = function(i) {
      if (N4(i)) {
        i.setData(r.data);
        var a = i.getContext();
        a && i.rebuildPath(a, 1);
      } else {
        var a = i;
        r.rebuildPath(a, 1);
      }
    }, n.applyTransform = function(i) {
      R4(r, i), this.dirtyShape();
    }, n;
  }
  function z4(t, e) {
    return new O4(B4(t, e));
  }
  function CJ(t, e) {
    var r = B4(t, e), n = function(i) {
      K(a, i);
      function a(o) {
        var s = i.call(this, o) || this;
        return s.applyTransform = r.applyTransform, s.buildPath = r.buildPath, s;
      }
      return a;
    }(O4);
    return n;
  }
  function AJ(t, e) {
    for (var r = [], n = t.length, i = 0; i < n; i++) {
      var a = t[i];
      r.push(a.getUpdatedPathProxy(true));
    }
    var o = new st(e);
    return o.createPathProxy(), o.buildPath = function(s) {
      if (N4(s)) {
        s.appendPath(r);
        var l = s.getContext();
        l && s.rebuildPath(l, 1);
      }
    }, o;
  }
  function dT(t, e) {
    e = e || {};
    var r = new st();
    return t.shape && r.setShape(t.shape), r.setStyle(t.style), e.bakeTransform ? R4(r.path, t.getComputedTransform()) : e.toLocal ? r.setLocalTransform(t.getComputedTransform()) : r.copyTransform(t), r.buildPath = t.buildPath, r.applyTransform = r.applyTransform, r.z = t.z, r.z2 = t.z2, r.zlevel = t.zlevel, r;
  }
  var IJ = /* @__PURE__ */ function() {
    function t() {
      this.cx = 0, this.cy = 0, this.r = 0;
    }
    return t;
  }(), wo = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new IJ();
    }, e.prototype.buildPath = function(r, n) {
      r.moveTo(n.cx + n.r, n.cy), r.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
    }, e;
  }(st);
  wo.prototype.type = "circle";
  var MJ = /* @__PURE__ */ function() {
    function t() {
      this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
    }
    return t;
  }(), qm = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new MJ();
    }, e.prototype.buildPath = function(r, n) {
      var i = 0.5522848, a = n.cx, o = n.cy, s = n.rx, l = n.ry, u = s * i, c = l * i;
      r.moveTo(a - s, o), r.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l), r.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o), r.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l), r.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o), r.closePath();
    }, e;
  }(st);
  qm.prototype.type = "ellipse";
  var F4 = Math.PI, D0 = F4 * 2, Fs = Math.sin, Su = Math.cos, DJ = Math.acos, Kr = Math.atan2, MD = Math.abs, Cf = Math.sqrt, Jh = Math.max, ua = Math.min, Ri = 1e-4;
  function EJ(t, e, r, n, i, a, o, s) {
    var l = r - t, u = n - e, c = o - i, h = s - a, f = h * l - c * u;
    if (!(f * f < Ri)) return f = (c * (e - a) - h * (t - i)) / f, [
      t + f * l,
      e + f * u
    ];
  }
  function Ip(t, e, r, n, i, a, o) {
    var s = t - r, l = e - n, u = (o ? a : -a) / Cf(s * s + l * l), c = u * l, h = -u * s, f = t + c, d = e + h, p = r + c, v = n + h, g = (f + p) / 2, m = (d + v) / 2, y = p - f, _ = v - d, b = y * y + _ * _, w = i - a, x = f * v - p * d, T = (_ < 0 ? -1 : 1) * Cf(Jh(0, w * w * b - x * x)), A = (x * _ - y * T) / b, I = (-x * y - _ * T) / b, M = (x * _ + y * T) / b, k = (-x * y + _ * T) / b, B = A - g, L = I - m, z = M - g, F = k - m;
    return B * B + L * L > z * z + F * F && (A = M, I = k), {
      cx: A,
      cy: I,
      x0: -c,
      y0: -h,
      x1: A * (i / w - 1),
      y1: I * (i / w - 1)
    };
  }
  function kJ(t) {
    var e;
    if (ae(t)) {
      var r = t.length;
      if (!r) return t;
      r === 1 ? e = [
        t[0],
        t[0],
        0,
        0
      ] : r === 2 ? e = [
        t[0],
        t[0],
        t[1],
        t[1]
      ] : r === 3 ? e = t.concat(t[2]) : e = t;
    } else e = [
      t,
      t,
      t,
      t
    ];
    return e;
  }
  function PJ(t, e) {
    var r, n = Jh(e.r, 0), i = Jh(e.r0 || 0, 0), a = n > 0, o = i > 0;
    if (!(!a && !o)) {
      if (a || (n = i, i = 0), i > n) {
        var s = n;
        n = i, i = s;
      }
      var l = e.startAngle, u = e.endAngle;
      if (!(isNaN(l) || isNaN(u))) {
        var c = e.cx, h = e.cy, f = !!e.clockwise, d = MD(u - l), p = d > D0 && d % D0;
        if (p > Ri && (d = p), !(n > Ri)) t.moveTo(c, h);
        else if (d > D0 - Ri) t.moveTo(c + n * Su(l), h + n * Fs(l)), t.arc(c, h, n, l, u, !f), i > Ri && (t.moveTo(c + i * Su(u), h + i * Fs(u)), t.arc(c, h, i, u, l, f));
        else {
          var v = void 0, g = void 0, m = void 0, y = void 0, _ = void 0, b = void 0, w = void 0, x = void 0, T = void 0, A = void 0, I = void 0, M = void 0, k = void 0, B = void 0, L = void 0, z = void 0, F = n * Su(l), E = n * Fs(l), O = i * Su(u), N = i * Fs(u), V = d > Ri;
          if (V) {
            var H = e.cornerRadius;
            H && (r = kJ(H), v = r[0], g = r[1], m = r[2], y = r[3]);
            var G = MD(n - i) / 2;
            if (_ = ua(G, m), b = ua(G, y), w = ua(G, v), x = ua(G, g), I = T = Jh(_, b), M = A = Jh(w, x), (T > Ri || A > Ri) && (k = n * Su(u), B = n * Fs(u), L = i * Su(l), z = i * Fs(l), d < F4)) {
              var Y = EJ(F, E, L, z, k, B, O, N);
              if (Y) {
                var U = F - Y[0], Z = E - Y[1], ee = k - Y[0], we = B - Y[1], Te = 1 / Fs(DJ((U * ee + Z * we) / (Cf(U * U + Z * Z) * Cf(ee * ee + we * we))) / 2), le = Cf(Y[0] * Y[0] + Y[1] * Y[1]);
                I = ua(T, (n - le) / (Te + 1)), M = ua(A, (i - le) / (Te - 1));
              }
            }
          }
          if (!V) t.moveTo(c + F, h + E);
          else if (I > Ri) {
            var ue = ua(m, I), ye = ua(y, I), ve = Ip(L, z, F, E, n, ue, f), Se = Ip(k, B, O, N, n, ye, f);
            t.moveTo(c + ve.cx + ve.x0, h + ve.cy + ve.y0), I < T && ue === ye ? t.arc(c + ve.cx, h + ve.cy, I, Kr(ve.y0, ve.x0), Kr(Se.y0, Se.x0), !f) : (ue > 0 && t.arc(c + ve.cx, h + ve.cy, ue, Kr(ve.y0, ve.x0), Kr(ve.y1, ve.x1), !f), t.arc(c, h, n, Kr(ve.cy + ve.y1, ve.cx + ve.x1), Kr(Se.cy + Se.y1, Se.cx + Se.x1), !f), ye > 0 && t.arc(c + Se.cx, h + Se.cy, ye, Kr(Se.y1, Se.x1), Kr(Se.y0, Se.x0), !f));
          } else t.moveTo(c + F, h + E), t.arc(c, h, n, l, u, !f);
          if (!(i > Ri) || !V) t.lineTo(c + O, h + N);
          else if (M > Ri) {
            var ue = ua(v, M), ye = ua(g, M), ve = Ip(O, N, k, B, i, -ye, f), Se = Ip(F, E, L, z, i, -ue, f);
            t.lineTo(c + ve.cx + ve.x0, h + ve.cy + ve.y0), M < A && ue === ye ? t.arc(c + ve.cx, h + ve.cy, M, Kr(ve.y0, ve.x0), Kr(Se.y0, Se.x0), !f) : (ye > 0 && t.arc(c + ve.cx, h + ve.cy, ye, Kr(ve.y0, ve.x0), Kr(ve.y1, ve.x1), !f), t.arc(c, h, i, Kr(ve.cy + ve.y1, ve.cx + ve.x1), Kr(Se.cy + Se.y1, Se.cx + Se.x1), f), ue > 0 && t.arc(c + Se.cx, h + Se.cy, ue, Kr(Se.y1, Se.x1), Kr(Se.y0, Se.x0), !f));
          } else t.lineTo(c + O, h + N), t.arc(c, h, i, u, l, f);
        }
        t.closePath();
      }
    }
  }
  var LJ = /* @__PURE__ */ function() {
    function t() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true, this.cornerRadius = 0;
    }
    return t;
  }(), wn = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new LJ();
    }, e.prototype.buildPath = function(r, n) {
      PJ(r, n);
    }, e.prototype.isZeroArea = function() {
      return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
    }, e;
  }(st);
  wn.prototype.type = "sector";
  var $J = /* @__PURE__ */ function() {
    function t() {
      this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
    }
    return t;
  }(), Pd = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new $J();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.cx, a = n.cy, o = Math.PI * 2;
      r.moveTo(i + n.r, a), r.arc(i, a, n.r, 0, o, false), r.moveTo(i + n.r0, a), r.arc(i, a, n.r0, 0, o, true);
    }, e;
  }(st);
  Pd.prototype.type = "ring";
  function RJ(t, e, r, n) {
    var i = [], a = [], o = [], s = [], l, u, c, h;
    if (n) {
      c = [
        1 / 0,
        1 / 0
      ], h = [
        -1 / 0,
        -1 / 0
      ];
      for (var f = 0, d = t.length; f < d; f++) Ko(c, c, t[f]), Zo(h, h, t[f]);
      Ko(c, c, n[0]), Zo(h, h, n[1]);
    }
    for (var f = 0, d = t.length; f < d; f++) {
      var p = t[f];
      if (r) l = t[f ? f - 1 : d - 1], u = t[(f + 1) % d];
      else if (f === 0 || f === d - 1) {
        i.push(no(t[f]));
        continue;
      } else l = t[f - 1], u = t[f + 1];
      wl(a, u, l), jv(a, a, e);
      var v = nx(p, l), g = nx(p, u), m = v + g;
      m !== 0 && (v /= m, g /= m), jv(o, a, -v), jv(s, a, g);
      var y = TM([], p, o), _ = TM([], p, s);
      n && (Zo(y, y, c), Ko(y, y, h), Zo(_, _, c), Ko(_, _, h)), i.push(y), i.push(_);
    }
    return r && i.push(i.shift()), i;
  }
  function V4(t, e, r) {
    var n = e.smooth, i = e.points;
    if (i && i.length >= 2) {
      if (n) {
        var a = RJ(i, n, r, e.smoothConstraint);
        t.moveTo(i[0][0], i[0][1]);
        for (var o = i.length, s = 0; s < (r ? o : o - 1); s++) {
          var l = a[s * 2], u = a[s * 2 + 1], c = i[(s + 1) % o];
          t.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
        }
      } else {
        t.moveTo(i[0][0], i[0][1]);
        for (var s = 1, h = i.length; s < h; s++) t.lineTo(i[s][0], i[s][1]);
      }
      r && t.closePath();
    }
  }
  var OJ = /* @__PURE__ */ function() {
    function t() {
      this.points = null, this.smooth = 0, this.smoothConstraint = null;
    }
    return t;
  }(), Sn = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new OJ();
    }, e.prototype.buildPath = function(r, n) {
      V4(r, n, true);
    }, e;
  }(st);
  Sn.prototype.type = "polygon";
  var NJ = /* @__PURE__ */ function() {
    function t() {
      this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
    }
    return t;
  }(), Tn = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new NJ();
    }, e.prototype.buildPath = function(r, n) {
      V4(r, n, false);
    }, e;
  }(st);
  Tn.prototype.type = "polyline";
  var BJ = {}, zJ = /* @__PURE__ */ function() {
    function t() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return t;
  }(), Mr = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new zJ();
    }, e.prototype.buildPath = function(r, n) {
      var i, a, o, s;
      if (this.subPixelOptimize) {
        var l = w4(BJ, n, this.style);
        i = l.x1, a = l.y1, o = l.x2, s = l.y2;
      } else i = n.x1, a = n.y1, o = n.x2, s = n.y2;
      var u = n.percent;
      u !== 0 && (r.moveTo(i, a), u < 1 && (o = i * (1 - u) + o * u, s = a * (1 - u) + s * u), r.lineTo(o, s));
    }, e.prototype.pointAt = function(r) {
      var n = this.shape;
      return [
        n.x1 * (1 - r) + n.x2 * r,
        n.y1 * (1 - r) + n.y2 * r
      ];
    }, e;
  }(st);
  Mr.prototype.type = "line";
  var Cn = [], FJ = /* @__PURE__ */ function() {
    function t() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
    }
    return t;
  }();
  function DD(t, e, r) {
    var n = t.cpx2, i = t.cpy2;
    return n != null || i != null ? [
      (r ? OM : Ar)(t.x1, t.cpx1, t.cpx2, t.x2, e),
      (r ? OM : Ar)(t.y1, t.cpy1, t.cpy2, t.y2, e)
    ] : [
      (r ? lx : Br)(t.x1, t.cpx1, t.x2, e),
      (r ? lx : Br)(t.y1, t.cpy1, t.y2, e)
    ];
  }
  var Ld = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new FJ();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.x1, a = n.y1, o = n.x2, s = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, h = n.cpy2, f = n.percent;
      f !== 0 && (r.moveTo(i, a), c == null || h == null ? (f < 1 && (Gf(i, l, o, f, Cn), l = Cn[1], o = Cn[2], Gf(a, u, s, f, Cn), u = Cn[1], s = Cn[2]), r.quadraticCurveTo(l, u, o, s)) : (f < 1 && (fs(i, l, c, o, f, Cn), l = Cn[1], c = Cn[2], o = Cn[3], fs(a, u, h, s, f, Cn), u = Cn[1], h = Cn[2], s = Cn[3]), r.bezierCurveTo(l, u, c, h, o, s)));
    }, e.prototype.pointAt = function(r) {
      return DD(this.shape, r, false);
    }, e.prototype.tangentAt = function(r) {
      var n = DD(this.shape, r, true);
      return Bc(n, n);
    }, e;
  }(st);
  Ld.prototype.type = "bezier-curve";
  var VJ = /* @__PURE__ */ function() {
    function t() {
      this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
    }
    return t;
  }(), Xm = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new VJ();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.cx, a = n.cy, o = Math.max(n.r, 0), s = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(s), h = Math.sin(s);
      r.moveTo(c * o + i, h * o + a), r.arc(i, a, o, s, l, !u);
    }, e;
  }(st);
  Xm.prototype.type = "arc";
  var pT = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = "compound", r;
    }
    return e.prototype._updatePathDirty = function() {
      for (var r = this.shape.paths, n = this.shapeChanged(), i = 0; i < r.length; i++) n = n || r[i].shapeChanged();
      n && this.dirtyShape();
    }, e.prototype.beforeBrush = function() {
      this._updatePathDirty();
      for (var r = this.shape.paths || [], n = this.getGlobalScale(), i = 0; i < r.length; i++) r[i].path || r[i].createPathProxy(), r[i].path.setScale(n[0], n[1], r[i].segmentIgnoreThreshold);
    }, e.prototype.buildPath = function(r, n) {
      for (var i = n.paths || [], a = 0; a < i.length; a++) i[a].buildPath(r, i[a].shape, true);
    }, e.prototype.afterBrush = function() {
      for (var r = this.shape.paths || [], n = 0; n < r.length; n++) r[n].pathUpdated();
    }, e.prototype.getBoundingRect = function() {
      return this._updatePathDirty.call(this), st.prototype.getBoundingRect.call(this);
    }, e;
  }(st), G4 = function() {
    function t(e) {
      this.colorStops = e || [];
    }
    return t.prototype.addColorStop = function(e, r) {
      this.colorStops.push({
        offset: e,
        color: r
      });
    }, t;
  }(), $d = function(t) {
    K(e, t);
    function e(r, n, i, a, o, s) {
      var l = t.call(this, o) || this;
      return l.x = r ?? 0, l.y = n ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || false, l;
    }
    return e;
  }(G4), W4 = function(t) {
    K(e, t);
    function e(r, n, i, a, o) {
      var s = t.call(this, a) || this;
      return s.x = r ?? 0.5, s.y = n ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = o || false, s;
    }
    return e;
  }(G4), Vs = [
    0,
    0
  ], Gs = [
    0,
    0
  ], Mp = new Ke(), Dp = new Ke(), Pg = function() {
    function t(e, r) {
      this._corners = [], this._axes = [], this._origin = [
        0,
        0
      ];
      for (var n = 0; n < 4; n++) this._corners[n] = new Ke();
      for (var n = 0; n < 2; n++) this._axes[n] = new Ke();
      e && this.fromBoundingRect(e, r);
    }
    return t.prototype.fromBoundingRect = function(e, r) {
      var n = this._corners, i = this._axes, a = e.x, o = e.y, s = a + e.width, l = o + e.height;
      if (n[0].set(a, o), n[1].set(s, o), n[2].set(s, l), n[3].set(a, l), r) for (var u = 0; u < 4; u++) n[u].transform(r);
      Ke.sub(i[0], n[1], n[0]), Ke.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize();
      for (var u = 0; u < 2; u++) this._origin[u] = i[u].dot(n[0]);
    }, t.prototype.intersect = function(e, r) {
      var n = true, i = !r;
      return Mp.set(1 / 0, 1 / 0), Dp.set(0, 0), !this._intersectCheckOneSide(this, e, Mp, Dp, i, 1) && (n = false, i) || !this._intersectCheckOneSide(e, this, Mp, Dp, i, -1) && (n = false, i) || i || Ke.copy(r, n ? Mp : Dp), n;
    }, t.prototype._intersectCheckOneSide = function(e, r, n, i, a, o) {
      for (var s = true, l = 0; l < 2; l++) {
        var u = this._axes[l];
        if (this._getProjMinMaxOnAxis(l, e._corners, Vs), this._getProjMinMaxOnAxis(l, r._corners, Gs), Vs[1] < Gs[0] || Vs[0] > Gs[1]) {
          if (s = false, a) return s;
          var c = Math.abs(Gs[0] - Vs[1]), h = Math.abs(Vs[0] - Gs[1]);
          Math.min(c, h) > i.len() && (c < h ? Ke.scale(i, u, -c * o) : Ke.scale(i, u, h * o));
        } else if (n) {
          var c = Math.abs(Gs[0] - Vs[1]), h = Math.abs(Vs[0] - Gs[1]);
          Math.min(c, h) < n.len() && (c < h ? Ke.scale(n, u, c * o) : Ke.scale(n, u, -h * o));
        }
      }
      return s;
    }, t.prototype._getProjMinMaxOnAxis = function(e, r, n) {
      for (var i = this._axes[e], a = this._origin, o = r[0].dot(i) + a[e], s = o, l = o, u = 1; u < r.length; u++) {
        var c = r[u].dot(i) + a[e];
        s = Math.min(c, s), l = Math.max(c, l);
      }
      n[0] = s, n[1] = l;
    }, t;
  }(), GJ = [], WJ = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.notClear = true, r.incremental = true, r._displayables = [], r._temporaryDisplayables = [], r._cursor = 0, r;
    }
    return e.prototype.traverse = function(r, n) {
      r.call(n, this);
    }, e.prototype.useStyle = function() {
      this.style = {};
    }, e.prototype.getCursor = function() {
      return this._cursor;
    }, e.prototype.innerAfterBrush = function() {
      this._cursor = this._displayables.length;
    }, e.prototype.clearDisplaybles = function() {
      this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = false;
    }, e.prototype.clearTemporalDisplayables = function() {
      this._temporaryDisplayables = [];
    }, e.prototype.addDisplayable = function(r, n) {
      n ? this._temporaryDisplayables.push(r) : this._displayables.push(r), this.markRedraw();
    }, e.prototype.addDisplayables = function(r, n) {
      n = n || false;
      for (var i = 0; i < r.length; i++) this.addDisplayable(r[i], n);
    }, e.prototype.getDisplayables = function() {
      return this._displayables;
    }, e.prototype.getTemporalDisplayables = function() {
      return this._temporaryDisplayables;
    }, e.prototype.eachPendingDisplayable = function(r) {
      for (var n = this._cursor; n < this._displayables.length; n++) r && r(this._displayables[n]);
      for (var n = 0; n < this._temporaryDisplayables.length; n++) r && r(this._temporaryDisplayables[n]);
    }, e.prototype.update = function() {
      this.updateTransform();
      for (var r = this._cursor; r < this._displayables.length; r++) {
        var n = this._displayables[r];
        n.parent = this, n.update(), n.parent = null;
      }
      for (var r = 0; r < this._temporaryDisplayables.length; r++) {
        var n = this._temporaryDisplayables[r];
        n.parent = this, n.update(), n.parent = null;
      }
    }, e.prototype.getBoundingRect = function() {
      if (!this._rect) {
        for (var r = new Ze(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
          var i = this._displayables[n], a = i.getBoundingRect().clone();
          i.needLocalTransform() && a.applyTransform(i.getLocalTransform(GJ)), r.union(a);
        }
        this._rect = r;
      }
      return this._rect;
    }, e.prototype.contain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), a = this.getBoundingRect();
      if (a.contain(i[0], i[1])) for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(r, n)) return true;
      }
      return false;
    }, e;
  }(bi), H4 = _t();
  function Gc(t, e, r, n, i) {
    var a;
    if (e && e.ecModel) {
      var o = e.ecModel.getUpdatePayload();
      a = o && o.animation;
    }
    var s = e && e.isAnimationEnabled(), l = t === "update";
    if (s) {
      var u = void 0, c = void 0, h = void 0;
      n ? (u = We(n.duration, 200), c = We(n.easing, "cubicOut"), h = 0) : (u = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), De(h) && (h = h(r, i)), De(u) && (u = u(r));
      var f = {
        duration: u || 0,
        delay: h,
        easing: c
      };
      return f;
    } else return null;
  }
  function vT(t, e, r, n, i, a, o) {
    var s = false, l;
    De(i) ? (o = a, a = i, i = null) : Le(i) && (a = i.cb, o = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
    var u = t === "leave";
    u || e.stopAnimation("leave");
    var c = Gc(t, n, i, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(e, i) : null);
    if (c && c.duration > 0) {
      var h = c.duration, f = c.delay, d = c.easing, p = {
        duration: h,
        delay: f || 0,
        easing: d,
        done: a,
        force: !!a || !!o,
        setToFinal: !u,
        scope: t,
        during: o
      };
      s ? e.animateFrom(r, p) : e.animateTo(r, p);
    } else e.stopAnimation(), !s && e.attr(r), o && o(1), a && a();
  }
  function wt(t, e, r, n, i, a) {
    vT("update", t, e, r, n, i, a);
  }
  function er(t, e, r, n, i, a) {
    vT("enter", t, e, r, n, i, a);
  }
  function hc(t) {
    if (!t.__zr) return true;
    for (var e = 0; e < t.animators.length; e++) {
      var r = t.animators[e];
      if (r.scope === "leave") return true;
    }
    return false;
  }
  function ds(t, e, r, n, i, a) {
    hc(t) || vT("leave", t, e, r, n, i, a);
  }
  function ED(t, e, r, n) {
    t.removeTextContent(), t.removeTextGuideLine(), ds(t, {
      style: {
        opacity: 0
      }
    }, e, r, n);
  }
  function jf(t, e, r) {
    function n() {
      t.parent && t.parent.remove(t);
    }
    t.isGroup ? t.traverse(function(i) {
      i.isGroup || ED(i, e, r, n);
    }) : ED(t, e, r, n);
  }
  function Ki(t) {
    H4(t).oldStyle = t.style;
  }
  function HJ(t) {
    return H4(t).oldStyle;
  }
  var Lg = Math.max, $g = Math.min, $x = {};
  function UJ(t) {
    return st.extend(t);
  }
  var YJ = CJ;
  function qJ(t, e) {
    return YJ(t, e);
  }
  function Qi(t, e) {
    $x[t] = e;
  }
  function gT(t) {
    if ($x.hasOwnProperty(t)) return $x[t];
  }
  function jm(t, e, r, n) {
    var i = z4(t, e);
    return r && (n === "center" && (r = Y4(r, i.getBoundingRect())), q4(i, r)), i;
  }
  function U4(t, e, r) {
    var n = new Gr({
      style: {
        image: t,
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      onload: function(i) {
        if (r === "center") {
          var a = {
            width: i.width,
            height: i.height
          };
          n.setStyle(Y4(e, a));
        }
      }
    });
    return n;
  }
  function Y4(t, e) {
    var r = e.width / e.height, n = t.height * r, i;
    n <= t.width ? i = t.height : (n = t.width, i = n / r);
    var a = t.x + t.width / 2, o = t.y + t.height / 2;
    return {
      x: a - n / 2,
      y: o - i / 2,
      width: n,
      height: i
    };
  }
  var vi = AJ;
  function q4(t, e) {
    if (t.applyTransform) {
      var r = t.getBoundingRect(), n = r.calculateTransform(e);
      t.applyTransform(n);
    }
  }
  function yc(t, e) {
    return w4(t, t, {
      lineWidth: e
    }), t;
  }
  function XJ(t) {
    return S4(t.shape, t.shape, t.style), t;
  }
  var ag = Sl;
  function Bl(t, e) {
    for (var r = Nm([]); t && t !== e; ) io(r, t.getLocalTransform(), r), t = t.parent;
    return r;
  }
  function Yi(t, e, r) {
    return e && !on(e) && (e = Qa.getLocalTransform(e)), r && (e = zc([], e)), Ur([], t, e);
  }
  function Km(t, e, r) {
    var n = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), i = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), a = [
      t === "left" ? -n : t === "right" ? n : 0,
      t === "top" ? -i : t === "bottom" ? i : 0
    ];
    return a = Yi(a, e, r), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
  }
  function kD(t) {
    return !t.isGroup;
  }
  function jJ(t) {
    return t.shape != null;
  }
  function Rd(t, e, r) {
    if (!t || !e) return;
    function n(o) {
      var s = {};
      return o.traverse(function(l) {
        kD(l) && l.anid && (s[l.anid] = l);
      }), s;
    }
    function i(o) {
      var s = {
        x: o.x,
        y: o.y,
        rotation: o.rotation
      };
      return jJ(o) && (s.shape = te({}, o.shape)), s;
    }
    var a = n(t);
    e.traverse(function(o) {
      if (kD(o) && o.anid) {
        var s = a[o.anid];
        if (s) {
          var l = i(o);
          o.attr(i(s)), wt(o, l, r, Ge(o).dataIndex);
        }
      }
    });
  }
  function X4(t, e) {
    return oe(t, function(r) {
      var n = r[0];
      n = Lg(n, e.x), n = $g(n, e.x + e.width);
      var i = r[1];
      return i = Lg(i, e.y), i = $g(i, e.y + e.height), [
        n,
        i
      ];
    });
  }
  function KJ(t, e) {
    var r = Lg(t.x, e.x), n = $g(t.x + t.width, e.x + e.width), i = Lg(t.y, e.y), a = $g(t.y + t.height, e.y + e.height);
    if (n >= r && a >= i) return {
      x: r,
      y: i,
      width: n - r,
      height: a - i
    };
  }
  function Od(t, e, r) {
    var n = te({
      rectHover: true
    }, e), i = n.style = {
      strokeNoScale: true
    };
    if (r = r || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }, t) return t.indexOf("image://") === 0 ? (i.image = t.slice(8), Ee(i, r), new Gr(n)) : jm(t.replace("path://", ""), n, r, "center");
  }
  function ef(t, e, r, n, i) {
    for (var a = 0, o = i[i.length - 1]; a < i.length; a++) {
      var s = i[a];
      if (j4(t, e, r, n, s[0], s[1], o[0], o[1])) return true;
      o = s;
    }
  }
  function j4(t, e, r, n, i, a, o, s) {
    var l = r - t, u = n - e, c = o - i, h = s - a, f = E0(c, h, l, u);
    if (ZJ(f)) return false;
    var d = t - i, p = e - a, v = E0(d, p, l, u) / f;
    if (v < 0 || v > 1) return false;
    var g = E0(d, p, c, h) / f;
    return !(g < 0 || g > 1);
  }
  function E0(t, e, r, n) {
    return t * n - r * e;
  }
  function ZJ(t) {
    return t <= 1e-6 && t >= -1e-6;
  }
  function iu(t) {
    var e = t.itemTooltipOption, r = t.componentModel, n = t.itemName, i = me(e) ? {
      formatter: e
    } : e, a = r.mainType, o = r.componentIndex, s = {
      componentType: a,
      name: n,
      $vars: [
        "name"
      ]
    };
    s[a + "Index"] = o;
    var l = t.formatterParamsExtra;
    l && $(gt(l), function(c) {
      xe(s, c) || (s[c] = l[c], s.$vars.push(c));
    });
    var u = Ge(t.el);
    u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
      name: n,
      option: Ee({
        content: n,
        encodeHTMLContent: true,
        formatterParams: s
      }, i)
    };
  }
  function PD(t, e) {
    var r;
    t.isGroup && (r = e(t)), r || t.traverse(e);
  }
  function bs(t, e) {
    if (t) if (ae(t)) for (var r = 0; r < t.length; r++) PD(t[r], e);
    else PD(t, e);
  }
  Qi("circle", wo);
  Qi("ellipse", qm);
  Qi("sector", wn);
  Qi("ring", Pd);
  Qi("polygon", Sn);
  Qi("polyline", Tn);
  Qi("rect", yt);
  Qi("line", Mr);
  Qi("bezierCurve", Ld);
  Qi("arc", Xm);
  const au = Object.freeze(Object.defineProperty({
    __proto__: null,
    Arc: Xm,
    BezierCurve: Ld,
    BoundingRect: Ze,
    Circle: wo,
    CompoundPath: pT,
    Ellipse: qm,
    Group: Be,
    Image: Gr,
    IncrementalDisplayable: WJ,
    Line: Mr,
    LinearGradient: $d,
    OrientedBoundingRect: Pg,
    Path: st,
    Point: Ke,
    Polygon: Sn,
    Polyline: Tn,
    RadialGradient: W4,
    Rect: yt,
    Ring: Pd,
    Sector: wn,
    Text: bt,
    applyTransform: Yi,
    clipPointsByRect: X4,
    clipRectByRect: KJ,
    createIcon: Od,
    extendPath: qJ,
    extendShape: UJ,
    getShapeClass: gT,
    getTransform: Bl,
    groupTransition: Rd,
    initProps: er,
    isElementRemoved: hc,
    lineLineIntersect: j4,
    linePolygonIntersect: ef,
    makeImage: U4,
    makePath: jm,
    mergePath: vi,
    registerShape: Qi,
    removeElement: ds,
    removeElementWithFadeOut: jf,
    resizePath: q4,
    setTooltipConfig: iu,
    subPixelOptimize: ag,
    subPixelOptimizeLine: yc,
    subPixelOptimizeRect: XJ,
    transformDirection: Km,
    traverseElements: bs,
    updateProps: wt
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var Zm = {};
  function K4(t, e) {
    for (var r = 0; r < xn.length; r++) {
      var n = xn[r], i = e[n], a = t.ensureState(n);
      a.style = a.style || {}, a.style.text = i;
    }
    var o = t.currentStates.slice();
    t.clearStates(true), t.setStyle({
      text: e.normal
    }), t.useStates(o, true);
  }
  function Rx(t, e, r) {
    var n = t.labelFetcher, i = t.labelDataIndex, a = t.labelDimIndex, o = e.normal, s;
    n && (s = n.getFormattedLabel(i, "normal", null, a, o && o.get("formatter"), r != null ? {
      interpolatedValue: r
    } : null)), s == null && (s = De(t.defaultText) ? t.defaultText(i, t, r) : t.defaultText);
    for (var l = {
      normal: s
    }, u = 0; u < xn.length; u++) {
      var c = xn[u], h = e[c];
      l[c] = We(n ? n.getFormattedLabel(i, c, null, a, h && h.get("formatter")) : null, s);
    }
    return l;
  }
  function Xr(t, e, r, n) {
    r = r || Zm;
    for (var i = t instanceof bt, a = false, o = 0; o < qf.length; o++) {
      var s = e[qf[o]];
      if (s && s.getShallow("show")) {
        a = true;
        break;
      }
    }
    var l = i ? t : t.getTextContent();
    if (a) {
      i || (l || (l = new bt(), t.setTextContent(l)), t.stateProxy && (l.stateProxy = t.stateProxy));
      var u = Rx(r, e), c = e.normal, h = !!c.getShallow("show"), f = Yt(c, n && n.normal, r, false, !i);
      f.text = u.normal, i || t.setTextConfig(Rg(c, r, false));
      for (var o = 0; o < xn.length; o++) {
        var d = xn[o], s = e[d];
        if (s) {
          var p = l.ensureState(d), v = !!We(s.getShallow("show"), h);
          if (v !== h && (p.ignore = !v), p.style = Yt(s, n && n[d], r, true, !i), p.style.text = u[d], !i) {
            var g = t.ensureState(d);
            g.textConfig = Rg(s, r, true);
          }
        }
      }
      l.silent = !!c.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !h, l.useStyle(f), l.dirty(), r.enableTextSetter && (Wc(l).setLabelText = function(m) {
        var y = Rx(r, e, m);
        K4(l, y);
      });
    } else l && (l.ignore = true);
    t.dirty();
  }
  function Lr(t, e) {
    e = e || "label";
    for (var r = {
      normal: t.getModel(e)
    }, n = 0; n < xn.length; n++) {
      var i = xn[n];
      r[i] = t.getModel([
        i,
        e
      ]);
    }
    return r;
  }
  function Yt(t, e, r, n, i) {
    var a = {};
    return QJ(a, t, r, n, i), e && te(a, e), a;
  }
  function Rg(t, e, r) {
    e = e || {};
    var n = {}, i, a = t.getShallow("rotate"), o = We(t.getShallow("distance"), r ? null : 5), s = t.getShallow("offset");
    return i = t.getShallow("position") || (r ? null : "inside"), i === "outside" && (i = e.defaultOutsidePosition || "top"), i != null && (n.position = i), s != null && (n.offset = s), a != null && (a *= Math.PI / 180, n.rotation = a), o != null && (n.distance = o), n.outsideFill = t.get("color") === "inherit" ? e.inheritColor || null : "auto", n;
  }
  function QJ(t, e, r, n, i) {
    r = r || Zm;
    var a = e.ecModel, o = a && a.option.textStyle, s = JJ(e), l;
    if (s) {
      l = {};
      for (var u in s) if (s.hasOwnProperty(u)) {
        var c = e.getModel([
          "rich",
          u
        ]);
        OD(l[u] = {}, c, o, r, n, i, false, true);
      }
    }
    l && (t.rich = l);
    var h = e.get("overflow");
    h && (t.overflow = h);
    var f = e.get("minMargin");
    f != null && (t.margin = f), OD(t, e, o, r, n, i, true, false);
  }
  function JJ(t) {
    for (var e; t && t !== t.ecModel; ) {
      var r = (t.option || Zm).rich;
      if (r) {
        e = e || {};
        for (var n = gt(r), i = 0; i < n.length; i++) {
          var a = n[i];
          e[a] = 1;
        }
      }
      t = t.parentModel;
    }
    return e;
  }
  var LD = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "textShadowColor",
    "textShadowBlur",
    "textShadowOffsetX",
    "textShadowOffsetY"
  ], $D = [
    "align",
    "lineHeight",
    "width",
    "height",
    "tag",
    "verticalAlign",
    "ellipsis"
  ], RD = [
    "padding",
    "borderWidth",
    "borderRadius",
    "borderDashOffset",
    "backgroundColor",
    "borderColor",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY"
  ];
  function OD(t, e, r, n, i, a, o, s) {
    r = !i && r || Zm;
    var l = n && n.inheritColor, u = e.getShallow("color"), c = e.getShallow("textBorderColor"), h = We(e.getShallow("opacity"), r.opacity);
    (u === "inherit" || u === "auto") && (l ? u = l : u = null), (c === "inherit" || c === "auto") && (l ? c = l : c = null), a || (u = u || r.color, c = c || r.textBorderColor), u != null && (t.fill = u), c != null && (t.stroke = c);
    var f = We(e.getShallow("textBorderWidth"), r.textBorderWidth);
    f != null && (t.lineWidth = f);
    var d = We(e.getShallow("textBorderType"), r.textBorderType);
    d != null && (t.lineDash = d);
    var p = We(e.getShallow("textBorderDashOffset"), r.textBorderDashOffset);
    p != null && (t.lineDashOffset = p), !i && h == null && !s && (h = n && n.defaultOpacity), h != null && (t.opacity = h), !i && !a && t.fill == null && n.inheritColor && (t.fill = n.inheritColor);
    for (var v = 0; v < LD.length; v++) {
      var g = LD[v], m = We(e.getShallow(g), r[g]);
      m != null && (t[g] = m);
    }
    for (var v = 0; v < $D.length; v++) {
      var g = $D[v], m = e.getShallow(g);
      m != null && (t[g] = m);
    }
    if (t.verticalAlign == null) {
      var y = e.getShallow("baseline");
      y != null && (t.verticalAlign = y);
    }
    if (!o || !n.disableBox) {
      for (var v = 0; v < RD.length; v++) {
        var g = RD[v], m = e.getShallow(g);
        m != null && (t[g] = m);
      }
      var _ = e.getShallow("borderType");
      _ != null && (t.borderDash = _), (t.backgroundColor === "auto" || t.backgroundColor === "inherit") && l && (t.backgroundColor = l), (t.borderColor === "auto" || t.borderColor === "inherit") && l && (t.borderColor = l);
    }
  }
  function mT(t, e) {
    var r = e && e.getModel("textStyle");
    return Vi([
      t.fontStyle || r && r.getShallow("fontStyle") || "",
      t.fontWeight || r && r.getShallow("fontWeight") || "",
      (t.fontSize || r && r.getShallow("fontSize") || 12) + "px",
      t.fontFamily || r && r.getShallow("fontFamily") || "sans-serif"
    ].join(" "));
  }
  var Wc = _t();
  function Z4(t, e, r, n) {
    if (t) {
      var i = Wc(t);
      i.prevValue = i.value, i.value = r;
      var a = e.normal;
      i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = n, i.statesModels = e);
    }
  }
  function Q4(t, e, r, n, i) {
    var a = Wc(t);
    if (!a.valueAnimation || a.prevValue === a.value) return;
    var o = a.defaultInterpolatedText, s = We(a.interpolatedValue, a.prevValue), l = a.value;
    function u(c) {
      var h = p4(r, a.precision, s, l, c);
      a.interpolatedValue = c === 1 ? null : h;
      var f = Rx({
        labelDataIndex: e,
        labelFetcher: i,
        defaultText: o ? o(h) : h + ""
      }, a.statesModels, h);
      K4(t, f);
    }
    t.percent = 0, (a.prevValue == null ? er : wt)(t, {
      percent: 1
    }, n, e, null, u);
  }
  var eee = [
    "textStyle",
    "color"
  ], k0 = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "padding",
    "lineHeight",
    "rich",
    "width",
    "height",
    "overflow"
  ], P0 = new bt(), tee = function() {
    function t() {
    }
    return t.prototype.getTextColor = function(e) {
      var r = this.ecModel;
      return this.getShallow("color") || (!e && r ? r.get(eee) : null);
    }, t.prototype.getFont = function() {
      return mT({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, t.prototype.getTextRect = function(e) {
      for (var r = {
        text: e,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < k0.length; n++) r[k0[n]] = this.getShallow(k0[n]);
      return P0.useStyle(r), P0.update(), P0.getBoundingRect();
    }, t;
  }(), J4 = [
    [
      "lineWidth",
      "width"
    ],
    [
      "stroke",
      "color"
    ],
    [
      "opacity"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ],
    [
      "lineDash",
      "type"
    ],
    [
      "lineDashOffset",
      "dashOffset"
    ],
    [
      "lineCap",
      "cap"
    ],
    [
      "lineJoin",
      "join"
    ],
    [
      "miterLimit"
    ]
  ], ree = ql(J4), nee = function() {
    function t() {
    }
    return t.prototype.getLineStyle = function(e) {
      return ree(this, e);
    }, t;
  }(), eV = [
    [
      "fill",
      "color"
    ],
    [
      "stroke",
      "borderColor"
    ],
    [
      "lineWidth",
      "borderWidth"
    ],
    [
      "opacity"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ],
    [
      "lineDash",
      "borderType"
    ],
    [
      "lineDashOffset",
      "borderDashOffset"
    ],
    [
      "lineCap",
      "borderCap"
    ],
    [
      "lineJoin",
      "borderJoin"
    ],
    [
      "miterLimit",
      "borderMiterLimit"
    ]
  ], iee = ql(eV), aee = function() {
    function t() {
    }
    return t.prototype.getItemStyle = function(e, r) {
      return iee(this, e, r);
    }, t;
  }(), kt = function() {
    function t(e, r, n) {
      this.parentModel = r, this.ecModel = n, this.option = e;
    }
    return t.prototype.init = function(e, r, n) {
    }, t.prototype.mergeOption = function(e, r) {
      je(this.option, e, true);
    }, t.prototype.get = function(e, r) {
      return e == null ? this.option : this._doGet(this.parsePath(e), !r && this.parentModel);
    }, t.prototype.getShallow = function(e, r) {
      var n = this.option, i = n == null ? n : n[e];
      if (i == null && !r) {
        var a = this.parentModel;
        a && (i = a.getShallow(e));
      }
      return i;
    }, t.prototype.getModel = function(e, r) {
      var n = e != null, i = n ? this.parsePath(e) : null, a = n ? this._doGet(i) : this.option;
      return r = r || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new t(a, r, this.ecModel);
    }, t.prototype.isEmpty = function() {
      return this.option == null;
    }, t.prototype.restoreData = function() {
    }, t.prototype.clone = function() {
      var e = this.constructor;
      return new e(Oe(this.option));
    }, t.prototype.parsePath = function(e) {
      return typeof e == "string" ? e.split(".") : e;
    }, t.prototype.resolveParentPath = function(e) {
      return e;
    }, t.prototype.isAnimationEnabled = function() {
      if (!ct.node && this.option) {
        if (this.option.animation != null) return !!this.option.animation;
        if (this.parentModel) return this.parentModel.isAnimationEnabled();
      }
    }, t.prototype._doGet = function(e, r) {
      var n = this.option;
      if (!e) return n;
      for (var i = 0; i < e.length && !(e[i] && (n = n && typeof n == "object" ? n[e[i]] : null, n == null)); i++) ;
      return n == null && r && (n = r._doGet(this.resolveParentPath(e), r.parentModel)), n;
    }, t;
  }();
  aT(kt);
  pQ(kt);
  yr(kt, nee);
  yr(kt, aee);
  yr(kt, _Q);
  yr(kt, tee);
  var oee = Math.round(Math.random() * 10);
  function Hc(t) {
    return [
      t || "",
      oee++
    ].join("_");
  }
  function see(t) {
    var e = {};
    t.registerSubTypeDefaulter = function(r, n) {
      var i = Sa(r);
      e[i.main] = n;
    }, t.determineSubType = function(r, n) {
      var i = n.type;
      if (!i) {
        var a = Sa(r).main;
        t.hasSubTypes(r) && e[a] && (i = e[a](n));
      }
      return i;
    };
  }
  function lee(t, e) {
    t.topologicalTravel = function(a, o, s, l) {
      if (!a.length) return;
      var u = r(o), c = u.graph, h = u.noEntryList, f = {};
      for ($(a, function(y) {
        f[y] = true;
      }); h.length; ) {
        var d = h.pop(), p = c[d], v = !!f[d];
        v && (s.call(l, d, p.originalDeps.slice()), delete f[d]), $(p.successor, v ? m : g);
      }
      $(f, function() {
        var y = "";
        throw new Error(y);
      });
      function g(y) {
        c[y].entryCount--, c[y].entryCount === 0 && h.push(y);
      }
      function m(y) {
        f[y] = true, g(y);
      }
    };
    function r(a) {
      var o = {}, s = [];
      return $(a, function(l) {
        var u = n(o, l), c = u.originalDeps = e(l), h = i(c, a);
        u.entryCount = h.length, u.entryCount === 0 && s.push(l), $(h, function(f) {
          et(u.predecessor, f) < 0 && u.predecessor.push(f);
          var d = n(o, f);
          et(d.successor, f) < 0 && d.successor.push(l);
        });
      }), {
        graph: o,
        noEntryList: s
      };
    }
    function n(a, o) {
      return a[o] || (a[o] = {
        predecessor: [],
        successor: []
      }), a[o];
    }
    function i(a, o) {
      var s = [];
      return $(a, function(l) {
        et(o, l) >= 0 && s.push(l);
      }), s;
    }
  }
  function xs(t, e) {
    return je(je({}, t, true), e, true);
  }
  const uee = {
    time: {
      month: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ],
      monthAbbr: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      dayOfWeek: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ],
      dayOfWeekAbbr: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ]
    },
    legend: {
      selector: {
        all: "All",
        inverse: "Inv"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "Box Select",
          polygon: "Lasso Select",
          lineX: "Horizontally Select",
          lineY: "Vertically Select",
          keep: "Keep Selections",
          clear: "Clear Selections"
        }
      },
      dataView: {
        title: "Data View",
        lang: [
          "Data View",
          "Close",
          "Refresh"
        ]
      },
      dataZoom: {
        title: {
          zoom: "Zoom",
          back: "Zoom Reset"
        }
      },
      magicType: {
        title: {
          line: "Switch to Line Chart",
          bar: "Switch to Bar Chart",
          stack: "Stack",
          tiled: "Tile"
        }
      },
      restore: {
        title: "Restore"
      },
      saveAsImage: {
        title: "Save as Image",
        lang: [
          "Right Click to Save Image"
        ]
      }
    },
    series: {
      typeNames: {
        pie: "Pie chart",
        bar: "Bar chart",
        line: "Line chart",
        scatter: "Scatter plot",
        effectScatter: "Ripple scatter plot",
        radar: "Radar chart",
        tree: "Tree",
        treemap: "Treemap",
        boxplot: "Boxplot",
        candlestick: "Candlestick",
        k: "K line chart",
        heatmap: "Heat map",
        map: "Map",
        parallel: "Parallel coordinate map",
        lines: "Line graph",
        graph: "Relationship graph",
        sankey: "Sankey diagram",
        funnel: "Funnel chart",
        gauge: "Gauge",
        pictorialBar: "Pictorial bar",
        themeRiver: "Theme River Map",
        sunburst: "Sunburst",
        custom: "Custom chart",
        chart: "Chart"
      }
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: "This is a chart"
      },
      series: {
        single: {
          prefix: "",
          withName: " with type {seriesType} named {seriesName}.",
          withoutName: " with type {seriesType}."
        },
        multiple: {
          prefix: ". It consists of {seriesCount} series count.",
          withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
          withoutName: " The {seriesId} series is a {seriesType}.",
          separator: {
            middle: "",
            end: ""
          }
        }
      },
      data: {
        allData: "The data is as follows: ",
        partialData: "The first {displayCnt} items are: ",
        withName: "the data for {name} is {value}",
        withoutName: "{value}",
        separator: {
          middle: ", ",
          end: ". "
        }
      }
    }
  }, cee = {
    time: {
      month: [
        "\u4E00\u6708",
        "\u4E8C\u6708",
        "\u4E09\u6708",
        "\u56DB\u6708",
        "\u4E94\u6708",
        "\u516D\u6708",
        "\u4E03\u6708",
        "\u516B\u6708",
        "\u4E5D\u6708",
        "\u5341\u6708",
        "\u5341\u4E00\u6708",
        "\u5341\u4E8C\u6708"
      ],
      monthAbbr: [
        "1\u6708",
        "2\u6708",
        "3\u6708",
        "4\u6708",
        "5\u6708",
        "6\u6708",
        "7\u6708",
        "8\u6708",
        "9\u6708",
        "10\u6708",
        "11\u6708",
        "12\u6708"
      ],
      dayOfWeek: [
        "\u661F\u671F\u65E5",
        "\u661F\u671F\u4E00",
        "\u661F\u671F\u4E8C",
        "\u661F\u671F\u4E09",
        "\u661F\u671F\u56DB",
        "\u661F\u671F\u4E94",
        "\u661F\u671F\u516D"
      ],
      dayOfWeekAbbr: [
        "\u65E5",
        "\u4E00",
        "\u4E8C",
        "\u4E09",
        "\u56DB",
        "\u4E94",
        "\u516D"
      ]
    },
    legend: {
      selector: {
        all: "\u5168\u9009",
        inverse: "\u53CD\u9009"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "\u77E9\u5F62\u9009\u62E9",
          polygon: "\u5708\u9009",
          lineX: "\u6A2A\u5411\u9009\u62E9",
          lineY: "\u7EB5\u5411\u9009\u62E9",
          keep: "\u4FDD\u6301\u9009\u62E9",
          clear: "\u6E05\u9664\u9009\u62E9"
        }
      },
      dataView: {
        title: "\u6570\u636E\u89C6\u56FE",
        lang: [
          "\u6570\u636E\u89C6\u56FE",
          "\u5173\u95ED",
          "\u5237\u65B0"
        ]
      },
      dataZoom: {
        title: {
          zoom: "\u533A\u57DF\u7F29\u653E",
          back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
        }
      },
      magicType: {
        title: {
          line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
          bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
          stack: "\u5207\u6362\u4E3A\u5806\u53E0",
          tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
        }
      },
      restore: {
        title: "\u8FD8\u539F"
      },
      saveAsImage: {
        title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
        lang: [
          "\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"
        ]
      }
    },
    series: {
      typeNames: {
        pie: "\u997C\u56FE",
        bar: "\u67F1\u72B6\u56FE",
        line: "\u6298\u7EBF\u56FE",
        scatter: "\u6563\u70B9\u56FE",
        effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
        radar: "\u96F7\u8FBE\u56FE",
        tree: "\u6811\u56FE",
        treemap: "\u77E9\u5F62\u6811\u56FE",
        boxplot: "\u7BB1\u578B\u56FE",
        candlestick: "K\u7EBF\u56FE",
        k: "K\u7EBF\u56FE",
        heatmap: "\u70ED\u529B\u56FE",
        map: "\u5730\u56FE",
        parallel: "\u5E73\u884C\u5750\u6807\u56FE",
        lines: "\u7EBF\u56FE",
        graph: "\u5173\u7CFB\u56FE",
        sankey: "\u6851\u57FA\u56FE",
        funnel: "\u6F0F\u6597\u56FE",
        gauge: "\u4EEA\u8868\u76D8\u56FE",
        pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
        themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
        sunburst: "\u65ED\u65E5\u56FE",
        custom: "\u81EA\u5B9A\u4E49\u56FE\u8868",
        chart: "\u56FE\u8868"
      }
    },
    aria: {
      general: {
        withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
        withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
      },
      series: {
        single: {
          prefix: "",
          withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
          withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
        },
        multiple: {
          prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
          withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
          withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
          separator: {
            middle: "\uFF1B",
            end: "\u3002"
          }
        }
      },
      data: {
        allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
        partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
        withName: "{name}\u7684\u6570\u636E\u662F{value}",
        withoutName: "{value}",
        separator: {
          middle: "\uFF0C",
          end: ""
        }
      }
    }
  };
  var Og = "ZH", yT = "EN", fc = yT, og = {}, _T = {}, tV = ct.domSupported ? function() {
    var t = (document.documentElement.lang || navigator.language || navigator.browserLanguage || fc).toUpperCase();
    return t.indexOf(Og) > -1 ? Og : fc;
  }() : fc;
  function rV(t, e) {
    t = t.toUpperCase(), _T[t] = new kt(e), og[t] = e;
  }
  function hee(t) {
    if (me(t)) {
      var e = og[t.toUpperCase()] || {};
      return t === Og || t === yT ? Oe(e) : je(Oe(e), Oe(og[fc]), false);
    } else return je(Oe(t), Oe(og[fc]), false);
  }
  function Ox(t) {
    return _T[t];
  }
  function fee() {
    return _T[fc];
  }
  rV(yT, uee);
  rV(Og, cee);
  var bT = 1e3, xT = bT * 60, Af = xT * 60, gi = Af * 24, ND = gi * 365, tf = {
    year: "{yyyy}",
    month: "{MMM}",
    day: "{d}",
    hour: "{HH}:{mm}",
    minute: "{HH}:{mm}",
    second: "{HH}:{mm}:{ss}",
    millisecond: "{HH}:{mm}:{ss} {SSS}",
    none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
  }, Ep = "{yyyy}-{MM}-{dd}", BD = {
    year: "{yyyy}",
    month: "{yyyy}-{MM}",
    day: Ep,
    hour: Ep + " " + tf.hour,
    minute: Ep + " " + tf.minute,
    second: Ep + " " + tf.second,
    millisecond: tf.none
  }, L0 = [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ], nV = [
    "year",
    "half-year",
    "quarter",
    "month",
    "week",
    "half-week",
    "day",
    "half-day",
    "quarter-day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  function ko(t, e) {
    return t += "", "0000".substr(0, e - t.length) + t;
  }
  function dc(t) {
    switch (t) {
      case "half-year":
      case "quarter":
        return "month";
      case "week":
      case "half-week":
        return "day";
      case "half-day":
      case "quarter-day":
        return "hour";
      default:
        return t;
    }
  }
  function dee(t) {
    return t === dc(t);
  }
  function pee(t) {
    switch (t) {
      case "year":
      case "month":
        return "day";
      case "millisecond":
        return "millisecond";
      default:
        return "second";
    }
  }
  function Qm(t, e, r, n) {
    var i = $a(t), a = i[wT(r)](), o = i[pc(r)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = i[Jm(r)](), u = i["get" + (r ? "UTC" : "") + "Day"](), c = i[Kf(r)](), h = (c - 1) % 12 + 1, f = i[ey(r)](), d = i[ty(r)](), p = i[ry(r)](), v = c >= 12 ? "pm" : "am", g = v.toUpperCase(), m = n instanceof kt ? n : Ox(n || tV) || fee(), y = m.getModel("time"), _ = y.get("month"), b = y.get("monthAbbr"), w = y.get("dayOfWeek"), x = y.get("dayOfWeekAbbr");
    return (e || "").replace(/{a}/g, v + "").replace(/{A}/g, g + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, ko(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, _[o - 1]).replace(/{MMM}/g, b[o - 1]).replace(/{MM}/g, ko(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, ko(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, w[u]).replace(/{ee}/g, x[u]).replace(/{e}/g, u + "").replace(/{HH}/g, ko(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, ko(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, ko(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, ko(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, ko(p, 3)).replace(/{S}/g, p + "");
  }
  function vee(t, e, r, n, i) {
    var a = null;
    if (me(r)) a = r;
    else if (De(r)) a = r(t.value, e, {
      level: t.level
    });
    else {
      var o = te({}, tf);
      if (t.level > 0) for (var s = 0; s < L0.length; ++s) o[L0[s]] = "{primary|" + o[L0[s]] + "}";
      var l = r ? r.inherit === false ? r : Ee(r, o) : o, u = iV(t.value, i);
      if (l[u]) a = l[u];
      else if (l.inherit) {
        for (var c = nV.indexOf(u), s = c - 1; s >= 0; --s) if (l[u]) {
          a = l[u];
          break;
        }
        a = a || o.none;
      }
      if (ae(a)) {
        var h = t.level == null ? 0 : t.level >= 0 ? t.level : a.length + t.level;
        h = Math.min(h, a.length - 1), a = a[h];
      }
    }
    return Qm(new Date(t.value), a, i, n);
  }
  function iV(t, e) {
    var r = $a(t), n = r[pc(e)]() + 1, i = r[Jm(e)](), a = r[Kf(e)](), o = r[ey(e)](), s = r[ty(e)](), l = r[ry(e)](), u = l === 0, c = u && s === 0, h = c && o === 0, f = h && a === 0, d = f && i === 1, p = d && n === 1;
    return p ? "year" : d ? "month" : f ? "day" : h ? "hour" : c ? "minute" : u ? "second" : "millisecond";
  }
  function zD(t, e, r) {
    var n = xt(t) ? $a(t) : t;
    switch (e = e || iV(t, r), e) {
      case "year":
        return n[wT(r)]();
      case "half-year":
        return n[pc(r)]() >= 6 ? 1 : 0;
      case "quarter":
        return Math.floor((n[pc(r)]() + 1) / 4);
      case "month":
        return n[pc(r)]();
      case "day":
        return n[Jm(r)]();
      case "half-day":
        return n[Kf(r)]() / 24;
      case "hour":
        return n[Kf(r)]();
      case "minute":
        return n[ey(r)]();
      case "second":
        return n[ty(r)]();
      case "millisecond":
        return n[ry(r)]();
    }
  }
  function wT(t) {
    return t ? "getUTCFullYear" : "getFullYear";
  }
  function pc(t) {
    return t ? "getUTCMonth" : "getMonth";
  }
  function Jm(t) {
    return t ? "getUTCDate" : "getDate";
  }
  function Kf(t) {
    return t ? "getUTCHours" : "getHours";
  }
  function ey(t) {
    return t ? "getUTCMinutes" : "getMinutes";
  }
  function ty(t) {
    return t ? "getUTCSeconds" : "getSeconds";
  }
  function ry(t) {
    return t ? "getUTCMilliseconds" : "getMilliseconds";
  }
  function gee(t) {
    return t ? "setUTCFullYear" : "setFullYear";
  }
  function aV(t) {
    return t ? "setUTCMonth" : "setMonth";
  }
  function oV(t) {
    return t ? "setUTCDate" : "setDate";
  }
  function sV(t) {
    return t ? "setUTCHours" : "setHours";
  }
  function lV(t) {
    return t ? "setUTCMinutes" : "setMinutes";
  }
  function uV(t) {
    return t ? "setUTCSeconds" : "setSeconds";
  }
  function cV(t) {
    return t ? "setUTCMilliseconds" : "setMilliseconds";
  }
  function hV(t) {
    if (!o4(t)) return me(t) ? t : "-";
    var e = (t + "").split(".");
    return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "");
  }
  function fV(t, e) {
    return t = (t || "").toLowerCase().replace(/-(.)/g, function(r, n) {
      return n.toUpperCase();
    }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t;
  }
  var Uc = jS;
  function Nx(t, e, r) {
    var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
    function i(c) {
      return c && Vi(c) ? c : "-";
    }
    function a(c) {
      return !!(c != null && !isNaN(c) && isFinite(c));
    }
    var o = e === "time", s = t instanceof Date;
    if (o || s) {
      var l = o ? $a(t) : t;
      if (isNaN(+l)) {
        if (s) return "-";
      } else return Qm(l, n, r);
    }
    if (e === "ordinal") return ex(t) ? i(t) : xt(t) && a(t) ? t + "" : "-";
    var u = ho(t);
    return a(u) ? hV(u) : ex(t) ? i(t) : typeof t == "boolean" ? t + "" : "-";
  }
  var FD = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g"
  ], $0 = function(t, e) {
    return "{" + t + (e ?? "") + "}";
  };
  function dV(t, e, r) {
    ae(e) || (e = [
      e
    ]);
    var n = e.length;
    if (!n) return "";
    for (var i = e[0].$vars || [], a = 0; a < i.length; a++) {
      var o = FD[a];
      t = t.replace($0(o), $0(o, 0));
    }
    for (var s = 0; s < n; s++) for (var l = 0; l < i.length; l++) {
      var u = e[s][i[l]];
      t = t.replace($0(FD[l], s), r ? vn(u) : u);
    }
    return t;
  }
  function mee(t, e, r) {
    return $(e, function(n, i) {
      t = t.replace("{" + i + "}", n);
    }), t;
  }
  function yee(t, e) {
    var r = me(t) ? {
      color: t,
      extraCssText: e
    } : t || {}, n = r.color, i = r.type;
    e = r.extraCssText;
    var a = r.renderMode || "html";
    if (!n) return "";
    if (a === "html") return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + vn(n) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + vn(n) + ";" + (e || "") + '"></span>';
    var o = r.markerId || "markerX";
    return {
      renderMode: a,
      content: "{" + o + "|}  ",
      style: i === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: n
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: n
      }
    };
  }
  function jl(t, e) {
    return e = e || "transparent", me(t) ? t : Le(t) && t.colorStops && (t.colorStops[0] || {}).color || e;
  }
  function Ng(t, e) {
    if (e === "_blank" || e === "blank") {
      var r = window.open();
      r.opener = null, r.location.href = t;
    } else window.open(t, e);
  }
  var sg = $, pV = [
    "left",
    "right",
    "top",
    "bottom",
    "width",
    "height"
  ], Cl = [
    [
      "width",
      "left",
      "right"
    ],
    [
      "height",
      "top",
      "bottom"
    ]
  ];
  function ST(t, e, r, n, i) {
    var a = 0, o = 0;
    n == null && (n = 1 / 0), i == null && (i = 1 / 0);
    var s = 0;
    e.eachChild(function(l, u) {
      var c = l.getBoundingRect(), h = e.childAt(u + 1), f = h && h.getBoundingRect(), d, p;
      if (t === "horizontal") {
        var v = c.width + (f ? -f.x + c.x : 0);
        d = a + v, d > n || l.newline ? (a = 0, d = v, o += s + r, s = c.height) : s = Math.max(s, c.height);
      } else {
        var g = c.height + (f ? -f.y + c.y : 0);
        p = o + g, p > i || l.newline ? (a += s + r, o = 0, p = g, s = c.width) : s = Math.max(s, c.width);
      }
      l.newline || (l.x = a, l.y = o, l.markRedraw(), t === "horizontal" ? a = d + r : o = p + r);
    });
  }
  var zl = ST;
  Ye(ST, "vertical");
  Ye(ST, "horizontal");
  function _ee(t, e, r) {
    var n = e.width, i = e.height, a = pe(t.left, n), o = pe(t.top, i), s = pe(t.right, n), l = pe(t.bottom, i);
    return (isNaN(a) || isNaN(parseFloat(t.left))) && (a = 0), (isNaN(s) || isNaN(parseFloat(t.right))) && (s = n), (isNaN(o) || isNaN(parseFloat(t.top))) && (o = 0), (isNaN(l) || isNaN(parseFloat(t.bottom))) && (l = i), r = Uc(r || 0), {
      width: Math.max(s - a - r[1] - r[3], 0),
      height: Math.max(l - o - r[0] - r[2], 0)
    };
  }
  function Tr(t, e, r) {
    r = Uc(r || 0);
    var n = e.width, i = e.height, a = pe(t.left, n), o = pe(t.top, i), s = pe(t.right, n), l = pe(t.bottom, i), u = pe(t.width, n), c = pe(t.height, i), h = r[2] + r[0], f = r[1] + r[3], d = t.aspect;
    switch (isNaN(u) && (u = n - s - f - a), isNaN(c) && (c = i - l - h - o), d != null && (isNaN(u) && isNaN(c) && (d > n / i ? u = n * 0.8 : c = i * 0.8), isNaN(u) && (u = d * c), isNaN(c) && (c = u / d)), isNaN(a) && (a = n - s - u - f), isNaN(o) && (o = i - l - c - h), t.left || t.right) {
      case "center":
        a = n / 2 - u / 2 - r[3];
        break;
      case "right":
        a = n - u - f;
        break;
    }
    switch (t.top || t.bottom) {
      case "middle":
      case "center":
        o = i / 2 - c / 2 - r[0];
        break;
      case "bottom":
        o = i - c - h;
        break;
    }
    a = a || 0, o = o || 0, isNaN(u) && (u = n - f - a - (s || 0)), isNaN(c) && (c = i - h - o - (l || 0));
    var p = new Ze(a + r[3], o + r[0], u, c);
    return p.margin = r, p;
  }
  function ny(t, e, r, n, i, a) {
    var o = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
    if (a = a || t, a.x = t.x, a.y = t.y, !o && !s) return false;
    var u;
    if (l === "raw") u = t.type === "group" ? new Ze(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect();
    else if (u = t.getBoundingRect(), t.needLocalTransform()) {
      var c = t.getLocalTransform();
      u = u.clone(), u.applyTransform(c);
    }
    var h = Tr(Ee({
      width: u.width,
      height: u.height
    }, e), r, n), f = o ? h.x - u.x : 0, d = s ? h.y - u.y : 0;
    return l === "raw" ? (a.x = f, a.y = d) : (a.x += f, a.y += d), a === t && t.markRedraw(), true;
  }
  function bee(t, e) {
    return t[Cl[e][0]] != null || t[Cl[e][1]] != null && t[Cl[e][2]] != null;
  }
  function Zf(t) {
    var e = t.layoutMode || t.constructor.layoutMode;
    return Le(e) ? e : e ? {
      type: e
    } : null;
  }
  function ps(t, e, r) {
    var n = r && r.ignoreSize;
    !ae(n) && (n = [
      n,
      n
    ]);
    var i = o(Cl[0], 0), a = o(Cl[1], 1);
    u(Cl[0], t, i), u(Cl[1], t, a);
    function o(c, h) {
      var f = {}, d = 0, p = {}, v = 0, g = 2;
      if (sg(c, function(_) {
        p[_] = t[_];
      }), sg(c, function(_) {
        s(e, _) && (f[_] = p[_] = e[_]), l(f, _) && d++, l(p, _) && v++;
      }), n[h]) return l(e, c[1]) ? p[c[2]] = null : l(e, c[2]) && (p[c[1]] = null), p;
      if (v === g || !d) return p;
      if (d >= g) return f;
      for (var m = 0; m < c.length; m++) {
        var y = c[m];
        if (!s(f, y) && s(t, y)) {
          f[y] = t[y];
          break;
        }
      }
      return f;
    }
    function s(c, h) {
      return c.hasOwnProperty(h);
    }
    function l(c, h) {
      return c[h] != null && c[h] !== "auto";
    }
    function u(c, h, f) {
      sg(c, function(d) {
        h[d] = f[d];
      });
    }
  }
  function Yc(t) {
    return vV({}, t);
  }
  function vV(t, e) {
    return e && t && sg(pV, function(r) {
      e.hasOwnProperty(r) && (t[r] = e[r]);
    }), t;
  }
  var xee = _t(), vt = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this, r, n, i) || this;
      return a.uid = Hc("ec_cpt_model"), a;
    }
    return e.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i);
    }, e.prototype.mergeDefaultAndTheme = function(r, n) {
      var i = Zf(this), a = i ? Yc(r) : {}, o = n.getTheme();
      je(r, o.get(this.mainType)), je(r, this.getDefaultOption()), i && ps(r, a, i);
    }, e.prototype.mergeOption = function(r, n) {
      je(this.option, r, true);
      var i = Zf(this);
      i && ps(this.option, r, i);
    }, e.prototype.optionUpdated = function(r, n) {
    }, e.prototype.getDefaultOption = function() {
      var r = this.constructor;
      if (!hQ(r)) return r.defaultOption;
      var n = xee(this);
      if (!n.defaultOption) {
        for (var i = [], a = r; a; ) {
          var o = a.prototype.defaultOption;
          o && i.push(o), a = a.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--) s = je(s, i[l], true);
        n.defaultOption = s;
      }
      return n.defaultOption;
    }, e.prototype.getReferringComponents = function(r, n) {
      var i = r + "Index", a = r + "Id";
      return Ed(this.ecModel, r, {
        index: this.get(i, true),
        id: this.get(a, true)
      }, n);
    }, e.prototype.getBoxLayoutParams = function() {
      var r = this;
      return {
        left: r.get("left"),
        top: r.get("top"),
        right: r.get("right"),
        bottom: r.get("bottom"),
        width: r.get("width"),
        height: r.get("height")
      };
    }, e.prototype.getZLevelKey = function() {
      return "";
    }, e.prototype.setZLevel = function(r) {
      this.option.zlevel = r;
    }, e.protoInitialize = function() {
      var r = e.prototype;
      r.type = "component", r.id = "", r.name = "", r.mainType = "", r.subType = "", r.componentIndex = 0;
    }(), e;
  }(kt);
  g4(vt, kt);
  Vm(vt);
  see(vt);
  lee(vt, wee);
  function wee(t) {
    var e = [];
    return $(vt.getClassesByMainType(t), function(r) {
      e = e.concat(r.dependencies || r.prototype.dependencies || []);
    }), e = oe(e, function(r) {
      return Sa(r).main;
    }), t !== "dataset" && et(e, "dataset") <= 0 && e.unshift("dataset"), e;
  }
  var gV = "";
  typeof navigator < "u" && (gV = navigator.platform || "");
  var Tu = "rgba(0, 0, 0, 0.2)";
  const See = {
    darkMode: "auto",
    colorBy: "series",
    color: [
      "#5470c6",
      "#91cc75",
      "#fac858",
      "#ee6666",
      "#73c0de",
      "#3ba272",
      "#fc8452",
      "#9a60b4",
      "#ea7ccc"
    ],
    gradientColor: [
      "#f6efa6",
      "#d88273",
      "#bf444c"
    ],
    aria: {
      decal: {
        decals: [
          {
            color: Tu,
            dashArrayX: [
              1,
              0
            ],
            dashArrayY: [
              2,
              5
            ],
            symbolSize: 1,
            rotation: Math.PI / 6
          },
          {
            color: Tu,
            symbol: "circle",
            dashArrayX: [
              [
                8,
                8
              ],
              [
                0,
                8,
                8,
                0
              ]
            ],
            dashArrayY: [
              6,
              0
            ],
            symbolSize: 0.8
          },
          {
            color: Tu,
            dashArrayX: [
              1,
              0
            ],
            dashArrayY: [
              4,
              3
            ],
            rotation: -Math.PI / 4
          },
          {
            color: Tu,
            dashArrayX: [
              [
                6,
                6
              ],
              [
                0,
                6,
                6,
                0
              ]
            ],
            dashArrayY: [
              6,
              0
            ]
          },
          {
            color: Tu,
            dashArrayX: [
              [
                1,
                0
              ],
              [
                1,
                6
              ]
            ],
            dashArrayY: [
              1,
              0,
              6,
              0
            ],
            rotation: Math.PI / 4
          },
          {
            color: Tu,
            symbol: "triangle",
            dashArrayX: [
              [
                9,
                9
              ],
              [
                0,
                9,
                9,
                0
              ]
            ],
            dashArrayY: [
              7,
              2
            ],
            symbolSize: 0.75
          }
        ]
      }
    },
    textStyle: {
      fontFamily: gV.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
      fontSize: 12,
      fontStyle: "normal",
      fontWeight: "normal"
    },
    blendMode: null,
    stateAnimation: {
      duration: 300,
      easing: "cubicOut"
    },
    animation: "auto",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut",
    animationEasingUpdate: "cubicInOut",
    animationThreshold: 2e3,
    progressiveThreshold: 3e3,
    progressive: 400,
    hoverLayerThreshold: 3e3,
    useUTC: false
  };
  var mV = Ce([
    "tooltip",
    "label",
    "itemName",
    "itemId",
    "itemGroupId",
    "itemChildGroupId",
    "seriesName"
  ]), wi = "original", sn = "arrayRows", Si = "objectRows", Na = "keyedColumns", os = "typedArray", yV = "unknown", Ma = "column", qc = "row", Hr = {
    Must: 1,
    Might: 2,
    Not: 3
  }, _V = _t();
  function Tee(t) {
    _V(t).datasetMap = Ce();
  }
  function bV(t, e, r) {
    var n = {}, i = CT(e);
    if (!i || !t) return n;
    var a = [], o = [], s = e.ecModel, l = _V(s).datasetMap, u = i.uid + "_" + r.seriesLayoutBy, c, h;
    t = t.slice(), $(t, function(v, g) {
      var m = Le(v) ? v : t[g] = {
        name: v
      };
      m.type === "ordinal" && c == null && (c = g, h = p(m)), n[m.name] = [];
    });
    var f = l.get(u) || l.set(u, {
      categoryWayDim: h,
      valueWayDim: 0
    });
    $(t, function(v, g) {
      var m = v.name, y = p(v);
      if (c == null) {
        var _ = f.valueWayDim;
        d(n[m], _, y), d(o, _, y), f.valueWayDim += y;
      } else if (c === g) d(n[m], 0, y), d(a, 0, y);
      else {
        var _ = f.categoryWayDim;
        d(n[m], _, y), d(o, _, y), f.categoryWayDim += y;
      }
    });
    function d(v, g, m) {
      for (var y = 0; y < m; y++) v.push(g + y);
    }
    function p(v) {
      var g = v.dimsDef;
      return g ? g.length : 1;
    }
    return a.length && (n.itemName = a), o.length && (n.seriesName = o), n;
  }
  function TT(t, e, r) {
    var n = {}, i = CT(t);
    if (!i) return n;
    var a = e.sourceFormat, o = e.dimensionsDefine, s;
    (a === Si || a === Na) && $(o, function(c, h) {
      (Le(c) ? c.name : c) === "name" && (s = h);
    });
    var l = function() {
      for (var c = {}, h = {}, f = [], d = 0, p = Math.min(5, r); d < p; d++) {
        var v = wV(e.data, a, e.seriesLayoutBy, o, e.startIndex, d);
        f.push(v);
        var g = v === Hr.Not;
        if (g && c.v == null && d !== s && (c.v = d), (c.n == null || c.n === c.v || !g && f[c.n] === Hr.Not) && (c.n = d), m(c) && f[c.n] !== Hr.Not) return c;
        g || (v === Hr.Might && h.v == null && d !== s && (h.v = d), (h.n == null || h.n === h.v) && (h.n = d));
      }
      function m(y) {
        return y.v != null && y.n != null;
      }
      return m(c) ? c : m(h) ? h : null;
    }();
    if (l) {
      n.value = [
        l.v
      ];
      var u = s ?? l.n;
      n.itemName = [
        u
      ], n.seriesName = [
        u
      ];
    }
    return n;
  }
  function CT(t) {
    var e = t.get("data", true);
    if (!e) return Ed(t.ecModel, "dataset", {
      index: t.get("datasetIndex", true),
      id: t.get("datasetId", true)
    }, gr).models[0];
  }
  function Cee(t) {
    return !t.get("transform", true) && !t.get("fromTransformResult", true) ? [] : Ed(t.ecModel, "dataset", {
      index: t.get("fromDatasetIndex", true),
      id: t.get("fromDatasetId", true)
    }, gr).models;
  }
  function xV(t, e) {
    return wV(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e);
  }
  function wV(t, e, r, n, i, a) {
    var o, s = 5;
    if ($n(t)) return Hr.Not;
    var l, u;
    if (n) {
      var c = n[a];
      Le(c) ? (l = c.name, u = c.type) : me(c) && (l = c);
    }
    if (u != null) return u === "ordinal" ? Hr.Must : Hr.Not;
    if (e === sn) {
      var h = t;
      if (r === qc) {
        for (var f = h[a], d = 0; d < (f || []).length && d < s; d++) if ((o = b(f[i + d])) != null) return o;
      } else for (var d = 0; d < h.length && d < s; d++) {
        var p = h[i + d];
        if (p && (o = b(p[a])) != null) return o;
      }
    } else if (e === Si) {
      var v = t;
      if (!l) return Hr.Not;
      for (var d = 0; d < v.length && d < s; d++) {
        var g = v[d];
        if (g && (o = b(g[l])) != null) return o;
      }
    } else if (e === Na) {
      var m = t;
      if (!l) return Hr.Not;
      var f = m[l];
      if (!f || $n(f)) return Hr.Not;
      for (var d = 0; d < f.length && d < s; d++) if ((o = b(f[d])) != null) return o;
    } else if (e === wi) for (var y = t, d = 0; d < y.length && d < s; d++) {
      var g = y[d], _ = Fc(g);
      if (!ae(_)) return Hr.Not;
      if ((o = b(_[a])) != null) return o;
    }
    function b(w) {
      var x = me(w);
      if (w != null && Number.isFinite(Number(w)) && w !== "") return x ? Hr.Might : Hr.Not;
      if (x && w !== "-") return Hr.Must;
    }
    return Hr.Not;
  }
  var Bx = Ce();
  function Aee(t, e) {
    bn(Bx.get(t) == null && e), Bx.set(t, e);
  }
  function Iee(t, e, r) {
    var n = Bx.get(e);
    if (!n) return r;
    var i = n(t);
    return i ? r.concat(i) : r;
  }
  var VD = _t(), Mee = _t(), AT = function() {
    function t() {
    }
    return t.prototype.getColorFromPalette = function(e, r, n) {
      var i = Ot(this.get("color", true)), a = this.get("colorLayer", true);
      return SV(this, VD, i, a, e, r, n);
    }, t.prototype.clearColorPalette = function() {
      Eee(this, VD);
    }, t;
  }();
  function zx(t, e, r, n) {
    var i = Ot(t.get([
      "aria",
      "decal",
      "decals"
    ]));
    return SV(t, Mee, i, null, e, r, n);
  }
  function Dee(t, e) {
    for (var r = t.length, n = 0; n < r; n++) if (t[n].length > e) return t[n];
    return t[r - 1];
  }
  function SV(t, e, r, n, i, a, o) {
    a = a || t;
    var s = e(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
    if (u.hasOwnProperty(i)) return u[i];
    var c = o == null || !n ? r : Dee(n, o);
    if (c = c || r, !(!c || !c.length)) {
      var h = c[l];
      return i && (u[i] = h), s.paletteIdx = (l + 1) % c.length, h;
    }
  }
  function Eee(t, e) {
    e(t).paletteIdx = 0, e(t).paletteNameMap = {};
  }
  var kp, dh, GD, WD = "\0_ec_inner", kee = 1, IT = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.init = function(r, n, i, a, o, s) {
      a = a || {}, this.option = null, this._theme = new kt(a), this._locale = new kt(o), this._optionManager = s;
    }, e.prototype.setOption = function(r, n, i) {
      var a = YD(n);
      this._optionManager.setOption(r, i, a), this._resetOption(null, a);
    }, e.prototype.resetOption = function(r, n) {
      return this._resetOption(r, YD(n));
    }, e.prototype._resetOption = function(r, n) {
      var i = false, a = this._optionManager;
      if (!r || r === "recreate") {
        var o = a.mountOption(r === "recreate");
        !this.option || r === "recreate" ? GD(this, o) : (this.restoreData(), this._mergeOption(o, n)), i = true;
      }
      if ((r === "timeline" || r === "media") && this.restoreData(), !r || r === "recreate" || r === "timeline") {
        var s = a.getTimelineOption(this);
        s && (i = true, this._mergeOption(s, n));
      }
      if (!r || r === "recreate" || r === "media") {
        var l = a.getMediaOption(this);
        l.length && $(l, function(u) {
          i = true, this._mergeOption(u, n);
        }, this);
      }
      return i;
    }, e.prototype.mergeOption = function(r) {
      this._mergeOption(r, null);
    }, e.prototype._mergeOption = function(r, n) {
      var i = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = Ce(), u = n && n.replaceMergeMainTypeMap;
      Tee(this), $(r, function(h, f) {
        h != null && (vt.hasClass(f) ? f && (s.push(f), l.set(f, true)) : i[f] = i[f] == null ? Oe(h) : je(i[f], h, true));
      }), u && u.each(function(h, f) {
        vt.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, true));
      }), vt.topologicalTravel(s, vt.getAllClassMainTypes(), c, this);
      function c(h) {
        var f = Iee(this, h, Ot(r[h])), d = a.get(h), p = d ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll", v = h4(d, f, p);
        rQ(v, h, vt), i[h] = null, a.set(h, null), o.set(h, 0);
        var g = [], m = [], y = 0, _;
        $(v, function(b, w) {
          var x = b.existing, T = b.newOption;
          if (!T) x && (x.mergeOption({}, this), x.optionUpdated({}, false));
          else {
            var A = h === "series", I = vt.getClass(h, b.keyInfo.subType, !A);
            if (!I) return;
            if (h === "tooltip") {
              if (_) return;
              _ = true;
            }
            if (x && x.constructor === I) x.name = b.keyInfo.name, x.mergeOption(T, this), x.optionUpdated(T, false);
            else {
              var M = te({
                componentIndex: w
              }, b.keyInfo);
              x = new I(T, this, this, M), te(x, M), b.brandNew && (x.__requireNewView = true), x.init(T, this, this), x.optionUpdated(null, true);
            }
          }
          x ? (g.push(x.option), m.push(x), y++) : (g.push(void 0), m.push(void 0));
        }, this), i[h] = g, a.set(h, m), o.set(h, y), h === "series" && kp(this);
      }
      this._seriesIndices || kp(this);
    }, e.prototype.getOption = function() {
      var r = Oe(this.option);
      return $(r, function(n, i) {
        if (vt.hasClass(i)) {
          for (var a = Ot(n), o = a.length, s = false, l = o - 1; l >= 0; l--) a[l] && !Yf(a[l]) ? s = true : (a[l] = null, !s && o--);
          a.length = o, r[i] = a;
        }
      }), delete r[WD], r;
    }, e.prototype.getTheme = function() {
      return this._theme;
    }, e.prototype.getLocaleModel = function() {
      return this._locale;
    }, e.prototype.setUpdatePayload = function(r) {
      this._payload = r;
    }, e.prototype.getUpdatePayload = function() {
      return this._payload;
    }, e.prototype.getComponent = function(r, n) {
      var i = this._componentsMap.get(r);
      if (i) {
        var a = i[n || 0];
        if (a) return a;
        if (n == null) {
          for (var o = 0; o < i.length; o++) if (i[o]) return i[o];
        }
      }
    }, e.prototype.queryComponents = function(r) {
      var n = r.mainType;
      if (!n) return [];
      var i = r.index, a = r.id, o = r.name, s = this._componentsMap.get(n);
      if (!s || !s.length) return [];
      var l;
      return i != null ? (l = [], $(Ot(i), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = HD("id", a, s) : o != null ? l = HD("name", o, s) : l = Dt(s, function(u) {
        return !!u;
      }), UD(l, r);
    }, e.prototype.findComponents = function(r) {
      var n = r.query, i = r.mainType, a = s(n), o = a ? this.queryComponents(a) : Dt(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(UD(o, r));
      function s(u) {
        var c = i + "Index", h = i + "Id", f = i + "Name";
        return u && (u[c] != null || u[h] != null || u[f] != null) ? {
          mainType: i,
          index: u[c],
          id: u[h],
          name: u[f]
        } : null;
      }
      function l(u) {
        return r.filter ? Dt(u, r.filter) : u;
      }
    }, e.prototype.eachComponent = function(r, n, i) {
      var a = this._componentsMap;
      if (De(r)) {
        var o = n, s = r;
        a.each(function(h, f) {
          for (var d = 0; h && d < h.length; d++) {
            var p = h[d];
            p && s.call(o, f, p, p.componentIndex);
          }
        });
      } else for (var l = me(r) ? a.get(r) : Le(r) ? this.findComponents(r) : null, u = 0; l && u < l.length; u++) {
        var c = l[u];
        c && n.call(i, c, c.componentIndex);
      }
    }, e.prototype.getSeriesByName = function(r) {
      var n = xr(r, null);
      return Dt(this._componentsMap.get("series"), function(i) {
        return !!i && n != null && i.name === n;
      });
    }, e.prototype.getSeriesByIndex = function(r) {
      return this._componentsMap.get("series")[r];
    }, e.prototype.getSeriesByType = function(r) {
      return Dt(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === r;
      });
    }, e.prototype.getSeries = function() {
      return Dt(this._componentsMap.get("series"), function(r) {
        return !!r;
      });
    }, e.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, e.prototype.eachSeries = function(r, n) {
      dh(this), $(this._seriesIndices, function(i) {
        var a = this._componentsMap.get("series")[i];
        r.call(n, a, i);
      }, this);
    }, e.prototype.eachRawSeries = function(r, n) {
      $(this._componentsMap.get("series"), function(i) {
        i && r.call(n, i, i.componentIndex);
      });
    }, e.prototype.eachSeriesByType = function(r, n, i) {
      dh(this), $(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === r && n.call(i, o, a);
      }, this);
    }, e.prototype.eachRawSeriesByType = function(r, n, i) {
      return $(this.getSeriesByType(r), n, i);
    }, e.prototype.isSeriesFiltered = function(r) {
      return dh(this), this._seriesIndicesMap.get(r.componentIndex) == null;
    }, e.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, e.prototype.filterSeries = function(r, n) {
      dh(this);
      var i = [];
      $(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        r.call(n, o, a) && i.push(a);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = Ce(i);
    }, e.prototype.restoreData = function(r) {
      kp(this);
      var n = this._componentsMap, i = [];
      n.each(function(a, o) {
        vt.hasClass(o) && i.push(o);
      }), vt.topologicalTravel(i, vt.getAllClassMainTypes(), function(a) {
        $(n.get(a), function(o) {
          o && (a !== "series" || !Pee(o, r)) && o.restoreData();
        });
      });
    }, e.internalField = function() {
      kp = function(r) {
        var n = r._seriesIndices = [];
        $(r._componentsMap.get("series"), function(i) {
          i && n.push(i.componentIndex);
        }), r._seriesIndicesMap = Ce(n);
      }, dh = function(r) {
      }, GD = function(r, n) {
        r.option = {}, r.option[WD] = kee, r._componentsMap = Ce({
          series: []
        }), r._componentsCount = Ce();
        var i = n.aria;
        Le(i) && i.enabled == null && (i.enabled = true), Lee(n, r._theme.option), je(n, See, false), r._mergeOption(n, null);
      };
    }(), e;
  }(kt);
  function Pee(t, e) {
    if (e) {
      var r = e.seriesIndex, n = e.seriesId, i = e.seriesName;
      return r != null && t.componentIndex !== r || n != null && t.id !== n || i != null && t.name !== i;
    }
  }
  function Lee(t, e) {
    var r = t.color && !t.colorLayer;
    $(e, function(n, i) {
      i === "colorLayer" && r || vt.hasClass(i) || (typeof n == "object" ? t[i] = t[i] ? je(t[i], n, false) : Oe(n) : t[i] == null && (t[i] = n));
    });
  }
  function HD(t, e, r) {
    if (ae(e)) {
      var n = Ce();
      return $(e, function(a) {
        if (a != null) {
          var o = xr(a, null);
          o != null && n.set(a, true);
        }
      }), Dt(r, function(a) {
        return a && n.get(a[t]);
      });
    } else {
      var i = xr(e, null);
      return Dt(r, function(a) {
        return a && i != null && a[t] === i;
      });
    }
  }
  function UD(t, e) {
    return e.hasOwnProperty("subType") ? Dt(t, function(r) {
      return r && r.subType === e.subType;
    }) : t;
  }
  function YD(t) {
    var e = Ce();
    return t && $(Ot(t.replaceMerge), function(r) {
      e.set(r, true);
    }), {
      replaceMergeMainTypeMap: e
    };
  }
  yr(IT, AT);
  var $ee = [
    "getDom",
    "getZr",
    "getWidth",
    "getHeight",
    "getDevicePixelRatio",
    "dispatchAction",
    "isSSR",
    "isDisposed",
    "on",
    "off",
    "getDataURL",
    "getConnectedDataURL",
    "getOption",
    "getId",
    "updateLabelLayout"
  ], TV = /* @__PURE__ */ function() {
    function t(e) {
      $($ee, function(r) {
        this[r] = _e(e[r], e);
      }, this);
    }
    return t;
  }(), R0 = {}, Nd = function() {
    function t() {
      this._coordinateSystems = [];
    }
    return t.prototype.create = function(e, r) {
      var n = [];
      $(R0, function(i, a) {
        var o = i.create(e, r);
        n = n.concat(o || []);
      }), this._coordinateSystems = n;
    }, t.prototype.update = function(e, r) {
      $(this._coordinateSystems, function(n) {
        n.update && n.update(e, r);
      });
    }, t.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, t.register = function(e, r) {
      R0[e] = r;
    }, t.get = function(e) {
      return R0[e];
    }, t;
  }(), Ree = /^(min|max)?(.+)$/, Oee = function() {
    function t(e) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e;
    }
    return t.prototype.setOption = function(e, r, n) {
      e && ($(Ot(e.series), function(o) {
        o && o.data && $n(o.data) && wg(o.data);
      }), $(Ot(e.dataset), function(o) {
        o && o.source && $n(o.source) && wg(o.source);
      })), e = Oe(e);
      var i = this._optionBackup, a = Nee(e, r, !i);
      this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, t.prototype.mountOption = function(e) {
      var r = this._optionBackup;
      return this._timelineOptions = r.timelineOptions, this._mediaList = r.mediaList, this._mediaDefault = r.mediaDefault, this._currentMediaIndices = [], Oe(e ? r.baseOption : this._newBaseOption);
    }, t.prototype.getTimelineOption = function(e) {
      var r, n = this._timelineOptions;
      if (n.length) {
        var i = e.getComponent("timeline");
        i && (r = Oe(n[i.getCurrentIndex()]));
      }
      return r;
    }, t.prototype.getMediaOption = function(e) {
      var r = this._api.getWidth(), n = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!i.length && !a) return s;
      for (var l = 0, u = i.length; l < u; l++) Bee(i[l].query, r, n) && o.push(l);
      return !o.length && a && (o = [
        -1
      ]), o.length && !Fee(o, this._currentMediaIndices) && (s = oe(o, function(c) {
        return Oe(c === -1 ? a.option : i[c].option);
      })), this._currentMediaIndices = o, s;
    }, t;
  }();
  function Nee(t, e, r) {
    var n = [], i, a, o = t.baseOption, s = t.timeline, l = t.options, u = t.media, c = !!t.media, h = !!(l || s || o && o.timeline);
    o ? (a = o, a.timeline || (a.timeline = s)) : ((h || c) && (t.options = t.media = null), a = t), c && ae(u) && $(u, function(d) {
      d && d.option && (d.query ? n.push(d) : i || (i = d));
    }), f(a), $(l, function(d) {
      return f(d);
    }), $(n, function(d) {
      return f(d.option);
    });
    function f(d) {
      $(e, function(p) {
        p(d, r);
      });
    }
    return {
      baseOption: a,
      timelineOptions: l || [],
      mediaDefault: i,
      mediaList: n
    };
  }
  function Bee(t, e, r) {
    var n = {
      width: e,
      height: r,
      aspectratio: e / r
    }, i = true;
    return $(t, function(a, o) {
      var s = o.match(Ree);
      if (!(!s || !s[1] || !s[2])) {
        var l = s[1], u = s[2].toLowerCase();
        zee(n[u], a, l) || (i = false);
      }
    }), i;
  }
  function zee(t, e, r) {
    return r === "min" ? t >= e : r === "max" ? t <= e : t === e;
  }
  function Fee(t, e) {
    return t.join(",") === e.join(",");
  }
  var Ii = $, Qf = Le, qD = [
    "areaStyle",
    "lineStyle",
    "nodeStyle",
    "linkStyle",
    "chordStyle",
    "label",
    "labelLine"
  ];
  function O0(t) {
    var e = t && t.itemStyle;
    if (e) for (var r = 0, n = qD.length; r < n; r++) {
      var i = qD[r], a = e.normal, o = e.emphasis;
      a && a[i] && (t[i] = t[i] || {}, t[i].normal ? je(t[i].normal, a[i]) : t[i].normal = a[i], a[i] = null), o && o[i] && (t[i] = t[i] || {}, t[i].emphasis ? je(t[i].emphasis, o[i]) : t[i].emphasis = o[i], o[i] = null);
    }
  }
  function en(t, e, r) {
    if (t && t[e] && (t[e].normal || t[e].emphasis)) {
      var n = t[e].normal, i = t[e].emphasis;
      n && (r ? (t[e].normal = t[e].emphasis = null, Ee(t[e], n)) : t[e] = n), i && (t.emphasis = t.emphasis || {}, t.emphasis[e] = i, i.focus && (t.emphasis.focus = i.focus), i.blurScope && (t.emphasis.blurScope = i.blurScope));
    }
  }
  function rf(t) {
    en(t, "itemStyle"), en(t, "lineStyle"), en(t, "areaStyle"), en(t, "label"), en(t, "labelLine"), en(t, "upperLabel"), en(t, "edgeLabel");
  }
  function vr(t, e) {
    var r = Qf(t) && t[e], n = Qf(r) && r.textStyle;
    if (n) for (var i = 0, a = JM.length; i < a; i++) {
      var o = JM[i];
      n.hasOwnProperty(o) && (r[o] = n[o]);
    }
  }
  function li(t) {
    t && (rf(t), vr(t, "label"), t.emphasis && vr(t.emphasis, "label"));
  }
  function Vee(t) {
    if (Qf(t)) {
      O0(t), rf(t), vr(t, "label"), vr(t, "upperLabel"), vr(t, "edgeLabel"), t.emphasis && (vr(t.emphasis, "label"), vr(t.emphasis, "upperLabel"), vr(t.emphasis, "edgeLabel"));
      var e = t.markPoint;
      e && (O0(e), li(e));
      var r = t.markLine;
      r && (O0(r), li(r));
      var n = t.markArea;
      n && li(n);
      var i = t.data;
      if (t.type === "graph") {
        i = i || t.nodes;
        var a = t.links || t.edges;
        if (a && !$n(a)) for (var o = 0; o < a.length; o++) li(a[o]);
        $(t.categories, function(u) {
          rf(u);
        });
      }
      if (i && !$n(i)) for (var o = 0; o < i.length; o++) li(i[o]);
      if (e = t.markPoint, e && e.data) for (var s = e.data, o = 0; o < s.length; o++) li(s[o]);
      if (r = t.markLine, r && r.data) for (var l = r.data, o = 0; o < l.length; o++) ae(l[o]) ? (li(l[o][0]), li(l[o][1])) : li(l[o]);
      t.type === "gauge" ? (vr(t, "axisLabel"), vr(t, "title"), vr(t, "detail")) : t.type === "treemap" ? (en(t.breadcrumb, "itemStyle"), $(t.levels, function(u) {
        rf(u);
      })) : t.type === "tree" && rf(t.leaves);
    }
  }
  function Ha(t) {
    return ae(t) ? t : t ? [
      t
    ] : [];
  }
  function XD(t) {
    return (ae(t) ? t[0] : t) || {};
  }
  function Gee(t, e) {
    Ii(Ha(t.series), function(n) {
      Qf(n) && Vee(n);
    });
    var r = [
      "xAxis",
      "yAxis",
      "radiusAxis",
      "angleAxis",
      "singleAxis",
      "parallelAxis",
      "radar"
    ];
    e && r.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Ii(r, function(n) {
      Ii(Ha(t[n]), function(i) {
        i && (vr(i, "axisLabel"), vr(i.axisPointer, "label"));
      });
    }), Ii(Ha(t.parallel), function(n) {
      var i = n && n.parallelAxisDefault;
      vr(i, "axisLabel"), vr(i && i.axisPointer, "label");
    }), Ii(Ha(t.calendar), function(n) {
      en(n, "itemStyle"), vr(n, "dayLabel"), vr(n, "monthLabel"), vr(n, "yearLabel");
    }), Ii(Ha(t.radar), function(n) {
      vr(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap);
    }), Ii(Ha(t.geo), function(n) {
      Qf(n) && (li(n), Ii(Ha(n.regions), function(i) {
        li(i);
      }));
    }), Ii(Ha(t.timeline), function(n) {
      li(n), en(n, "label"), en(n, "itemStyle"), en(n, "controlStyle", true);
      var i = n.data;
      ae(i) && $(i, function(a) {
        Le(a) && (en(a, "label"), en(a, "itemStyle"));
      });
    }), Ii(Ha(t.toolbox), function(n) {
      en(n, "iconStyle"), Ii(n.feature, function(i) {
        en(i, "iconStyle");
      });
    }), vr(XD(t.axisPointer), "label"), vr(XD(t.tooltip).axisPointer, "label");
  }
  function Wee(t, e) {
    for (var r = e.split(","), n = t, i = 0; i < r.length && (n = n && n[r[i]], n != null); i++) ;
    return n;
  }
  function Hee(t, e, r, n) {
    for (var i = e.split(","), a = t, o, s = 0; s < i.length - 1; s++) o = i[s], a[o] == null && (a[o] = {}), a = a[o];
    a[i[s]] == null && (a[i[s]] = r);
  }
  function jD(t) {
    t && $(Uee, function(e) {
      e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]]);
    });
  }
  var Uee = [
    [
      "x",
      "left"
    ],
    [
      "y",
      "top"
    ],
    [
      "x2",
      "right"
    ],
    [
      "y2",
      "bottom"
    ]
  ], Yee = [
    "grid",
    "geo",
    "parallel",
    "legend",
    "toolbox",
    "title",
    "visualMap",
    "dataZoom",
    "timeline"
  ], N0 = [
    [
      "borderRadius",
      "barBorderRadius"
    ],
    [
      "borderColor",
      "barBorderColor"
    ],
    [
      "borderWidth",
      "barBorderWidth"
    ]
  ];
  function ph(t) {
    var e = t && t.itemStyle;
    if (e) for (var r = 0; r < N0.length; r++) {
      var n = N0[r][1], i = N0[r][0];
      e[n] != null && (e[i] = e[n]);
    }
  }
  function KD(t) {
    t && t.alignTo === "edge" && t.margin != null && t.edgeDistance == null && (t.edgeDistance = t.margin);
  }
  function ZD(t) {
    t && t.downplay && !t.blur && (t.blur = t.downplay);
  }
  function qee(t) {
    t && t.focusNodeAdjacency != null && (t.emphasis = t.emphasis || {}, t.emphasis.focus == null && (t.emphasis.focus = "adjacency"));
  }
  function CV(t, e) {
    if (t) for (var r = 0; r < t.length; r++) e(t[r]), t[r] && CV(t[r].children, e);
  }
  function AV(t, e) {
    Gee(t, e), t.series = Ot(t.series), $(t.series, function(r) {
      if (Le(r)) {
        var n = r.type;
        if (n === "line") r.clipOverflow != null && (r.clip = r.clipOverflow);
        else if (n === "pie" || n === "gauge") {
          r.clockWise != null && (r.clockwise = r.clockWise), KD(r.label);
          var i = r.data;
          if (i && !$n(i)) for (var a = 0; a < i.length; a++) KD(i[a]);
          r.hoverOffset != null && (r.emphasis = r.emphasis || {}, (r.emphasis.scaleSize = null) && (r.emphasis.scaleSize = r.hoverOffset));
        } else if (n === "gauge") {
          var o = Wee(r, "pointer.color");
          o != null && Hee(r, "itemStyle.color", o);
        } else if (n === "bar") {
          ph(r), ph(r.backgroundStyle), ph(r.emphasis);
          var i = r.data;
          if (i && !$n(i)) for (var a = 0; a < i.length; a++) typeof i[a] == "object" && (ph(i[a]), ph(i[a] && i[a].emphasis));
        } else if (n === "sunburst") {
          var s = r.highlightPolicy;
          s && (r.emphasis = r.emphasis || {}, r.emphasis.focus || (r.emphasis.focus = s)), ZD(r), CV(r.data, ZD);
        } else n === "graph" || n === "sankey" ? qee(r) : n === "map" && (r.mapType && !r.map && (r.map = r.mapType), r.mapLocation && Ee(r, r.mapLocation));
        r.hoverAnimation != null && (r.emphasis = r.emphasis || {}, r.emphasis && r.emphasis.scale == null && (r.emphasis.scale = r.hoverAnimation)), jD(r);
      }
    }), t.dataRange && (t.visualMap = t.dataRange), $(Yee, function(r) {
      var n = t[r];
      n && (ae(n) || (n = [
        n
      ]), $(n, function(i) {
        jD(i);
      }));
    });
  }
  function Xee(t) {
    var e = Ce();
    t.eachSeries(function(r) {
      var n = r.get("stack");
      if (n) {
        var i = e.get(n) || e.set(n, []), a = r.getData(), o = {
          stackResultDimension: a.getCalculationInfo("stackResultDimension"),
          stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
          stackedDimension: a.getCalculationInfo("stackedDimension"),
          stackedByDimension: a.getCalculationInfo("stackedByDimension"),
          isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
          data: a,
          seriesModel: r
        };
        if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension)) return;
        i.length && a.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(o);
      }
    }), e.each(jee);
  }
  function jee(t) {
    $(t, function(e, r) {
      var n = [], i = [
        NaN,
        NaN
      ], a = [
        e.stackResultDimension,
        e.stackedOverDimension
      ], o = e.data, s = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign";
      o.modify(a, function(u, c, h) {
        var f = o.get(e.stackedDimension, h);
        if (isNaN(f)) return i;
        var d, p;
        s ? p = o.getRawIndex(h) : d = o.get(e.stackedByDimension, h);
        for (var v = NaN, g = r - 1; g >= 0; g--) {
          var m = t[g];
          if (s || (p = m.data.rawIndexOf(m.stackedByDimension, d)), p >= 0) {
            var y = m.data.getByRawIndex(m.stackResultDimension, p);
            if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && f >= 0 && y > 0 || l === "samesign" && f <= 0 && y < 0) {
              f = UZ(f, y), v = y;
              break;
            }
          }
        }
        return n[0] = f, n[1] = v, n;
      });
    });
  }
  var iy = /* @__PURE__ */ function() {
    function t(e) {
      this.data = e.data || (e.sourceFormat === Na ? {} : []), this.sourceFormat = e.sourceFormat || yV, this.seriesLayoutBy = e.seriesLayoutBy || Ma, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption;
      var r = this.dimensionsDefine = e.dimensionsDefine;
      if (r) for (var n = 0; n < r.length; n++) {
        var i = r[n];
        i.type == null && xV(this, n) === Hr.Must && (i.type = "ordinal");
      }
    }
    return t;
  }();
  function MT(t) {
    return t instanceof iy;
  }
  function Fx(t, e, r) {
    r = r || IV(t);
    var n = e.seriesLayoutBy, i = Zee(t, r, n, e.sourceHeader, e.dimensions), a = new iy({
      data: t,
      sourceFormat: r,
      seriesLayoutBy: n,
      dimensionsDefine: i.dimensionsDefine,
      startIndex: i.startIndex,
      dimensionsDetectedCount: i.dimensionsDetectedCount,
      metaRawOption: Oe(e)
    });
    return a;
  }
  function DT(t) {
    return new iy({
      data: t,
      sourceFormat: $n(t) ? os : wi
    });
  }
  function Kee(t) {
    return new iy({
      data: t.data,
      sourceFormat: t.sourceFormat,
      seriesLayoutBy: t.seriesLayoutBy,
      dimensionsDefine: Oe(t.dimensionsDefine),
      startIndex: t.startIndex,
      dimensionsDetectedCount: t.dimensionsDetectedCount
    });
  }
  function IV(t) {
    var e = yV;
    if ($n(t)) e = os;
    else if (ae(t)) {
      t.length === 0 && (e = sn);
      for (var r = 0, n = t.length; r < n; r++) {
        var i = t[r];
        if (i != null) {
          if (ae(i) || $n(i)) {
            e = sn;
            break;
          } else if (Le(i)) {
            e = Si;
            break;
          }
        }
      }
    } else if (Le(t)) {
      for (var a in t) if (xe(t, a) && on(t[a])) {
        e = Na;
        break;
      }
    }
    return e;
  }
  function Zee(t, e, r, n, i) {
    var a, o;
    if (!t) return {
      dimensionsDefine: QD(i),
      startIndex: o,
      dimensionsDetectedCount: a
    };
    if (e === sn) {
      var s = t;
      n === "auto" || n == null ? JD(function(u) {
        u != null && u !== "-" && (me(u) ? o == null && (o = 1) : o = 0);
      }, r, s, 10) : o = xt(n) ? n : n ? 1 : 0, !i && o === 1 && (i = [], JD(function(u, c) {
        i[c] = u != null ? u + "" : "";
      }, r, s, 1 / 0)), a = i ? i.length : r === qc ? s.length : s[0] ? s[0].length : null;
    } else if (e === Si) i || (i = Qee(t));
    else if (e === Na) i || (i = [], $(t, function(u, c) {
      i.push(c);
    }));
    else if (e === wi) {
      var l = Fc(t[0]);
      a = ae(l) && l.length || 1;
    }
    return {
      startIndex: o,
      dimensionsDefine: QD(i),
      dimensionsDetectedCount: a
    };
  }
  function Qee(t) {
    for (var e = 0, r; e < t.length && !(r = t[e++]); ) ;
    if (r) return gt(r);
  }
  function QD(t) {
    if (t) {
      var e = Ce();
      return oe(t, function(r, n) {
        r = Le(r) ? r : {
          name: r
        };
        var i = {
          name: r.name,
          displayName: r.displayName,
          type: r.type
        };
        if (i.name == null) return i;
        i.name += "", i.displayName == null && (i.displayName = i.name);
        var a = e.get(i.name);
        return a ? i.name += "-" + a.count++ : e.set(i.name, {
          count: 1
        }), i;
      });
    }
  }
  function JD(t, e, r, n) {
    if (e === qc) for (var i = 0; i < r.length && i < n; i++) t(r[i] ? r[i][0] : null, i);
    else for (var a = r[0] || [], i = 0; i < a.length && i < n; i++) t(a[i], i);
  }
  function MV(t) {
    var e = t.sourceFormat;
    return e === Si || e === Na;
  }
  var Ws, Hs, Us, eE, tE, DV = function() {
    function t(e, r) {
      var n = MT(e) ? e : DT(e);
      this._source = n;
      var i = this._data = n.data;
      n.sourceFormat === os && (this._offset = 0, this._dimSize = r, this._data = i), tE(this, i, n);
    }
    return t.prototype.getSource = function() {
      return this._source;
    }, t.prototype.count = function() {
      return 0;
    }, t.prototype.getItem = function(e, r) {
    }, t.prototype.appendData = function(e) {
    }, t.prototype.clean = function() {
    }, t.protoInitialize = function() {
      var e = t.prototype;
      e.pure = false, e.persistent = true;
    }(), t.internalField = function() {
      var e;
      tE = function(o, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, f = l.dimensionsDefine, d = eE[ET(u, c)];
        if (te(o, d), u === os) o.getItem = r, o.count = i, o.fillStorage = n;
        else {
          var p = EV(u, c);
          o.getItem = _e(p, null, s, h, f);
          var v = kV(u, c);
          o.count = _e(v, null, s, h, f);
        }
      };
      var r = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * o, h = 0; h < u; h++) s[h] = l[c + h];
        return s;
      }, n = function(o, s, l, u) {
        for (var c = this._data, h = this._dimSize, f = 0; f < h; f++) {
          for (var d = u[f], p = d[0] == null ? 1 / 0 : d[0], v = d[1] == null ? -1 / 0 : d[1], g = s - o, m = l[f], y = 0; y < g; y++) {
            var _ = c[y * h + f];
            m[o + y] = _, _ < p && (p = _), _ > v && (v = _);
          }
          d[0] = p, d[1] = v;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      eE = (e = {}, e[sn + "_" + Ma] = {
        pure: true,
        appendData: a
      }, e[sn + "_" + qc] = {
        pure: true,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, e[Si] = {
        pure: true,
        appendData: a
      }, e[Na] = {
        pure: true,
        appendData: function(o) {
          var s = this._data;
          $(o, function(l, u) {
            for (var c = s[u] || (s[u] = []), h = 0; h < (l || []).length; h++) c.push(l[h]);
          });
        }
      }, e[wi] = {
        appendData: a
      }, e[os] = {
        persistent: false,
        pure: true,
        appendData: function(o) {
          this._data = o;
        },
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, e);
      function a(o) {
        for (var s = 0; s < o.length; s++) this._data.push(o[s]);
      }
    }(), t;
  }(), rE = function(t, e, r, n) {
    return t[n];
  }, Jee = (Ws = {}, Ws[sn + "_" + Ma] = function(t, e, r, n) {
    return t[n + e];
  }, Ws[sn + "_" + qc] = function(t, e, r, n, i) {
    n += e;
    for (var a = i || [], o = t, s = 0; s < o.length; s++) {
      var l = o[s];
      a[s] = l ? l[n] : null;
    }
    return a;
  }, Ws[Si] = rE, Ws[Na] = function(t, e, r, n, i) {
    for (var a = i || [], o = 0; o < r.length; o++) {
      var s = r[o].name, l = t[s];
      a[o] = l ? l[n] : null;
    }
    return a;
  }, Ws[wi] = rE, Ws);
  function EV(t, e) {
    var r = Jee[ET(t, e)];
    return r;
  }
  var nE = function(t, e, r) {
    return t.length;
  }, ete = (Hs = {}, Hs[sn + "_" + Ma] = function(t, e, r) {
    return Math.max(0, t.length - e);
  }, Hs[sn + "_" + qc] = function(t, e, r) {
    var n = t[0];
    return n ? Math.max(0, n.length - e) : 0;
  }, Hs[Si] = nE, Hs[Na] = function(t, e, r) {
    var n = r[0].name, i = t[n];
    return i ? i.length : 0;
  }, Hs[wi] = nE, Hs);
  function kV(t, e) {
    var r = ete[ET(t, e)];
    return r;
  }
  var B0 = function(t, e, r) {
    return t[e];
  }, tte = (Us = {}, Us[sn] = B0, Us[Si] = function(t, e, r) {
    return t[r];
  }, Us[Na] = B0, Us[wi] = function(t, e, r) {
    var n = Fc(t);
    return n instanceof Array ? n[e] : n;
  }, Us[os] = B0, Us);
  function PV(t) {
    var e = tte[t];
    return e;
  }
  function ET(t, e) {
    return t === sn ? t + "_" + e : t;
  }
  function _c(t, e, r) {
    if (t) {
      var n = t.getRawDataItem(e);
      if (n != null) {
        var i = t.getStore(), a = i.getSource().sourceFormat;
        if (r != null) {
          var o = t.getDimensionIndex(r), s = i.getDimensionProperty(o);
          return PV(a)(n, o, s);
        } else {
          var l = n;
          return a === wi && (l = Fc(n)), l;
        }
      }
    }
  }
  var rte = /\{@(.+?)\}/g, ay = function() {
    function t() {
    }
    return t.prototype.getDataParams = function(e, r) {
      var n = this.getData(r), i = this.getRawValue(e, r), a = n.getRawIndex(e), o = n.getName(e), s = n.getRawDataItem(e), l = n.getItemVisual(e, "style"), u = l && l[n.getItemVisual(e, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, f = h === "series", d = n.userOutput && n.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: f ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: f ? this.id : null,
        seriesName: f ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: r,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        $vars: [
          "seriesName",
          "name",
          "value"
        ]
      };
    }, t.prototype.getFormattedLabel = function(e, r, n, i, a, o) {
      r = r || "normal";
      var s = this.getData(n), l = this.getDataParams(e, n);
      if (o && (l.value = o.interpolatedValue), i != null && ae(l.value) && (l.value = l.value[i]), !a) {
        var u = s.getItemModel(e);
        a = u.get(r === "normal" ? [
          "label",
          "formatter"
        ] : [
          r,
          "label",
          "formatter"
        ]);
      }
      if (De(a)) return l.status = r, l.dimensionIndex = i, a(l);
      if (me(a)) {
        var c = dV(a, l);
        return c.replace(rte, function(h, f) {
          var d = f.length, p = f;
          p.charAt(0) === "[" && p.charAt(d - 1) === "]" && (p = +p.slice(1, d - 1));
          var v = _c(s, e, p);
          if (o && ae(o.interpolatedValue)) {
            var g = s.getDimensionIndex(p);
            g >= 0 && (v = o.interpolatedValue[g]);
          }
          return v != null ? v + "" : "";
        });
      }
    }, t.prototype.getRawValue = function(e, r) {
      return _c(this.getData(r), e);
    }, t.prototype.formatTooltip = function(e, r, n) {
    }, t;
  }();
  function iE(t) {
    var e, r;
    return Le(t) ? t.type && (r = t) : e = t, {
      text: e,
      frag: r
    };
  }
  function If(t) {
    return new nte(t);
  }
  var nte = function() {
    function t(e) {
      e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = true;
    }
    return t.prototype.perform = function(e) {
      var r = this._upstream, n = e && e.skip;
      if (this._dirty && r) {
        var i = this.context;
        i.data = i.outputData = r.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var o = c(this._modBy), s = this._modDataCount || 0, l = c(e && e.modBy), u = e && e.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = false, h = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var f = e && e.step;
      if (r ? this._dueEnd = r._outputDueEnd : this._dueEnd = this._count ? this._count(this.context) : 1 / 0, this._progress) {
        var d = this._dueIndex, p = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
        if (!n && (h || d < p)) {
          var v = this._progress;
          if (ae(v)) for (var g = 0; g < v.length; g++) this._doProgress(v[g], d, p, l, u);
          else this._doProgress(v, d, p, l, u);
        }
        this._dueIndex = p;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        this._outputDueEnd = m;
      } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, t.prototype.dirty = function() {
      this._dirty = true, this._onDirty && this._onDirty(this.context);
    }, t.prototype._doProgress = function(e, r, n, i, a) {
      aE.reset(r, n, i, a), this._callingProgress = e, this._callingProgress({
        start: r,
        end: n,
        count: n - r,
        next: aE.next
      }, this.context);
    }, t.prototype._doReset = function(e) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var r, n;
      !e && this._reset && (r = this._reset(this.context), r && r.progress && (n = r.forceFirstProgress, r = r.progress), ae(r) && !r.length && (r = null)), this._progress = r, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), n;
    }, t.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, t.prototype.pipe = function(e) {
      (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty());
    }, t.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = false, this._disposed = true);
    }, t.prototype.getUpstream = function() {
      return this._upstream;
    }, t.prototype.getDownstream = function() {
      return this._downstream;
    }, t.prototype.setOutputEnd = function(e) {
      this._outputDueEnd = this._settedOutputEnd = e;
    }, t;
  }(), aE = /* @__PURE__ */ function() {
    var t, e, r, n, i, a = {
      reset: function(l, u, c, h) {
        e = l, t = u, r = c, n = h, i = Math.ceil(n / r), a.next = r > 1 && n > 0 ? s : o;
      }
    };
    return a;
    function o() {
      return e < t ? e++ : null;
    }
    function s() {
      var l = e % i * r + Math.ceil(e / i), u = e >= t ? null : l < n ? l : e;
      return e++, u;
    }
  }();
  function ss(t, e) {
    var r = e && e.type;
    return r === "ordinal" ? t : (r === "time" && !xt(t) && t != null && t !== "-" && (t = +$a(t)), t == null || t === "" ? NaN : Number(t));
  }
  var ite = Ce({
    number: function(t) {
      return parseFloat(t);
    },
    time: function(t) {
      return +$a(t);
    },
    trim: function(t) {
      return me(t) ? Vi(t) : t;
    }
  });
  function LV(t) {
    return ite.get(t);
  }
  var $V = {
    lt: function(t, e) {
      return t < e;
    },
    lte: function(t, e) {
      return t <= e;
    },
    gt: function(t, e) {
      return t > e;
    },
    gte: function(t, e) {
      return t >= e;
    }
  }, ate = function() {
    function t(e, r) {
      if (!xt(r)) {
        var n = "";
        It(n);
      }
      this._opFn = $V[e], this._rvalFloat = ho(r);
    }
    return t.prototype.evaluate = function(e) {
      return xt(e) ? this._opFn(e, this._rvalFloat) : this._opFn(ho(e), this._rvalFloat);
    }, t;
  }(), RV = function() {
    function t(e, r) {
      var n = e === "desc";
      this._resultLT = n ? 1 : -1, r == null && (r = n ? "min" : "max"), this._incomparable = r === "min" ? -1 / 0 : 1 / 0;
    }
    return t.prototype.evaluate = function(e, r) {
      var n = xt(e) ? e : ho(e), i = xt(r) ? r : ho(r), a = isNaN(n), o = isNaN(i);
      if (a && (n = this._incomparable), o && (i = this._incomparable), a && o) {
        var s = me(e), l = me(r);
        s && (n = l ? e : 0), l && (i = s ? r : 0);
      }
      return n < i ? this._resultLT : n > i ? -this._resultLT : 0;
    }, t;
  }(), ote = function() {
    function t(e, r) {
      this._rval = r, this._isEQ = e, this._rvalTypeof = typeof r, this._rvalFloat = ho(r);
    }
    return t.prototype.evaluate = function(e) {
      var r = e === this._rval;
      if (!r) {
        var n = typeof e;
        n !== this._rvalTypeof && (n === "number" || this._rvalTypeof === "number") && (r = ho(e) === this._rvalFloat);
      }
      return this._isEQ ? r : !r;
    }, t;
  }();
  function ste(t, e) {
    return t === "eq" || t === "ne" ? new ote(t === "eq", e) : xe($V, t) ? new ate(t, e) : null;
  }
  var lte = function() {
    function t() {
    }
    return t.prototype.getRawData = function() {
      throw new Error("not supported");
    }, t.prototype.getRawDataItem = function(e) {
      throw new Error("not supported");
    }, t.prototype.cloneRawData = function() {
    }, t.prototype.getDimensionInfo = function(e) {
    }, t.prototype.cloneAllDimensionInfo = function() {
    }, t.prototype.count = function() {
    }, t.prototype.retrieveValue = function(e, r) {
    }, t.prototype.retrieveValueFromItem = function(e, r) {
    }, t.prototype.convertValue = function(e, r) {
      return ss(e, r);
    }, t;
  }();
  function ute(t, e) {
    var r = new lte(), n = t.data, i = r.sourceFormat = t.sourceFormat, a = t.startIndex, o = "";
    t.seriesLayoutBy !== Ma && It(o);
    var s = [], l = {}, u = t.dimensionsDefine;
    if (u) $(u, function(v, g) {
      var m = v.name, y = {
        index: g,
        name: m,
        displayName: v.displayName
      };
      if (s.push(y), m != null) {
        var _ = "";
        xe(l, m) && It(_), l[m] = y;
      }
    });
    else for (var c = 0; c < t.dimensionsDetectedCount; c++) s.push({
      index: c
    });
    var h = EV(i, Ma);
    e.__isBuiltIn && (r.getRawDataItem = function(v) {
      return h(n, a, s, v);
    }, r.getRawData = _e(cte, null, t)), r.cloneRawData = _e(hte, null, t);
    var f = kV(i, Ma);
    r.count = _e(f, null, n, a, s);
    var d = PV(i);
    r.retrieveValue = function(v, g) {
      var m = h(n, a, s, v);
      return p(m, g);
    };
    var p = r.retrieveValueFromItem = function(v, g) {
      if (v != null) {
        var m = s[g];
        if (m) return d(v, g, m.name);
      }
    };
    return r.getDimensionInfo = _e(fte, null, s, l), r.cloneAllDimensionInfo = _e(dte, null, s), r;
  }
  function cte(t) {
    var e = t.sourceFormat;
    if (!kT(e)) {
      var r = "";
      It(r);
    }
    return t.data;
  }
  function hte(t) {
    var e = t.sourceFormat, r = t.data;
    if (!kT(e)) {
      var n = "";
      It(n);
    }
    if (e === sn) {
      for (var i = [], a = 0, o = r.length; a < o; a++) i.push(r[a].slice());
      return i;
    } else if (e === Si) {
      for (var i = [], a = 0, o = r.length; a < o; a++) i.push(te({}, r[a]));
      return i;
    }
  }
  function fte(t, e, r) {
    if (r != null) {
      if (xt(r) || !isNaN(r) && !xe(e, r)) return t[r];
      if (xe(e, r)) return e[r];
    }
  }
  function dte(t) {
    return Oe(t);
  }
  var OV = Ce();
  function pte(t) {
    t = Oe(t);
    var e = t.type, r = "";
    e || It(r);
    var n = e.split(":");
    n.length !== 2 && It(r);
    var i = false;
    n[0] === "echarts" && (e = n[1], i = true), t.__isBuiltIn = i, OV.set(e, t);
  }
  function vte(t, e, r) {
    var n = Ot(t), i = n.length, a = "";
    i || It(a);
    for (var o = 0, s = i; o < s; o++) {
      var l = n[o];
      e = gte(l, e), o !== s - 1 && (e.length = Math.max(e.length, 1));
    }
    return e;
  }
  function gte(t, e, r, n) {
    var i = "";
    e.length || It(i), Le(t) || It(i);
    var a = t.type, o = OV.get(a);
    o || It(i);
    var s = oe(e, function(u) {
      return ute(u, o);
    }), l = Ot(o.transform({
      upstream: s[0],
      upstreamList: s,
      config: Oe(t.config)
    }));
    return oe(l, function(u, c) {
      var h = "";
      Le(u) || It(h), u.data || It(h);
      var f = IV(u.data);
      kT(f) || It(h);
      var d, p = e[0];
      if (p && c === 0 && !u.dimensions) {
        var v = p.startIndex;
        v && (u.data = p.data.slice(0, v).concat(u.data)), d = {
          seriesLayoutBy: Ma,
          sourceHeader: v,
          dimensions: p.metaRawOption.dimensions
        };
      } else d = {
        seriesLayoutBy: Ma,
        sourceHeader: 0,
        dimensions: u.dimensions
      };
      return Fx(u.data, d, null);
    });
  }
  function kT(t) {
    return t === sn || t === Si;
  }
  var oy = "undefined", mte = typeof Uint32Array === oy ? Array : Uint32Array, yte = typeof Uint16Array === oy ? Array : Uint16Array, NV = typeof Int32Array === oy ? Array : Int32Array, oE = typeof Float64Array === oy ? Array : Float64Array, BV = {
    float: oE,
    int: NV,
    ordinal: Array,
    number: Array,
    time: oE
  }, z0;
  function Cu(t) {
    return t > 65535 ? mte : yte;
  }
  function Au() {
    return [
      1 / 0,
      -1 / 0
    ];
  }
  function _te(t) {
    var e = t.constructor;
    return e === Array ? t.slice() : new e(t);
  }
  function sE(t, e, r, n, i) {
    var a = BV[r || "float"];
    if (i) {
      var o = t[e], s = o && o.length;
      if (s !== n) {
        for (var l = new a(n), u = 0; u < s; u++) l[u] = o[u];
        t[e] = l;
      }
    } else t[e] = new a(n);
  }
  var Vx = function() {
    function t() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = Ce();
    }
    return t.prototype.initData = function(e, r, n) {
      this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = e.getSource(), a = this.defaultDimValueGetter = z0[i.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [], MV(i), this._dimensions = oe(r, function(o) {
        return {
          type: o.type,
          property: o.property
        };
      }), this._initDataFromProvider(0, e.count());
    }, t.prototype.getProvider = function() {
      return this._provider;
    }, t.prototype.getSource = function() {
      return this._provider.getSource();
    }, t.prototype.ensureCalculationDimension = function(e, r) {
      var n = this._calcDimNameToIdx, i = this._dimensions, a = n.get(e);
      if (a != null) {
        if (i[a].type === r) return a;
      } else a = i.length;
      return i[a] = {
        type: r
      }, n.set(e, a), this._chunks[a] = new BV[r || "float"](this._rawCount), this._rawExtent[a] = Au(), a;
    }, t.prototype.collectOrdinalMeta = function(e, r) {
      var n = this._chunks[e], i = this._dimensions[e], a = this._rawExtent, o = i.ordinalOffset || 0, s = n.length;
      o === 0 && (a[e] = Au());
      for (var l = a[e], u = o; u < s; u++) {
        var c = n[u] = r.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = r, i.ordinalOffset = s, i.type = "ordinal";
    }, t.prototype.getOrdinalMeta = function(e) {
      var r = this._dimensions[e], n = r.ordinalMeta;
      return n;
    }, t.prototype.getDimensionProperty = function(e) {
      var r = this._dimensions[e];
      return r && r.property;
    }, t.prototype.appendData = function(e) {
      var r = this._provider, n = this.count();
      r.appendData(e);
      var i = r.count();
      return r.persistent || (i += n), n < i && this._initDataFromProvider(n, i, true), [
        n,
        i
      ];
    }, t.prototype.appendValues = function(e, r) {
      for (var n = this._chunks, i = this._dimensions, a = i.length, o = this._rawExtent, s = this.count(), l = s + Math.max(e.length, r || 0), u = 0; u < a; u++) {
        var c = i[u];
        sE(n, u, c.type, l, true);
      }
      for (var h = [], f = s; f < l; f++) for (var d = f - s, p = 0; p < a; p++) {
        var c = i[p], v = z0.arrayRows.call(this, e[d] || h, c.property, d, p);
        n[p][f] = v;
        var g = o[p];
        v < g[0] && (g[0] = v), v > g[1] && (g[1] = v);
      }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, t.prototype._initDataFromProvider = function(e, r, n) {
      for (var i = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = oe(o, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var h = o[c];
        l[c] || (l[c] = Au()), sE(a, c, h.type, r, n);
      }
      if (i.fillStorage) i.fillStorage(e, r, a, l);
      else for (var f = [], d = e; d < r; d++) {
        f = i.getItem(d, f);
        for (var p = 0; p < s; p++) {
          var v = a[p], g = this._dimValueGetter(f, u[p], d, p);
          v[d] = g;
          var m = l[p];
          g < m[0] && (m[0] = g), g > m[1] && (m[1] = g);
        }
      }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = r, this._extent = [];
    }, t.prototype.count = function() {
      return this._count;
    }, t.prototype.get = function(e, r) {
      if (!(r >= 0 && r < this._count)) return NaN;
      var n = this._chunks[e];
      return n ? n[this.getRawIndex(r)] : NaN;
    }, t.prototype.getValues = function(e, r) {
      var n = [], i = [];
      if (r == null) {
        r = e, e = [];
        for (var a = 0; a < this._dimensions.length; a++) i.push(a);
      } else i = e;
      for (var a = 0, o = i.length; a < o; a++) n.push(this.get(i[a], r));
      return n;
    }, t.prototype.getByRawIndex = function(e, r) {
      if (!(r >= 0 && r < this._rawCount)) return NaN;
      var n = this._chunks[e];
      return n ? n[r] : NaN;
    }, t.prototype.getSum = function(e) {
      var r = this._chunks[e], n = 0;
      if (r) for (var i = 0, a = this.count(); i < a; i++) {
        var o = this.get(e, i);
        isNaN(o) || (n += o);
      }
      return n;
    }, t.prototype.getMedian = function(e) {
      var r = [];
      this.each([
        e
      ], function(a) {
        isNaN(a) || r.push(a);
      });
      var n = r.sort(function(a, o) {
        return a - o;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2;
    }, t.prototype.indexOfRawIndex = function(e) {
      if (e >= this._rawCount || e < 0) return -1;
      if (!this._indices) return e;
      var r = this._indices, n = r[e];
      if (n != null && n < this._count && n === e) return e;
      for (var i = 0, a = this._count - 1; i <= a; ) {
        var o = (i + a) / 2 | 0;
        if (r[o] < e) i = o + 1;
        else if (r[o] > e) a = o - 1;
        else return o;
      }
      return -1;
    }, t.prototype.indicesOfNearest = function(e, r, n) {
      var i = this._chunks, a = i[e], o = [];
      if (!a) return o;
      n == null && (n = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, c = 0, h = this.count(); c < h; c++) {
        var f = this.getRawIndex(c), d = r - a[f], p = Math.abs(d);
        p <= n && ((p < s || p === s && d >= 0 && l < 0) && (s = p, l = d, u = 0), d === l && (o[u++] = c));
      }
      return o.length = u, o;
    }, t.prototype.getIndices = function() {
      var e, r = this._indices;
      if (r) {
        var n = r.constructor, i = this._count;
        if (n === Array) {
          e = new n(i);
          for (var a = 0; a < i; a++) e[a] = r[a];
        } else e = new n(r.buffer, 0, i);
      } else {
        var n = Cu(this._rawCount);
        e = new n(this.count());
        for (var a = 0; a < e.length; a++) e[a] = a;
      }
      return e;
    }, t.prototype.filter = function(e, r) {
      if (!this._count) return this;
      for (var n = this.clone(), i = n.count(), a = Cu(n._rawCount), o = new a(i), s = [], l = e.length, u = 0, c = e[0], h = n._chunks, f = 0; f < i; f++) {
        var d = void 0, p = n.getRawIndex(f);
        if (l === 0) d = r(f);
        else if (l === 1) {
          var v = h[c][p];
          d = r(v, f);
        } else {
          for (var g = 0; g < l; g++) s[g] = h[e[g]][p];
          s[g] = f, d = r.apply(null, s);
        }
        d && (o[u++] = p);
      }
      return u < i && (n._indices = o), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, t.prototype.selectRange = function(e) {
      var r = this.clone(), n = r._count;
      if (!n) return this;
      var i = gt(e), a = i.length;
      if (!a) return this;
      var o = r.count(), s = Cu(r._rawCount), l = new s(o), u = 0, c = i[0], h = e[c][0], f = e[c][1], d = r._chunks, p = false;
      if (!r._indices) {
        var v = 0;
        if (a === 1) {
          for (var g = d[i[0]], m = 0; m < n; m++) {
            var y = g[m];
            (y >= h && y <= f || isNaN(y)) && (l[u++] = v), v++;
          }
          p = true;
        } else if (a === 2) {
          for (var g = d[i[0]], _ = d[i[1]], b = e[i[1]][0], w = e[i[1]][1], m = 0; m < n; m++) {
            var y = g[m], x = _[m];
            (y >= h && y <= f || isNaN(y)) && (x >= b && x <= w || isNaN(x)) && (l[u++] = v), v++;
          }
          p = true;
        }
      }
      if (!p) if (a === 1) for (var m = 0; m < o; m++) {
        var T = r.getRawIndex(m), y = d[i[0]][T];
        (y >= h && y <= f || isNaN(y)) && (l[u++] = T);
      }
      else for (var m = 0; m < o; m++) {
        for (var A = true, T = r.getRawIndex(m), I = 0; I < a; I++) {
          var M = i[I], y = d[M][T];
          (y < e[M][0] || y > e[M][1]) && (A = false);
        }
        A && (l[u++] = r.getRawIndex(m));
      }
      return u < o && (r._indices = l), r._count = u, r._extent = [], r._updateGetRawIdx(), r;
    }, t.prototype.map = function(e, r) {
      var n = this.clone(e);
      return this._updateDims(n, e, r), n;
    }, t.prototype.modify = function(e, r) {
      this._updateDims(this, e, r);
    }, t.prototype._updateDims = function(e, r, n) {
      for (var i = e._chunks, a = [], o = r.length, s = e.count(), l = [], u = e._rawExtent, c = 0; c < r.length; c++) u[r[c]] = Au();
      for (var h = 0; h < s; h++) {
        for (var f = e.getRawIndex(h), d = 0; d < o; d++) l[d] = i[r[d]][f];
        l[o] = h;
        var p = n && n.apply(null, l);
        if (p != null) {
          typeof p != "object" && (a[0] = p, p = a);
          for (var c = 0; c < p.length; c++) {
            var v = r[c], g = p[c], m = u[v], y = i[v];
            y && (y[f] = g), g < m[0] && (m[0] = g), g > m[1] && (m[1] = g);
          }
        }
      }
    }, t.prototype.lttbDownSample = function(e, r) {
      var n = this.clone([
        e
      ], true), i = n._chunks, a = i[e], o = this.count(), s = 0, l = Math.floor(1 / r), u = this.getRawIndex(0), c, h, f, d = new (Cu(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      d[s++] = u;
      for (var p = 1; p < o - 1; p += l) {
        for (var v = Math.min(p + l, o - 1), g = Math.min(p + l * 2, o), m = (g + v) / 2, y = 0, _ = v; _ < g; _++) {
          var b = this.getRawIndex(_), w = a[b];
          isNaN(w) || (y += w);
        }
        y /= g - v;
        var x = p, T = Math.min(p + l, o), A = p - 1, I = a[u];
        c = -1, f = x;
        for (var M = -1, k = 0, _ = x; _ < T; _++) {
          var b = this.getRawIndex(_), w = a[b];
          if (isNaN(w)) {
            k++, M < 0 && (M = b);
            continue;
          }
          h = Math.abs((A - m) * (w - I) - (A - _) * (y - I)), h > c && (c = h, f = b);
        }
        k > 0 && k < T - x && (d[s++] = Math.min(M, f), f = Math.max(M, f)), d[s++] = f, u = f;
      }
      return d[s++] = this.getRawIndex(o - 1), n._count = s, n._indices = d, n.getRawIndex = this._getRawIdx, n;
    }, t.prototype.minmaxDownSample = function(e, r) {
      for (var n = this.clone([
        e
      ], true), i = n._chunks, a = Math.floor(1 / r), o = i[e], s = this.count(), l = new (Cu(this._rawCount))(Math.ceil(s / a) * 2), u = 0, c = 0; c < s; c += a) {
        var h = c, f = o[this.getRawIndex(h)], d = c, p = o[this.getRawIndex(d)], v = a;
        c + a > s && (v = s - c);
        for (var g = 0; g < v; g++) {
          var m = this.getRawIndex(c + g), y = o[m];
          y < f && (f = y, h = c + g), y > p && (p = y, d = c + g);
        }
        var _ = this.getRawIndex(h), b = this.getRawIndex(d);
        h < d ? (l[u++] = _, l[u++] = b) : (l[u++] = b, l[u++] = _);
      }
      return n._count = u, n._indices = l, n._updateGetRawIdx(), n;
    }, t.prototype.downSample = function(e, r, n, i) {
      for (var a = this.clone([
        e
      ], true), o = a._chunks, s = [], l = Math.floor(1 / r), u = o[e], c = this.count(), h = a._rawExtent[e] = Au(), f = new (Cu(this._rawCount))(Math.ceil(c / l)), d = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, s.length = l);
        for (var v = 0; v < l; v++) {
          var g = this.getRawIndex(p + v);
          s[v] = u[g];
        }
        var m = n(s), y = this.getRawIndex(Math.min(p + i(s, m) || 0, c - 1));
        u[y] = m, m < h[0] && (h[0] = m), m > h[1] && (h[1] = m), f[d++] = y;
      }
      return a._count = d, a._indices = f, a._updateGetRawIdx(), a;
    }, t.prototype.each = function(e, r) {
      if (this._count) for (var n = e.length, i = this._chunks, a = 0, o = this.count(); a < o; a++) {
        var s = this.getRawIndex(a);
        switch (n) {
          case 0:
            r(a);
            break;
          case 1:
            r(i[e[0]][s], a);
            break;
          case 2:
            r(i[e[0]][s], i[e[1]][s], a);
            break;
          default:
            for (var l = 0, u = []; l < n; l++) u[l] = i[e[l]][s];
            u[l] = a, r.apply(null, u);
        }
      }
    }, t.prototype.getDataExtent = function(e) {
      var r = this._chunks[e], n = Au();
      if (!r) return n;
      var i = this.count(), a = !this._indices, o;
      if (a) return this._rawExtent[e].slice();
      if (o = this._extent[e], o) return o.slice();
      o = n;
      for (var s = o[0], l = o[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), h = r[c];
        h < s && (s = h), h > l && (l = h);
      }
      return o = [
        s,
        l
      ], this._extent[e] = o, o;
    }, t.prototype.getRawDataItem = function(e) {
      var r = this.getRawIndex(e);
      if (this._provider.persistent) return this._provider.getItem(r);
      for (var n = [], i = this._chunks, a = 0; a < i.length; a++) n.push(i[a][r]);
      return n;
    }, t.prototype.clone = function(e, r) {
      var n = new t(), i = this._chunks, a = e && ka(e, function(s, l) {
        return s[l] = true, s;
      }, {});
      if (a) for (var o = 0; o < i.length; o++) n._chunks[o] = a[o] ? _te(i[o]) : i[o];
      else n._chunks = i;
      return this._copyCommonProps(n), r || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, t.prototype._copyCommonProps = function(e) {
      e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = Oe(this._extent), e._rawExtent = Oe(this._rawExtent);
    }, t.prototype._cloneIndices = function() {
      if (this._indices) {
        var e = this._indices.constructor, r = void 0;
        if (e === Array) {
          var n = this._indices.length;
          r = new e(n);
          for (var i = 0; i < n; i++) r[i] = this._indices[i];
        } else r = new e(this._indices);
        return r;
      }
      return null;
    }, t.prototype._getRawIdxIdentity = function(e) {
      return e;
    }, t.prototype._getRawIdx = function(e) {
      return e < this._count && e >= 0 ? this._indices[e] : -1;
    }, t.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, t.internalField = function() {
      function e(r, n, i, a) {
        return ss(r[a], this._dimensions[a]);
      }
      z0 = {
        arrayRows: e,
        objectRows: function(r, n, i, a) {
          return ss(r[n], this._dimensions[a]);
        },
        keyedColumns: e,
        original: function(r, n, i, a) {
          var o = r && (r.value == null ? r : r.value);
          return ss(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(r, n, i, a) {
          return r[a];
        }
      };
    }(), t;
  }(), zV = function() {
    function t(e) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = true, this._sourceHost = e;
    }
    return t.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = true;
    }, t.prototype._setLocalSource = function(e, r) {
      this._sourceList = e, this._upstreamSignList = r, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, t.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, t.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = false);
    }, t.prototype._createSource = function() {
      this._setLocalSource([], []);
      var e = this._sourceHost, r = this._getUpstreamSourceManagers(), n = !!r.length, i, a;
      if (Pp(e)) {
        var o = e, s = void 0, l = void 0, u = void 0;
        if (n) {
          var c = r[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, a = [
            c._getVersionSign()
          ];
        } else s = o.get("data", true), l = $n(s) ? os : wi, a = [];
        var h = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, d = We(h.seriesLayoutBy, f.seriesLayoutBy) || null, p = We(h.sourceHeader, f.sourceHeader), v = We(h.dimensions, f.dimensions), g = d !== f.seriesLayoutBy || !!p != !!f.sourceHeader || v;
        i = g ? [
          Fx(s, {
            seriesLayoutBy: d,
            sourceHeader: p,
            dimensions: v
          }, l)
        ] : [];
      } else {
        var m = e;
        if (n) {
          var y = this._applyTransform(r);
          i = y.sourceList, a = y.upstreamSignList;
        } else {
          var _ = m.get("source", true);
          i = [
            Fx(_, this._getSourceMetaRawOption(), null)
          ], a = [];
        }
      }
      this._setLocalSource(i, a);
    }, t.prototype._applyTransform = function(e) {
      var r = this._sourceHost, n = r.get("transform", true), i = r.get("fromTransformResult", true);
      if (i != null) {
        var a = "";
        e.length !== 1 && uE(a);
      }
      var o, s = [], l = [];
      return $(e, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), h = "";
        i != null && !c && uE(h), s.push(c), l.push(u._getVersionSign());
      }), n ? o = vte(n, s, {
        datasetIndex: r.componentIndex
      }) : i != null && (o = [
        Kee(s[0])
      ]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, t.prototype._isDirty = function() {
      if (this._dirty) return true;
      for (var e = this._getUpstreamSourceManagers(), r = 0; r < e.length; r++) {
        var n = e[r];
        if (n._isDirty() || this._upstreamSignList[r] !== n._getVersionSign()) return true;
      }
    }, t.prototype.getSource = function(e) {
      e = e || 0;
      var r = this._sourceList[e];
      if (!r) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(e);
      }
      return r;
    }, t.prototype.getSharedDataStore = function(e) {
      var r = e.makeStoreSchema();
      return this._innerGetDataStore(r.dimensions, e.source, r.hash);
    }, t.prototype._innerGetDataStore = function(e, r, n) {
      var i = 0, a = this._storeList, o = a[i];
      o || (o = a[i] = {});
      var s = o[n];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        Pp(this._sourceHost) && l ? s = l._innerGetDataStore(e, r, n) : (s = new Vx(), s.initData(new DV(r, e.length), e)), o[n] = s;
      }
      return s;
    }, t.prototype._getUpstreamSourceManagers = function() {
      var e = this._sourceHost;
      if (Pp(e)) {
        var r = CT(e);
        return r ? [
          r.getSourceManager()
        ] : [];
      } else return oe(Cee(e), function(n) {
        return n.getSourceManager();
      });
    }, t.prototype._getSourceMetaRawOption = function() {
      var e = this._sourceHost, r, n, i;
      if (Pp(e)) r = e.get("seriesLayoutBy", true), n = e.get("sourceHeader", true), i = e.get("dimensions", true);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = e;
        r = a.get("seriesLayoutBy", true), n = a.get("sourceHeader", true), i = a.get("dimensions", true);
      }
      return {
        seriesLayoutBy: r,
        sourceHeader: n,
        dimensions: i
      };
    }, t;
  }();
  function lE(t) {
    var e = t.option.transform;
    e && wg(t.option.transform);
  }
  function Pp(t) {
    return t.mainType === "series";
  }
  function uE(t) {
    throw new Error(t);
  }
  var bte = "line-height:1";
  function FV(t) {
    var e = t.lineHeight;
    return e == null ? bte : "line-height:" + vn(e + "") + "px";
  }
  function VV(t, e) {
    var r = t.color || "#6e7079", n = t.fontSize || 12, i = t.fontWeight || "400", a = t.color || "#464646", o = t.fontSize || 14, s = t.fontWeight || "900";
    return e === "html" ? {
      nameStyle: "font-size:" + vn(n + "") + "px;color:" + vn(r) + ";font-weight:" + vn(i + ""),
      valueStyle: "font-size:" + vn(o + "") + "px;color:" + vn(a) + ";font-weight:" + vn(s + "")
    } : {
      nameStyle: {
        fontSize: n,
        fill: r,
        fontWeight: i
      },
      valueStyle: {
        fontSize: o,
        fill: a,
        fontWeight: s
      }
    };
  }
  var xte = [
    0,
    10,
    20,
    30
  ], wte = [
    "",
    `
`,
    `

`,
    `


`
  ];
  function $r(t, e) {
    return e.type = t, e;
  }
  function Gx(t) {
    return t.type === "section";
  }
  function GV(t) {
    return Gx(t) ? Ste : Tte;
  }
  function WV(t) {
    if (Gx(t)) {
      var e = 0, r = t.blocks.length, n = r > 1 || r > 0 && !t.noHeader;
      return $(t.blocks, function(i) {
        var a = WV(i);
        a >= e && (e = a + +(n && (!a || Gx(i) && !i.noHeader)));
      }), e;
    }
    return 0;
  }
  function Ste(t, e, r, n) {
    var i = e.noHeader, a = Cte(WV(e)), o = [], s = e.blocks || [];
    bn(!s || ae(s)), s = s || [];
    var l = t.orderMode;
    if (e.sortBlocks && l) {
      s = s.slice();
      var u = {
        valueAsc: "asc",
        valueDesc: "desc"
      };
      if (xe(u, l)) {
        var c = new RV(u[l], null);
        s.sort(function(v, g) {
          return c.evaluate(v.sortParam, g.sortParam);
        });
      } else l === "seriesDesc" && s.reverse();
    }
    $(s, function(v, g) {
      var m = e.valueFormatter, y = GV(v)(m ? te(te({}, t), {
        valueFormatter: m
      }) : t, v, g > 0 ? a.html : 0, n);
      y != null && o.push(y);
    });
    var h = t.renderMode === "richText" ? o.join(a.richText) : Wx(n, o.join(""), i ? r : a.html);
    if (i) return h;
    var f = Nx(e.header, "ordinal", t.useUTC), d = VV(n, t.renderMode).nameStyle, p = FV(n);
    return t.renderMode === "richText" ? HV(t, f, d) + a.richText + h : Wx(n, '<div style="' + d + ";" + p + ';">' + vn(f) + "</div>" + h, r);
  }
  function Tte(t, e, r, n) {
    var i = t.renderMode, a = e.noName, o = e.noValue, s = !e.markerType, l = e.name, u = t.useUTC, c = e.valueFormatter || t.valueFormatter || function(b) {
      return b = ae(b) ? b : [
        b
      ], oe(b, function(w, x) {
        return Nx(w, ae(d) ? d[x] : d, u);
      });
    };
    if (!(a && o)) {
      var h = s ? "" : t.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", i), f = a ? "" : Nx(l, "ordinal", u), d = e.valueType, p = o ? [] : c(e.value, e.dataIndex), v = !s || !a, g = !s && a, m = VV(n, i), y = m.nameStyle, _ = m.valueStyle;
      return i === "richText" ? (s ? "" : h) + (a ? "" : HV(t, f, y)) + (o ? "" : Mte(t, p, v, g, _)) : Wx(n, (s ? "" : h) + (a ? "" : Ate(f, !s, y)) + (o ? "" : Ite(p, v, g, _)), r);
    }
  }
  function cE(t, e, r, n, i, a) {
    if (t) {
      var o = GV(t), s = {
        useUTC: i,
        renderMode: r,
        orderMode: n,
        markupStyleCreator: e,
        valueFormatter: t.valueFormatter
      };
      return o(s, t, 0, a);
    }
  }
  function Cte(t) {
    return {
      html: xte[t],
      richText: wte[t]
    };
  }
  function Wx(t, e, r) {
    var n = '<div style="clear:both"></div>', i = "margin: " + r + "px 0 0", a = FV(t);
    return '<div style="' + i + ";" + a + ';">' + e + n + "</div>";
  }
  function Ate(t, e, r) {
    var n = e ? "margin-left:2px" : "";
    return '<span style="' + r + ";" + n + '">' + vn(t) + "</span>";
  }
  function Ite(t, e, r, n) {
    var i = r ? "10px" : "20px", a = e ? "float:right;margin-left:" + i : "";
    return t = ae(t) ? t : [
      t
    ], '<span style="' + a + ";" + n + '">' + oe(t, function(o) {
      return vn(o);
    }).join("&nbsp;&nbsp;") + "</span>";
  }
  function HV(t, e, r) {
    return t.markupStyleCreator.wrapRichTextStyle(e, r);
  }
  function Mte(t, e, r, n, i) {
    var a = [
      i
    ], o = n ? 10 : 20;
    return r && a.push({
      padding: [
        0,
        0,
        0,
        o
      ],
      align: "right"
    }), t.markupStyleCreator.wrapRichTextStyle(ae(e) ? e.join("  ") : e, a);
  }
  function UV(t, e) {
    var r = t.getData().getItemVisual(e, "style"), n = r[t.visualDrawType];
    return jl(n);
  }
  function YV(t, e) {
    var r = t.get("padding");
    return r ?? (e === "richText" ? [
      8,
      10
    ] : 10);
  }
  var F0 = function() {
    function t() {
      this.richTextStyles = {}, this._nextStyleNameId = s4();
    }
    return t.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, t.prototype.makeTooltipMarker = function(e, r, n) {
      var i = n === "richText" ? this._generateStyleName() : null, a = yee({
        color: r,
        type: e,
        renderMode: n,
        markerId: i
      });
      return me(a) ? a : (this.richTextStyles[i] = a.style, a.content);
    }, t.prototype.wrapRichTextStyle = function(e, r) {
      var n = {};
      ae(r) ? $(r, function(a) {
        return te(n, a);
      }) : te(n, r);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = n, "{" + i + "|" + e + "}";
    }, t;
  }();
  function qV(t) {
    var e = t.series, r = t.dataIndex, n = t.multipleSeries, i = e.getData(), a = i.mapDimensionsAll("defaultedTooltip"), o = a.length, s = e.getRawValue(r), l = ae(s), u = UV(e, r), c, h, f, d;
    if (o > 1 || l && !o) {
      var p = Dte(s, e, r, a, u);
      c = p.inlineValues, h = p.inlineValueTypes, f = p.blocks, d = p.inlineValues[0];
    } else if (o) {
      var v = i.getDimensionInfo(a[0]);
      d = c = _c(i, r, a[0]), h = v.type;
    } else d = c = l ? s[0] : s;
    var g = nT(e), m = g && e.name || "", y = i.getName(r), _ = n ? m : y;
    return $r("section", {
      header: m,
      noHeader: n || !g,
      sortParam: d,
      blocks: [
        $r("nameValue", {
          markerType: "item",
          markerColor: u,
          name: _,
          noName: !Vi(_),
          value: c,
          valueType: h,
          dataIndex: r
        })
      ].concat(f || [])
    });
  }
  function Dte(t, e, r, n, i) {
    var a = e.getData(), o = ka(t, function(h, f, d) {
      var p = a.getDimensionInfo(d);
      return h = h || p && p.tooltip !== false && p.displayName != null;
    }, false), s = [], l = [], u = [];
    n.length ? $(n, function(h) {
      c(_c(a, r, h), h);
    }) : $(t, c);
    function c(h, f) {
      var d = a.getDimensionInfo(f);
      !d || d.otherDims.tooltip === false || (o ? u.push($r("nameValue", {
        markerType: "subItem",
        markerColor: i,
        name: d.displayName,
        value: h,
        valueType: d.type
      })) : (s.push(h), l.push(d.type)));
    }
    return {
      inlineValues: s,
      inlineValueTypes: l,
      blocks: u
    };
  }
  var Po = _t();
  function Lp(t, e) {
    return t.getName(e) || t.getId(e);
  }
  var lg = "__universalTransitionEnabled", Xt = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r._selectedDataIndicesMap = {}, r;
    }
    return e.prototype.init = function(r, n, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = If({
        count: kte,
        reset: Pte
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(r, i);
      var a = Po(this).sourceManager = new zV(this);
      a.prepareSource();
      var o = this.getInitialData(r, i);
      fE(o, this), this.dataTask.context.data = o, Po(this).dataBeforeProcessed = o, hE(this), this._initSelectedMapFromData(o);
    }, e.prototype.mergeDefaultAndTheme = function(r, n) {
      var i = Zf(this), a = i ? Yc(r) : {}, o = this.subType;
      vt.hasClass(o) && (o += "Series"), je(r, n.getTheme().get(this.subType)), je(r, this.getDefaultOption()), Ul(r, "label", [
        "show"
      ]), this.fillDataTextStyle(r.data), i && ps(r, a, i);
    }, e.prototype.mergeOption = function(r, n) {
      r = je(this.option, r, true), this.fillDataTextStyle(r.data);
      var i = Zf(this);
      i && ps(this.option, r, i);
      var a = Po(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(r, n);
      fE(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, Po(this).dataBeforeProcessed = o, hE(this), this._initSelectedMapFromData(o);
    }, e.prototype.fillDataTextStyle = function(r) {
      if (r && !$n(r)) for (var n = [
        "show"
      ], i = 0; i < r.length; i++) r[i] && r[i].label && Ul(r[i], "label", n);
    }, e.prototype.getInitialData = function(r, n) {
    }, e.prototype.appendData = function(r) {
      var n = this.getRawData();
      n.appendData(r.data);
    }, e.prototype.getData = function(r) {
      var n = Hx(this);
      if (n) {
        var i = n.context.data;
        return r == null || !i.getLinkedData ? i : i.getLinkedData(r);
      } else return Po(this).data;
    }, e.prototype.getAllData = function() {
      var r = this.getData();
      return r && r.getLinkedDataAll ? r.getLinkedDataAll() : [
        {
          data: r
        }
      ];
    }, e.prototype.setData = function(r) {
      var n = Hx(this);
      if (n) {
        var i = n.context;
        i.outputData = r, n !== this.dataTask && (i.data = r);
      }
      Po(this).data = r;
    }, e.prototype.getEncode = function() {
      var r = this.get("encode", true);
      if (r) return Ce(r);
    }, e.prototype.getSourceManager = function() {
      return Po(this).sourceManager;
    }, e.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, e.prototype.getRawData = function() {
      return Po(this).dataBeforeProcessed;
    }, e.prototype.getColorBy = function() {
      var r = this.get("colorBy");
      return r || "series";
    }, e.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, e.prototype.getBaseAxis = function() {
      var r = this.coordinateSystem;
      return r && r.getBaseAxis && r.getBaseAxis();
    }, e.prototype.formatTooltip = function(r, n, i) {
      return qV({
        series: this,
        dataIndex: r,
        multipleSeries: n
      });
    }, e.prototype.isAnimationEnabled = function() {
      var r = this.ecModel;
      if (ct.node && !(r && r.ssr)) return false;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = false), !!n;
    }, e.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, e.prototype.getColorFromPalette = function(r, n, i) {
      var a = this.ecModel, o = AT.prototype.getColorFromPalette.call(this, r, n, i);
      return o || (o = a.getColorFromPalette(r, n, i)), o;
    }, e.prototype.coordDimToDataDim = function(r) {
      return this.getRawData().mapDimensionsAll(r);
    }, e.prototype.getProgressive = function() {
      return this.get("progressive");
    }, e.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, e.prototype.select = function(r, n) {
      this._innerSelect(this.getData(n), r);
    }, e.prototype.unselect = function(r, n) {
      var i = this.option.selectedMap;
      if (i) {
        var a = this.option.selectedMode, o = this.getData(n);
        if (a === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < r.length; s++) {
          var l = r[s], u = Lp(o, l);
          i[u] = false, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, e.prototype.toggleSelect = function(r, n) {
      for (var i = [], a = 0; a < r.length; a++) i[0] = r[a], this.isSelected(r[a], n) ? this.unselect(i, n) : this.select(i, n);
    }, e.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
      for (var r = this._selectedDataIndicesMap, n = gt(r), i = [], a = 0; a < n.length; a++) {
        var o = r[n[a]];
        o >= 0 && i.push(o);
      }
      return i;
    }, e.prototype.isSelected = function(r, n) {
      var i = this.option.selectedMap;
      if (!i) return false;
      var a = this.getData(n);
      return (i === "all" || i[Lp(a, r)]) && !a.getItemModel(r).get([
        "select",
        "disabled"
      ]);
    }, e.prototype.isUniversalTransitionEnabled = function() {
      if (this[lg]) return true;
      var r = this.option.universalTransition;
      return r ? r === true ? true : r && r.enabled : false;
    }, e.prototype._innerSelect = function(r, n) {
      var i, a, o = this.option, s = o.selectedMode, l = n.length;
      if (!(!s || !l)) {
        if (s === "series") o.selectedMap = "all";
        else if (s === "multiple") {
          Le(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, c = 0; c < l; c++) {
            var h = n[c], f = Lp(r, h);
            u[f] = true, this._selectedDataIndicesMap[f] = r.getRawIndex(h);
          }
        } else if (s === "single" || s === true) {
          var d = n[l - 1], f = Lp(r, d);
          o.selectedMap = (i = {}, i[f] = true, i), this._selectedDataIndicesMap = (a = {}, a[f] = r.getRawIndex(d), a);
        }
      }
    }, e.prototype._initSelectedMapFromData = function(r) {
      if (!this.option.selectedMap) {
        var n = [];
        r.hasItemOption && r.each(function(i) {
          var a = r.getRawDataItem(i);
          a && a.selected && n.push(i);
        }), n.length > 0 && this._innerSelect(r, n);
      }
    }, e.registerClass = function(r) {
      return vt.registerClass(r);
    }, e.protoInitialize = function() {
      var r = e.prototype;
      r.type = "series.__base__", r.seriesIndex = 0, r.ignoreStyleOnData = false, r.hasSymbolVisual = false, r.defaultSymbol = "circle", r.visualStyleAccessPath = "itemStyle", r.visualDrawType = "fill";
    }(), e;
  }(vt);
  yr(Xt, ay);
  yr(Xt, AT);
  g4(Xt, vt);
  function hE(t) {
    var e = t.name;
    nT(t) || (t.name = Ete(t) || e);
  }
  function Ete(t) {
    var e = t.getRawData(), r = e.mapDimensionsAll("seriesName"), n = [];
    return $(r, function(i) {
      var a = e.getDimensionInfo(i);
      a.displayName && n.push(a.displayName);
    }), n.join(" ");
  }
  function kte(t) {
    return t.model.getRawData().count();
  }
  function Pte(t) {
    var e = t.model;
    return e.setData(e.getRawData().cloneShallow()), Lte;
  }
  function Lte(t, e) {
    e.outputData && t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
  }
  function fE(t, e) {
    $(Vf(t.CHANGABLE_METHODS, t.DOWNSAMPLE_METHODS), function(r) {
      t.wrapMethod(r, Ye($te, e));
    });
  }
  function $te(t, e) {
    var r = Hx(t);
    return r && r.setOutputEnd((e || this).count()), e;
  }
  function Hx(t) {
    var e = (t.ecModel || {}).scheduler, r = e && e.getPipeline(t.uid);
    if (r) {
      var n = r.currentTask;
      if (n) {
        var i = n.agentStubMap;
        i && (n = i.get(t.uid));
      }
      return n;
    }
  }
  var tr = function() {
    function t() {
      this.group = new Be(), this.uid = Hc("viewComponent");
    }
    return t.prototype.init = function(e, r) {
    }, t.prototype.render = function(e, r, n, i) {
    }, t.prototype.dispose = function(e, r) {
    }, t.prototype.updateView = function(e, r, n, i) {
    }, t.prototype.updateLayout = function(e, r, n, i) {
    }, t.prototype.updateVisual = function(e, r, n, i) {
    }, t.prototype.toggleBlurSeries = function(e, r, n) {
    }, t.prototype.eachRendered = function(e) {
      var r = this.group;
      r && r.traverse(e);
    }, t;
  }();
  aT(tr);
  Vm(tr);
  function Xc() {
    var t = _t();
    return function(e) {
      var r = t(e), n = e.pipelineContext, i = !!r.large, a = !!r.progressiveRender, o = r.large = !!(n && n.large), s = r.progressiveRender = !!(n && n.progressiveRender);
      return (i !== o || a !== s) && "reset";
    };
  }
  var XV = _t(), Rte = Xc(), Ft = function() {
    function t() {
      this.group = new Be(), this.uid = Hc("viewChart"), this.renderTask = If({
        plan: Ote,
        reset: Nte
      }), this.renderTask.context = {
        view: this
      };
    }
    return t.prototype.init = function(e, r) {
    }, t.prototype.render = function(e, r, n, i) {
    }, t.prototype.highlight = function(e, r, n, i) {
      var a = e.getData(i && i.dataType);
      a && pE(a, i, "emphasis");
    }, t.prototype.downplay = function(e, r, n, i) {
      var a = e.getData(i && i.dataType);
      a && pE(a, i, "normal");
    }, t.prototype.remove = function(e, r) {
      this.group.removeAll();
    }, t.prototype.dispose = function(e, r) {
    }, t.prototype.updateView = function(e, r, n, i) {
      this.render(e, r, n, i);
    }, t.prototype.updateLayout = function(e, r, n, i) {
      this.render(e, r, n, i);
    }, t.prototype.updateVisual = function(e, r, n, i) {
      this.render(e, r, n, i);
    }, t.prototype.eachRendered = function(e) {
      bs(this.group, e);
    }, t.markUpdateMethod = function(e, r) {
      XV(e).updateMethod = r;
    }, t.protoInitialize = function() {
      var e = t.prototype;
      e.type = "chart";
    }(), t;
  }();
  function dE(t, e, r) {
    t && Xf(t) && (e === "emphasis" ? fo : po)(t, r);
  }
  function pE(t, e, r) {
    var n = Yl(t, e), i = e && e.highlightKey != null ? yJ(e.highlightKey) : null;
    n != null ? $(Ot(n), function(a) {
      dE(t.getItemGraphicEl(a), r, i);
    }) : t.eachItemGraphicEl(function(a) {
      dE(a, r, i);
    });
  }
  aT(Ft);
  Vm(Ft);
  function Ote(t) {
    return Rte(t.model);
  }
  function Nte(t) {
    var e = t.model, r = t.ecModel, n = t.api, i = t.payload, a = e.pipelineContext.progressiveRender, o = t.view, s = i && XV(i).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
    return l !== "render" && o[l](e, r, n, i), Bte[l];
  }
  var Bte = {
    incrementalPrepareRender: {
      progress: function(t, e) {
        e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload);
      }
    },
    render: {
      forceFirstProgress: true,
      progress: function(t, e) {
        e.view.render(e.model, e.ecModel, e.api, e.payload);
      }
    }
  }, Bg = "\0__throttleOriginMethod", vE = "\0__throttleRate", gE = "\0__throttleType";
  function PT(t, e, r) {
    var n, i = 0, a = 0, o = null, s, l, u, c;
    e = e || 0;
    function h() {
      a = (/* @__PURE__ */ new Date()).getTime(), o = null, t.apply(l, u || []);
    }
    var f = function() {
      for (var d = [], p = 0; p < arguments.length; p++) d[p] = arguments[p];
      n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
      var v = c || e, g = c || r;
      c = null, s = n - (g ? i : a) - v, clearTimeout(o), g ? o = setTimeout(h, v) : s >= 0 ? h() : o = setTimeout(h, -s), i = n;
    };
    return f.clear = function() {
      o && (clearTimeout(o), o = null);
    }, f.debounceNextCall = function(d) {
      c = d;
    }, f;
  }
  function jc(t, e, r, n) {
    var i = t[e];
    if (i) {
      var a = i[Bg] || i, o = i[gE], s = i[vE];
      if (s !== r || o !== n) {
        if (r == null || !n) return t[e] = a;
        i = t[e] = PT(a, r, n === "debounce"), i[Bg] = a, i[gE] = n, i[vE] = r;
      }
      return i;
    }
  }
  function Jf(t, e) {
    var r = t[e];
    r && r[Bg] && (r.clear && r.clear(), t[e] = r[Bg]);
  }
  var mE = _t(), yE = {
    itemStyle: ql(eV, true),
    lineStyle: ql(J4, true)
  }, zte = {
    lineStyle: "stroke",
    itemStyle: "fill"
  };
  function jV(t, e) {
    var r = t.visualStyleMapper || yE[e];
    return r || (console.warn("Unknown style type '" + e + "'."), yE.itemStyle);
  }
  function KV(t, e) {
    var r = t.visualDrawType || zte[e];
    return r || (console.warn("Unknown style type '" + e + "'."), "fill");
  }
  var Fte = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(t, e) {
      var r = t.getData(), n = t.visualStyleAccessPath || "itemStyle", i = t.getModel(n), a = jV(t, n), o = a(i), s = i.getShallow("decal");
      s && (r.setVisual("decal", s), s.dirty = true);
      var l = KV(t, n), u = o[l], c = De(u) ? u : null, h = o.fill === "auto" || o.stroke === "auto";
      if (!o[l] || c || h) {
        var f = t.getColorFromPalette(t.name, null, e.getSeriesCount());
        o[l] || (o[l] = f, r.setVisual("colorFromPalette", true)), o.fill = o.fill === "auto" || De(o.fill) ? f : o.fill, o.stroke = o.stroke === "auto" || De(o.stroke) ? f : o.stroke;
      }
      if (r.setVisual("style", o), r.setVisual("drawType", l), !e.isSeriesFiltered(t) && c) return r.setVisual("colorFromPalette", false), {
        dataEach: function(d, p) {
          var v = t.getDataParams(p), g = te({}, o);
          g[l] = c(v), d.setItemVisual(p, "style", g);
        }
      };
    }
  }, vh = new kt(), Vte = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(t, e) {
      if (!(t.ignoreStyleOnData || e.isSeriesFiltered(t))) {
        var r = t.getData(), n = t.visualStyleAccessPath || "itemStyle", i = jV(t, n), a = r.getVisual("drawType");
        return {
          dataEach: r.hasItemOption ? function(o, s) {
            var l = o.getRawDataItem(s);
            if (l && l[n]) {
              vh.option = l[n];
              var u = i(vh), c = o.ensureUniqueItemVisual(s, "style");
              te(c, u), vh.option.decal && (o.setItemVisual(s, "decal", vh.option.decal), vh.option.decal.dirty = true), a in u && o.setItemVisual(s, "colorFromPalette", false);
            }
          } : null
        };
      }
    }
  }, Gte = {
    performRawSeries: true,
    overallReset: function(t) {
      var e = Ce();
      t.eachSeries(function(r) {
        var n = r.getColorBy();
        if (!r.isColorBySeries()) {
          var i = r.type + "-" + n, a = e.get(i);
          a || (a = {}, e.set(i, a)), mE(r).scope = a;
        }
      }), t.eachSeries(function(r) {
        if (!(r.isColorBySeries() || t.isSeriesFiltered(r))) {
          var n = r.getRawData(), i = {}, a = r.getData(), o = mE(r).scope, s = r.visualStyleAccessPath || "itemStyle", l = KV(r, s);
          a.each(function(u) {
            var c = a.getRawIndex(u);
            i[c] = u;
          }), n.each(function(u) {
            var c = i[u], h = a.getItemVisual(c, "colorFromPalette");
            if (h) {
              var f = a.ensureUniqueItemVisual(c, "style"), d = n.getName(u) || u + "", p = n.count();
              f[l] = r.getColorFromPalette(d, o, p);
            }
          });
        }
      });
    }
  }, $p = Math.PI;
  function Wte(t, e) {
    e = e || {}, Ee(e, {
      text: "loading",
      textColor: "#000",
      fontSize: 12,
      fontWeight: "normal",
      fontStyle: "normal",
      fontFamily: "sans-serif",
      maskColor: "rgba(255, 255, 255, 0.8)",
      showSpinner: true,
      color: "#5470c6",
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    });
    var r = new Be(), n = new yt({
      style: {
        fill: e.maskColor
      },
      zlevel: e.zlevel,
      z: 1e4
    });
    r.add(n);
    var i = new bt({
      style: {
        text: e.text,
        fill: e.textColor,
        fontSize: e.fontSize,
        fontWeight: e.fontWeight,
        fontStyle: e.fontStyle,
        fontFamily: e.fontFamily
      },
      zlevel: e.zlevel,
      z: 10001
    }), a = new yt({
      style: {
        fill: "none"
      },
      textContent: i,
      textConfig: {
        position: "right",
        distance: 10
      },
      zlevel: e.zlevel,
      z: 10001
    });
    r.add(a);
    var o;
    return e.showSpinner && (o = new Xm({
      shape: {
        startAngle: -$p / 2,
        endAngle: -$p / 2 + 0.1,
        r: e.spinnerRadius
      },
      style: {
        stroke: e.color,
        lineCap: "round",
        lineWidth: e.lineWidth
      },
      zlevel: e.zlevel,
      z: 10001
    }), o.animateShape(true).when(1e3, {
      endAngle: $p * 3 / 2
    }).start("circularInOut"), o.animateShape(true).when(1e3, {
      startAngle: $p * 3 / 2
    }).delay(300).start("circularInOut"), r.add(o)), r.resize = function() {
      var s = i.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, u = (t.getWidth() - l * 2 - (e.showSpinner && s ? 10 : 0) - s) / 2 - (e.showSpinner && s ? 0 : 5 + s / 2) + (e.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = t.getHeight() / 2;
      e.showSpinner && o.setShape({
        cx: u,
        cy: c
      }), a.setShape({
        x: u - l,
        y: c - l,
        width: l * 2,
        height: l * 2
      }), n.setShape({
        x: 0,
        y: 0,
        width: t.getWidth(),
        height: t.getHeight()
      });
    }, r.resize(), r;
  }
  var ZV = function() {
    function t(e, r, n, i) {
      this._stageTaskMap = Ce(), this.ecInstance = e, this.api = r, n = this._dataProcessorHandlers = n.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i);
    }
    return t.prototype.restoreData = function(e, r) {
      e.restoreData(r), this._stageTaskMap.each(function(n) {
        var i = n.overallTask;
        i && i.dirty();
      });
    }, t.prototype.getPerformArgs = function(e, r) {
      if (e.__pipeline) {
        var n = this._pipelineMap.get(e.__pipeline.id), i = n.context, a = !r && n.progressiveEnabled && (!i || i.progressiveRender) && e.__idxInPipeline > n.blockIndex, o = a ? n.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, t.prototype.getPipeline = function(e) {
      return this._pipelineMap.get(e);
    }, t.prototype.updateStreamModes = function(e, r) {
      var n = this._pipelineMap.get(e.uid), i = e.getData(), a = i.count(), o = n.progressiveEnabled && r.incrementalPrepareRender && a >= n.threshold, s = e.get("large") && a >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? a : null;
      e.pipelineContext = n.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, t.prototype.restorePipelines = function(e) {
      var r = this, n = r._pipelineMap = Ce();
      e.eachSeries(function(i) {
        var a = i.getProgressive(), o = i.uid;
        n.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), r._pipe(i, i.dataTask);
      });
    }, t.prototype.prepareStageTasks = function() {
      var e = this._stageTaskMap, r = this.api.getModel(), n = this.api;
      $(this._allHandlers, function(i) {
        var a = e.get(i.uid) || e.set(i.uid, {}), o = "";
        bn(!(i.reset && i.overallReset), o), i.reset && this._createSeriesStageTask(i, a, r, n), i.overallReset && this._createOverallStageTask(i, a, r, n);
      }, this);
    }, t.prototype.prepareView = function(e, r, n, i) {
      var a = e.renderTask, o = a.context;
      o.model = r, o.ecModel = n, o.api = i, a.__block = !e.incrementalPrepareRender, this._pipe(r, a);
    }, t.prototype.performDataProcessorTasks = function(e, r) {
      this._performStageTasks(this._dataProcessorHandlers, e, r, {
        block: true
      });
    }, t.prototype.performVisualTasks = function(e, r, n) {
      this._performStageTasks(this._visualHandlers, e, r, n);
    }, t.prototype._performStageTasks = function(e, r, n, i) {
      i = i || {};
      var a = false, o = this;
      $(e, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid), h = c.seriesTaskMap, f = c.overallTask;
          if (f) {
            var d, p = f.agentStubMap;
            p.each(function(g) {
              s(i, g) && (g.dirty(), d = true);
            }), d && f.dirty(), o.updatePayload(f, n);
            var v = o.getPerformArgs(f, i.block);
            p.each(function(g) {
              g.perform(v);
            }), f.perform(v) && (a = true);
          } else h && h.each(function(g, m) {
            s(i, g) && g.dirty();
            var y = o.getPerformArgs(g, i.block);
            y.skip = !l.performRawSeries && r.isSeriesFiltered(g.context.model), o.updatePayload(g, n), g.perform(y) && (a = true);
          });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, t.prototype.performSeriesTasks = function(e) {
      var r;
      e.eachSeries(function(n) {
        r = n.dataTask.perform() || r;
      }), this.unfinished = r || this.unfinished;
    }, t.prototype.plan = function() {
      this._pipelineMap.each(function(e) {
        var r = e.tail;
        do {
          if (r.__block) {
            e.blockIndex = r.__idxInPipeline;
            break;
          }
          r = r.getUpstream();
        } while (r);
      });
    }, t.prototype.updatePayload = function(e, r) {
      r !== "remain" && (e.context.payload = r);
    }, t.prototype._createSeriesStageTask = function(e, r, n, i) {
      var a = this, o = r.seriesTaskMap, s = r.seriesTaskMap = Ce(), l = e.seriesType, u = e.getTargetSeries;
      e.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, i).each(c);
      function c(h) {
        var f = h.uid, d = s.set(f, o && o.get(f) || If({
          plan: Xte,
          reset: jte,
          count: Zte
        }));
        d.context = {
          model: h,
          ecModel: n,
          api: i,
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: a
        }, a._pipe(h, d);
      }
    }, t.prototype._createOverallStageTask = function(e, r, n, i) {
      var a = this, o = r.overallTask = r.overallTask || If({
        reset: Hte
      });
      o.context = {
        ecModel: n,
        api: i,
        overallReset: e.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = Ce(), u = e.seriesType, c = e.getTargetSeries, h = true, f = false, d = "";
      bn(!e.createOnAllSeries, d), u ? n.eachRawSeriesByType(u, p) : c ? c(n, i).each(p) : (h = false, $(n.getSeries(), p));
      function p(v) {
        var g = v.uid, m = l.set(g, s && s.get(g) || (f = true, If({
          reset: Ute,
          onDirty: qte
        })));
        m.context = {
          model: v,
          overallProgress: h
        }, m.agent = o, m.__block = h, a._pipe(v, m);
      }
      f && o.dirty();
    }, t.prototype._pipe = function(e, r) {
      var n = e.uid, i = this._pipelineMap.get(n);
      !i.head && (i.head = r), i.tail && i.tail.pipe(r), i.tail = r, r.__idxInPipeline = i.count++, r.__pipeline = i;
    }, t.wrapStageHandler = function(e, r) {
      return De(e) && (e = {
        overallReset: e,
        seriesType: Qte(e)
      }), e.uid = Hc("stageHandler"), r && (e.visualType = r), e;
    }, t;
  }();
  function Hte(t) {
    t.overallReset(t.ecModel, t.api, t.payload);
  }
  function Ute(t) {
    return t.overallProgress && Yte;
  }
  function Yte() {
    this.agent.dirty(), this.getDownstream().dirty();
  }
  function qte() {
    this.agent && this.agent.dirty();
  }
  function Xte(t) {
    return t.plan ? t.plan(t.model, t.ecModel, t.api, t.payload) : null;
  }
  function jte(t) {
    t.useClearVisual && t.data.clearAllVisual();
    var e = t.resetDefines = Ot(t.reset(t.model, t.ecModel, t.api, t.payload));
    return e.length > 1 ? oe(e, function(r, n) {
      return QV(n);
    }) : Kte;
  }
  var Kte = QV(0);
  function QV(t) {
    return function(e, r) {
      var n = r.data, i = r.resetDefines[t];
      if (i && i.dataEach) for (var a = e.start; a < e.end; a++) i.dataEach(n, a);
      else i && i.progress && i.progress(e, n);
    };
  }
  function Zte(t) {
    return t.data.count();
  }
  function Qte(t) {
    zg = null;
    try {
      t(ed, JV);
    } catch {
    }
    return zg;
  }
  var ed = {}, JV = {}, zg;
  e5(ed, IT);
  e5(JV, TV);
  ed.eachSeriesByType = ed.eachRawSeriesByType = function(t) {
    zg = t;
  };
  ed.eachComponent = function(t) {
    t.mainType === "series" && t.subType && (zg = t.subType);
  };
  function e5(t, e) {
    for (var r in e.prototype) t[r] = dr;
  }
  var _E = [
    "#37A2DA",
    "#32C5E9",
    "#67E0E3",
    "#9FE6B8",
    "#FFDB5C",
    "#ff9f7f",
    "#fb7293",
    "#E062AE",
    "#E690D1",
    "#e7bcf3",
    "#9d96f5",
    "#8378EA",
    "#96BFFF"
  ];
  const Jte = {
    color: _E,
    colorLayer: [
      [
        "#37A2DA",
        "#ffd85c",
        "#fd7b5f"
      ],
      [
        "#37A2DA",
        "#67E0E3",
        "#FFDB5C",
        "#ff9f7f",
        "#E062AE",
        "#9d96f5"
      ],
      [
        "#37A2DA",
        "#32C5E9",
        "#9FE6B8",
        "#FFDB5C",
        "#ff9f7f",
        "#fb7293",
        "#e7bcf3",
        "#8378EA",
        "#96BFFF"
      ],
      _E
    ]
  };
  var Qr = "#B9B8CE", bE = "#100C2A", Rp = function() {
    return {
      axisLine: {
        lineStyle: {
          color: Qr
        }
      },
      splitLine: {
        lineStyle: {
          color: "#484753"
        }
      },
      splitArea: {
        areaStyle: {
          color: [
            "rgba(255,255,255,0.02)",
            "rgba(255,255,255,0.05)"
          ]
        }
      },
      minorSplitLine: {
        lineStyle: {
          color: "#20203B"
        }
      }
    };
  }, xE = [
    "#4992ff",
    "#7cffb2",
    "#fddd60",
    "#ff6e76",
    "#58d9f9",
    "#05c091",
    "#ff8a45",
    "#8d48e3",
    "#dd79ff"
  ], t5 = {
    darkMode: true,
    color: xE,
    backgroundColor: bE,
    axisPointer: {
      lineStyle: {
        color: "#817f91"
      },
      crossStyle: {
        color: "#817f91"
      },
      label: {
        color: "#fff"
      }
    },
    legend: {
      textStyle: {
        color: Qr
      },
      pageTextStyle: {
        color: Qr
      }
    },
    textStyle: {
      color: Qr
    },
    title: {
      textStyle: {
        color: "#EEF1FA"
      },
      subtextStyle: {
        color: "#B9B8CE"
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: Qr
      }
    },
    dataZoom: {
      borderColor: "#71708A",
      textStyle: {
        color: Qr
      },
      brushStyle: {
        color: "rgba(135,163,206,0.3)"
      },
      handleStyle: {
        color: "#353450",
        borderColor: "#C5CBE3"
      },
      moveHandleStyle: {
        color: "#B0B6C3",
        opacity: 0.3
      },
      fillerColor: "rgba(135,163,206,0.2)",
      emphasis: {
        handleStyle: {
          borderColor: "#91B7F2",
          color: "#4D587D"
        },
        moveHandleStyle: {
          color: "#636D9A",
          opacity: 0.7
        }
      },
      dataBackground: {
        lineStyle: {
          color: "#71708A",
          width: 1
        },
        areaStyle: {
          color: "#71708A"
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#87A3CE"
        },
        areaStyle: {
          color: "#87A3CE"
        }
      }
    },
    visualMap: {
      textStyle: {
        color: Qr
      }
    },
    timeline: {
      lineStyle: {
        color: Qr
      },
      label: {
        color: Qr
      },
      controlStyle: {
        color: Qr,
        borderColor: Qr
      }
    },
    calendar: {
      itemStyle: {
        color: bE
      },
      dayLabel: {
        color: Qr
      },
      monthLabel: {
        color: Qr
      },
      yearLabel: {
        color: Qr
      }
    },
    timeAxis: Rp(),
    logAxis: Rp(),
    valueAxis: Rp(),
    categoryAxis: Rp(),
    line: {
      symbol: "circle"
    },
    graph: {
      color: xE
    },
    gauge: {
      title: {
        color: Qr
      },
      axisLine: {
        lineStyle: {
          color: [
            [
              1,
              "rgba(207,212,219,0.2)"
            ]
          ]
        }
      },
      axisLabel: {
        color: Qr
      },
      detail: {
        color: "#EEF1FA"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#f64e56",
        color0: "#54ea92",
        borderColor: "#f64e56",
        borderColor0: "#54ea92"
      }
    }
  };
  t5.categoryAxis.splitLine.show = false;
  var ere = function() {
    function t() {
    }
    return t.prototype.normalizeQuery = function(e) {
      var r = {}, n = {}, i = {};
      if (me(e)) {
        var a = Sa(e);
        r.mainType = a.main || null, r.subType = a.sub || null;
      } else {
        var o = [
          "Index",
          "Name",
          "Id"
        ], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        $(e, function(l, u) {
          for (var c = false, h = 0; h < o.length; h++) {
            var f = o[h], d = u.lastIndexOf(f);
            if (d > 0 && d === u.length - f.length) {
              var p = u.slice(0, d);
              p !== "data" && (r.mainType = p, r[f.toLowerCase()] = l, c = true);
            }
          }
          s.hasOwnProperty(u) && (n[u] = l, c = true), c || (i[u] = l);
        });
      }
      return {
        cptQuery: r,
        dataQuery: n,
        otherQuery: i
      };
    }, t.prototype.filter = function(e, r) {
      var n = this.eventInfo;
      if (!n) return true;
      var i = n.targetEl, a = n.packedEvent, o = n.model, s = n.view;
      if (!o || !s) return true;
      var l = r.cptQuery, u = r.dataQuery;
      return c(l, o, "mainType") && c(l, o, "subType") && c(l, o, "index", "componentIndex") && c(l, o, "name") && c(l, o, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(e, r.otherQuery, i, a));
      function c(h, f, d, p) {
        return h[d] == null || f[p || d] === h[d];
      }
    }, t.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, t;
  }(), Ux = [
    "symbol",
    "symbolSize",
    "symbolRotate",
    "symbolOffset"
  ], wE = Ux.concat([
    "symbolKeepAspect"
  ]), tre = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(t, e) {
      var r = t.getData();
      if (t.legendIcon && r.setVisual("legendIcon", t.legendIcon), !t.hasSymbolVisual) return;
      for (var n = {}, i = {}, a = false, o = 0; o < Ux.length; o++) {
        var s = Ux[o], l = t.get(s);
        De(l) ? (a = true, i[s] = l) : n[s] = l;
      }
      if (n.symbol = n.symbol || t.defaultSymbol, r.setVisual(te({
        legendIcon: t.legendIcon || n.symbol,
        symbolKeepAspect: t.get("symbolKeepAspect")
      }, n)), e.isSeriesFiltered(t)) return;
      var u = gt(i);
      function c(h, f) {
        for (var d = t.getRawValue(f), p = t.getDataParams(f), v = 0; v < u.length; v++) {
          var g = u[v];
          h.setItemVisual(f, g, i[g](d, p));
        }
      }
      return {
        dataEach: a ? c : null
      };
    }
  }, rre = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(t, e) {
      if (!t.hasSymbolVisual || e.isSeriesFiltered(t)) return;
      var r = t.getData();
      function n(i, a) {
        for (var o = i.getItemModel(a), s = 0; s < wE.length; s++) {
          var l = wE[s], u = o.getShallow(l, true);
          u != null && i.setItemVisual(a, l, u);
        }
      }
      return {
        dataEach: r.hasItemOption ? n : null
      };
    }
  };
  function LT(t, e, r) {
    switch (r) {
      case "color":
        var n = t.getItemVisual(e, "style");
        return n[t.getVisual("drawType")];
      case "opacity":
        return t.getItemVisual(e, "style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return t.getItemVisual(e, r);
    }
  }
  function Bd(t, e) {
    switch (e) {
      case "color":
        var r = t.getVisual("style");
        return r[t.getVisual("drawType")];
      case "opacity":
        return t.getVisual("style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return t.getVisual(e);
    }
  }
  function r5(t, e, r, n) {
    switch (r) {
      case "color":
        var i = t.ensureUniqueItemVisual(e, "style");
        i[t.getVisual("drawType")] = n, t.setItemVisual(e, "colorFromPalette", false);
        break;
      case "opacity":
        t.ensureUniqueItemVisual(e, "style").opacity = n;
        break;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        t.setItemVisual(e, r, n);
        break;
    }
  }
  function n5(t, e) {
    function r(n, i) {
      var a = [];
      return n.eachComponent({
        mainType: "series",
        subType: t,
        query: i
      }, function(o) {
        a.push(o.seriesIndex);
      }), a;
    }
    $([
      [
        t + "ToggleSelect",
        "toggleSelect"
      ],
      [
        t + "Select",
        "select"
      ],
      [
        t + "UnSelect",
        "unselect"
      ]
    ], function(n) {
      e(n[0], function(i, a, o) {
        i = te({}, i), o.dispatchAction(te(i, {
          type: n[1],
          seriesIndex: r(a, i)
        }));
      });
    });
  }
  function Iu(t, e, r, n, i) {
    var a = t + e;
    r.isSilent(a) || n.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(o) {
      for (var s = o.seriesIndex, l = o.option.selectedMap, u = i.selected, c = 0; c < u.length; c++) if (u[c].seriesIndex === s) {
        var h = o.getData(), f = Yl(h, i.fromActionPayload);
        r.trigger(a, {
          type: a,
          seriesId: o.id,
          name: ae(f) ? h.getName(f[0]) : h.getName(f),
          selected: me(l) ? l : te({}, l)
        });
      }
    });
  }
  function nre(t, e, r) {
    t.on("selectchanged", function(n) {
      var i = r.getModel();
      n.isFromClick ? (Iu("map", "selectchanged", e, i, n), Iu("pie", "selectchanged", e, i, n)) : n.fromAction === "select" ? (Iu("map", "selected", e, i, n), Iu("pie", "selected", e, i, n)) : n.fromAction === "unselect" && (Iu("map", "unselected", e, i, n), Iu("pie", "unselected", e, i, n));
    });
  }
  function Al(t, e, r) {
    for (var n; t && !(e(t) && (n = t, r)); ) t = t.__hostTarget || t.parent;
    return n;
  }
  var ire = Math.round(Math.random() * 9), are = typeof Object.defineProperty == "function", ore = function() {
    function t() {
      this._id = "__ec_inner_" + ire++;
    }
    return t.prototype.get = function(e) {
      return this._guard(e)[this._id];
    }, t.prototype.set = function(e, r) {
      var n = this._guard(e);
      return are ? Object.defineProperty(n, this._id, {
        value: r,
        enumerable: false,
        configurable: true
      }) : n[this._id] = r, this;
    }, t.prototype.delete = function(e) {
      return this.has(e) ? (delete this._guard(e)[this._id], true) : false;
    }, t.prototype.has = function(e) {
      return !!this._guard(e)[this._id];
    }, t.prototype._guard = function(e) {
      if (e !== Object(e)) throw TypeError("Value of WeakMap is not a non-null object.");
      return e;
    }, t;
  }(), sre = st.extend({
    type: "triangle",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(t, e) {
      var r = e.cx, n = e.cy, i = e.width / 2, a = e.height / 2;
      t.moveTo(r, n - a), t.lineTo(r + i, n + a), t.lineTo(r - i, n + a), t.closePath();
    }
  }), lre = st.extend({
    type: "diamond",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(t, e) {
      var r = e.cx, n = e.cy, i = e.width / 2, a = e.height / 2;
      t.moveTo(r, n - a), t.lineTo(r + i, n), t.lineTo(r, n + a), t.lineTo(r - i, n), t.closePath();
    }
  }), ure = st.extend({
    type: "pin",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(t, e) {
      var r = e.x, n = e.y, i = e.width / 5 * 3, a = Math.max(i, e.height), o = i / 2, s = o * o / (a - o), l = n - a + o + s, u = Math.asin(s / o), c = Math.cos(u) * o, h = Math.sin(u), f = Math.cos(u), d = o * 0.6, p = o * 0.7;
      t.moveTo(r - c, l + s), t.arc(r, l, o, Math.PI - u, Math.PI * 2 + u), t.bezierCurveTo(r + c - h * d, l + s + f * d, r, n - p, r, n), t.bezierCurveTo(r, n - p, r - c + h * d, l + s + f * d, r - c, l + s), t.closePath();
    }
  }), cre = st.extend({
    type: "arrow",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(t, e) {
      var r = e.height, n = e.width, i = e.x, a = e.y, o = n / 3 * 2;
      t.moveTo(i, a), t.lineTo(i + o, a + r), t.lineTo(i, a + r / 4 * 3), t.lineTo(i - o, a + r), t.lineTo(i, a), t.closePath();
    }
  }), hre = {
    line: Mr,
    rect: yt,
    roundRect: yt,
    square: yt,
    circle: wo,
    diamond: lre,
    pin: ure,
    arrow: cre,
    triangle: sre
  }, fre = {
    line: function(t, e, r, n, i) {
      i.x1 = t, i.y1 = e + n / 2, i.x2 = t + r, i.y2 = e + n / 2;
    },
    rect: function(t, e, r, n, i) {
      i.x = t, i.y = e, i.width = r, i.height = n;
    },
    roundRect: function(t, e, r, n, i) {
      i.x = t, i.y = e, i.width = r, i.height = n, i.r = Math.min(r, n) / 4;
    },
    square: function(t, e, r, n, i) {
      var a = Math.min(r, n);
      i.x = t, i.y = e, i.width = a, i.height = a;
    },
    circle: function(t, e, r, n, i) {
      i.cx = t + r / 2, i.cy = e + n / 2, i.r = Math.min(r, n) / 2;
    },
    diamond: function(t, e, r, n, i) {
      i.cx = t + r / 2, i.cy = e + n / 2, i.width = r, i.height = n;
    },
    pin: function(t, e, r, n, i) {
      i.x = t + r / 2, i.y = e + n / 2, i.width = r, i.height = n;
    },
    arrow: function(t, e, r, n, i) {
      i.x = t + r / 2, i.y = e + n / 2, i.width = r, i.height = n;
    },
    triangle: function(t, e, r, n, i) {
      i.cx = t + r / 2, i.cy = e + n / 2, i.width = r, i.height = n;
    }
  }, Fg = {};
  $(hre, function(t, e) {
    Fg[e] = new t();
  });
  var dre = st.extend({
    type: "symbol",
    shape: {
      symbolType: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function(t, e, r) {
      var n = Dg(t, e, r), i = this.shape;
      return i && i.symbolType === "pin" && e.position === "inside" && (n.y = r.y + r.height * 0.4), n;
    },
    buildPath: function(t, e, r) {
      var n = e.symbolType;
      if (n !== "none") {
        var i = Fg[n];
        i || (n = "rect", i = Fg[n]), fre[n](e.x, e.y, e.width, e.height, i.shape), i.buildPath(t, i.shape, r);
      }
    }
  });
  function pre(t, e) {
    if (this.type !== "image") {
      var r = this.style;
      this.__isEmptyBrush ? (r.stroke = t, r.fill = e || "#fff", r.lineWidth = 2) : this.shape.symbolType === "line" ? r.stroke = t : r.fill = t, this.markRedraw();
    }
  }
  function mr(t, e, r, n, i, a, o) {
    var s = t.indexOf("empty") === 0;
    s && (t = t.substr(5, 1).toLowerCase() + t.substr(6));
    var l;
    return t.indexOf("image://") === 0 ? l = U4(t.slice(8), new Ze(e, r, n, i), o ? "center" : "cover") : t.indexOf("path://") === 0 ? l = jm(t.slice(7), {}, new Ze(e, r, n, i), o ? "center" : "cover") : l = new dre({
      shape: {
        symbolType: t,
        x: e,
        y: r,
        width: n,
        height: i
      }
    }), l.__isEmptyBrush = s, l.setColor = pre, a && l.setColor(a), l;
  }
  function Kc(t) {
    return ae(t) || (t = [
      +t,
      +t
    ]), [
      t[0] || 0,
      t[1] || 0
    ];
  }
  function ou(t, e) {
    if (t != null) return ae(t) || (t = [
      t,
      t
    ]), [
      pe(t[0], e[0]) || 0,
      pe(We(t[1], t[0]), e[1]) || 0
    ];
  }
  function Il(t) {
    return isFinite(t);
  }
  function vre(t, e, r) {
    var n = e.x == null ? 0 : e.x, i = e.x2 == null ? 1 : e.x2, a = e.y == null ? 0 : e.y, o = e.y2 == null ? 0 : e.y2;
    e.global || (n = n * r.width + r.x, i = i * r.width + r.x, a = a * r.height + r.y, o = o * r.height + r.y), n = Il(n) ? n : 0, i = Il(i) ? i : 1, a = Il(a) ? a : 0, o = Il(o) ? o : 0;
    var s = t.createLinearGradient(n, a, i, o);
    return s;
  }
  function gre(t, e, r) {
    var n = r.width, i = r.height, a = Math.min(n, i), o = e.x == null ? 0.5 : e.x, s = e.y == null ? 0.5 : e.y, l = e.r == null ? 0.5 : e.r;
    e.global || (o = o * n + r.x, s = s * i + r.y, l = l * a), o = Il(o) ? o : 0.5, s = Il(s) ? s : 0.5, l = l >= 0 && Il(l) ? l : 0.5;
    var u = t.createRadialGradient(o, s, 0, o, s, l);
    return u;
  }
  function Yx(t, e, r) {
    for (var n = e.type === "radial" ? gre(t, e, r) : vre(t, e, r), i = e.colorStops, a = 0; a < i.length; a++) n.addColorStop(i[a].offset, i[a].color);
    return n;
  }
  function mre(t, e) {
    if (t === e || !t && !e) return false;
    if (!t || !e || t.length !== e.length) return true;
    for (var r = 0; r < t.length; r++) if (t[r] !== e[r]) return true;
    return false;
  }
  function Op(t) {
    return parseInt(t, 10);
  }
  function ic(t, e, r) {
    var n = [
      "width",
      "height"
    ][e], i = [
      "clientWidth",
      "clientHeight"
    ][e], a = [
      "paddingLeft",
      "paddingTop"
    ][e], o = [
      "paddingRight",
      "paddingBottom"
    ][e];
    if (r[n] != null && r[n] !== "auto") return parseFloat(r[n]);
    var s = document.defaultView.getComputedStyle(t);
    return (t[i] || Op(s[n]) || Op(t.style[n])) - (Op(s[a]) || 0) - (Op(s[o]) || 0) | 0;
  }
  function yre(t, e) {
    return !t || t === "solid" || !(e > 0) ? null : t === "dashed" ? [
      4 * e,
      2 * e
    ] : t === "dotted" ? [
      e
    ] : xt(t) ? [
      t
    ] : ae(t) ? t : null;
  }
  function $T(t) {
    var e = t.style, r = e.lineDash && e.lineWidth > 0 && yre(e.lineDash, e.lineWidth), n = e.lineDashOffset;
    if (r) {
      var i = e.strokeNoScale && t.getLineScale ? t.getLineScale() : 1;
      i && i !== 1 && (r = oe(r, function(a) {
        return a / i;
      }), n /= i);
    }
    return [
      r,
      n
    ];
  }
  var _re = new Ra(true);
  function Vg(t) {
    var e = t.stroke;
    return !(e == null || e === "none" || !(t.lineWidth > 0));
  }
  function SE(t) {
    return typeof t == "string" && t !== "none";
  }
  function Gg(t) {
    var e = t.fill;
    return e != null && e !== "none";
  }
  function TE(t, e) {
    if (e.fillOpacity != null && e.fillOpacity !== 1) {
      var r = t.globalAlpha;
      t.globalAlpha = e.fillOpacity * e.opacity, t.fill(), t.globalAlpha = r;
    } else t.fill();
  }
  function CE(t, e) {
    if (e.strokeOpacity != null && e.strokeOpacity !== 1) {
      var r = t.globalAlpha;
      t.globalAlpha = e.strokeOpacity * e.opacity, t.stroke(), t.globalAlpha = r;
    } else t.stroke();
  }
  function qx(t, e, r) {
    var n = oT(e.image, e.__image, r);
    if (Gm(n)) {
      var i = t.createPattern(n, e.repeat || "repeat");
      if (typeof DOMMatrix == "function" && i && i.setTransform) {
        var a = new DOMMatrix();
        a.translateSelf(e.x || 0, e.y || 0), a.rotateSelf(0, 0, (e.rotation || 0) * Xv), a.scaleSelf(e.scaleX || 1, e.scaleY || 1), i.setTransform(a);
      }
      return i;
    }
  }
  function bre(t, e, r, n) {
    var i, a = Vg(r), o = Gg(r), s = r.strokePercent, l = s < 1, u = !e.path;
    (!e.silent || l) && u && e.createPathProxy();
    var c = e.path || _re, h = e.__dirty;
    if (!n) {
      var f = r.fill, d = r.stroke, p = o && !!f.colorStops, v = a && !!d.colorStops, g = o && !!f.image, m = a && !!d.image, y = void 0, _ = void 0, b = void 0, w = void 0, x = void 0;
      (p || v) && (x = e.getBoundingRect()), p && (y = h ? Yx(t, f, x) : e.__canvasFillGradient, e.__canvasFillGradient = y), v && (_ = h ? Yx(t, d, x) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = _), g && (b = h || !e.__canvasFillPattern ? qx(t, f, e) : e.__canvasFillPattern, e.__canvasFillPattern = b), m && (w = h || !e.__canvasStrokePattern ? qx(t, d, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = b), p ? t.fillStyle = y : g && (b ? t.fillStyle = b : o = false), v ? t.strokeStyle = _ : m && (w ? t.strokeStyle = w : a = false);
    }
    var T = e.getGlobalScale();
    c.setScale(T[0], T[1], e.segmentIgnoreThreshold);
    var A, I;
    t.setLineDash && r.lineDash && (i = $T(e), A = i[0], I = i[1]);
    var M = true;
    (u || h & Kh) && (c.setDPR(t.dpr), l ? c.setContext(null) : (c.setContext(t), M = false), c.reset(), e.buildPath(c, e.shape, n), c.toStatic(), e.pathUpdated()), M && c.rebuildPath(t, l ? s : 1), A && (t.setLineDash(A), t.lineDashOffset = I), n || (r.strokeFirst ? (a && CE(t, r), o && TE(t, r)) : (o && TE(t, r), a && CE(t, r))), A && t.setLineDash([]);
  }
  function xre(t, e, r) {
    var n = e.__image = oT(r.image, e.__image, e, e.onload);
    if (!(!n || !Gm(n))) {
      var i = r.x || 0, a = r.y || 0, o = e.getWidth(), s = e.getHeight(), l = n.width / n.height;
      if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = n.width, s = n.height), r.sWidth && r.sHeight) {
        var u = r.sx || 0, c = r.sy || 0;
        t.drawImage(n, u, c, r.sWidth, r.sHeight, i, a, o, s);
      } else if (r.sx && r.sy) {
        var u = r.sx, c = r.sy, h = o - u, f = s - c;
        t.drawImage(n, u, c, h, f, i, a, o, s);
      } else t.drawImage(n, i, a, o, s);
    }
  }
  function wre(t, e, r) {
    var n, i = r.text;
    if (i != null && (i += ""), i) {
      t.font = r.font || cs, t.textAlign = r.textAlign, t.textBaseline = r.textBaseline;
      var a = void 0, o = void 0;
      t.setLineDash && r.lineDash && (n = $T(e), a = n[0], o = n[1]), a && (t.setLineDash(a), t.lineDashOffset = o), r.strokeFirst ? (Vg(r) && t.strokeText(i, r.x, r.y), Gg(r) && t.fillText(i, r.x, r.y)) : (Gg(r) && t.fillText(i, r.x, r.y), Vg(r) && t.strokeText(i, r.x, r.y)), a && t.setLineDash([]);
    }
  }
  var AE = [
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY"
  ], IE = [
    [
      "lineCap",
      "butt"
    ],
    [
      "lineJoin",
      "miter"
    ],
    [
      "miterLimit",
      10
    ]
  ];
  function i5(t, e, r, n, i) {
    var a = false;
    if (!n && (r = r || {}, e === r)) return false;
    if (n || e.opacity !== r.opacity) {
      kn(t, i), a = true;
      var o = Math.max(Math.min(e.opacity, 1), 0);
      t.globalAlpha = isNaN(o) ? Rl.opacity : o;
    }
    (n || e.blend !== r.blend) && (a || (kn(t, i), a = true), t.globalCompositeOperation = e.blend || Rl.blend);
    for (var s = 0; s < AE.length; s++) {
      var l = AE[s];
      (n || e[l] !== r[l]) && (a || (kn(t, i), a = true), t[l] = t.dpr * (e[l] || 0));
    }
    return (n || e.shadowColor !== r.shadowColor) && (a || (kn(t, i), a = true), t.shadowColor = e.shadowColor || Rl.shadowColor), a;
  }
  function ME(t, e, r, n, i) {
    var a = td(e, i.inHover), o = n ? null : r && td(r, i.inHover) || {};
    if (a === o) return false;
    var s = i5(t, a, o, n, i);
    if ((n || a.fill !== o.fill) && (s || (kn(t, i), s = true), SE(a.fill) && (t.fillStyle = a.fill)), (n || a.stroke !== o.stroke) && (s || (kn(t, i), s = true), SE(a.stroke) && (t.strokeStyle = a.stroke)), (n || a.opacity !== o.opacity) && (s || (kn(t, i), s = true), t.globalAlpha = a.opacity == null ? 1 : a.opacity), e.hasStroke()) {
      var l = a.lineWidth, u = l / (a.strokeNoScale && e.getLineScale ? e.getLineScale() : 1);
      t.lineWidth !== u && (s || (kn(t, i), s = true), t.lineWidth = u);
    }
    for (var c = 0; c < IE.length; c++) {
      var h = IE[c], f = h[0];
      (n || a[f] !== o[f]) && (s || (kn(t, i), s = true), t[f] = a[f] || h[1]);
    }
    return s;
  }
  function Sre(t, e, r, n, i) {
    return i5(t, td(e, i.inHover), r && td(r, i.inHover), n, i);
  }
  function a5(t, e) {
    var r = e.transform, n = t.dpr || 1;
    r ? t.setTransform(n * r[0], n * r[1], n * r[2], n * r[3], n * r[4], n * r[5]) : t.setTransform(n, 0, 0, n, 0, 0);
  }
  function Tre(t, e, r) {
    for (var n = false, i = 0; i < t.length; i++) {
      var a = t[i];
      n = n || a.isZeroArea(), a5(e, a), e.beginPath(), a.buildPath(e, a.shape), e.clip();
    }
    r.allClipped = n;
  }
  function Cre(t, e) {
    return t && e ? t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || t[4] !== e[4] || t[5] !== e[5] : !(!t && !e);
  }
  var DE = 1, EE = 2, kE = 3, PE = 4;
  function Are(t) {
    var e = Gg(t), r = Vg(t);
    return !(t.lineDash || !(+e ^ +r) || e && typeof t.fill != "string" || r && typeof t.stroke != "string" || t.strokePercent < 1 || t.strokeOpacity < 1 || t.fillOpacity < 1);
  }
  function kn(t, e) {
    e.batchFill && t.fill(), e.batchStroke && t.stroke(), e.batchFill = "", e.batchStroke = "";
  }
  function td(t, e) {
    return e && t.__hoverStyle || t.style;
  }
  function o5(t, e) {
    Ml(t, e, {
      inHover: false,
      viewWidth: 0,
      viewHeight: 0
    }, true);
  }
  function Ml(t, e, r, n) {
    var i = e.transform;
    if (!e.shouldBePainted(r.viewWidth, r.viewHeight, false, false)) {
      e.__dirty &= -2, e.__isRendered = false;
      return;
    }
    var a = e.__clipPaths, o = r.prevElClipPaths, s = false, l = false;
    if ((!o || mre(a, o)) && (o && o.length && (kn(t, r), t.restore(), l = s = true, r.prevElClipPaths = null, r.allClipped = false, r.prevEl = null), a && a.length && (kn(t, r), t.save(), Tre(a, t, r), s = true), r.prevElClipPaths = a), r.allClipped) {
      e.__isRendered = false;
      return;
    }
    e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
    var u = r.prevEl;
    u || (l = s = true);
    var c = e instanceof st && e.autoBatch && Are(e.style);
    s || Cre(i, u.transform) ? (kn(t, r), a5(t, e)) : c || kn(t, r);
    var h = td(e, r.inHover);
    e instanceof st ? (r.lastDrawType !== DE && (l = true, r.lastDrawType = DE), ME(t, e, u, l, r), (!c || !r.batchFill && !r.batchStroke) && t.beginPath(), bre(t, e, h, c), c && (r.batchFill = h.fill || "", r.batchStroke = h.stroke || "")) : e instanceof mc ? (r.lastDrawType !== kE && (l = true, r.lastDrawType = kE), ME(t, e, u, l, r), wre(t, e, h)) : e instanceof Gr ? (r.lastDrawType !== EE && (l = true, r.lastDrawType = EE), Sre(t, e, u, l, r), xre(t, e, h)) : e.getTemporalDisplayables && (r.lastDrawType !== PE && (l = true, r.lastDrawType = PE), Ire(t, e, r)), c && n && kn(t, r), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), r.prevEl = e, e.__dirty = 0, e.__isRendered = true;
  }
  function Ire(t, e, r) {
    var n = e.getDisplayables(), i = e.getTemporalDisplayables();
    t.save();
    var a = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: false,
      viewWidth: r.viewWidth,
      viewHeight: r.viewHeight,
      inHover: r.inHover
    }, o, s;
    for (o = e.getCursor(), s = n.length; o < s; o++) {
      var l = n[o];
      l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Ml(t, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
    }
    for (var u = 0, c = i.length; u < c; u++) {
      var l = i[u];
      l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Ml(t, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
    }
    e.clearTemporalDisplayables(), e.notClear = true, t.restore();
  }
  var V0 = new ore(), LE = new Md(100), $E = [
    "symbol",
    "symbolSize",
    "symbolKeepAspect",
    "color",
    "backgroundColor",
    "dashArrayX",
    "dashArrayY",
    "maxTileWidth",
    "maxTileHeight"
  ];
  function bc(t, e) {
    if (t === "none") return null;
    var r = e.getDevicePixelRatio(), n = e.getZr(), i = n.painter.type === "svg";
    t.dirty && V0.delete(t);
    var a = V0.get(t);
    if (a) return a;
    var o = Ee(t, {
      symbol: "rect",
      symbolSize: 1,
      symbolKeepAspect: true,
      color: "rgba(0, 0, 0, 0.2)",
      backgroundColor: null,
      dashArrayX: 5,
      dashArrayY: 5,
      rotation: 0,
      maxTileWidth: 512,
      maxTileHeight: 512
    });
    o.backgroundColor === "none" && (o.backgroundColor = null);
    var s = {
      repeat: "repeat"
    };
    return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / r, V0.set(t, s), t.dirty = false, s;
    function l(u) {
      for (var c = [
        r
      ], h = true, f = 0; f < $E.length; ++f) {
        var d = o[$E[f]];
        if (d != null && !ae(d) && !me(d) && !xt(d) && typeof d != "boolean") {
          h = false;
          break;
        }
        c.push(d);
      }
      var p;
      if (h) {
        p = c.join(",") + (i ? "-svg" : "");
        var v = LE.get(p);
        v && (i ? u.svgElement = v : u.image = v);
      }
      var g = l5(o.dashArrayX), m = Mre(o.dashArrayY), y = s5(o.symbol), _ = Dre(g), b = u5(m), w = !i && hs.createCanvas(), x = i && {
        tag: "g",
        attrs: {},
        key: "dcl",
        children: []
      }, T = I(), A;
      w && (w.width = T.width * r, w.height = T.height * r, A = w.getContext("2d")), M(), h && LE.put(p, w || x), u.image = w, u.svgElement = x, u.svgWidth = T.width, u.svgHeight = T.height;
      function I() {
        for (var k = 1, B = 0, L = _.length; B < L; ++B) k = ZM(k, _[B]);
        for (var z = 1, B = 0, L = y.length; B < L; ++B) z = ZM(z, y[B].length);
        k *= z;
        var F = b * _.length * y.length;
        return {
          width: Math.max(1, Math.min(k, o.maxTileWidth)),
          height: Math.max(1, Math.min(F, o.maxTileHeight))
        };
      }
      function M() {
        A && (A.clearRect(0, 0, w.width, w.height), o.backgroundColor && (A.fillStyle = o.backgroundColor, A.fillRect(0, 0, w.width, w.height)));
        for (var k = 0, B = 0; B < m.length; ++B) k += m[B];
        if (k <= 0) return;
        for (var L = -b, z = 0, F = 0, E = 0; L < T.height; ) {
          if (z % 2 === 0) {
            for (var O = F / 2 % y.length, N = 0, V = 0, H = 0; N < T.width * 2; ) {
              for (var G = 0, B = 0; B < g[E].length; ++B) G += g[E][B];
              if (G <= 0) break;
              if (V % 2 === 0) {
                var Y = (1 - o.symbolSize) * 0.5, U = N + g[E][V] * Y, Z = L + m[z] * Y, ee = g[E][V] * o.symbolSize, we = m[z] * o.symbolSize, Te = H / 2 % y[O].length;
                le(U, Z, ee, we, y[O][Te]);
              }
              N += g[E][V], ++H, ++V, V === g[E].length && (V = 0);
            }
            ++E, E === g.length && (E = 0);
          }
          L += m[z], ++F, ++z, z === m.length && (z = 0);
        }
        function le(ue, ye, ve, Se, Qe) {
          var Xe = i ? 1 : r, be = mr(Qe, ue * Xe, ye * Xe, ve * Xe, Se * Xe, o.color, o.symbolKeepAspect);
          if (i) {
            var ke = n.painter.renderOneToVNode(be);
            ke && x.children.push(ke);
          } else o5(A, be);
        }
      }
    }
  }
  function s5(t) {
    if (!t || t.length === 0) return [
      [
        "rect"
      ]
    ];
    if (me(t)) return [
      [
        t
      ]
    ];
    for (var e = true, r = 0; r < t.length; ++r) if (!me(t[r])) {
      e = false;
      break;
    }
    if (e) return s5([
      t
    ]);
    for (var n = [], r = 0; r < t.length; ++r) me(t[r]) ? n.push([
      t[r]
    ]) : n.push(t[r]);
    return n;
  }
  function l5(t) {
    if (!t || t.length === 0) return [
      [
        0,
        0
      ]
    ];
    if (xt(t)) {
      var e = Math.ceil(t);
      return [
        [
          e,
          e
        ]
      ];
    }
    for (var r = true, n = 0; n < t.length; ++n) if (!xt(t[n])) {
      r = false;
      break;
    }
    if (r) return l5([
      t
    ]);
    for (var i = [], n = 0; n < t.length; ++n) if (xt(t[n])) {
      var e = Math.ceil(t[n]);
      i.push([
        e,
        e
      ]);
    } else {
      var e = oe(t[n], function(s) {
        return Math.ceil(s);
      });
      e.length % 2 === 1 ? i.push(e.concat(e)) : i.push(e);
    }
    return i;
  }
  function Mre(t) {
    if (!t || typeof t == "object" && t.length === 0) return [
      0,
      0
    ];
    if (xt(t)) {
      var e = Math.ceil(t);
      return [
        e,
        e
      ];
    }
    var r = oe(t, function(n) {
      return Math.ceil(n);
    });
    return t.length % 2 ? r.concat(r) : r;
  }
  function Dre(t) {
    return oe(t, function(e) {
      return u5(e);
    });
  }
  function u5(t) {
    for (var e = 0, r = 0; r < t.length; ++r) e += t[r];
    return t.length % 2 === 1 ? e * 2 : e;
  }
  function Ere(t, e) {
    t.eachRawSeries(function(r) {
      if (!t.isSeriesFiltered(r)) {
        var n = r.getData();
        n.hasItemVisual() && n.each(function(o) {
          var s = n.getItemVisual(o, "decal");
          if (s) {
            var l = n.ensureUniqueItemVisual(o, "style");
            l.decal = bc(s, e);
          }
        });
        var i = n.getVisual("decal");
        if (i) {
          var a = n.getVisual("style");
          a.decal = bc(i, e);
        }
      }
    });
  }
  var Bi = new xi(), c5 = {};
  function kre(t, e) {
    c5[t] = e;
  }
  function Pre(t) {
    return c5[t];
  }
  var Lre = 1, $re = 800, Rre = 900, Ore = 1e3, Nre = 2e3, Bre = 5e3, h5 = 1e3, zre = 1100, RT = 2e3, f5 = 3e3, Fre = 4e3, sy = 4500, Vre = 4600, Gre = 5e3, Wre = 6e3, d5 = 7e3, Hre = {
    PROCESSOR: {
      FILTER: Ore,
      SERIES_FILTER: $re,
      STATISTIC: Bre
    },
    VISUAL: {
      LAYOUT: h5,
      PROGRESSIVE_LAYOUT: zre,
      GLOBAL: RT,
      CHART: f5,
      POST_CHART_LAYOUT: Vre,
      COMPONENT: Fre,
      BRUSH: Gre,
      CHART_ITEM: sy,
      ARIA: Wre,
      DECAL: d5
    }
  }, Zr = "__flagInMainProcess", An = "__pendingUpdate", G0 = "__needsUpdateStatus", RE = /^[a-zA-Z0-9_]+$/, W0 = "__connectUpdateStatus", OE = 0, Ure = 1, Yre = 2;
  function p5(t) {
    return function() {
      for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r];
      if (this.isDisposed()) {
        this.id;
        return;
      }
      return g5(this, t, e);
    };
  }
  function v5(t) {
    return function() {
      for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r];
      return g5(this, t, e);
    };
  }
  function g5(t, e, r) {
    return r[0] = r[0] && r[0].toLowerCase(), xi.prototype[e].apply(t, r);
  }
  var m5 = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  }(xi), y5 = m5.prototype;
  y5.on = v5("on");
  y5.off = v5("off");
  var Mu, H0, Np, Lo, U0, Y0, q0, gh, mh, NE, BE, X0, zE, Bp, FE, _5, ti, VE, b5 = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this, new ere()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, me(n) && (n = x5[n]), a._dom = r;
      var o = "canvas", s = "auto", l = false;
      i.ssr && FZ(function(f) {
        var d = Ge(f), p = d.dataIndex;
        if (p != null) {
          var v = Ce();
          return v.set("series_index", d.seriesIndex), v.set("data_index", p), d.ssrType && v.set("ssr_type", d.ssrType), v;
        }
      });
      var u = a._zr = XM(r, {
        renderer: i.renderer || o,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: We(i.useDirtyRect, l),
        useCoarsePointer: We(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      a._ssr = i.ssr, a._throttledZrFlush = PT(_e(u.flush, u), 17), n = Oe(n), n && AV(n, true), a._theme = n, a._locale = hee(i.locale || tV), a._coordSysMgr = new Nd();
      var c = a._api = FE(a);
      function h(f, d) {
        return f.__prio - d.__prio;
      }
      return Zv(Hg, h), Zv(Xx, h), a._scheduler = new ZV(a, c, Xx, Hg), a._messageCenter = new m5(), a._initEvents(), a.resize = _e(a.resize, a), u.animation.on("frame", a._onframe, a), NE(u, a), BE(u, a), wg(a), a;
    }
    return e.prototype._onframe = function() {
      if (!this._disposed) {
        VE(this);
        var r = this._scheduler;
        if (this[An]) {
          var n = this[An].silent;
          this[Zr] = true;
          try {
            Mu(this), Lo.update.call(this, null, this[An].updateParams);
          } catch (l) {
            throw this[Zr] = false, this[An] = null, l;
          }
          this._zr.flush(), this[Zr] = false, this[An] = null, gh.call(this, n), mh.call(this, n);
        } else if (r.unfinished) {
          var i = Lre, a = this._model, o = this._api;
          r.unfinished = false;
          do {
            var s = +/* @__PURE__ */ new Date();
            r.performSeriesTasks(a), r.performDataProcessorTasks(a), Y0(this, a), r.performVisualTasks(a), Bp(this, this._model, o, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && r.unfinished);
          r.unfinished || this._zr.flush();
        }
      }
    }, e.prototype.getDom = function() {
      return this._dom;
    }, e.prototype.getId = function() {
      return this.id;
    }, e.prototype.getZr = function() {
      return this._zr;
    }, e.prototype.isSSR = function() {
      return this._ssr;
    }, e.prototype.setOption = function(r, n, i) {
      if (!this[Zr]) {
        if (this._disposed) {
          this.id;
          return;
        }
        var a, o, s;
        if (Le(n) && (i = n.lazyUpdate, a = n.silent, o = n.replaceMerge, s = n.transition, n = n.notMerge), this[Zr] = true, !this._model || n) {
          var l = new Oee(this._api), u = this._theme, c = this._model = new IT();
          c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
        }
        this._model.setOption(r, {
          replaceMerge: o
        }, jx);
        var h = {
          seriesTransition: s,
          optionChanged: true
        };
        if (i) this[An] = {
          silent: a,
          updateParams: h
        }, this[Zr] = false, this.getZr().wakeUp();
        else {
          try {
            Mu(this), Lo.update.call(this, null, h);
          } catch (f) {
            throw this[An] = null, this[Zr] = false, f;
          }
          this._ssr || this._zr.flush(), this[An] = null, this[Zr] = false, gh.call(this, a), mh.call(this, a);
        }
      }
    }, e.prototype.setTheme = function() {
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, e.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, e.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, e.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || ct.hasGlobalWindow && window.devicePixelRatio || 1;
    }, e.prototype.getRenderedCanvas = function(r) {
      return this.renderToCanvas(r);
    }, e.prototype.renderToCanvas = function(r) {
      r = r || {};
      var n = this._zr.painter;
      return n.getRenderedCanvas({
        backgroundColor: r.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: r.pixelRatio || this.getDevicePixelRatio()
      });
    }, e.prototype.renderToSVGString = function(r) {
      r = r || {};
      var n = this._zr.painter;
      return n.renderToString({
        useViewBox: r.useViewBox
      });
    }, e.prototype.getSvgDataURL = function() {
      if (ct.svgSupported) {
        var r = this._zr, n = r.storage.getDisplayList();
        return $(n, function(i) {
          i.stopAnimation(null, true);
        }), r.painter.toDataURL();
      }
    }, e.prototype.getDataURL = function(r) {
      if (this._disposed) {
        this.id;
        return;
      }
      r = r || {};
      var n = r.excludeComponents, i = this._model, a = [], o = this;
      $(n, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = o._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = true);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(r).toDataURL("image/" + (r && r.type || "png"));
      return $(a, function(l) {
        l.group.ignore = false;
      }), s;
    }, e.prototype.getConnectedDataURL = function(r) {
      if (this._disposed) {
        this.id;
        return;
      }
      var n = r.type === "svg", i = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (GE[i]) {
        var l = s, u = s, c = -s, h = -s, f = [], d = r && r.pixelRatio || this.getDevicePixelRatio();
        $(Df, function(_, b) {
          if (_.group === i) {
            var w = n ? _.getZr().painter.getSvgDom().innerHTML : _.renderToCanvas(Oe(r)), x = _.getDom().getBoundingClientRect();
            l = a(x.left, l), u = a(x.top, u), c = o(x.right, c), h = o(x.bottom, h), f.push({
              dom: w,
              left: x.left,
              top: x.top
            });
          }
        }), l *= d, u *= d, c *= d, h *= d;
        var p = c - l, v = h - u, g = hs.createCanvas(), m = XM(g, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: p,
          height: v
        }), n) {
          var y = "";
          return $(f, function(_) {
            var b = _.left - l, w = _.top - u;
            y += '<g transform="translate(' + b + "," + w + ')">' + _.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, r.connectedBackgroundColor && m.painter.setBackgroundColor(r.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else return r.connectedBackgroundColor && m.add(new yt({
          shape: {
            x: 0,
            y: 0,
            width: p,
            height: v
          },
          style: {
            fill: r.connectedBackgroundColor
          }
        })), $(f, function(_) {
          var b = new Gr({
            style: {
              x: _.left * d - l,
              y: _.top * d - u,
              image: _.dom
            }
          });
          m.add(b);
        }), m.refreshImmediately(), g.toDataURL("image/" + (r && r.type || "png"));
      } else return this.getDataURL(r);
    }, e.prototype.convertToPixel = function(r, n) {
      return U0(this, "convertToPixel", r, n);
    }, e.prototype.convertFromPixel = function(r, n) {
      return U0(this, "convertFromPixel", r, n);
    }, e.prototype.containPixel = function(r, n) {
      if (this._disposed) {
        this.id;
        return;
      }
      var i = this._model, a, o = wf(i, r);
      return $(o, function(s, l) {
        l.indexOf("Models") >= 0 && $(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint) a = a || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint && (a = a || h.containPoint(n, u));
          }
        }, this);
      }, this), !!a;
    }, e.prototype.getVisual = function(r, n) {
      var i = this._model, a = wf(i, r, {
        defaultMainType: "series"
      }), o = a.seriesModel, s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? LT(s, l, n) : Bd(s, n);
    }, e.prototype.getViewOfComponentModel = function(r) {
      return this._componentsMap[r.__viewId];
    }, e.prototype.getViewOfSeriesModel = function(r) {
      return this._chartsMap[r.__viewId];
    }, e.prototype._initEvents = function() {
      var r = this;
      $(qre, function(n) {
        var i = function(a) {
          var o = r.getModel(), s = a.target, l, u = n === "globalout";
          if (u ? l = {} : s && Al(s, function(p) {
            var v = Ge(p);
            if (v && v.dataIndex != null) {
              var g = v.dataModel || o.getSeriesByIndex(v.seriesIndex);
              return l = g && g.getDataParams(v.dataIndex, v.dataType, s) || {}, true;
            } else if (v.eventData) return l = te({}, v.eventData), true;
          }, true), l) {
            var c = l.componentType, h = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", h = l.seriesIndex);
            var f = c && h != null && o.getComponent(c, h), d = f && r[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            l.event = a, l.type = n, r._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: f,
              view: d
            }, r.trigger(n, l);
          }
        };
        i.zrEventfulCallAtLast = true, r._zr.on(n, i, r);
      }), $(Mf, function(n, i) {
        r._messageCenter.on(i, function(a) {
          this.trigger(i, a);
        }, r);
      }), $([
        "selectchanged"
      ], function(n) {
        r._messageCenter.on(n, function(i) {
          this.trigger(n, i);
        }, r);
      }), nre(this._messageCenter, this, this._api);
    }, e.prototype.isDisposed = function() {
      return this._disposed;
    }, e.prototype.clear = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this.setOption({
        series: []
      }, true);
    }, e.prototype.dispose = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._disposed = true;
      var r = this.getDom();
      r && d4(this.getDom(), NT, "");
      var n = this, i = n._api, a = n._model;
      $(n._componentsViews, function(o) {
        o.dispose(a, i);
      }), $(n._chartsViews, function(o) {
        o.dispose(a, i);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete Df[n.id];
    }, e.prototype.resize = function(r) {
      if (!this[Zr]) {
        if (this._disposed) {
          this.id;
          return;
        }
        this._zr.resize(r);
        var n = this._model;
        if (this._loadingFX && this._loadingFX.resize(), !!n) {
          var i = n.resetOption("media"), a = r && r.silent;
          this[An] && (a == null && (a = this[An].silent), i = true, this[An] = null), this[Zr] = true;
          try {
            i && Mu(this), Lo.update.call(this, {
              type: "resize",
              animation: te({
                duration: 0
              }, r && r.animation)
            });
          } catch (o) {
            throw this[Zr] = false, o;
          }
          this[Zr] = false, gh.call(this, a), mh.call(this, a);
        }
      }
    }, e.prototype.showLoading = function(r, n) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (Le(r) && (n = r, r = ""), r = r || "default", this.hideLoading(), !!Kx[r]) {
        var i = Kx[r](this._api, n), a = this._zr;
        this._loadingFX = i, a.add(i);
      }
    }, e.prototype.hideLoading = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, e.prototype.makeActionFromEvent = function(r) {
      var n = te({}, r);
      return n.type = Mf[r.type], n;
    }, e.prototype.dispatchAction = function(r, n) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (Le(n) || (n = {
        silent: !!n
      }), !!Wg[r.type] && this._model) {
        if (this[Zr]) {
          this._pendingActions.push(r);
          return;
        }
        var i = n.silent;
        q0.call(this, r, i);
        var a = n.flush;
        a ? this._zr.flush() : a !== false && ct.browser.weChat && this._throttledZrFlush(), gh.call(this, i), mh.call(this, i);
      }
    }, e.prototype.updateLabelLayout = function() {
      Bi.trigger("series:layoutlabels", this._model, this._api, {
        updatedSeries: []
      });
    }, e.prototype.appendData = function(r) {
      if (this._disposed) {
        this.id;
        return;
      }
      var n = r.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(n);
      a.appendData(r), this._scheduler.unfinished = true, this.getZr().wakeUp();
    }, e.internalField = function() {
      Mu = function(h) {
        var f = h._scheduler;
        f.restorePipelines(h._model), f.prepareStageTasks(), H0(h, true), H0(h, false), f.plan();
      }, H0 = function(h, f) {
        for (var d = h._model, p = h._scheduler, v = f ? h._componentsViews : h._chartsViews, g = f ? h._componentsMap : h._chartsMap, m = h._zr, y = h._api, _ = 0; _ < v.length; _++) v[_].__alive = false;
        f ? d.eachComponent(function(x, T) {
          x !== "series" && b(T);
        }) : d.eachSeries(b);
        function b(x) {
          var T = x.__requireNewView;
          x.__requireNewView = false;
          var A = "_ec_" + x.id + "_" + x.type, I = !T && g[A];
          if (!I) {
            var M = Sa(x.type), k = f ? tr.getClass(M.main, M.sub) : Ft.getClass(M.sub);
            I = new k(), I.init(d, y), g[A] = I, v.push(I), m.add(I.group);
          }
          x.__viewId = I.__id = A, I.__alive = true, I.__model = x, I.group.__ecComponentInfo = {
            mainType: x.mainType,
            index: x.componentIndex
          }, !f && p.prepareView(I, x, d, y);
        }
        for (var _ = 0; _ < v.length; ) {
          var w = v[_];
          w.__alive ? _++ : (!f && w.renderTask.dispose(), m.remove(w.group), w.dispose(d, y), v.splice(_, 1), g[w.__id] === w && delete g[w.__id], w.__id = w.group.__ecComponentInfo = null);
        }
      }, Np = function(h, f, d, p, v) {
        var g = h._model;
        if (g.setUpdatePayload(d), !p) {
          $([].concat(h._componentsViews).concat(h._chartsViews), w);
          return;
        }
        var m = {};
        m[p + "Id"] = d[p + "Id"], m[p + "Index"] = d[p + "Index"], m[p + "Name"] = d[p + "Name"];
        var y = {
          mainType: p,
          query: m
        };
        v && (y.subType = v);
        var _ = d.excludeSeriesId, b;
        _ != null && (b = Ce(), $(Ot(_), function(x) {
          var T = xr(x, null);
          T != null && b.set(T, true);
        })), g && g.eachComponent(y, function(x) {
          var T = b && b.get(x.id) != null;
          if (!T) if (SD(d)) if (x instanceof Xt) d.type === Ol && !d.notBlur && !x.get([
            "emphasis",
            "disabled"
          ]) && cJ(x, d, h._api);
          else {
            var A = fT(x.mainType, x.componentIndex, d.name, h._api), I = A.focusSelf, M = A.dispatchers;
            d.type === Ol && I && !d.notBlur && Ex(x.mainType, x.componentIndex, h._api), M && $(M, function(k) {
              d.type === Ol ? fo(k) : po(k);
            });
          }
          else Px(d) && x instanceof Xt && (dJ(x, d, h._api), xD(x), ti(h));
        }, h), g && g.eachComponent(y, function(x) {
          var T = b && b.get(x.id) != null;
          T || w(h[p === "series" ? "_chartsMap" : "_componentsMap"][x.__viewId]);
        }, h);
        function w(x) {
          x && x.__alive && x[f] && x[f](x.__model, g, h._api, d);
        }
      }, Lo = {
        prepareAndUpdate: function(h) {
          Mu(this), Lo.update.call(this, h, {
            optionChanged: h.newOption != null
          });
        },
        update: function(h, f) {
          var d = this._model, p = this._api, v = this._zr, g = this._coordSysMgr, m = this._scheduler;
          if (d) {
            d.setUpdatePayload(h), m.restoreData(d, h), m.performSeriesTasks(d), g.create(d, p), m.performDataProcessorTasks(d, h), Y0(this, d), g.update(d, p), r(d), m.performVisualTasks(d, h), X0(this, d, p, h, f);
            var y = d.get("backgroundColor") || "transparent", _ = d.get("darkMode");
            v.setBackgroundColor(y), _ != null && _ !== "auto" && v.setDarkMode(_), Bi.trigger("afterupdate", d, p);
          }
        },
        updateTransform: function(h) {
          var f = this, d = this._model, p = this._api;
          if (d) {
            d.setUpdatePayload(h);
            var v = [];
            d.eachComponent(function(m, y) {
              if (m !== "series") {
                var _ = f.getViewOfComponentModel(y);
                if (_ && _.__alive) if (_.updateTransform) {
                  var b = _.updateTransform(y, d, p, h);
                  b && b.update && v.push(_);
                } else v.push(_);
              }
            });
            var g = Ce();
            d.eachSeries(function(m) {
              var y = f._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var _ = y.updateTransform(m, d, p, h);
                _ && _.update && g.set(m.uid, 1);
              } else g.set(m.uid, 1);
            }), r(d), this._scheduler.performVisualTasks(d, h, {
              setDirty: true,
              dirtyMap: g
            }), Bp(this, d, p, h, {}, g), Bi.trigger("afterupdate", d, p);
          }
        },
        updateView: function(h) {
          var f = this._model;
          f && (f.setUpdatePayload(h), Ft.markUpdateMethod(h, "updateView"), r(f), this._scheduler.performVisualTasks(f, h, {
            setDirty: true
          }), X0(this, f, this._api, h, {}), Bi.trigger("afterupdate", f, this._api));
        },
        updateVisual: function(h) {
          var f = this, d = this._model;
          d && (d.setUpdatePayload(h), d.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), Ft.markUpdateMethod(h, "updateVisual"), r(d), this._scheduler.performVisualTasks(d, h, {
            visualType: "visual",
            setDirty: true
          }), d.eachComponent(function(p, v) {
            if (p !== "series") {
              var g = f.getViewOfComponentModel(v);
              g && g.__alive && g.updateVisual(v, d, f._api, h);
            }
          }), d.eachSeries(function(p) {
            var v = f._chartsMap[p.__viewId];
            v.updateVisual(p, d, f._api, h);
          }), Bi.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(h) {
          Lo.update.call(this, h);
        }
      }, U0 = function(h, f, d, p) {
        if (h._disposed) {
          h.id;
          return;
        }
        for (var v = h._model, g = h._coordSysMgr.getCoordinateSystems(), m, y = wf(v, d), _ = 0; _ < g.length; _++) {
          var b = g[_];
          if (b[f] && (m = b[f](v, y, p)) != null) return m;
        }
      }, Y0 = function(h, f) {
        var d = h._chartsMap, p = h._scheduler;
        f.eachSeries(function(v) {
          p.updateStreamModes(v, d[v.__viewId]);
        });
      }, q0 = function(h, f) {
        var d = this, p = this.getModel(), v = h.type, g = h.escapeConnect, m = Wg[v], y = m.actionInfo, _ = (y.update || "update").split(":"), b = _.pop(), w = _[0] != null && Sa(_[0]);
        this[Zr] = true;
        var x = [
          h
        ], T = false;
        h.batch && (T = true, x = oe(h.batch, function(z) {
          return z = Ee(te({}, z), h), z.batch = null, z;
        }));
        var A = [], I, M = Px(h), k = SD(h);
        if (k && $4(this._api), $(x, function(z) {
          if (I = m.action(z, d._model, d._api), I = I || te({}, z), I.type = y.event || I.type, A.push(I), k) {
            var F = iT(h), E = F.queryOptionMap, O = F.mainTypeSpecified, N = O ? E.keys()[0] : "series";
            Np(d, b, z, N), ti(d);
          } else M ? (Np(d, b, z, "series"), ti(d)) : w && Np(d, b, z, w.main, w.sub);
        }), b !== "none" && !k && !M && !w) try {
          this[An] ? (Mu(this), Lo.update.call(this, h), this[An] = null) : Lo[b].call(this, h);
        } catch (z) {
          throw this[Zr] = false, z;
        }
        if (T ? I = {
          type: y.event || v,
          escapeConnect: g,
          batch: A
        } : I = A[0], this[Zr] = false, !f) {
          var B = this._messageCenter;
          if (B.trigger(I.type, I), M) {
            var L = {
              type: "selectchanged",
              escapeConnect: g,
              selected: pJ(p),
              isFromClick: h.isFromClick || false,
              fromAction: h.type,
              fromActionPayload: h
            };
            B.trigger(L.type, L);
          }
        }
      }, gh = function(h) {
        for (var f = this._pendingActions; f.length; ) {
          var d = f.shift();
          q0.call(this, d, h);
        }
      }, mh = function(h) {
        !h && this.trigger("updated");
      }, NE = function(h, f) {
        h.on("rendered", function(d) {
          f.trigger("rendered", d), h.animation.isFinished() && !f[An] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
        });
      }, BE = function(h, f) {
        h.on("mouseover", function(d) {
          var p = d.target, v = Al(p, Xf);
          v && (hJ(v, d, f._api), ti(f));
        }).on("mouseout", function(d) {
          var p = d.target, v = Al(p, Xf);
          v && (fJ(v, d, f._api), ti(f));
        }).on("click", function(d) {
          var p = d.target, v = Al(p, function(y) {
            return Ge(y).dataIndex != null;
          }, true);
          if (v) {
            var g = v.selected ? "unselect" : "select", m = Ge(v);
            f._api.dispatchAction({
              type: g,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: true
            });
          }
        });
      };
      function r(h) {
        h.clearColorPalette(), h.eachSeries(function(f) {
          f.clearColorPalette();
        });
      }
      function n(h) {
        var f = [], d = [], p = false;
        if (h.eachComponent(function(y, _) {
          var b = _.get("zlevel") || 0, w = _.get("z") || 0, x = _.getZLevelKey();
          p = p || !!x, (y === "series" ? d : f).push({
            zlevel: b,
            z: w,
            idx: _.componentIndex,
            type: y,
            key: x
          });
        }), p) {
          var v = f.concat(d), g, m;
          Zv(v, function(y, _) {
            return y.zlevel === _.zlevel ? y.z - _.z : y.zlevel - _.zlevel;
          }), $(v, function(y) {
            var _ = h.getComponent(y.type, y.idx), b = y.zlevel, w = y.key;
            g != null && (b = Math.max(g, b)), w ? (b === g && w !== m && b++, m = w) : m && (b === g && b++, m = ""), g = b, _.setZLevel(b);
          });
        }
      }
      X0 = function(h, f, d, p, v) {
        n(f), zE(h, f, d, p, v), $(h._chartsViews, function(g) {
          g.__alive = false;
        }), Bp(h, f, d, p, v), $(h._chartsViews, function(g) {
          g.__alive || g.remove(f, d);
        });
      }, zE = function(h, f, d, p, v, g) {
        $(g || h._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, f, d, p), s(y, m), c(y, m);
        });
      }, Bp = function(h, f, d, p, v, g) {
        var m = h._scheduler;
        v = te(v || {}, {
          updatedSeries: f.getSeries()
        }), Bi.trigger("series:beforeupdate", f, d, v);
        var y = false;
        f.eachSeries(function(_) {
          var b = h._chartsMap[_.__viewId];
          b.__alive = true;
          var w = b.renderTask;
          m.updatePayload(w, p), u(_, b), g && g.get(_.uid) && w.dirty(), w.perform(m.getPerformArgs(w)) && (y = true), b.group.silent = !!_.get("silent"), o(_, b), xD(_);
        }), m.unfinished = y || m.unfinished, Bi.trigger("series:layoutlabels", f, d, v), Bi.trigger("series:transition", f, d, v), f.eachSeries(function(_) {
          var b = h._chartsMap[_.__viewId];
          s(_, b), c(_, b);
        }), a(h, f), Bi.trigger("series:afterupdate", f, d, v);
      }, ti = function(h) {
        h[G0] = true, h.getZr().wakeUp();
      }, VE = function(h) {
        h[G0] && (h.getZr().storage.traverse(function(f) {
          hc(f) || i(f);
        }), h[G0] = false);
      };
      function i(h) {
        for (var f = [], d = h.currentStates, p = 0; p < d.length; p++) {
          var v = d[p];
          v === "emphasis" || v === "blur" || v === "select" || f.push(v);
        }
        h.selected && h.states.select && f.push("select"), h.hoverState === Um && h.states.emphasis ? f.push("emphasis") : h.hoverState === kd && h.states.blur && f.push("blur"), h.useStates(f);
      }
      function a(h, f) {
        var d = h._zr, p = d.storage, v = 0;
        p.traverse(function(g) {
          g.isGroup || v++;
        }), v > f.get("hoverLayerThreshold") && !ct.node && !ct.worker && f.eachSeries(function(g) {
          if (!g.preventUsingHoverLayer) {
            var m = h._chartsMap[g.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = true);
            });
          }
        });
      }
      function o(h, f) {
        var d = h.get("blendMode") || null;
        f.eachRendered(function(p) {
          p.isGroup || (p.style.blend = d);
        });
      }
      function s(h, f) {
        if (!h.preventAutoZ) {
          var d = h.get("z") || 0, p = h.get("zlevel") || 0;
          f.eachRendered(function(v) {
            return l(v, d, p, -1 / 0), true;
          });
        }
      }
      function l(h, f, d, p) {
        var v = h.getTextContent(), g = h.getTextGuideLine(), m = h.isGroup;
        if (m) for (var y = h.childrenRef(), _ = 0; _ < y.length; _++) p = Math.max(l(y[_], f, d, p), p);
        else h.z = f, h.zlevel = d, p = Math.max(h.z2, p);
        if (v && (v.z = f, v.zlevel = d, isFinite(p) && (v.z2 = p + 2)), g) {
          var b = h.textGuideLineConfig;
          g.z = f, g.zlevel = d, isFinite(p) && (g.z2 = p + (b && b.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(h, f) {
        f.eachRendered(function(d) {
          if (!hc(d)) {
            var p = d.getTextContent(), v = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), v && v.stateTransition && (v.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function c(h, f) {
        var d = h.getModel("stateAnimation"), p = h.isAnimationEnabled(), v = d.get("duration"), g = v > 0 ? {
          duration: v,
          delay: d.get("delay"),
          easing: d.get("easing")
        } : null;
        f.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (hc(m)) return;
            if (m instanceof st && _J(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (p) {
              m.stateTransition = g;
              var _ = m.getTextContent(), b = m.getTextGuideLine();
              _ && (_.stateTransition = g), b && (b.stateTransition = g);
            }
            m.__dirty && i(m);
          }
        });
      }
      FE = function(h) {
        return new (function(f) {
          K(d, f);
          function d() {
            return f !== null && f.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var v = p.__ecComponentInfo;
              if (v != null) return h._model.getComponent(v.mainType, v.index);
              p = p.parent;
            }
          }, d.prototype.enterEmphasis = function(p, v) {
            fo(p, v), ti(h);
          }, d.prototype.leaveEmphasis = function(p, v) {
            po(p, v), ti(h);
          }, d.prototype.enterBlur = function(p) {
            E4(p), ti(h);
          }, d.prototype.leaveBlur = function(p) {
            hT(p), ti(h);
          }, d.prototype.enterSelect = function(p) {
            k4(p), ti(h);
          }, d.prototype.leaveSelect = function(p) {
            P4(p), ti(h);
          }, d.prototype.getModel = function() {
            return h.getModel();
          }, d.prototype.getViewOfComponentModel = function(p) {
            return h.getViewOfComponentModel(p);
          }, d.prototype.getViewOfSeriesModel = function(p) {
            return h.getViewOfSeriesModel(p);
          }, d;
        }(TV))(h);
      }, _5 = function(h) {
        function f(d, p) {
          for (var v = 0; v < d.length; v++) {
            var g = d[v];
            g[W0] = p;
          }
        }
        $(Mf, function(d, p) {
          h._messageCenter.on(p, function(v) {
            if (GE[h.group] && h[W0] !== OE) {
              if (v && v.escapeConnect) return;
              var g = h.makeActionFromEvent(v), m = [];
              $(Df, function(y) {
                y !== h && y.group === h.group && m.push(y);
              }), f(m, OE), $(m, function(y) {
                y[W0] !== Ure && y.dispatchAction(g);
              }), f(m, Yre);
            }
          });
        });
      };
    }(), e;
  }(xi), OT = b5.prototype;
  OT.on = p5("on");
  OT.off = p5("off");
  OT.one = function(t, e, r) {
    var n = this;
    function i() {
      for (var a = [], o = 0; o < arguments.length; o++) a[o] = arguments[o];
      e && e.apply && e.apply(this, a), n.off(t, i);
    }
    this.on.call(this, t, i, r);
  };
  var qre = [
    "click",
    "dblclick",
    "mouseover",
    "mouseout",
    "mousemove",
    "mousedown",
    "mouseup",
    "globalout",
    "contextmenu"
  ];
  var Wg = {}, Mf = {}, Xx = [], jx = [], Hg = [], x5 = {}, Kx = {}, Df = {}, GE = {}, Xre = +/* @__PURE__ */ new Date() - 0, NT = "_echarts_instance_";
  function jre(t, e, r) {
    {
      var n = Kre(t);
      if (n) return n;
    }
    var i = new b5(t, e, r);
    return i.id = "ec_" + Xre++, Df[i.id] = i, d4(t, NT, i.id), _5(i), Bi.trigger("afterinit", i), i;
  }
  function Kre(t) {
    return Df[sQ(t, NT)];
  }
  function w5(t, e) {
    x5[t] = e;
  }
  function S5(t) {
    et(jx, t) < 0 && jx.push(t);
  }
  function T5(t, e) {
    zT(Xx, t, e, Nre);
  }
  function Zre(t) {
    BT("afterinit", t);
  }
  function Qre(t) {
    BT("afterupdate", t);
  }
  function BT(t, e) {
    Bi.on(t, e);
  }
  function Ba(t, e, r) {
    De(e) && (r = e, e = "");
    var n = Le(t) ? t.type : [
      t,
      t = {
        event: e
      }
    ][0];
    t.event = (t.event || n).toLowerCase(), e = t.event, !Mf[e] && (bn(RE.test(n) && RE.test(e)), Wg[n] || (Wg[n] = {
      action: r,
      actionInfo: t
    }), Mf[e] = n);
  }
  function Jre(t, e) {
    Nd.register(t, e);
  }
  function ene(t, e) {
    zT(Hg, t, e, h5, "layout");
  }
  function su(t, e) {
    zT(Hg, t, e, f5, "visual");
  }
  var WE = [];
  function zT(t, e, r, n, i) {
    if ((De(e) || Le(e)) && (r = e, e = n), !(et(WE, r) >= 0)) {
      WE.push(r);
      var a = ZV.wrapStageHandler(r, i);
      a.__prio = e, a.__raw = r, t.push(a);
    }
  }
  function C5(t, e) {
    Kx[t] = e;
  }
  function tne(t, e, r) {
    var n = Pre("registerMap");
    n && n(t, e, r);
  }
  var rne = pte;
  su(RT, Fte);
  su(sy, Vte);
  su(sy, Gte);
  su(RT, tre);
  su(sy, rre);
  su(d5, Ere);
  S5(AV);
  T5(Rre, Xee);
  C5("default", Wte);
  Ba({
    type: Ol,
    event: Ol,
    update: Ol
  }, dr);
  Ba({
    type: ng,
    event: ng,
    update: ng
  }, dr);
  Ba({
    type: Sf,
    event: Sf,
    update: Sf
  }, dr);
  Ba({
    type: ig,
    event: ig,
    update: ig
  }, dr);
  Ba({
    type: Tf,
    event: Tf,
    update: Tf
  }, dr);
  w5("light", Jte);
  w5("dark", t5);
  var HE = [], nne = {
    registerPreprocessor: S5,
    registerProcessor: T5,
    registerPostInit: Zre,
    registerPostUpdate: Qre,
    registerUpdateLifecycle: BT,
    registerAction: Ba,
    registerCoordinateSystem: Jre,
    registerLayout: ene,
    registerVisual: su,
    registerTransform: rne,
    registerLoading: C5,
    registerMap: tne,
    registerImpl: kre,
    PRIORITY: Hre,
    ComponentModel: vt,
    ComponentView: tr,
    SeriesModel: Xt,
    ChartView: Ft,
    registerComponentModel: function(t) {
      vt.registerClass(t);
    },
    registerComponentView: function(t) {
      tr.registerClass(t);
    },
    registerSeriesModel: function(t) {
      Xt.registerClass(t);
    },
    registerChartView: function(t) {
      Ft.registerClass(t);
    },
    registerSubTypeDefaulter: function(t, e) {
      vt.registerSubTypeDefaulter(t, e);
    },
    registerPainter: function(t, e) {
      BZ(t, e);
    }
  };
  function rt(t) {
    if (ae(t)) {
      $(t, function(e) {
        rt(e);
      });
      return;
    }
    et(HE, t) >= 0 || (HE.push(t), De(t) && (t = {
      install: t
    }), t.install(nne));
  }
  function yh(t) {
    return t == null ? 0 : t.length || 1;
  }
  function UE(t) {
    return t;
  }
  var vo = function() {
    function t(e, r, n, i, a, o) {
      this._old = e, this._new = r, this._oldKeyGetter = n || UE, this._newKeyGetter = i || UE, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return t.prototype.add = function(e) {
      return this._add = e, this;
    }, t.prototype.update = function(e) {
      return this._update = e, this;
    }, t.prototype.updateManyToOne = function(e) {
      return this._updateManyToOne = e, this;
    }, t.prototype.updateOneToMany = function(e) {
      return this._updateOneToMany = e, this;
    }, t.prototype.updateManyToMany = function(e) {
      return this._updateManyToMany = e, this;
    }, t.prototype.remove = function(e) {
      return this._remove = e, this;
    }, t.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, t.prototype._executeOneToOne = function() {
      var e = this._old, r = this._new, n = {}, i = new Array(e.length), a = new Array(r.length);
      this._initIndexMap(e, null, i, "_oldKeyGetter"), this._initIndexMap(r, n, a, "_newKeyGetter");
      for (var o = 0; o < e.length; o++) {
        var s = i[o], l = n[s], u = yh(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[s] = l[0]), this._update && this._update(c, o);
        } else u === 1 ? (n[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, n);
    }, t.prototype._executeMultiple = function() {
      var e = this._old, r = this._new, n = {}, i = {}, a = [], o = [];
      this._initIndexMap(e, n, a, "_oldKeyGetter"), this._initIndexMap(r, i, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = n[l], c = i[l], h = yh(u), f = yh(c);
        if (h > 1 && f === 1) this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (h === 1 && f > 1) this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (h === 1 && f === 1) this._update && this._update(c, u), i[l] = null;
        else if (h > 1 && f > 1) this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (h > 1) for (var d = 0; d < h; d++) this._remove && this._remove(u[d]);
        else this._remove && this._remove(u);
      }
      this._performRestAdd(o, i);
    }, t.prototype._performRestAdd = function(e, r) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n], a = r[i], o = yh(a);
        if (o > 1) for (var s = 0; s < o; s++) this._add && this._add(a[s]);
        else o === 1 && this._add && this._add(a);
        r[i] = null;
      }
    }, t.prototype._initIndexMap = function(e, r, n, i) {
      for (var a = this._diffModeMultiple, o = 0; o < e.length; o++) {
        var s = "_ec_" + this[i](e[o], o);
        if (a || (n[o] = s), !!r) {
          var l = r[s], u = yh(l);
          u === 0 ? (r[s] = o, a && n.push(s)) : u === 1 ? r[s] = [
            l,
            o
          ] : l.push(o);
        }
      }
    }, t;
  }(), ine = function() {
    function t(e, r) {
      this._encode = e, this._schema = r;
    }
    return t.prototype.get = function() {
      return {
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, t.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, t;
  }();
  function ane(t, e) {
    var r = {}, n = r.encode = {}, i = Ce(), a = [], o = [], s = {};
    $(t.dimensions, function(f) {
      var d = t.getDimensionInfo(f), p = d.coordDim;
      if (p) {
        var v = d.coordDimIndex;
        j0(n, p)[v] = f, d.isExtraCoord || (i.set(p, 1), one(d.type) && (a[0] = f), j0(s, p)[v] = t.getDimensionIndex(d.name)), d.defaultTooltip && o.push(f);
      }
      mV.each(function(g, m) {
        var y = j0(n, m), _ = d.otherDims[m];
        _ != null && _ !== false && (y[_] = d.name);
      });
    });
    var l = [], u = {};
    i.each(function(f, d) {
      var p = n[d];
      u[d] = p[0], l = l.concat(p);
    }), r.dataDimsOnCoord = l, r.dataDimIndicesOnCoord = oe(l, function(f) {
      return t.getDimensionInfo(f).storeDimIndex;
    }), r.encodeFirstDimNotExtra = u;
    var c = n.label;
    c && c.length && (a = c.slice());
    var h = n.tooltip;
    return h && h.length ? o = h.slice() : o.length || (o = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = o, r.userOutput = new ine(s, e), r;
  }
  function j0(t, e) {
    return t.hasOwnProperty(e) || (t[e] = []), t[e];
  }
  function Ug(t) {
    return t === "category" ? "ordinal" : t === "time" ? "time" : "float";
  }
  function one(t) {
    return !(t === "ordinal" || t === "time");
  }
  var ug = /* @__PURE__ */ function() {
    function t(e) {
      this.otherDims = {}, e != null && te(this, e);
    }
    return t;
  }(), sne = _t(), lne = {
    float: "f",
    int: "i",
    ordinal: "o",
    number: "n",
    time: "t"
  }, A5 = function() {
    function t(e) {
      this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted);
    }
    return t.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, t.prototype._updateDimOmitted = function(e) {
      this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = D5(this.source)));
    }, t.prototype.getSourceDimensionIndex = function(e) {
      return We(this._dimNameMap.get(e), -1);
    }, t.prototype.getSourceDimension = function(e) {
      var r = this.source.dimensionsDefine;
      if (r) return r[e];
    }, t.prototype.makeStoreSchema = function() {
      for (var e = this._fullDimCount, r = MV(this.source), n = !E5(e), i = "", a = [], o = 0, s = 0; o < e; o++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[s];
        if (h && h.storeDimIndex === o) l = r ? h.name : null, u = h.type, c = h.ordinalMeta, s++;
        else {
          var f = this.getSourceDimension(o);
          f && (l = r ? f.name : null, u = f.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), r && l != null && (!h || !h.isCalculationCoord) && (i += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += lne[u] || "f", c && (i += c.uid), i += "$";
      }
      var d = this.source, p = [
        d.seriesLayoutBy,
        d.startIndex,
        i
      ].join("$$");
      return {
        dimensions: a,
        hash: p
      };
    }, t.prototype.makeOutputDimensionNames = function() {
      for (var e = [], r = 0, n = 0; r < this._fullDimCount; r++) {
        var i = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === r) a.isCalculationCoord || (i = a.name), n++;
        else {
          var o = this.getSourceDimension(r);
          o && (i = o.name);
        }
        e.push(i);
      }
      return e;
    }, t.prototype.appendCalculationDimension = function(e) {
      this.dimensions.push(e), e.isCalculationCoord = true, this._fullDimCount++, this._updateDimOmitted(true);
    }, t;
  }();
  function I5(t) {
    return t instanceof A5;
  }
  function M5(t) {
    for (var e = Ce(), r = 0; r < (t || []).length; r++) {
      var n = t[r], i = Le(n) ? n.name : n;
      i != null && e.get(i) == null && e.set(i, r);
    }
    return e;
  }
  function D5(t) {
    var e = sne(t);
    return e.dimNameMap || (e.dimNameMap = M5(t.dimensionsDefine));
  }
  function E5(t) {
    return t > 30;
  }
  var _h = Le, $o = oe, une = typeof Int32Array > "u" ? Array : Int32Array, cne = "e\0\0", YE = -1, hne = [
    "hasItemOption",
    "_nameList",
    "_idList",
    "_invertedIndicesMap",
    "_dimSummary",
    "userOutput",
    "_rawData",
    "_dimValueGetter",
    "_nameDimIdx",
    "_idDimIdx",
    "_nameRepeatCount"
  ], fne = [
    "_approximateExtent"
  ], qE, zp, bh, xh, K0, wh, Z0, yn = function() {
    function t(e, r) {
      this.type = "list", this._dimOmitted = false, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = false, this.TRANSFERABLE_METHODS = [
        "cloneShallow",
        "downSample",
        "minmaxDownSample",
        "lttbDownSample",
        "map"
      ], this.CHANGABLE_METHODS = [
        "filterSelf",
        "selectRange"
      ], this.DOWNSAMPLE_METHODS = [
        "downSample",
        "minmaxDownSample",
        "lttbDownSample"
      ];
      var n, i = false;
      I5(e) ? (n = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (i = true, n = e), n = n || [
        "x",
        "y"
      ];
      for (var a = {}, o = [], s = {}, l = false, u = {}, c = 0; c < n.length; c++) {
        var h = n[c], f = me(h) ? new ug({
          name: h
        }) : h instanceof ug ? h : new ug(h), d = f.name;
        f.type = f.type || "float", f.coordDim || (f.coordDim = d, f.coordDimIndex = 0);
        var p = f.otherDims = f.otherDims || {};
        o.push(d), a[d] = f, u[d] != null && (l = true), f.createInvertedIndices && (s[d] = []), p.itemName === 0 && (this._nameDimIdx = c), p.itemId === 0 && (this._idDimIdx = c), i && (f.storeDimIndex = c);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = r, this._invertedIndicesMap = s, this._dimOmitted) {
        var v = this._dimIdxToName = Ce();
        $(o, function(g) {
          v.set(a[g].storeDimIndex, g);
        });
      }
    }
    return t.prototype.getDimension = function(e) {
      var r = this._recognizeDimIndex(e);
      if (r == null) return e;
      if (r = e, !this._dimOmitted) return this.dimensions[r];
      var n = this._dimIdxToName.get(r);
      if (n != null) return n;
      var i = this._schema.getSourceDimension(r);
      if (i) return i.name;
    }, t.prototype.getDimensionIndex = function(e) {
      var r = this._recognizeDimIndex(e);
      if (r != null) return r;
      if (e == null) return -1;
      var n = this._getDimInfo(e);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1;
    }, t.prototype._recognizeDimIndex = function(e) {
      if (xt(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0)) return +e;
    }, t.prototype._getStoreDimIndex = function(e) {
      var r = this.getDimensionIndex(e);
      return r;
    }, t.prototype.getDimensionInfo = function(e) {
      return this._getDimInfo(this.getDimension(e));
    }, t.prototype._initGetDimensionInfo = function(e) {
      var r = this._dimInfos;
      this._getDimInfo = e ? function(n) {
        return r.hasOwnProperty(n) ? r[n] : void 0;
      } : function(n) {
        return r[n];
      };
    }, t.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, t.prototype.mapDimension = function(e, r) {
      var n = this._dimSummary;
      if (r == null) return n.encodeFirstDimNotExtra[e];
      var i = n.encode[e];
      return i ? i[r] : null;
    }, t.prototype.mapDimensionsAll = function(e) {
      var r = this._dimSummary, n = r.encode[e];
      return (n || []).slice();
    }, t.prototype.getStore = function() {
      return this._store;
    }, t.prototype.initData = function(e, r, n) {
      var i = this, a;
      if (e instanceof Vx && (a = e), !a) {
        var o = this.dimensions, s = MT(e) || on(e) ? new DV(e, o.length) : e;
        a = new Vx();
        var l = $o(o, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, n);
      }
      this._store = a, this._nameList = (r || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = ane(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, t.prototype.appendData = function(e) {
      var r = this._store.appendData(e);
      this._doInit(r[0], r[1]);
    }, t.prototype.appendValues = function(e, r) {
      var n = this._store.appendValues(e, r && r.length), i = n.start, a = n.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), r) for (var s = i; s < a; s++) {
        var l = s - i;
        this._nameList[s] = r[l], o && Z0(this, s);
      }
    }, t.prototype._updateOrdinalMeta = function() {
      for (var e = this._store, r = this.dimensions, n = 0; n < r.length; n++) {
        var i = this._dimInfos[r[n]];
        i.ordinalMeta && e.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, t.prototype._shouldMakeIdFromName = function() {
      var e = this._store.getProvider();
      return this._idDimIdx == null && e.getSource().sourceFormat !== os && !e.fillStorage;
    }, t.prototype._doInit = function(e, r) {
      if (!(e >= r)) {
        var n = this._store, i = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = i.getSource().sourceFormat, l = s === wi;
        if (l && !i.pure) for (var u = [], c = e; c < r; c++) {
          var h = i.getItem(c, u);
          if (!this.hasItemOption && XZ(h) && (this.hasItemOption = true), h) {
            var f = h.name;
            a[c] == null && f != null && (a[c] = xr(f, null));
            var d = h.id;
            o[c] == null && d != null && (o[c] = xr(d, null));
          }
        }
        if (this._shouldMakeIdFromName()) for (var c = e; c < r; c++) Z0(this, c);
        qE(this);
      }
    }, t.prototype.getApproximateExtent = function(e) {
      return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e));
    }, t.prototype.setApproximateExtent = function(e, r) {
      r = this.getDimension(r), this._approximateExtent[r] = e.slice();
    }, t.prototype.getCalculationInfo = function(e) {
      return this._calculationInfo[e];
    }, t.prototype.setCalculationInfo = function(e, r) {
      _h(e) ? te(this._calculationInfo, e) : this._calculationInfo[e] = r;
    }, t.prototype.getName = function(e) {
      var r = this.getRawIndex(e), n = this._nameList[r];
      return n == null && this._nameDimIdx != null && (n = bh(this, this._nameDimIdx, r)), n == null && (n = ""), n;
    }, t.prototype._getCategory = function(e, r) {
      var n = this._store.get(e, r), i = this._store.getOrdinalMeta(e);
      return i ? i.categories[n] : n;
    }, t.prototype.getId = function(e) {
      return zp(this, this.getRawIndex(e));
    }, t.prototype.count = function() {
      return this._store.count();
    }, t.prototype.get = function(e, r) {
      var n = this._store, i = this._dimInfos[e];
      if (i) return n.get(i.storeDimIndex, r);
    }, t.prototype.getByRawIndex = function(e, r) {
      var n = this._store, i = this._dimInfos[e];
      if (i) return n.getByRawIndex(i.storeDimIndex, r);
    }, t.prototype.getIndices = function() {
      return this._store.getIndices();
    }, t.prototype.getDataExtent = function(e) {
      return this._store.getDataExtent(this._getStoreDimIndex(e));
    }, t.prototype.getSum = function(e) {
      return this._store.getSum(this._getStoreDimIndex(e));
    }, t.prototype.getMedian = function(e) {
      return this._store.getMedian(this._getStoreDimIndex(e));
    }, t.prototype.getValues = function(e, r) {
      var n = this, i = this._store;
      return ae(e) ? i.getValues($o(e, function(a) {
        return n._getStoreDimIndex(a);
      }), r) : i.getValues(e);
    }, t.prototype.hasValue = function(e) {
      for (var r = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = r.length; n < i; n++) if (isNaN(this._store.get(r[n], e))) return false;
      return true;
    }, t.prototype.indexOfName = function(e) {
      for (var r = 0, n = this._store.count(); r < n; r++) if (this.getName(r) === e) return r;
      return -1;
    }, t.prototype.getRawIndex = function(e) {
      return this._store.getRawIndex(e);
    }, t.prototype.indexOfRawIndex = function(e) {
      return this._store.indexOfRawIndex(e);
    }, t.prototype.rawIndexOf = function(e, r) {
      var n = e && this._invertedIndicesMap[e], i = n && n[r];
      return i == null || isNaN(i) ? YE : i;
    }, t.prototype.indicesOfNearest = function(e, r, n) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(e), r, n);
    }, t.prototype.each = function(e, r, n) {
      De(e) && (n = r, r = e, e = []);
      var i = n || this, a = $o(xh(e), this._getStoreDimIndex, this);
      this._store.each(a, i ? _e(r, i) : r);
    }, t.prototype.filterSelf = function(e, r, n) {
      De(e) && (n = r, r = e, e = []);
      var i = n || this, a = $o(xh(e), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, i ? _e(r, i) : r), this;
    }, t.prototype.selectRange = function(e) {
      var r = this, n = {}, i = gt(e);
      return $(i, function(a) {
        var o = r._getStoreDimIndex(a);
        n[o] = e[a];
      }), this._store = this._store.selectRange(n), this;
    }, t.prototype.mapArray = function(e, r, n) {
      De(e) && (n = r, r = e, e = []), n = n || this;
      var i = [];
      return this.each(e, function() {
        i.push(r && r.apply(this, arguments));
      }, n), i;
    }, t.prototype.map = function(e, r, n, i) {
      var a = n || i || this, o = $o(xh(e), this._getStoreDimIndex, this), s = wh(this);
      return s._store = this._store.map(o, a ? _e(r, a) : r), s;
    }, t.prototype.modify = function(e, r, n, i) {
      var a = n || i || this, o = $o(xh(e), this._getStoreDimIndex, this);
      this._store.modify(o, a ? _e(r, a) : r);
    }, t.prototype.downSample = function(e, r, n, i) {
      var a = wh(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(e), r, n, i), a;
    }, t.prototype.minmaxDownSample = function(e, r) {
      var n = wh(this);
      return n._store = this._store.minmaxDownSample(this._getStoreDimIndex(e), r), n;
    }, t.prototype.lttbDownSample = function(e, r) {
      var n = wh(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(e), r), n;
    }, t.prototype.getRawDataItem = function(e) {
      return this._store.getRawDataItem(e);
    }, t.prototype.getItemModel = function(e) {
      var r = this.hostModel, n = this.getRawDataItem(e);
      return new kt(n, r, r && r.ecModel);
    }, t.prototype.diff = function(e) {
      var r = this;
      return new vo(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return zp(e, n);
      }, function(n) {
        return zp(r, n);
      });
    }, t.prototype.getVisual = function(e) {
      var r = this._visual;
      return r && r[e];
    }, t.prototype.setVisual = function(e, r) {
      this._visual = this._visual || {}, _h(e) ? te(this._visual, e) : this._visual[e] = r;
    }, t.prototype.getItemVisual = function(e, r) {
      var n = this._itemVisuals[e], i = n && n[r];
      return i ?? this.getVisual(r);
    }, t.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, t.prototype.ensureUniqueItemVisual = function(e, r) {
      var n = this._itemVisuals, i = n[e];
      i || (i = n[e] = {});
      var a = i[r];
      return a == null && (a = this.getVisual(r), ae(a) ? a = a.slice() : _h(a) && (a = te({}, a)), i[r] = a), a;
    }, t.prototype.setItemVisual = function(e, r, n) {
      var i = this._itemVisuals[e] || {};
      this._itemVisuals[e] = i, _h(r) ? te(i, r) : i[r] = n;
    }, t.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, t.prototype.setLayout = function(e, r) {
      _h(e) ? te(this._layout, e) : this._layout[e] = r;
    }, t.prototype.getLayout = function(e) {
      return this._layout[e];
    }, t.prototype.getItemLayout = function(e) {
      return this._itemLayouts[e];
    }, t.prototype.setItemLayout = function(e, r, n) {
      this._itemLayouts[e] = n ? te(this._itemLayouts[e] || {}, r) : r;
    }, t.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, t.prototype.setItemGraphicEl = function(e, r) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      Mx(n, this.dataType, e, r), this._graphicEls[e] = r;
    }, t.prototype.getItemGraphicEl = function(e) {
      return this._graphicEls[e];
    }, t.prototype.eachItemGraphicEl = function(e, r) {
      $(this._graphicEls, function(n, i) {
        n && e && e.call(r, n, i);
      });
    }, t.prototype.cloneShallow = function(e) {
      return e || (e = new t(this._schema ? this._schema : $o(this.dimensions, this._getDimInfo, this), this.hostModel)), K0(e, this), e._store = this._store, e;
    }, t.prototype.wrapMethod = function(e, r) {
      var n = this[e];
      De(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function() {
        var i = n.apply(this, arguments);
        return r.apply(this, [
          i
        ].concat(XS(arguments)));
      });
    }, t.internalField = function() {
      qE = function(e) {
        var r = e._invertedIndicesMap;
        $(r, function(n, i) {
          var a = e._dimInfos[i], o = a.ordinalMeta, s = e._store;
          if (o) {
            n = r[i] = new une(o.categories.length);
            for (var l = 0; l < n.length; l++) n[l] = YE;
            for (var l = 0; l < s.count(); l++) n[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, bh = function(e, r, n) {
        return xr(e._getCategory(r, n), null);
      }, zp = function(e, r) {
        var n = e._idList[r];
        return n == null && e._idDimIdx != null && (n = bh(e, e._idDimIdx, r)), n == null && (n = cne + r), n;
      }, xh = function(e) {
        return ae(e) || (e = e != null ? [
          e
        ] : []), e;
      }, wh = function(e) {
        var r = new t(e._schema ? e._schema : $o(e.dimensions, e._getDimInfo, e), e.hostModel);
        return K0(r, e), r;
      }, K0 = function(e, r) {
        $(hne.concat(r.__wrappedMethods || []), function(n) {
          r.hasOwnProperty(n) && (e[n] = r[n]);
        }), e.__wrappedMethods = r.__wrappedMethods, $(fne, function(n) {
          e[n] = Oe(r[n]);
        }), e._calculationInfo = te({}, r._calculationInfo);
      }, Z0 = function(e, r) {
        var n = e._nameList, i = e._idList, a = e._nameDimIdx, o = e._idDimIdx, s = n[r], l = i[r];
        if (s == null && a != null && (n[r] = s = bh(e, a, r)), l == null && o != null && (i[r] = l = bh(e, o, r)), l == null && s != null) {
          var u = e._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), i[r] = l;
        }
      };
    }(), t;
  }();
  function zd(t, e) {
    MT(t) || (t = DT(t)), e = e || {};
    var r = e.coordDimensions || [], n = e.dimensionsDefine || t.dimensionsDefine || [], i = Ce(), a = [], o = pne(t, r, n, e.dimensionsCount), s = e.canOmitUnusedDimensions && E5(o), l = n === t.dimensionsDefine, u = l ? D5(t) : M5(n), c = e.encodeDefine;
    !c && e.encodeDefaulter && (c = e.encodeDefaulter(t, o));
    for (var h = Ce(c), f = new NV(o), d = 0; d < f.length; d++) f[d] = -1;
    function p(I) {
      var M = f[I];
      if (M < 0) {
        var k = n[I], B = Le(k) ? k : {
          name: k
        }, L = new ug(), z = B.name;
        z != null && u.get(z) != null && (L.name = L.displayName = z), B.type != null && (L.type = B.type), B.displayName != null && (L.displayName = B.displayName);
        var F = a.length;
        return f[I] = F, L.storeDimIndex = I, a.push(L), L;
      }
      return a[M];
    }
    if (!s) for (var d = 0; d < o; d++) p(d);
    h.each(function(I, M) {
      var k = Ot(I).slice();
      if (k.length === 1 && !me(k[0]) && k[0] < 0) {
        h.set(M, false);
        return;
      }
      var B = h.set(M, []);
      $(k, function(L, z) {
        var F = me(L) ? u.get(L) : L;
        F != null && F < o && (B[z] = F, g(p(F), M, z));
      });
    });
    var v = 0;
    $(r, function(I) {
      var M, k, B, L;
      if (me(I)) M = I, L = {};
      else {
        L = I, M = L.name;
        var z = L.ordinalMeta;
        L.ordinalMeta = null, L = te({}, L), L.ordinalMeta = z, k = L.dimsDef, B = L.otherDims, L.name = L.coordDim = L.coordDimIndex = L.dimsDef = L.otherDims = null;
      }
      var F = h.get(M);
      if (F !== false) {
        if (F = Ot(F), !F.length) for (var E = 0; E < (k && k.length || 1); E++) {
          for (; v < o && p(v).coordDim != null; ) v++;
          v < o && F.push(v++);
        }
        $(F, function(O, N) {
          var V = p(O);
          if (l && L.type != null && (V.type = L.type), g(Ee(V, L), M, N), V.name == null && k) {
            var H = k[N];
            !Le(H) && (H = {
              name: H
            }), V.name = V.displayName = H.name, V.defaultTooltip = H.defaultTooltip;
          }
          B && Ee(V.otherDims, B);
        });
      }
    });
    function g(I, M, k) {
      mV.get(M) != null ? I.otherDims[M] = k : (I.coordDim = M, I.coordDimIndex = k, i.set(M, true));
    }
    var m = e.generateCoord, y = e.generateCoordCount, _ = y != null;
    y = m ? y || 1 : 0;
    var b = m || "value";
    function w(I) {
      I.name == null && (I.name = I.coordDim);
    }
    if (s) $(a, function(I) {
      w(I);
    }), a.sort(function(I, M) {
      return I.storeDimIndex - M.storeDimIndex;
    });
    else for (var x = 0; x < o; x++) {
      var T = p(x), A = T.coordDim;
      A == null && (T.coordDim = vne(b, i, _), T.coordDimIndex = 0, (!m || y <= 0) && (T.isExtraCoord = true), y--), w(T), T.type == null && (xV(t, x) === Hr.Must || T.isExtraCoord && (T.otherDims.itemName != null || T.otherDims.seriesName != null)) && (T.type = "ordinal");
    }
    return dne(a), new A5({
      source: t,
      dimensions: a,
      fullDimensionCount: o,
      dimensionOmitted: s
    });
  }
  function dne(t) {
    for (var e = Ce(), r = 0; r < t.length; r++) {
      var n = t[r], i = n.name, a = e.get(i) || 0;
      a > 0 && (n.name = i + (a - 1)), a++, e.set(i, a);
    }
  }
  function pne(t, e, r, n) {
    var i = Math.max(t.dimensionsDetectedCount || 1, e.length, r.length, n || 0);
    return $(e, function(a) {
      var o;
      Le(a) && (o = a.dimsDef) && (i = Math.max(i, o.length));
    }), i;
  }
  function vne(t, e, r) {
    if (r || e.hasKey(t)) {
      for (var n = 0; e.hasKey(t + n); ) n++;
      t += n;
    }
    return e.set(t, true), t;
  }
  var gne = /* @__PURE__ */ function() {
    function t(e) {
      this.coordSysDims = [], this.axisMap = Ce(), this.categoryAxisMap = Ce(), this.coordSysName = e;
    }
    return t;
  }();
  function mne(t) {
    var e = t.get("coordinateSystem"), r = new gne(e), n = yne[e];
    if (n) return n(t, r, r.axisMap, r.categoryAxisMap), r;
  }
  var yne = {
    cartesian2d: function(t, e, r, n) {
      var i = t.getReferringComponents("xAxis", gr).models[0], a = t.getReferringComponents("yAxis", gr).models[0];
      e.coordSysDims = [
        "x",
        "y"
      ], r.set("x", i), r.set("y", a), Du(i) && (n.set("x", i), e.firstCategoryDimIndex = 0), Du(a) && (n.set("y", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
    },
    singleAxis: function(t, e, r, n) {
      var i = t.getReferringComponents("singleAxis", gr).models[0];
      e.coordSysDims = [
        "single"
      ], r.set("single", i), Du(i) && (n.set("single", i), e.firstCategoryDimIndex = 0);
    },
    polar: function(t, e, r, n) {
      var i = t.getReferringComponents("polar", gr).models[0], a = i.findAxisModel("radiusAxis"), o = i.findAxisModel("angleAxis");
      e.coordSysDims = [
        "radius",
        "angle"
      ], r.set("radius", a), r.set("angle", o), Du(a) && (n.set("radius", a), e.firstCategoryDimIndex = 0), Du(o) && (n.set("angle", o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
    },
    geo: function(t, e, r, n) {
      e.coordSysDims = [
        "lng",
        "lat"
      ];
    },
    parallel: function(t, e, r, n) {
      var i = t.ecModel, a = i.getComponent("parallel", t.get("parallelIndex")), o = e.coordSysDims = a.dimensions.slice();
      $(a.parallelAxisIndex, function(s, l) {
        var u = i.getComponent("parallelAxis", s), c = o[l];
        r.set(c, u), Du(u) && (n.set(c, u), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l));
      });
    }
  };
  function Du(t) {
    return t.get("type") === "category";
  }
  function _ne(t, e, r) {
    r = r || {};
    var n = r.byIndex, i = r.stackedCoordDimension, a, o, s;
    bne(e) ? a = e : (o = e.schema, a = o.dimensions, s = e.store);
    var l = !!(t && t.get("stack")), u, c, h, f;
    if ($(a, function(y, _) {
      me(y) && (a[_] = y = {
        name: y
      }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
    }), c && !n && !u && (n = true), c) {
      h = "__\0ecstackresult_" + t.id, f = "__\0ecstackedover_" + t.id, u && (u.createInvertedIndices = true);
      var d = c.coordDim, p = c.type, v = 0;
      $(a, function(y) {
        y.coordDim === d && v++;
      });
      var g = {
        name: h,
        coordDim: d,
        coordDimIndex: v,
        type: p,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: a.length
      }, m = {
        name: f,
        coordDim: f,
        coordDimIndex: v + 1,
        type: p,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: a.length + 1
      };
      o ? (s && (g.storeDimIndex = s.ensureCalculationDimension(f, p), m.storeDimIndex = s.ensureCalculationDimension(h, p)), o.appendCalculationDimension(g), o.appendCalculationDimension(m)) : (a.push(g), a.push(m));
    }
    return {
      stackedDimension: c && c.name,
      stackedByDimension: u && u.name,
      isStackedByIndex: n,
      stackedOverDimension: f,
      stackResultDimension: h
    };
  }
  function bne(t) {
    return !I5(t.schema);
  }
  function vs(t, e) {
    return !!e && e === t.getCalculationInfo("stackedDimension");
  }
  function k5(t, e) {
    return vs(t, e) ? t.getCalculationInfo("stackResultDimension") : e;
  }
  function xne(t, e) {
    var r = t.get("coordinateSystem"), n = Nd.get(r), i;
    return e && e.coordSysDims && (i = oe(e.coordSysDims, function(a) {
      var o = {
        name: a
      }, s = e.axisMap.get(a);
      if (s) {
        var l = s.get("type");
        o.type = Ug(l);
      }
      return o;
    })), i || (i = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || [
      "x",
      "y"
    ]), i;
  }
  function wne(t, e, r) {
    var n, i;
    return r && $(t, function(a, o) {
      var s = a.coordDim, l = r.categoryAxisMap.get(s);
      l && (n == null && (n = o), a.ordinalMeta = l.getOrdinalMeta(), e && (a.createInvertedIndices = true)), a.otherDims.itemName != null && (i = true);
    }), !i && n != null && (t[n].otherDims.itemName = 0), n;
  }
  function So(t, e, r) {
    r = r || {};
    var n = e.getSourceManager(), i, a = false;
    t ? (a = true, i = DT(t)) : (i = n.getSource(), a = i.sourceFormat === wi);
    var o = mne(e), s = xne(e, o), l = r.useEncodeDefaulter, u = De(l) ? l : l ? Ye(bV, s, e) : null, c = {
      coordDimensions: s,
      generateCoord: r.generateCoord,
      encodeDefine: e.getEncode(),
      encodeDefaulter: u,
      canOmitUnusedDimensions: !a
    }, h = zd(i, c), f = wne(h.dimensions, r.createInvertedIndices, o), d = a ? null : n.getSharedDataStore(h), p = _ne(e, {
      schema: h,
      store: d
    }), v = new yn(h, e);
    v.setCalculationInfo(p);
    var g = f != null && Sne(i) ? function(m, y, _, b) {
      return b === f ? _ : this.defaultDimValueGetter(m, y, _, b);
    } : null;
    return v.hasItemOption = false, v.initData(a ? i : d, null, g), v;
  }
  function Sne(t) {
    if (t.sourceFormat === wi) {
      var e = Tne(t.data || []);
      return !ae(Fc(e));
    }
  }
  function Tne(t) {
    for (var e = 0; e < t.length && t[e] == null; ) e++;
    return t[e];
  }
  var za = function() {
    function t(e) {
      this._setting = e || {}, this._extent = [
        1 / 0,
        -1 / 0
      ];
    }
    return t.prototype.getSetting = function(e) {
      return this._setting[e];
    }, t.prototype.unionExtent = function(e) {
      var r = this._extent;
      e[0] < r[0] && (r[0] = e[0]), e[1] > r[1] && (r[1] = e[1]);
    }, t.prototype.unionExtentFromData = function(e, r) {
      this.unionExtent(e.getApproximateExtent(r));
    }, t.prototype.getExtent = function() {
      return this._extent.slice();
    }, t.prototype.setExtent = function(e, r) {
      var n = this._extent;
      isNaN(e) || (n[0] = e), isNaN(r) || (n[1] = r);
    }, t.prototype.isInExtentRange = function(e) {
      return this._extent[0] <= e && this._extent[1] >= e;
    }, t.prototype.isBlank = function() {
      return this._isBlank;
    }, t.prototype.setBlank = function(e) {
      this._isBlank = e;
    }, t;
  }();
  Vm(za);
  var Cne = 0, Zx = function() {
    function t(e) {
      this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++Cne;
    }
    return t.createByAxisModel = function(e) {
      var r = e.option, n = r.data, i = n && oe(n, Ane);
      return new t({
        categories: i,
        needCollect: !i,
        deduplication: r.dedplication !== false
      });
    }, t.prototype.getOrdinal = function(e) {
      return this._getOrCreateMap().get(e);
    }, t.prototype.parseAndCollect = function(e) {
      var r, n = this._needCollect;
      if (!me(e) && !n) return e;
      if (n && !this._deduplication) return r = this.categories.length, this.categories[r] = e, r;
      var i = this._getOrCreateMap();
      return r = i.get(e), r == null && (n ? (r = this.categories.length, this.categories[r] = e, i.set(e, r)) : r = NaN), r;
    }, t.prototype._getOrCreateMap = function() {
      return this._map || (this._map = Ce(this.categories));
    }, t;
  }();
  function Ane(t) {
    return Le(t) && t.value != null ? t.value : t + "";
  }
  function Qx(t) {
    return t.type === "interval" || t.type === "log";
  }
  function Ine(t, e, r, n) {
    var i = {}, a = t[1] - t[0], o = i.interval = a4(a / e);
    r != null && o < r && (o = i.interval = r), n != null && o > n && (o = i.interval = n);
    var s = i.intervalPrecision = P5(o), l = i.niceTickExtent = [
      lr(Math.ceil(t[0] / o) * o, s),
      lr(Math.floor(t[1] / o) * o, s)
    ];
    return Mne(l, t), i;
  }
  function Q0(t) {
    var e = Math.pow(10, rT(t)), r = t / e;
    return r ? r === 2 ? r = 3 : r === 3 ? r = 5 : r *= 2 : r = 1, lr(r * e);
  }
  function P5(t) {
    return wa(t) + 2;
  }
  function XE(t, e, r) {
    t[e] = Math.max(Math.min(t[e], r[1]), r[0]);
  }
  function Mne(t, e) {
    !isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), XE(t, 0, e), XE(t, 1, e), t[0] > t[1] && (t[0] = t[1]);
  }
  function ly(t, e) {
    return t >= e[0] && t <= e[1];
  }
  function uy(t, e) {
    return e[1] === e[0] ? 0.5 : (t - e[0]) / (e[1] - e[0]);
  }
  function cy(t, e) {
    return t * (e[1] - e[0]) + e[0];
  }
  var hy = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      n.type = "ordinal";
      var i = n.getSetting("ordinalMeta");
      return i || (i = new Zx({})), ae(i) && (i = new Zx({
        categories: oe(i, function(a) {
          return Le(a) ? a.value : a;
        })
      })), n._ordinalMeta = i, n._extent = n.getSetting("extent") || [
        0,
        i.categories.length - 1
      ], n;
    }
    return e.prototype.parse = function(r) {
      return r == null ? NaN : me(r) ? this._ordinalMeta.getOrdinal(r) : Math.round(r);
    }, e.prototype.contain = function(r) {
      return r = this.parse(r), ly(r, this._extent) && this._ordinalMeta.categories[r] != null;
    }, e.prototype.normalize = function(r) {
      return r = this._getTickNumber(this.parse(r)), uy(r, this._extent);
    }, e.prototype.scale = function(r) {
      return r = Math.round(cy(r, this._extent)), this.getRawOrdinalNumber(r);
    }, e.prototype.getTicks = function() {
      for (var r = [], n = this._extent, i = n[0]; i <= n[1]; ) r.push({
        value: i
      }), i++;
      return r;
    }, e.prototype.getMinorTicks = function(r) {
    }, e.prototype.setSortInfo = function(r) {
      if (r == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var n = r.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, n.length); o < l; ++o) {
        var u = n[o];
        i[o] = u, a[u] = o;
      }
      for (var c = 0; o < s; ++o) {
        for (; a[c] != null; ) c++;
        i.push(c), a[c] = o;
      }
    }, e.prototype._getTickNumber = function(r) {
      var n = this._ticksByOrdinalNumber;
      return n && r >= 0 && r < n.length ? n[r] : r;
    }, e.prototype.getRawOrdinalNumber = function(r) {
      var n = this._ordinalNumbersByTick;
      return n && r >= 0 && r < n.length ? n[r] : r;
    }, e.prototype.getLabel = function(r) {
      if (!this.isBlank()) {
        var n = this.getRawOrdinalNumber(r.value), i = this._ordinalMeta.categories[n];
        return i == null ? "" : i + "";
      }
    }, e.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, e.prototype.unionExtentFromData = function(r, n) {
      this.unionExtent(r.getApproximateExtent(n));
    }, e.prototype.isInExtentRange = function(r) {
      return r = this._getTickNumber(r), this._extent[0] <= r && this._extent[1] >= r;
    }, e.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, e.prototype.calcNiceTicks = function() {
    }, e.prototype.calcNiceExtent = function() {
    }, e.type = "ordinal", e;
  }(za);
  za.registerClass(hy);
  var Ys = lr, go = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = "interval", r._interval = 0, r._intervalPrecision = 2, r;
    }
    return e.prototype.parse = function(r) {
      return r;
    }, e.prototype.contain = function(r) {
      return ly(r, this._extent);
    }, e.prototype.normalize = function(r) {
      return uy(r, this._extent);
    }, e.prototype.scale = function(r) {
      return cy(r, this._extent);
    }, e.prototype.setExtent = function(r, n) {
      var i = this._extent;
      isNaN(r) || (i[0] = parseFloat(r)), isNaN(n) || (i[1] = parseFloat(n));
    }, e.prototype.unionExtent = function(r) {
      var n = this._extent;
      r[0] < n[0] && (n[0] = r[0]), r[1] > n[1] && (n[1] = r[1]), this.setExtent(n[0], n[1]);
    }, e.prototype.getInterval = function() {
      return this._interval;
    }, e.prototype.setInterval = function(r) {
      this._interval = r, this._niceExtent = this._extent.slice(), this._intervalPrecision = P5(r);
    }, e.prototype.getTicks = function(r) {
      var n = this._interval, i = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
      if (!n) return s;
      var l = 1e4;
      i[0] < a[0] && (r ? s.push({
        value: Ys(a[0] - n, o)
      }) : s.push({
        value: i[0]
      }));
      for (var u = a[0]; u <= a[1] && (s.push({
        value: u
      }), u = Ys(u + n, o), u !== s[s.length - 1].value); ) if (s.length > l) return [];
      var c = s.length ? s[s.length - 1].value : a[1];
      return i[1] > c && (r ? s.push({
        value: Ys(c + n, o)
      }) : s.push({
        value: i[1]
      })), s;
    }, e.prototype.getMinorTicks = function(r) {
      for (var n = this.getTicks(true), i = [], a = this.getExtent(), o = 1; o < n.length; o++) {
        for (var s = n[o], l = n[o - 1], u = 0, c = [], h = s.value - l.value, f = h / r; u < r - 1; ) {
          var d = Ys(l.value + (u + 1) * f);
          d > a[0] && d < a[1] && c.push(d), u++;
        }
        i.push(c);
      }
      return i;
    }, e.prototype.getLabel = function(r, n) {
      if (r == null) return "";
      var i = n && n.precision;
      i == null ? i = wa(r.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var a = Ys(r.value, i, true);
      return hV(a);
    }, e.prototype.calcNiceTicks = function(r, n, i) {
      r = r || 5;
      var a = this._extent, o = a[1] - a[0];
      if (isFinite(o)) {
        o < 0 && (o = -o, a.reverse());
        var s = Ine(a, r, n, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, e.prototype.calcNiceExtent = function(r) {
      var n = this._extent;
      if (n[0] === n[1]) if (n[0] !== 0) {
        var i = Math.abs(n[0]);
        r.fixMax || (n[1] += i / 2), n[0] -= i / 2;
      } else n[1] = 1;
      var a = n[1] - n[0];
      isFinite(a) || (n[0] = 0, n[1] = 1), this.calcNiceTicks(r.splitNumber, r.minInterval, r.maxInterval);
      var o = this._interval;
      r.fixMin || (n[0] = Ys(Math.floor(n[0] / o) * o)), r.fixMax || (n[1] = Ys(Math.ceil(n[1] / o) * o));
    }, e.prototype.setNiceExtent = function(r, n) {
      this._niceExtent = [
        r,
        n
      ];
    }, e.type = "interval", e;
  }(za);
  za.registerClass(go);
  var L5 = typeof Float32Array < "u", Dne = L5 ? Float32Array : Array;
  function Ta(t) {
    return ae(t) ? L5 ? new Float32Array(t) : t : new Dne(t);
  }
  var Jx = "__ec_stack_";
  function $5(t) {
    return t.get("stack") || Jx + t.seriesIndex;
  }
  function FT(t) {
    return t.dim + t.index;
  }
  function Ene(t) {
    var e = [], r = t.axis, n = "axis0";
    if (r.type === "category") {
      for (var i = r.getBandWidth(), a = 0; a < t.count; a++) e.push(Ee({
        bandWidth: i,
        axisKey: n,
        stackId: Jx + a
      }, t));
      for (var o = N5(e), s = [], a = 0; a < t.count; a++) {
        var l = o[n][Jx + a];
        l.offsetCenter = l.offset + l.width / 2, s.push(l);
      }
      return s;
    }
  }
  function R5(t, e) {
    var r = [];
    return e.eachSeriesByType(t, function(n) {
      F5(n) && r.push(n);
    }), r;
  }
  function kne(t) {
    var e = {};
    $(t, function(l) {
      var u = l.coordinateSystem, c = u.getBaseAxis();
      if (!(c.type !== "time" && c.type !== "value")) for (var h = l.getData(), f = c.dim + "_" + c.index, d = h.getDimensionIndex(h.mapDimension(c.dim)), p = h.getStore(), v = 0, g = p.count(); v < g; ++v) {
        var m = p.get(d, v);
        e[f] ? e[f].push(m) : e[f] = [
          m
        ];
      }
    });
    var r = {};
    for (var n in e) if (e.hasOwnProperty(n)) {
      var i = e[n];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, o = 1; o < i.length; ++o) {
          var s = i[o] - i[o - 1];
          s > 0 && (a = a === null ? s : Math.min(a, s));
        }
        r[n] = a;
      }
    }
    return r;
  }
  function O5(t) {
    var e = kne(t), r = [];
    return $(t, function(n) {
      var i = n.coordinateSystem, a = i.getBaseAxis(), o = a.getExtent(), s;
      if (a.type === "category") s = a.getBandWidth();
      else if (a.type === "value" || a.type === "time") {
        var l = a.dim + "_" + a.index, u = e[l], c = Math.abs(o[1] - o[0]), h = a.scale.getExtent(), f = Math.abs(h[1] - h[0]);
        s = u ? c / f * u : c;
      } else {
        var d = n.getData();
        s = Math.abs(o[1] - o[0]) / d.count();
      }
      var p = pe(n.get("barWidth"), s), v = pe(n.get("barMaxWidth"), s), g = pe(n.get("barMinWidth") || (V5(n) ? 0.5 : 1), s), m = n.get("barGap"), y = n.get("barCategoryGap");
      r.push({
        bandWidth: s,
        barWidth: p,
        barMaxWidth: v,
        barMinWidth: g,
        barGap: m,
        barCategoryGap: y,
        axisKey: FT(a),
        stackId: $5(n)
      });
    }), N5(r);
  }
  function N5(t) {
    var e = {};
    $(t, function(n, i) {
      var a = n.axisKey, o = n.bandWidth, s = e[a] || {
        bandWidth: o,
        remainedWidth: o,
        autoWidthCount: 0,
        categoryGap: null,
        gap: "20%",
        stacks: {}
      }, l = s.stacks;
      e[a] = s;
      var u = n.stackId;
      l[u] || s.autoWidthCount++, l[u] = l[u] || {
        width: 0,
        maxWidth: 0
      };
      var c = n.barWidth;
      c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
      var h = n.barMaxWidth;
      h && (l[u].maxWidth = h);
      var f = n.barMinWidth;
      f && (l[u].minWidth = f);
      var d = n.barGap;
      d != null && (s.gap = d);
      var p = n.barCategoryGap;
      p != null && (s.categoryGap = p);
    });
    var r = {};
    return $(e, function(n, i) {
      r[i] = {};
      var a = n.stacks, o = n.bandWidth, s = n.categoryGap;
      if (s == null) {
        var l = gt(a).length;
        s = Math.max(35 - l * 4, 15) + "%";
      }
      var u = pe(s, o), c = pe(n.gap, 1), h = n.remainedWidth, f = n.autoWidthCount, d = (h - u) / (f + (f - 1) * c);
      d = Math.max(d, 0), $(a, function(m) {
        var y = m.maxWidth, _ = m.minWidth;
        if (m.width) {
          var b = m.width;
          y && (b = Math.min(b, y)), _ && (b = Math.max(b, _)), m.width = b, h -= b + c * b, f--;
        } else {
          var b = d;
          y && y < b && (b = Math.min(y, h)), _ && _ > b && (b = _), b !== d && (m.width = b, h -= b + c * b, f--);
        }
      }), d = (h - u) / (f + (f - 1) * c), d = Math.max(d, 0);
      var p = 0, v;
      $(a, function(m, y) {
        m.width || (m.width = d), v = m, p += m.width * (1 + c);
      }), v && (p -= v.width * c);
      var g = -p / 2;
      $(a, function(m, y) {
        r[i][y] = r[i][y] || {
          bandWidth: o,
          offset: g,
          width: m.width
        }, g += m.width * (1 + c);
      });
    }), r;
  }
  function Pne(t, e, r) {
    if (t && e) {
      var n = t[FT(e)];
      return n;
    }
  }
  function B5(t, e) {
    var r = R5(t, e), n = O5(r);
    $(r, function(i) {
      var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = $5(i), u = n[FT(s)][l], c = u.offset, h = u.width;
      a.setLayout({
        bandWidth: u.bandWidth,
        offset: c,
        size: h
      });
    });
  }
  function z5(t) {
    return {
      seriesType: t,
      plan: Xc(),
      reset: function(e) {
        if (F5(e)) {
          var r = e.getData(), n = e.coordinateSystem, i = n.getBaseAxis(), a = n.getOtherAxis(i), o = r.getDimensionIndex(r.mapDimension(a.dim)), s = r.getDimensionIndex(r.mapDimension(i.dim)), l = e.get("showBackground", true), u = r.mapDimension(a.dim), c = r.getCalculationInfo("stackResultDimension"), h = vs(r, u) && !!r.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), d = Lne(i, a), p = V5(e), v = e.get("barMinHeight") || 0, g = c && r.getDimensionIndex(c), m = r.getLayout("size"), y = r.getLayout("offset");
          return {
            progress: function(_, b) {
              for (var w = _.count, x = p && Ta(w * 3), T = p && l && Ta(w * 3), A = p && Ta(w), I = n.master.getRect(), M = f ? I.width : I.height, k, B = b.getStore(), L = 0; (k = _.next()) != null; ) {
                var z = B.get(h ? g : o, k), F = B.get(s, k), E = d, O = void 0;
                h && (O = +z - B.get(o, k));
                var N = void 0, V = void 0, H = void 0, G = void 0;
                if (f) {
                  var Y = n.dataToPoint([
                    z,
                    F
                  ]);
                  if (h) {
                    var U = n.dataToPoint([
                      O,
                      F
                    ]);
                    E = U[0];
                  }
                  N = E, V = Y[1] + y, H = Y[0] - E, G = m, Math.abs(H) < v && (H = (H < 0 ? -1 : 1) * v);
                } else {
                  var Y = n.dataToPoint([
                    F,
                    z
                  ]);
                  if (h) {
                    var U = n.dataToPoint([
                      F,
                      O
                    ]);
                    E = U[1];
                  }
                  N = Y[0] + y, V = E, H = m, G = Y[1] - E, Math.abs(G) < v && (G = (G <= 0 ? -1 : 1) * v);
                }
                p ? (x[L] = N, x[L + 1] = V, x[L + 2] = f ? H : G, T && (T[L] = f ? I.x : N, T[L + 1] = f ? V : I.y, T[L + 2] = M), A[k] = k) : b.setItemLayout(k, {
                  x: N,
                  y: V,
                  width: H,
                  height: G
                }), L += 3;
              }
              p && b.setLayout({
                largePoints: x,
                largeDataIndices: A,
                largeBackgroundPoints: T,
                valueAxisHorizontal: f
              });
            }
          };
        }
      }
    };
  }
  function F5(t) {
    return t.coordinateSystem && t.coordinateSystem.type === "cartesian2d";
  }
  function V5(t) {
    return t.pipelineContext && t.pipelineContext.large;
  }
  function Lne(t, e) {
    var r = e.model.get("startValue");
    return r || (r = 0), e.toGlobalCoord(e.dataToCoord(e.type === "log" ? r > 0 ? r : 1 : r));
  }
  var $ne = function(t, e, r, n) {
    for (; r < n; ) {
      var i = r + n >>> 1;
      t[i][1] < e ? r = i + 1 : n = i;
    }
    return r;
  }, VT = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "time", n;
    }
    return e.prototype.getLabel = function(r) {
      var n = this.getSetting("useUTC");
      return Qm(r.value, BD[pee(dc(this._minLevelUnit))] || BD.second, n, this.getSetting("locale"));
    }, e.prototype.getFormattedLabel = function(r, n, i) {
      var a = this.getSetting("useUTC"), o = this.getSetting("locale");
      return vee(r, n, i, o, a);
    }, e.prototype.getTicks = function() {
      var r = this._interval, n = this._extent, i = [];
      if (!r) return i;
      i.push({
        value: n[0],
        level: 0
      });
      var a = this.getSetting("useUTC"), o = Vne(this._minLevelUnit, this._approxInterval, a, n);
      return i = i.concat(o), i.push({
        value: n[1],
        level: 0
      }), i;
    }, e.prototype.calcNiceExtent = function(r) {
      var n = this._extent;
      if (n[0] === n[1] && (n[0] -= gi, n[1] += gi), n[1] === -1 / 0 && n[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        n[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), n[0] = n[1] - gi;
      }
      this.calcNiceTicks(r.splitNumber, r.minInterval, r.maxInterval);
    }, e.prototype.calcNiceTicks = function(r, n, i) {
      r = r || 10;
      var a = this._extent, o = a[1] - a[0];
      this._approxInterval = o / r, n != null && this._approxInterval < n && (this._approxInterval = n), i != null && this._approxInterval > i && (this._approxInterval = i);
      var s = Fp.length, l = Math.min($ne(Fp, this._approxInterval, 0, s), s - 1);
      this._interval = Fp[l][1], this._minLevelUnit = Fp[Math.max(l - 1, 0)][0];
    }, e.prototype.parse = function(r) {
      return xt(r) ? r : +$a(r);
    }, e.prototype.contain = function(r) {
      return ly(this.parse(r), this._extent);
    }, e.prototype.normalize = function(r) {
      return uy(this.parse(r), this._extent);
    }, e.prototype.scale = function(r) {
      return cy(r, this._extent);
    }, e.type = "time", e;
  }(go), Fp = [
    [
      "second",
      bT
    ],
    [
      "minute",
      xT
    ],
    [
      "hour",
      Af
    ],
    [
      "quarter-day",
      Af * 6
    ],
    [
      "half-day",
      Af * 12
    ],
    [
      "day",
      gi * 1.2
    ],
    [
      "half-week",
      gi * 3.5
    ],
    [
      "week",
      gi * 7
    ],
    [
      "month",
      gi * 31
    ],
    [
      "quarter",
      gi * 95
    ],
    [
      "half-year",
      ND / 2
    ],
    [
      "year",
      ND
    ]
  ];
  function Rne(t, e, r, n) {
    var i = $a(e), a = $a(r), o = function(p) {
      return zD(i, p, n) === zD(a, p, n);
    }, s = function() {
      return o("year");
    }, l = function() {
      return s() && o("month");
    }, u = function() {
      return l() && o("day");
    }, c = function() {
      return u() && o("hour");
    }, h = function() {
      return c() && o("minute");
    }, f = function() {
      return h() && o("second");
    }, d = function() {
      return f() && o("millisecond");
    };
    switch (t) {
      case "year":
        return s();
      case "month":
        return l();
      case "day":
        return u();
      case "hour":
        return c();
      case "minute":
        return h();
      case "second":
        return f();
      case "millisecond":
        return d();
    }
  }
  function One(t, e) {
    return t /= gi, t > 16 ? 16 : t > 7.5 ? 7 : t > 3.5 ? 4 : t > 1.5 ? 2 : 1;
  }
  function Nne(t) {
    var e = 30 * gi;
    return t /= e, t > 6 ? 6 : t > 3 ? 3 : t > 2 ? 2 : 1;
  }
  function Bne(t) {
    return t /= Af, t > 12 ? 12 : t > 6 ? 6 : t > 3.5 ? 4 : t > 2 ? 2 : 1;
  }
  function jE(t, e) {
    return t /= e ? xT : bT, t > 30 ? 30 : t > 20 ? 20 : t > 15 ? 15 : t > 10 ? 10 : t > 5 ? 5 : t > 2 ? 2 : 1;
  }
  function zne(t) {
    return a4(t);
  }
  function Fne(t, e, r) {
    var n = new Date(t);
    switch (dc(e)) {
      case "year":
      case "month":
        n[aV(r)](0);
      case "day":
        n[oV(r)](1);
      case "hour":
        n[sV(r)](0);
      case "minute":
        n[lV(r)](0);
      case "second":
        n[uV(r)](0), n[cV(r)](0);
    }
    return n.getTime();
  }
  function Vne(t, e, r, n) {
    var i = 1e4, a = nV, o = 0;
    function s(M, k, B, L, z, F, E) {
      for (var O = new Date(k), N = k, V = O[L](); N < B && N <= n[1]; ) E.push({
        value: N
      }), V += M, O[z](V), N = O.getTime();
      E.push({
        value: N,
        notAdd: true
      });
    }
    function l(M, k, B) {
      var L = [], z = !k.length;
      if (!Rne(dc(M), n[0], n[1], r)) {
        z && (k = [
          {
            value: Fne(new Date(n[0]), M, r)
          },
          {
            value: n[1]
          }
        ]);
        for (var F = 0; F < k.length - 1; F++) {
          var E = k[F].value, O = k[F + 1].value;
          if (E !== O) {
            var N = void 0, V = void 0, H = void 0, G = false;
            switch (M) {
              case "year":
                N = Math.max(1, Math.round(e / gi / 365)), V = wT(r), H = gee(r);
                break;
              case "half-year":
              case "quarter":
              case "month":
                N = Nne(e), V = pc(r), H = aV(r);
                break;
              case "week":
              case "half-week":
              case "day":
                N = One(e), V = Jm(r), H = oV(r), G = true;
                break;
              case "half-day":
              case "quarter-day":
              case "hour":
                N = Bne(e), V = Kf(r), H = sV(r);
                break;
              case "minute":
                N = jE(e, true), V = ey(r), H = lV(r);
                break;
              case "second":
                N = jE(e, false), V = ty(r), H = uV(r);
                break;
              case "millisecond":
                N = zne(e), V = ry(r), H = cV(r);
                break;
            }
            s(N, E, O, V, H, G, L), M === "year" && B.length > 1 && F === 0 && B.unshift({
              value: B[0].value - N
            });
          }
        }
        for (var F = 0; F < L.length; F++) B.push(L[F]);
        return L;
      }
    }
    for (var u = [], c = [], h = 0, f = 0, d = 0; d < a.length && o++ < i; ++d) {
      var p = dc(a[d]);
      if (dee(a[d])) {
        l(a[d], u[u.length - 1] || [], c);
        var v = a[d + 1] ? dc(a[d + 1]) : null;
        if (p !== v) {
          if (c.length) {
            f = h, c.sort(function(M, k) {
              return M.value - k.value;
            });
            for (var g = [], m = 0; m < c.length; ++m) {
              var y = c[m].value;
              (m === 0 || c[m - 1].value !== y) && (g.push(c[m]), y >= n[0] && y <= n[1] && h++);
            }
            var _ = (n[1] - n[0]) / e;
            if (h > _ * 1.5 && f > _ / 1.5 || (u.push(g), h > _ || t === a[d])) break;
          }
          c = [];
        }
      }
    }
    for (var b = Dt(oe(u, function(M) {
      return Dt(M, function(k) {
        return k.value >= n[0] && k.value <= n[1] && !k.notAdd;
      });
    }), function(M) {
      return M.length > 0;
    }), w = [], x = b.length - 1, d = 0; d < b.length; ++d) for (var T = b[d], A = 0; A < T.length; ++A) w.push({
      value: T[A].value,
      level: x - d
    });
    w.sort(function(M, k) {
      return M.value - k.value;
    });
    for (var I = [], d = 0; d < w.length; ++d) (d === 0 || w[d].value !== w[d - 1].value) && I.push(w[d]);
    return I;
  }
  za.registerClass(VT);
  var KE = za.prototype, Ef = go.prototype, Gne = lr, Wne = Math.floor, Hne = Math.ceil, Vp = Math.pow, Mi = Math.log, GT = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = "log", r.base = 10, r._originalScale = new go(), r._interval = 0, r;
    }
    return e.prototype.getTicks = function(r) {
      var n = this._originalScale, i = this._extent, a = n.getExtent(), o = Ef.getTicks.call(this, r);
      return oe(o, function(s) {
        var l = s.value, u = lr(Vp(this.base, l));
        return u = l === i[0] && this._fixMin ? Gp(u, a[0]) : u, u = l === i[1] && this._fixMax ? Gp(u, a[1]) : u, {
          value: u
        };
      }, this);
    }, e.prototype.setExtent = function(r, n) {
      var i = Mi(this.base);
      r = Mi(Math.max(0, r)) / i, n = Mi(Math.max(0, n)) / i, Ef.setExtent.call(this, r, n);
    }, e.prototype.getExtent = function() {
      var r = this.base, n = KE.getExtent.call(this);
      n[0] = Vp(r, n[0]), n[1] = Vp(r, n[1]);
      var i = this._originalScale, a = i.getExtent();
      return this._fixMin && (n[0] = Gp(n[0], a[0])), this._fixMax && (n[1] = Gp(n[1], a[1])), n;
    }, e.prototype.unionExtent = function(r) {
      this._originalScale.unionExtent(r);
      var n = this.base;
      r[0] = Mi(r[0]) / Mi(n), r[1] = Mi(r[1]) / Mi(n), KE.unionExtent.call(this, r);
    }, e.prototype.unionExtentFromData = function(r, n) {
      this.unionExtent(r.getApproximateExtent(n));
    }, e.prototype.calcNiceTicks = function(r) {
      r = r || 10;
      var n = this._extent, i = n[1] - n[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var a = qZ(i), o = r / i * a;
        for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; ) a *= 10;
        var s = [
          lr(Hne(n[0] / a) * a),
          lr(Wne(n[1] / a) * a)
        ];
        this._interval = a, this._niceExtent = s;
      }
    }, e.prototype.calcNiceExtent = function(r) {
      Ef.calcNiceExtent.call(this, r), this._fixMin = r.fixMin, this._fixMax = r.fixMax;
    }, e.prototype.parse = function(r) {
      return r;
    }, e.prototype.contain = function(r) {
      return r = Mi(r) / Mi(this.base), ly(r, this._extent);
    }, e.prototype.normalize = function(r) {
      return r = Mi(r) / Mi(this.base), uy(r, this._extent);
    }, e.prototype.scale = function(r) {
      return r = cy(r, this._extent), Vp(this.base, r);
    }, e.type = "log", e;
  }(za), G5 = GT.prototype;
  G5.getMinorTicks = Ef.getMinorTicks;
  G5.getLabel = Ef.getLabel;
  function Gp(t, e) {
    return Gne(t, wa(e));
  }
  za.registerClass(GT);
  var Une = function() {
    function t(e, r, n) {
      this._prepareParams(e, r, n);
    }
    return t.prototype._prepareParams = function(e, r, n) {
      n[1] < n[0] && (n = [
        NaN,
        NaN
      ]), this._dataMin = n[0], this._dataMax = n[1];
      var i = this._isOrdinal = e.type === "ordinal";
      this._needCrossZero = e.type === "interval" && r.getNeedCrossZero && r.getNeedCrossZero();
      var a = r.get("min", true);
      a == null && (a = r.get("startValue", true));
      var o = this._modelMinRaw = a;
      De(o) ? this._modelMinNum = Wp(e, o({
        min: n[0],
        max: n[1]
      })) : o !== "dataMin" && (this._modelMinNum = Wp(e, o));
      var s = this._modelMaxRaw = r.get("max", true);
      if (De(s) ? this._modelMaxNum = Wp(e, s({
        min: n[0],
        max: n[1]
      })) : s !== "dataMax" && (this._modelMaxNum = Wp(e, s)), i) this._axisDataLen = r.getCategories().length;
      else {
        var l = r.get("boundaryGap"), u = ae(l) ? l : [
          l || 0,
          l || 0
        ];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? this._boundaryGapInner = [
          0,
          0
        ] : this._boundaryGapInner = [
          ji(u[0], 1),
          ji(u[1], 1)
        ];
      }
    }, t.prototype.calculate = function() {
      var e = this._isOrdinal, r = this._dataMin, n = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, o = e ? null : n - r || Math.abs(r), s = this._modelMinRaw === "dataMin" ? r : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? n : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = e ? i ? 0 : NaN : r - a[0] * o), l == null && (l = e ? i ? i - 1 : NaN : n + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var h = Ff(s) || Ff(l) || e && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var f = this._determinedMin, d = this._determinedMax;
      return f != null && (s = f, u = true), d != null && (l = d, c = true), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: h
      };
    }, t.prototype.modifyDataMinMax = function(e, r) {
      this[qne[e]] = r;
    }, t.prototype.setDeterminedMinMax = function(e, r) {
      var n = Yne[e];
      this[n] = r;
    }, t.prototype.freeze = function() {
      this.frozen = true;
    }, t;
  }(), Yne = {
    min: "_determinedMin",
    max: "_determinedMax"
  }, qne = {
    min: "_dataMin",
    max: "_dataMax"
  };
  function W5(t, e, r) {
    var n = t.rawExtentInfo;
    return n || (n = new Une(t, e, r), t.rawExtentInfo = n, n);
  }
  function Wp(t, e) {
    return e == null ? null : Ff(e) ? NaN : t.parse(e);
  }
  function H5(t, e) {
    var r = t.type, n = W5(t, e, t.getExtent()).calculate();
    t.setBlank(n.isBlank);
    var i = n.min, a = n.max, o = e.ecModel;
    if (o && r === "time") {
      var s = R5("bar", o), l = false;
      if ($(s, function(h) {
        l = l || h.getBaseAxis() === e.axis;
      }), l) {
        var u = O5(s), c = Xne(i, a, e, u);
        i = c.min, a = c.max;
      }
    }
    return {
      extent: [
        i,
        a
      ],
      fixMin: n.minFixed,
      fixMax: n.maxFixed
    };
  }
  function Xne(t, e, r, n) {
    var i = r.axis.getExtent(), a = Math.abs(i[1] - i[0]), o = Pne(n, r.axis);
    if (o === void 0) return {
      min: t,
      max: e
    };
    var s = 1 / 0;
    $(o, function(d) {
      s = Math.min(d.offset, s);
    });
    var l = -1 / 0;
    $(o, function(d) {
      l = Math.max(d.offset + d.width, l);
    }), s = Math.abs(s), l = Math.abs(l);
    var u = s + l, c = e - t, h = 1 - (s + l) / a, f = c / h - c;
    return e += f * (l / u), t -= f * (s / u), {
      min: t,
      max: e
    };
  }
  function xc(t, e) {
    var r = e, n = H5(t, r), i = n.extent, a = r.get("splitNumber");
    t instanceof GT && (t.base = r.get("logBase"));
    var o = t.type, s = r.get("interval"), l = o === "interval" || o === "time";
    t.setExtent(i[0], i[1]), t.calcNiceExtent({
      splitNumber: a,
      fixMin: n.fixMin,
      fixMax: n.fixMax,
      minInterval: l ? r.get("minInterval") : null,
      maxInterval: l ? r.get("maxInterval") : null
    }), s != null && t.setInterval && t.setInterval(s);
  }
  function fy(t, e) {
    if (e = e || t.get("type"), e) switch (e) {
      case "category":
        return new hy({
          ordinalMeta: t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(),
          extent: [
            1 / 0,
            -1 / 0
          ]
        });
      case "time":
        return new VT({
          locale: t.ecModel.getLocaleModel(),
          useUTC: t.ecModel.get("useUTC")
        });
      default:
        return new (za.getClass(e) || go)();
    }
  }
  function jne(t) {
    var e = t.scale.getExtent(), r = e[0], n = e[1];
    return !(r > 0 && n > 0 || r < 0 && n < 0);
  }
  function Zc(t) {
    var e = t.getLabelModel().get("formatter"), r = t.type === "category" ? t.scale.getExtent()[0] : null;
    return t.scale.type === "time" ? /* @__PURE__ */ function(n) {
      return function(i, a) {
        return t.scale.getFormattedLabel(i, a, n);
      };
    }(e) : me(e) ? /* @__PURE__ */ function(n) {
      return function(i) {
        var a = t.scale.getLabel(i), o = n.replace("{value}", a ?? "");
        return o;
      };
    }(e) : De(e) ? /* @__PURE__ */ function(n) {
      return function(i, a) {
        return r != null && (a = i.value - r), n(WT(t, i), a, i.level != null ? {
          level: i.level
        } : null);
      };
    }(e) : function(n) {
      return t.scale.getLabel(n);
    };
  }
  function WT(t, e) {
    return t.type === "category" ? t.scale.getLabel(e) : e.value;
  }
  function Kne(t) {
    var e = t.model, r = t.scale;
    if (!(!e.get([
      "axisLabel",
      "show"
    ]) || r.isBlank())) {
      var n, i, a = r.getExtent();
      r instanceof hy ? i = r.count() : (n = r.getTicks(), i = n.length);
      var o = t.getLabelModel(), s = Zc(t), l, u = 1;
      i > 40 && (u = Math.ceil(i / 40));
      for (var c = 0; c < i; c += u) {
        var h = n ? n[c] : {
          value: a[0] + c
        }, f = s(h, c), d = o.getTextRect(f), p = Zne(d, o.get("rotate") || 0);
        l ? l.union(p) : l = p;
      }
      return l;
    }
  }
  function Zne(t, e) {
    var r = e * Math.PI / 180, n = t.width, i = t.height, a = n * Math.abs(Math.cos(r)) + Math.abs(i * Math.sin(r)), o = n * Math.abs(Math.sin(r)) + Math.abs(i * Math.cos(r)), s = new Ze(t.x, t.y, a, o);
    return s;
  }
  function HT(t) {
    var e = t.get("interval");
    return e ?? "auto";
  }
  function U5(t) {
    return t.type === "category" && HT(t.getLabelModel()) === 0;
  }
  function Yg(t, e) {
    var r = {};
    return $(t.mapDimensionsAll(e), function(n) {
      r[k5(t, n)] = true;
    }), gt(r);
  }
  function Qne(t, e, r) {
    e && $(Yg(e, r), function(n) {
      var i = e.getApproximateExtent(n);
      i[0] < t[0] && (t[0] = i[0]), i[1] > t[1] && (t[1] = i[1]);
    });
  }
  var Fd = function() {
    function t() {
    }
    return t.prototype.getNeedCrossZero = function() {
      var e = this.option;
      return !e.scale;
    }, t.prototype.getCoordSysModel = function() {
    }, t;
  }(), Jne = 1e-8;
  function ZE(t, e) {
    return Math.abs(t - e) < Jne;
  }
  function vl(t, e, r) {
    var n = 0, i = t[0];
    if (!i) return false;
    for (var a = 1; a < t.length; a++) {
      var o = t[a];
      n += Za(i[0], i[1], o[0], o[1], e, r), i = o;
    }
    var s = t[0];
    return (!ZE(i[0], s[0]) || !ZE(i[1], s[1])) && (n += Za(i[0], i[1], s[0], s[1], e, r)), n !== 0;
  }
  var eie = [];
  function J0(t, e) {
    for (var r = 0; r < t.length; r++) Ur(t[r], t[r], e);
  }
  function QE(t, e, r, n) {
    for (var i = 0; i < t.length; i++) {
      var a = t[i];
      n && (a = n.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Ko(e, e, a), Zo(r, r, a));
    }
  }
  function tie(t) {
    for (var e = 0, r = 0, n = 0, i = t.length, a = t[i - 1][0], o = t[i - 1][1], s = 0; s < i; s++) {
      var l = t[s][0], u = t[s][1], c = a * u - l * o;
      e += c, r += (a + l) * c, n += (o + u) * c, a = l, o = u;
    }
    return e ? [
      r / e / 3,
      n / e / 3,
      e
    ] : [
      t[0][0] || 0,
      t[0][1] || 0
    ];
  }
  var Y5 = function() {
    function t(e) {
      this.name = e;
    }
    return t.prototype.setCenter = function(e) {
      this._center = e;
    }, t.prototype.getCenter = function() {
      var e = this._center;
      return e || (e = this._center = this.calcCenter()), e;
    }, t;
  }(), JE = /* @__PURE__ */ function() {
    function t(e, r) {
      this.type = "polygon", this.exterior = e, this.interiors = r;
    }
    return t;
  }(), ek = /* @__PURE__ */ function() {
    function t(e) {
      this.type = "linestring", this.points = e;
    }
    return t;
  }(), q5 = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this, r) || this;
      return a.type = "geoJSON", a.geometries = n, a._center = i && [
        i[0],
        i[1]
      ], a;
    }
    return e.prototype.calcCenter = function() {
      for (var r = this.geometries, n, i = 0, a = 0; a < r.length; a++) {
        var o = r[a], s = o.exterior, l = s && s.length;
        l > i && (n = o, i = l);
      }
      if (n) return tie(n.exterior);
      var u = this.getBoundingRect();
      return [
        u.x + u.width / 2,
        u.y + u.height / 2
      ];
    }, e.prototype.getBoundingRect = function(r) {
      var n = this._rect;
      if (n && !r) return n;
      var i = [
        1 / 0,
        1 / 0
      ], a = [
        -1 / 0,
        -1 / 0
      ], o = this.geometries;
      return $(o, function(s) {
        s.type === "polygon" ? QE(s.exterior, i, a, r) : $(s.points, function(l) {
          QE(l, i, a, r);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), n = new Ze(i[0], i[1], a[0] - i[0], a[1] - i[1]), r || (this._rect = n), n;
    }, e.prototype.contain = function(r) {
      var n = this.getBoundingRect(), i = this.geometries;
      if (!n.contain(r[0], r[1])) return false;
      e: for (var a = 0, o = i.length; a < o; a++) {
        var s = i[a];
        if (s.type === "polygon") {
          var l = s.exterior, u = s.interiors;
          if (vl(l, r[0], r[1])) {
            for (var c = 0; c < (u ? u.length : 0); c++) if (vl(u[c], r[0], r[1])) continue e;
            return true;
          }
        }
      }
      return false;
    }, e.prototype.transformTo = function(r, n, i, a) {
      var o = this.getBoundingRect(), s = o.width / o.height;
      i ? a || (a = i / s) : i = s * a;
      for (var l = new Ze(r, n, i, a), u = o.calculateTransform(l), c = this.geometries, h = 0; h < c.length; h++) {
        var f = c[h];
        f.type === "polygon" ? (J0(f.exterior, u), $(f.interiors, function(d) {
          J0(d, u);
        })) : $(f.points, function(d) {
          J0(d, u);
        });
      }
      o = this._rect, o.copy(l), this._center = [
        o.x + o.width / 2,
        o.y + o.height / 2
      ];
    }, e.prototype.cloneShallow = function(r) {
      r == null && (r = this.name);
      var n = new e(r, this.geometries, this._center);
      return n._rect = this._rect, n.transformTo = null, n;
    }, e;
  }(Y5), rie = function(t) {
    K(e, t);
    function e(r, n) {
      var i = t.call(this, r) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = n, i;
    }
    return e.prototype.calcCenter = function() {
      for (var r = this._elOnlyForCalculate, n = r.getBoundingRect(), i = [
        n.x + n.width / 2,
        n.y + n.height / 2
      ], a = Nm(eie), o = r; o && !o.isGeoSVGGraphicRoot; ) io(a, o.getLocalTransform(), a), o = o.parent;
      return zc(a, a), Ur(i, i, a), i;
    }, e;
  }(Y5);
  function nie(t) {
    if (!t.UTF8Encoding) return t;
    var e = t, r = e.UTF8Scale;
    r == null && (r = 1024);
    var n = e.features;
    return $(n, function(i) {
      var a = i.geometry, o = a.encodeOffsets, s = a.coordinates;
      if (o) switch (a.type) {
        case "LineString":
          a.coordinates = X5(s, o, r);
          break;
        case "Polygon":
          e_(s, o, r);
          break;
        case "MultiLineString":
          e_(s, o, r);
          break;
        case "MultiPolygon":
          $(s, function(l, u) {
            return e_(l, o[u], r);
          });
      }
    }), e.UTF8Encoding = false, e;
  }
  function e_(t, e, r) {
    for (var n = 0; n < t.length; n++) t[n] = X5(t[n], e[n], r);
  }
  function X5(t, e, r) {
    for (var n = [], i = e[0], a = e[1], o = 0; o < t.length; o += 2) {
      var s = t.charCodeAt(o) - 64, l = t.charCodeAt(o + 1) - 64;
      s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += a, i = s, a = l, n.push([
        s / r,
        l / r
      ]);
    }
    return n;
  }
  function iie(t, e) {
    return t = nie(t), oe(Dt(t.features, function(r) {
      return r.geometry && r.properties && r.geometry.coordinates.length > 0;
    }), function(r) {
      var n = r.properties, i = r.geometry, a = [];
      switch (i.type) {
        case "Polygon":
          var o = i.coordinates;
          a.push(new JE(o[0], o.slice(1)));
          break;
        case "MultiPolygon":
          $(i.coordinates, function(l) {
            l[0] && a.push(new JE(l[0], l.slice(1)));
          });
          break;
        case "LineString":
          a.push(new ek([
            i.coordinates
          ]));
          break;
        case "MultiLineString":
          a.push(new ek(i.coordinates));
      }
      var s = new q5(n[e || "name"], a, n.cp);
      return s.properties = n, s;
    });
  }
  var rd = _t();
  function j5(t, e) {
    var r = oe(e, function(n) {
      return t.scale.parse(n);
    });
    return t.type === "time" && r.length > 0 && (r.sort(), r.unshift(r[0]), r.push(r[r.length - 1])), r;
  }
  function aie(t) {
    var e = t.getLabelModel().get("customValues");
    if (e) {
      var r = Zc(t), n = t.scale.getExtent(), i = j5(t, e), a = Dt(i, function(o) {
        return o >= n[0] && o <= n[1];
      });
      return {
        labels: oe(a, function(o) {
          var s = {
            value: o
          };
          return {
            formattedLabel: r(s),
            rawLabel: t.scale.getLabel(s),
            tickValue: o
          };
        })
      };
    }
    return t.type === "category" ? sie(t) : uie(t);
  }
  function oie(t, e) {
    var r = t.getTickModel().get("customValues");
    if (r) {
      var n = t.scale.getExtent(), i = j5(t, r);
      return {
        ticks: Dt(i, function(a) {
          return a >= n[0] && a <= n[1];
        })
      };
    }
    return t.type === "category" ? lie(t, e) : {
      ticks: oe(t.scale.getTicks(), function(a) {
        return a.value;
      })
    };
  }
  function sie(t) {
    var e = t.getLabelModel(), r = K5(t, e);
    return !e.get("show") || t.scale.isBlank() ? {
      labels: [],
      labelCategoryInterval: r.labelCategoryInterval
    } : r;
  }
  function K5(t, e) {
    var r = Z5(t, "labels"), n = HT(e), i = Q5(r, n);
    if (i) return i;
    var a, o;
    return De(n) ? a = tG(t, n) : (o = n === "auto" ? cie(t) : n, a = eG(t, o)), J5(r, n, {
      labels: a,
      labelCategoryInterval: o
    });
  }
  function lie(t, e) {
    var r = Z5(t, "ticks"), n = HT(e), i = Q5(r, n);
    if (i) return i;
    var a, o;
    if ((!e.get("show") || t.scale.isBlank()) && (a = []), De(n)) a = tG(t, n, true);
    else if (n === "auto") {
      var s = K5(t, t.getLabelModel());
      o = s.labelCategoryInterval, a = oe(s.labels, function(l) {
        return l.tickValue;
      });
    } else o = n, a = eG(t, o, true);
    return J5(r, n, {
      ticks: a,
      tickCategoryInterval: o
    });
  }
  function uie(t) {
    var e = t.scale.getTicks(), r = Zc(t);
    return {
      labels: oe(e, function(n, i) {
        return {
          level: n.level,
          formattedLabel: r(n, i),
          rawLabel: t.scale.getLabel(n),
          tickValue: n.value
        };
      })
    };
  }
  function Z5(t, e) {
    return rd(t)[e] || (rd(t)[e] = []);
  }
  function Q5(t, e) {
    for (var r = 0; r < t.length; r++) if (t[r].key === e) return t[r].value;
  }
  function J5(t, e, r) {
    return t.push({
      key: e,
      value: r
    }), r;
  }
  function cie(t) {
    var e = rd(t).autoInterval;
    return e ?? (rd(t).autoInterval = t.calculateCategoryInterval());
  }
  function hie(t) {
    var e = fie(t), r = Zc(t), n = (e.axisRotate - e.labelRotate) / 180 * Math.PI, i = t.scale, a = i.getExtent(), o = i.count();
    if (a[1] - a[0] < 1) return 0;
    var s = 1;
    o > 40 && (s = Math.max(1, Math.floor(o / 40)));
    for (var l = a[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), c = Math.abs(u * Math.cos(n)), h = Math.abs(u * Math.sin(n)), f = 0, d = 0; l <= a[1]; l += s) {
      var p = 0, v = 0, g = Dd(r({
        value: l
      }), e.font, "center", "top");
      p = g.width * 1.3, v = g.height * 1.3, f = Math.max(f, p, 7), d = Math.max(d, v, 7);
    }
    var m = f / c, y = d / h;
    isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0);
    var _ = Math.max(0, Math.floor(Math.min(m, y))), b = rd(t.model), w = t.getExtent(), x = b.lastAutoInterval, T = b.lastTickCount;
    return x != null && T != null && Math.abs(x - _) <= 1 && Math.abs(T - o) <= 1 && x > _ && b.axisExtent0 === w[0] && b.axisExtent1 === w[1] ? _ = x : (b.lastTickCount = o, b.lastAutoInterval = _, b.axisExtent0 = w[0], b.axisExtent1 = w[1]), _;
  }
  function fie(t) {
    var e = t.getLabelModel();
    return {
      axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0,
      labelRotate: e.get("rotate") || 0,
      font: e.getFont()
    };
  }
  function eG(t, e, r) {
    var n = Zc(t), i = t.scale, a = i.getExtent(), o = t.getLabelModel(), s = [], l = Math.max((e || 0) + 1, 1), u = a[0], c = i.count();
    u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
    var h = U5(t), f = o.get("showMinLabel") || h, d = o.get("showMaxLabel") || h;
    f && u !== a[0] && v(a[0]);
    for (var p = u; p <= a[1]; p += l) v(p);
    d && p - l !== a[1] && v(a[1]);
    function v(g) {
      var m = {
        value: g
      };
      s.push(r ? g : {
        formattedLabel: n(m),
        rawLabel: i.getLabel(m),
        tickValue: g
      });
    }
    return s;
  }
  function tG(t, e, r) {
    var n = t.scale, i = Zc(t), a = [];
    return $(n.getTicks(), function(o) {
      var s = n.getLabel(o), l = o.value;
      e(o.value, s) && a.push(r ? l : {
        formattedLabel: i(o),
        rawLabel: s,
        tickValue: l
      });
    }), a;
  }
  var tk = [
    0,
    1
  ], Ji = function() {
    function t(e, r, n) {
      this.onBand = false, this.inverse = false, this.dim = e, this.scale = r, this._extent = n || [
        0,
        0
      ];
    }
    return t.prototype.contain = function(e) {
      var r = this._extent, n = Math.min(r[0], r[1]), i = Math.max(r[0], r[1]);
      return e >= n && e <= i;
    }, t.prototype.containData = function(e) {
      return this.scale.contain(e);
    }, t.prototype.getExtent = function() {
      return this._extent.slice();
    }, t.prototype.getPixelPrecision = function(e) {
      return n4(e || this.scale.getExtent(), this._extent);
    }, t.prototype.setExtent = function(e, r) {
      var n = this._extent;
      n[0] = e, n[1] = r;
    }, t.prototype.dataToCoord = function(e, r) {
      var n = this._extent, i = this.scale;
      return e = i.normalize(e), this.onBand && i.type === "ordinal" && (n = n.slice(), rk(n, i.count())), Et(e, tk, n, r);
    }, t.prototype.coordToData = function(e, r) {
      var n = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (n = n.slice(), rk(n, i.count()));
      var a = Et(e, n, tk, r);
      return this.scale.scale(a);
    }, t.prototype.pointToData = function(e, r) {
    }, t.prototype.getTicksCoords = function(e) {
      e = e || {};
      var r = e.tickModel || this.getTickModel(), n = oie(this, r), i = n.ticks, a = oe(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), o = r.get("alignWithLabel");
      return die(this, a, o, e.clamp), a;
    }, t.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal") return [];
      var e = this.model.getModel("minorTick"), r = e.get("splitNumber");
      r > 0 && r < 100 || (r = 5);
      var n = this.scale.getMinorTicks(r), i = oe(n, function(a) {
        return oe(a, function(o) {
          return {
            coord: this.dataToCoord(o),
            tickValue: o
          };
        }, this);
      }, this);
      return i;
    }, t.prototype.getViewLabels = function() {
      return aie(this).labels;
    }, t.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, t.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, t.prototype.getBandWidth = function() {
      var e = this._extent, r = this.scale.getExtent(), n = r[1] - r[0] + (this.onBand ? 1 : 0);
      n === 0 && (n = 1);
      var i = Math.abs(e[1] - e[0]);
      return Math.abs(i) / n;
    }, t.prototype.calculateCategoryInterval = function() {
      return hie(this);
    }, t;
  }();
  function rk(t, e) {
    var r = t[1] - t[0], n = e, i = r / n / 2;
    t[0] += i, t[1] -= i;
  }
  function die(t, e, r, n) {
    var i = e.length;
    if (!t.onBand || r || !i) return;
    var a = t.getExtent(), o, s;
    if (i === 1) e[0].coord = a[0], o = e[1] = {
      coord: a[1],
      tickValue: e[0].tickValue
    };
    else {
      var l = e[i - 1].tickValue - e[0].tickValue, u = (e[i - 1].coord - e[0].coord) / l;
      $(e, function(d) {
        d.coord -= u / 2;
      });
      var c = t.scale.getExtent();
      s = 1 + c[1] - e[i - 1].tickValue, o = {
        coord: e[i - 1].coord + u * s,
        tickValue: c[1] + 1
      }, e.push(o);
    }
    var h = a[0] > a[1];
    f(e[0].coord, a[0]) && (n ? e[0].coord = a[0] : e.shift()), n && f(a[0], e[0].coord) && e.unshift({
      coord: a[0]
    }), f(a[1], o.coord) && (n ? o.coord = a[1] : e.pop()), n && f(o.coord, a[1]) && e.push({
      coord: a[1]
    });
    function f(d, p) {
      return d = lr(d), p = lr(p), h ? d > p : d < p;
    }
  }
  var Sh = Math.PI * 2, qs = Ra.CMD, pie = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function vie(t, e, r, n, i) {
    var a = r.width, o = r.height;
    switch (t) {
      case "top":
        n.set(r.x + a / 2, r.y - e), i.set(0, -1);
        break;
      case "bottom":
        n.set(r.x + a / 2, r.y + o + e), i.set(0, 1);
        break;
      case "left":
        n.set(r.x - e, r.y + o / 2), i.set(-1, 0);
        break;
      case "right":
        n.set(r.x + a + e, r.y + o / 2), i.set(1, 0);
        break;
    }
  }
  function gie(t, e, r, n, i, a, o, s, l) {
    o -= t, s -= e;
    var u = Math.sqrt(o * o + s * s);
    o /= u, s /= u;
    var c = o * r + t, h = s * r + e;
    if (Math.abs(n - i) % Sh < 1e-4) return l[0] = c, l[1] = h, u - r;
    if (a) {
      var f = n;
      n = Wn(i), i = Wn(f);
    } else n = Wn(n), i = Wn(i);
    n > i && (i += Sh);
    var d = Math.atan2(s, o);
    if (d < 0 && (d += Sh), d >= n && d <= i || d + Sh >= n && d + Sh <= i) return l[0] = c, l[1] = h, u - r;
    var p = r * Math.cos(n) + t, v = r * Math.sin(n) + e, g = r * Math.cos(i) + t, m = r * Math.sin(i) + e, y = (p - o) * (p - o) + (v - s) * (v - s), _ = (g - o) * (g - o) + (m - s) * (m - s);
    return y < _ ? (l[0] = p, l[1] = v, Math.sqrt(y)) : (l[0] = g, l[1] = m, Math.sqrt(_));
  }
  function qg(t, e, r, n, i, a, o, s) {
    var l = i - t, u = a - e, c = r - t, h = n - e, f = Math.sqrt(c * c + h * h);
    c /= f, h /= f;
    var d = l * c + u * h, p = d / f;
    s && (p = Math.min(Math.max(p, 0), 1)), p *= f;
    var v = o[0] = t + p * c, g = o[1] = e + p * h;
    return Math.sqrt((v - i) * (v - i) + (g - a) * (g - a));
  }
  function rG(t, e, r, n, i, a, o) {
    r < 0 && (t = t + r, r = -r), n < 0 && (e = e + n, n = -n);
    var s = t + r, l = e + n, u = o[0] = Math.min(Math.max(i, t), s), c = o[1] = Math.min(Math.max(a, e), l);
    return Math.sqrt((u - i) * (u - i) + (c - a) * (c - a));
  }
  var zi = [];
  function mie(t, e, r) {
    var n = rG(e.x, e.y, e.width, e.height, t.x, t.y, zi);
    return r.set(zi[0], zi[1]), n;
  }
  function yie(t, e, r) {
    for (var n = 0, i = 0, a = 0, o = 0, s, l, u = 1 / 0, c = e.data, h = t.x, f = t.y, d = 0; d < c.length; ) {
      var p = c[d++];
      d === 1 && (n = c[d], i = c[d + 1], a = n, o = i);
      var v = u;
      switch (p) {
        case qs.M:
          a = c[d++], o = c[d++], n = a, i = o;
          break;
        case qs.L:
          v = qg(n, i, c[d], c[d + 1], h, f, zi, true), n = c[d++], i = c[d++];
          break;
        case qs.C:
          v = zF(n, i, c[d++], c[d++], c[d++], c[d++], c[d], c[d + 1], h, f, zi), n = c[d++], i = c[d++];
          break;
        case qs.Q:
          v = VF(n, i, c[d++], c[d++], c[d], c[d + 1], h, f, zi), n = c[d++], i = c[d++];
          break;
        case qs.A:
          var g = c[d++], m = c[d++], y = c[d++], _ = c[d++], b = c[d++], w = c[d++];
          d += 1;
          var x = !!(1 - c[d++]);
          s = Math.cos(b) * y + g, l = Math.sin(b) * _ + m, d <= 1 && (a = s, o = l);
          var T = (h - g) * _ / y + g;
          v = gie(g, m, _, b, b + w, x, T, f, zi), n = Math.cos(b + w) * y + g, i = Math.sin(b + w) * _ + m;
          break;
        case qs.R:
          a = n = c[d++], o = i = c[d++];
          var A = c[d++], I = c[d++];
          v = rG(a, o, A, I, h, f, zi);
          break;
        case qs.Z:
          v = qg(n, i, a, o, h, f, zi, true), n = a, i = o;
          break;
      }
      v < u && (u = v, r.set(zi[0], zi[1]));
    }
    return u;
  }
  var Gi = new Ke(), Ut = new Ke(), hr = new Ke(), Ca = new Ke(), _a = new Ke();
  function nk(t, e) {
    if (t) {
      var r = t.getTextGuideLine(), n = t.getTextContent();
      if (n && r) {
        var i = t.textGuideLineConfig || {}, a = [
          [
            0,
            0
          ],
          [
            0,
            0
          ],
          [
            0,
            0
          ]
        ], o = i.candidates || pie, s = n.getBoundingRect().clone();
        s.applyTransform(n.getComputedTransform());
        var l = 1 / 0, u = i.anchor, c = t.getComputedTransform(), h = c && zc([], c), f = e.get("length2") || 0;
        u && hr.copy(u);
        for (var d = 0; d < o.length; d++) {
          var p = o[d];
          vie(p, 0, s, Gi, Ca), Ke.scaleAndAdd(Ut, Gi, Ca, f), Ut.transform(h);
          var v = t.getBoundingRect(), g = u ? u.distance(Ut) : t instanceof st ? yie(Ut, t.path, hr) : mie(Ut, v, hr);
          g < l && (l = g, Ut.transform(c), hr.transform(c), hr.toArray(a[0]), Ut.toArray(a[1]), Gi.toArray(a[2]));
        }
        nG(a, e.get("minTurnAngle")), r.setShape({
          points: a
        });
      }
    }
  }
  var Xg = [], pn = new Ke();
  function nG(t, e) {
    if (e <= 180 && e > 0) {
      e = e / 180 * Math.PI, Gi.fromArray(t[0]), Ut.fromArray(t[1]), hr.fromArray(t[2]), Ke.sub(Ca, Gi, Ut), Ke.sub(_a, hr, Ut);
      var r = Ca.len(), n = _a.len();
      if (!(r < 1e-3 || n < 1e-3)) {
        Ca.scale(1 / r), _a.scale(1 / n);
        var i = Ca.dot(_a), a = Math.cos(e);
        if (a < i) {
          var o = qg(Ut.x, Ut.y, hr.x, hr.y, Gi.x, Gi.y, Xg, false);
          pn.fromArray(Xg), pn.scaleAndAdd(_a, o / Math.tan(Math.PI - e));
          var s = hr.x !== Ut.x ? (pn.x - Ut.x) / (hr.x - Ut.x) : (pn.y - Ut.y) / (hr.y - Ut.y);
          if (isNaN(s)) return;
          s < 0 ? Ke.copy(pn, Ut) : s > 1 && Ke.copy(pn, hr), pn.toArray(t[1]);
        }
      }
    }
  }
  function _ie(t, e, r) {
    if (r <= 180 && r > 0) {
      r = r / 180 * Math.PI, Gi.fromArray(t[0]), Ut.fromArray(t[1]), hr.fromArray(t[2]), Ke.sub(Ca, Ut, Gi), Ke.sub(_a, hr, Ut);
      var n = Ca.len(), i = _a.len();
      if (!(n < 1e-3 || i < 1e-3)) {
        Ca.scale(1 / n), _a.scale(1 / i);
        var a = Ca.dot(e), o = Math.cos(r);
        if (a < o) {
          var s = qg(Ut.x, Ut.y, hr.x, hr.y, Gi.x, Gi.y, Xg, false);
          pn.fromArray(Xg);
          var l = Math.PI / 2, u = Math.acos(_a.dot(e)), c = l + u - r;
          if (c >= l) Ke.copy(pn, hr);
          else {
            pn.scaleAndAdd(_a, s / Math.tan(Math.PI / 2 - c));
            var h = hr.x !== Ut.x ? (pn.x - Ut.x) / (hr.x - Ut.x) : (pn.y - Ut.y) / (hr.y - Ut.y);
            if (isNaN(h)) return;
            h < 0 ? Ke.copy(pn, Ut) : h > 1 && Ke.copy(pn, hr);
          }
          pn.toArray(t[1]);
        }
      }
    }
  }
  function t_(t, e, r, n) {
    var i = r === "normal", a = i ? t : t.ensureState(r);
    a.ignore = e;
    var o = n.get("smooth");
    o && o === true && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
    var s = n.getModel("lineStyle").getLineStyle();
    i ? t.useStyle(s) : a.style = s;
  }
  function bie(t, e) {
    var r = e.smooth, n = e.points;
    if (n) if (t.moveTo(n[0][0], n[0][1]), r > 0 && n.length >= 3) {
      var i = jo(n[0], n[1]), a = jo(n[1], n[2]);
      if (!i || !a) {
        t.lineTo(n[1][0], n[1][1]), t.lineTo(n[2][0], n[2][1]);
        return;
      }
      var o = Math.min(i, a) * r, s = Kv([], n[1], n[0], o / i), l = Kv([], n[1], n[2], o / a), u = Kv([], s, l, 0.5);
      t.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), t.bezierCurveTo(l[0], l[1], l[0], l[1], n[2][0], n[2][1]);
    } else for (var c = 1; c < n.length; c++) t.lineTo(n[c][0], n[c][1]);
  }
  function UT(t, e, r) {
    var n = t.getTextGuideLine(), i = t.getTextContent();
    if (!i) {
      n && t.removeTextGuideLine();
      return;
    }
    for (var a = e.normal, o = a.get("show"), s = i.ignore, l = 0; l < qf.length; l++) {
      var u = qf[l], c = e[u], h = u === "normal";
      if (c) {
        var f = c.get("show"), d = h ? s : We(i.states[u] && i.states[u].ignore, s);
        if (d || !We(f, o)) {
          var p = h ? n : n && n.states[u];
          p && (p.ignore = true), n && t_(n, true, u, c);
          continue;
        }
        n || (n = new Tn(), t.setTextGuideLine(n), !h && (s || !o) && t_(n, true, "normal", e.normal), t.stateProxy && (n.stateProxy = t.stateProxy)), t_(n, false, u, c);
      }
    }
    if (n) {
      Ee(n.style, r), n.style.fill = null;
      var v = a.get("showAbove"), g = t.textGuideLineConfig = t.textGuideLineConfig || {};
      g.showAbove = v || false, n.buildPath = bie;
    }
  }
  function YT(t, e) {
    e = e || "labelLine";
    for (var r = {
      normal: t.getModel(e)
    }, n = 0; n < xn.length; n++) {
      var i = xn[n];
      r[i] = t.getModel([
        i,
        e
      ]);
    }
    return r;
  }
  function iG(t) {
    for (var e = [], r = 0; r < t.length; r++) {
      var n = t[r];
      if (!n.defaultAttr.ignore) {
        var i = n.label, a = i.getComputedTransform(), o = i.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = i.style.margin || 0, u = o.clone();
        u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
        var c = s ? new Pg(o, a) : null;
        e.push({
          label: i,
          labelLine: n.labelLine,
          rect: u,
          localRect: o,
          obb: c,
          priority: n.priority,
          defaultAttr: n.defaultAttr,
          layoutOption: n.computedLayoutOption,
          axisAligned: s,
          transform: a
        });
      }
    }
    return e;
  }
  function aG(t, e, r, n, i, a) {
    var o = t.length;
    if (o < 2) return;
    t.sort(function(x, T) {
      return x.rect[e] - T.rect[e];
    });
    for (var s = 0, l, u = false, c = 0; c < o; c++) {
      var h = t[c], f = h.rect;
      l = f[e] - s, l < 0 && (f[e] -= l, h.label[e] -= l, u = true), s = f[e] + f[r];
    }
    var d = t[0], p = t[o - 1], v, g;
    m(), v < 0 && b(-v, 0.8), g < 0 && b(g, 0.8), m(), y(v, g, 1), y(g, v, -1), m(), v < 0 && w(-v), g < 0 && w(g);
    function m() {
      v = d.rect[e] - n, g = i - p.rect[e] - p.rect[r];
    }
    function y(x, T, A) {
      if (x < 0) {
        var I = Math.min(T, -x);
        if (I > 0) {
          _(I * A, 0, o);
          var M = I + x;
          M < 0 && b(-M * A, 1);
        } else b(-x * A, 1);
      }
    }
    function _(x, T, A) {
      x !== 0 && (u = true);
      for (var I = T; I < A; I++) {
        var M = t[I], k = M.rect;
        k[e] += x, M.label[e] += x;
      }
    }
    function b(x, T) {
      for (var A = [], I = 0, M = 1; M < o; M++) {
        var k = t[M - 1].rect, B = Math.max(t[M].rect[e] - k[e] - k[r], 0);
        A.push(B), I += B;
      }
      if (I) {
        var L = Math.min(Math.abs(x) / I, T);
        if (x > 0) for (var M = 0; M < o - 1; M++) {
          var z = A[M] * L;
          _(z, 0, M + 1);
        }
        else for (var M = o - 1; M > 0; M--) {
          var z = A[M - 1] * L;
          _(-z, M, o);
        }
      }
    }
    function w(x) {
      var T = x < 0 ? -1 : 1;
      x = Math.abs(x);
      for (var A = Math.ceil(x / (o - 1)), I = 0; I < o - 1; I++) if (T > 0 ? _(A, 0, I + 1) : _(-A, o - I - 1, o), x -= A, x <= 0) return;
    }
    return u;
  }
  function xie(t, e, r, n) {
    return aG(t, "x", "width", e, r);
  }
  function oG(t, e, r, n) {
    return aG(t, "y", "height", e, r);
  }
  function sG(t) {
    var e = [];
    t.sort(function(v, g) {
      return g.priority - v.priority;
    });
    var r = new Ze(0, 0, 0, 0);
    function n(v) {
      if (!v.ignore) {
        var g = v.ensureState("emphasis");
        g.ignore == null && (g.ignore = false);
      }
      v.ignore = true;
    }
    for (var i = 0; i < t.length; i++) {
      var a = t[i], o = a.axisAligned, s = a.localRect, l = a.transform, u = a.label, c = a.labelLine;
      r.copy(a.rect), r.width -= 0.1, r.height -= 0.1, r.x += 0.05, r.y += 0.05;
      for (var h = a.obb, f = false, d = 0; d < e.length; d++) {
        var p = e[d];
        if (r.intersect(p.rect)) {
          if (o && p.axisAligned) {
            f = true;
            break;
          }
          if (p.obb || (p.obb = new Pg(p.localRect, p.transform)), h || (h = new Pg(s, l)), h.intersect(p.obb)) {
            f = true;
            break;
          }
        }
      }
      f ? (n(u), c && n(c)) : (u.attr("ignore", a.defaultAttr.ignore), c && c.attr("ignore", a.defaultAttr.labelGuideIgnore), e.push(a));
    }
  }
  function wie(t) {
    if (t) {
      for (var e = [], r = 0; r < t.length; r++) e.push(t[r].slice());
      return e;
    }
  }
  function Sie(t, e) {
    var r = t.label, n = e && e.getTextGuideLine();
    return {
      dataIndex: t.dataIndex,
      dataType: t.dataType,
      seriesIndex: t.seriesModel.seriesIndex,
      text: t.label.style.text,
      rect: t.hostRect,
      labelRect: t.rect,
      align: r.style.align,
      verticalAlign: r.style.verticalAlign,
      labelLinePoints: wie(n && n.shape.points)
    };
  }
  var ik = [
    "align",
    "verticalAlign",
    "width",
    "height",
    "fontSize"
  ], un = new Qa(), r_ = _t(), Tie = _t();
  function Hp(t, e, r) {
    for (var n = 0; n < r.length; n++) {
      var i = r[n];
      e[i] != null && (t[i] = e[i]);
    }
  }
  var Up = [
    "x",
    "y",
    "rotation"
  ], Cie = function() {
    function t() {
      this._labelList = [], this._chartViewList = [];
    }
    return t.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, t.prototype._addLabel = function(e, r, n, i, a) {
      var o = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      Ze.applyTransform(c, c, u), u ? un.setLocalTransform(u) : (un.x = un.y = un.rotation = un.originX = un.originY = 0, un.scaleX = un.scaleY = 1), un.rotation = Wn(un.rotation);
      var h = i.__hostTarget, f;
      if (h) {
        f = h.getBoundingRect().plain();
        var d = h.getComputedTransform();
        Ze.applyTransform(f, f, d);
      }
      var p = f && h.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: n,
        dataIndex: e,
        dataType: r,
        layoutOption: a,
        computedLayoutOption: null,
        rect: c,
        hostRect: f,
        priority: f ? f.width * f.height : 0,
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: un.x,
          y: un.y,
          scaleX: un.scaleX,
          scaleY: un.scaleY,
          rotation: un.rotation,
          style: {
            x: o.x,
            y: o.y,
            align: o.align,
            verticalAlign: o.verticalAlign,
            width: o.width,
            height: o.height,
            fontSize: o.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, t.prototype.addLabelsOfSeries = function(e) {
      var r = this;
      this._chartViewList.push(e);
      var n = e.__model, i = n.get("labelLayout");
      (De(i) || gt(i).length) && e.group.traverse(function(a) {
        if (a.ignore) return true;
        var o = a.getTextContent(), s = Ge(a);
        o && !o.disableLabelLayout && r._addLabel(s.dataIndex, s.dataType, n, o, i);
      });
    }, t.prototype.updateLayoutConfig = function(e) {
      var r = e.getWidth(), n = e.getHeight();
      function i(_, b) {
        return function() {
          nk(_, b);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, c = void 0;
        De(o.layoutOption) ? c = o.layoutOption(Sie(o, l)) : c = o.layoutOption, c = c || {}, o.computedLayoutOption = c;
        var h = Math.PI / 180;
        l && l.setTextConfig({
          local: false,
          position: c.x != null || c.y != null ? null : u.attachedPos,
          rotation: c.rotate != null ? c.rotate * h : u.attachedRot,
          offset: [
            c.dx || 0,
            c.dy || 0
          ]
        });
        var f = false;
        if (c.x != null ? (s.x = pe(c.x, r), s.setStyle("x", 0), f = true) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = pe(c.y, n), s.setStyle("y", 0), f = true) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var d = l.getTextGuideLine();
          d && (d.setShape({
            points: c.labelLinePoints
          }), f = false);
        }
        var p = r_(s);
        p.needsUpdateLabelLine = f, s.rotation = c.rotate != null ? c.rotate * h : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var v = 0; v < ik.length; v++) {
          var g = ik[v];
          s.setStyle(g, c[g] != null ? c[g] : u.style[g]);
        }
        if (c.draggable) {
          if (s.draggable = true, s.cursor = "move", l) {
            var m = o.seriesModel;
            if (o.dataIndex != null) {
              var y = o.seriesModel.getData(o.dataType);
              m = y.getItemModel(o.dataIndex);
            }
            s.on("drag", i(l, m.getModel("labelLine")));
          }
        } else s.off("drag"), s.cursor = u.cursor;
      }
    }, t.prototype.layout = function(e) {
      var r = e.getWidth(), n = e.getHeight(), i = iG(this._labelList), a = Dt(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), o = Dt(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      xie(a, 0, r), oG(o, 0, n);
      var s = Dt(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      sG(s);
    }, t.prototype.processLabelsOverall = function() {
      var e = this;
      $(this._chartViewList, function(r) {
        var n = r.__model, i = r.ignoreLabelLineUpdate, a = n.isAnimationEnabled();
        r.group.traverse(function(o) {
          if (o.ignore && !o.forceLabelAnimation) return true;
          var s = !i, l = o.getTextContent();
          !s && l && (s = r_(l).needsUpdateLabelLine), s && e._updateLabelLine(o, n), a && e._animateLabels(o, n);
        });
      });
    }, t.prototype._updateLabelLine = function(e, r) {
      var n = e.getTextContent(), i = Ge(e), a = i.dataIndex;
      if (n && a != null) {
        var o = r.getData(i.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
        if (u) {
          var c = o.getVisual("drawType");
          l.stroke = u[c];
        }
        var h = s.getModel("labelLine");
        UT(e, YT(s), l), nk(e, h);
      }
    }, t.prototype._animateLabels = function(e, r) {
      var n = e.getTextContent(), i = e.getTextGuideLine();
      if (n && (e.forceLabelAnimation || !n.ignore && !n.invisible && !e.disableLabelAnimation && !hc(e))) {
        var a = r_(n), o = a.oldLayout, s = Ge(e), l = s.dataIndex, u = {
          x: n.x,
          y: n.y,
          rotation: n.rotation
        }, c = r.getData(s.dataType);
        if (o) {
          n.attr(o);
          var f = e.prevStates;
          f && (et(f, "select") >= 0 && n.attr(a.oldLayoutSelect), et(f, "emphasis") >= 0 && n.attr(a.oldLayoutEmphasis)), wt(n, u, r, l);
        } else if (n.attr(u), !Wc(n).valueAnimation) {
          var h = We(n.style.opacity, 1);
          n.style.opacity = 0, er(n, {
            style: {
              opacity: h
            }
          }, r, l);
        }
        if (a.oldLayout = u, n.states.select) {
          var d = a.oldLayoutSelect = {};
          Hp(d, u, Up), Hp(d, n.states.select, Up);
        }
        if (n.states.emphasis) {
          var p = a.oldLayoutEmphasis = {};
          Hp(p, u, Up), Hp(p, n.states.emphasis, Up);
        }
        Q4(n, l, c, r, r);
      }
      if (i && !i.ignore && !i.invisible) {
        var a = Tie(i), o = a.oldLayout, v = {
          points: i.shape.points
        };
        o ? (i.attr({
          shape: o
        }), wt(i, {
          shape: v
        }, r)) : (i.setShape(v), i.style.strokePercent = 0, er(i, {
          style: {
            strokePercent: 1
          }
        }, r)), a.oldLayout = v;
      }
    }, t;
  }(), n_ = _t();
  function Aie(t) {
    t.registerUpdateLifecycle("series:beforeupdate", function(e, r, n) {
      var i = n_(r).labelManager;
      i || (i = n_(r).labelManager = new Cie()), i.clearLabels();
    }), t.registerUpdateLifecycle("series:layoutlabels", function(e, r, n) {
      var i = n_(r).labelManager;
      n.updatedSeries.forEach(function(a) {
        i.addLabelsOfSeries(r.getViewOfSeriesModel(a));
      }), i.updateLayoutConfig(r), i.layout(r), i.processLabelsOverall();
    });
  }
  var i_ = Math.sin, a_ = Math.cos, lG = Math.PI, Xs = Math.PI * 2, Iie = 180 / lG, uG = function() {
    function t() {
    }
    return t.prototype.reset = function(e) {
      this._start = true, this._d = [], this._str = "", this._p = Math.pow(10, e || 4);
    }, t.prototype.moveTo = function(e, r) {
      this._add("M", e, r);
    }, t.prototype.lineTo = function(e, r) {
      this._add("L", e, r);
    }, t.prototype.bezierCurveTo = function(e, r, n, i, a, o) {
      this._add("C", e, r, n, i, a, o);
    }, t.prototype.quadraticCurveTo = function(e, r, n, i) {
      this._add("Q", e, r, n, i);
    }, t.prototype.arc = function(e, r, n, i, a, o) {
      this.ellipse(e, r, n, n, 0, i, a, o);
    }, t.prototype.ellipse = function(e, r, n, i, a, o, s, l) {
      var u = s - o, c = !l, h = Math.abs(u), f = es(h - Xs) || (c ? u >= Xs : -u >= Xs), d = u > 0 ? u % Xs : u % Xs + Xs, p = false;
      f ? p = true : es(h) ? p = false : p = d >= lG == !!c;
      var v = e + n * a_(o), g = r + i * i_(o);
      this._start && this._add("M", v, g);
      var m = Math.round(a * Iie);
      if (f) {
        var y = 1 / this._p, _ = (c ? 1 : -1) * (Xs - y);
        this._add("A", n, i, m, 1, +c, e + n * a_(o + _), r + i * i_(o + _)), y > 0.01 && this._add("A", n, i, m, 0, +c, v, g);
      } else {
        var b = e + n * a_(s), w = r + i * i_(s);
        this._add("A", n, i, m, +p, +c, b, w);
      }
    }, t.prototype.rect = function(e, r, n, i) {
      this._add("M", e, r), this._add("l", n, 0), this._add("l", 0, i), this._add("l", -n, 0), this._add("Z");
    }, t.prototype.closePath = function() {
      this._d.length > 0 && this._add("Z");
    }, t.prototype._add = function(e, r, n, i, a, o, s, l, u) {
      for (var c = [], h = this._p, f = 1; f < arguments.length; f++) {
        var d = arguments[f];
        if (isNaN(d)) {
          this._invalid = true;
          return;
        }
        c.push(Math.round(d * h) / h);
      }
      this._d.push(e + c.join(" ")), this._start = e === "Z";
    }, t.prototype.generateStr = function() {
      this._str = this._invalid ? "" : this._d.join(""), this._d = [];
    }, t.prototype.getStr = function() {
      return this._str;
    }, t;
  }(), qT = "none", Mie = Math.round;
  function Die(t) {
    var e = t.fill;
    return e != null && e !== qT;
  }
  function Eie(t) {
    var e = t.stroke;
    return e != null && e !== qT;
  }
  var ew = [
    "lineCap",
    "miterLimit",
    "lineJoin"
  ], kie = oe(ew, function(t) {
    return "stroke-" + t.toLowerCase();
  });
  function Pie(t, e, r, n) {
    var i = e.opacity == null ? 1 : e.opacity;
    if (r instanceof Gr) {
      t("opacity", i);
      return;
    }
    if (Die(e)) {
      var a = Hf(e.fill);
      t("fill", a.color);
      var o = e.fillOpacity != null ? e.fillOpacity * a.opacity * i : a.opacity * i;
      o < 1 && t("fill-opacity", o);
    } else t("fill", qT);
    if (Eie(e)) {
      var s = Hf(e.stroke);
      t("stroke", s.color);
      var l = e.strokeNoScale ? r.getLineScale() : 1, u = l ? (e.lineWidth || 0) / l : 0, c = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * i : s.opacity * i, h = e.strokeFirst;
      if (u !== 1 && t("stroke-width", u), h && t("paint-order", h ? "stroke" : "fill"), c < 1 && t("stroke-opacity", c), e.lineDash) {
        var f = $T(r), d = f[0], p = f[1];
        d && (p = Mie(p || 0), t("stroke-dasharray", d.join(",")), (p || n) && t("stroke-dashoffset", p));
      }
      for (var v = 0; v < ew.length; v++) {
        var g = ew[v];
        if (e[g] !== Eg[g]) {
          var m = e[g] || Eg[g];
          m && t(kie[v], m);
        }
      }
    }
  }
  var cG = "http://www.w3.org/2000/svg", hG = "http://www.w3.org/1999/xlink", Lie = "http://www.w3.org/2000/xmlns/", $ie = "http://www.w3.org/XML/1998/namespace", ak = "ecmeta_";
  function fG(t) {
    return document.createElementNS(cG, t);
  }
  function Dr(t, e, r, n, i) {
    return {
      tag: t,
      attrs: r || {},
      children: n,
      text: i,
      key: e
    };
  }
  function Rie(t, e) {
    var r = [];
    if (e) for (var n in e) {
      var i = e[n], a = n;
      i !== false && (i !== true && i != null && (a += '="' + i + '"'), r.push(a));
    }
    return "<" + t + " " + r.join(" ") + ">";
  }
  function Oie(t) {
    return "</" + t + ">";
  }
  function XT(t, e) {
    e = e || {};
    var r = e.newline ? `
` : "";
    function n(i) {
      var a = i.children, o = i.tag, s = i.attrs, l = i.text;
      return Rie(o, s) + (o !== "style" ? vn(l) : l || "") + (a ? "" + r + oe(a, function(u) {
        return n(u);
      }).join(r) + r : "") + Oie(o);
    }
    return n(t);
  }
  function Nie(t, e, r) {
    r = r || {};
    var n = r.newline ? `
` : "", i = " {" + n, a = n + "}", o = oe(gt(t), function(l) {
      return l + i + oe(gt(t[l]), function(u) {
        return u + ":" + t[l][u] + ";";
      }).join(n) + a;
    }).join(n), s = oe(gt(e), function(l) {
      return "@keyframes " + l + i + oe(gt(e[l]), function(u) {
        return u + i + oe(gt(e[l][u]), function(c) {
          var h = e[l][u][c];
          return c === "d" && (h = 'path("' + h + '")'), c + ":" + h + ";";
        }).join(n) + a;
      }).join(n) + a;
    }).join(n);
    return !o && !s ? "" : [
      "<![CDATA[",
      o,
      s,
      "]]>"
    ].join(n);
  }
  function tw(t) {
    return {
      zrId: t,
      shadowCache: {},
      patternCache: {},
      gradientCache: {},
      clipPathCache: {},
      defs: {},
      cssNodes: {},
      cssAnims: {},
      cssStyleCache: {},
      cssAnimIdx: 0,
      shadowIdx: 0,
      gradientIdx: 0,
      patternIdx: 0,
      clipPathIdx: 0
    };
  }
  function ok(t, e, r, n) {
    return Dr("svg", "root", {
      width: t,
      height: e,
      xmlns: cG,
      "xmlns:xlink": hG,
      version: "1.1",
      baseProfile: "full",
      viewBox: n ? "0 0 " + t + " " + e : false
    }, r);
  }
  var Bie = 0;
  function dG() {
    return Bie++;
  }
  var sk = {
    cubicIn: "0.32,0,0.67,0",
    cubicOut: "0.33,1,0.68,1",
    cubicInOut: "0.65,0,0.35,1",
    quadraticIn: "0.11,0,0.5,0",
    quadraticOut: "0.5,1,0.89,1",
    quadraticInOut: "0.45,0,0.55,1",
    quarticIn: "0.5,0,0.75,0",
    quarticOut: "0.25,1,0.5,1",
    quarticInOut: "0.76,0,0.24,1",
    quinticIn: "0.64,0,0.78,0",
    quinticOut: "0.22,1,0.36,1",
    quinticInOut: "0.83,0,0.17,1",
    sinusoidalIn: "0.12,0,0.39,0",
    sinusoidalOut: "0.61,1,0.88,1",
    sinusoidalInOut: "0.37,0,0.63,1",
    exponentialIn: "0.7,0,0.84,0",
    exponentialOut: "0.16,1,0.3,1",
    exponentialInOut: "0.87,0,0.13,1",
    circularIn: "0.55,0,1,0.45",
    circularOut: "0,0.55,0.45,1",
    circularInOut: "0.85,0,0.15,1"
  }, al = "transform-origin";
  function zie(t, e, r) {
    var n = te({}, t.shape);
    te(n, e), t.buildPath(r, n);
    var i = new uG();
    return i.reset(XF(t)), r.rebuildPath(i, 1), i.generateStr(), i.getStr();
  }
  function Fie(t, e) {
    var r = e.originX, n = e.originY;
    (r || n) && (t[al] = r + "px " + n + "px");
  }
  var Vie = {
    fill: "fill",
    opacity: "opacity",
    lineWidth: "stroke-width",
    lineDashOffset: "stroke-dashoffset"
  };
  function pG(t, e) {
    var r = e.zrId + "-ani-" + e.cssAnimIdx++;
    return e.cssAnims[r] = t, r;
  }
  function Gie(t, e, r) {
    var n = t.shape.paths, i = {}, a, o;
    if ($(n, function(l) {
      var u = tw(r.zrId);
      u.animation = true, dy(l, {}, u, true);
      var c = u.cssAnims, h = u.cssNodes, f = gt(c), d = f.length;
      if (d) {
        o = f[d - 1];
        var p = c[o];
        for (var v in p) {
          var g = p[v];
          i[v] = i[v] || {
            d: ""
          }, i[v].d += g.d || "";
        }
        for (var m in h) {
          var y = h[m].animation;
          y.indexOf(o) >= 0 && (a = y);
        }
      }
    }), !!a) {
      e.d = false;
      var s = pG(i, r);
      return a.replace(o, s);
    }
  }
  function lk(t) {
    return me(t) ? sk[t] ? "cubic-bezier(" + sk[t] + ")" : JS(t) ? t : "" : "";
  }
  function dy(t, e, r, n) {
    var i = t.animators, a = i.length, o = [];
    if (t instanceof pT) {
      var s = Gie(t, e, r);
      if (s) o.push(s);
      else if (!a) return;
    } else if (!a) return;
    for (var l = {}, u = 0; u < a; u++) {
      var c = i[u], h = [
        c.getMaxTime() / 1e3 + "s"
      ], f = lk(c.getClip().easing), d = c.getDelay();
      f ? h.push(f) : h.push("linear"), d && h.push(d / 1e3 + "s"), c.getLoop() && h.push("infinite");
      var p = h.join(" ");
      l[p] = l[p] || [
        p,
        []
      ], l[p][1].push(c);
    }
    function v(y) {
      var _ = y[1], b = _.length, w = {}, x = {}, T = {}, A = "animation-timing-function";
      function I(le, ue, ye) {
        for (var ve = le.getTracks(), Se = le.getMaxTime(), Qe = 0; Qe < ve.length; Qe++) {
          var Xe = ve[Qe];
          if (Xe.needsAnimate()) {
            var be = Xe.keyframes, ke = Xe.propName;
            if (ye && (ke = ye(ke)), ke) for (var Vt = 0; Vt < be.length; Vt++) {
              var X = be[Vt], j = Math.round(X.time / Se * 100) + "%", he = lk(X.easing), $e = X.rawValue;
              (me($e) || xt($e)) && (ue[j] = ue[j] || {}, ue[j][ke] = X.rawValue, he && (ue[j][A] = he));
            }
          }
        }
      }
      for (var M = 0; M < b; M++) {
        var k = _[M], B = k.targetName;
        B ? B === "shape" && I(k, x) : !n && I(k, w);
      }
      for (var L in w) {
        var z = {};
        JF(z, t), te(z, w[L]);
        var F = jF(z), E = w[L][A];
        T[L] = F ? {
          transform: F
        } : {}, Fie(T[L], z), E && (T[L][A] = E);
      }
      var O, N = true;
      for (var L in x) {
        T[L] = T[L] || {};
        var V = !O, E = x[L][A];
        V && (O = new Ra());
        var H = O.len();
        O.reset(), T[L].d = zie(t, x[L], O);
        var G = O.len();
        if (!V && H !== G) {
          N = false;
          break;
        }
        E && (T[L][A] = E);
      }
      if (!N) for (var L in T) delete T[L].d;
      if (!n) for (var M = 0; M < b; M++) {
        var k = _[M], B = k.targetName;
        B === "style" && I(k, T, function(ve) {
          return Vie[ve];
        });
      }
      for (var Y = gt(T), U = true, Z, M = 1; M < Y.length; M++) {
        var ee = Y[M - 1], we = Y[M];
        if (T[ee][al] !== T[we][al]) {
          U = false;
          break;
        }
        Z = T[ee][al];
      }
      if (U && Z) {
        for (var L in T) T[L][al] && delete T[L][al];
        e[al] = Z;
      }
      if (Dt(Y, function(le) {
        return gt(T[le]).length > 0;
      }).length) {
        var Te = pG(T, r);
        return Te + " " + y[0] + " both";
      }
    }
    for (var g in l) {
      var s = v(l[g]);
      s && o.push(s);
    }
    if (o.length) {
      var m = r.zrId + "-cls-" + dG();
      r.cssNodes["." + m] = {
        animation: o.join(",")
      }, e.class = m;
    }
  }
  function Wie(t, e, r) {
    if (!t.ignore) if (t.isSilent()) {
      var n = {
        "pointer-events": "none"
      };
      uk(n, e, r);
    } else {
      var i = t.states.emphasis && t.states.emphasis.style ? t.states.emphasis.style : {}, a = i.fill;
      if (!a) {
        var o = t.style && t.style.fill, s = t.states.select && t.states.select.style && t.states.select.style.fill, l = t.currentStates.indexOf("select") >= 0 && s || o;
        l && (a = fx(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && t.transform ? t.transform[0] : 1;
        u = u / c;
      }
      var n = {
        cursor: "pointer"
      };
      a && (n.fill = a), i.stroke && (n.stroke = i.stroke), u && (n["stroke-width"] = u), uk(n, e, r);
    }
  }
  function uk(t, e, r, n) {
    var i = JSON.stringify(t), a = r.cssStyleCache[i];
    a || (a = r.zrId + "-cls-" + dG(), r.cssStyleCache[i] = a, r.cssNodes["." + a + ":hover"] = t), e.class = e.class ? e.class + " " + a : a;
  }
  var nd = Math.round;
  function vG(t) {
    return t && me(t.src);
  }
  function gG(t) {
    return t && De(t.toDataURL);
  }
  function jT(t, e, r, n) {
    Pie(function(i, a) {
      var o = i === "fill" || i === "stroke";
      o && qF(a) ? yG(e, t, i, n) : o && eT(a) ? _G(r, t, i, n) : t[i] = a, o && n.ssr && a === "none" && (t["pointer-events"] = "visible");
    }, e, r, false), Kie(r, t, n);
  }
  function KT(t, e) {
    var r = zZ(e);
    r && (r.each(function(n, i) {
      n != null && (t[(ak + i).toLowerCase()] = n + "");
    }), e.isSilent() && (t[ak + "silent"] = "true"));
  }
  function ck(t) {
    return es(t[0] - 1) && es(t[1]) && es(t[2]) && es(t[3] - 1);
  }
  function Hie(t) {
    return es(t[4]) && es(t[5]);
  }
  function ZT(t, e, r) {
    if (e && !(Hie(e) && ck(e))) {
      var n = 1e4;
      t.transform = ck(e) ? "translate(" + nd(e[4] * n) / n + " " + nd(e[5] * n) / n + ")" : sZ(e);
    }
  }
  function hk(t, e, r) {
    for (var n = t.points, i = [], a = 0; a < n.length; a++) i.push(nd(n[a][0] * r) / r), i.push(nd(n[a][1] * r) / r);
    e.points = i.join(" ");
  }
  function fk(t) {
    return !t.smooth;
  }
  function Uie(t) {
    var e = oe(t, function(r) {
      return typeof r == "string" ? [
        r,
        r
      ] : r;
    });
    return function(r, n, i) {
      for (var a = 0; a < e.length; a++) {
        var o = e[a], s = r[o[0]];
        s != null && (n[o[1]] = nd(s * i) / i);
      }
    };
  }
  var Yie = {
    circle: [
      Uie([
        "cx",
        "cy",
        "r"
      ])
    ],
    polyline: [
      hk,
      fk
    ],
    polygon: [
      hk,
      fk
    ]
  };
  function qie(t) {
    for (var e = t.animators, r = 0; r < e.length; r++) if (e[r].targetName === "shape") return true;
    return false;
  }
  function mG(t, e) {
    var r = t.style, n = t.shape, i = Yie[t.type], a = {}, o = e.animation, s = "path", l = t.style.strokePercent, u = e.compress && XF(t) || 4;
    if (i && !e.willUpdate && !(i[1] && !i[1](n)) && !(o && qie(t)) && !(l < 1)) {
      s = t.type;
      var c = Math.pow(10, u);
      i[0](n, a, c);
    } else {
      var h = !t.path || t.shapeChanged();
      t.path || t.createPathProxy();
      var f = t.path;
      h && (f.beginPath(), t.buildPath(f, t.shape), t.pathUpdated());
      var d = f.getVersion(), p = t, v = p.__svgPathBuilder;
      (p.__svgPathVersion !== d || !v || l !== p.__svgPathStrokePercent) && (v || (v = p.__svgPathBuilder = new uG()), v.reset(u), f.rebuildPath(v, l), v.generateStr(), p.__svgPathVersion = d, p.__svgPathStrokePercent = l), a.d = v.getStr();
    }
    return ZT(a, t.transform), jT(a, r, t, e), KT(a, t), e.animation && dy(t, a, e), e.emphasis && Wie(t, a, e), Dr(s, t.id + "", a);
  }
  function Xie(t, e) {
    var r = t.style, n = r.image;
    if (n && !me(n) && (vG(n) ? n = n.src : gG(n) && (n = n.toDataURL())), !!n) {
      var i = r.x || 0, a = r.y || 0, o = r.width, s = r.height, l = {
        href: n,
        width: o,
        height: s
      };
      return i && (l.x = i), a && (l.y = a), ZT(l, t.transform), jT(l, r, t, e), KT(l, t), e.animation && dy(t, l, e), Dr("image", t.id + "", l);
    }
  }
  function jie(t, e) {
    var r = t.style, n = r.text;
    if (n != null && (n += ""), !(!n || isNaN(r.x) || isNaN(r.y))) {
      var i = r.font || cs, a = r.x || 0, o = uZ(r.y || 0, zm(i), r.textBaseline), s = lZ[r.textAlign] || r.textAlign, l = {
        "dominant-baseline": "central",
        "text-anchor": s
      };
      if (C4(r)) {
        var u = "", c = r.fontStyle, h = T4(r.fontSize);
        if (!parseFloat(h)) return;
        var f = r.fontFamily || SF, d = r.fontWeight;
        u += "font-size:" + h + ";font-family:" + f + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), d && d !== "normal" && (u += "font-weight:" + d + ";"), l.style = u;
      } else l.style = "font: " + i;
      return n.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), ZT(l, t.transform), jT(l, r, t, e), KT(l, t), e.animation && dy(t, l, e), Dr("text", t.id + "", l, void 0, n);
    }
  }
  function dk(t, e) {
    if (t instanceof st) return mG(t, e);
    if (t instanceof Gr) return Xie(t, e);
    if (t instanceof mc) return jie(t, e);
  }
  function Kie(t, e, r) {
    var n = t.style;
    if (cZ(n)) {
      var i = hZ(t), a = r.shadowCache, o = a[i];
      if (!o) {
        var s = t.getGlobalScale(), l = s[0], u = s[1];
        if (!l || !u) return;
        var c = n.shadowOffsetX || 0, h = n.shadowOffsetY || 0, f = n.shadowBlur, d = Hf(n.shadowColor), p = d.opacity, v = d.color, g = f / 2 / l, m = f / 2 / u, y = g + " " + m;
        o = r.zrId + "-s" + r.shadowIdx++, r.defs[o] = Dr("filter", o, {
          id: o,
          x: "-100%",
          y: "-100%",
          width: "300%",
          height: "300%"
        }, [
          Dr("feDropShadow", "", {
            dx: c / l,
            dy: h / u,
            stdDeviation: y,
            "flood-color": v,
            "flood-opacity": p
          })
        ]), a[i] = o;
      }
      e.filter = Bm(o);
    }
  }
  function yG(t, e, r, n) {
    var i = t[r], a, o = {
      gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
    };
    if (UF(i)) a = "linearGradient", o.x1 = i.x, o.y1 = i.y, o.x2 = i.x2, o.y2 = i.y2;
    else if (YF(i)) a = "radialGradient", o.cx = We(i.x, 0.5), o.cy = We(i.y, 0.5), o.r = We(i.r, 0.5);
    else return;
    for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
      var h = dx(s[u].offset) * 100 + "%", f = s[u].color, d = Hf(f), p = d.color, v = d.opacity, g = {
        offset: h
      };
      g["stop-color"] = p, v < 1 && (g["stop-opacity"] = v), l.push(Dr("stop", u + "", g));
    }
    var m = Dr(a, "", o, l), y = XT(m), _ = n.gradientCache, b = _[y];
    b || (b = n.zrId + "-g" + n.gradientIdx++, _[y] = b, o.id = b, n.defs[b] = Dr(a, b, o, l)), e[r] = Bm(b);
  }
  function _G(t, e, r, n) {
    var i = t.style[r], a = t.getBoundingRect(), o = {}, s = i.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", h;
    if (HF(i)) {
      var f = i.imageWidth, d = i.imageHeight, p = void 0, v = i.image;
      if (me(v) ? p = v : vG(v) ? p = v.src : gG(v) && (p = v.toDataURL()), typeof Image > "u") {
        var g = "Image width/height must been given explictly in svg-ssr renderer.";
        bn(f, g), bn(d, g);
      } else if (f == null || d == null) {
        var m = function(M, k) {
          if (M) {
            var B = M.elm, L = f || k.width, z = d || k.height;
            M.tag === "pattern" && (u ? (z = 1, L /= a.width) : c && (L = 1, z /= a.height)), M.attrs.width = L, M.attrs.height = z, B && (B.setAttribute("width", L), B.setAttribute("height", z));
          }
        }, y = oT(p, null, t, function(M) {
          l || m(x, M), m(h, M);
        });
        y && y.width && y.height && (f = f || y.width, d = d || y.height);
      }
      h = Dr("image", "img", {
        href: p,
        width: f,
        height: d
      }), o.width = f, o.height = d;
    } else i.svgElement && (h = Oe(i.svgElement), o.width = i.svgWidth, o.height = i.svgHeight);
    if (h) {
      var _, b;
      l ? _ = b = 1 : u ? (b = 1, _ = o.width / a.width) : c ? (_ = 1, b = o.height / a.height) : o.patternUnits = "userSpaceOnUse", _ != null && !isNaN(_) && (o.width = _), b != null && !isNaN(b) && (o.height = b);
      var w = jF(i);
      w && (o.patternTransform = w);
      var x = Dr("pattern", "", o, [
        h
      ]), T = XT(x), A = n.patternCache, I = A[T];
      I || (I = n.zrId + "-p" + n.patternIdx++, A[T] = I, o.id = I, x = n.defs[I] = Dr("pattern", I, o, [
        h
      ])), e[r] = Bm(I);
    }
  }
  function Zie(t, e, r) {
    var n = r.clipPathCache, i = r.defs, a = n[t.id];
    if (!a) {
      a = r.zrId + "-c" + r.clipPathIdx++;
      var o = {
        id: a
      };
      n[t.id] = a, i[a] = Dr("clipPath", a, o, [
        mG(t, r)
      ]);
    }
    e["clip-path"] = Bm(a);
  }
  function pk(t) {
    return document.createTextNode(t);
  }
  function gl(t, e, r) {
    t.insertBefore(e, r);
  }
  function vk(t, e) {
    t.removeChild(e);
  }
  function gk(t, e) {
    t.appendChild(e);
  }
  function bG(t) {
    return t.parentNode;
  }
  function xG(t) {
    return t.nextSibling;
  }
  function o_(t, e) {
    t.textContent = e;
  }
  var mk = 58, Qie = 120, Jie = Dr("", "");
  function rw(t) {
    return t === void 0;
  }
  function ma(t) {
    return t !== void 0;
  }
  function eae(t, e, r) {
    for (var n = {}, i = e; i <= r; ++i) {
      var a = t[i].key;
      a !== void 0 && (n[a] = i);
    }
    return n;
  }
  function nf(t, e) {
    var r = t.key === e.key, n = t.tag === e.tag;
    return n && r;
  }
  function id(t) {
    var e, r = t.children, n = t.tag;
    if (ma(n)) {
      var i = t.elm = fG(n);
      if (QT(Jie, t), ae(r)) for (e = 0; e < r.length; ++e) {
        var a = r[e];
        a != null && gk(i, id(a));
      }
      else ma(t.text) && !Le(t.text) && gk(i, pk(t.text));
    } else t.elm = pk(t.text);
    return t.elm;
  }
  function wG(t, e, r, n, i) {
    for (; n <= i; ++n) {
      var a = r[n];
      a != null && gl(t, id(a), e);
    }
  }
  function jg(t, e, r, n) {
    for (; r <= n; ++r) {
      var i = e[r];
      if (i != null) if (ma(i.tag)) {
        var a = bG(i.elm);
        vk(a, i.elm);
      } else vk(t, i.elm);
    }
  }
  function QT(t, e) {
    var r, n = e.elm, i = t && t.attrs || {}, a = e.attrs || {};
    if (i !== a) {
      for (r in a) {
        var o = a[r], s = i[r];
        s !== o && (o === true ? n.setAttribute(r, "") : o === false ? n.removeAttribute(r) : r === "style" ? n.style.cssText = o : r.charCodeAt(0) !== Qie ? n.setAttribute(r, o) : r === "xmlns:xlink" || r === "xmlns" ? n.setAttributeNS(Lie, r, o) : r.charCodeAt(3) === mk ? n.setAttributeNS($ie, r, o) : r.charCodeAt(5) === mk ? n.setAttributeNS(hG, r, o) : n.setAttribute(r, o));
      }
      for (r in i) r in a || n.removeAttribute(r);
    }
  }
  function tae(t, e, r) {
    for (var n = 0, i = 0, a = e.length - 1, o = e[0], s = e[a], l = r.length - 1, u = r[0], c = r[l], h, f, d, p; n <= a && i <= l; ) o == null ? o = e[++n] : s == null ? s = e[--a] : u == null ? u = r[++i] : c == null ? c = r[--l] : nf(o, u) ? (qu(o, u), o = e[++n], u = r[++i]) : nf(s, c) ? (qu(s, c), s = e[--a], c = r[--l]) : nf(o, c) ? (qu(o, c), gl(t, o.elm, xG(s.elm)), o = e[++n], c = r[--l]) : nf(s, u) ? (qu(s, u), gl(t, s.elm, o.elm), s = e[--a], u = r[++i]) : (rw(h) && (h = eae(e, n, a)), f = h[u.key], rw(f) ? gl(t, id(u), o.elm) : (d = e[f], d.tag !== u.tag ? gl(t, id(u), o.elm) : (qu(d, u), e[f] = void 0, gl(t, d.elm, o.elm))), u = r[++i]);
    (n <= a || i <= l) && (n > a ? (p = r[l + 1] == null ? null : r[l + 1].elm, wG(t, p, r, i, l)) : jg(t, e, n, a));
  }
  function qu(t, e) {
    var r = e.elm = t.elm, n = t.children, i = e.children;
    t !== e && (QT(t, e), rw(e.text) ? ma(n) && ma(i) ? n !== i && tae(r, n, i) : ma(i) ? (ma(t.text) && o_(r, ""), wG(r, null, i, 0, i.length - 1)) : ma(n) ? jg(r, n, 0, n.length - 1) : ma(t.text) && o_(r, "") : t.text !== e.text && (ma(n) && jg(r, n, 0, n.length - 1), o_(r, e.text)));
  }
  function rae(t, e) {
    if (nf(t, e)) qu(t, e);
    else {
      var r = t.elm, n = bG(r);
      id(e), n !== null && (gl(n, e.elm, xG(r)), jg(n, [
        t
      ], 0, 0));
    }
    return e;
  }
  var nae = 0, iae = function() {
    function t(e, r, n) {
      if (this.type = "svg", this.refreshHover = yk(), this.configLayer = yk(), this.storage = r, this._opts = n = te({}, n), this.root = e, this._id = "zr" + nae++, this._oldVNode = ok(n.width, n.height), e && !n.ssr) {
        var i = this._viewport = document.createElement("div");
        i.style.cssText = "position:relative;overflow:hidden";
        var a = this._svgDom = this._oldVNode.elm = fG("svg");
        QT(null, this._oldVNode), i.appendChild(a), e.appendChild(i);
      }
      this.resize(n.width, n.height);
    }
    return t.prototype.getType = function() {
      return this.type;
    }, t.prototype.getViewportRoot = function() {
      return this._viewport;
    }, t.prototype.getViewportRootOffset = function() {
      var e = this.getViewportRoot();
      if (e) return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
    }, t.prototype.getSvgDom = function() {
      return this._svgDom;
    }, t.prototype.refresh = function() {
      if (this.root) {
        var e = this.renderToVNode({
          willUpdate: true
        });
        e.attrs.style = "position:absolute;left:0;top:0;user-select:none", rae(this._oldVNode, e), this._oldVNode = e;
      }
    }, t.prototype.renderOneToVNode = function(e) {
      return dk(e, tw(this._id));
    }, t.prototype.renderToVNode = function(e) {
      e = e || {};
      var r = this.storage.getDisplayList(true), n = this._width, i = this._height, a = tw(this._id);
      a.animation = e.animation, a.willUpdate = e.willUpdate, a.compress = e.compress, a.emphasis = e.emphasis, a.ssr = this._opts.ssr;
      var o = [], s = this._bgVNode = aae(n, i, this._backgroundColor, a);
      s && o.push(s);
      var l = e.compress ? null : this._mainVNode = Dr("g", "main", {}, []);
      this._paintList(r, a, l ? l.children : o), l && o.push(l);
      var u = oe(gt(a.defs), function(f) {
        return a.defs[f];
      });
      if (u.length && o.push(Dr("defs", "defs", {}, u)), e.animation) {
        var c = Nie(a.cssNodes, a.cssAnims, {
          newline: true
        });
        if (c) {
          var h = Dr("style", "stl", {}, [], c);
          o.push(h);
        }
      }
      return ok(n, i, o, e.useViewBox);
    }, t.prototype.renderToString = function(e) {
      return e = e || {}, XT(this.renderToVNode({
        animation: We(e.cssAnimation, true),
        emphasis: We(e.cssEmphasis, true),
        willUpdate: false,
        compress: true,
        useViewBox: We(e.useViewBox, true)
      }), {
        newline: true
      });
    }, t.prototype.setBackgroundColor = function(e) {
      this._backgroundColor = e;
    }, t.prototype.getSvgRoot = function() {
      return this._mainVNode && this._mainVNode.elm;
    }, t.prototype._paintList = function(e, r, n) {
      for (var i = e.length, a = [], o = 0, s, l, u = 0, c = 0; c < i; c++) {
        var h = e[c];
        if (!h.invisible) {
          var f = h.__clipPaths, d = f && f.length || 0, p = l && l.length || 0, v = void 0;
          for (v = Math.max(d - 1, p - 1); v >= 0 && !(f && l && f[v] === l[v]); v--) ;
          for (var g = p - 1; g > v; g--) o--, s = a[o - 1];
          for (var m = v + 1; m < d; m++) {
            var y = {};
            Zie(f[m], y, r);
            var _ = Dr("g", "clip-g-" + u++, y, []);
            (s ? s.children : n).push(_), a[o++] = _, s = _;
          }
          l = f;
          var b = dk(h, r);
          b && (s ? s.children : n).push(b);
        }
      }
    }, t.prototype.resize = function(e, r) {
      var n = this._opts, i = this.root, a = this._viewport;
      if (e != null && (n.width = e), r != null && (n.height = r), i && a && (a.style.display = "none", e = ic(i, 0, n), r = ic(i, 1, n), a.style.display = ""), this._width !== e || this._height !== r) {
        if (this._width = e, this._height = r, a) {
          var o = a.style;
          o.width = e + "px", o.height = r + "px";
        }
        if (eT(this._backgroundColor)) this.refresh();
        else {
          var s = this._svgDom;
          s && (s.setAttribute("width", e), s.setAttribute("height", r));
          var l = this._bgVNode && this._bgVNode.elm;
          l && (l.setAttribute("width", e), l.setAttribute("height", r));
        }
      }
    }, t.prototype.getWidth = function() {
      return this._width;
    }, t.prototype.getHeight = function() {
      return this._height;
    }, t.prototype.dispose = function() {
      this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
    }, t.prototype.clear = function() {
      this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
    }, t.prototype.toDataURL = function(e) {
      var r = this.renderToString(), n = "data:image/svg+xml;";
      return e ? (r = dZ(r), r && n + "base64," + r) : n + "charset=UTF-8," + encodeURIComponent(r);
    }, t;
  }();
  function yk(t) {
    return function() {
    };
  }
  function aae(t, e, r, n) {
    var i;
    if (r && r !== "none") if (i = Dr("rect", "bg", {
      width: t,
      height: e,
      x: "0",
      y: "0"
    }), qF(r)) yG({
      fill: r
    }, i.attrs, "fill", n);
    else if (eT(r)) _G({
      style: {
        fill: r
      },
      dirty: dr,
      getBoundingRect: function() {
        return {
          width: t,
          height: e
        };
      }
    }, i.attrs, "fill", n);
    else {
      var a = Hf(r), o = a.color, s = a.opacity;
      i.attrs.fill = o, s < 1 && (i.attrs["fill-opacity"] = s);
    }
    return i;
  }
  function oae(t) {
    t.registerPainter("svg", iae);
  }
  function _k(t, e, r) {
    var n = hs.createCanvas(), i = e.getWidth(), a = e.getHeight(), o = n.style;
    return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = i + "px", o.height = a + "px", n.setAttribute("data-zr-dom-id", t)), n.width = i * r, n.height = a * r, n;
  }
  var s_ = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this) || this;
      a.motionBlur = false, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = false, a.config = {}, a.incremental = false, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = true, a.__firstTimePaint = true, a.__used = false, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
      var o;
      i = i || Mg, typeof r == "string" ? o = _k(r, n, i) : Le(r) && (o = r, r = o.id), a.id = r, a.dom = o;
      var s = o.style;
      return s && (DF(o), o.onselectstart = function() {
        return false;
      }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = n, a.dpr = i, a;
    }
    return e.prototype.getElementCount = function() {
      return this.__endIndex - this.__startIndex;
    }, e.prototype.afterBrush = function() {
      this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
    }, e.prototype.initContext = function() {
      this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
    }, e.prototype.setUnpainted = function() {
      this.__firstTimePaint = true;
    }, e.prototype.createBackBuffer = function() {
      var r = this.dpr;
      this.domBack = _k("back-" + this.id, this.painter, r), this.ctxBack = this.domBack.getContext("2d"), r !== 1 && this.ctxBack.scale(r, r);
    }, e.prototype.createRepaintRects = function(r, n, i, a) {
      if (this.__firstTimePaint) return this.__firstTimePaint = false, null;
      var o = [], s = this.maxRepaintRectCount, l = false, u = new Ze(0, 0, 0, 0);
      function c(y) {
        if (!(!y.isFinite() || y.isZero())) if (o.length === 0) {
          var _ = new Ze(0, 0, 0, 0);
          _.copy(y), o.push(_);
        } else {
          for (var b = false, w = 1 / 0, x = 0, T = 0; T < o.length; ++T) {
            var A = o[T];
            if (A.intersect(y)) {
              var I = new Ze(0, 0, 0, 0);
              I.copy(A), I.union(y), o[T] = I, b = true;
              break;
            } else if (l) {
              u.copy(y), u.union(A);
              var M = y.width * y.height, k = A.width * A.height, B = u.width * u.height, L = B - M - k;
              L < w && (w = L, x = T);
            }
          }
          if (l && (o[x].union(y), b = true), !b) {
            var _ = new Ze(0, 0, 0, 0);
            _.copy(y), o.push(_);
          }
          l || (l = o.length >= s);
        }
      }
      for (var h = this.__startIndex; h < this.__endIndex; ++h) {
        var f = r[h];
        if (f) {
          var d = f.shouldBePainted(i, a, true, true), p = f.__isRendered && (f.__dirty & Ia || !d) ? f.getPrevPaintRect() : null;
          p && c(p);
          var v = d && (f.__dirty & Ia || !f.__isRendered) ? f.getPaintRect() : null;
          v && c(v);
        }
      }
      for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
        var f = n[h], d = f && f.shouldBePainted(i, a, true, true);
        if (f && (!d || !f.__zr) && f.__isRendered) {
          var p = f.getPrevPaintRect();
          p && c(p);
        }
      }
      var g;
      do {
        g = false;
        for (var h = 0; h < o.length; ) {
          if (o[h].isZero()) {
            o.splice(h, 1);
            continue;
          }
          for (var m = h + 1; m < o.length; ) o[h].intersect(o[m]) ? (g = true, o[h].union(o[m]), o.splice(m, 1)) : m++;
          h++;
        }
      } while (g);
      return this._paintRects = o, o;
    }, e.prototype.debugGetPaintRects = function() {
      return (this._paintRects || []).slice();
    }, e.prototype.resize = function(r, n) {
      var i = this.dpr, a = this.dom, o = a.style, s = this.domBack;
      o && (o.width = r + "px", o.height = n + "px"), a.width = r * i, a.height = n * i, s && (s.width = r * i, s.height = n * i, i !== 1 && this.ctxBack.scale(i, i));
    }, e.prototype.clear = function(r, n, i) {
      var a = this.dom, o = this.ctx, s = a.width, l = a.height;
      n = n || this.clearColor;
      var u = this.motionBlur && !r, c = this.lastFrameAlpha, h = this.dpr, f = this;
      u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / h, l / h));
      var d = this.domBack;
      function p(v, g, m, y) {
        if (o.clearRect(v, g, m, y), n && n !== "transparent") {
          var _ = void 0;
          if (Rm(n)) {
            var b = n.global || n.__width === m && n.__height === y;
            _ = b && n.__canvasGradient || Yx(o, n, {
              x: 0,
              y: 0,
              width: m,
              height: y
            }), n.__canvasGradient = _, n.__width = m, n.__height = y;
          } else bK(n) && (n.scaleX = n.scaleX || h, n.scaleY = n.scaleY || h, _ = qx(o, n, {
            dirty: function() {
              f.setUnpainted(), f.painter.refresh();
            }
          }));
          o.save(), o.fillStyle = _ || n, o.fillRect(v, g, m, y), o.restore();
        }
        u && (o.save(), o.globalAlpha = c, o.drawImage(d, v, g, m, y), o.restore());
      }
      !i || u ? p(0, 0, s, l) : i.length && $(i, function(v) {
        p(v.x * h, v.y * h, v.width * h, v.height * h);
      });
    }, e;
  }(xi), bk = 1e5, js = 314159, Yp = 0.01, sae = 1e-3;
  function lae(t) {
    return t ? t.__builtin__ ? true : !(typeof t.resize != "function" || typeof t.refresh != "function") : false;
  }
  function uae(t, e) {
    var r = document.createElement("div");
    return r.style.cssText = [
      "position:relative",
      "width:" + t + "px",
      "height:" + e + "px",
      "padding:0",
      "margin:0",
      "border-width:0"
    ].join(";") + ";", r;
  }
  var cae = function() {
    function t(e, r, n, i) {
      this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = false, this.type = "canvas";
      var a = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
      this._opts = n = te({}, n || {}), this.dpr = n.devicePixelRatio || Mg, this._singleCanvas = a, this.root = e;
      var o = e.style;
      o && (DF(e), e.innerHTML = ""), this.storage = r;
      var s = this._zlevelList;
      this._prevDisplayList = [];
      var l = this._layers;
      if (a) {
        var c = e, h = c.width, f = c.height;
        n.width != null && (h = n.width), n.height != null && (f = n.height), this.dpr = n.devicePixelRatio || 1, c.width = h * this.dpr, c.height = f * this.dpr, this._width = h, this._height = f;
        var d = new s_(c, this, this.dpr);
        d.__builtin__ = true, d.initContext(), l[js] = d, d.zlevel = js, s.push(js), this._domRoot = e;
      } else {
        this._width = ic(e, 0, n), this._height = ic(e, 1, n);
        var u = this._domRoot = uae(this._width, this._height);
        e.appendChild(u);
      }
    }
    return t.prototype.getType = function() {
      return "canvas";
    }, t.prototype.isSingleCanvas = function() {
      return this._singleCanvas;
    }, t.prototype.getViewportRoot = function() {
      return this._domRoot;
    }, t.prototype.getViewportRootOffset = function() {
      var e = this.getViewportRoot();
      if (e) return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
    }, t.prototype.refresh = function(e) {
      var r = this.storage.getDisplayList(true), n = this._prevDisplayList, i = this._zlevelList;
      this._redrawId = Math.random(), this._paintList(r, n, e, this._redrawId);
      for (var a = 0; a < i.length; a++) {
        var o = i[a], s = this._layers[o];
        if (!s.__builtin__ && s.refresh) {
          var l = a === 0 ? this._backgroundColor : null;
          s.refresh(l);
        }
      }
      return this._opts.useDirtyRect && (this._prevDisplayList = r.slice()), this;
    }, t.prototype.refreshHover = function() {
      this._paintHoverList(this.storage.getDisplayList(false));
    }, t.prototype._paintHoverList = function(e) {
      var r = e.length, n = this._hoverlayer;
      if (n && n.clear(), !!r) {
        for (var i = {
          inHover: true,
          viewWidth: this._width,
          viewHeight: this._height
        }, a, o = 0; o < r; o++) {
          var s = e[o];
          s.__inHover && (n || (n = this._hoverlayer = this.getLayer(bk)), a || (a = n.ctx, a.save()), Ml(a, s, i, o === r - 1));
        }
        a && a.restore();
      }
    }, t.prototype.getHoverLayer = function() {
      return this.getLayer(bk);
    }, t.prototype.paintOne = function(e, r) {
      o5(e, r);
    }, t.prototype._paintList = function(e, r, n, i) {
      if (this._redrawId === i) {
        n = n || false, this._updateLayerStatus(e);
        var a = this._doPaintList(e, r, n), o = a.finished, s = a.needsRefreshHover;
        if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), o) this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
        else {
          var l = this;
          Sg(function() {
            l._paintList(e, r, n, i);
          });
        }
      }
    }, t.prototype._compositeManually = function() {
      var e = this.getLayer(js).ctx, r = this._domRoot.width, n = this._domRoot.height;
      e.clearRect(0, 0, r, n), this.eachBuiltinLayer(function(i) {
        i.virtual && e.drawImage(i.dom, 0, 0, r, n);
      });
    }, t.prototype._doPaintList = function(e, r, n) {
      for (var i = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
        var l = this._zlevelList[s], u = this._layers[l];
        u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
      }
      for (var c = true, h = false, f = function(v) {
        var g = a[v], m = g.ctx, y = o && g.createRepaintRects(e, r, d._width, d._height), _ = n ? g.__startIndex : g.__drawIndex, b = !n && g.incremental && Date.now, w = b && Date.now(), x = g.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
        if (g.__startIndex === g.__endIndex) g.clear(false, x, y);
        else if (_ === g.__startIndex) {
          var T = e[_];
          (!T.incremental || !T.notClear || n) && g.clear(false, x, y);
        }
        _ === -1 && (console.error("For some unknown reason. drawIndex is -1"), _ = g.__startIndex);
        var A, I = function(L) {
          var z = {
            inHover: false,
            allClipped: false,
            prevEl: null,
            viewWidth: i._width,
            viewHeight: i._height
          };
          for (A = _; A < g.__endIndex; A++) {
            var F = e[A];
            if (F.__inHover && (h = true), i._doPaintEl(F, g, o, L, z, A === g.__endIndex - 1), b) {
              var E = Date.now() - w;
              if (E > 15) break;
            }
          }
          z.prevElClipPaths && m.restore();
        };
        if (y) if (y.length === 0) A = g.__endIndex;
        else for (var M = d.dpr, k = 0; k < y.length; ++k) {
          var B = y[k];
          m.save(), m.beginPath(), m.rect(B.x * M, B.y * M, B.width * M, B.height * M), m.clip(), I(B), m.restore();
        }
        else m.save(), I(), m.restore();
        g.__drawIndex = A, g.__drawIndex < g.__endIndex && (c = false);
      }, d = this, p = 0; p < a.length; p++) f(p);
      return ct.wxa && $(this._layers, function(v) {
        v && v.ctx && v.ctx.draw && v.ctx.draw();
      }), {
        finished: c,
        needsRefreshHover: h
      };
    }, t.prototype._doPaintEl = function(e, r, n, i, a, o) {
      var s = r.ctx;
      if (n) {
        var l = e.getPaintRect();
        (!i || l && l.intersect(i)) && (Ml(s, e, a, o), e.setPrevPaintRect(l));
      } else Ml(s, e, a, o);
    }, t.prototype.getLayer = function(e, r) {
      this._singleCanvas && !this._needsManuallyCompositing && (e = js);
      var n = this._layers[e];
      return n || (n = new s_("zr_" + e, this, this.dpr), n.zlevel = e, n.__builtin__ = true, this._layerConfig[e] ? je(n, this._layerConfig[e], true) : this._layerConfig[e - Yp] && je(n, this._layerConfig[e - Yp], true), r && (n.virtual = r), this.insertLayer(e, n), n.initContext()), n;
    }, t.prototype.insertLayer = function(e, r) {
      var n = this._layers, i = this._zlevelList, a = i.length, o = this._domRoot, s = null, l = -1;
      if (!n[e] && lae(r)) {
        if (a > 0 && e > i[0]) {
          for (l = 0; l < a - 1 && !(i[l] < e && i[l + 1] > e); l++) ;
          s = n[i[l]];
        }
        if (i.splice(l + 1, 0, e), n[e] = r, !r.virtual) if (s) {
          var u = s.dom;
          u.nextSibling ? o.insertBefore(r.dom, u.nextSibling) : o.appendChild(r.dom);
        } else o.firstChild ? o.insertBefore(r.dom, o.firstChild) : o.appendChild(r.dom);
        r.painter || (r.painter = this);
      }
    }, t.prototype.eachLayer = function(e, r) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i];
        e.call(r, this._layers[a], a);
      }
    }, t.prototype.eachBuiltinLayer = function(e, r) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i], o = this._layers[a];
        o.__builtin__ && e.call(r, o, a);
      }
    }, t.prototype.eachOtherLayer = function(e, r) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i], o = this._layers[a];
        o.__builtin__ || e.call(r, o, a);
      }
    }, t.prototype.getLayers = function() {
      return this._layers;
    }, t.prototype._updateLayerStatus = function(e) {
      this.eachBuiltinLayer(function(h, f) {
        h.__dirty = h.__used = false;
      });
      function r(h) {
        a && (a.__endIndex !== h && (a.__dirty = true), a.__endIndex = h);
      }
      if (this._singleCanvas) for (var n = 1; n < e.length; n++) {
        var i = e[n];
        if (i.zlevel !== e[n - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
      var a = null, o = 0, s, l;
      for (l = 0; l < e.length; l++) {
        var i = e[l], u = i.zlevel, c = void 0;
        s !== u && (s = u, o = 0), i.incremental ? (c = this.getLayer(u + sae, this._needsManuallyCompositing), c.incremental = true, o = 1) : c = this.getLayer(u + (o > 0 ? Yp : 0), this._needsManuallyCompositing), c.__builtin__ || YS("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = true, c.__startIndex !== l && (c.__dirty = true), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, r(l), a = c), i.__dirty & Ia && !i.__inHover && (c.__dirty = true, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
      }
      r(l), this.eachBuiltinLayer(function(h, f) {
        !h.__used && h.getElementCount() > 0 && (h.__dirty = true, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
      });
    }, t.prototype.clear = function() {
      return this.eachBuiltinLayer(this._clearLayer), this;
    }, t.prototype._clearLayer = function(e) {
      e.clear();
    }, t.prototype.setBackgroundColor = function(e) {
      this._backgroundColor = e, $(this._layers, function(r) {
        r.setUnpainted();
      });
    }, t.prototype.configLayer = function(e, r) {
      if (r) {
        var n = this._layerConfig;
        n[e] ? je(n[e], r, true) : n[e] = r;
        for (var i = 0; i < this._zlevelList.length; i++) {
          var a = this._zlevelList[i];
          if (a === e || a === e + Yp) {
            var o = this._layers[a];
            je(o, n[e], true);
          }
        }
      }
    }, t.prototype.delLayer = function(e) {
      var r = this._layers, n = this._zlevelList, i = r[e];
      i && (i.dom.parentNode.removeChild(i.dom), delete r[e], n.splice(et(n, e), 1));
    }, t.prototype.resize = function(e, r) {
      if (this._domRoot.style) {
        var n = this._domRoot;
        n.style.display = "none";
        var i = this._opts, a = this.root;
        if (e != null && (i.width = e), r != null && (i.height = r), e = ic(a, 0, i), r = ic(a, 1, i), n.style.display = "", this._width !== e || r !== this._height) {
          n.style.width = e + "px", n.style.height = r + "px";
          for (var o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(e, r);
          this.refresh(true);
        }
        this._width = e, this._height = r;
      } else {
        if (e == null || r == null) return;
        this._width = e, this._height = r, this.getLayer(js).resize(e, r);
      }
      return this;
    }, t.prototype.clearLayer = function(e) {
      var r = this._layers[e];
      r && r.clear();
    }, t.prototype.dispose = function() {
      this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
    }, t.prototype.getRenderedCanvas = function(e) {
      if (e = e || {}, this._singleCanvas && !this._compositeManually) return this._layers[js].dom;
      var r = new s_("image", this, e.pixelRatio || this.dpr);
      r.initContext(), r.clear(false, e.backgroundColor || this._backgroundColor);
      var n = r.ctx;
      if (e.pixelRatio <= this.dpr) {
        this.refresh();
        var i = r.dom.width, a = r.dom.height;
        this.eachLayer(function(h) {
          h.__builtin__ ? n.drawImage(h.dom, 0, 0, i, a) : h.renderToCanvas && (n.save(), h.renderToCanvas(n), n.restore());
        });
      } else for (var o = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(true), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        Ml(n, c, o, l === u - 1);
      }
      return r.dom;
    }, t.prototype.getWidth = function() {
      return this._width;
    }, t.prototype.getHeight = function() {
      return this._height;
    }, t;
  }();
  function hae(t) {
    t.registerPainter("canvas", cae);
  }
  var fae = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.hasSymbolVisual = true, r;
    }
    return e.prototype.getInitialData = function(r) {
      return So(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getLegendIcon = function(r) {
      var n = new Be(), i = mr("line", 0, r.itemHeight / 2, r.itemWidth, 0, r.lineStyle.stroke, false);
      n.add(i), i.setStyle(r.lineStyle);
      var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = r.itemHeight * 0.8, u = mr(s, (r.itemWidth - l) / 2, (r.itemHeight - l) / 2, l, l, r.itemStyle.fill);
      n.add(u), u.setStyle(r.itemStyle);
      var c = r.iconRotate === "inherit" ? o : r.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([
        r.itemWidth / 2,
        r.itemHeight / 2
      ]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), n;
    }, e.type = "series.line", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = {
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      clip: true,
      label: {
        position: "top"
      },
      endLabel: {
        show: false,
        valueAnimation: true,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: true
      },
      step: false,
      smooth: false,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: true,
      showAllSymbol: "auto",
      connectNulls: false,
      sampling: "none",
      animationEasing: "linear",
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: false
    }, e;
  }(Xt);
  function wc(t, e) {
    var r = t.mapDimensionsAll("defaultedLabel"), n = r.length;
    if (n === 1) {
      var i = _c(t, e, r[0]);
      return i != null ? i + "" : null;
    } else if (n) {
      for (var a = [], o = 0; o < r.length; o++) a.push(_c(t, e, r[o]));
      return a.join(" ");
    }
  }
  function SG(t, e) {
    var r = t.mapDimensionsAll("defaultedLabel");
    if (!ae(e)) return e + "";
    for (var n = [], i = 0; i < r.length; i++) {
      var a = t.getDimensionIndex(r[i]);
      a >= 0 && n.push(e[a]);
    }
    return n.join(" ");
  }
  var Vd = function(t) {
    K(e, t);
    function e(r, n, i, a) {
      var o = t.call(this) || this;
      return o.updateData(r, n, i, a), o;
    }
    return e.prototype._createSymbol = function(r, n, i, a, o) {
      this.removeAll();
      var s = mr(r, -1, -1, 2, 2, null, o);
      s.attr({
        z2: 100,
        culling: true,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), s.drift = dae, this._symbolType = r, this.add(s);
    }, e.prototype.stopSymbolAnimation = function(r) {
      this.childAt(0).stopAnimation(null, r);
    }, e.prototype.getSymbolType = function() {
      return this._symbolType;
    }, e.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, e.prototype.highlight = function() {
      fo(this.childAt(0));
    }, e.prototype.downplay = function() {
      po(this.childAt(0));
    }, e.prototype.setZ = function(r, n) {
      var i = this.childAt(0);
      i.zlevel = r, i.z = n;
    }, e.prototype.setDraggable = function(r, n) {
      var i = this.childAt(0);
      i.draggable = r, i.cursor = !n && r ? "move" : i.cursor;
    }, e.prototype.updateData = function(r, n, i, a) {
      this.silent = false;
      var o = r.getItemVisual(n, "symbol") || "circle", s = r.hostModel, l = e.getSymbolSize(r, n), u = o !== this._symbolType, c = a && a.disableAnimation;
      if (u) {
        var h = r.getItemVisual(n, "symbolKeepAspect");
        this._createSymbol(o, r, n, l, h);
      } else {
        var f = this.childAt(0);
        f.silent = false;
        var d = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? f.attr(d) : wt(f, d, s, n), Ki(f);
      }
      if (this._updateCommon(r, n, l, i, a), u) {
        var f = this.childAt(0);
        if (!c) {
          var d = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              opacity: f.style.opacity
            }
          };
          f.scaleX = f.scaleY = 0, f.style.opacity = 0, er(f, d, s, n);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, e.prototype._updateCommon = function(r, n, i, a, o) {
      var s = this.childAt(0), l = r.hostModel, u, c, h, f, d, p, v, g, m;
      if (a && (u = a.emphasisItemStyle, c = a.blurItemStyle, h = a.selectItemStyle, f = a.focus, d = a.blurScope, v = a.labelStatesModels, g = a.hoverScale, m = a.cursorStyle, p = a.emphasisDisabled), !a || r.hasItemOption) {
        var y = a && a.itemModel ? a.itemModel : r.getItemModel(n), _ = y.getModel("emphasis");
        u = _.getModel("itemStyle").getItemStyle(), h = y.getModel([
          "select",
          "itemStyle"
        ]).getItemStyle(), c = y.getModel([
          "blur",
          "itemStyle"
        ]).getItemStyle(), f = _.get("focus"), d = _.get("blurScope"), p = _.get("disabled"), v = Lr(y), g = _.getShallow("scale"), m = y.getShallow("cursor");
      }
      var b = r.getItemVisual(n, "symbolRotate");
      s.attr("rotation", (b || 0) * Math.PI / 180 || 0);
      var w = ou(r.getItemVisual(n, "symbolOffset"), i);
      w && (s.x = w[0], s.y = w[1]), m && s.attr("cursor", m);
      var x = r.getItemVisual(n, "style"), T = x.fill;
      if (s instanceof Gr) {
        var A = s.style;
        s.useStyle(te({
          image: A.image,
          x: A.x,
          y: A.y,
          width: A.width,
          height: A.height
        }, x));
      } else s.__isEmptyBrush ? s.useStyle(te({}, x)) : s.useStyle(x), s.style.decal = null, s.setColor(T, o && o.symbolInnerColor), s.style.strokeNoScale = true;
      var I = r.getItemVisual(n, "liftZ"), M = this._z2;
      I != null ? M == null && (this._z2 = s.z2, s.z2 += I) : M != null && (s.z2 = M, this._z2 = null);
      var k = o && o.useNameLabel;
      Xr(s, v, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: B,
        inheritColor: T,
        defaultOpacity: x.opacity
      });
      function B(F) {
        return k ? r.getName(F) : wc(r, F);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var L = s.ensureState("emphasis");
      L.style = u, s.ensureState("select").style = h, s.ensureState("blur").style = c;
      var z = g == null || g === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(g) && g > 0 ? +g : 1;
      L.scaleX = this._sizeX * z, L.scaleY = this._sizeY * z, this.setSymbolScale(1), ir(this, f, d, p);
    }, e.prototype.setSymbolScale = function(r) {
      this.scaleX = this.scaleY = r;
    }, e.prototype.fadeOut = function(r, n, i) {
      var a = this.childAt(0), o = Ge(this).dataIndex, s = i && i.animation;
      if (this.silent = a.silent = true, i && i.fadeLabel) {
        var l = a.getTextContent();
        l && ds(l, {
          style: {
            opacity: 0
          }
        }, n, {
          dataIndex: o,
          removeOpt: s,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else a.removeTextContent();
      ds(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, n, {
        dataIndex: o,
        cb: r,
        removeOpt: s
      });
    }, e.getSymbolSize = function(r, n) {
      return Kc(r.getItemVisual(n, "symbolSize"));
    }, e;
  }(Be);
  function dae(t, e) {
    this.parent.drift(t, e);
  }
  function l_(t, e, r, n) {
    return e && !isNaN(e[0]) && !isNaN(e[1]) && !(n.isIgnore && n.isIgnore(r)) && !(n.clipShape && !n.clipShape.contain(e[0], e[1])) && t.getItemVisual(r, "symbol") !== "none";
  }
  function xk(t) {
    return t != null && !Le(t) && (t = {
      isIgnore: t
    }), t || {};
  }
  function wk(t) {
    var e = t.hostModel, r = e.getModel("emphasis");
    return {
      emphasisItemStyle: r.getModel("itemStyle").getItemStyle(),
      blurItemStyle: e.getModel([
        "blur",
        "itemStyle"
      ]).getItemStyle(),
      selectItemStyle: e.getModel([
        "select",
        "itemStyle"
      ]).getItemStyle(),
      focus: r.get("focus"),
      blurScope: r.get("blurScope"),
      emphasisDisabled: r.get("disabled"),
      hoverScale: r.get("scale"),
      labelStatesModels: Lr(e),
      cursorStyle: e.get("cursor")
    };
  }
  var Gd = function() {
    function t(e) {
      this.group = new Be(), this._SymbolCtor = e || Vd;
    }
    return t.prototype.updateData = function(e, r) {
      this._progressiveEls = null, r = xk(r);
      var n = this.group, i = e.hostModel, a = this._data, o = this._SymbolCtor, s = r.disableAnimation, l = wk(e), u = {
        disableAnimation: s
      }, c = r.getSymbolPoint || function(h) {
        return e.getItemLayout(h);
      };
      a || n.removeAll(), e.diff(a).add(function(h) {
        var f = c(h);
        if (l_(e, f, h, r)) {
          var d = new o(e, h, l, u);
          d.setPosition(f), e.setItemGraphicEl(h, d), n.add(d);
        }
      }).update(function(h, f) {
        var d = a.getItemGraphicEl(f), p = c(h);
        if (!l_(e, p, h, r)) {
          n.remove(d);
          return;
        }
        var v = e.getItemVisual(h, "symbol") || "circle", g = d && d.getSymbolType && d.getSymbolType();
        if (!d || g && g !== v) n.remove(d), d = new o(e, h, l, u), d.setPosition(p);
        else {
          d.updateData(e, h, l, u);
          var m = {
            x: p[0],
            y: p[1]
          };
          s ? d.attr(m) : wt(d, m, i);
        }
        n.add(d), e.setItemGraphicEl(h, d);
      }).remove(function(h) {
        var f = a.getItemGraphicEl(h);
        f && f.fadeOut(function() {
          n.remove(f);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = e;
    }, t.prototype.updateLayout = function() {
      var e = this, r = this._data;
      r && r.eachItemGraphicEl(function(n, i) {
        var a = e._getSymbolPoint(i);
        n.setPosition(a), n.markRedraw();
      });
    }, t.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = wk(e), this._data = null, this.group.removeAll();
    }, t.prototype.incrementalUpdate = function(e, r, n) {
      this._progressiveEls = [], n = xk(n);
      function i(l) {
        l.isGroup || (l.incremental = true, l.ensureState("emphasis").hoverLayer = true);
      }
      for (var a = e.start; a < e.end; a++) {
        var o = r.getItemLayout(a);
        if (l_(r, o, a, n)) {
          var s = new this._SymbolCtor(r, a, this._seriesScope);
          s.traverse(i), s.setPosition(o), this.group.add(s), r.setItemGraphicEl(a, s), this._progressiveEls.push(s);
        }
      }
    }, t.prototype.eachRendered = function(e) {
      bs(this._progressiveEls || this.group, e);
    }, t.prototype.remove = function(e) {
      var r = this.group, n = this._data;
      n && e ? n.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          r.remove(i);
        }, n.hostModel);
      }) : r.removeAll();
    }, t;
  }();
  function TG(t, e, r) {
    var n = t.getBaseAxis(), i = t.getOtherAxis(n), a = pae(i, r), o = n.dim, s = i.dim, l = e.mapDimension(s), u = e.mapDimension(o), c = s === "x" || s === "radius" ? 1 : 0, h = oe(t.dimensions, function(p) {
      return e.mapDimension(p);
    }), f = false, d = e.getCalculationInfo("stackResultDimension");
    return vs(e, h[0]) && (f = true, h[0] = d), vs(e, h[1]) && (f = true, h[1] = d), {
      dataDimsForPoint: h,
      valueStart: a,
      valueAxisDim: s,
      baseAxisDim: o,
      stacked: !!f,
      valueDim: l,
      baseDim: u,
      baseDataOffset: c,
      stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
    };
  }
  function pae(t, e) {
    var r = 0, n = t.scale.getExtent();
    return e === "start" ? r = n[0] : e === "end" ? r = n[1] : xt(e) && !isNaN(e) ? r = e : n[0] > 0 ? r = n[0] : n[1] < 0 && (r = n[1]), r;
  }
  function CG(t, e, r, n) {
    var i = NaN;
    t.stacked && (i = r.get(r.getCalculationInfo("stackedOverDimension"), n)), isNaN(i) && (i = t.valueStart);
    var a = t.baseDataOffset, o = [];
    return o[a] = r.get(t.baseDim, n), o[1 - a] = i, e.dataToPoint(o);
  }
  function vae(t, e) {
    var r = [];
    return e.diff(t).add(function(n) {
      r.push({
        cmd: "+",
        idx: n
      });
    }).update(function(n, i) {
      r.push({
        cmd: "=",
        idx: i,
        idx1: n
      });
    }).remove(function(n) {
      r.push({
        cmd: "-",
        idx: n
      });
    }).execute(), r;
  }
  function gae(t, e, r, n, i, a, o, s) {
    for (var l = vae(t, e), u = [], c = [], h = [], f = [], d = [], p = [], v = [], g = TG(i, e, o), m = t.getLayout("points") || [], y = e.getLayout("points") || [], _ = 0; _ < l.length; _++) {
      var b = l[_], w = true, x = void 0, T = void 0;
      switch (b.cmd) {
        case "=":
          x = b.idx * 2, T = b.idx1 * 2;
          var A = m[x], I = m[x + 1], M = y[T], k = y[T + 1];
          (isNaN(A) || isNaN(I)) && (A = M, I = k), u.push(A, I), c.push(M, k), h.push(r[x], r[x + 1]), f.push(n[T], n[T + 1]), v.push(e.getRawIndex(b.idx1));
          break;
        case "+":
          var B = b.idx, L = g.dataDimsForPoint, z = i.dataToPoint([
            e.get(L[0], B),
            e.get(L[1], B)
          ]);
          T = B * 2, u.push(z[0], z[1]), c.push(y[T], y[T + 1]);
          var F = CG(g, i, e, B);
          h.push(F[0], F[1]), f.push(n[T], n[T + 1]), v.push(e.getRawIndex(B));
          break;
        case "-":
          w = false;
      }
      w && (d.push(b), p.push(p.length));
    }
    p.sort(function(ee, we) {
      return v[ee] - v[we];
    });
    for (var E = u.length, O = Ta(E), N = Ta(E), V = Ta(E), H = Ta(E), G = [], _ = 0; _ < p.length; _++) {
      var Y = p[_], U = _ * 2, Z = Y * 2;
      O[U] = u[Z], O[U + 1] = u[Z + 1], N[U] = c[Z], N[U + 1] = c[Z + 1], V[U] = h[Z], V[U + 1] = h[Z + 1], H[U] = f[Z], H[U + 1] = f[Z + 1], G[_] = d[Y];
    }
    return {
      current: O,
      next: N,
      stackedOnCurrent: V,
      stackedOnNext: H,
      status: G
    };
  }
  var Ro = Math.min, Oo = Math.max;
  function Fl(t, e) {
    return isNaN(t) || isNaN(e);
  }
  function nw(t, e, r, n, i, a, o, s, l) {
    for (var u, c, h, f, d, p, v = r, g = 0; g < n; g++) {
      var m = e[v * 2], y = e[v * 2 + 1];
      if (v >= i || v < 0) break;
      if (Fl(m, y)) {
        if (l) {
          v += a;
          continue;
        }
        break;
      }
      if (v === r) t[a > 0 ? "moveTo" : "lineTo"](m, y), h = m, f = y;
      else {
        var _ = m - u, b = y - c;
        if (_ * _ + b * b < 0.5) {
          v += a;
          continue;
        }
        if (o > 0) {
          for (var w = v + a, x = e[w * 2], T = e[w * 2 + 1]; x === m && T === y && g < n; ) g++, w += a, v += a, x = e[w * 2], T = e[w * 2 + 1], m = e[v * 2], y = e[v * 2 + 1], _ = m - u, b = y - c;
          var A = g + 1;
          if (l) for (; Fl(x, T) && A < n; ) A++, w += a, x = e[w * 2], T = e[w * 2 + 1];
          var I = 0.5, M = 0, k = 0, B = void 0, L = void 0;
          if (A >= n || Fl(x, T)) d = m, p = y;
          else {
            M = x - u, k = T - c;
            var z = m - u, F = x - m, E = y - c, O = T - y, N = void 0, V = void 0;
            if (s === "x") {
              N = Math.abs(z), V = Math.abs(F);
              var H = M > 0 ? 1 : -1;
              d = m - H * N * o, p = y, B = m + H * V * o, L = y;
            } else if (s === "y") {
              N = Math.abs(E), V = Math.abs(O);
              var G = k > 0 ? 1 : -1;
              d = m, p = y - G * N * o, B = m, L = y + G * V * o;
            } else N = Math.sqrt(z * z + E * E), V = Math.sqrt(F * F + O * O), I = V / (V + N), d = m - M * o * (1 - I), p = y - k * o * (1 - I), B = m + M * o * I, L = y + k * o * I, B = Ro(B, Oo(x, m)), L = Ro(L, Oo(T, y)), B = Oo(B, Ro(x, m)), L = Oo(L, Ro(T, y)), M = B - m, k = L - y, d = m - M * N / V, p = y - k * N / V, d = Ro(d, Oo(u, m)), p = Ro(p, Oo(c, y)), d = Oo(d, Ro(u, m)), p = Oo(p, Ro(c, y)), M = m - d, k = y - p, B = m + M * V / N, L = y + k * V / N;
          }
          t.bezierCurveTo(h, f, d, p, m, y), h = B, f = L;
        } else t.lineTo(m, y);
      }
      u = m, c = y, v += a;
    }
    return g;
  }
  var AG = /* @__PURE__ */ function() {
    function t() {
      this.smooth = 0, this.smoothConstraint = true;
    }
    return t;
  }(), mae = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "ec-polyline", n;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new AG();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.points, a = 0, o = i.length / 2;
      if (n.connectNulls) {
        for (; o > 0 && Fl(i[o * 2 - 2], i[o * 2 - 1]); o--) ;
        for (; a < o && Fl(i[a * 2], i[a * 2 + 1]); a++) ;
      }
      for (; a < o; ) a += nw(r, i, a, o, o, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1;
    }, e.prototype.getPointOn = function(r, n) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, a = i.data, o = Ra.CMD, s, l, u = n === "x", c = [], h = 0; h < a.length; ) {
        var f = a[h++], d = void 0, p = void 0, v = void 0, g = void 0, m = void 0, y = void 0, _ = void 0;
        switch (f) {
          case o.M:
            s = a[h++], l = a[h++];
            break;
          case o.L:
            if (d = a[h++], p = a[h++], _ = u ? (r - s) / (d - s) : (r - l) / (p - l), _ <= 1 && _ >= 0) {
              var b = u ? (p - l) * _ + l : (d - s) * _ + s;
              return u ? [
                r,
                b
              ] : [
                b,
                r
              ];
            }
            s = d, l = p;
            break;
          case o.C:
            d = a[h++], p = a[h++], v = a[h++], g = a[h++], m = a[h++], y = a[h++];
            var w = u ? Tg(s, d, v, m, r, c) : Tg(l, p, g, y, r, c);
            if (w > 0) for (var x = 0; x < w; x++) {
              var T = c[x];
              if (T <= 1 && T >= 0) {
                var b = u ? Ar(l, p, g, y, T) : Ar(s, d, v, m, T);
                return u ? [
                  r,
                  b
                ] : [
                  b,
                  r
                ];
              }
            }
            s = m, l = y;
            break;
        }
      }
    }, e;
  }(st), yae = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  }(AG), IG = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "ec-polygon", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new yae();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.points, a = n.stackedOnPoints, o = 0, s = i.length / 2, l = n.smoothMonotone;
      if (n.connectNulls) {
        for (; s > 0 && Fl(i[s * 2 - 2], i[s * 2 - 1]); s--) ;
        for (; o < s && Fl(i[o * 2], i[o * 2 + 1]); o++) ;
      }
      for (; o < s; ) {
        var u = nw(r, i, o, s, s, 1, n.smooth, l, n.connectNulls);
        nw(r, a, o + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls), o += u + 1, r.closePath();
      }
    }, e;
  }(st);
  function MG(t, e, r, n, i) {
    var a = t.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, c = r.get([
      "lineStyle",
      "width"
    ]) || 0;
    o -= c / 2, s -= c / 2, l += c, u += c, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++);
    var h = new yt({
      shape: {
        x: o,
        y: s,
        width: l,
        height: u
      }
    });
    if (e) {
      var f = t.getBaseAxis(), d = f.isHorizontal(), p = f.inverse;
      d ? (p && (h.shape.x += l), h.shape.width = 0) : (p || (h.shape.y += u), h.shape.height = 0);
      var v = De(i) ? function(g) {
        i(g, h);
      } : null;
      er(h, {
        shape: {
          width: l,
          height: u,
          x: o,
          y: s
        }
      }, r, null, n, v);
    }
    return h;
  }
  function DG(t, e, r) {
    var n = t.getArea(), i = lr(n.r0, 1), a = lr(n.r, 1), o = new wn({
      shape: {
        cx: lr(t.cx, 1),
        cy: lr(t.cy, 1),
        r0: i,
        r: a,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        clockwise: n.clockwise
      }
    });
    if (e) {
      var s = t.getBaseAxis().dim === "angle";
      s ? o.shape.endAngle = n.startAngle : o.shape.r = i, er(o, {
        shape: {
          endAngle: n.endAngle,
          r: a
        }
      }, r);
    }
    return o;
  }
  function Wd(t, e, r, n, i) {
    if (t) {
      if (t.type === "polar") return DG(t, e, r);
      if (t.type === "cartesian2d") return MG(t, e, r, n, i);
    } else return null;
    return null;
  }
  function lu(t, e) {
    return t.type === e;
  }
  function Sk(t, e) {
    if (t.length === e.length) {
      for (var r = 0; r < t.length; r++) if (t[r] !== e[r]) return;
      return true;
    }
  }
  function Tk(t) {
    for (var e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0; a < t.length; ) {
      var o = t[a++], s = t[a++];
      isNaN(o) || (e = Math.min(o, e), n = Math.max(o, n)), isNaN(s) || (r = Math.min(s, r), i = Math.max(s, i));
    }
    return [
      [
        e,
        r
      ],
      [
        n,
        i
      ]
    ];
  }
  function Ck(t, e) {
    var r = Tk(t), n = r[0], i = r[1], a = Tk(e), o = a[0], s = a[1];
    return Math.max(Math.abs(n[0] - o[0]), Math.abs(n[1] - o[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
  }
  function Ak(t) {
    return xt(t) ? t : t ? 0.5 : 0;
  }
  function _ae(t, e, r) {
    if (!r.valueDim) return [];
    for (var n = e.count(), i = Ta(n * 2), a = 0; a < n; a++) {
      var o = CG(r, t, e, a);
      i[a * 2] = o[0], i[a * 2 + 1] = o[1];
    }
    return i;
  }
  function No(t, e, r, n, i) {
    var a = r.getBaseAxis(), o = a.dim === "x" || a.dim === "radius" ? 0 : 1, s = [], l = 0, u = [], c = [], h = [], f = [];
    if (i) {
      for (l = 0; l < t.length; l += 2) {
        var d = e || t;
        !isNaN(d[l]) && !isNaN(d[l + 1]) && f.push(t[l], t[l + 1]);
      }
      t = f;
    }
    for (l = 0; l < t.length - 2; l += 2) switch (h[0] = t[l + 2], h[1] = t[l + 3], c[0] = t[l], c[1] = t[l + 1], s.push(c[0], c[1]), n) {
      case "end":
        u[o] = h[o], u[1 - o] = c[1 - o], s.push(u[0], u[1]);
        break;
      case "middle":
        var p = (c[o] + h[o]) / 2, v = [];
        u[o] = v[o] = p, u[1 - o] = c[1 - o], v[1 - o] = h[1 - o], s.push(u[0], u[1]), s.push(v[0], v[1]);
        break;
      default:
        u[o] = c[o], u[1 - o] = h[1 - o], s.push(u[0], u[1]);
    }
    return s.push(t[l++], t[l++]), s;
  }
  function bae(t, e) {
    var r = [], n = t.length, i, a;
    function o(c, h, f) {
      var d = c.coord, p = (f - d) / (h.coord - d), v = aZ(p, [
        c.color,
        h.color
      ]);
      return {
        coord: f,
        color: v
      };
    }
    for (var s = 0; s < n; s++) {
      var l = t[s], u = l.coord;
      if (u < 0) i = l;
      else if (u > e) {
        a ? r.push(o(a, l, e)) : i && r.push(o(i, l, 0), o(i, l, e));
        break;
      } else i && (r.push(o(i, l, 0)), i = null), r.push(l), a = l;
    }
    return r;
  }
  function xae(t, e, r) {
    var n = t.getVisual("visualMeta");
    if (!(!n || !n.length || !t.count()) && e.type === "cartesian2d") {
      for (var i, a, o = n.length - 1; o >= 0; o--) {
        var s = t.getDimensionInfo(n[o].dimension);
        if (i = s && s.coordDim, i === "x" || i === "y") {
          a = n[o];
          break;
        }
      }
      if (a) {
        var l = e.getAxis(i), u = oe(a.stops, function(_) {
          return {
            coord: l.toGlobalCoord(l.dataToCoord(_.value)),
            color: _.color
          };
        }), c = u.length, h = a.outerColors.slice();
        c && u[0].coord > u[c - 1].coord && (u.reverse(), h.reverse());
        var f = bae(u, i === "x" ? r.getWidth() : r.getHeight()), d = f.length;
        if (!d && c) return u[0].coord < 0 ? h[1] ? h[1] : u[c - 1].color : h[0] ? h[0] : u[0].color;
        var p = 10, v = f[0].coord - p, g = f[d - 1].coord + p, m = g - v;
        if (m < 1e-3) return "transparent";
        $(f, function(_) {
          _.offset = (_.coord - v) / m;
        }), f.push({
          offset: d ? f[d - 1].offset : 0.5,
          color: h[1] || "transparent"
        }), f.unshift({
          offset: d ? f[0].offset : 0.5,
          color: h[0] || "transparent"
        });
        var y = new $d(0, 0, 0, 0, f, true);
        return y[i] = v, y[i + "2"] = g, y;
      }
    }
  }
  function wae(t, e, r) {
    var n = t.get("showAllSymbol"), i = n === "auto";
    if (!(n && !i)) {
      var a = r.getAxesByScale("ordinal")[0];
      if (a && !(i && Sae(a, e))) {
        var o = e.mapDimension(a.dim), s = {};
        return $(a.getViewLabels(), function(l) {
          var u = a.scale.getRawOrdinalNumber(l.tickValue);
          s[u] = 1;
        }), function(l) {
          return !s.hasOwnProperty(e.get(o, l));
        };
      }
    }
  }
  function Sae(t, e) {
    var r = t.getExtent(), n = Math.abs(r[1] - r[0]) / t.scale.count();
    isNaN(n) && (n = 0);
    for (var i = e.count(), a = Math.max(1, Math.round(i / 5)), o = 0; o < i; o += a) if (Vd.getSymbolSize(e, o)[t.isHorizontal() ? 1 : 0] * 1.5 > n) return false;
    return true;
  }
  function Tae(t, e) {
    return isNaN(t) || isNaN(e);
  }
  function Cae(t) {
    for (var e = t.length / 2; e > 0 && Tae(t[e * 2 - 2], t[e * 2 - 1]); e--) ;
    return e - 1;
  }
  function Ik(t, e) {
    return [
      t[e * 2],
      t[e * 2 + 1]
    ];
  }
  function Aae(t, e, r) {
    for (var n = t.length / 2, i = r === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < n; u++) if (o = t[u * 2 + i], !(isNaN(o) || isNaN(t[u * 2 + 1 - i]))) {
      if (u === 0) {
        a = o;
        continue;
      }
      if (a <= e && o >= e || a >= e && o <= e) {
        l = u;
        break;
      }
      s = u, a = o;
    }
    return {
      range: [
        s,
        l
      ],
      t: (e - a) / (o - a)
    };
  }
  function EG(t) {
    if (t.get([
      "endLabel",
      "show"
    ])) return true;
    for (var e = 0; e < xn.length; e++) if (t.get([
      xn[e],
      "endLabel",
      "show"
    ])) return true;
    return false;
  }
  function u_(t, e, r, n) {
    if (lu(e, "cartesian2d")) {
      var i = n.getModel("endLabel"), a = i.get("valueAnimation"), o = n.getData(), s = {
        lastFrameIndex: 0
      }, l = EG(n) ? function(d, p) {
        t._endLabelOnDuring(d, p, o, s, a, i, e);
      } : null, u = e.getBaseAxis().isHorizontal(), c = MG(e, r, n, function() {
        var d = t._endLabel;
        d && r && s.originalX != null && d.attr({
          x: s.originalX,
          y: s.originalY
        });
      }, l);
      if (!n.get("clip", true)) {
        var h = c.shape, f = Math.max(h.width, h.height);
        u ? (h.y -= f, h.height += f * 2) : (h.x -= f, h.width += f * 2);
      }
      return l && l(1, c), c;
    } else return DG(e, r, n);
  }
  function Iae(t, e) {
    var r = e.getBaseAxis(), n = r.isHorizontal(), i = r.inverse, a = n ? i ? "right" : "left" : "center", o = n ? "middle" : i ? "top" : "bottom";
    return {
      normal: {
        align: t.get("align") || a,
        verticalAlign: t.get("verticalAlign") || o
      }
    };
  }
  var Mae = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      var r = new Be(), n = new Gd();
      this.group.add(n.group), this._symbolDraw = n, this._lineGroup = r, this._changePolyState = _e(this._changePolyState, this);
    }, e.prototype.render = function(r, n, i) {
      var a = r.coordinateSystem, o = this.group, s = r.getData(), l = r.getModel("lineStyle"), u = r.getModel("areaStyle"), c = s.getLayout("points") || [], h = a.type === "polar", f = this._coordSys, d = this._symbolDraw, p = this._polyline, v = this._polygon, g = this._lineGroup, m = !n.ssr && r.get("animation"), y = !u.isEmpty(), _ = u.get("origin"), b = TG(a, s, _), w = y && _ae(a, s, b), x = r.get("showSymbol"), T = r.get("connectNulls"), A = x && !h && wae(r, s, a), I = this._data;
      I && I.eachItemGraphicEl(function(ee, we) {
        ee.__temp && (o.remove(ee), I.setItemGraphicEl(we, null));
      }), x || d.remove(), o.add(g);
      var M = h ? false : r.get("step"), k;
      a && a.getArea && r.get("clip", true) && (k = a.getArea(), k.width != null ? (k.x -= 0.1, k.y -= 0.1, k.width += 0.2, k.height += 0.2) : k.r0 && (k.r0 -= 0.5, k.r += 0.5)), this._clipShapeForSymbol = k;
      var B = xae(s, a, i) || s.getVisual("style")[s.getVisual("drawType")];
      if (!(p && f.type === a.type && M === this._step)) x && d.updateData(s, {
        isIgnore: A,
        clipShape: k,
        disableAnimation: true,
        getSymbolPoint: function(ee) {
          return [
            c[ee * 2],
            c[ee * 2 + 1]
          ];
        }
      }), m && this._initSymbolLabelAnimation(s, a, k), M && (w && (w = No(w, c, a, M, T)), c = No(c, null, a, M, T)), p = this._newPolyline(c), y ? v = this._newPolygon(c, w) : v && (g.remove(v), v = this._polygon = null), h || this._initOrUpdateEndLabel(r, a, jl(B)), g.setClipPath(u_(this, a, true, r));
      else {
        y && !v ? v = this._newPolygon(c, w) : v && !y && (g.remove(v), v = this._polygon = null), h || this._initOrUpdateEndLabel(r, a, jl(B));
        var L = g.getClipPath();
        if (L) {
          var z = u_(this, a, false, r);
          er(L, {
            shape: z.shape
          }, r);
        } else g.setClipPath(u_(this, a, true, r));
        x && d.updateData(s, {
          isIgnore: A,
          clipShape: k,
          disableAnimation: true,
          getSymbolPoint: function(ee) {
            return [
              c[ee * 2],
              c[ee * 2 + 1]
            ];
          }
        }), (!Sk(this._stackedOnPoints, w) || !Sk(this._points, c)) && (m ? this._doUpdateAnimation(s, w, a, i, M, _, T) : (M && (w && (w = No(w, c, a, M, T)), c = No(c, null, a, M, T)), p.setShape({
          points: c
        }), v && v.setShape({
          points: c,
          stackedOnPoints: w
        })));
      }
      var F = r.getModel("emphasis"), E = F.get("focus"), O = F.get("blurScope"), N = F.get("disabled");
      if (p.useStyle(Ee(l.getLineStyle(), {
        fill: "none",
        stroke: B,
        lineJoin: "bevel"
      })), qr(p, r, "lineStyle"), p.style.lineWidth > 0 && r.get([
        "emphasis",
        "lineStyle",
        "width"
      ]) === "bolder") {
        var V = p.getState("emphasis").style;
        V.lineWidth = +p.style.lineWidth + 1;
      }
      Ge(p).seriesIndex = r.seriesIndex, ir(p, E, O, N);
      var H = Ak(r.get("smooth")), G = r.get("smoothMonotone");
      if (p.setShape({
        smooth: H,
        smoothMonotone: G,
        connectNulls: T
      }), v) {
        var Y = s.getCalculationInfo("stackedOnSeries"), U = 0;
        v.useStyle(Ee(u.getAreaStyle(), {
          fill: B,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: s.getVisual("style").decal
        })), Y && (U = Ak(Y.get("smooth"))), v.setShape({
          smooth: H,
          stackedOnSmooth: U,
          smoothMonotone: G,
          connectNulls: T
        }), qr(v, r, "areaStyle"), Ge(v).seriesIndex = r.seriesIndex, ir(v, E, O, N);
      }
      var Z = this._changePolyState;
      s.eachItemGraphicEl(function(ee) {
        ee && (ee.onHoverStateChange = Z);
      }), this._polyline.onHoverStateChange = Z, this._data = s, this._coordSys = a, this._stackedOnPoints = w, this._points = c, this._step = M, this._valueOrigin = _, r.get("triggerLineEvent") && (this.packEventData(r, p), v && this.packEventData(r, v));
    }, e.prototype.packEventData = function(r, n) {
      Ge(n).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: r.componentIndex,
        seriesIndex: r.seriesIndex,
        seriesName: r.name,
        seriesType: "line"
      };
    }, e.prototype.highlight = function(r, n, i, a) {
      var o = r.getData(), s = Yl(o, a);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], h = l[s * 2 + 1];
          if (isNaN(c) || isNaN(h) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, h)) return;
          var f = r.get("zlevel") || 0, d = r.get("z") || 0;
          u = new Vd(o, s), u.x = c, u.y = h, u.setZ(f, d);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = f, p.z = d, p.z2 = this._polyline.z2 + 1), u.__temp = true, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(true), this.group.add(u);
        }
        u.highlight();
      } else Ft.prototype.highlight.call(this, r, n, i, a);
    }, e.prototype.downplay = function(r, n, i, a) {
      var o = r.getData(), s = Yl(o, a);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = o.getItemGraphicEl(s);
        l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else Ft.prototype.downplay.call(this, r, n, i, a);
    }, e.prototype._changePolyState = function(r) {
      var n = this._polygon;
      kg(this._polyline, r), n && kg(n, r);
    }, e.prototype._newPolyline = function(r) {
      var n = this._polyline;
      return n && this._lineGroup.remove(n), n = new mae({
        shape: {
          points: r
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(n), this._polyline = n, n;
    }, e.prototype._newPolygon = function(r, n) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new IG({
        shape: {
          points: r,
          stackedOnPoints: n
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, e.prototype._initSymbolLabelAnimation = function(r, n, i) {
      var a, o, s = n.getBaseAxis(), l = s.inverse;
      n.type === "cartesian2d" ? (a = s.isHorizontal(), o = false) : n.type === "polar" && (a = s.dim === "angle", o = true);
      var u = r.hostModel, c = u.get("animationDuration");
      De(c) && (c = c(null));
      var h = u.get("animationDelay") || 0, f = De(h) ? h(null) : h;
      r.eachItemGraphicEl(function(d, p) {
        var v = d;
        if (v) {
          var g = [
            d.x,
            d.y
          ], m = void 0, y = void 0, _ = void 0;
          if (i) if (o) {
            var b = i, w = n.pointToCoord(g);
            a ? (m = b.startAngle, y = b.endAngle, _ = -w[1] / 180 * Math.PI) : (m = b.r0, y = b.r, _ = w[0]);
          } else {
            var x = i;
            a ? (m = x.x, y = x.x + x.width, _ = d.x) : (m = x.y + x.height, y = x.y, _ = d.y);
          }
          var T = y === m ? 0 : (_ - m) / (y - m);
          l && (T = 1 - T);
          var A = De(h) ? h(p) : c * T + f, I = v.getSymbolPath(), M = I.getTextContent();
          v.attr({
            scaleX: 0,
            scaleY: 0
          }), v.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: true,
            delay: A
          }), M && M.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: A
          }), I.disableLabelAnimation = true;
        }
      });
    }, e.prototype._initOrUpdateEndLabel = function(r, n, i) {
      var a = r.getModel("endLabel");
      if (EG(r)) {
        var o = r.getData(), s = this._polyline, l = o.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new bt({
          z2: 200
        }), u.ignoreClip = true, s.setTextContent(this._endLabel), s.disableLabelAnimation = true);
        var c = Cae(l);
        c >= 0 && (Xr(s, Lr(r, "endLabel"), {
          inheritColor: i,
          labelFetcher: r,
          labelDataIndex: c,
          defaultText: function(h, f, d) {
            return d != null ? SG(o, d) : wc(o, h);
          },
          enableTextSetter: true
        }, Iae(a, n)), s.textConfig.position = null);
      } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, e.prototype._endLabelOnDuring = function(r, n, i, a, o, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        r < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var h = i.getLayout("points"), f = i.hostModel, d = f.get("connectNulls"), p = s.get("precision"), v = s.get("distance") || 0, g = l.getBaseAxis(), m = g.isHorizontal(), y = g.inverse, _ = n.shape, b = y ? m ? _.x : _.y + _.height : m ? _.x + _.width : _.y, w = (m ? v : 0) * (y ? -1 : 1), x = (m ? 0 : -v) * (y ? -1 : 1), T = m ? "x" : "y", A = Aae(h, b, T), I = A.range, M = I[1] - I[0], k = void 0;
        if (M >= 1) {
          if (M > 1 && !d) {
            var B = Ik(h, I[0]);
            u.attr({
              x: B[0] + w,
              y: B[1] + x
            }), o && (k = f.getRawValue(I[0]));
          } else {
            var B = c.getPointOn(b, T);
            B && u.attr({
              x: B[0] + w,
              y: B[1] + x
            });
            var L = f.getRawValue(I[0]), z = f.getRawValue(I[1]);
            o && (k = p4(i, p, L, z, A.t));
          }
          a.lastFrameIndex = I[0];
        } else {
          var F = r === 1 || a.lastFrameIndex > 0 ? I[0] : 0, B = Ik(h, F);
          o && (k = f.getRawValue(F)), u.attr({
            x: B[0] + w,
            y: B[1] + x
          });
        }
        if (o) {
          var E = Wc(u);
          typeof E.setLabelText == "function" && E.setLabelText(k);
        }
      }
    }, e.prototype._doUpdateAnimation = function(r, n, i, a, o, s, l) {
      var u = this._polyline, c = this._polygon, h = r.hostModel, f = gae(this._data, r, this._stackedOnPoints, n, this._coordSys, i, this._valueOrigin), d = f.current, p = f.stackedOnCurrent, v = f.next, g = f.stackedOnNext;
      if (o && (p = No(f.stackedOnCurrent, f.current, i, o, l), d = No(f.current, null, i, o, l), g = No(f.stackedOnNext, f.next, i, o, l), v = No(f.next, null, i, o, l)), Ck(d, v) > 3e3 || c && Ck(p, g) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: v
        }), c && (c.stopAnimation(), c.setShape({
          points: v,
          stackedOnPoints: g
        }));
        return;
      }
      u.shape.__points = f.current, u.shape.points = d;
      var m = {
        shape: {
          points: v
        }
      };
      f.current !== d && (m.shape.__points = f.next), u.stopAnimation(), wt(u, m, h), c && (c.setShape({
        points: d,
        stackedOnPoints: p
      }), c.stopAnimation(), wt(c, {
        shape: {
          stackedOnPoints: g
        }
      }, h), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], _ = f.status, b = 0; b < _.length; b++) {
        var w = _[b].cmd;
        if (w === "=") {
          var x = r.getItemGraphicEl(_[b].idx1);
          x && y.push({
            el: x,
            ptIdx: b
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var T = u.shape.__points, A = 0; A < y.length; A++) {
          var I = y[A].el, M = y[A].ptIdx * 2;
          I.x = T[M], I.y = T[M + 1], I.markRedraw();
        }
      });
    }, e.prototype.remove = function(r) {
      var n = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(true), i && i.eachItemGraphicEl(function(a, o) {
        a.__temp && (n.remove(a), i.setItemGraphicEl(o, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, e.type = "line", e;
  }(Ft);
  function Hd(t, e) {
    return {
      seriesType: t,
      plan: Xc(),
      reset: function(r) {
        var n = r.getData(), i = r.coordinateSystem, a = r.pipelineContext, o = e || a.large;
        if (i) {
          var s = oe(i.dimensions, function(d) {
            return n.mapDimension(d);
          }).slice(0, 2), l = s.length, u = n.getCalculationInfo("stackResultDimension");
          vs(n, s[0]) && (s[0] = u), vs(n, s[1]) && (s[1] = u);
          var c = n.getStore(), h = n.getDimensionIndex(s[0]), f = n.getDimensionIndex(s[1]);
          return l && {
            progress: function(d, p) {
              for (var v = d.end - d.start, g = o && Ta(v * l), m = [], y = [], _ = d.start, b = 0; _ < d.end; _++) {
                var w = void 0;
                if (l === 1) {
                  var x = c.get(h, _);
                  w = i.dataToPoint(x, null, y);
                } else m[0] = c.get(h, _), m[1] = c.get(f, _), w = i.dataToPoint(m, null, y);
                o ? (g[b++] = w[0], g[b++] = w[1]) : p.setItemLayout(_, w.slice());
              }
              o && p.setLayout("points", g);
            }
          };
        }
      }
    };
  }
  var Dae = {
    average: function(t) {
      for (var e = 0, r = 0, n = 0; n < t.length; n++) isNaN(t[n]) || (e += t[n], r++);
      return r === 0 ? NaN : e / r;
    },
    sum: function(t) {
      for (var e = 0, r = 0; r < t.length; r++) e += t[r] || 0;
      return e;
    },
    max: function(t) {
      for (var e = -1 / 0, r = 0; r < t.length; r++) t[r] > e && (e = t[r]);
      return isFinite(e) ? e : NaN;
    },
    min: function(t) {
      for (var e = 1 / 0, r = 0; r < t.length; r++) t[r] < e && (e = t[r]);
      return isFinite(e) ? e : NaN;
    },
    nearest: function(t) {
      return t[0];
    }
  }, Eae = function(t) {
    return Math.round(t.length / 2);
  };
  function kG(t) {
    return {
      seriesType: t,
      reset: function(e, r, n) {
        var i = e.getData(), a = e.get("sampling"), o = e.coordinateSystem, s = i.count();
        if (s > 10 && o.type === "cartesian2d" && a) {
          var l = o.getBaseAxis(), u = o.getOtherAxis(l), c = l.getExtent(), h = n.getDevicePixelRatio(), f = Math.abs(c[1] - c[0]) * (h || 1), d = Math.round(s / f);
          if (isFinite(d) && d > 1) {
            a === "lttb" ? e.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / d)) : a === "minmax" && e.setData(i.minmaxDownSample(i.mapDimension(u.dim), 1 / d));
            var p = void 0;
            me(a) ? p = Dae[a] : De(a) && (p = a), p && e.setData(i.downSample(i.mapDimension(u.dim), 1 / d, p, Eae));
          }
        }
      }
    };
  }
  function kae(t) {
    t.registerChartView(Mae), t.registerSeriesModel(fae), t.registerLayout(Hd("line", true)), t.registerVisual({
      seriesType: "line",
      reset: function(e) {
        var r = e.getData(), n = e.getModel("lineStyle").getLineStyle();
        n && !n.stroke && (n.stroke = r.getVisual("style").fill), r.setVisual("legendLineStyle", n);
      }
    }), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, kG("line"));
  }
  var ad = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.getInitialData = function(r, n) {
      return So(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getMarkerPosition = function(r, n, i) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var o = a.clampData(r), s = a.dataToPoint(o);
        if (i) $(a.getAxes(), function(f, d) {
          if (f.type === "category" && n != null) {
            var p = f.getTicksCoords(), v = f.getTickModel().get("alignWithLabel"), g = o[d], m = n[d] === "x1" || n[d] === "y1";
            if (m && !v && (g += 1), p.length < 2) return;
            if (p.length === 2) {
              s[d] = f.toGlobalCoord(f.getExtent()[m ? 1 : 0]);
              return;
            }
            for (var y = void 0, _ = void 0, b = 1, w = 0; w < p.length; w++) {
              var x = p[w].coord, T = w === p.length - 1 ? p[w - 1].tickValue + b : p[w].tickValue;
              if (T === g) {
                _ = x;
                break;
              } else if (T < g) y = x;
              else if (y != null && T > g) {
                _ = (x + y) / 2;
                break;
              }
              w === 1 && (b = T - p[0].tickValue);
            }
            _ == null && (y ? y && (_ = p[p.length - 1].coord) : _ = p[0].coord), s[d] = f.toGlobalCoord(_);
          }
        });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), h = a.getBaseAxis().isHorizontal() ? 0 : 1;
          s[h] += u + c / 2;
        }
        return s;
      }
      return [
        NaN,
        NaN
      ];
    }, e.type = "series.__base_bar__", e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      barMinHeight: 0,
      barMinAngle: 0,
      large: false,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, e;
  }(Xt);
  Xt.registerClass(ad);
  var Pae = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.getInitialData = function() {
      return So(null, this, {
        useEncodeDefaulter: true,
        createInvertedIndices: !!this.get("realtimeSort", true) || null
      });
    }, e.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : false;
    }, e.prototype.getProgressiveThreshold = function() {
      var r = this.get("progressiveThreshold"), n = this.get("largeThreshold");
      return n > r && (r = n), r;
    }, e.prototype.brushSelector = function(r, n, i) {
      return i.rect(n.getItemLayout(r));
    }, e.type = "series.bar", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = xs(ad.defaultOption, {
      clip: true,
      roundCap: false,
      showBackground: false,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: false
    }), e;
  }(ad), Lae = /* @__PURE__ */ function() {
    function t() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
    }
    return t;
  }(), Kg = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "sausage", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new Lae();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.cx, a = n.cy, o = Math.max(n.r0 || 0, 0), s = Math.max(n.r, 0), l = (s - o) * 0.5, u = o + l, c = n.startAngle, h = n.endAngle, f = n.clockwise, d = Math.PI * 2, p = f ? h - c < d : c - h < d;
      p || (c = h - (f ? d : -d));
      var v = Math.cos(c), g = Math.sin(c), m = Math.cos(h), y = Math.sin(h);
      p ? (r.moveTo(v * o + i, g * o + a), r.arc(v * u + i, g * u + a, l, -Math.PI + c, c, !f)) : r.moveTo(v * s + i, g * s + a), r.arc(i, a, s, c, h, !f), r.arc(m * u + i, y * u + a, l, h - Math.PI * 2, h - Math.PI, !f), o !== 0 && r.arc(i, a, o, h, c, f);
    }, e;
  }(st);
  function $ae(t, e) {
    e = e || {};
    var r = e.isRoundCap;
    return function(n, i, a) {
      var o = i.position;
      if (!o || o instanceof Array) return Dg(n, i, a);
      var s = t(o), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, h = u.cy, f = u.r, d = u.r0, p = (f + d) / 2, v = u.startAngle, g = u.endAngle, m = (v + g) / 2, y = r ? Math.abs(f - d) / 2 : 0, _ = Math.cos, b = Math.sin, w = c + f * _(v), x = h + f * b(v), T = "left", A = "top";
      switch (s) {
        case "startArc":
          w = c + (d - l) * _(m), x = h + (d - l) * b(m), T = "center", A = "top";
          break;
        case "insideStartArc":
          w = c + (d + l) * _(m), x = h + (d + l) * b(m), T = "center", A = "bottom";
          break;
        case "startAngle":
          w = c + p * _(v) + qp(v, l + y, false), x = h + p * b(v) + Xp(v, l + y, false), T = "right", A = "middle";
          break;
        case "insideStartAngle":
          w = c + p * _(v) + qp(v, -l + y, false), x = h + p * b(v) + Xp(v, -l + y, false), T = "left", A = "middle";
          break;
        case "middle":
          w = c + p * _(m), x = h + p * b(m), T = "center", A = "middle";
          break;
        case "endArc":
          w = c + (f + l) * _(m), x = h + (f + l) * b(m), T = "center", A = "bottom";
          break;
        case "insideEndArc":
          w = c + (f - l) * _(m), x = h + (f - l) * b(m), T = "center", A = "top";
          break;
        case "endAngle":
          w = c + p * _(g) + qp(g, l + y, true), x = h + p * b(g) + Xp(g, l + y, true), T = "left", A = "middle";
          break;
        case "insideEndAngle":
          w = c + p * _(g) + qp(g, -l + y, true), x = h + p * b(g) + Xp(g, -l + y, true), T = "right", A = "middle";
          break;
        default:
          return Dg(n, i, a);
      }
      return n = n || {}, n.x = w, n.y = x, n.align = T, n.verticalAlign = A, n;
    };
  }
  function Rae(t, e, r, n) {
    if (xt(n)) {
      t.setTextConfig({
        rotation: n
      });
      return;
    } else if (ae(e)) {
      t.setTextConfig({
        rotation: 0
      });
      return;
    }
    var i = t.shape, a = i.clockwise ? i.startAngle : i.endAngle, o = i.clockwise ? i.endAngle : i.startAngle, s = (a + o) / 2, l, u = r(e);
    switch (u) {
      case "startArc":
      case "insideStartArc":
      case "middle":
      case "insideEndArc":
      case "endArc":
        l = s;
        break;
      case "startAngle":
      case "insideStartAngle":
        l = a;
        break;
      case "endAngle":
      case "insideEndAngle":
        l = o;
        break;
      default:
        t.setTextConfig({
          rotation: 0
        });
        return;
    }
    var c = Math.PI * 1.5 - l;
    u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), t.setTextConfig({
      rotation: c
    });
  }
  function qp(t, e, r) {
    return e * Math.sin(t) * (r ? -1 : 1);
  }
  function Xp(t, e, r) {
    return e * Math.cos(t) * (r ? 1 : -1);
  }
  function Dl(t, e, r) {
    var n = t.get("borderRadius");
    if (n == null) return r ? {
      cornerRadius: 0
    } : null;
    ae(n) || (n = [
      n,
      n,
      n,
      n
    ]);
    var i = Math.abs(e.r || 0 - e.r0 || 0);
    return {
      cornerRadius: oe(n, function(a) {
        return ji(a, i);
      })
    };
  }
  var c_ = Math.max, h_ = Math.min;
  function Oae(t, e) {
    var r = t.getArea && t.getArea();
    if (lu(t, "cartesian2d")) {
      var n = t.getBaseAxis();
      if (n.type !== "category" || !n.onBand) {
        var i = e.getLayout("bandWidth");
        n.isHorizontal() ? (r.x -= i, r.width += i * 2) : (r.y -= i, r.height += i * 2);
      }
    }
    return r;
  }
  var Nae = function(t) {
    K(e, t);
    function e() {
      var r = t.call(this) || this;
      return r.type = e.type, r._isFirstFrame = true, r;
    }
    return e.prototype.render = function(r, n, i, a) {
      this._model = r, this._removeOnRenderedListener(i), this._updateDrawMode(r);
      var o = r.get("coordinateSystem");
      (o === "cartesian2d" || o === "polar") && (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(r, n, i) : this._renderNormal(r, n, i, a));
    }, e.prototype.incrementalPrepareRender = function(r) {
      this._clear(), this._updateDrawMode(r), this._updateLargeClip(r);
    }, e.prototype.incrementalRender = function(r, n) {
      this._progressiveEls = [], this._incrementalRenderLarge(r, n);
    }, e.prototype.eachRendered = function(r) {
      bs(this._progressiveEls || this.group, r);
    }, e.prototype._updateDrawMode = function(r) {
      var n = r.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, e.prototype._renderNormal = function(r, n, i, a) {
      var o = this.group, s = r.getData(), l = this._data, u = r.coordinateSystem, c = u.getBaseAxis(), h;
      u.type === "cartesian2d" ? h = c.isHorizontal() : u.type === "polar" && (h = c.dim === "angle");
      var f = r.isAnimationEnabled() ? r : null, d = Bae(r, u);
      d && this._enableRealtimeSort(d, s, i);
      var p = r.get("clip", true) || d, v = Oae(u, s);
      o.removeClipPath();
      var g = r.get("roundCap", true), m = r.get("showBackground", true), y = r.getModel("backgroundStyle"), _ = y.get("borderRadius") || 0, b = [], w = this._backgroundEls, x = a && a.isInitSort, T = a && a.type === "changeAxisOrder";
      function A(k) {
        var B = jp[u.type](s, k), L = Uae(u, h, B);
        return L.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? L.setShape("r", _) : L.setShape("cornerRadius", _), b[k] = L, L;
      }
      s.diff(l).add(function(k) {
        var B = s.getItemModel(k), L = jp[u.type](s, k, B);
        if (m && A(k), !(!s.hasValue(k) || !Pk[u.type](L))) {
          var z = false;
          p && (z = Mk[u.type](v, L));
          var F = Dk[u.type](r, s, k, L, h, f, c.model, false, g);
          d && (F.forceLabelAnimation = true), Lk(F, s, k, B, L, r, h, u.type === "polar"), x ? F.attr({
            shape: L
          }) : d ? Ek(d, f, F, L, k, h, false, false) : er(F, {
            shape: L
          }, r, k), s.setItemGraphicEl(k, F), o.add(F), F.ignore = z;
        }
      }).update(function(k, B) {
        var L = s.getItemModel(k), z = jp[u.type](s, k, L);
        if (m) {
          var F = void 0;
          w.length === 0 ? F = A(B) : (F = w[B], F.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? F.setShape("r", _) : F.setShape("cornerRadius", _), b[k] = F);
          var E = jp[u.type](s, k), O = LG(h, E, u);
          wt(F, {
            shape: O
          }, f, k);
        }
        var N = l.getItemGraphicEl(B);
        if (!s.hasValue(k) || !Pk[u.type](z)) {
          o.remove(N);
          return;
        }
        var V = false;
        if (p && (V = Mk[u.type](v, z), V && o.remove(N)), N ? Ki(N) : N = Dk[u.type](r, s, k, z, h, f, c.model, !!N, g), d && (N.forceLabelAnimation = true), T) {
          var H = N.getTextContent();
          if (H) {
            var G = Wc(H);
            G.prevValue != null && (G.prevValue = G.value);
          }
        } else Lk(N, s, k, L, z, r, h, u.type === "polar");
        x ? N.attr({
          shape: z
        }) : d ? Ek(d, f, N, z, k, h, true, T) : wt(N, {
          shape: z
        }, r, k, null), s.setItemGraphicEl(k, N), N.ignore = V, o.add(N);
      }).remove(function(k) {
        var B = l.getItemGraphicEl(k);
        B && jf(B, r, k);
      }).execute();
      var I = this._backgroundGroup || (this._backgroundGroup = new Be());
      I.removeAll();
      for (var M = 0; M < b.length; ++M) I.add(b[M]);
      o.add(I), this._backgroundEls = b, this._data = s;
    }, e.prototype._renderLarge = function(r, n, i) {
      this._clear(), Rk(r, this.group), this._updateLargeClip(r);
    }, e.prototype._incrementalRenderLarge = function(r, n) {
      this._removeBackground(), Rk(n, this.group, this._progressiveEls, true);
    }, e.prototype._updateLargeClip = function(r) {
      var n = r.get("clip", true) && Wd(r.coordinateSystem, false, r), i = this.group;
      n ? i.setClipPath(n) : i.removeClipPath();
    }, e.prototype._enableRealtimeSort = function(r, n, i) {
      var a = this;
      if (n.count()) {
        var o = r.baseAxis;
        if (this._isFirstFrame) this._dispatchInitSort(n, r, i), this._isFirstFrame = false;
        else {
          var s = function(l) {
            var u = n.getItemGraphicEl(l), c = u && u.shape;
            return c && Math.abs(o.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(n, s, o, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, e.prototype._dataSort = function(r, n, i) {
      var a = [];
      return r.each(r.mapDimension(n.dim), function(o, s) {
        var l = i(s);
        l = l ?? NaN, a.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: o
        });
      }), a.sort(function(o, s) {
        return s.mappedValue - o.mappedValue;
      }), {
        ordinalNumbers: oe(a, function(o) {
          return o.ordinalNumber;
        })
      };
    }, e.prototype._isOrderChangedWithinSameData = function(r, n, i) {
      for (var a = i.scale, o = r.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = r.rawIndexOf(o, a.getRawOrdinalNumber(l)), h = c < 0 ? Number.MIN_VALUE : n(r.indexOfRawIndex(c));
        if (h > s) return true;
        s = h;
      }
      return false;
    }, e.prototype._isOrderDifferentInView = function(r, n) {
      for (var i = n.scale, a = i.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); o <= s; ++o) if (r.ordinalNumbers[o] !== i.getRawOrdinalNumber(o)) return true;
    }, e.prototype._updateSortWithinSameData = function(r, n, i, a) {
      if (this._isOrderChangedWithinSameData(r, n, i)) {
        var o = this._dataSort(r, i, n);
        this._isOrderDifferentInView(o, i) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: o
        }));
      }
    }, e.prototype._dispatchInitSort = function(r, n, i) {
      var a = n.baseAxis, o = this._dataSort(r, a, function(s) {
        return r.get(r.mapDimension(n.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: true,
        axisId: a.index,
        sortInfo: o
      });
    }, e.prototype.remove = function(r, n) {
      this._clear(this._model), this._removeOnRenderedListener(n);
    }, e.prototype.dispose = function(r, n) {
      this._removeOnRenderedListener(n);
    }, e.prototype._removeOnRenderedListener = function(r) {
      this._onRendered && (r.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, e.prototype._clear = function(r) {
      var n = this.group, i = this._data;
      r && r.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(a) {
        jf(a, r, Ge(a).dataIndex);
      })) : n.removeAll(), this._data = null, this._isFirstFrame = true;
    }, e.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, e.type = "bar", e;
  }(Ft), Mk = {
    cartesian2d: function(t, e) {
      var r = e.width < 0 ? -1 : 1, n = e.height < 0 ? -1 : 1;
      r < 0 && (e.x += e.width, e.width = -e.width), n < 0 && (e.y += e.height, e.height = -e.height);
      var i = t.x + t.width, a = t.y + t.height, o = c_(e.x, t.x), s = h_(e.x + e.width, i), l = c_(e.y, t.y), u = h_(e.y + e.height, a), c = s < o, h = u < l;
      return e.x = c && o > i ? s : o, e.y = h && l > a ? u : l, e.width = c ? 0 : s - o, e.height = h ? 0 : u - l, r < 0 && (e.x += e.width, e.width = -e.width), n < 0 && (e.y += e.height, e.height = -e.height), c || h;
    },
    polar: function(t, e) {
      var r = e.r0 <= e.r ? 1 : -1;
      if (r < 0) {
        var n = e.r;
        e.r = e.r0, e.r0 = n;
      }
      var i = h_(e.r, t.r), a = c_(e.r0, t.r0);
      e.r = i, e.r0 = a;
      var o = i - a < 0;
      if (r < 0) {
        var n = e.r;
        e.r = e.r0, e.r0 = n;
      }
      return o;
    }
  }, Dk = {
    cartesian2d: function(t, e, r, n, i, a, o, s, l) {
      var u = new yt({
        shape: te({}, n),
        z2: 1
      });
      if (u.__dataIndex = r, u.name = "item", a) {
        var c = u.shape, h = i ? "height" : "width";
        c[h] = 0;
      }
      return u;
    },
    polar: function(t, e, r, n, i, a, o, s, l) {
      var u = !i && l ? Kg : wn, c = new u({
        shape: n,
        z2: 1
      });
      c.name = "item";
      var h = PG(i);
      if (c.calculateTextPosition = $ae(h, {
        isRoundCap: u === Kg
      }), a) {
        var f = c.shape, d = i ? "r" : "endAngle", p = {};
        f[d] = i ? n.r0 : n.startAngle, p[d] = n[d], (s ? wt : er)(c, {
          shape: p
        }, a);
      }
      return c;
    }
  };
  function Bae(t, e) {
    var r = t.get("realtimeSort", true), n = e.getBaseAxis();
    if (r && n.type === "category" && e.type === "cartesian2d") return {
      baseAxis: n,
      otherAxis: e.getOtherAxis(n)
    };
  }
  function Ek(t, e, r, n, i, a, o, s) {
    var l, u;
    a ? (u = {
      x: n.x,
      width: n.width
    }, l = {
      y: n.y,
      height: n.height
    }) : (u = {
      y: n.y,
      height: n.height
    }, l = {
      x: n.x,
      width: n.width
    }), s || (o ? wt : er)(r, {
      shape: l
    }, e, i, null);
    var c = e ? t.baseAxis.model : null;
    (o ? wt : er)(r, {
      shape: u
    }, c, i);
  }
  function kk(t, e) {
    for (var r = 0; r < e.length; r++) if (!isFinite(t[e[r]])) return true;
    return false;
  }
  var zae = [
    "x",
    "y",
    "width",
    "height"
  ], Fae = [
    "cx",
    "cy",
    "r",
    "startAngle",
    "endAngle"
  ], Pk = {
    cartesian2d: function(t) {
      return !kk(t, zae);
    },
    polar: function(t) {
      return !kk(t, Fae);
    }
  }, jp = {
    cartesian2d: function(t, e, r) {
      var n = t.getItemLayout(e), i = r ? Gae(r, n) : 0, a = n.width > 0 ? 1 : -1, o = n.height > 0 ? 1 : -1;
      return {
        x: n.x + a * i / 2,
        y: n.y + o * i / 2,
        width: n.width - a * i,
        height: n.height - o * i
      };
    },
    polar: function(t, e, r) {
      var n = t.getItemLayout(e);
      return {
        cx: n.cx,
        cy: n.cy,
        r0: n.r0,
        r: n.r,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        clockwise: n.clockwise
      };
    }
  };
  function Vae(t) {
    return t.startAngle != null && t.endAngle != null && t.startAngle === t.endAngle;
  }
  function PG(t) {
    return /* @__PURE__ */ function(e) {
      var r = e ? "Arc" : "Angle";
      return function(n) {
        switch (n) {
          case "start":
          case "insideStart":
          case "end":
          case "insideEnd":
            return n + r;
          default:
            return n;
        }
      };
    }(t);
  }
  function Lk(t, e, r, n, i, a, o, s) {
    var l = e.getItemVisual(r, "style");
    if (s) {
      if (!a.get("roundCap")) {
        var c = t.shape, h = Dl(n.getModel("itemStyle"), c, true);
        te(c, h), t.setShape(c);
      }
    } else {
      var u = n.get([
        "itemStyle",
        "borderRadius"
      ]) || 0;
      t.setShape("r", u);
    }
    t.useStyle(l);
    var f = n.getShallow("cursor");
    f && t.attr("cursor", f);
    var d = s ? o ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : o ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = Lr(n);
    Xr(t, p, {
      labelFetcher: a,
      labelDataIndex: r,
      defaultText: wc(a.getData(), r),
      inheritColor: l.fill,
      defaultOpacity: l.opacity,
      defaultOutsidePosition: d
    });
    var v = t.getTextContent();
    if (s && v) {
      var g = n.get([
        "label",
        "position"
      ]);
      t.textConfig.inside = g === "middle" ? true : null, Rae(t, g === "outside" ? d : g, PG(o), n.get([
        "label",
        "rotate"
      ]));
    }
    Z4(v, p, a.getRawValue(r), function(y) {
      return SG(e, y);
    });
    var m = n.getModel([
      "emphasis"
    ]);
    ir(t, m.get("focus"), m.get("blurScope"), m.get("disabled")), qr(t, n), Vae(i) && (t.style.fill = "none", t.style.stroke = "none", $(t.states, function(y) {
      y.style && (y.style.fill = y.style.stroke = "none");
    }));
  }
  function Gae(t, e) {
    var r = t.get([
      "itemStyle",
      "borderColor"
    ]);
    if (!r || r === "none") return 0;
    var n = t.get([
      "itemStyle",
      "borderWidth"
    ]) || 0, i = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), a = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
    return Math.min(n, i, a);
  }
  var Wae = /* @__PURE__ */ function() {
    function t() {
    }
    return t;
  }(), $k = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "largeBar", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new Wae();
    }, e.prototype.buildPath = function(r, n) {
      for (var i = n.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3) l[a] = u, l[o] = i[c + 2], s[a] = i[c + a], s[o] = i[c + o], r.rect(s[0], s[1], l[0], l[1]);
    }, e;
  }(st);
  function Rk(t, e, r, n) {
    var i = t.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, o = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = t.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
    if (u) {
      var c = new $k({
        shape: {
          points: u
        },
        incremental: !!n,
        silent: true,
        z2: 0
      });
      c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, c.useStyle(l.getItemStyle()), e.add(c), r && r.push(c);
    }
    var h = new $k({
      shape: {
        points: i.getLayout("largePoints")
      },
      incremental: !!n,
      ignoreCoarsePointer: true,
      z2: 1
    });
    h.baseDimIdx = a, h.largeDataIndices = o, h.barWidth = s, e.add(h), h.useStyle(i.getVisual("style")), h.style.stroke = null, Ge(h).seriesIndex = t.seriesIndex, t.get("silent") || (h.on("mousedown", Ok), h.on("mousemove", Ok)), r && r.push(h);
  }
  var Ok = PT(function(t) {
    var e = this, r = Hae(e, t.offsetX, t.offsetY);
    Ge(e).dataIndex = r >= 0 ? r : null;
  }, 30, false);
  function Hae(t, e, r) {
    for (var n = t.baseDimIdx, i = 1 - n, a = t.shape.points, o = t.largeDataIndices, s = [], l = [], u = t.barWidth, c = 0, h = a.length / 3; c < h; c++) {
      var f = c * 3;
      if (l[n] = u, l[i] = a[f + 2], s[n] = a[f + n], s[i] = a[f + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), e >= s[0] && e <= s[0] + l[0] && r >= s[1] && r <= s[1] + l[1]) return o[c];
    }
    return -1;
  }
  function LG(t, e, r) {
    if (lu(r, "cartesian2d")) {
      var n = e, i = r.getArea();
      return {
        x: t ? n.x : i.x,
        y: t ? i.y : n.y,
        width: t ? n.width : i.width,
        height: t ? i.height : n.height
      };
    } else {
      var i = r.getArea(), a = e;
      return {
        cx: i.cx,
        cy: i.cy,
        r0: t ? i.r0 : a.r0,
        r: t ? i.r : a.r,
        startAngle: t ? a.startAngle : 0,
        endAngle: t ? a.endAngle : Math.PI * 2
      };
    }
  }
  function Uae(t, e, r) {
    var n = t.type === "polar" ? wn : yt;
    return new n({
      shape: LG(e, r, t),
      silent: true,
      z2: 0
    });
  }
  function Yae(t) {
    t.registerChartView(Nae), t.registerSeriesModel(Pae), t.registerLayout(t.PRIORITY.VISUAL.LAYOUT, Ye(B5, "bar")), t.registerLayout(t.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, z5("bar")), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, kG("bar")), t.registerAction({
      type: "changeAxisOrder",
      event: "changeAxisOrder",
      update: "update"
    }, function(e, r) {
      var n = e.componentType || "series";
      r.eachComponent({
        mainType: n,
        query: e
      }, function(i) {
        e.sortInfo && i.axis.setCategorySortInfo(e.sortInfo);
      });
    });
  }
  var Nk = Math.PI * 2, Kp = Math.PI / 180;
  function $G(t, e) {
    return Tr(t.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function RG(t, e) {
    var r = $G(t, e), n = t.get("center"), i = t.get("radius");
    ae(i) || (i = [
      0,
      i
    ]);
    var a = pe(r.width, e.getWidth()), o = pe(r.height, e.getHeight()), s = Math.min(a, o), l = pe(i[0], s / 2), u = pe(i[1], s / 2), c, h, f = t.coordinateSystem;
    if (f) {
      var d = f.dataToPoint(n);
      c = d[0] || 0, h = d[1] || 0;
    } else ae(n) || (n = [
      n,
      n
    ]), c = pe(n[0], a) + r.x, h = pe(n[1], o) + r.y;
    return {
      cx: c,
      cy: h,
      r0: l,
      r: u
    };
  }
  function qae(t, e, r) {
    e.eachSeriesByType(t, function(n) {
      var i = n.getData(), a = i.mapDimension("value"), o = $G(n, r), s = RG(n, r), l = s.cx, u = s.cy, c = s.r, h = s.r0, f = -n.get("startAngle") * Kp, d = n.get("endAngle"), p = n.get("padAngle") * Kp;
      d = d === "auto" ? f - Nk : -d * Kp;
      var v = n.get("minAngle") * Kp, g = v + p, m = 0;
      i.each(a, function(O) {
        !isNaN(O) && m++;
      });
      var y = i.getSum(a), _ = Math.PI / (y || m) * 2, b = n.get("clockwise"), w = n.get("roseType"), x = n.get("stillShowZeroSum"), T = i.getDataExtent(a);
      T[0] = 0;
      var A = b ? 1 : -1, I = [
        f,
        d
      ], M = A * p / 2;
      sT(I, !b), f = I[0], d = I[1];
      var k = OG(n);
      k.startAngle = f, k.endAngle = d, k.clockwise = b;
      var B = Math.abs(d - f), L = B, z = 0, F = f;
      if (i.setLayout({
        viewRect: o,
        r: c
      }), i.each(a, function(O, N) {
        var V;
        if (isNaN(O)) {
          i.setItemLayout(N, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: b,
            cx: l,
            cy: u,
            r0: h,
            r: w ? NaN : c
          });
          return;
        }
        w !== "area" ? V = y === 0 && x ? _ : O * _ : V = B / m, V < g ? (V = g, L -= g) : z += O;
        var H = F + A * V, G = 0, Y = 0;
        p > V ? (G = F + A * V / 2, Y = G) : (G = F + M, Y = H - M), i.setItemLayout(N, {
          angle: V,
          startAngle: G,
          endAngle: Y,
          clockwise: b,
          cx: l,
          cy: u,
          r0: h,
          r: w ? Et(O, T, [
            h,
            c
          ]) : c
        }), F = H;
      }), L < Nk && m) if (L <= 1e-3) {
        var E = B / m;
        i.each(a, function(O, N) {
          if (!isNaN(O)) {
            var V = i.getItemLayout(N);
            V.angle = E;
            var H = 0, G = 0;
            E < p ? (H = f + A * (N + 1 / 2) * E, G = H) : (H = f + A * N * E + M, G = f + A * (N + 1) * E - M), V.startAngle = H, V.endAngle = G;
          }
        });
      } else _ = L / z, F = f, i.each(a, function(O, N) {
        if (!isNaN(O)) {
          var V = i.getItemLayout(N), H = V.angle === g ? g : O * _, G = 0, Y = 0;
          H < p ? (G = F + A * H / 2, Y = G) : (G = F + M, Y = F + A * H - M), V.startAngle = G, V.endAngle = Y, F += A * H;
        }
      });
    });
  }
  var OG = _t();
  function Ud(t) {
    return {
      seriesType: t,
      reset: function(e, r) {
        var n = r.findComponents({
          mainType: "legend"
        });
        if (!(!n || !n.length)) {
          var i = e.getData();
          i.filterSelf(function(a) {
            for (var o = i.getName(a), s = 0; s < n.length; s++) if (!n[s].isSelected(o)) return false;
            return true;
          });
        }
      }
    };
  }
  var Xae = Math.PI / 180;
  function Bk(t, e, r, n, i, a, o, s, l, u) {
    if (t.length < 2) return;
    function c(v) {
      for (var g = v.rB, m = g * g, y = 0; y < v.list.length; y++) {
        var _ = v.list[y], b = Math.abs(_.label.y - r), w = n + _.len, x = w * w, T = Math.sqrt(Math.abs((1 - b * b / m) * x)), A = e + (T + _.len2) * i, I = A - _.label.x, M = _.targetTextWidth - I * i;
        NG(_, M, true), _.label.x = A;
      }
    }
    function h(v) {
      for (var g = {
        list: [],
        maxY: 0
      }, m = {
        list: [],
        maxY: 0
      }, y = 0; y < v.length; y++) if (v[y].labelAlignTo === "none") {
        var _ = v[y], b = _.label.y > r ? m : g, w = Math.abs(_.label.y - r);
        if (w >= b.maxY) {
          var x = _.label.x - e - _.len2 * i, T = n + _.len, A = Math.abs(x) < T ? Math.sqrt(w * w / (1 - x * x / T / T)) : T;
          b.rB = A, b.maxY = w;
        }
        b.list.push(_);
      }
      c(g), c(m);
    }
    for (var f = t.length, d = 0; d < f; d++) if (t[d].position === "outer" && t[d].labelAlignTo === "labelLine") {
      var p = t[d].label.x - u;
      t[d].linePoints[1][0] += p, t[d].label.x = u;
    }
    oG(t, l, l + o) && h(t);
  }
  function jae(t, e, r, n, i, a, o, s) {
    for (var l = [], u = [], c = Number.MAX_VALUE, h = -Number.MAX_VALUE, f = 0; f < t.length; f++) {
      var d = t[f].label;
      f_(t[f]) || (d.x < e ? (c = Math.min(c, d.x), l.push(t[f])) : (h = Math.max(h, d.x), u.push(t[f])));
    }
    for (var f = 0; f < t.length; f++) {
      var p = t[f];
      if (!f_(p) && p.linePoints) {
        if (p.labelStyleWidth != null) continue;
        var d = p.label, v = p.linePoints, g = void 0;
        p.labelAlignTo === "edge" ? d.x < e ? g = v[2][0] - p.labelDistance - o - p.edgeDistance : g = o + i - p.edgeDistance - v[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? d.x < e ? g = c - o - p.bleedMargin : g = o + i - h - p.bleedMargin : d.x < e ? g = d.x - o - p.bleedMargin : g = o + i - d.x - p.bleedMargin, p.targetTextWidth = g, NG(p, g);
      }
    }
    Bk(u, e, r, n, 1, i, a, o, s, h), Bk(l, e, r, n, -1, i, a, o, s, c);
    for (var f = 0; f < t.length; f++) {
      var p = t[f];
      if (!f_(p) && p.linePoints) {
        var d = p.label, v = p.linePoints, m = p.labelAlignTo === "edge", y = d.style.padding, _ = y ? y[1] + y[3] : 0, b = d.style.backgroundColor ? 0 : _, w = p.rect.width + b, x = v[1][0] - v[2][0];
        m ? d.x < e ? v[2][0] = o + p.edgeDistance + w + p.labelDistance : v[2][0] = o + i - p.edgeDistance - w - p.labelDistance : (d.x < e ? v[2][0] = d.x + p.labelDistance : v[2][0] = d.x - p.labelDistance, v[1][0] = v[2][0] + x), v[1][1] = v[2][1] = d.y;
      }
    }
  }
  function NG(t, e, r) {
    if (r === void 0 && (r = false), t.labelStyleWidth == null) {
      var n = t.label, i = n.style, a = t.rect, o = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, c = a.width + (o ? 0 : l);
      if (e < c || r) {
        var h = a.height;
        if (u && u.match("break")) {
          n.setStyle("backgroundColor", null), n.setStyle("width", e - l);
          var f = n.getBoundingRect();
          n.setStyle("width", Math.ceil(f.width)), n.setStyle("backgroundColor", o);
        } else {
          var d = e - l, p = e < c ? d : r ? d > t.unconstrainedWidth ? null : d : null;
          n.setStyle("width", p);
        }
        var v = n.getBoundingRect();
        a.width = v.width;
        var g = (n.style.margin || 0) + 2.1;
        a.height = v.height + g, a.y -= (a.height - h) / 2;
      }
    }
  }
  function f_(t) {
    return t.position === "center";
  }
  function Kae(t) {
    var e = t.getData(), r = [], n, i, a = false, o = (t.get("minShowLabelAngle") || 0) * Xae, s = e.getLayout("viewRect"), l = e.getLayout("r"), u = s.width, c = s.x, h = s.y, f = s.height;
    function d(x) {
      x.ignore = true;
    }
    function p(x) {
      if (!x.ignore) return true;
      for (var T in x.states) if (x.states[T].ignore === false) return true;
      return false;
    }
    e.each(function(x) {
      var T = e.getItemGraphicEl(x), A = T.shape, I = T.getTextContent(), M = T.getTextGuideLine(), k = e.getItemModel(x), B = k.getModel("label"), L = B.get("position") || k.get([
        "emphasis",
        "label",
        "position"
      ]), z = B.get("distanceToLabelLine"), F = B.get("alignTo"), E = pe(B.get("edgeDistance"), u), O = B.get("bleedMargin"), N = k.getModel("labelLine"), V = N.get("length");
      V = pe(V, u);
      var H = N.get("length2");
      if (H = pe(H, u), Math.abs(A.endAngle - A.startAngle) < o) {
        $(I.states, d), I.ignore = true, M && ($(M.states, d), M.ignore = true);
        return;
      }
      if (p(I)) {
        var G = (A.startAngle + A.endAngle) / 2, Y = Math.cos(G), U = Math.sin(G), Z, ee, we, Te;
        n = A.cx, i = A.cy;
        var le = L === "inside" || L === "inner";
        if (L === "center") Z = A.cx, ee = A.cy, Te = "center";
        else {
          var ue = (le ? (A.r + A.r0) / 2 * Y : A.r * Y) + n, ye = (le ? (A.r + A.r0) / 2 * U : A.r * U) + i;
          if (Z = ue + Y * 3, ee = ye + U * 3, !le) {
            var ve = ue + Y * (V + l - A.r), Se = ye + U * (V + l - A.r), Qe = ve + (Y < 0 ? -1 : 1) * H, Xe = Se;
            F === "edge" ? Z = Y < 0 ? c + E : c + u - E : Z = Qe + (Y < 0 ? -z : z), ee = Xe, we = [
              [
                ue,
                ye
              ],
              [
                ve,
                Se
              ],
              [
                Qe,
                Xe
              ]
            ];
          }
          Te = le ? "center" : F === "edge" ? Y > 0 ? "right" : "left" : Y > 0 ? "left" : "right";
        }
        var be = Math.PI, ke = 0, Vt = B.get("rotate");
        if (xt(Vt)) ke = Vt * (be / 180);
        else if (L === "center") ke = 0;
        else if (Vt === "radial" || Vt === true) {
          var X = Y < 0 ? -G + be : -G;
          ke = X;
        } else if (Vt === "tangential" && L !== "outside" && L !== "outer") {
          var j = Math.atan2(Y, U);
          j < 0 && (j = be * 2 + j);
          var he = U > 0;
          he && (j = be + j), ke = j - be;
        }
        if (a = !!ke, I.x = Z, I.y = ee, I.rotation = ke, I.setStyle({
          verticalAlign: "middle"
        }), le) {
          I.setStyle({
            align: Te
          });
          var pt = I.states.select;
          pt && (pt.x += I.x, pt.y += I.y);
        } else {
          var $e = I.getBoundingRect().clone();
          $e.applyTransform(I.getComputedTransform());
          var jt = (I.style.margin || 0) + 2.1;
          $e.y -= jt / 2, $e.height += jt, r.push({
            label: I,
            labelLine: M,
            position: L,
            len: V,
            len2: H,
            minTurnAngle: N.get("minTurnAngle"),
            maxSurfaceAngle: N.get("maxSurfaceAngle"),
            surfaceNormal: new Ke(Y, U),
            linePoints: we,
            textAlign: Te,
            labelDistance: z,
            labelAlignTo: F,
            edgeDistance: E,
            bleedMargin: O,
            rect: $e,
            unconstrainedWidth: $e.width,
            labelStyleWidth: I.style.width
          });
        }
        T.setTextConfig({
          inside: le
        });
      }
    }), !a && t.get("avoidLabelOverlap") && jae(r, n, i, l, u, f, c, h);
    for (var v = 0; v < r.length; v++) {
      var g = r[v], m = g.label, y = g.labelLine, _ = isNaN(m.x) || isNaN(m.y);
      if (m) {
        m.setStyle({
          align: g.textAlign
        }), _ && ($(m.states, d), m.ignore = true);
        var b = m.states.select;
        b && (b.x += m.x, b.y += m.y);
      }
      if (y) {
        var w = g.linePoints;
        _ || !w ? ($(y.states, d), y.ignore = true) : (nG(w, g.minTurnAngle), _ie(w, g.surfaceNormal, g.maxSurfaceAngle), y.setShape({
          points: w
        }), m.__hostTarget.textGuideLineConfig = {
          anchor: new Ke(w[0][0], w[0][1])
        });
      }
    }
  }
  var Zae = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this) || this;
      a.z2 = 2;
      var o = new bt();
      return a.setTextContent(o), a.updateData(r, n, i, true), a;
    }
    return e.prototype.updateData = function(r, n, i, a) {
      var o = this, s = r.hostModel, l = r.getItemModel(n), u = l.getModel("emphasis"), c = r.getItemLayout(n), h = te(Dl(l.getModel("itemStyle"), c, true), c);
      if (isNaN(h.startAngle)) {
        o.setShape(h);
        return;
      }
      if (a) {
        o.setShape(h);
        var f = s.getShallow("animationType");
        s.ecModel.ssr ? (er(o, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: n,
          isFrom: true
        }), o.originX = h.cx, o.originY = h.cy) : f === "scale" ? (o.shape.r = c.r0, er(o, {
          shape: {
            r: c.r
          }
        }, s, n)) : i != null ? (o.setShape({
          startAngle: i,
          endAngle: i
        }), er(o, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, n)) : (o.shape.endAngle = c.startAngle, wt(o, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, n));
      } else Ki(o), wt(o, {
        shape: h
      }, s, n);
      o.useStyle(r.getItemVisual(n, "style")), qr(o, l);
      var d = (c.startAngle + c.endAngle) / 2, p = s.get("selectedOffset"), v = Math.cos(d) * p, g = Math.sin(d) * p, m = l.getShallow("cursor");
      m && o.attr("cursor", m), this._updateLabel(s, r, n), o.ensureState("emphasis").shape = te({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, Dl(u.getModel("itemStyle"), c)), te(o.ensureState("select"), {
        x: v,
        y: g,
        shape: Dl(l.getModel([
          "select",
          "itemStyle"
        ]), c)
      }), te(o.ensureState("blur"), {
        shape: Dl(l.getModel([
          "blur",
          "itemStyle"
        ]), c)
      });
      var y = o.getTextGuideLine(), _ = o.getTextContent();
      y && te(y.ensureState("select"), {
        x: v,
        y: g
      }), te(_.ensureState("select"), {
        x: v,
        y: g
      }), ir(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(r, n, i) {
      var a = this, o = n.getItemModel(i), s = o.getModel("labelLine"), l = n.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      Xr(a, Lr(o), {
        labelFetcher: n.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: r.getFormattedLabel(i, "normal") || n.getName(i)
      });
      var h = a.getTextContent();
      a.setTextConfig({
        position: null,
        rotation: null
      }), h.attr({
        z2: 10
      });
      var f = r.get([
        "label",
        "position"
      ]);
      if (f !== "outside" && f !== "outer") a.removeTextGuideLine();
      else {
        var d = this.getTextGuideLine();
        d || (d = new Tn(), this.setTextGuideLine(d)), UT(this, YT(o), {
          stroke: u,
          opacity: Aa(s.get([
            "lineStyle",
            "opacity"
          ]), c, 1)
        });
      }
    }, e;
  }(wn), Qae = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.ignoreLabelLineUpdate = true, r;
    }
    return e.prototype.render = function(r, n, i, a) {
      var o = r.getData(), s = this._data, l = this.group, u;
      if (!s && o.count() > 0) {
        for (var c = o.getItemLayout(0), h = 1; isNaN(c && c.startAngle) && h < o.count(); ++h) c = o.getItemLayout(h);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && r.get("showEmptyCircle")) {
        var f = OG(r), d = new wn({
          shape: te(RG(r, i), f)
        });
        d.useStyle(r.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = d, l.add(d);
      }
      o.diff(s).add(function(p) {
        var v = new Zae(o, p, u);
        o.setItemGraphicEl(p, v), l.add(v);
      }).update(function(p, v) {
        var g = s.getItemGraphicEl(v);
        g.updateData(o, p, u), g.off("click"), l.add(g), o.setItemGraphicEl(p, g);
      }).remove(function(p) {
        var v = s.getItemGraphicEl(p);
        jf(v, r, p);
      }).execute(), Kae(r), r.get("animationTypeUpdate") !== "expansion" && (this._data = o);
    }, e.prototype.dispose = function() {
    }, e.prototype.containPoint = function(r, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = r[0] - a.cx, s = r[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "pie", e;
  }(Ft);
  function Qc(t, e, r) {
    e = ae(e) && {
      coordDimensions: e
    } || te({
      encodeDefine: t.getEncode()
    }, e);
    var n = t.getSource(), i = zd(n, e).dimensions, a = new yn(i, t);
    return a.initData(n, r), a;
  }
  var Yd = function() {
    function t(e, r) {
      this._getDataWithEncodedVisual = e, this._getRawData = r;
    }
    return t.prototype.getAllNames = function() {
      var e = this._getRawData();
      return e.mapArray(e.getName);
    }, t.prototype.containName = function(e) {
      var r = this._getRawData();
      return r.indexOfName(e) >= 0;
    }, t.prototype.indexOfName = function(e) {
      var r = this._getDataWithEncodedVisual();
      return r.indexOfName(e);
    }, t.prototype.getItemVisual = function(e, r) {
      var n = this._getDataWithEncodedVisual();
      return n.getItemVisual(e, r);
    }, t;
  }(), Jae = _t(), eoe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.init = function(r) {
      t.prototype.init.apply(this, arguments), this.legendVisualProvider = new Yd(_e(this.getData, this), _e(this.getRawData, this)), this._defaultLabelLine(r);
    }, e.prototype.mergeOption = function() {
      t.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.getInitialData = function() {
      return Qc(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: Ye(TT, this)
      });
    }, e.prototype.getDataParams = function(r) {
      var n = this.getData(), i = Jae(n), a = i.seats;
      if (!a) {
        var o = [];
        n.each(n.mapDimension("value"), function(l) {
          o.push(l);
        }), a = i.seats = HZ(o, n.hostModel.get("percentPrecision"));
      }
      var s = t.prototype.getDataParams.call(this, r);
      return s.percent = a[r] || 0, s.$vars.push("percent"), s;
    }, e.prototype._defaultLabelLine = function(r) {
      Ul(r, "labelLine", [
        "show"
      ]);
      var n = r.labelLine, i = r.emphasis.labelLine;
      n.show = n.show && r.label.show, i.show = i.show && r.emphasis.label.show;
    }, e.type = "series.pie", e.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      center: [
        "50%",
        "50%"
      ],
      radius: [
        0,
        "75%"
      ],
      clockwise: true,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      minAngle: 0,
      minShowLabelAngle: 0,
      selectedOffset: 10,
      percentPrecision: 2,
      stillShowZeroSum: true,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        rotate: 0,
        show: true,
        overflow: "truncate",
        position: "outer",
        alignTo: "none",
        edgeDistance: "25%",
        bleedMargin: 10,
        distanceToLabelLine: 5
      },
      labelLine: {
        show: true,
        length: 15,
        length2: 15,
        smooth: false,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: true,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        hideOverlap: true
      },
      emphasis: {
        scale: true,
        scaleSize: 5
      },
      avoidLabelOverlap: true,
      animationType: "expansion",
      animationDuration: 1e3,
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, e;
  }(Xt);
  function toe(t) {
    return {
      seriesType: t,
      reset: function(e, r) {
        var n = e.getData();
        n.filterSelf(function(i) {
          var a = n.mapDimension("value"), o = n.get(a, i);
          return !(xt(o) && !isNaN(o) && o < 0);
        });
      }
    };
  }
  function roe(t) {
    t.registerChartView(Qae), t.registerSeriesModel(eoe), n5("pie", t.registerAction), t.registerLayout(Ye(qae, "pie")), t.registerProcessor(Ud("pie")), t.registerProcessor(toe("pie"));
  }
  var noe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.hasSymbolVisual = true, r;
    }
    return e.prototype.getInitialData = function(r, n) {
      return So(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getProgressive = function() {
      var r = this.option.progressive;
      return r ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var r = this.option.progressiveThreshold;
      return r ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, e.prototype.brushSelector = function(r, n, i) {
      return i.point(n.getItemLayout(r));
    }, e.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, e.type = "series.scatter", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      symbolSize: 10,
      large: false,
      largeThreshold: 2e3,
      itemStyle: {
        opacity: 0.8
      },
      emphasis: {
        scale: true
      },
      clip: true,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
    }, e;
  }(Xt), BG = 4, ioe = /* @__PURE__ */ function() {
    function t() {
    }
    return t;
  }(), aoe = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return e.prototype.getDefaultShape = function() {
      return new ioe();
    }, e.prototype.reset = function() {
      this.notClear = false, this._off = 0;
    }, e.prototype.buildPath = function(r, n) {
      var i = n.points, a = n.size, o = this.symbolProxy, s = o.shape, l = r.getContext ? r.getContext() : r, u = l && a[0] < BG, c = this.softClipShape, h;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, h = this._off; h < i.length; ) {
        var f = i[h++], d = i[h++];
        isNaN(f) || isNaN(d) || c && !c.contain(f, d) || (s.x = f - a[0] / 2, s.y = d - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(r, s, true));
      }
      this.incremental && (this._off = h, this.notClear = true);
    }, e.prototype.afterBrush = function() {
      var r = this.shape, n = r.points, i = r.size, a = this._ctx, o = this.softClipShape, s;
      if (a) {
        for (s = this._off; s < n.length; ) {
          var l = n[s++], u = n[s++];
          isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = s, this.notClear = true);
      }
    }, e.prototype.findDataIndex = function(r, n) {
      for (var i = this.shape, a = i.points, o = i.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, h = a[c] - s / 2, f = a[c + 1] - l / 2;
        if (r >= h && n >= f && r <= h + s && n <= f + l) return u;
      }
      return -1;
    }, e.prototype.contain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), a = this.getBoundingRect();
      if (r = i[0], n = i[1], a.contain(r, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(r, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, false;
    }, e.prototype.getBoundingRect = function() {
      var r = this._rect;
      if (!r) {
        for (var n = this.shape, i = n.points, a = n.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, h = -1 / 0, f = 0; f < i.length; ) {
          var d = i[f++], p = i[f++];
          l = Math.min(d, l), c = Math.max(d, c), u = Math.min(p, u), h = Math.max(p, h);
        }
        r = this._rect = new Ze(l - o / 2, u - s / 2, c - l + o, h - u + s);
      }
      return r;
    }, e;
  }(st), ooe = function() {
    function t() {
      this.group = new Be();
    }
    return t.prototype.updateData = function(e, r) {
      this._clear();
      var n = this._create();
      n.setShape({
        points: e.getLayout("points")
      }), this._setCommon(n, e, r);
    }, t.prototype.updateLayout = function(e) {
      var r = e.getLayout("points");
      this.group.eachChild(function(n) {
        if (n.startIndex != null) {
          var i = (n.endIndex - n.startIndex) * 2, a = n.startIndex * 4 * 2;
          r = new Float32Array(r.buffer, a, i);
        }
        n.setShape("points", r), n.reset();
      });
    }, t.prototype.incrementalPrepareUpdate = function(e) {
      this._clear();
    }, t.prototype.incrementalUpdate = function(e, r, n) {
      var i = this._newAdded[0], a = r.getLayout("points"), o = i && i.shape.points;
      if (o && o.length < 2e4) {
        var s = o.length, l = new Float32Array(s + a.length);
        l.set(o), l.set(a, s), i.endIndex = e.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = e.start, u.endIndex = e.end, u.incremental = true, u.setShape({
          points: a
        }), this._setCommon(u, r, n);
      }
    }, t.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, t.prototype._create = function() {
      var e = new aoe({
        cursor: "default"
      });
      return e.ignoreCoarsePointer = true, this.group.add(e), this._newAdded.push(e), e;
    }, t.prototype._setCommon = function(e, r, n) {
      var i = r.hostModel;
      n = n || {};
      var a = r.getVisual("symbolSize");
      e.setShape("size", a instanceof Array ? a : [
        a,
        a
      ]), e.softClipShape = n.clipShape || null, e.symbolProxy = mr(r.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor;
      var o = e.shape.size[0] < BG;
      e.useStyle(i.getModel("itemStyle").getItemStyle(o ? [
        "color",
        "shadowBlur",
        "shadowColor"
      ] : [
        "color"
      ]));
      var s = r.getVisual("style"), l = s && s.fill;
      l && e.setColor(l);
      var u = Ge(e);
      u.seriesIndex = i.seriesIndex, e.on("mousemove", function(c) {
        u.dataIndex = null;
        var h = e.hoverDataIdx;
        h >= 0 && (u.dataIndex = h + (e.startIndex || 0));
      });
    }, t.prototype.remove = function() {
      this._clear();
    }, t.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, t;
  }(), soe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = r.getData(), o = this._updateSymbolDraw(a, r);
      o.updateData(a, {
        clipShape: this._getClipShape(r)
      }), this._finished = true;
    }, e.prototype.incrementalPrepareRender = function(r, n, i) {
      var a = r.getData(), o = this._updateSymbolDraw(a, r);
      o.incrementalPrepareUpdate(a), this._finished = false;
    }, e.prototype.incrementalRender = function(r, n, i) {
      this._symbolDraw.incrementalUpdate(r, n.getData(), {
        clipShape: this._getClipShape(n)
      }), this._finished = r.end === n.getData().count();
    }, e.prototype.updateTransform = function(r, n, i) {
      var a = r.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4) return {
        update: true
      };
      var o = Hd("").reset(r, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, e.prototype.eachRendered = function(r) {
      this._symbolDraw && this._symbolDraw.eachRendered(r);
    }, e.prototype._getClipShape = function(r) {
      if (r.get("clip", true)) {
        var n = r.coordinateSystem;
        return n && n.getArea && n.getArea(0.1);
      }
    }, e.prototype._updateSymbolDraw = function(r, n) {
      var i = this._symbolDraw, a = n.pipelineContext, o = a.large;
      return (!i || o !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = o ? new ooe() : new Gd(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), i;
    }, e.prototype.remove = function(r, n) {
      this._symbolDraw && this._symbolDraw.remove(true), this._symbolDraw = null;
    }, e.prototype.dispose = function() {
    }, e.type = "scatter", e;
  }(Ft), loe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.type = "grid", e.dependencies = [
      "xAxis",
      "yAxis"
    ], e.layoutMode = "box", e.defaultOption = {
      show: false,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      containLabel: false,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, e;
  }(vt), iw = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", gr).models[0];
    }, e.type = "cartesian2dAxis", e;
  }(vt);
  yr(iw, Fd);
  var zG = {
    show: true,
    z: 0,
    inverse: false,
    name: "",
    nameLocation: "end",
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: "...",
      placeholder: "."
    },
    nameTextStyle: {},
    nameGap: 15,
    silent: false,
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: "#6E7079",
        width: 1,
        type: "solid"
      },
      symbol: [
        "none",
        "none"
      ],
      symbolSize: [
        10,
        15
      ]
    },
    axisTick: {
      show: true,
      inside: false,
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      inside: false,
      rotate: 0,
      showMinLabel: null,
      showMaxLabel: null,
      margin: 8,
      fontSize: 12
    },
    splitLine: {
      show: true,
      showMinLine: true,
      showMaxLine: true,
      lineStyle: {
        color: [
          "#E0E6F1"
        ],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: [
          "rgba(250,250,250,0.2)",
          "rgba(210,219,238,0.2)"
        ]
      }
    }
  }, uoe = je({
    boundaryGap: true,
    deduplication: null,
    splitLine: {
      show: false
    },
    axisTick: {
      alignWithLabel: false,
      interval: "auto"
    },
    axisLabel: {
      interval: "auto"
    }
  }, zG), JT = je({
    boundaryGap: [
      0,
      0
    ],
    axisLine: {
      show: "auto"
    },
    axisTick: {
      show: "auto"
    },
    splitNumber: 5,
    minorTick: {
      show: false,
      splitNumber: 5,
      length: 3,
      lineStyle: {}
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: "#F4F7FD",
        width: 1
      }
    }
  }, zG), coe = je({
    splitNumber: 6,
    axisLabel: {
      showMinLabel: false,
      showMaxLabel: false,
      rich: {
        primary: {
          fontWeight: "bold"
        }
      }
    },
    splitLine: {
      show: false
    }
  }, JT), hoe = Ee({
    logBase: 10
  }, JT);
  const FG = {
    category: uoe,
    value: JT,
    time: coe,
    log: hoe
  };
  var foe = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
  };
  function Sc(t, e, r, n) {
    $(foe, function(i, a) {
      var o = je(je({}, FG[a], true), n, true), s = function(l) {
        K(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = e + "Axis." + a, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, h) {
          var f = Zf(this), d = f ? Yc(c) : {}, p = h.getTheme();
          je(c, p.get(a + "Axis")), je(c, this.getDefaultOption()), c.type = zk(c), f && ps(c, d, f);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = Zx.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var h = this.option;
          if (h.type === "category") return c ? h.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = e + "Axis." + a, u.defaultOption = o, u;
      }(r);
      t.registerComponentModel(s);
    }), t.registerSubTypeDefaulter(e + "Axis", zk);
  }
  function zk(t) {
    return t.type || (t.data ? "category" : "value");
  }
  var doe = function() {
    function t(e) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "";
    }
    return t.prototype.getAxis = function(e) {
      return this._axes[e];
    }, t.prototype.getAxes = function() {
      return oe(this._dimList, function(e) {
        return this._axes[e];
      }, this);
    }, t.prototype.getAxesByScale = function(e) {
      return e = e.toLowerCase(), Dt(this.getAxes(), function(r) {
        return r.scale.type === e;
      });
    }, t.prototype.addAxis = function(e) {
      var r = e.dim;
      this._axes[r] = e, this._dimList.push(r);
    }, t;
  }(), aw = [
    "x",
    "y"
  ];
  function Fk(t) {
    return t.type === "interval" || t.type === "time";
  }
  var poe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = "cartesian2d", r.dimensions = aw, r;
    }
    return e.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var r = this.getAxis("x").scale, n = this.getAxis("y").scale;
      if (!(!Fk(r) || !Fk(n))) {
        var i = r.getExtent(), a = n.getExtent(), o = this.dataToPoint([
          i[0],
          a[0]
        ]), s = this.dataToPoint([
          i[1],
          a[1]
        ]), l = i[1] - i[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var c = (s[0] - o[0]) / l, h = (s[1] - o[1]) / u, f = o[0] - i[0] * c, d = o[1] - a[0] * h, p = this._transform = [
            c,
            0,
            0,
            h,
            f,
            d
          ];
          this._invTransform = zc([], p);
        }
      }
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, e.prototype.containPoint = function(r) {
      var n = this.getAxis("x"), i = this.getAxis("y");
      return n.contain(n.toLocalCoord(r[0])) && i.contain(i.toLocalCoord(r[1]));
    }, e.prototype.containData = function(r) {
      return this.getAxis("x").containData(r[0]) && this.getAxis("y").containData(r[1]);
    }, e.prototype.containZone = function(r, n) {
      var i = this.dataToPoint(r), a = this.dataToPoint(n), o = this.getArea(), s = new Ze(i[0], i[1], a[0] - i[0], a[1] - i[1]);
      return o.intersect(s);
    }, e.prototype.dataToPoint = function(r, n, i) {
      i = i || [];
      var a = r[0], o = r[1];
      if (this._transform && a != null && isFinite(a) && o != null && isFinite(o)) return Ur(i, r, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(a, n)), i[1] = l.toGlobalCoord(l.dataToCoord(o, n)), i;
    }, e.prototype.clampData = function(r, n) {
      var i = this.getAxis("x").scale, a = this.getAxis("y").scale, o = i.getExtent(), s = a.getExtent(), l = i.parse(r[0]), u = a.parse(r[1]);
      return n = n || [], n[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), n[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), n;
    }, e.prototype.pointToData = function(r, n) {
      var i = [];
      if (this._invTransform) return Ur(i, r, this._invTransform);
      var a = this.getAxis("x"), o = this.getAxis("y");
      return i[0] = a.coordToData(a.toLocalCoord(r[0]), n), i[1] = o.coordToData(o.toLocalCoord(r[1]), n), i;
    }, e.prototype.getOtherAxis = function(r) {
      return this.getAxis(r.dim === "x" ? "y" : "x");
    }, e.prototype.getArea = function(r) {
      r = r || 0;
      var n = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(n[0], n[1]) - r, o = Math.min(i[0], i[1]) - r, s = Math.max(n[0], n[1]) - a + r, l = Math.max(i[0], i[1]) - o + r;
      return new Ze(a, o, s, l);
    }, e;
  }(doe), voe = function(t) {
    K(e, t);
    function e(r, n, i, a, o) {
      var s = t.call(this, r, n, i) || this;
      return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var r = this.position;
      return r === "top" || r === "bottom";
    }, e.prototype.getGlobalExtent = function(r) {
      var n = this.getExtent();
      return n[0] = this.toGlobalCoord(n[0]), n[1] = this.toGlobalCoord(n[1]), r && n[0] > n[1] && n.reverse(), n;
    }, e.prototype.pointToData = function(r, n) {
      return this.coordToData(this.toLocalCoord(r[this.dim === "x" ? 0 : 1]), n);
    }, e.prototype.setCategorySortInfo = function(r) {
      if (this.type !== "category") return false;
      this.model.option.categorySortInfo = r, this.scale.setSortInfo(r);
    }, e;
  }(Ji);
  function ow(t, e, r) {
    r = r || {};
    var n = t.coordinateSystem, i = e.axis, a = {}, o = i.getAxesOnZeroOf()[0], s = i.position, l = o ? "onZero" : s, u = i.dim, c = n.getRect(), h = [
      c.x,
      c.x + c.width,
      c.y,
      c.y + c.height
    ], f = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    }, d = e.get("offset") || 0, p = u === "x" ? [
      h[2] - d,
      h[3] + d
    ] : [
      h[0] - d,
      h[1] + d
    ];
    if (o) {
      var v = o.toGlobalCoord(o.dataToCoord(0));
      p[f.onZero] = Math.max(Math.min(v, p[1]), p[0]);
    }
    a.position = [
      u === "y" ? p[f[l]] : h[0],
      u === "x" ? p[f[l]] : h[3]
    ], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
    var g = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    a.labelDirection = a.tickDirection = a.nameDirection = g[s], a.labelOffset = o ? p[f[s]] - p[f.onZero] : 0, e.get([
      "axisTick",
      "inside"
    ]) && (a.tickDirection = -a.tickDirection), Fr(r.labelInside, e.get([
      "axisLabel",
      "inside"
    ])) && (a.labelDirection = -a.labelDirection);
    var m = e.get([
      "axisLabel",
      "rotate"
    ]);
    return a.labelRotate = l === "top" ? -m : m, a.z2 = 1, a;
  }
  function Vk(t) {
    return t.get("coordinateSystem") === "cartesian2d";
  }
  function Gk(t) {
    var e = {
      xAxisModel: null,
      yAxisModel: null
    };
    return $(e, function(r, n) {
      var i = n.replace(/Model$/, ""), a = t.getReferringComponents(i, gr).models[0];
      e[n] = a;
    }), e;
  }
  var d_ = Math.log;
  function VG(t, e, r) {
    var n = go.prototype, i = n.getTicks.call(r), a = n.getTicks.call(r, true), o = i.length - 1, s = n.getInterval.call(r), l = H5(t, e), u = l.extent, c = l.fixMin, h = l.fixMax;
    if (t.type === "log") {
      var f = d_(t.base);
      u = [
        d_(u[0]) / f,
        d_(u[1]) / f
      ];
    }
    t.setExtent(u[0], u[1]), t.calcNiceExtent({
      splitNumber: o,
      fixMin: c,
      fixMax: h
    });
    var d = n.getExtent.call(t);
    c && (u[0] = d[0]), h && (u[1] = d[1]);
    var p = n.getInterval.call(t), v = u[0], g = u[1];
    if (c && h) p = (g - v) / o;
    else if (c) for (g = u[0] + p * o; g < u[1] && isFinite(g) && isFinite(u[1]); ) p = Q0(p), g = u[0] + p * o;
    else if (h) for (v = u[1] - p * o; v > u[0] && isFinite(v) && isFinite(u[0]); ) p = Q0(p), v = u[1] - p * o;
    else {
      var m = t.getTicks().length - 1;
      m > o && (p = Q0(p));
      var y = p * o;
      g = Math.ceil(u[1] / p) * p, v = lr(g - y), v < 0 && u[0] >= 0 ? (v = 0, g = lr(y)) : g > 0 && u[1] <= 0 && (g = 0, v = -lr(y));
    }
    var _ = (i[0].value - a[0].value) / s, b = (i[o].value - a[o].value) / s;
    n.setExtent.call(t, v + p * _, g + p * b), n.setInterval.call(t, p), (_ || b) && n.setNiceExtent.call(t, v + p, g - p);
  }
  var goe = function() {
    function t(e, r, n) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = true, this.dimensions = aw, this._initCartesian(e, r, n), this.model = e;
    }
    return t.prototype.getRect = function() {
      return this._rect;
    }, t.prototype.update = function(e, r) {
      var n = this._axesMap;
      this._updateScale(e, this.model);
      function i(o) {
        var s, l = gt(o), u = l.length;
        if (u) {
          for (var c = [], h = u - 1; h >= 0; h--) {
            var f = +l[h], d = o[f], p = d.model, v = d.scale;
            Qx(v) && p.get("alignTicks") && p.get("interval") == null ? c.push(d) : (xc(v, p), Qx(v) && (s = d));
          }
          c.length && (s || (s = c.pop(), xc(s.scale, s.model)), $(c, function(g) {
            VG(g.scale, g.model, s.scale);
          }));
        }
      }
      i(n.x), i(n.y);
      var a = {};
      $(n.x, function(o) {
        Wk(n, "y", o, a);
      }), $(n.y, function(o) {
        Wk(n, "x", o, a);
      }), this.resize(this.model, r);
    }, t.prototype.resize = function(e, r, n) {
      var i = e.getBoxLayoutParams(), a = !n && e.get("containLabel"), o = Tr(i, {
        width: r.getWidth(),
        height: r.getHeight()
      });
      this._rect = o;
      var s = this._axesList;
      l(), a && ($(s, function(u) {
        if (!u.model.get([
          "axisLabel",
          "inside"
        ])) {
          var c = Kne(u);
          if (c) {
            var h = u.isHorizontal() ? "height" : "width", f = u.model.get([
              "axisLabel",
              "margin"
            ]);
            o[h] -= c[h] + f, u.position === "top" ? o.y += c.height + f : u.position === "left" && (o.x += c.width + f);
          }
        }
      }), l()), $(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        $(s, function(u) {
          var c = u.isHorizontal(), h = c ? [
            0,
            o.width
          ] : [
            0,
            o.height
          ], f = u.inverse ? 1 : 0;
          u.setExtent(h[f], h[1 - f]), moe(u, c ? o.x : o.y);
        });
      }
    }, t.prototype.getAxis = function(e, r) {
      var n = this._axesMap[e];
      if (n != null) return n[r || 0];
    }, t.prototype.getAxes = function() {
      return this._axesList.slice();
    }, t.prototype.getCartesian = function(e, r) {
      if (e != null && r != null) {
        var n = "x" + e + "y" + r;
        return this._coordsMap[n];
      }
      Le(e) && (r = e.yAxisIndex, e = e.xAxisIndex);
      for (var i = 0, a = this._coordsList; i < a.length; i++) if (a[i].getAxis("x").index === e || a[i].getAxis("y").index === r) return a[i];
    }, t.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, t.prototype.convertToPixel = function(e, r, n) {
      var i = this._findConvertTarget(r);
      return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null;
    }, t.prototype.convertFromPixel = function(e, r, n) {
      var i = this._findConvertTarget(r);
      return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null;
    }, t.prototype._findConvertTarget = function(e) {
      var r = e.seriesModel, n = e.xAxisModel || r && r.getReferringComponents("xAxis", gr).models[0], i = e.yAxisModel || r && r.getReferringComponents("yAxis", gr).models[0], a = e.gridModel, o = this._coordsList, s, l;
      if (r) s = r.coordinateSystem, et(o, s) < 0 && (s = null);
      else if (n && i) s = this.getCartesian(n.componentIndex, i.componentIndex);
      else if (n) l = this.getAxis("x", n.componentIndex);
      else if (i) l = this.getAxis("y", i.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, t.prototype.containPoint = function(e) {
      var r = this._coordsList[0];
      if (r) return r.containPoint(e);
    }, t.prototype._initCartesian = function(e, r, n) {
      var i = this, a = this, o = {
        left: false,
        right: false,
        top: false,
        bottom: false
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (r.eachComponent("xAxis", u("x"), this), r.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, $(s.x, function(c, h) {
        $(s.y, function(f, d) {
          var p = "x" + h + "y" + d, v = new poe(p);
          v.master = i, v.model = e, i._coordsMap[p] = v, i._coordsList.push(v), v.addAxis(c), v.addAxis(f);
        });
      });
      function u(c) {
        return function(h, f) {
          if (p_(h, e)) {
            var d = h.get("position");
            c === "x" ? d !== "top" && d !== "bottom" && (d = o.bottom ? "top" : "bottom") : d !== "left" && d !== "right" && (d = o.left ? "right" : "left"), o[d] = true;
            var p = new voe(c, fy(h), [
              0,
              0
            ], h.get("type"), d), v = p.type === "category";
            p.onBand = v && h.get("boundaryGap"), p.inverse = h.get("inverse"), h.axis = p, p.model = h, p.grid = a, p.index = f, a._axesList.push(p), s[c][f] = p, l[c]++;
          }
        };
      }
    }, t.prototype._updateScale = function(e, r) {
      $(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var a = i.model.get("categorySortInfo");
          i.scale.setSortInfo(a);
        }
      }), e.eachSeries(function(i) {
        if (Vk(i)) {
          var a = Gk(i), o = a.xAxisModel, s = a.yAxisModel;
          if (!p_(o, r) || !p_(s, r)) return;
          var l = this.getCartesian(o.componentIndex, s.componentIndex), u = i.getData(), c = l.getAxis("x"), h = l.getAxis("y");
          n(u, c), n(u, h);
        }
      }, this);
      function n(i, a) {
        $(Yg(i, a.dim), function(o) {
          a.scale.unionExtentFromData(i, o);
        });
      }
    }, t.prototype.getTooltipAxes = function(e) {
      var r = [], n = [];
      return $(this.getCartesians(), function(i) {
        var a = e != null && e !== "auto" ? i.getAxis(e) : i.getBaseAxis(), o = i.getOtherAxis(a);
        et(r, a) < 0 && r.push(a), et(n, o) < 0 && n.push(o);
      }), {
        baseAxes: r,
        otherAxes: n
      };
    }, t.create = function(e, r) {
      var n = [];
      return e.eachComponent("grid", function(i, a) {
        var o = new t(i, e, r);
        o.name = "grid_" + a, o.resize(i, r, true), i.coordinateSystem = o, n.push(o);
      }), e.eachSeries(function(i) {
        if (Vk(i)) {
          var a = Gk(i), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel(), u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex);
        }
      }), n;
    }, t.dimensions = aw, t;
  }();
  function p_(t, e) {
    return t.getCoordSysModel() === e;
  }
  function Wk(t, e, r, n) {
    r.getAxesOnZeroOf = function() {
      return a ? [
        a
      ] : [];
    };
    var i = t[e], a, o = r.model, s = o.get([
      "axisLine",
      "onZero"
    ]), l = o.get([
      "axisLine",
      "onZeroAxisIndex"
    ]);
    if (!s) return;
    if (l != null) Hk(i[l]) && (a = i[l]);
    else for (var u in i) if (i.hasOwnProperty(u) && Hk(i[u]) && !n[c(i[u])]) {
      a = i[u];
      break;
    }
    a && (n[c(a)] = true);
    function c(h) {
      return h.dim + "_" + h.index;
    }
  }
  function Hk(t) {
    return t && t.type !== "category" && t.type !== "time" && jne(t);
  }
  function moe(t, e) {
    var r = t.getExtent(), n = r[0] + r[1];
    t.toGlobalCoord = t.dim === "x" ? function(i) {
      return i + e;
    } : function(i) {
      return n - i + e;
    }, t.toLocalCoord = t.dim === "x" ? function(i) {
      return i - e;
    } : function(i) {
      return n - i + e;
    };
  }
  var ts = Math.PI, _n = function() {
    function t(e, r) {
      this.group = new Be(), this.opt = r, this.axisModel = e, Ee(r, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true,
        handleAutoShown: function() {
          return true;
        }
      });
      var n = new Be({
        x: r.position[0],
        y: r.position[1],
        rotation: r.rotation
      });
      n.updateTransform(), this._transformGroup = n;
    }
    return t.prototype.hasBuilder = function(e) {
      return !!Uk[e];
    }, t.prototype.add = function(e) {
      Uk[e](this.opt, this.axisModel, this.group, this._transformGroup);
    }, t.prototype.getGroup = function() {
      return this.group;
    }, t.innerTextLayout = function(e, r, n) {
      var i = i4(r - e), a, o;
      return Uf(i) ? (o = n > 0 ? "top" : "bottom", a = "center") : Uf(i - ts) ? (o = n > 0 ? "bottom" : "top", a = "center") : (o = "middle", i > 0 && i < ts ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: a,
        textVerticalAlign: o
      };
    }, t.makeAxisEventDataBase = function(e) {
      var r = {
        componentType: e.mainType,
        componentIndex: e.componentIndex
      };
      return r[e.mainType + "Index"] = e.componentIndex, r;
    }, t.isLabelSilent = function(e) {
      var r = e.get("tooltip");
      return e.get("silent") || !(e.get("triggerEvent") || r && r.show);
    }, t;
  }(), Uk = {
    axisLine: function(t, e, r, n) {
      var i = e.get([
        "axisLine",
        "show"
      ]);
      if (i === "auto" && t.handleAutoShown && (i = t.handleAutoShown("axisLine")), !!i) {
        var a = e.axis.getExtent(), o = n.transform, s = [
          a[0],
          0
        ], l = [
          a[1],
          0
        ], u = s[0] > l[0];
        o && (Ur(s, s, o), Ur(l, l, o));
        var c = te({
          lineCap: "round"
        }, e.getModel([
          "axisLine",
          "lineStyle"
        ]).getLineStyle()), h = new Mr({
          shape: {
            x1: s[0],
            y1: s[1],
            x2: l[0],
            y2: l[1]
          },
          style: c,
          strokeContainThreshold: t.strokeContainThreshold || 5,
          silent: true,
          z2: 1
        });
        yc(h.shape, h.style.lineWidth), h.anid = "line", r.add(h);
        var f = e.get([
          "axisLine",
          "symbol"
        ]);
        if (f != null) {
          var d = e.get([
            "axisLine",
            "symbolSize"
          ]);
          me(f) && (f = [
            f,
            f
          ]), (me(d) || xt(d)) && (d = [
            d,
            d
          ]);
          var p = ou(e.get([
            "axisLine",
            "symbolOffset"
          ]) || 0, d), v = d[0], g = d[1];
          $([
            {
              rotate: t.rotation + Math.PI / 2,
              offset: p[0],
              r: 0
            },
            {
              rotate: t.rotation - Math.PI / 2,
              offset: p[1],
              r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
            }
          ], function(m, y) {
            if (f[y] !== "none" && f[y] != null) {
              var _ = mr(f[y], -v / 2, -g / 2, v, g, c.stroke, true), b = m.r + m.offset, w = u ? l : s;
              _.attr({
                rotation: m.rotate,
                x: w[0] + b * Math.cos(t.rotation),
                y: w[1] - b * Math.sin(t.rotation),
                silent: true,
                z2: 11
              }), r.add(_);
            }
          });
        }
      }
    },
    axisTickLabel: function(t, e, r, n) {
      var i = boe(r, n, e, t), a = woe(r, n, e, t);
      if (_oe(e, a, i), xoe(r, n, e, t.tickDirection), e.get([
        "axisLabel",
        "hideOverlap"
      ])) {
        var o = iG(oe(a, function(s) {
          return {
            label: s,
            priority: s.z2,
            defaultAttr: {
              ignore: s.ignore
            }
          };
        }));
        sG(o);
      }
    },
    axisName: function(t, e, r, n) {
      var i = Fr(t.axisName, e.get("name"));
      if (i) {
        var a = e.get("nameLocation"), o = t.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = e.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, h = [
          a === "start" ? u[0] - c * l : a === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
          qk(a) ? t.labelOffset + o * l : 0
        ], f, d = e.get("nameRotate");
        d != null && (d = d * ts / 180);
        var p;
        qk(a) ? f = _n.innerTextLayout(t.rotation, d ?? t.rotation, o) : (f = yoe(t.rotation, a, d || 0, u), p = t.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(f.rotation)), !isFinite(p) && (p = null)));
        var v = s.getFont(), g = e.get("nameTruncate", true) || {}, m = g.ellipsis, y = Fr(t.nameTruncateMaxWidth, g.maxWidth, p), _ = new bt({
          x: h[0],
          y: h[1],
          rotation: f.rotation,
          silent: _n.isLabelSilent(e),
          style: Yt(s, {
            text: i,
            font: v,
            overflow: "truncate",
            width: y,
            ellipsis: m,
            fill: s.getTextColor() || e.get([
              "axisLine",
              "lineStyle",
              "color"
            ]),
            align: s.get("align") || f.textAlign,
            verticalAlign: s.get("verticalAlign") || f.textVerticalAlign
          }),
          z2: 1
        });
        if (iu({
          el: _,
          componentModel: e,
          itemName: i
        }), _.__fullText = i, _.anid = "name", e.get("triggerEvent")) {
          var b = _n.makeAxisEventDataBase(e);
          b.targetType = "axisName", b.name = i, Ge(_).eventData = b;
        }
        n.add(_), _.updateTransform(), r.add(_), _.decomposeTransform();
      }
    }
  };
  function yoe(t, e, r, n) {
    var i = i4(r - t), a, o, s = n[0] > n[1], l = e === "start" && !s || e !== "start" && s;
    return Uf(i - ts / 2) ? (o = l ? "bottom" : "top", a = "center") : Uf(i - ts * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", i < ts * 1.5 && i > ts / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
      rotation: i,
      textAlign: a,
      textVerticalAlign: o
    };
  }
  function _oe(t, e, r) {
    if (!U5(t.axis)) {
      var n = t.get([
        "axisLabel",
        "showMinLabel"
      ]), i = t.get([
        "axisLabel",
        "showMaxLabel"
      ]);
      e = e || [], r = r || [];
      var a = e[0], o = e[1], s = e[e.length - 1], l = e[e.length - 2], u = r[0], c = r[1], h = r[r.length - 1], f = r[r.length - 2];
      n === false ? (ri(a), ri(u)) : Yk(a, o) && (n ? (ri(o), ri(c)) : (ri(a), ri(u))), i === false ? (ri(s), ri(h)) : Yk(l, s) && (i ? (ri(l), ri(f)) : (ri(s), ri(h)));
    }
  }
  function ri(t) {
    t && (t.ignore = true);
  }
  function Yk(t, e) {
    var r = t && t.getBoundingRect().clone(), n = e && e.getBoundingRect().clone();
    if (!(!r || !n)) {
      var i = Nm([]);
      return nu(i, i, -t.rotation), r.applyTransform(io([], i, t.getLocalTransform())), n.applyTransform(io([], i, e.getLocalTransform())), r.intersect(n);
    }
  }
  function qk(t) {
    return t === "middle" || t === "center";
  }
  function GG(t, e, r, n, i) {
    for (var a = [], o = [], s = [], l = 0; l < t.length; l++) {
      var u = t[l].coord;
      o[0] = u, o[1] = 0, s[0] = u, s[1] = r, e && (Ur(o, o, e), Ur(s, s, e));
      var c = new Mr({
        shape: {
          x1: o[0],
          y1: o[1],
          x2: s[0],
          y2: s[1]
        },
        style: n,
        z2: 2,
        autoBatch: true,
        silent: true
      });
      yc(c.shape, c.style.lineWidth), c.anid = i + "_" + t[l].tickValue, a.push(c);
    }
    return a;
  }
  function boe(t, e, r, n) {
    var i = r.axis, a = r.getModel("axisTick"), o = a.get("show");
    if (o === "auto" && n.handleAutoShown && (o = n.handleAutoShown("axisTick")), !(!o || i.scale.isBlank())) {
      for (var s = a.getModel("lineStyle"), l = n.tickDirection * a.get("length"), u = i.getTicksCoords(), c = GG(u, e.transform, l, Ee(s.getLineStyle(), {
        stroke: r.get([
          "axisLine",
          "lineStyle",
          "color"
        ])
      }), "ticks"), h = 0; h < c.length; h++) t.add(c[h]);
      return c;
    }
  }
  function xoe(t, e, r, n) {
    var i = r.axis, a = r.getModel("minorTick");
    if (!(!a.get("show") || i.scale.isBlank())) {
      var o = i.getMinorTicksCoords();
      if (o.length) for (var s = a.getModel("lineStyle"), l = n * a.get("length"), u = Ee(s.getLineStyle(), Ee(r.getModel("axisTick").getLineStyle(), {
        stroke: r.get([
          "axisLine",
          "lineStyle",
          "color"
        ])
      })), c = 0; c < o.length; c++) for (var h = GG(o[c], e.transform, l, u, "minorticks_" + c), f = 0; f < h.length; f++) t.add(h[f]);
    }
  }
  function woe(t, e, r, n) {
    var i = r.axis, a = Fr(n.axisLabelShow, r.get([
      "axisLabel",
      "show"
    ]));
    if (!(!a || i.scale.isBlank())) {
      var o = r.getModel("axisLabel"), s = o.get("margin"), l = i.getViewLabels(), u = (Fr(n.labelRotate, o.get("rotate")) || 0) * ts / 180, c = _n.innerTextLayout(n.rotation, u, n.labelDirection), h = r.getCategories && r.getCategories(true), f = [], d = _n.isLabelSilent(r), p = r.get("triggerEvent");
      return $(l, function(v, g) {
        var m = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(v.tickValue) : v.tickValue, y = v.formattedLabel, _ = v.rawLabel, b = o;
        if (h && h[m]) {
          var w = h[m];
          Le(w) && w.textStyle && (b = new kt(w.textStyle, o, r.ecModel));
        }
        var x = b.getTextColor() || r.get([
          "axisLine",
          "lineStyle",
          "color"
        ]), T = i.dataToCoord(m), A = b.getShallow("align", true) || c.textAlign, I = We(b.getShallow("alignMinLabel", true), A), M = We(b.getShallow("alignMaxLabel", true), A), k = b.getShallow("verticalAlign", true) || b.getShallow("baseline", true) || c.textVerticalAlign, B = We(b.getShallow("verticalAlignMinLabel", true), k), L = We(b.getShallow("verticalAlignMaxLabel", true), k), z = new bt({
          x: T,
          y: n.labelOffset + n.labelDirection * s,
          rotation: c.rotation,
          silent: d,
          z2: 10 + (v.level || 0),
          style: Yt(b, {
            text: y,
            align: g === 0 ? I : g === l.length - 1 ? M : A,
            verticalAlign: g === 0 ? B : g === l.length - 1 ? L : k,
            fill: De(x) ? x(i.type === "category" ? _ : i.type === "value" ? m + "" : m, g) : x
          })
        });
        if (z.anid = "label_" + m, iu({
          el: z,
          componentModel: r,
          itemName: y,
          formatterParamsExtra: {
            isTruncated: function() {
              return z.isTruncated;
            },
            value: _,
            tickIndex: g
          }
        }), p) {
          var F = _n.makeAxisEventDataBase(r);
          F.targetType = "axisLabel", F.value = _, F.tickIndex = g, i.type === "category" && (F.dataIndex = m), Ge(z).eventData = F;
        }
        e.add(z), z.updateTransform(), f.push(z), t.add(z), z.decomposeTransform();
      }), f;
    }
  }
  function Soe(t, e) {
    var r = {
      axesInfo: {},
      seriesInvolved: false,
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    return Toe(r, t, e), r.seriesInvolved && Aoe(r, t), r;
  }
  function Toe(t, e, r) {
    var n = e.getComponent("tooltip"), i = e.getComponent("axisPointer"), a = i.get("link", true) || [], o = [];
    $(r.getCoordinateSystems(), function(s) {
      if (!s.axisPointerEnabled) return;
      var l = od(s.model), u = t.coordSysAxesInfo[l] = {};
      t.coordSysMap[l] = s;
      var c = s.model, h = c.getModel("tooltip", n);
      if ($(s.getAxes(), Ye(v, false, null)), s.getTooltipAxes && n && h.get("show")) {
        var f = h.get("trigger") === "axis", d = h.get([
          "axisPointer",
          "type"
        ]) === "cross", p = s.getTooltipAxes(h.get([
          "axisPointer",
          "axis"
        ]));
        (f || d) && $(p.baseAxes, Ye(v, d ? "cross" : true, f)), d && $(p.otherAxes, Ye(v, "cross", false));
      }
      function v(g, m, y) {
        var _ = y.model.getModel("axisPointer", i), b = _.get("show");
        if (!(!b || b === "auto" && !g && !sw(_))) {
          m == null && (m = _.get("triggerTooltip")), _ = g ? Coe(y, h, i, e, g, m) : _;
          var w = _.get("snap"), x = _.get("triggerEmphasis"), T = od(y.model), A = m || w || y.type === "category", I = t.axesInfo[T] = {
            key: T,
            axis: y,
            coordSys: s,
            axisPointerModel: _,
            triggerTooltip: m,
            triggerEmphasis: x,
            involveSeries: A,
            snap: w,
            useHandle: sw(_),
            seriesModels: [],
            linkGroup: null
          };
          u[T] = I, t.seriesInvolved = t.seriesInvolved || A;
          var M = Ioe(a, y);
          if (M != null) {
            var k = o[M] || (o[M] = {
              axesInfo: {}
            });
            k.axesInfo[T] = I, k.mapper = a[M].mapper, I.linkGroup = k;
          }
        }
      }
    });
  }
  function Coe(t, e, r, n, i, a) {
    var o = e.getModel("axisPointer"), s = [
      "type",
      "snap",
      "lineStyle",
      "shadowStyle",
      "label",
      "animation",
      "animationDurationUpdate",
      "animationEasingUpdate",
      "z"
    ], l = {};
    $(s, function(f) {
      l[f] = Oe(o.get(f));
    }), l.snap = t.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
    var u = l.label || (l.label = {});
    if (u.show == null && (u.show = false), i === "cross") {
      var c = o.get([
        "label",
        "show"
      ]);
      if (u.show = c ?? true, !a) {
        var h = l.lineStyle = o.get("crossStyle");
        h && Ee(u, h.textStyle);
      }
    }
    return t.model.getModel("axisPointer", new kt(l, r, n));
  }
  function Aoe(t, e) {
    e.eachSeries(function(r) {
      var n = r.coordinateSystem, i = r.get([
        "tooltip",
        "trigger"
      ], true), a = r.get([
        "tooltip",
        "show"
      ], true);
      !n || i === "none" || i === false || i === "item" || a === false || r.get([
        "axisPointer",
        "show"
      ], true) === false || $(t.coordSysAxesInfo[od(n.model)], function(o) {
        var s = o.axis;
        n.getAxis(s.dim) === s && (o.seriesModels.push(r), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += r.getData().count());
      });
    });
  }
  function Ioe(t, e) {
    for (var r = e.model, n = e.dim, i = 0; i < t.length; i++) {
      var a = t[i] || {};
      if (v_(a[n + "AxisId"], r.id) || v_(a[n + "AxisIndex"], r.componentIndex) || v_(a[n + "AxisName"], r.name)) return i;
    }
  }
  function v_(t, e) {
    return t === "all" || ae(t) && et(t, e) >= 0 || t === e;
  }
  function Moe(t) {
    var e = e2(t);
    if (e) {
      var r = e.axisPointerModel, n = e.axis.scale, i = r.option, a = r.get("status"), o = r.get("value");
      o != null && (o = n.parse(o));
      var s = sw(r);
      a == null && (i.status = s ? "show" : "hide");
      var l = n.getExtent().slice();
      l[0] > l[1] && l.reverse(), (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), i.value = o, s && (i.status = e.axis.scale.isBlank() ? "hide" : "show");
    }
  }
  function e2(t) {
    var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return e && e.axesInfo[od(t)];
  }
  function Doe(t) {
    var e = e2(t);
    return e && e.axisPointerModel;
  }
  function sw(t) {
    return !!t.get([
      "handle",
      "show"
    ]);
  }
  function od(t) {
    return t.type + "||" + t.id;
  }
  var Xk = {}, uu = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i, a) {
      this.axisPointerClass && Moe(r), t.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(r, i, true);
    }, e.prototype.updateAxisPointer = function(r, n, i, a) {
      this._doUpdateAxisPointerClass(r, i, false);
    }, e.prototype.remove = function(r, n) {
      var i = this._axisPointer;
      i && i.remove(n);
    }, e.prototype.dispose = function(r, n) {
      this._disposeAxisPointer(n), t.prototype.dispose.apply(this, arguments);
    }, e.prototype._doUpdateAxisPointerClass = function(r, n, i) {
      var a = e.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = Doe(r);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(r, o, n, i) : this._disposeAxisPointer(n);
      }
    }, e.prototype._disposeAxisPointer = function(r) {
      this._axisPointer && this._axisPointer.dispose(r), this._axisPointer = null;
    }, e.registerAxisPointerClass = function(r, n) {
      Xk[r] = n;
    }, e.getAxisPointerClass = function(r) {
      return r && Xk[r];
    }, e.type = "axis", e;
  }(tr), lw = _t();
  function WG(t, e, r, n) {
    var i = r.axis;
    if (!i.scale.isBlank()) {
      var a = r.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = n.coordinateSystem.getRect(), u = i.getTicksCoords({
        tickModel: a,
        clamp: true
      });
      if (u.length) {
        var c = s.length, h = lw(t).splitAreaColors, f = Ce(), d = 0;
        if (h) for (var p = 0; p < u.length; p++) {
          var v = h.get(u[p].tickValue);
          if (v != null) {
            d = (v + (c - 1) * p) % c;
            break;
          }
        }
        var g = i.toGlobalCoord(u[0].coord), m = o.getAreaStyle();
        s = ae(s) ? s : [
          s
        ];
        for (var p = 1; p < u.length; p++) {
          var y = i.toGlobalCoord(u[p].coord), _ = void 0, b = void 0, w = void 0, x = void 0;
          i.isHorizontal() ? (_ = g, b = l.y, w = y - _, x = l.height, g = _ + w) : (_ = l.x, b = g, w = l.width, x = y - b, g = b + x);
          var T = u[p - 1].tickValue;
          T != null && f.set(T, d), e.add(new yt({
            anid: T != null ? "area_" + T : null,
            shape: {
              x: _,
              y: b,
              width: w,
              height: x
            },
            style: Ee({
              fill: s[d]
            }, m),
            autoBatch: true,
            silent: true
          })), d = (d + 1) % c;
        }
        lw(t).splitAreaColors = f;
      }
    }
  }
  function HG(t) {
    lw(t).splitAreaColors = null;
  }
  var Eoe = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], koe = [
    "splitArea",
    "splitLine",
    "minorSplitLine"
  ], UG = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.axisPointerClass = "CartesianAxisPointer", r;
    }
    return e.prototype.render = function(r, n, i, a) {
      this.group.removeAll();
      var o = this._axisGroup;
      if (this._axisGroup = new Be(), this.group.add(this._axisGroup), !!r.get("show")) {
        var s = r.getCoordSysModel(), l = ow(s, r), u = new _n(r, te({
          handleAutoShown: function(h) {
            for (var f = s.coordinateSystem.getCartesians(), d = 0; d < f.length; d++) if (Qx(f[d].getOtherAxis(r.axis).scale)) return true;
            return false;
          }
        }, l));
        $(Eoe, u.add, u), this._axisGroup.add(u.getGroup()), $(koe, function(h) {
          r.get([
            h,
            "show"
          ]) && Poe[h](this, this._axisGroup, r, s);
        }, this);
        var c = a && a.type === "changeAxisOrder" && a.isInitSort;
        c || Rd(o, this._axisGroup, r), t.prototype.render.call(this, r, n, i, a);
      }
    }, e.prototype.remove = function() {
      HG(this);
    }, e.type = "cartesianAxis", e;
  }(uu), Poe = {
    splitLine: function(t, e, r, n) {
      var i = r.axis;
      if (!i.scale.isBlank()) {
        var a = r.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color"), l = a.get("showMinLine") !== false, u = a.get("showMaxLine") !== false;
        s = ae(s) ? s : [
          s
        ];
        for (var c = n.coordinateSystem.getRect(), h = i.isHorizontal(), f = 0, d = i.getTicksCoords({
          tickModel: a
        }), p = [], v = [], g = o.getLineStyle(), m = 0; m < d.length; m++) {
          var y = i.toGlobalCoord(d[m].coord);
          if (!(m === 0 && !l || m === d.length - 1 && !u)) {
            var _ = d[m].tickValue;
            h ? (p[0] = y, p[1] = c.y, v[0] = y, v[1] = c.y + c.height) : (p[0] = c.x, p[1] = y, v[0] = c.x + c.width, v[1] = y);
            var b = f++ % s.length, w = new Mr({
              anid: _ != null ? "line_" + _ : null,
              autoBatch: true,
              shape: {
                x1: p[0],
                y1: p[1],
                x2: v[0],
                y2: v[1]
              },
              style: Ee({
                stroke: s[b]
              }, g),
              silent: true
            });
            yc(w.shape, g.lineWidth), e.add(w);
          }
        }
      }
    },
    minorSplitLine: function(t, e, r, n) {
      var i = r.axis, a = r.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = n.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
      if (u.length) for (var c = [], h = [], f = o.getLineStyle(), d = 0; d < u.length; d++) for (var p = 0; p < u[d].length; p++) {
        var v = i.toGlobalCoord(u[d][p].coord);
        l ? (c[0] = v, c[1] = s.y, h[0] = v, h[1] = s.y + s.height) : (c[0] = s.x, c[1] = v, h[0] = s.x + s.width, h[1] = v);
        var g = new Mr({
          anid: "minor_line_" + u[d][p].tickValue,
          autoBatch: true,
          shape: {
            x1: c[0],
            y1: c[1],
            x2: h[0],
            y2: h[1]
          },
          style: f,
          silent: true
        });
        yc(g.shape, f.lineWidth), e.add(g);
      }
    },
    splitArea: function(t, e, r, n) {
      WG(t, e, r, n);
    }
  }, YG = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "xAxis", e;
  }(UG), Loe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = YG.type, r;
    }
    return e.type = "yAxis", e;
  }(UG), $oe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = "grid", r;
    }
    return e.prototype.render = function(r, n) {
      this.group.removeAll(), r.get("show") && this.group.add(new yt({
        shape: r.coordinateSystem.getRect(),
        style: Ee({
          fill: r.get("backgroundColor")
        }, r.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }, e.type = "grid", e;
  }(tr), jk = {
    offset: 0
  };
  function qG(t) {
    t.registerComponentView($oe), t.registerComponentModel(loe), t.registerCoordinateSystem("cartesian2d", goe), Sc(t, "x", iw, jk), Sc(t, "y", iw, jk), t.registerComponentView(YG), t.registerComponentView(Loe), t.registerPreprocessor(function(e) {
      e.xAxis && e.yAxis && !e.grid && (e.grid = {});
    });
  }
  function Roe(t) {
    rt(qG), t.registerSeriesModel(noe), t.registerChartView(soe), t.registerLayout(Hd("scatter"));
  }
  function Ooe(t) {
    t.eachSeriesByType("radar", function(e) {
      var r = e.getData(), n = [], i = e.coordinateSystem;
      if (i) {
        var a = i.getIndicatorAxes();
        $(a, function(o, s) {
          r.each(r.mapDimension(a[s].dim), function(l, u) {
            n[u] = n[u] || [];
            var c = i.dataToPoint(l, s);
            n[u][s] = Kk(c) ? c : Zk(i);
          });
        }), r.each(function(o) {
          var s = yK(n[o], function(l) {
            return Kk(l);
          }) || Zk(i);
          n[o].push(s.slice()), r.setItemLayout(o, n[o]);
        });
      }
    });
  }
  function Kk(t) {
    return !isNaN(t[0]) && !isNaN(t[1]);
  }
  function Zk(t) {
    return [
      t.cx,
      t.cy
    ];
  }
  function Noe(t) {
    var e = t.polar;
    if (e) {
      ae(e) || (e = [
        e
      ]);
      var r = [];
      $(e, function(n, i) {
        n.indicator ? (n.type && !n.shape && (n.shape = n.type), t.radar = t.radar || [], ae(t.radar) || (t.radar = [
          t.radar
        ]), t.radar.push(n)) : r.push(n);
      }), t.polar = r;
    }
    $(t.series, function(n) {
      n && n.type === "radar" && n.polarIndex && (n.radarIndex = n.polarIndex);
    });
  }
  var Boe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = r.coordinateSystem, o = this.group, s = r.getData(), l = this._data;
      function u(f, d) {
        var p = f.getItemVisual(d, "symbol") || "circle";
        if (p !== "none") {
          var v = Kc(f.getItemVisual(d, "symbolSize")), g = mr(p, -1, -1, 2, 2), m = f.getItemVisual(d, "symbolRotate") || 0;
          return g.attr({
            style: {
              strokeNoScale: true
            },
            z2: 100,
            scaleX: v[0] / 2,
            scaleY: v[1] / 2,
            rotation: m * Math.PI / 180 || 0
          }), g;
        }
      }
      function c(f, d, p, v, g, m) {
        p.removeAll();
        for (var y = 0; y < d.length - 1; y++) {
          var _ = u(v, g);
          _ && (_.__dimIdx = y, f[y] ? (_.setPosition(f[y]), au[m ? "initProps" : "updateProps"](_, {
            x: d[y][0],
            y: d[y][1]
          }, r, g)) : _.setPosition(d[y]), p.add(_));
        }
      }
      function h(f) {
        return oe(f, function(d) {
          return [
            a.cx,
            a.cy
          ];
        });
      }
      s.diff(l).add(function(f) {
        var d = s.getItemLayout(f);
        if (d) {
          var p = new Sn(), v = new Tn(), g = {
            shape: {
              points: d
            }
          };
          p.shape.points = h(d), v.shape.points = h(d), er(p, g, r, f), er(v, g, r, f);
          var m = new Be(), y = new Be();
          m.add(v), m.add(p), m.add(y), c(v.shape.points, d, y, s, f, true), s.setItemGraphicEl(f, m);
        }
      }).update(function(f, d) {
        var p = l.getItemGraphicEl(d), v = p.childAt(0), g = p.childAt(1), m = p.childAt(2), y = {
          shape: {
            points: s.getItemLayout(f)
          }
        };
        y.shape.points && (c(v.shape.points, y.shape.points, m, s, f, false), Ki(g), Ki(v), wt(v, y, r), wt(g, y, r), s.setItemGraphicEl(f, p));
      }).remove(function(f) {
        o.remove(l.getItemGraphicEl(f));
      }).execute(), s.eachItemGraphicEl(function(f, d) {
        var p = s.getItemModel(d), v = f.childAt(0), g = f.childAt(1), m = f.childAt(2), y = s.getItemVisual(d, "style"), _ = y.fill;
        o.add(f), v.useStyle(Ee(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: _
        })), qr(v, p, "lineStyle"), qr(g, p, "areaStyle");
        var b = p.getModel("areaStyle"), w = b.isEmpty() && b.parentModel.isEmpty();
        g.ignore = w, $([
          "emphasis",
          "select",
          "blur"
        ], function(A) {
          var I = p.getModel([
            A,
            "areaStyle"
          ]), M = I.isEmpty() && I.parentModel.isEmpty();
          g.ensureState(A).ignore = M && w;
        }), g.useStyle(Ee(b.getAreaStyle(), {
          fill: _,
          opacity: 0.7,
          decal: y.decal
        }));
        var x = p.getModel("emphasis"), T = x.getModel("itemStyle").getItemStyle();
        m.eachChild(function(A) {
          if (A instanceof Gr) {
            var I = A.style;
            A.useStyle(te({
              image: I.image,
              x: I.x,
              y: I.y,
              width: I.width,
              height: I.height
            }, y));
          } else A.useStyle(y), A.setColor(_), A.style.strokeNoScale = true;
          var M = A.ensureState("emphasis");
          M.style = Oe(T);
          var k = s.getStore().get(s.getDimensionIndex(A.__dimIdx), d);
          (k == null || isNaN(k)) && (k = ""), Xr(A, Lr(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: d,
            labelDimIndex: A.__dimIdx,
            defaultText: k,
            inheritColor: _,
            defaultOpacity: y.opacity
          });
        }), ir(f, x.get("focus"), x.get("blurScope"), x.get("disabled"));
      }), this._data = s;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "radar", e;
  }(Ft), zoe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.hasSymbolVisual = true, r;
    }
    return e.prototype.init = function(r) {
      t.prototype.init.apply(this, arguments), this.legendVisualProvider = new Yd(_e(this.getData, this), _e(this.getRawData, this));
    }, e.prototype.getInitialData = function(r, n) {
      return Qc(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, e.prototype.formatTooltip = function(r, n, i) {
      var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(r), u = l === "" ? this.name : l, c = UV(this, r);
      return $r("section", {
        header: u,
        sortBlocks: true,
        blocks: oe(s, function(h) {
          var f = a.get(a.mapDimension(h.dim), r);
          return $r("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: h.name,
            value: f,
            sortParam: f
          });
        })
      });
    }, e.prototype.getTooltipPosition = function(r) {
      if (r != null) {
        for (var n = this.getData(), i = this.coordinateSystem, a = n.getValues(oe(i.dimensions, function(u) {
          return n.mapDimension(u);
        }), r), o = 0, s = a.length; o < s; o++) if (!isNaN(a[o])) {
          var l = i.getIndicatorAxes();
          return i.coordToPoint(l[o].dataToCoord(a[o]), o);
        }
      }
    }, e.type = "series.radar", e.dependencies = [
      "radar"
    ], e.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: true,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      symbolSize: 8
    }, e;
  }(Xt), Th = FG.value;
  function Zp(t, e) {
    return Ee({
      show: e
    }, t);
  }
  var Foe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.optionUpdated = function() {
      var r = this.get("boundaryGap"), n = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get([
        "axisName",
        "show"
      ]), c = this.get([
        "axisName",
        "formatter"
      ]), h = this.get("axisNameGap"), f = this.get("triggerEvent"), d = oe(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var v = l;
        p.color != null && (v = Ee({
          color: p.color
        }, l));
        var g = je(Oe(p), {
          boundaryGap: r,
          splitNumber: n,
          scale: i,
          axisLine: a,
          axisTick: o,
          axisLabel: s,
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: h,
          nameTextStyle: v,
          triggerEvent: f
        }, false);
        if (me(c)) {
          var m = g.name;
          g.name = c.replace("{value}", m ?? "");
        } else De(c) && (g.name = c(g.name, g));
        var y = new kt(g, null, this.ecModel);
        return yr(y, Fd.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = d;
    }, e.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, e.type = "radar", e.defaultOption = {
      z: 0,
      center: [
        "50%",
        "50%"
      ],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: true
      },
      boundaryGap: [
        0,
        0
      ],
      splitNumber: 5,
      axisNameGap: 15,
      scale: false,
      shape: "polygon",
      axisLine: je({
        lineStyle: {
          color: "#bbb"
        }
      }, Th.axisLine),
      axisLabel: Zp(Th.axisLabel, false),
      axisTick: Zp(Th.axisTick, false),
      splitLine: Zp(Th.splitLine, true),
      splitArea: Zp(Th.splitArea, true),
      indicator: []
    }, e;
  }(vt), Voe = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], Goe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = this.group;
      a.removeAll(), this._buildAxes(r), this._buildSplitLineAndArea(r);
    }, e.prototype._buildAxes = function(r) {
      var n = r.coordinateSystem, i = n.getIndicatorAxes(), a = oe(i, function(o) {
        var s = o.model.get("showName") ? o.name : "", l = new _n(o.model, {
          axisName: s,
          position: [
            n.cx,
            n.cy
          ],
          rotation: o.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      $(a, function(o) {
        $(Voe, o.add, o), this.group.add(o.getGroup());
      }, this);
    }, e.prototype._buildSplitLineAndArea = function(r) {
      var n = r.coordinateSystem, i = n.getIndicatorAxes();
      if (!i.length) return;
      var a = r.get("shape"), o = r.getModel("splitLine"), s = r.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), c = o.get("show"), h = s.get("show"), f = l.get("color"), d = u.get("color"), p = ae(f) ? f : [
        f
      ], v = ae(d) ? d : [
        d
      ], g = [], m = [];
      function y(F, E, O) {
        var N = O % E.length;
        return F[N] = F[N] || [], N;
      }
      if (a === "circle") for (var _ = i[0].getTicksCoords(), b = n.cx, w = n.cy, x = 0; x < _.length; x++) {
        if (c) {
          var T = y(g, p, x);
          g[T].push(new wo({
            shape: {
              cx: b,
              cy: w,
              r: _[x].coord
            }
          }));
        }
        if (h && x < _.length - 1) {
          var T = y(m, v, x);
          m[T].push(new Pd({
            shape: {
              cx: b,
              cy: w,
              r0: _[x].coord,
              r: _[x + 1].coord
            }
          }));
        }
      }
      else for (var A, I = oe(i, function(F, E) {
        var O = F.getTicksCoords();
        return A = A == null ? O.length - 1 : Math.min(O.length - 1, A), oe(O, function(N) {
          return n.coordToPoint(N.coord, E);
        });
      }), M = [], x = 0; x <= A; x++) {
        for (var k = [], B = 0; B < i.length; B++) k.push(I[B][x]);
        if (k[0] && k.push(k[0].slice()), c) {
          var T = y(g, p, x);
          g[T].push(new Tn({
            shape: {
              points: k
            }
          }));
        }
        if (h && M) {
          var T = y(m, v, x - 1);
          m[T].push(new Sn({
            shape: {
              points: k.concat(M)
            }
          }));
        }
        M = k.slice().reverse();
      }
      var L = l.getLineStyle(), z = u.getAreaStyle();
      $(m, function(F, E) {
        this.group.add(vi(F, {
          style: Ee({
            stroke: "none",
            fill: v[E % v.length]
          }, z),
          silent: true
        }));
      }, this), $(g, function(F, E) {
        this.group.add(vi(F, {
          style: Ee({
            fill: "none",
            stroke: p[E % p.length]
          }, L),
          silent: true
        }));
      }, this);
    }, e.type = "radar", e;
  }(tr), Woe = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this, r, n, i) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return e;
  }(Ji), Hoe = function() {
    function t(e, r, n) {
      this.dimensions = [], this._model = e, this._indicatorAxes = oe(e.getIndicatorModels(), function(i, a) {
        var o = "indicator_" + a, s = new Woe(o, new go());
        return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(o), s;
      }, this), this.resize(e, n);
    }
    return t.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, t.prototype.dataToPoint = function(e, r) {
      var n = this._indicatorAxes[r];
      return this.coordToPoint(n.dataToCoord(e), r);
    }, t.prototype.coordToPoint = function(e, r) {
      var n = this._indicatorAxes[r], i = n.angle, a = this.cx + e * Math.cos(i), o = this.cy - e * Math.sin(i);
      return [
        a,
        o
      ];
    }, t.prototype.pointToData = function(e) {
      var r = e[0] - this.cx, n = e[1] - this.cy, i = Math.sqrt(r * r + n * n);
      r /= i, n /= i;
      for (var a = Math.atan2(-n, r), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], h = Math.abs(a - c.angle);
        h < o && (s = c, l = u, o = h);
      }
      return [
        l,
        +(s && s.coordToData(i))
      ];
    }, t.prototype.resize = function(e, r) {
      var n = e.get("center"), i = r.getWidth(), a = r.getHeight(), o = Math.min(i, a) / 2;
      this.cx = pe(n[0], i), this.cy = pe(n[1], a), this.startAngle = e.get("startAngle") * Math.PI / 180;
      var s = e.get("radius");
      (me(s) || xt(s)) && (s = [
        0,
        s
      ]), this.r0 = pe(s[0], o), this.r = pe(s[1], o), $(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, t.prototype.update = function(e, r) {
      var n = this._indicatorAxes, i = this._model;
      $(n, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), e.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || e.getComponent("radar", s.get("radarIndex")) !== i)) {
          var u = s.getData();
          $(n, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var a = i.get("splitNumber"), o = new go();
      o.setExtent(0, a), o.setInterval(1), $(n, function(s, l) {
        VG(s.scale, s.model, o);
      });
    }, t.prototype.convertToPixel = function(e, r, n) {
      return console.warn("Not implemented."), null;
    }, t.prototype.convertFromPixel = function(e, r, n) {
      return console.warn("Not implemented."), null;
    }, t.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), false;
    }, t.create = function(e, r) {
      var n = [];
      return e.eachComponent("radar", function(i) {
        var a = new t(i, e, r);
        n.push(a), i.coordinateSystem = a;
      }), e.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = n[i.get("radarIndex") || 0]);
      }), n;
    }, t.dimensions = [], t;
  }();
  function Uoe(t) {
    t.registerCoordinateSystem("radar", Hoe), t.registerComponentModel(Foe), t.registerComponentView(Goe), t.registerVisual({
      seriesType: "radar",
      reset: function(e) {
        var r = e.getData();
        r.each(function(n) {
          r.setItemVisual(n, "legendIcon", "roundRect");
        }), r.setVisual("legendIcon", "roundRect");
      }
    });
  }
  function Yoe(t) {
    rt(Uoe), t.registerChartView(Boe), t.registerSeriesModel(zoe), t.registerLayout(Ooe), t.registerProcessor(Ud("radar")), t.registerPreprocessor(Noe);
  }
  var Qk = "\0_ec_interaction_mutex";
  function qoe(t, e, r) {
    var n = t2(t);
    n[e] = r;
  }
  function Xoe(t, e, r) {
    var n = t2(t), i = n[e];
    i === r && (n[e] = null);
  }
  function Jk(t, e) {
    return !!t2(t)[e];
  }
  function t2(t) {
    return t[Qk] || (t[Qk] = {});
  }
  Ba({
    type: "takeGlobalCursor",
    event: "globalCursorTaken",
    update: "update"
  }, dr);
  var qd = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this) || this;
      n._zr = r;
      var i = _e(n._mousedownHandler, n), a = _e(n._mousemoveHandler, n), o = _e(n._mouseupHandler, n), s = _e(n._mousewheelHandler, n), l = _e(n._pinchHandler, n);
      return n.enable = function(u, c) {
        this.disable(), this._opt = Ee(Oe(c) || {}, {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: false,
          preventDefaultMouseMove: true
        }), u == null && (u = true), (u === true || u === "move" || u === "pan") && (r.on("mousedown", i), r.on("mousemove", a), r.on("mouseup", o)), (u === true || u === "scale" || u === "zoom") && (r.on("mousewheel", s), r.on("pinch", l));
      }, n.disable = function() {
        r.off("mousedown", i), r.off("mousemove", a), r.off("mouseup", o), r.off("mousewheel", s), r.off("pinch", l);
      }, n;
    }
    return e.prototype.isDragging = function() {
      return this._dragging;
    }, e.prototype.isPinching = function() {
      return this._pinching;
    }, e.prototype.setPointerChecker = function(r) {
      this.pointerChecker = r;
    }, e.prototype.dispose = function() {
      this.disable();
    }, e.prototype._mousedownHandler = function(r) {
      if (!MM(r)) {
        for (var n = r.target; n; ) {
          if (n.draggable) return;
          n = n.__hostTarget || n.parent;
        }
        var i = r.offsetX, a = r.offsetY;
        this.pointerChecker && this.pointerChecker(r, i, a) && (this._x = i, this._y = a, this._dragging = true);
      }
    }, e.prototype._mousemoveHandler = function(r) {
      if (!(!this._dragging || !cg("moveOnMouseMove", r, this._opt) || r.gestureEvent === "pinch" || Jk(this._zr, "globalPan"))) {
        var n = r.offsetX, i = r.offsetY, a = this._x, o = this._y, s = n - a, l = i - o;
        this._x = n, this._y = i, this._opt.preventDefaultMouseMove && co(r.event), XG(this, "pan", "moveOnMouseMove", r, {
          dx: s,
          dy: l,
          oldX: a,
          oldY: o,
          newX: n,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, e.prototype._mouseupHandler = function(r) {
      MM(r) || (this._dragging = false);
    }, e.prototype._mousewheelHandler = function(r) {
      var n = cg("zoomOnMouseWheel", r, this._opt), i = cg("moveOnMouseWheel", r, this._opt), a = r.wheelDelta, o = Math.abs(a), s = r.offsetX, l = r.offsetY;
      if (!(a === 0 || !n && !i)) {
        if (n) {
          var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
          g_(this, "zoom", "zoomOnMouseWheel", r, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var h = Math.abs(a), f = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
          g_(this, "scrollMove", "moveOnMouseWheel", r, {
            scrollDelta: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, e.prototype._pinchHandler = function(r) {
      if (!Jk(this._zr, "globalPan")) {
        var n = r.pinchScale > 1 ? 1.1 : 1 / 1.1;
        g_(this, "zoom", null, r, {
          scale: n,
          originX: r.pinchX,
          originY: r.pinchY,
          isAvailableBehavior: null
        });
      }
    }, e;
  }(xi);
  function g_(t, e, r, n, i) {
    t.pointerChecker && t.pointerChecker(n, i.originX, i.originY) && (co(n.event), XG(t, e, r, n, i));
  }
  function XG(t, e, r, n, i) {
    i.isAvailableBehavior = _e(cg, null, r, n), t.trigger(e, i);
  }
  function cg(t, e, r) {
    var n = r[t];
    return !t || n && (!me(n) || e.event[n + "Key"]);
  }
  function r2(t, e, r) {
    var n = t.target;
    n.x += e, n.y += r, n.dirty();
  }
  function n2(t, e, r, n) {
    var i = t.target, a = t.zoomLimit, o = t.zoom = t.zoom || 1;
    if (o *= e, a) {
      var s = a.min || 0, l = a.max || 1 / 0;
      o = Math.max(Math.min(l, o), s);
    }
    var u = o / t.zoom;
    t.zoom = o, i.x -= (r - i.x) * (u - 1), i.y -= (n - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
  }
  var joe = {
    axisPointer: 1,
    tooltip: 1,
    brush: 1
  };
  function py(t, e, r) {
    var n = e.getComponentByElement(t.topTarget), i = n && n.coordinateSystem;
    return n && n !== r && !joe.hasOwnProperty(n.mainType) && i && i.model !== r;
  }
  function jG(t) {
    if (me(t)) {
      var e = new DOMParser();
      t = e.parseFromString(t, "text/xml");
    }
    var r = t;
    for (r.nodeType === 9 && (r = r.firstChild); r.nodeName.toLowerCase() !== "svg" || r.nodeType !== 1; ) r = r.nextSibling;
    return r;
  }
  var m_, Zg = {
    fill: "fill",
    stroke: "stroke",
    "stroke-width": "lineWidth",
    opacity: "opacity",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-miterlimit": "miterLimit",
    "font-family": "fontFamily",
    "font-size": "fontSize",
    "font-style": "fontStyle",
    "font-weight": "fontWeight",
    "text-anchor": "textAlign",
    visibility: "visibility",
    display: "display"
  }, eP = gt(Zg), Qg = {
    "alignment-baseline": "textBaseline",
    "stop-color": "stopColor"
  }, tP = gt(Qg), Koe = function() {
    function t() {
      this._defs = {}, this._root = null;
    }
    return t.prototype.parse = function(e, r) {
      r = r || {};
      var n = jG(e);
      this._defsUsePending = [];
      var i = new Be();
      this._root = i;
      var a = [], o = n.getAttribute("viewBox") || "", s = parseFloat(n.getAttribute("width") || r.width), l = parseFloat(n.getAttribute("height") || r.height);
      isNaN(s) && (s = null), isNaN(l) && (l = null), zn(n, i, null, true, false);
      for (var u = n.firstChild; u; ) this._parseNode(u, i, a, null, false, false), u = u.nextSibling;
      Joe(this._defs, this._defsUsePending), this._defsUsePending = [];
      var c, h;
      if (o) {
        var f = vy(o);
        f.length >= 4 && (c = {
          x: parseFloat(f[0] || 0),
          y: parseFloat(f[1] || 0),
          width: parseFloat(f[2]),
          height: parseFloat(f[3])
        });
      }
      if (c && s != null && l != null && (h = ZG(c, {
        x: 0,
        y: 0,
        width: s,
        height: l
      }), !r.ignoreViewBox)) {
        var d = i;
        i = new Be(), i.add(d), d.scaleX = d.scaleY = h.scale, d.x = h.x, d.y = h.y;
      }
      return !r.ignoreRootClip && s != null && l != null && i.setClipPath(new yt({
        shape: {
          x: 0,
          y: 0,
          width: s,
          height: l
        }
      })), {
        root: i,
        width: s,
        height: l,
        viewBoxRect: c,
        viewBoxTransform: h,
        named: a
      };
    }, t.prototype._parseNode = function(e, r, n, i, a, o) {
      var s = e.nodeName.toLowerCase(), l, u = i;
      if (s === "defs" && (a = true), s === "text" && (o = true), s === "defs" || s === "switch") l = r;
      else {
        if (!a) {
          var c = m_[s];
          if (c && xe(m_, s)) {
            l = c.call(this, e, r);
            var h = e.getAttribute("name");
            if (h) {
              var f = {
                name: h,
                namedFrom: null,
                svgNodeTagLower: s,
                el: l
              };
              n.push(f), s === "g" && (u = f);
            } else i && n.push({
              name: i.name,
              namedFrom: i,
              svgNodeTagLower: s,
              el: l
            });
            r.add(l);
          }
        }
        var d = rP[s];
        if (d && xe(rP, s)) {
          var p = d.call(this, e), v = e.getAttribute("id");
          v && (this._defs[v] = p);
        }
      }
      if (l && l.isGroup) for (var g = e.firstChild; g; ) g.nodeType === 1 ? this._parseNode(g, l, n, u, a, o) : g.nodeType === 3 && o && this._parseText(g, l), g = g.nextSibling;
    }, t.prototype._parseText = function(e, r) {
      var n = new mc({
        style: {
          text: e.textContent
        },
        silent: true,
        x: this._textX || 0,
        y: this._textY || 0
      });
      ni(r, n), zn(e, n, this._defsUsePending, false, false), Zoe(n, r);
      var i = n.style, a = i.fontSize;
      a && a < 9 && (i.fontSize = 9, n.scaleX *= a / 9, n.scaleY *= a / 9);
      var o = (i.fontSize || i.fontFamily) && [
        i.fontStyle,
        i.fontWeight,
        (i.fontSize || 12) + "px",
        i.fontFamily || "sans-serif"
      ].join(" ");
      i.font = o;
      var s = n.getBoundingRect();
      return this._textX += s.width, r.add(n), n;
    }, t.internalField = function() {
      m_ = {
        g: function(e, r) {
          var n = new Be();
          return ni(r, n), zn(e, n, this._defsUsePending, false, false), n;
        },
        rect: function(e, r) {
          var n = new yt();
          return ni(r, n), zn(e, n, this._defsUsePending, false, false), n.setShape({
            x: parseFloat(e.getAttribute("x") || "0"),
            y: parseFloat(e.getAttribute("y") || "0"),
            width: parseFloat(e.getAttribute("width") || "0"),
            height: parseFloat(e.getAttribute("height") || "0")
          }), n.silent = true, n;
        },
        circle: function(e, r) {
          var n = new wo();
          return ni(r, n), zn(e, n, this._defsUsePending, false, false), n.setShape({
            cx: parseFloat(e.getAttribute("cx") || "0"),
            cy: parseFloat(e.getAttribute("cy") || "0"),
            r: parseFloat(e.getAttribute("r") || "0")
          }), n.silent = true, n;
        },
        line: function(e, r) {
          var n = new Mr();
          return ni(r, n), zn(e, n, this._defsUsePending, false, false), n.setShape({
            x1: parseFloat(e.getAttribute("x1") || "0"),
            y1: parseFloat(e.getAttribute("y1") || "0"),
            x2: parseFloat(e.getAttribute("x2") || "0"),
            y2: parseFloat(e.getAttribute("y2") || "0")
          }), n.silent = true, n;
        },
        ellipse: function(e, r) {
          var n = new qm();
          return ni(r, n), zn(e, n, this._defsUsePending, false, false), n.setShape({
            cx: parseFloat(e.getAttribute("cx") || "0"),
            cy: parseFloat(e.getAttribute("cy") || "0"),
            rx: parseFloat(e.getAttribute("rx") || "0"),
            ry: parseFloat(e.getAttribute("ry") || "0")
          }), n.silent = true, n;
        },
        polygon: function(e, r) {
          var n = e.getAttribute("points"), i;
          n && (i = aP(n));
          var a = new Sn({
            shape: {
              points: i || []
            },
            silent: true
          });
          return ni(r, a), zn(e, a, this._defsUsePending, false, false), a;
        },
        polyline: function(e, r) {
          var n = e.getAttribute("points"), i;
          n && (i = aP(n));
          var a = new Tn({
            shape: {
              points: i || []
            },
            silent: true
          });
          return ni(r, a), zn(e, a, this._defsUsePending, false, false), a;
        },
        image: function(e, r) {
          var n = new Gr();
          return ni(r, n), zn(e, n, this._defsUsePending, false, false), n.setStyle({
            image: e.getAttribute("xlink:href") || e.getAttribute("href"),
            x: +e.getAttribute("x"),
            y: +e.getAttribute("y"),
            width: +e.getAttribute("width"),
            height: +e.getAttribute("height")
          }), n.silent = true, n;
        },
        text: function(e, r) {
          var n = e.getAttribute("x") || "0", i = e.getAttribute("y") || "0", a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0";
          this._textX = parseFloat(n) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(o);
          var s = new Be();
          return ni(r, s), zn(e, s, this._defsUsePending, false, true), s;
        },
        tspan: function(e, r) {
          var n = e.getAttribute("x"), i = e.getAttribute("y");
          n != null && (this._textX = parseFloat(n)), i != null && (this._textY = parseFloat(i));
          var a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0", s = new Be();
          return ni(r, s), zn(e, s, this._defsUsePending, false, true), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
        },
        path: function(e, r) {
          var n = e.getAttribute("d") || "", i = z4(n);
          return ni(r, i), zn(e, i, this._defsUsePending, false, false), i.silent = true, i;
        }
      };
    }(), t;
  }(), rP = {
    lineargradient: function(t) {
      var e = parseInt(t.getAttribute("x1") || "0", 10), r = parseInt(t.getAttribute("y1") || "0", 10), n = parseInt(t.getAttribute("x2") || "10", 10), i = parseInt(t.getAttribute("y2") || "0", 10), a = new $d(e, r, n, i);
      return nP(t, a), iP(t, a), a;
    },
    radialgradient: function(t) {
      var e = parseInt(t.getAttribute("cx") || "0", 10), r = parseInt(t.getAttribute("cy") || "0", 10), n = parseInt(t.getAttribute("r") || "0", 10), i = new W4(e, r, n);
      return nP(t, i), iP(t, i), i;
    }
  };
  function nP(t, e) {
    var r = t.getAttribute("gradientUnits");
    r === "userSpaceOnUse" && (e.global = true);
  }
  function iP(t, e) {
    for (var r = t.firstChild; r; ) {
      if (r.nodeType === 1 && r.nodeName.toLocaleLowerCase() === "stop") {
        var n = r.getAttribute("offset"), i = void 0;
        n && n.indexOf("%") > 0 ? i = parseInt(n, 10) / 100 : n ? i = parseFloat(n) : i = 0;
        var a = {};
        KG(r, a, a);
        var o = a.stopColor || r.getAttribute("stop-color") || "#000000";
        e.colorStops.push({
          offset: i,
          color: o
        });
      }
      r = r.nextSibling;
    }
  }
  function ni(t, e) {
    t && t.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), Ee(e.__inheritedStyle, t.__inheritedStyle));
  }
  function aP(t) {
    for (var e = vy(t), r = [], n = 0; n < e.length; n += 2) {
      var i = parseFloat(e[n]), a = parseFloat(e[n + 1]);
      r.push([
        i,
        a
      ]);
    }
    return r;
  }
  function zn(t, e, r, n, i) {
    var a = e, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
    t.nodeType === 1 && (rse(t, e), KG(t, o, s), n || nse(t, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = oP(a, "fill", o.fill, r)), o.stroke != null && (a.style.stroke = oP(a, "stroke", o.stroke, r)), $([
      "lineWidth",
      "opacity",
      "fillOpacity",
      "strokeOpacity",
      "miterLimit",
      "fontSize"
    ], function(l) {
      o[l] != null && (a.style[l] = parseFloat(o[l]));
    }), $([
      "lineDashOffset",
      "lineCap",
      "lineJoin",
      "fontWeight",
      "fontFamily",
      "fontStyle",
      "textAlign"
    ], function(l) {
      o[l] != null && (a.style[l] = o[l]);
    }), i && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = oe(vy(o.lineDash), function(l) {
      return parseFloat(l);
    })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = true), o.display === "none" && (a.ignore = true);
  }
  function Zoe(t, e) {
    var r = e.__selfStyle;
    if (r) {
      var n = r.textBaseline, i = n;
      !n || n === "auto" || n === "baseline" ? i = "alphabetic" : n === "before-edge" || n === "text-before-edge" ? i = "top" : n === "after-edge" || n === "text-after-edge" ? i = "bottom" : (n === "central" || n === "mathematical") && (i = "middle"), t.style.textBaseline = i;
    }
    var a = e.__inheritedStyle;
    if (a) {
      var o = a.textAlign, s = o;
      o && (o === "middle" && (s = "center"), t.style.textAlign = s);
    }
  }
  var Qoe = /^url\(\s*#(.*?)\)/;
  function oP(t, e, r, n) {
    var i = r && r.match(Qoe);
    if (i) {
      var a = Vi(i[1]);
      n.push([
        t,
        e,
        a
      ]);
      return;
    }
    return r === "none" && (r = null), r;
  }
  function Joe(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n[0].style[n[1]] = t[n[2]];
    }
  }
  var ese = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function vy(t) {
    return t.match(ese) || [];
  }
  var tse = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, y_ = Math.PI / 180;
  function rse(t, e) {
    var r = t.getAttribute("transform");
    if (r) {
      r = r.replace(/,/g, " ");
      var n = [], i = null;
      r.replace(tse, function(h, f, d) {
        return n.push(f, d), "";
      });
      for (var a = n.length - 1; a > 0; a -= 2) {
        var o = n[a], s = n[a - 1], l = vy(o);
        switch (i = i || Hn(), s) {
          case "translate":
            Pa(i, i, [
              parseFloat(l[0]),
              parseFloat(l[1] || "0")
            ]);
            break;
          case "scale":
            QS(i, i, [
              parseFloat(l[0]),
              parseFloat(l[1] || l[0])
            ]);
            break;
          case "rotate":
            nu(i, i, -parseFloat(l[0]) * y_, [
              parseFloat(l[1] || "0"),
              parseFloat(l[2] || "0")
            ]);
            break;
          case "skewX":
            var u = Math.tan(parseFloat(l[0]) * y_);
            io(i, [
              1,
              0,
              u,
              1,
              0,
              0
            ], i);
            break;
          case "skewY":
            var c = Math.tan(parseFloat(l[0]) * y_);
            io(i, [
              1,
              c,
              0,
              1,
              0,
              0
            ], i);
            break;
          case "matrix":
            i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
            break;
        }
      }
      e.setLocalTransform(i);
    }
  }
  var sP = /([^\s:;]+)\s*:\s*([^:;]+)/g;
  function KG(t, e, r) {
    var n = t.getAttribute("style");
    if (n) {
      sP.lastIndex = 0;
      for (var i; (i = sP.exec(n)) != null; ) {
        var a = i[1], o = xe(Zg, a) ? Zg[a] : null;
        o && (e[o] = i[2]);
        var s = xe(Qg, a) ? Qg[a] : null;
        s && (r[s] = i[2]);
      }
    }
  }
  function nse(t, e, r) {
    for (var n = 0; n < eP.length; n++) {
      var i = eP[n], a = t.getAttribute(i);
      a != null && (e[Zg[i]] = a);
    }
    for (var n = 0; n < tP.length; n++) {
      var i = tP[n], a = t.getAttribute(i);
      a != null && (r[Qg[i]] = a);
    }
  }
  function ZG(t, e) {
    var r = e.width / t.width, n = e.height / t.height, i = Math.min(r, n);
    return {
      scale: i,
      x: -(t.x + t.width / 2) * i + (e.x + e.width / 2),
      y: -(t.y + t.height / 2) * i + (e.y + e.height / 2)
    };
  }
  function ise(t, e) {
    var r = new Koe();
    return r.parse(t, e);
  }
  var ase = Ce([
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path",
    "text",
    "tspan",
    "g"
  ]), ose = function() {
    function t(e, r) {
      this.type = "geoSVG", this._usedGraphicMap = Ce(), this._freedGraphics = [], this._mapName = e, this._parsedXML = jG(r);
    }
    return t.prototype.load = function() {
      var e = this._firstGraphic;
      if (!e) {
        e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var r = lse(e.named), n = r.regions, i = r.regionsMap;
        this._regions = n, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, t.prototype._buildGraphic = function(e) {
      var r, n;
      try {
        r = e && ise(e, {
          ignoreViewBox: true,
          ignoreRootClip: true
        }) || {}, n = r.root, bn(n != null);
      } catch (g) {
        throw new Error(`Invalid svg format
` + g.message);
      }
      var i = new Be();
      i.add(n), i.isGeoSVGGraphicRoot = true;
      var a = r.width, o = r.height, s = r.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, h = void 0, f = void 0;
        if (a != null ? (u = 0, h = a) : s && (u = s.x, h = s.width), o != null ? (c = 0, f = o) : s && (c = s.y, f = s.height), u == null || c == null) {
          var d = n.getBoundingRect();
          u == null && (u = d.x, h = d.width), c == null && (c = d.y, f = d.height);
        }
        l = this._boundingRect = new Ze(u, c, h, f);
      }
      if (s) {
        var p = ZG(s, l);
        n.scaleX = n.scaleY = p.scale, n.x = p.x, n.y = p.y;
      }
      i.setClipPath(new yt({
        shape: l.plain()
      }));
      var v = [];
      return $(r.named, function(g) {
        ase.get(g.svgNodeTagLower) != null && (v.push(g), sse(g.el));
      }), {
        root: i,
        boundingRect: l,
        named: v
      };
    }, t.prototype.useGraphic = function(e) {
      var r = this._usedGraphicMap, n = r.get(e);
      return n || (n = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), r.set(e, n), n);
    }, t.prototype.freeGraphic = function(e) {
      var r = this._usedGraphicMap, n = r.get(e);
      n && (r.removeKey(e), this._freedGraphics.push(n));
    }, t;
  }();
  function sse(t) {
    t.silent = false, t.isGroup && t.traverse(function(e) {
      e.silent = false;
    });
  }
  function lse(t) {
    var e = [], r = Ce();
    return $(t, function(n) {
      if (n.namedFrom == null) {
        var i = new rie(n.name, n.el);
        e.push(i), r.set(n.name, i);
      }
    }), {
      regions: e,
      regionsMap: r
    };
  }
  var uw = [
    126,
    25
  ], lP = "\u5357\u6D77\u8BF8\u5C9B", ol = [
    [
      [
        0,
        3.5
      ],
      [
        7,
        11.2
      ],
      [
        15,
        11.9
      ],
      [
        30,
        7
      ],
      [
        42,
        0.7
      ],
      [
        52,
        0.7
      ],
      [
        56,
        7.7
      ],
      [
        59,
        0.7
      ],
      [
        64,
        0.7
      ],
      [
        64,
        0
      ],
      [
        5,
        0
      ],
      [
        0,
        3.5
      ]
    ],
    [
      [
        13,
        16.1
      ],
      [
        19,
        14.7
      ],
      [
        16,
        21.7
      ],
      [
        11,
        23.1
      ],
      [
        13,
        16.1
      ]
    ],
    [
      [
        12,
        32.2
      ],
      [
        14,
        38.5
      ],
      [
        15,
        38.5
      ],
      [
        13,
        32.2
      ],
      [
        12,
        32.2
      ]
    ],
    [
      [
        16,
        47.6
      ],
      [
        12,
        53.2
      ],
      [
        13,
        53.2
      ],
      [
        18,
        47.6
      ],
      [
        16,
        47.6
      ]
    ],
    [
      [
        6,
        64.4
      ],
      [
        8,
        70
      ],
      [
        9,
        70
      ],
      [
        8,
        64.4
      ],
      [
        6,
        64.4
      ]
    ],
    [
      [
        23,
        82.6
      ],
      [
        29,
        79.8
      ],
      [
        30,
        79.8
      ],
      [
        25,
        82.6
      ],
      [
        23,
        82.6
      ]
    ],
    [
      [
        37,
        70.7
      ],
      [
        43,
        62.3
      ],
      [
        44,
        62.3
      ],
      [
        39,
        70.7
      ],
      [
        37,
        70.7
      ]
    ],
    [
      [
        48,
        51.1
      ],
      [
        51,
        45.5
      ],
      [
        53,
        45.5
      ],
      [
        50,
        51.1
      ],
      [
        48,
        51.1
      ]
    ],
    [
      [
        51,
        35
      ],
      [
        51,
        28.7
      ],
      [
        53,
        28.7
      ],
      [
        53,
        35
      ],
      [
        51,
        35
      ]
    ],
    [
      [
        52,
        22.4
      ],
      [
        55,
        17.5
      ],
      [
        56,
        17.5
      ],
      [
        53,
        22.4
      ],
      [
        52,
        22.4
      ]
    ],
    [
      [
        58,
        12.6
      ],
      [
        62,
        7
      ],
      [
        63,
        7
      ],
      [
        60,
        12.6
      ],
      [
        58,
        12.6
      ]
    ],
    [
      [
        0,
        3.5
      ],
      [
        0,
        93.1
      ],
      [
        64,
        93.1
      ],
      [
        64,
        0
      ],
      [
        63,
        0
      ],
      [
        63,
        92.4
      ],
      [
        1,
        92.4
      ],
      [
        1,
        3.5
      ],
      [
        0,
        3.5
      ]
    ]
  ];
  for (var Ks = 0; Ks < ol.length; Ks++) for (var Eu = 0; Eu < ol[Ks].length; Eu++) ol[Ks][Eu][0] /= 10.5, ol[Ks][Eu][1] /= -10.5 / 0.75, ol[Ks][Eu][0] += uw[0], ol[Ks][Eu][1] += uw[1];
  function use(t, e) {
    if (t === "china") {
      for (var r = 0; r < e.length; r++) if (e[r].name === lP) return;
      e.push(new q5(lP, oe(ol, function(n) {
        return {
          type: "polygon",
          exterior: n
        };
      }), uw));
    }
  }
  var cse = {
    \u5357\u6D77\u8BF8\u5C9B: [
      32,
      80
    ],
    \u5E7F\u4E1C: [
      0,
      -10
    ],
    \u9999\u6E2F: [
      10,
      5
    ],
    \u6FB3\u95E8: [
      -10,
      10
    ],
    \u5929\u6D25: [
      5,
      5
    ]
  };
  function hse(t, e) {
    if (t === "china") {
      var r = cse[e.name];
      if (r) {
        var n = e.getCenter();
        n[0] += r[0] / 10.5, n[1] += -r[1] / (10.5 / 0.75), e.setCenter(n);
      }
    }
  }
  var fse = [
    [
      [
        123.45165252685547,
        25.73527164402261
      ],
      [
        123.49731445312499,
        25.73527164402261
      ],
      [
        123.49731445312499,
        25.750734064600884
      ],
      [
        123.45165252685547,
        25.750734064600884
      ],
      [
        123.45165252685547,
        25.73527164402261
      ]
    ]
  ];
  function dse(t, e) {
    t === "china" && e.name === "\u53F0\u6E7E" && e.geometries.push({
      type: "polygon",
      exterior: fse[0]
    });
  }
  var pse = "name", vse = function() {
    function t(e, r, n) {
      this.type = "geoJSON", this._parsedMap = Ce(), this._mapName = e, this._specialAreas = n, this._geoJSON = mse(r);
    }
    return t.prototype.load = function(e, r) {
      r = r || pse;
      var n = this._parsedMap.get(r);
      if (!n) {
        var i = this._parseToRegions(r);
        n = this._parsedMap.set(r, {
          regions: i,
          boundingRect: gse(i)
        });
      }
      var a = Ce(), o = [];
      return $(n.regions, function(s) {
        var l = s.name;
        e && xe(e, l) && (s = s.cloneShallow(l = e[l])), o.push(s), a.set(l, s);
      }), {
        regions: o,
        boundingRect: n.boundingRect || new Ze(0, 0, 0, 0),
        regionsMap: a
      };
    }, t.prototype._parseToRegions = function(e) {
      var r = this._mapName, n = this._geoJSON, i;
      try {
        i = n ? iie(n, e) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return use(r, i), $(i, function(a) {
        var o = a.name;
        hse(r, a), dse(r, a);
        var s = this._specialAreas && this._specialAreas[o];
        s && a.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, t.prototype.getMapForUser = function() {
      return {
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, t;
  }();
  function gse(t) {
    for (var e, r = 0; r < t.length; r++) {
      var n = t[r].getBoundingRect();
      e = e || n.clone(), e.union(n);
    }
    return e;
  }
  function mse(t) {
    return me(t) ? typeof JSON < "u" && JSON.parse ? JSON.parse(t) : new Function("return (" + t + ");")() : t;
  }
  var Ch = Ce();
  const mo = {
    registerMap: function(t, e, r) {
      if (e.svg) {
        var n = new ose(t, e.svg);
        Ch.set(t, n);
      } else {
        var i = e.geoJson || e.geoJSON;
        i && !e.features ? r = e.specialAreas : i = e;
        var n = new vse(t, i, r);
        Ch.set(t, n);
      }
    },
    getGeoResource: function(t) {
      return Ch.get(t);
    },
    getMapForUser: function(t) {
      var e = Ch.get(t);
      return e && e.type === "geoJSON" && e.getMapForUser();
    },
    load: function(t, e, r) {
      var n = Ch.get(t);
      if (n) return n.load(e, r);
    }
  };
  var i2 = [
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path"
  ], yse = Ce(i2), _se = Ce(i2.concat([
    "g"
  ])), bse = Ce(i2.concat([
    "g"
  ])), QG = _t();
  function Qp(t) {
    var e = t.getItemStyle(), r = t.get("areaColor");
    return r != null && (e.fill = r), e;
  }
  function uP(t) {
    var e = t.style;
    e && (e.stroke = e.stroke || e.fill, e.fill = null);
  }
  var JG = function() {
    function t(e) {
      var r = new Be();
      this.uid = Hc("ec_map_draw"), this._controller = new qd(e.getZr()), this._controllerHost = {
        target: r
      }, this.group = r, r.add(this._regionsGroup = new Be()), r.add(this._svgGroup = new Be());
    }
    return t.prototype.draw = function(e, r, n, i, a) {
      var o = e.mainType === "geo", s = e.getData && e.getData();
      o && r.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(m) {
        !s && m.getHostGeoModel() === e && (s = m.getData());
      });
      var l = e.coordinateSystem, u = this._regionsGroup, c = this.group, h = l.getTransformInfo(), f = h.raw, d = h.roam, p = !u.childAt(0) || a;
      p ? (c.x = d.x, c.y = d.y, c.scaleX = d.scaleX, c.scaleY = d.scaleY, c.dirty()) : wt(c, d, e);
      var v = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, g = {
        api: n,
        geo: l,
        mapOrGeoModel: e,
        data: s,
        isVisualEncodedByVisualMap: v,
        isGeo: o,
        transformInfoRaw: f
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(g) : l.resourceType === "geoSVG" && this._buildSVG(g), this._updateController(e, r, n), this._updateMapSelectHandler(e, u, n, i);
    }, t.prototype._buildGeoJSON = function(e) {
      var r = this._regionsGroupByName = Ce(), n = Ce(), i = this._regionsGroup, a = e.transformInfoRaw, o = e.mapOrGeoModel, s = e.data, l = e.geo.projection, u = l && l.stream;
      function c(d, p) {
        return p && (d = p(d)), d && [
          d[0] * a.scaleX + a.x,
          d[1] * a.scaleY + a.y
        ];
      }
      function h(d) {
        for (var p = [], v = !u && l && l.project, g = 0; g < d.length; ++g) {
          var m = c(d[g], v);
          m && p.push(m);
        }
        return p;
      }
      function f(d) {
        return {
          shape: {
            points: h(d)
          }
        };
      }
      i.removeAll(), $(e.geo.regions, function(d) {
        var p = d.name, v = r.get(p), g = n.get(p) || {}, m = g.dataIdx, y = g.regionModel;
        if (!v) {
          v = r.set(p, new Be()), i.add(v), m = s ? s.indexOfName(p) : null, y = e.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(m) : null;
          var _ = y.get("silent", true);
          _ != null && (v.silent = _), n.set(p, {
            dataIdx: m,
            regionModel: y
          });
        }
        var b = [], w = [];
        $(d.geometries, function(A) {
          if (A.type === "polygon") {
            var I = [
              A.exterior
            ].concat(A.interiors || []);
            u && (I = vP(I, u)), $(I, function(k) {
              b.push(new Sn(f(k)));
            });
          } else {
            var M = A.points;
            u && (M = vP(M, u, true)), $(M, function(k) {
              w.push(new Tn(f(k)));
            });
          }
        });
        var x = c(d.getCenter(), l && l.project);
        function T(A, I) {
          if (A.length) {
            var M = new pT({
              culling: true,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: A
              }
            });
            v.add(M), cP(e, M, m, y), hP(e, M, p, y, o, m, x), I && (uP(M), $(M.states, uP));
          }
        }
        T(b), T(w, true);
      }), r.each(function(d, p) {
        var v = n.get(p), g = v.dataIdx, m = v.regionModel;
        fP(e, d, p, m, o, g), dP(e, d, p, m, o), pP(e, d, p, m, o);
      }, this);
    }, t.prototype._buildSVG = function(e) {
      var r = e.geo.map, n = e.transformInfoRaw;
      this._svgGroup.x = n.x, this._svgGroup.y = n.y, this._svgGroup.scaleX = n.scaleX, this._svgGroup.scaleY = n.scaleY, this._svgResourceChanged(r) && (this._freeSVG(), this._useSVG(r));
      var i = this._svgDispatcherMap = Ce(), a = false;
      $(this._svgGraphicRecord.named, function(o) {
        var s = o.name, l = e.mapOrGeoModel, u = e.data, c = o.svgNodeTagLower, h = o.el, f = u ? u.indexOfName(s) : null, d = l.getRegionModel(s);
        yse.get(c) != null && h instanceof bi && cP(e, h, f, d), h instanceof bi && (h.culling = true);
        var p = d.get("silent", true);
        if (p != null && (h.silent = p), h.z2EmphasisLift = 0, !o.namedFrom && (bse.get(c) != null && hP(e, h, s, d, l, f, null), fP(e, h, s, d, l, f), dP(e, h, s, d, l), _se.get(c) != null)) {
          var v = pP(e, h, s, d, l);
          v === "self" && (a = true);
          var g = i.get(s) || i.set(s, []);
          g.push(h);
        }
      }, this), this._enableBlurEntireSVG(a, e);
    }, t.prototype._enableBlurEntireSVG = function(e, r) {
      if (e && r.isGeo) {
        var n = r.mapOrGeoModel.getModel([
          "blur",
          "itemStyle"
        ]).getItemStyle(), i = n.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            Xl(a);
            var o = a.ensureState("blur").style || {};
            o.opacity == null && i != null && (o.opacity = i), a.ensureState("emphasis");
          }
        });
      }
    }, t.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, t.prototype.findHighDownDispatchers = function(e, r) {
      if (e == null) return [];
      var n = r.coordinateSystem;
      if (n.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var a = i.get(e);
          return a ? [
            a
          ] : [];
        }
      } else if (n.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [];
    }, t.prototype._svgResourceChanged = function(e) {
      return this._svgMapName !== e;
    }, t.prototype._useSVG = function(e) {
      var r = mo.getGeoResource(e);
      if (r && r.type === "geoSVG") {
        var n = r.useGraphic(this.uid);
        this._svgGroup.add(n.root), this._svgGraphicRecord = n, this._svgMapName = e;
      }
    }, t.prototype._freeSVG = function() {
      var e = this._svgMapName;
      if (e != null) {
        var r = mo.getGeoResource(e);
        r && r.type === "geoSVG" && r.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, t.prototype._updateController = function(e, r, n) {
      var i = e.coordinateSystem, a = this._controller, o = this._controllerHost;
      o.zoomLimit = e.get("scaleLimit"), o.zoom = i.getZoom(), a.enable(e.get("roam") || false);
      var s = e.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = e.id, u;
      }
      a.off("pan").on("pan", function(u) {
        this._mouseDownFlag = false, r2(o, u.dx, u.dy), n.dispatchAction(te(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), a.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = false, n2(o, u.scale, u.originX, u.originY), n.dispatchAction(te(l(), {
          totalZoom: o.zoom,
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), a.setPointerChecker(function(u, c, h) {
        return i.containPoint([
          c,
          h
        ]) && !py(u, n, e);
      });
    }, t.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(e) {
        var r = e.getTextContent();
        r && (r.ignore = QG(r).ignore);
      });
    }, t.prototype._updateMapSelectHandler = function(e, r, n, i) {
      var a = this;
      r.off("mousedown"), r.off("click"), e.get("selectedMode") && (r.on("mousedown", function() {
        a._mouseDownFlag = true;
      }), r.on("click", function(o) {
        a._mouseDownFlag && (a._mouseDownFlag = false);
      }));
    }, t;
  }();
  function cP(t, e, r, n) {
    var i = n.getModel("itemStyle"), a = n.getModel([
      "emphasis",
      "itemStyle"
    ]), o = n.getModel([
      "blur",
      "itemStyle"
    ]), s = n.getModel([
      "select",
      "itemStyle"
    ]), l = Qp(i), u = Qp(a), c = Qp(s), h = Qp(o), f = t.data;
    if (f) {
      var d = f.getItemVisual(r, "style"), p = f.getItemVisual(r, "decal");
      t.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill), p && (l.decal = bc(p, t.api));
    }
    e.setStyle(l), e.style.strokeNoScale = true, e.ensureState("emphasis").style = u, e.ensureState("select").style = c, e.ensureState("blur").style = h, Xl(e);
  }
  function hP(t, e, r, n, i, a, o) {
    var s = t.data, l = t.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), c = s && s.getItemLayout(a);
    if (l || u || c && c.showLabel) {
      var h = l ? r : a, f = void 0;
      (!s || a >= 0) && (f = i);
      var d = o ? {
        normal: {
          align: "center",
          verticalAlign: "middle"
        }
      } : null;
      Xr(e, Lr(n), {
        labelFetcher: f,
        labelDataIndex: h,
        defaultText: r
      }, d);
      var p = e.getTextContent();
      if (p && (QG(p).ignore = p.ignore, e.textConfig && o)) {
        var v = e.getBoundingRect().clone();
        e.textConfig.layoutRect = v, e.textConfig.position = [
          (o[0] - v.x) / v.width * 100 + "%",
          (o[1] - v.y) / v.height * 100 + "%"
        ];
      }
      e.disableLabelAnimation = true;
    } else e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null;
  }
  function fP(t, e, r, n, i, a) {
    t.data ? t.data.setItemGraphicEl(a, e) : Ge(e).eventData = {
      componentType: "geo",
      componentIndex: i.componentIndex,
      geoIndex: i.componentIndex,
      name: r,
      region: n && n.option || {}
    };
  }
  function dP(t, e, r, n, i) {
    t.data || iu({
      el: e,
      componentModel: i,
      itemName: r,
      itemTooltipOption: n.get("tooltip")
    });
  }
  function pP(t, e, r, n, i) {
    e.highDownSilentOnTouch = !!i.get("selectedMode");
    var a = n.getModel("emphasis"), o = a.get("focus");
    return ir(e, o, a.get("blurScope"), a.get("disabled")), t.isGeo && mJ(e, i, r), o;
  }
  function vP(t, e, r) {
    var n = [], i;
    function a() {
      i = [];
    }
    function o() {
      i.length && (n.push(i), i = []);
    }
    var s = e({
      polygonStart: a,
      polygonEnd: o,
      lineStart: a,
      lineEnd: o,
      point: function(l, u) {
        isFinite(l) && isFinite(u) && i.push([
          l,
          u
        ]);
      },
      sphere: function() {
      }
    });
    return !r && s.polygonStart(), $(t, function(l) {
      s.lineStart();
      for (var u = 0; u < l.length; u++) s.point(l[u][0], l[u][1]);
      s.lineEnd();
    }), !r && s.polygonEnd(), n;
  }
  var xse = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var o = this.group;
        if (o.removeAll(), !r.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === r.id) {
            var s = this._mapDraw;
            s && o.add(s.group);
          } else if (r.needsDrawMap) {
            var s = this._mapDraw || new JG(i);
            o.add(s.group), s.draw(r, n, i, this, a), this._mapDraw = s;
          } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          r.get("showLegendSymbol") && n.getComponent("legend") && this._renderSymbols(r, n, i);
        }
      }
    }, e.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, e.prototype._renderSymbols = function(r, n, i) {
      var a = r.originalData, o = this.group;
      a.each(a.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, h = u.offset, f = new wo({
              style: {
                fill: r.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + h * 9,
                cy: c[1],
                r: 3
              },
              silent: true,
              z2: 8 + (h ? 0 : Vc + 1)
            });
            if (!h) {
              var d = r.mainSeries.getData(), p = a.getName(l), v = d.indexOfName(p), g = a.getItemModel(l), m = g.getModel("label"), y = d.getItemGraphicEl(v);
              Xr(f, Lr(g), {
                labelFetcher: {
                  getFormattedLabel: function(_, b) {
                    return r.getFormattedLabel(v, b);
                  }
                },
                defaultText: p
              }), f.disableLabelAnimation = true, m.get("position") || f.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(_) {
                kg(f, _);
              };
            }
            o.add(f);
          }
        }
      });
    }, e.type = "map", e;
  }(Ft), wse = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.needsDrawMap = false, r.seriesGroup = [], r.getTooltipPosition = function(n) {
        if (n != null) {
          var i = this.getData().getName(n), a = this.coordinateSystem, o = a.getRegion(i);
          return o && a.dataToPoint(o.getCenter());
        }
      }, r;
    }
    return e.prototype.getInitialData = function(r) {
      for (var n = Qc(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: Ye(TT, this)
      }), i = Ce(), a = [], o = 0, s = n.count(); o < s; o++) {
        var l = n.getName(o);
        i.set(l, o);
      }
      var u = mo.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return $(u.regions, function(c) {
        var h = c.name, f = i.get(h), d = c.properties && c.properties.echartsStyle, p;
        f == null ? (p = {
          name: h
        }, a.push(p)) : p = n.getRawDataItem(f), d && je(p, d);
      }), n.appendData(a), n;
    }, e.prototype.getHostGeoModel = function() {
      var r = this.option.geoIndex;
      return r != null ? this.ecModel.getComponent("geo", r) : null;
    }, e.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, e.prototype.getRawValue = function(r) {
      var n = this.getData();
      return n.get(n.mapDimension("value"), r);
    }, e.prototype.getRegionModel = function(r) {
      var n = this.getData();
      return n.getItemModel(n.indexOfName(r));
    }, e.prototype.formatTooltip = function(r, n, i) {
      for (var a = this.getData(), o = this.getRawValue(r), s = a.getName(r), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var h = l[c].originalData.indexOfName(s), f = a.mapDimension("value");
        isNaN(l[c].originalData.get(f, h)) || u.push(l[c].name);
      }
      return $r("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [
          $r("nameValue", {
            name: s,
            value: o
          })
        ]
      });
    }, e.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, e.prototype.setCenter = function(r) {
      this.option.center = r;
    }, e.prototype.getLegendIcon = function(r) {
      var n = r.icon || "roundRect", i = mr(n, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill);
      return i.setStyle(r.itemStyle), i.style.stroke = "none", n.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, e.type = "series.map", e.dependencies = [
      "geo"
    ], e.layoutMode = "box", e.defaultOption = {
      z: 2,
      coordinateSystem: "geo",
      map: "",
      left: "center",
      top: "center",
      aspectScale: null,
      showLegendSymbol: true,
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: true,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, e;
  }(Xt);
  function Sse(t, e) {
    var r = {};
    return $(t, function(n) {
      n.each(n.mapDimension("value"), function(i, a) {
        var o = "ec-" + n.getName(a);
        r[o] = r[o] || [], isNaN(i) || r[o].push(i);
      });
    }), t[0].map(t[0].mapDimension("value"), function(n, i) {
      for (var a = "ec-" + t[0].getName(i), o = 0, s = 1 / 0, l = -1 / 0, u = r[a].length, c = 0; c < u; c++) s = Math.min(s, r[a][c]), l = Math.max(l, r[a][c]), o += r[a][c];
      var h;
      return e === "min" ? h = s : e === "max" ? h = l : e === "average" ? h = o / u : h = o, u === 0 ? NaN : h;
    });
  }
  function Tse(t) {
    var e = {};
    t.eachSeriesByType("map", function(r) {
      var n = r.getHostGeoModel(), i = n ? "o" + n.id : "i" + r.getMapType();
      (e[i] = e[i] || []).push(r);
    }), $(e, function(r, n) {
      for (var i = Sse(oe(r, function(o) {
        return o.getData();
      }), r[0].get("mapValueCalculation")), a = 0; a < r.length; a++) r[a].originalData = r[a].getData();
      for (var a = 0; a < r.length; a++) r[a].seriesGroup = r, r[a].needsDrawMap = a === 0 && !r[a].getHostGeoModel(), r[a].setData(i.cloneShallow()), r[a].mainSeries = r[0];
    });
  }
  function Cse(t) {
    var e = {};
    t.eachSeriesByType("map", function(r) {
      var n = r.getMapType();
      if (!(r.getHostGeoModel() || e[n])) {
        var i = {};
        $(r.seriesGroup, function(o) {
          var s = o.coordinateSystem, l = o.originalData;
          o.get("showLegendSymbol") && t.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
            var h = l.getName(c), f = s.getRegion(h);
            if (!(!f || isNaN(u))) {
              var d = i[h] || 0, p = s.dataToPoint(f.getCenter());
              i[h] = d + 1, l.setItemLayout(c, {
                point: p,
                offset: d
              });
            }
          });
        });
        var a = r.getData();
        a.each(function(o) {
          var s = a.getName(o), l = a.getItemLayout(o) || {};
          l.showLabel = !i[s], a.setItemLayout(o, l);
        }), e[n] = true;
      }
    });
  }
  var gP = Ur, Xd = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this) || this;
      return n.type = "view", n.dimensions = [
        "x",
        "y"
      ], n._roamTransformable = new Qa(), n._rawTransformable = new Qa(), n.name = r, n;
    }
    return e.prototype.setBoundingRect = function(r, n, i, a) {
      return this._rect = new Ze(r, n, i, a), this._rect;
    }, e.prototype.getBoundingRect = function() {
      return this._rect;
    }, e.prototype.setViewRect = function(r, n, i, a) {
      this._transformTo(r, n, i, a), this._viewRect = new Ze(r, n, i, a);
    }, e.prototype._transformTo = function(r, n, i, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new Ze(r, n, i, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, e.prototype.setCenter = function(r, n) {
      r && (this._center = [
        pe(r[0], n.getWidth()),
        pe(r[1], n.getHeight())
      ], this._updateCenterAndZoom());
    }, e.prototype.setZoom = function(r) {
      r = r || 1;
      var n = this.zoomLimit;
      n && (n.max != null && (r = Math.min(n.max, r)), n.min != null && (r = Math.max(n.min, r))), this._zoom = r, this._updateCenterAndZoom();
    }, e.prototype.getDefaultCenter = function() {
      var r = this.getBoundingRect(), n = r.x + r.width / 2, i = r.y + r.height / 2;
      return [
        n,
        i
      ];
    }, e.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, e.prototype.getZoom = function() {
      return this._zoom || 1;
    }, e.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, e.prototype._updateCenterAndZoom = function() {
      var r = this._rawTransformable.getLocalTransform(), n = this._roamTransformable, i = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
      a = Ur([], a, r), i = Ur([], i, r), n.originX = a[0], n.originY = a[1], n.x = i[0] - a[0], n.y = i[1] - a[1], n.scaleX = n.scaleY = o, this._updateTransform();
    }, e.prototype._updateTransform = function() {
      var r = this._roamTransformable, n = this._rawTransformable;
      n.parent = r, r.updateTransform(), n.updateTransform(), ZS(this.transform || (this.transform = []), n.transform || Hn()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], zc(this.invTransform, this.transform), this.decomposeTransform();
    }, e.prototype.getTransformInfo = function() {
      var r = this._rawTransformable, n = this._roamTransformable, i = new Qa();
      return i.transform = n.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: r.x,
          y: r.y,
          scaleX: r.scaleX,
          scaleY: r.scaleY
        }
      };
    }, e.prototype.getViewRect = function() {
      return this._viewRect;
    }, e.prototype.getViewRectAfterRoam = function() {
      var r = this.getBoundingRect().clone();
      return r.applyTransform(this.transform), r;
    }, e.prototype.dataToPoint = function(r, n, i) {
      var a = n ? this._rawTransform : this.transform;
      return i = i || [], a ? gP(i, r, a) : fn(i, r);
    }, e.prototype.pointToData = function(r) {
      var n = this.invTransform;
      return n ? gP([], r, n) : [
        r[0],
        r[1]
      ];
    }, e.prototype.convertToPixel = function(r, n, i) {
      var a = mP(n);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(r, n, i) {
      var a = mP(n);
      return a === this ? a.pointToData(i) : null;
    }, e.prototype.containPoint = function(r) {
      return this.getViewRectAfterRoam().contain(r[0], r[1]);
    }, e.dimensions = [
      "x",
      "y"
    ], e;
  }(Qa);
  function mP(t) {
    var e = t.seriesModel;
    return e ? e.coordinateSystem : null;
  }
  var Ase = {
    geoJSON: {
      aspectScale: 0.75,
      invertLongitute: true
    },
    geoSVG: {
      aspectScale: 1,
      invertLongitute: false
    }
  }, eW = [
    "lng",
    "lat"
  ], cw = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this, r) || this;
      a.dimensions = eW, a.type = "geo", a._nameCoordMap = Ce(), a.map = n;
      var o = i.projection, s = mo.load(n, i.nameMap, i.nameProperty), l = mo.getGeoResource(n);
      a.resourceType = l ? l.type : null;
      var u = a.regions = s.regions, c = Ase[l.type];
      a._regionsMap = s.regionsMap, a.regions = s.regions, a.projection = o;
      var h;
      if (o) for (var f = 0; f < u.length; f++) {
        var d = u[f].getBoundingRect(o);
        h = h || d.clone(), h.union(d);
      }
      else h = s.boundingRect;
      return a.setBoundingRect(h.x, h.y, h.width, h.height), a.aspectScale = o ? 1 : We(i.aspectScale, c.aspectScale), a._invertLongitute = o ? false : c.invertLongitute, a;
    }
    return e.prototype._transformTo = function(r, n, i, a) {
      var o = this.getBoundingRect(), s = this._invertLongitute;
      o = o.clone(), s && (o.y = -o.y - o.height);
      var l = this._rawTransformable;
      l.transform = o.calculateTransform(new Ze(r, n, i, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, e.prototype.getRegion = function(r) {
      return this._regionsMap.get(r);
    }, e.prototype.getRegionByCoord = function(r) {
      for (var n = this.regions, i = 0; i < n.length; i++) {
        var a = n[i];
        if (a.type === "geoJSON" && a.contain(r)) return n[i];
      }
    }, e.prototype.addGeoCoord = function(r, n) {
      this._nameCoordMap.set(r, n);
    }, e.prototype.getGeoCoord = function(r) {
      var n = this._regionsMap.get(r);
      return this._nameCoordMap.get(r) || n && n.getCenter();
    }, e.prototype.dataToPoint = function(r, n, i) {
      if (me(r) && (r = this.getGeoCoord(r)), r) {
        var a = this.projection;
        return a && (r = a.project(r)), r && this.projectedToPoint(r, n, i);
      }
    }, e.prototype.pointToData = function(r) {
      var n = this.projection;
      return n && (r = n.unproject(r)), r && this.pointToProjected(r);
    }, e.prototype.pointToProjected = function(r) {
      return t.prototype.pointToData.call(this, r);
    }, e.prototype.projectedToPoint = function(r, n, i) {
      return t.prototype.dataToPoint.call(this, r, n, i);
    }, e.prototype.convertToPixel = function(r, n, i) {
      var a = yP(n);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(r, n, i) {
      var a = yP(n);
      return a === this ? a.pointToData(i) : null;
    }, e;
  }(Xd);
  yr(cw, Xd);
  function yP(t) {
    var e = t.geoModel, r = t.seriesModel;
    return e ? e.coordinateSystem : r ? r.coordinateSystem || (r.getReferringComponents("geo", gr).models[0] || {}).coordinateSystem : null;
  }
  function _P(t, e) {
    var r = t.get("boundingCoords");
    if (r != null) {
      var n = r[0], i = r[1];
      if (isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])) {
        var a = this.projection;
        if (a) {
          var o = n[0], s = n[1], l = i[0], u = i[1];
          n = [
            1 / 0,
            1 / 0
          ], i = [
            -1 / 0,
            -1 / 0
          ];
          var c = function(x, T, A, I) {
            for (var M = A - x, k = I - T, B = 0; B <= 100; B++) {
              var L = B / 100, z = a.project([
                x + M * L,
                T + k * L
              ]);
              Ko(n, n, z), Zo(i, i, z);
            }
          };
          c(o, s, l, s), c(l, s, l, u), c(l, u, o, u), c(o, u, l, s);
        }
        this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1]);
      }
    }
    var h = this.getBoundingRect(), f = t.get("layoutCenter"), d = t.get("layoutSize"), p = e.getWidth(), v = e.getHeight(), g = h.width / h.height * this.aspectScale, m = false, y, _;
    f && d && (y = [
      pe(f[0], p),
      pe(f[1], v)
    ], _ = pe(d, Math.min(p, v)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(_) && (m = true));
    var b;
    if (m) b = {}, g > 1 ? (b.width = _, b.height = _ / g) : (b.height = _, b.width = _ * g), b.y = y[1] - b.height / 2, b.x = y[0] - b.width / 2;
    else {
      var w = t.getBoxLayoutParams();
      w.aspect = g, b = Tr(w, {
        width: p,
        height: v
      });
    }
    this.setViewRect(b.x, b.y, b.width, b.height), this.setCenter(t.get("center"), e), this.setZoom(t.get("zoom"));
  }
  function Ise(t, e) {
    $(e.get("geoCoord"), function(r, n) {
      t.addGeoCoord(n, r);
    });
  }
  var Mse = function() {
    function t() {
      this.dimensions = eW;
    }
    return t.prototype.create = function(e, r) {
      var n = [];
      function i(o) {
        return {
          nameProperty: o.get("nameProperty"),
          aspectScale: o.get("aspectScale"),
          projection: o.get("projection")
        };
      }
      e.eachComponent("geo", function(o, s) {
        var l = o.get("map"), u = new cw(l + s, l, te({
          nameMap: o.get("nameMap")
        }, i(o)));
        u.zoomLimit = o.get("scaleLimit"), n.push(u), o.coordinateSystem = u, u.model = o, u.resize = _P, u.resize(o, r);
      }), e.eachSeries(function(o) {
        var s = o.get("coordinateSystem");
        if (s === "geo") {
          var l = o.get("geoIndex") || 0;
          o.coordinateSystem = n[l];
        }
      });
      var a = {};
      return e.eachSeriesByType("map", function(o) {
        if (!o.getHostGeoModel()) {
          var s = o.getMapType();
          a[s] = a[s] || [], a[s].push(o);
        }
      }), $(a, function(o, s) {
        var l = oe(o, function(c) {
          return c.get("nameMap");
        }), u = new cw(s, s, te({
          nameMap: qS(l)
        }, i(o[0])));
        u.zoomLimit = Fr.apply(null, oe(o, function(c) {
          return c.get("scaleLimit");
        })), n.push(u), u.resize = _P, u.resize(o[0], r), $(o, function(c) {
          c.coordinateSystem = u, Ise(u, c);
        });
      }), n;
    }, t.prototype.getFilledRegions = function(e, r, n, i) {
      for (var a = (e || []).slice(), o = Ce(), s = 0; s < a.length; s++) o.set(a[s].name, a[s]);
      var l = mo.load(r, n, i);
      return $(l.regions, function(u) {
        var c = u.name, h = o.get(c), f = u.properties && u.properties.echartsStyle;
        h || (h = {
          name: c
        }, a.push(h)), f && je(h, f);
      }), a;
    }, t;
  }(), tW = new Mse(), Dse = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r, n, i) {
      var a = mo.getGeoResource(r.map);
      if (a && a.type === "geoJSON") {
        var o = r.itemStyle = r.itemStyle || {};
        "color" in o || (o.color = "#eee");
      }
      this.mergeDefaultAndTheme(r, i), Ul(r, "label", [
        "show"
      ]);
    }, e.prototype.optionUpdated = function() {
      var r = this, n = this.option;
      n.regions = tW.getFilledRegions(n.regions, n.map, n.nameMap, n.nameProperty);
      var i = {};
      this._optionModelMap = ka(n.regions || [], function(a, o) {
        var s = o.name;
        return s && (a.set(s, new kt(o, r, r.ecModel)), o.selected && (i[s] = true)), a;
      }, Ce()), n.selectedMap || (n.selectedMap = i);
    }, e.prototype.getRegionModel = function(r) {
      return this._optionModelMap.get(r) || new kt(null, this, this.ecModel);
    }, e.prototype.getFormattedLabel = function(r, n) {
      var i = this.getRegionModel(r), a = n === "normal" ? i.get([
        "label",
        "formatter"
      ]) : i.get([
        "emphasis",
        "label",
        "formatter"
      ]), o = {
        name: r
      };
      if (De(a)) return o.status = n, a(o);
      if (me(a)) return a.replace("{a}", r ?? "");
    }, e.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, e.prototype.setCenter = function(r) {
      this.option.center = r;
    }, e.prototype.select = function(r) {
      var n = this.option, i = n.selectedMode;
      if (i) {
        i !== "multiple" && (n.selectedMap = null);
        var a = n.selectedMap || (n.selectedMap = {});
        a[r] = true;
      }
    }, e.prototype.unSelect = function(r) {
      var n = this.option.selectedMap;
      n && (n[r] = false);
    }, e.prototype.toggleSelected = function(r) {
      this[this.isSelected(r) ? "unSelect" : "select"](r);
    }, e.prototype.isSelected = function(r) {
      var n = this.option.selectedMap;
      return !!(n && n[r]);
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
      z: 0,
      show: true,
      left: "center",
      top: "center",
      aspectScale: null,
      silent: false,
      map: "",
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
    }, e;
  }(vt);
  function bP(t, e) {
    return t.pointToProjected ? t.pointToProjected(e) : t.pointToData(e);
  }
  function a2(t, e, r, n) {
    var i = t.getZoom(), a = t.getCenter(), o = e.zoom, s = t.projectedToPoint ? t.projectedToPoint(a) : t.dataToPoint(a);
    if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, t.setCenter(bP(t, s), n)), o != null) {
      if (r) {
        var l = r.min || 0, u = r.max || 1 / 0;
        o = Math.max(Math.min(i * o, u), l) / i;
      }
      t.scaleX *= o, t.scaleY *= o;
      var c = (e.originX - t.x) * (o - 1), h = (e.originY - t.y) * (o - 1);
      t.x -= c, t.y -= h, t.updateTransform(), t.setCenter(bP(t, s), n), t.setZoom(o * i);
    }
    return {
      center: t.getCenter(),
      zoom: t.getZoom()
    };
  }
  var Ese = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.focusBlurEnabled = true, r;
    }
    return e.prototype.init = function(r, n) {
      this._api = n;
    }, e.prototype.render = function(r, n, i, a) {
      if (this._model = r, !r.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new JG(i));
      var o = this._mapDraw;
      o.draw(r, n, i, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = r.get("silent"), this.group.add(o.group), this.updateSelectStatus(r, n, i);
    }, e.prototype._handleRegionClick = function(r) {
      var n;
      Al(r.target, function(i) {
        return (n = Ge(i).eventData) != null;
      }, true), n && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: n.name
      });
    }, e.prototype.updateSelectStatus = function(r, n, i) {
      var a = this;
      this._mapDraw.group.traverse(function(o) {
        var s = Ge(o).eventData;
        if (s) return a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o), true;
      });
    }, e.prototype.findHighDownDispatchers = function(r) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(r, this._model);
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, e.type = "geo", e;
  }(tr);
  function kse(t, e, r) {
    mo.registerMap(t, e, r);
  }
  function rW(t) {
    t.registerCoordinateSystem("geo", tW), t.registerComponentModel(Dse), t.registerComponentView(Ese), t.registerImpl("registerMap", kse), t.registerImpl("getMap", function(r) {
      return mo.getMapForUser(r);
    });
    function e(r, n) {
      n.update = "geo:updateSelectStatus", t.registerAction(n, function(i, a) {
        var o = {}, s = [];
        return a.eachComponent({
          mainType: "geo",
          query: i
        }, function(l) {
          l[r](i.name);
          var u = l.coordinateSystem;
          $(u.regions, function(h) {
            o[h.name] = l.isSelected(h.name) || false;
          });
          var c = [];
          $(o, function(h, f) {
            o[f] && c.push(f);
          }), s.push({
            geoIndex: l.componentIndex,
            name: c
          });
        }), {
          selected: o,
          allSelected: s,
          name: i.name
        };
      });
    }
    e("toggleSelected", {
      type: "geoToggleSelect",
      event: "geoselectchanged"
    }), e("select", {
      type: "geoSelect",
      event: "geoselected"
    }), e("unSelect", {
      type: "geoUnSelect",
      event: "geounselected"
    }), t.registerAction({
      type: "geoRoam",
      event: "geoRoam",
      update: "updateTransform"
    }, function(r, n, i) {
      var a = r.componentType || "series";
      n.eachComponent({
        mainType: a,
        query: r
      }, function(o) {
        var s = o.coordinateSystem;
        if (s.type === "geo") {
          var l = a2(s, r, o.get("scaleLimit"), i);
          o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && $(o.seriesGroup, function(u) {
            u.setCenter(l.center), u.setZoom(l.zoom);
          });
        }
      });
    });
  }
  function Pse(t) {
    rt(rW), t.registerChartView(xse), t.registerSeriesModel(wse), t.registerLayout(Cse), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, Tse), n5("map", t.registerAction);
  }
  function Lse(t) {
    var e = t;
    e.hierNode = {
      defaultAncestor: null,
      ancestor: e,
      prelim: 0,
      modifier: 0,
      change: 0,
      shift: 0,
      i: 0,
      thread: null
    };
    for (var r = [
      e
    ], n, i; n = r.pop(); ) if (i = n.children, n.isExpand && i.length) for (var a = i.length, o = a - 1; o >= 0; o--) {
      var s = i[o];
      s.hierNode = {
        defaultAncestor: null,
        ancestor: s,
        prelim: 0,
        modifier: 0,
        change: 0,
        shift: 0,
        i: o,
        thread: null
      }, r.push(s);
    }
  }
  function $se(t, e) {
    var r = t.isExpand ? t.children : [], n = t.parentNode.children, i = t.hierNode.i ? n[t.hierNode.i - 1] : null;
    if (r.length) {
      Nse(t);
      var a = (r[0].hierNode.prelim + r[r.length - 1].hierNode.prelim) / 2;
      i ? (t.hierNode.prelim = i.hierNode.prelim + e(t, i), t.hierNode.modifier = t.hierNode.prelim - a) : t.hierNode.prelim = a;
    } else i && (t.hierNode.prelim = i.hierNode.prelim + e(t, i));
    t.parentNode.hierNode.defaultAncestor = Bse(t, i, t.parentNode.hierNode.defaultAncestor || n[0], e);
  }
  function Rse(t) {
    var e = t.hierNode.prelim + t.parentNode.hierNode.modifier;
    t.setLayout({
      x: e
    }, true), t.hierNode.modifier += t.parentNode.hierNode.modifier;
  }
  function xP(t) {
    return arguments.length ? t : Vse;
  }
  function af(t, e) {
    return t -= Math.PI / 2, {
      x: e * Math.cos(t),
      y: e * Math.sin(t)
    };
  }
  function Ose(t, e) {
    return Tr(t.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function Nse(t) {
    for (var e = t.children, r = e.length, n = 0, i = 0; --r >= 0; ) {
      var a = e[r];
      a.hierNode.prelim += n, a.hierNode.modifier += n, i += a.hierNode.change, n += a.hierNode.shift + i;
    }
  }
  function Bse(t, e, r, n) {
    if (e) {
      for (var i = t, a = t, o = a.parentNode.children[0], s = e, l = i.hierNode.modifier, u = a.hierNode.modifier, c = o.hierNode.modifier, h = s.hierNode.modifier; s = __(s), a = b_(a), s && a; ) {
        i = __(i), o = b_(o), i.hierNode.ancestor = t;
        var f = s.hierNode.prelim + h - a.hierNode.prelim - u + n(s, a);
        f > 0 && (Fse(zse(s, t, r), t, f), u += f, l += f), h += s.hierNode.modifier, u += a.hierNode.modifier, l += i.hierNode.modifier, c += o.hierNode.modifier;
      }
      s && !__(i) && (i.hierNode.thread = s, i.hierNode.modifier += h - l), a && !b_(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - c, r = t);
    }
    return r;
  }
  function __(t) {
    var e = t.children;
    return e.length && t.isExpand ? e[e.length - 1] : t.hierNode.thread;
  }
  function b_(t) {
    var e = t.children;
    return e.length && t.isExpand ? e[0] : t.hierNode.thread;
  }
  function zse(t, e, r) {
    return t.hierNode.ancestor.parentNode === e.parentNode ? t.hierNode.ancestor : r;
  }
  function Fse(t, e, r) {
    var n = r / (e.hierNode.i - t.hierNode.i);
    e.hierNode.change -= n, e.hierNode.shift += r, e.hierNode.modifier += r, e.hierNode.prelim += r, t.hierNode.change += n;
  }
  function Vse(t, e) {
    return t.parentNode === e.parentNode ? 1 : 2;
  }
  var Gse = /* @__PURE__ */ function() {
    function t() {
      this.parentPoint = [], this.childPoints = [];
    }
    return t;
  }(), Wse = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new Gse();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.childPoints, a = i.length, o = n.parentPoint, s = i[0], l = i[a - 1];
      if (a === 1) {
        r.moveTo(o[0], o[1]), r.lineTo(s[0], s[1]);
        return;
      }
      var u = n.orient, c = u === "TB" || u === "BT" ? 0 : 1, h = 1 - c, f = pe(n.forkPosition, 1), d = [];
      d[c] = o[c], d[h] = o[h] + (l[h] - o[h]) * f, r.moveTo(o[0], o[1]), r.lineTo(d[0], d[1]), r.moveTo(s[0], s[1]), d[c] = s[c], r.lineTo(d[0], d[1]), d[c] = l[c], r.lineTo(d[0], d[1]), r.lineTo(l[0], l[1]);
      for (var p = 1; p < a - 1; p++) {
        var v = i[p];
        r.moveTo(v[0], v[1]), d[c] = v[c], r.lineTo(d[0], d[1]);
      }
    }, e;
  }(st), Hse = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._mainGroup = new Be(), r;
    }
    return e.prototype.init = function(r, n) {
      this._controller = new qd(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, e.prototype.render = function(r, n, i) {
      var a = r.getData(), o = r.layoutInfo, s = this._mainGroup, l = r.get("layout");
      l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(r, i), this._updateController(r, n, i);
      var u = this._data;
      a.diff(u).add(function(c) {
        wP(a, c) && SP(a, c, null, s, r);
      }).update(function(c, h) {
        var f = u.getItemGraphicEl(h);
        if (!wP(a, c)) {
          f && CP(u, h, f, s, r);
          return;
        }
        SP(a, c, f, s, r);
      }).remove(function(c) {
        var h = u.getItemGraphicEl(c);
        h && CP(u, c, h, s, r);
      }).execute(), this._nodeScaleRatio = r.get("nodeScaleRatio"), this._updateNodeAndLinkScale(r), r.get("expandAndCollapse") === true && a.eachItemGraphicEl(function(c, h) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: r.id,
            dataIndex: h
          });
        });
      }), this._data = a;
    }, e.prototype._updateViewCoordSys = function(r, n) {
      var i = r.getData(), a = [];
      i.each(function(h) {
        var f = i.getItemLayout(h);
        f && !isNaN(f.x) && !isNaN(f.y) && a.push([
          +f.x,
          +f.y
        ]);
      });
      var o = [], s = [];
      Hm(a, o, s);
      var l = this._min, u = this._max;
      s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = r.coordinateSystem = new Xd();
      c.zoomLimit = r.get("scaleLimit"), c.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), c.setCenter(r.get("center"), n), c.setZoom(r.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = o, this._max = s;
    }, e.prototype._updateController = function(r, n, i) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      o.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !py(u, i, r);
      }), o.enable(r.get("roam")), s.zoomLimit = r.get("scaleLimit"), s.zoom = r.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        r2(s, u.dx, u.dy), i.dispatchAction({
          seriesId: r.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        n2(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: r.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(r), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function(r) {
      var n = r.getData(), i = this._getNodeGlobalScale(r);
      n.eachItemGraphicEl(function(a, o) {
        a.setSymbolScale(i);
      });
    }, e.prototype._getNodeGlobalScale = function(r) {
      var n = r.coordinateSystem;
      if (n.type !== "view") return 1;
      var i = this._nodeScaleRatio, a = n.scaleX || 1, o = n.getZoom(), s = (o - 1) * i + 1;
      return s / a;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, e.type = "tree", e;
  }(Ft);
  function wP(t, e) {
    var r = t.getItemLayout(e);
    return r && !isNaN(r.x) && !isNaN(r.y);
  }
  function SP(t, e, r, n, i) {
    var a = !r, o = t.tree.getNodeByDataIndex(e), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === false && o.children.length !== 0 ? l : "#fff", c = t.tree.root, h = o.parentNode === c ? o : o.parentNode || o, f = t.getItemGraphicEl(h.dataIndex), d = h.getLayout(), p = f ? {
      x: f.__oldX,
      y: f.__oldY,
      rawX: f.__radialOldRawX,
      rawY: f.__radialOldRawY
    } : d, v = o.getLayout();
    a ? (r = new Vd(t, e, null, {
      symbolInnerColor: u,
      useNameLabel: true
    }), r.x = p.x, r.y = p.y) : r.updateData(t, e, null, {
      symbolInnerColor: u,
      useNameLabel: true
    }), r.__radialOldRawX = r.__radialRawX, r.__radialOldRawY = r.__radialRawY, r.__radialRawX = v.rawX, r.__radialRawY = v.rawY, n.add(r), t.setItemGraphicEl(e, r), r.__oldX = r.x, r.__oldY = r.y, wt(r, {
      x: v.x,
      y: v.y
    }, i);
    var g = r.getSymbolPath();
    if (i.get("layout") === "radial") {
      var m = c.children[0], y = m.getLayout(), _ = m.children.length, b = void 0, w = void 0;
      if (v.x === y.x && o.isExpand === true && m.children.length) {
        var x = {
          x: (m.children[0].getLayout().x + m.children[_ - 1].getLayout().x) / 2,
          y: (m.children[0].getLayout().y + m.children[_ - 1].getLayout().y) / 2
        };
        b = Math.atan2(x.y - y.y, x.x - y.x), b < 0 && (b = Math.PI * 2 + b), w = x.x < y.x, w && (b = b - Math.PI);
      } else b = Math.atan2(v.y - y.y, v.x - y.x), b < 0 && (b = Math.PI * 2 + b), o.children.length === 0 || o.children.length !== 0 && o.isExpand === false ? (w = v.x < y.x, w && (b = b - Math.PI)) : (w = v.x > y.x, w || (b = b - Math.PI));
      var T = w ? "left" : "right", A = s.getModel("label"), I = A.get("rotate"), M = I * (Math.PI / 180), k = g.getTextContent();
      k && (g.setTextConfig({
        position: A.get("position") || T,
        rotation: I == null ? -b : M,
        origin: "center"
      }), k.setStyle("verticalAlign", "middle"));
    }
    var B = s.get([
      "emphasis",
      "focus"
    ]), L = B === "relative" ? Vf(o.getAncestorsIndices(), o.getDescendantIndices()) : B === "ancestor" ? o.getAncestorsIndices() : B === "descendant" ? o.getDescendantIndices() : null;
    L && (Ge(r).focus = L), Use(i, o, c, r, p, d, v, n), r.__edge && (r.onHoverStateChange = function(z) {
      if (z !== "blur") {
        var F = o.parentNode && t.getItemGraphicEl(o.parentNode.dataIndex);
        F && F.hoverState === kd || kg(r.__edge, z);
      }
    });
  }
  function Use(t, e, r, n, i, a, o, s) {
    var l = e.getModel(), u = t.get("edgeShape"), c = t.get("layout"), h = t.getOrient(), f = t.get([
      "lineStyle",
      "curveness"
    ]), d = t.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), v = n.__edge;
    if (u === "curve") e.parentNode && e.parentNode !== r && (v || (v = n.__edge = new Ld({
      shape: hw(c, h, f, i, i)
    })), wt(v, {
      shape: hw(c, h, f, a, o)
    }, t));
    else if (u === "polyline" && c === "orthogonal" && e !== r && e.children && e.children.length !== 0 && e.isExpand === true) {
      for (var g = e.children, m = [], y = 0; y < g.length; y++) {
        var _ = g[y].getLayout();
        m.push([
          _.x,
          _.y
        ]);
      }
      v || (v = n.__edge = new Wse({
        shape: {
          parentPoint: [
            o.x,
            o.y
          ],
          childPoints: [
            [
              o.x,
              o.y
            ]
          ],
          orient: h,
          forkPosition: d
        }
      })), wt(v, {
        shape: {
          parentPoint: [
            o.x,
            o.y
          ],
          childPoints: m
        }
      }, t);
    }
    v && !(u === "polyline" && !e.isExpand) && (v.useStyle(Ee({
      strokeNoScale: true,
      fill: null
    }, p)), qr(v, l, "lineStyle"), Xl(v), s.add(v));
  }
  function TP(t, e, r, n, i) {
    var a = e.tree.root, o = nW(a, t), s = o.source, l = o.sourceLayout, u = e.getItemGraphicEl(t.dataIndex);
    if (u) {
      var c = e.getItemGraphicEl(s.dataIndex), h = c.__edge, f = u.__edge || (s.isExpand === false || s.children.length === 1 ? h : void 0), d = n.get("edgeShape"), p = n.get("layout"), v = n.get("orient"), g = n.get([
        "lineStyle",
        "curveness"
      ]);
      f && (d === "curve" ? ds(f, {
        shape: hw(p, v, g, l, l),
        style: {
          opacity: 0
        }
      }, n, {
        cb: function() {
          r.remove(f);
        },
        removeOpt: i
      }) : d === "polyline" && n.get("layout") === "orthogonal" && ds(f, {
        shape: {
          parentPoint: [
            l.x,
            l.y
          ],
          childPoints: [
            [
              l.x,
              l.y
            ]
          ]
        },
        style: {
          opacity: 0
        }
      }, n, {
        cb: function() {
          r.remove(f);
        },
        removeOpt: i
      }));
    }
  }
  function nW(t, e) {
    for (var r = e.parentNode === t ? e : e.parentNode || e, n; n = r.getLayout(), n == null; ) r = r.parentNode === t ? r : r.parentNode || r;
    return {
      source: r,
      sourceLayout: n
    };
  }
  function CP(t, e, r, n, i) {
    var a = t.tree.getNodeByDataIndex(e), o = t.tree.root, s = nW(o, a).sourceLayout, l = {
      duration: i.get("animationDurationUpdate"),
      easing: i.get("animationEasingUpdate")
    };
    ds(r, {
      x: s.x + 1,
      y: s.y + 1
    }, i, {
      cb: function() {
        n.remove(r), t.setItemGraphicEl(e, null);
      },
      removeOpt: l
    }), r.fadeOut(null, t.hostModel, {
      fadeLabel: true,
      animation: l
    }), a.children.forEach(function(u) {
      TP(u, t, n, i, l);
    }), TP(a, t, n, i, l);
  }
  function hw(t, e, r, n, i) {
    var a, o, s, l, u, c, h, f;
    if (t === "radial") {
      u = n.rawX, h = n.rawY, c = i.rawX, f = i.rawY;
      var d = af(u, h), p = af(u, h + (f - h) * r), v = af(c, f + (h - f) * r), g = af(c, f);
      return {
        x1: d.x || 0,
        y1: d.y || 0,
        x2: g.x || 0,
        y2: g.y || 0,
        cpx1: p.x || 0,
        cpy1: p.y || 0,
        cpx2: v.x || 0,
        cpy2: v.y || 0
      };
    } else u = n.x, h = n.y, c = i.x, f = i.y, (e === "LR" || e === "RL") && (a = u + (c - u) * r, o = h, s = c + (u - c) * r, l = f), (e === "TB" || e === "BT") && (a = u, o = h + (f - h) * r, s = c, l = f + (h - f) * r);
    return {
      x1: u,
      y1: h,
      x2: c,
      y2: f,
      cpx1: a,
      cpy1: o,
      cpx2: s,
      cpy2: l
    };
  }
  var _i = _t();
  function iW(t) {
    var e = t.mainData, r = t.datas;
    r || (r = {
      main: e
    }, t.datasAttr = {
      main: "data"
    }), t.datas = t.mainData = null, aW(e, r, t), $(r, function(n) {
      $(e.TRANSFERABLE_METHODS, function(i) {
        n.wrapMethod(i, Ye(Yse, t));
      });
    }), e.wrapMethod("cloneShallow", Ye(Xse, t)), $(e.CHANGABLE_METHODS, function(n) {
      e.wrapMethod(n, Ye(qse, t));
    }), bn(r[e.dataType] === e);
  }
  function Yse(t, e) {
    if (Zse(this)) {
      var r = te({}, _i(this).datas);
      r[this.dataType] = e, aW(e, r, t);
    } else o2(e, this.dataType, _i(this).mainData, t);
    return e;
  }
  function qse(t, e) {
    return t.struct && t.struct.update(), e;
  }
  function Xse(t, e) {
    return $(_i(e).datas, function(r, n) {
      r !== e && o2(r.cloneShallow(), n, e, t);
    }), e;
  }
  function jse(t) {
    var e = _i(this).mainData;
    return t == null || e == null ? e : _i(e).datas[t];
  }
  function Kse() {
    var t = _i(this).mainData;
    return t == null ? [
      {
        data: t
      }
    ] : oe(gt(_i(t).datas), function(e) {
      return {
        type: e,
        data: _i(t).datas[e]
      };
    });
  }
  function Zse(t) {
    return _i(t).mainData === t;
  }
  function aW(t, e, r) {
    _i(t).datas = {}, $(e, function(n, i) {
      o2(n, i, t, r);
    });
  }
  function o2(t, e, r, n) {
    _i(r).datas[e] = t, _i(t).mainData = r, t.dataType = e, n.struct && (t[n.structAttr] = n.struct, n.struct[n.datasAttr[e]] = t), t.getLinkedData = jse, t.getLinkedDataAll = Kse;
  }
  var Qse = function() {
    function t(e, r) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = false, this.name = e || "", this.hostTree = r;
    }
    return t.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, t.prototype.eachNode = function(e, r, n) {
      De(e) && (n = r, r = e, e = null), e = e || {}, me(e) && (e = {
        order: e
      });
      var i = e.order || "preorder", a = this[e.attr || "children"], o;
      i === "preorder" && (o = r.call(n, this));
      for (var s = 0; !o && s < a.length; s++) a[s].eachNode(e, r, n);
      i === "postorder" && r.call(n, this);
    }, t.prototype.updateDepthAndHeight = function(e) {
      var r = 0;
      this.depth = e;
      for (var n = 0; n < this.children.length; n++) {
        var i = this.children[n];
        i.updateDepthAndHeight(e + 1), i.height > r && (r = i.height);
      }
      this.height = r + 1;
    }, t.prototype.getNodeById = function(e) {
      if (this.getId() === e) return this;
      for (var r = 0, n = this.children, i = n.length; r < i; r++) {
        var a = n[r].getNodeById(e);
        if (a) return a;
      }
    }, t.prototype.contains = function(e) {
      if (e === this) return true;
      for (var r = 0, n = this.children, i = n.length; r < i; r++) {
        var a = n[r].contains(e);
        if (a) return a;
      }
    }, t.prototype.getAncestors = function(e) {
      for (var r = [], n = e ? this : this.parentNode; n; ) r.push(n), n = n.parentNode;
      return r.reverse(), r;
    }, t.prototype.getAncestorsIndices = function() {
      for (var e = [], r = this; r; ) e.push(r.dataIndex), r = r.parentNode;
      return e.reverse(), e;
    }, t.prototype.getDescendantIndices = function() {
      var e = [];
      return this.eachNode(function(r) {
        e.push(r.dataIndex);
      }), e;
    }, t.prototype.getValue = function(e) {
      var r = this.hostTree.data;
      return r.getStore().get(r.getDimensionIndex(e || "value"), this.dataIndex);
    }, t.prototype.setLayout = function(e, r) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, r);
    }, t.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, t.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostTree, n = r.data.getItemModel(this.dataIndex);
        return n.getModel(e);
      }
    }, t.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, t.prototype.setVisual = function(e, r) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, r);
    }, t.prototype.getVisual = function(e) {
      return this.hostTree.data.getItemVisual(this.dataIndex, e);
    }, t.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, t.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, t.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var e = this.parentNode.children, r = 0; r < e.length; ++r) if (e[r] === this) return r;
        return -1;
      }
      return -1;
    }, t.prototype.isAncestorOf = function(e) {
      for (var r = e.parentNode; r; ) {
        if (r === this) return true;
        r = r.parentNode;
      }
      return false;
    }, t.prototype.isDescendantOf = function(e) {
      return e !== this && e.isAncestorOf(this);
    }, t;
  }(), s2 = function() {
    function t(e) {
      this.type = "tree", this._nodes = [], this.hostModel = e;
    }
    return t.prototype.eachNode = function(e, r, n) {
      this.root.eachNode(e, r, n);
    }, t.prototype.getNodeByDataIndex = function(e) {
      var r = this.data.getRawIndex(e);
      return this._nodes[r];
    }, t.prototype.getNodeById = function(e) {
      return this.root.getNodeById(e);
    }, t.prototype.update = function() {
      for (var e = this.data, r = this._nodes, n = 0, i = r.length; n < i; n++) r[n].dataIndex = -1;
      for (var n = 0, i = e.count(); n < i; n++) r[e.getRawIndex(n)].dataIndex = n;
    }, t.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, t.createTree = function(e, r, n) {
      var i = new t(r), a = [], o = 1;
      s(e);
      function s(c, h) {
        var f = c.value;
        o = Math.max(o, ae(f) ? f.length : 1), a.push(c);
        var d = new Qse(xr(c.name, ""), i);
        h ? Jse(d, h) : i.root = d, i._nodes.push(d);
        var p = c.children;
        if (p) for (var v = 0; v < p.length; v++) s(p[v], d);
      }
      i.root.updateDepthAndHeight(0);
      var l = zd(a, {
        coordDimensions: [
          "value"
        ],
        dimensionsCount: o
      }).dimensions, u = new yn(l, r);
      return u.initData(a), n && n(u), iW({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, t;
  }();
  function Jse(t, e) {
    var r = e.children;
    t.parentNode !== e && (r.push(t), t.parentNode = e);
  }
  function sd(t, e, r) {
    if (t && et(e, t.type) >= 0) {
      var n = r.getData().tree.root, i = t.targetNode;
      if (me(i) && (i = n.getNodeById(i)), i && n.contains(i)) return {
        node: i
      };
      var a = t.targetNodeId;
      if (a != null && (i = n.getNodeById(a))) return {
        node: i
      };
    }
  }
  function oW(t) {
    for (var e = []; t; ) t = t.parentNode, t && e.push(t);
    return e.reverse();
  }
  function l2(t, e) {
    var r = oW(t);
    return et(r, e) >= 0;
  }
  function gy(t, e) {
    for (var r = []; t; ) {
      var n = t.dataIndex;
      r.push({
        name: t.name,
        dataIndex: n,
        value: e.getRawValue(n)
      }), t = t.parentNode;
    }
    return r.reverse(), r;
  }
  var ele = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.hasSymbolVisual = true, r.ignoreStyleOnData = true, r;
    }
    return e.prototype.getInitialData = function(r) {
      var n = {
        name: r.name,
        children: r.data
      }, i = r.leaves || {}, a = new kt(i, this, this.ecModel), o = s2.createTree(n, this, s);
      function s(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = o.getNodeByDataIndex(d);
          return p && p.children.length && p.isExpand || (f.parentModel = a), f;
        });
      }
      var l = 0;
      o.eachNode("preorder", function(h) {
        h.depth > l && (l = h.depth);
      });
      var u = r.expandAndCollapse, c = u && r.initialTreeDepth >= 0 ? r.initialTreeDepth : l;
      return o.root.eachNode("preorder", function(h) {
        var f = h.hostTree.data.getRawDataItem(h.dataIndex);
        h.isExpand = f && f.collapsed != null ? !f.collapsed : h.depth <= c;
      }), o.data;
    }, e.prototype.getOrient = function() {
      var r = this.get("orient");
      return r === "horizontal" ? r = "LR" : r === "vertical" && (r = "TB"), r;
    }, e.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, e.prototype.setCenter = function(r) {
      this.option.center = r;
    }, e.prototype.formatTooltip = function(r, n, i) {
      for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(r), l = s.getValue(), u = s.name; s && s !== o; ) u = s.parentNode.name + "." + u, s = s.parentNode;
      return $r("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, e.prototype.getDataParams = function(r) {
      var n = t.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treeAncestors = gy(i, this), n.collapsed = !i.isExpand, n;
    }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      layout: "orthogonal",
      edgeShape: "curve",
      edgeForkPosition: "50%",
      roam: false,
      nodeScaleRatio: 0.4,
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: true,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        borderWidth: 1.5
      },
      label: {
        show: true
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, e;
  }(Xt);
  function tle(t, e, r) {
    for (var n = [
      t
    ], i = [], a; a = n.pop(); ) if (i.push(a), a.isExpand) {
      var o = a.children;
      if (o.length) for (var s = 0; s < o.length; s++) n.push(o[s]);
    }
    for (; a = i.pop(); ) e(a, r);
  }
  function Ah(t, e) {
    for (var r = [
      t
    ], n; n = r.pop(); ) if (e(n), n.isExpand) {
      var i = n.children;
      if (i.length) for (var a = i.length - 1; a >= 0; a--) r.push(i[a]);
    }
  }
  function rle(t, e) {
    t.eachSeriesByType("tree", function(r) {
      nle(r, e);
    });
  }
  function nle(t, e) {
    var r = Ose(t, e);
    t.layoutInfo = r;
    var n = t.get("layout"), i = 0, a = 0, o = null;
    n === "radial" ? (i = 2 * Math.PI, a = Math.min(r.height, r.width) / 2, o = xP(function(_, b) {
      return (_.parentNode === b.parentNode ? 1 : 2) / _.depth;
    })) : (i = r.width, a = r.height, o = xP());
    var s = t.getData().tree.root, l = s.children[0];
    if (l) {
      Lse(s), tle(l, $se, o), s.hierNode.modifier = -l.hierNode.prelim, Ah(l, Rse);
      var u = l, c = l, h = l;
      Ah(l, function(_) {
        var b = _.getLayout().x;
        b < u.getLayout().x && (u = _), b > c.getLayout().x && (c = _), _.depth > h.depth && (h = _);
      });
      var f = u === c ? 1 : o(u, c) / 2, d = f - u.getLayout().x, p = 0, v = 0, g = 0, m = 0;
      if (n === "radial") p = i / (c.getLayout().x + f + d), v = a / (h.depth - 1 || 1), Ah(l, function(_) {
        g = (_.getLayout().x + d) * p, m = (_.depth - 1) * v;
        var b = af(g, m);
        _.setLayout({
          x: b.x,
          y: b.y,
          rawX: g,
          rawY: m
        }, true);
      });
      else {
        var y = t.getOrient();
        y === "RL" || y === "LR" ? (v = a / (c.getLayout().x + f + d), p = i / (h.depth - 1 || 1), Ah(l, function(_) {
          m = (_.getLayout().x + d) * v, g = y === "LR" ? (_.depth - 1) * p : i - (_.depth - 1) * p, _.setLayout({
            x: g,
            y: m
          }, true);
        })) : (y === "TB" || y === "BT") && (p = i / (c.getLayout().x + f + d), v = a / (h.depth - 1 || 1), Ah(l, function(_) {
          g = (_.getLayout().x + d) * p, m = y === "TB" ? (_.depth - 1) * v : a - (_.depth - 1) * v, _.setLayout({
            x: g,
            y: m
          }, true);
        }));
      }
    }
  }
  function ile(t) {
    t.eachSeriesByType("tree", function(e) {
      var r = e.getData(), n = r.tree;
      n.eachNode(function(i) {
        var a = i.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = r.ensureUniqueItemVisual(i.dataIndex, "style");
        te(s, o);
      });
    });
  }
  function ale(t) {
    t.registerAction({
      type: "treeExpandAndCollapse",
      event: "treeExpandAndCollapse",
      update: "update"
    }, function(e, r) {
      r.eachComponent({
        mainType: "series",
        subType: "tree",
        query: e
      }, function(n) {
        var i = e.dataIndex, a = n.getData().tree, o = a.getNodeByDataIndex(i);
        o.isExpand = !o.isExpand;
      });
    }), t.registerAction({
      type: "treeRoam",
      event: "treeRoam",
      update: "none"
    }, function(e, r, n) {
      r.eachComponent({
        mainType: "series",
        subType: "tree",
        query: e
      }, function(i) {
        var a = i.coordinateSystem, o = a2(a, e, void 0, n);
        i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom);
      });
    });
  }
  function ole(t) {
    t.registerChartView(Hse), t.registerSeriesModel(ele), t.registerLayout(rle), t.registerVisual(ile), ale(t);
  }
  var AP = [
    "treemapZoomToNode",
    "treemapRender",
    "treemapMove"
  ];
  function sle(t) {
    for (var e = 0; e < AP.length; e++) t.registerAction({
      type: AP[e],
      update: "updateView"
    }, dr);
    t.registerAction({
      type: "treemapRootToNode",
      update: "updateView"
    }, function(r, n) {
      n.eachComponent({
        mainType: "series",
        subType: "treemap",
        query: r
      }, i);
      function i(a, o) {
        var s = [
          "treemapZoomToNode",
          "treemapRootToNode"
        ], l = sd(r, s, a);
        if (l) {
          var u = a.getViewRoot();
          u && (r.direction = l2(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
        }
      }
    });
  }
  function sW(t) {
    var e = t.getData(), r = e.tree, n = {};
    r.eachNode(function(i) {
      for (var a = i; a && a.depth > 1; ) a = a.parentNode;
      var o = zx(t.ecModel, a.name || a.dataIndex + "", n);
      i.setVisual("decal", o);
    });
  }
  var lle = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.preventUsingHoverLayer = true, r;
    }
    return e.prototype.getInitialData = function(r, n) {
      var i = {
        name: r.name,
        children: r.data
      };
      lW(i);
      var a = r.levels || [], o = this.designatedVisualItemStyle = {}, s = new kt({
        itemStyle: o
      }, this, n);
      a = r.levels = ule(a, n);
      var l = oe(a || [], function(h) {
        return new kt(h, s, n);
      }, this), u = s2.createTree(i, this, c);
      function c(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = u.getNodeByDataIndex(d), v = p ? l[p.depth] : null;
          return f.parentModel = v || s, f;
        });
      }
      return u.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.formatTooltip = function(r, n, i) {
      var a = this.getData(), o = this.getRawValue(r), s = a.getName(r);
      return $r("nameValue", {
        name: s,
        value: o
      });
    }, e.prototype.getDataParams = function(r) {
      var n = t.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treeAncestors = gy(i, this), n.treePathInfo = n.treeAncestors, n;
    }, e.prototype.setLayoutInfo = function(r) {
      this.layoutInfo = this.layoutInfo || {}, te(this.layoutInfo, r);
    }, e.prototype.mapIdToIndex = function(r) {
      var n = this._idIndexMap;
      n || (n = this._idIndexMap = Ce(), this._idIndexMapCount = 0);
      var i = n.get(r);
      return i == null && n.set(r, i = this._idIndexMapCount++), i;
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(r) {
      r ? this._viewRoot = r : r = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!r || r !== n && !n.contains(r)) && (this._viewRoot = n);
    }, e.prototype.enableAriaDecal = function() {
      sW(this);
    }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = {
      progressive: 0,
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: true,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "\u25B6",
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: true,
      nodeClick: "zoomToNode",
      animation: true,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: true,
        height: 22,
        left: "center",
        top: "bottom",
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
          }
        }
      },
      label: {
        show: true,
        distance: 0,
        padding: 5,
        position: "inside",
        color: "#fff",
        overflow: "truncate"
      },
      upperLabel: {
        show: false,
        position: [
          0,
          "50%"
        ],
        height: 20,
        overflow: "truncate",
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
      },
      emphasis: {
        upperLabel: {
          show: true,
          position: [
            0,
            "50%"
          ],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: []
    }, e;
  }(Xt);
  function lW(t) {
    var e = 0;
    $(t.children, function(n) {
      lW(n);
      var i = n.value;
      ae(i) && (i = i[0]), e += i;
    });
    var r = t.value;
    ae(r) && (r = r[0]), (r == null || isNaN(r)) && (r = e), r < 0 && (r = 0), ae(t.value) ? t.value[0] = r : t.value = r;
  }
  function ule(t, e) {
    var r = Ot(e.get("color")), n = Ot(e.get([
      "aria",
      "decal",
      "decals"
    ]));
    if (r) {
      t = t || [];
      var i, a;
      $(t, function(s) {
        var l = new kt(s), u = l.get("color"), c = l.get("decal");
        (l.get([
          "itemStyle",
          "color"
        ]) || u && u !== "none") && (i = true), (l.get([
          "itemStyle",
          "decal"
        ]) || c && c !== "none") && (a = true);
      });
      var o = t[0] || (t[0] = {});
      return i || (o.color = r.slice()), !a && n && (o.decal = n.slice()), t;
    }
  }
  var cle = 8, IP = 8, x_ = 5, hle = function() {
    function t(e) {
      this.group = new Be(), e.add(this.group);
    }
    return t.prototype.render = function(e, r, n, i) {
      var a = e.getModel("breadcrumb"), o = this.group;
      if (o.removeAll(), !(!a.get("show") || !n)) {
        var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel([
          "itemStyle",
          "textStyle"
        ]), h = {
          pos: {
            left: a.get("left"),
            right: a.get("right"),
            top: a.get("top"),
            bottom: a.get("bottom")
          },
          box: {
            width: r.getWidth(),
            height: r.getHeight()
          },
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(n, h, u), this._renderContent(e, h, s, l, u, c, i), ny(o, h.pos, h.box);
      }
    }, t.prototype._prepare = function(e, r, n) {
      for (var i = e; i; i = i.parentNode) {
        var a = xr(i.getModel().get("name"), ""), o = n.getTextRect(a), s = Math.max(o.width + cle * 2, r.emptyItemWidth);
        r.totalWidth += s + IP, r.renderList.push({
          node: i,
          text: a,
          width: s
        });
      }
    }, t.prototype._renderContent = function(e, r, n, i, a, o, s) {
      for (var l = 0, u = r.emptyItemWidth, c = e.get([
        "breadcrumb",
        "height"
      ]), h = _ee(r.pos, r.box), f = r.totalWidth, d = r.renderList, p = i.getModel("itemStyle").getItemStyle(), v = d.length - 1; v >= 0; v--) {
        var g = d[v], m = g.node, y = g.width, _ = g.text;
        f > h.width && (f -= y - u, y = u, _ = null);
        var b = new Sn({
          shape: {
            points: fle(l, 0, y, c, v === d.length - 1, v === 0)
          },
          style: Ee(n.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new bt({
            style: Yt(a, {
              text: _
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: Vc * 1e4,
          onclick: Ye(s, m)
        });
        b.disableLabelAnimation = true, b.getTextContent().ensureState("emphasis").style = Yt(o, {
          text: _
        }), b.ensureState("emphasis").style = p, ir(b, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(b), dle(b, e, m), l += y + IP;
      }
    }, t.prototype.remove = function() {
      this.group.removeAll();
    }, t;
  }();
  function fle(t, e, r, n, i, a) {
    var o = [
      [
        i ? t : t - x_,
        e
      ],
      [
        t + r,
        e
      ],
      [
        t + r,
        e + n
      ],
      [
        i ? t : t - x_,
        e + n
      ]
    ];
    return !a && o.splice(2, 0, [
      t + r + x_,
      e + n / 2
    ]), !i && o.push([
      t,
      e + n / 2
    ]), o;
  }
  function dle(t, e, r) {
    Ge(t).eventData = {
      componentType: "series",
      componentSubType: "treemap",
      componentIndex: e.componentIndex,
      seriesIndex: e.seriesIndex,
      seriesName: e.name,
      seriesType: "treemap",
      selfType: "breadcrumb",
      nodeData: {
        dataIndex: r && r.dataIndex,
        name: r && r.name
      },
      treePathInfo: r && gy(r, e)
    };
  }
  var ple = function() {
    function t() {
      this._storage = [], this._elExistsMap = {};
    }
    return t.prototype.add = function(e, r, n, i, a) {
      return this._elExistsMap[e.id] ? false : (this._elExistsMap[e.id] = true, this._storage.push({
        el: e,
        target: r,
        duration: n,
        delay: i,
        easing: a
      }), true);
    }, t.prototype.finished = function(e) {
      return this._finishedCallback = e, this;
    }, t.prototype.start = function() {
      for (var e = this, r = this._storage.length, n = function() {
        r--, r <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback());
      }, i = 0, a = this._storage.length; i < a; i++) {
        var o = this._storage[i];
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: true,
          done: n,
          aborted: n
        });
      }
      return this;
    }, t;
  }();
  function vle() {
    return new ple();
  }
  var fw = Be, MP = yt, DP = 3, EP = "label", kP = "upperLabel", gle = Vc * 10, mle = Vc * 2, yle = Vc * 3, sl = ql([
    [
      "fill",
      "color"
    ],
    [
      "stroke",
      "strokeColor"
    ],
    [
      "lineWidth",
      "strokeWidth"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ]
  ]), PP = function(t) {
    var e = sl(t);
    return e.stroke = e.fill = e.lineWidth = null, e;
  }, Jg = _t(), _le = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._state = "ready", r._storage = Ih(), r;
    }
    return e.prototype.render = function(r, n, i, a) {
      var o = n.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(et(o, r) < 0)) {
        this.seriesModel = r, this.api = i, this.ecModel = n;
        var s = [
          "treemapZoomToNode",
          "treemapRootToNode"
        ], l = sd(a, s, r), u = a && a.type, c = r.layoutInfo, h = !this._oldTree, f = this._storage, d = u === "treemapRootToNode" && l && f ? {
          rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, p = this._giveContainerGroup(c), v = r.get("animation"), g = this._doRender(p, r, d);
        v && !h && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, g, r, d) : g.renderFinally(), this._resetController(i), this._renderBreadcrumb(r, i, l);
      }
    }, e.prototype._giveContainerGroup = function(r) {
      var n = this._containerGroup;
      return n || (n = this._containerGroup = new fw(), this._initEvents(n), this.group.add(n)), n.x = r.x, n.y = r.y, n;
    }, e.prototype._doRender = function(r, n, i) {
      var a = n.getData().tree, o = this._oldTree, s = Ih(), l = Ih(), u = this._storage, c = [];
      function h(y, _, b, w) {
        return ble(n, l, u, i, s, c, y, _, b, w);
      }
      v(a.root ? [
        a.root
      ] : [], o && o.root ? [
        o.root
      ] : [], r, a === o || !o, 0);
      var f = g(u);
      if (this._oldTree = a, this._storage = l, this._controllerHost) {
        var d = this.seriesModel.layoutInfo, p = a.root.getLayout();
        p.width === d.width && p.height === d.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: s,
        willDeleteEls: f,
        renderFinally: m
      };
      function v(y, _, b, w, x) {
        w ? (_ = y, $(y, function(I, M) {
          !I.isRemoved() && A(M, M);
        })) : new vo(_, y, T, T).add(A).update(A).remove(Ye(A, null)).execute();
        function T(I) {
          return I.getId();
        }
        function A(I, M) {
          var k = I != null ? y[I] : null, B = M != null ? _[M] : null, L = h(k, B, b, x);
          L && v(k && k.viewChildren || [], B && B.viewChildren || [], L, w, x + 1);
        }
      }
      function g(y) {
        var _ = Ih();
        return y && $(y, function(b, w) {
          var x = _[w];
          $(b, function(T) {
            T && (x.push(T), Jg(T).willDelete = true);
          });
        }), _;
      }
      function m() {
        $(f, function(y) {
          $(y, function(_) {
            _.parent && _.parent.remove(_);
          });
        }), $(c, function(y) {
          y.invisible = true, y.dirty();
        });
      }
    }, e.prototype._doAnimation = function(r, n, i, a) {
      var o = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (De(o) ? 0 : o) || 0, u = (De(s) ? null : s) || "cubicOut", c = vle();
      $(n.willDeleteEls, function(h, f) {
        $(h, function(d, p) {
          if (!d.invisible) {
            var v = d.parent, g, m = Jg(v);
            if (a && a.direction === "drillDown") g = v === a.rootNodeGroup ? {
              shape: {
                x: 0,
                y: 0,
                width: m.nodeWidth,
                height: m.nodeHeight
              },
              style: {
                opacity: 0
              }
            } : {
              style: {
                opacity: 0
              }
            };
            else {
              var y = 0, _ = 0;
              m.willDelete || (y = m.nodeWidth / 2, _ = m.nodeHeight / 2), g = f === "nodeGroup" ? {
                x: y,
                y: _,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: _,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            g && c.add(d, g, l, 0, u);
          }
        });
      }), $(this._storage, function(h, f) {
        $(h, function(d, p) {
          var v = n.lastsForAnimation[f][p], g = {};
          v && (d instanceof Be ? v.oldX != null && (g.x = d.x, g.y = d.y, d.x = v.oldX, d.y = v.oldY) : (v.oldShape && (g.shape = te({}, d.shape), d.setShape(v.oldShape)), v.fadein ? (d.setStyle("opacity", 0), g.style = {
            opacity: 1
          }) : d.style.opacity !== 1 && (g.style = {
            opacity: 1
          })), c.add(d, g, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(_e(function() {
        this._state = "ready", n.renderFinally();
      }, this)).start();
    }, e.prototype._resetController = function(r) {
      var n = this._controller, i = this._controllerHost;
      i || (this._controllerHost = {
        target: this.group
      }, i = this._controllerHost), n || (n = this._controller = new qd(r.getZr()), n.enable(this.seriesModel.get("roam")), i.zoomLimit = this.seriesModel.get("scaleLimit"), i.zoom = this.seriesModel.get("zoom"), n.on("pan", _e(this._onPan, this)), n.on("zoom", _e(this._onZoom, this)));
      var a = new Ze(0, 0, r.getWidth(), r.getHeight());
      n.setPointerChecker(function(o, s, l) {
        return a.contain(s, l);
      });
    }, e.prototype._clearController = function() {
      var r = this._controller;
      this._controllerHost = null, r && (r.dispose(), r = null);
    }, e.prototype._onPan = function(r) {
      if (this._state !== "animating" && (Math.abs(r.dx) > DP || Math.abs(r.dy) > DP)) {
        var n = this.seriesModel.getData().tree.root;
        if (!n) return;
        var i = n.getLayout();
        if (!i) return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + r.dx,
            y: i.y + r.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, e.prototype._onZoom = function(r) {
      var n = r.originX, i = r.originY, a = r.scale;
      if (this._state !== "animating") {
        var o = this.seriesModel.getData().tree.root;
        if (!o) return;
        var s = o.getLayout();
        if (!s) return;
        var l = new Ze(s.x, s.y, s.width, s.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var h = c.zoom = c.zoom || 1;
        if (h *= a, u) {
          var f = u.min || 0, d = u.max || 1 / 0;
          h = Math.max(Math.min(d, h), f);
        }
        var p = h / c.zoom;
        c.zoom = h;
        var v = this.seriesModel.layoutInfo;
        n -= v.x, i -= v.y;
        var g = Hn();
        Pa(g, g, [
          -n,
          -i
        ]), QS(g, g, [
          p,
          p
        ]), Pa(g, g, [
          n,
          i
        ]), l.applyTransform(g), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, e.prototype._initEvents = function(r) {
      var n = this;
      r.on("click", function(i) {
        if (n._state === "ready") {
          var a = n.seriesModel.get("nodeClick", true);
          if (a) {
            var o = n.findTarget(i.offsetX, i.offsetY);
            if (o) {
              var s = o.node;
              if (s.getLayout().isLeafRoot) n._rootToNode(o);
              else if (a === "zoomToNode") n._zoomToNode(o);
              else if (a === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", true), c = l.get("target", true) || "blank";
                u && Ng(u, c);
              }
            }
          }
        }
      }, this);
    }, e.prototype._renderBreadcrumb = function(r, n, i) {
      var a = this;
      i || (i = r.get("leafDepth", true) != null ? {
        node: r.getViewRoot()
      } : this.findTarget(n.getWidth() / 2, n.getHeight() / 2), i || (i = {
        node: r.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new hle(this.group))).render(r, n, i.node, function(o) {
        a._state !== "animating" && (l2(r.getViewRoot(), o) ? a._rootToNode({
          node: o
        }) : a._zoomToNode({
          node: o
        }));
      });
    }, e.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = Ih(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, e.prototype.dispose = function() {
      this._clearController();
    }, e.prototype._zoomToNode = function(r) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r.node
      });
    }, e.prototype._rootToNode = function(r) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r.node
      });
    }, e.prototype.findTarget = function(r, n) {
      var i, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(o) {
        var s = this._storage.background[o.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(r, n), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height) i = {
            node: o,
            offsetX: l[0],
            offsetY: l[1]
          };
          else return false;
        }
      }, this), i;
    }, e.type = "treemap", e;
  }(Ft);
  function Ih() {
    return {
      nodeGroup: [],
      background: [],
      content: []
    };
  }
  function ble(t, e, r, n, i, a, o, s, l, u) {
    if (!o) return;
    var c = o.getLayout(), h = t.getData(), f = o.getModel();
    if (h.setItemGraphicEl(o.dataIndex, null), !c || !c.isInView) return;
    var d = c.width, p = c.height, v = c.borderWidth, g = c.invisible, m = o.getRawIndex(), y = s && s.getRawIndex(), _ = o.viewChildren, b = c.upperHeight, w = _ && _.length, x = f.getModel("itemStyle"), T = f.getModel([
      "emphasis",
      "itemStyle"
    ]), A = f.getModel([
      "blur",
      "itemStyle"
    ]), I = f.getModel([
      "select",
      "itemStyle"
    ]), M = x.get("borderRadius") || 0, k = ee("nodeGroup", fw);
    if (!k) return;
    if (l.add(k), k.x = c.x || 0, k.y = c.y || 0, k.markRedraw(), Jg(k).nodeWidth = d, Jg(k).nodeHeight = p, c.isAboveViewRoot) return k;
    var B = ee("background", MP, u, mle);
    B && H(k, B, w && c.upperLabelHeight);
    var L = f.getModel("emphasis"), z = L.get("focus"), F = L.get("blurScope"), E = L.get("disabled"), O = z === "ancestor" ? o.getAncestorsIndices() : z === "descendant" ? o.getDescendantIndices() : z;
    if (w) Xf(k) && Tl(k, false), B && (Tl(B, !E), h.setItemGraphicEl(o.dataIndex, B), kx(B, O, F));
    else {
      var N = ee("content", MP, u, yle);
      N && G(k, N), B.disableMorphing = true, B && Xf(B) && Tl(B, false), Tl(k, !E), h.setItemGraphicEl(o.dataIndex, k);
      var V = f.getShallow("cursor");
      V && N.attr("cursor", V), kx(k, O, F);
    }
    return k;
    function H(le, ue, ye) {
      var ve = Ge(ue);
      if (ve.dataIndex = o.dataIndex, ve.seriesIndex = t.seriesIndex, ue.setShape({
        x: 0,
        y: 0,
        width: d,
        height: p,
        r: M
      }), g) Y(ue);
      else {
        ue.invisible = false;
        var Se = o.getVisual("style"), Qe = Se.stroke, Xe = PP(x);
        Xe.fill = Qe;
        var be = sl(T);
        be.fill = T.get("borderColor");
        var ke = sl(A);
        ke.fill = A.get("borderColor");
        var Vt = sl(I);
        if (Vt.fill = I.get("borderColor"), ye) {
          var X = d - 2 * v;
          U(ue, Qe, Se.opacity, {
            x: v,
            y: 0,
            width: X,
            height: b
          });
        } else ue.removeTextContent();
        ue.setStyle(Xe), ue.ensureState("emphasis").style = be, ue.ensureState("blur").style = ke, ue.ensureState("select").style = Vt, Xl(ue);
      }
      le.add(ue);
    }
    function G(le, ue) {
      var ye = Ge(ue);
      ye.dataIndex = o.dataIndex, ye.seriesIndex = t.seriesIndex;
      var ve = Math.max(d - 2 * v, 0), Se = Math.max(p - 2 * v, 0);
      if (ue.culling = true, ue.setShape({
        x: v,
        y: v,
        width: ve,
        height: Se,
        r: M
      }), g) Y(ue);
      else {
        ue.invisible = false;
        var Qe = o.getVisual("style"), Xe = Qe.fill, be = PP(x);
        be.fill = Xe, be.decal = Qe.decal;
        var ke = sl(T), Vt = sl(A), X = sl(I);
        U(ue, Xe, Qe.opacity, null), ue.setStyle(be), ue.ensureState("emphasis").style = ke, ue.ensureState("blur").style = Vt, ue.ensureState("select").style = X, Xl(ue);
      }
      le.add(ue);
    }
    function Y(le) {
      !le.invisible && a.push(le);
    }
    function U(le, ue, ye, ve) {
      var Se = f.getModel(ve ? kP : EP), Qe = xr(f.get("name"), null), Xe = Se.getShallow("show");
      Xr(le, Lr(f, ve ? kP : EP), {
        defaultText: Xe ? Qe : null,
        inheritColor: ue,
        defaultOpacity: ye,
        labelFetcher: t,
        labelDataIndex: o.dataIndex
      });
      var be = le.getTextContent();
      if (be) {
        var ke = be.style, Vt = jS(ke.padding || 0);
        ve && (le.setTextConfig({
          layoutRect: ve
        }), be.disableLabelLayout = true), be.beforeUpdate = function() {
          var j = Math.max((ve ? ve.width : le.shape.width) - Vt[1] - Vt[3], 0), he = Math.max((ve ? ve.height : le.shape.height) - Vt[0] - Vt[2], 0);
          (ke.width !== j || ke.height !== he) && be.setStyle({
            width: j,
            height: he
          });
        }, ke.truncateMinChar = 2, ke.lineOverflow = "truncate", Z(ke, ve, c);
        var X = be.getState("emphasis");
        Z(X ? X.style : null, ve, c);
      }
    }
    function Z(le, ue, ye) {
      var ve = le ? le.text : null;
      if (!ue && ye.isLeafRoot && ve != null) {
        var Se = t.get("drillDownIcon", true);
        le.text = Se ? Se + " " + ve : ve;
      }
    }
    function ee(le, ue, ye, ve) {
      var Se = y != null && r[le][y], Qe = i[le];
      return Se ? (r[le][y] = null, we(Qe, Se)) : g || (Se = new ue(), Se instanceof bi && (Se.z2 = xle(ye, ve)), Te(Qe, Se)), e[le][m] = Se;
    }
    function we(le, ue) {
      var ye = le[m] = {};
      ue instanceof fw ? (ye.oldX = ue.x, ye.oldY = ue.y) : ye.oldShape = te({}, ue.shape);
    }
    function Te(le, ue) {
      var ye = le[m] = {}, ve = o.parentNode, Se = ue instanceof Be;
      if (ve && (!n || n.direction === "drillDown")) {
        var Qe = 0, Xe = 0, be = i.background[ve.getRawIndex()];
        !n && be && be.oldShape && (Qe = be.oldShape.width, Xe = be.oldShape.height), Se ? (ye.oldX = 0, ye.oldY = Xe) : ye.oldShape = {
          x: Qe,
          y: Xe,
          width: 0,
          height: 0
        };
      }
      ye.fadein = !Se;
    }
  }
  function xle(t, e) {
    return t * gle + e;
  }
  var ld = $, wle = Le, em = -1, Er = function() {
    function t(e) {
      var r = e.mappingMethod, n = e.type, i = this.option = Oe(e);
      this.type = n, this.mappingMethod = r, this._normalizeData = Cle[r];
      var a = t.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[r], r === "piecewise" ? (w_(i), Sle(i)) : r === "category" ? i.categories ? Tle(i) : w_(i, true) : (bn(r !== "linear" || i.dataExtent), w_(i));
    }
    return t.prototype.mapValueToVisual = function(e) {
      var r = this._normalizeData(e);
      return this._normalizedToVisual(r, e);
    }, t.prototype.getNormalizer = function() {
      return _e(this._normalizeData, this);
    }, t.listVisualTypes = function() {
      return gt(t.visualHandlers);
    }, t.isValidType = function(e) {
      return t.visualHandlers.hasOwnProperty(e);
    }, t.eachVisual = function(e, r, n) {
      Le(e) ? $(e, r, n) : r.call(n, e);
    }, t.mapVisual = function(e, r, n) {
      var i, a = ae(e) ? [] : Le(e) ? {} : (i = true, null);
      return t.eachVisual(e, function(o, s) {
        var l = r.call(n, o, s);
        i ? a = l : a[s] = l;
      }), a;
    }, t.retrieveVisuals = function(e) {
      var r = {}, n;
      return e && ld(t.visualHandlers, function(i, a) {
        e.hasOwnProperty(a) && (r[a] = e[a], n = true);
      }), n ? r : null;
    }, t.prepareVisualTypes = function(e) {
      if (ae(e)) e = e.slice();
      else if (wle(e)) {
        var r = [];
        ld(e, function(n, i) {
          r.push(i);
        }), e = r;
      } else return [];
      return e.sort(function(n, i) {
        return i === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), e;
    }, t.dependsOn = function(e, r) {
      return r === "color" ? !!(e && e.indexOf(r) === 0) : e === r;
    }, t.findPieceIndex = function(e, r, n) {
      for (var i, a = 1 / 0, o = 0, s = r.length; o < s; o++) {
        var l = r[o].value;
        if (l != null) {
          if (l === e || me(l) && l === e + "") return o;
          n && f(l, o);
        }
      }
      for (var o = 0, s = r.length; o < s; o++) {
        var u = r[o], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (ev(h[1], e, c[1])) return o;
          } else if (c[1] === 1 / 0) {
            if (ev(h[0], c[0], e)) return o;
          } else if (ev(h[0], c[0], e) && ev(h[1], e, c[1])) return o;
          n && f(c[0], o), n && f(c[1], o);
        }
      }
      if (n) return e === 1 / 0 ? r.length - 1 : e === -1 / 0 ? 0 : i;
      function f(d, p) {
        var v = Math.abs(d - e);
        v < a && (a = v, i = p);
      }
    }, t.visualHandlers = {
      color: {
        applyVisual: Mh("color"),
        getColorMapper: function() {
          var e = this.option;
          return _e(e.mappingMethod === "category" ? function(r, n) {
            return !n && (r = this._normalizeData(r)), of.call(this, r);
          } : function(r, n, i) {
            var a = !!i;
            return !n && (r = this._normalizeData(r)), i = r0(r, e.parsedVisual, i), a ? i : ao(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(e) {
            return ao(r0(e, this.option.parsedVisual), "rgba");
          },
          category: of,
          piecewise: function(e, r) {
            var n = pw.call(this, r);
            return n == null && (n = ao(r0(e, this.option.parsedVisual), "rgba")), n;
          },
          fixed: ll
        }
      },
      colorHue: Jp(function(e, r) {
        return _f(e, r);
      }),
      colorSaturation: Jp(function(e, r) {
        return _f(e, null, r);
      }),
      colorLightness: Jp(function(e, r) {
        return _f(e, null, null, r);
      }),
      colorAlpha: Jp(function(e, r) {
        return Cg(e, r);
      }),
      decal: {
        applyVisual: Mh("decal"),
        _normalizedToVisual: {
          linear: null,
          category: of,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: Mh("opacity"),
        _normalizedToVisual: dw([
          0,
          1
        ])
      },
      liftZ: {
        applyVisual: Mh("liftZ"),
        _normalizedToVisual: {
          linear: ll,
          category: ll,
          piecewise: ll,
          fixed: ll
        }
      },
      symbol: {
        applyVisual: function(e, r, n) {
          var i = this.mapValueToVisual(e);
          n("symbol", i);
        },
        _normalizedToVisual: {
          linear: LP,
          category: of,
          piecewise: function(e, r) {
            var n = pw.call(this, r);
            return n == null && (n = LP.call(this, e)), n;
          },
          fixed: ll
        }
      },
      symbolSize: {
        applyVisual: Mh("symbolSize"),
        _normalizedToVisual: dw([
          0,
          1
        ])
      }
    }, t;
  }();
  function Sle(t) {
    var e = t.pieceList;
    t.hasSpecialVisual = false, $(e, function(r, n) {
      r.originIndex = n, r.visual != null && (t.hasSpecialVisual = true);
    });
  }
  function Tle(t) {
    var e = t.categories, r = t.categoryMap = {}, n = t.visual;
    if (ld(e, function(o, s) {
      r[o] = s;
    }), !ae(n)) {
      var i = [];
      Le(n) ? ld(n, function(o, s) {
        var l = r[s];
        i[l ?? em] = o;
      }) : i[em] = n, n = uW(t, i);
    }
    for (var a = e.length - 1; a >= 0; a--) n[a] == null && (delete r[e[a]], e.pop());
  }
  function w_(t, e) {
    var r = t.visual, n = [];
    Le(r) ? ld(r, function(a) {
      n.push(a);
    }) : r != null && n.push(r);
    var i = {
      color: 1,
      symbol: 1
    };
    !e && n.length === 1 && !i.hasOwnProperty(t.type) && (n[1] = n[0]), uW(t, n);
  }
  function Jp(t) {
    return {
      applyVisual: function(e, r, n) {
        var i = this.mapValueToVisual(e);
        n("color", t(r("color"), i));
      },
      _normalizedToVisual: dw([
        0,
        1
      ])
    };
  }
  function LP(t) {
    var e = this.option.visual;
    return e[Math.round(Et(t, [
      0,
      1
    ], [
      0,
      e.length - 1
    ], true))] || {};
  }
  function Mh(t) {
    return function(e, r, n) {
      n(t, this.mapValueToVisual(e));
    };
  }
  function of(t) {
    var e = this.option.visual;
    return e[this.option.loop && t !== em ? t % e.length : t];
  }
  function ll() {
    return this.option.visual[0];
  }
  function dw(t) {
    return {
      linear: function(e) {
        return Et(e, t, this.option.visual, true);
      },
      category: of,
      piecewise: function(e, r) {
        var n = pw.call(this, r);
        return n == null && (n = Et(e, t, this.option.visual, true)), n;
      },
      fixed: ll
    };
  }
  function pw(t) {
    var e = this.option, r = e.pieceList;
    if (e.hasSpecialVisual) {
      var n = Er.findPieceIndex(t, r), i = r[n];
      if (i && i.visual) return i.visual[this.type];
    }
  }
  function uW(t, e) {
    return t.visual = e, t.type === "color" && (t.parsedVisual = oe(e, function(r) {
      var n = Un(r);
      return n || [
        0,
        0,
        0,
        1
      ];
    })), e;
  }
  var Cle = {
    linear: function(t) {
      return Et(t, this.option.dataExtent, [
        0,
        1
      ], true);
    },
    piecewise: function(t) {
      var e = this.option.pieceList, r = Er.findPieceIndex(t, e, true);
      if (r != null) return Et(r, [
        0,
        e.length - 1
      ], [
        0,
        1
      ], true);
    },
    category: function(t) {
      var e = this.option.categories ? this.option.categoryMap[t] : t;
      return e ?? em;
    },
    fixed: dr
  };
  function ev(t, e, r) {
    return t ? e <= r : e < r;
  }
  var Ale = "itemStyle", cW = _t();
  const Ile = {
    seriesType: "treemap",
    reset: function(t) {
      var e = t.getData().tree, r = e.root;
      r.isRemoved() || hW(r, {}, t.getViewRoot().getAncestors(), t);
    }
  };
  function hW(t, e, r, n) {
    var i = t.getModel(), a = t.getLayout(), o = t.hostTree.data;
    if (!(!a || a.invisible || !a.isInView)) {
      var s = i.getModel(Ale), l = Mle(s, e, n), u = o.ensureUniqueItemVisual(t.dataIndex, "style"), c = s.get("borderColor"), h = s.get("borderColorSaturation"), f;
      h != null && (f = $P(l), c = Dle(h, f)), u.stroke = c;
      var d = t.viewChildren;
      if (!d || !d.length) f = $P(l), u.fill = f;
      else {
        var p = Ele(t, i, a, s, l, d);
        $(d, function(v, g) {
          if (v.depth >= r.length || v === r[v.depth]) {
            var m = kle(i, l, v, g, p, n);
            hW(v, m, r, n);
          }
        });
      }
    }
  }
  function Mle(t, e, r) {
    var n = te({}, e), i = r.designatedVisualItemStyle;
    return $([
      "color",
      "colorAlpha",
      "colorSaturation"
    ], function(a) {
      i[a] = e[a];
      var o = t.get(a);
      i[a] = null, o != null && (n[a] = o);
    }), n;
  }
  function $P(t) {
    var e = S_(t, "color");
    if (e) {
      var r = S_(t, "colorAlpha"), n = S_(t, "colorSaturation");
      return n && (e = _f(e, null, null, n)), r && (e = Cg(e, r)), e;
    }
  }
  function Dle(t, e) {
    return e != null ? _f(e, null, null, t) : null;
  }
  function S_(t, e) {
    var r = t[e];
    if (r != null && r !== "none") return r;
  }
  function Ele(t, e, r, n, i, a) {
    if (!(!a || !a.length)) {
      var o = T_(e, "color") || i.color != null && i.color !== "none" && (T_(e, "colorAlpha") || T_(e, "colorSaturation"));
      if (o) {
        var s = e.get("visualMin"), l = e.get("visualMax"), u = r.dataExtent.slice();
        s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
        var c = e.get("colorMappingBy"), h = {
          type: o.name,
          dataExtent: u,
          visual: o.range
        };
        h.type === "color" && (c === "index" || c === "id") ? (h.mappingMethod = "category", h.loop = true) : h.mappingMethod = "linear";
        var f = new Er(h);
        return cW(f).drColorMappingBy = c, f;
      }
    }
  }
  function T_(t, e) {
    var r = t.get(e);
    return ae(r) && r.length ? {
      name: e,
      range: r
    } : null;
  }
  function kle(t, e, r, n, i, a) {
    var o = te({}, e);
    if (i) {
      var s = i.type, l = s === "color" && cW(i).drColorMappingBy, u = l === "index" ? n : l === "id" ? a.mapIdToIndex(r.getId()) : r.getValue(t.get("visualDimension"));
      o[s] = i.mapValueToVisual(u);
    }
    return o;
  }
  var ud = Math.max, tm = Math.min, RP = Fr, u2 = $, fW = [
    "itemStyle",
    "borderWidth"
  ], Ple = [
    "itemStyle",
    "gapWidth"
  ], Lle = [
    "upperLabel",
    "show"
  ], $le = [
    "upperLabel",
    "height"
  ];
  const Rle = {
    seriesType: "treemap",
    reset: function(t, e, r, n) {
      var i = r.getWidth(), a = r.getHeight(), o = t.option, s = Tr(t.getBoxLayoutParams(), {
        width: r.getWidth(),
        height: r.getHeight()
      }), l = o.size || [], u = pe(RP(s.width, l[0]), i), c = pe(RP(s.height, l[1]), a), h = n && n.type, f = [
        "treemapZoomToNode",
        "treemapRootToNode"
      ], d = sd(n, f, t), p = h === "treemapRender" || h === "treemapMove" ? n.rootRect : null, v = t.getViewRoot(), g = oW(v);
      if (h !== "treemapMove") {
        var m = h === "treemapZoomToNode" ? Vle(t, d, v, u, c) : p ? [
          p.width,
          p.height
        ] : [
          u,
          c
        ], y = o.sort;
        y && y !== "asc" && y !== "desc" && (y = "desc");
        var _ = {
          squareRatio: o.squareRatio,
          sort: y,
          leafDepth: o.leafDepth
        };
        v.hostTree.clearLayouts();
        var b = {
          x: 0,
          y: 0,
          width: m[0],
          height: m[1],
          area: m[0] * m[1]
        };
        v.setLayout(b), dW(v, _, false, 0), b = v.getLayout(), u2(g, function(x, T) {
          var A = (g[T + 1] || v).getValue();
          x.setLayout(te({
            dataExtent: [
              A,
              A
            ],
            borderWidth: 0,
            upperHeight: 0
          }, b));
        });
      }
      var w = t.getData().tree.root;
      w.setLayout(Gle(s, p, d), true), t.setLayoutInfo(s), pW(w, new Ze(-s.x, -s.y, i, a), g, v, 0);
    }
  };
  function dW(t, e, r, n) {
    var i, a;
    if (!t.isRemoved()) {
      var o = t.getLayout();
      i = o.width, a = o.height;
      var s = t.getModel(), l = s.get(fW), u = s.get(Ple) / 2, c = vW(s), h = Math.max(l, c), f = l - u, d = h - u;
      t.setLayout({
        borderWidth: l,
        upperHeight: h,
        upperLabelHeight: c
      }, true), i = ud(i - 2 * f, 0), a = ud(a - f - d, 0);
      var p = i * a, v = Ole(t, s, p, e, r, n);
      if (v.length) {
        var g = {
          x: f,
          y: d,
          width: i,
          height: a
        }, m = tm(i, a), y = 1 / 0, _ = [];
        _.area = 0;
        for (var b = 0, w = v.length; b < w; ) {
          var x = v[b];
          _.push(x), _.area += x.getLayout().area;
          var T = Fle(_, m, e.squareRatio);
          T <= y ? (b++, y = T) : (_.area -= _.pop().getLayout().area, OP(_, m, g, u, false), m = tm(g.width, g.height), _.length = _.area = 0, y = 1 / 0);
        }
        if (_.length && OP(_, m, g, u, true), !r) {
          var A = s.get("childrenVisibleMin");
          A != null && p < A && (r = true);
        }
        for (var b = 0, w = v.length; b < w; b++) dW(v[b], e, r, n + 1);
      }
    }
  }
  function Ole(t, e, r, n, i, a) {
    var o = t.children || [], s = n.sort;
    s !== "asc" && s !== "desc" && (s = null);
    var l = n.leafDepth != null && n.leafDepth <= a;
    if (i && !l) return t.viewChildren = [];
    o = Dt(o, function(d) {
      return !d.isRemoved();
    }), Ble(o, s);
    var u = zle(e, o, s);
    if (u.sum === 0) return t.viewChildren = [];
    if (u.sum = Nle(e, r, u.sum, s, o), u.sum === 0) return t.viewChildren = [];
    for (var c = 0, h = o.length; c < h; c++) {
      var f = o[c].getValue() / u.sum * r;
      o[c].setLayout({
        area: f
      });
    }
    return l && (o.length && t.setLayout({
      isLeafRoot: true
    }, true), o.length = 0), t.viewChildren = o, t.setLayout({
      dataExtent: u.dataExtent
    }, true), o;
  }
  function Nle(t, e, r, n, i) {
    if (!n) return r;
    for (var a = t.get("visibleMin"), o = i.length, s = o, l = o - 1; l >= 0; l--) {
      var u = i[n === "asc" ? o - l - 1 : l].getValue();
      u / r * e < a && (s = l, r -= u);
    }
    return n === "asc" ? i.splice(0, o - s) : i.splice(s, o - s), r;
  }
  function Ble(t, e) {
    return e && t.sort(function(r, n) {
      var i = e === "asc" ? r.getValue() - n.getValue() : n.getValue() - r.getValue();
      return i === 0 ? e === "asc" ? r.dataIndex - n.dataIndex : n.dataIndex - r.dataIndex : i;
    }), t;
  }
  function zle(t, e, r) {
    for (var n = 0, i = 0, a = e.length; i < a; i++) n += e[i].getValue();
    var o = t.get("visualDimension"), s;
    return !e || !e.length ? s = [
      NaN,
      NaN
    ] : o === "value" && r ? (s = [
      e[e.length - 1].getValue(),
      e[0].getValue()
    ], r === "asc" && s.reverse()) : (s = [
      1 / 0,
      -1 / 0
    ], u2(e, function(l) {
      var u = l.getValue(o);
      u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
    })), {
      sum: n,
      dataExtent: s
    };
  }
  function Fle(t, e, r) {
    for (var n = 0, i = 1 / 0, a = 0, o = void 0, s = t.length; a < s; a++) o = t[a].getLayout().area, o && (o < i && (i = o), o > n && (n = o));
    var l = t.area * t.area, u = e * e * r;
    return l ? ud(u * n / l, l / (u * i)) : 1 / 0;
  }
  function OP(t, e, r, n, i) {
    var a = e === r.width ? 0 : 1, o = 1 - a, s = [
      "x",
      "y"
    ], l = [
      "width",
      "height"
    ], u = r[s[a]], c = e ? t.area / e : 0;
    (i || c > r[l[o]]) && (c = r[l[o]]);
    for (var h = 0, f = t.length; h < f; h++) {
      var d = t[h], p = {}, v = c ? d.getLayout().area / c : 0, g = p[l[o]] = ud(c - 2 * n, 0), m = r[s[a]] + r[l[a]] - u, y = h === f - 1 || m < v ? m : v, _ = p[l[a]] = ud(y - 2 * n, 0);
      p[s[o]] = r[s[o]] + tm(n, g / 2), p[s[a]] = u + tm(n, _ / 2), u += y, d.setLayout(p, true);
    }
    r[s[o]] += c, r[l[o]] -= c;
  }
  function Vle(t, e, r, n, i) {
    var a = (e || {}).node, o = [
      n,
      i
    ];
    if (!a || a === r) return o;
    for (var s, l = n * i, u = l * t.option.zoomToNodeRatio; s = a.parentNode; ) {
      for (var c = 0, h = s.children, f = 0, d = h.length; f < d; f++) c += h[f].getValue();
      var p = a.getValue();
      if (p === 0) return o;
      u *= c / p;
      var v = s.getModel(), g = v.get(fW), m = Math.max(g, vW(v));
      u += 4 * g * g + (3 * g + m) * Math.pow(u, 0.5), u > jM && (u = jM), a = s;
    }
    u < l && (u = l);
    var y = Math.pow(u / l, 0.5);
    return [
      n * y,
      i * y
    ];
  }
  function Gle(t, e, r) {
    if (e) return {
      x: e.x,
      y: e.y
    };
    var n = {
      x: 0,
      y: 0
    };
    if (!r) return n;
    var i = r.node, a = i.getLayout();
    if (!a) return n;
    for (var o = [
      a.width / 2,
      a.height / 2
    ], s = i; s; ) {
      var l = s.getLayout();
      o[0] += l.x, o[1] += l.y, s = s.parentNode;
    }
    return {
      x: t.width / 2 - o[0],
      y: t.height / 2 - o[1]
    };
  }
  function pW(t, e, r, n, i) {
    var a = t.getLayout(), o = r[i], s = o && o === t;
    if (!(o && !s || i === r.length && t !== n)) {
      t.setLayout({
        isInView: true,
        invisible: !s && !e.intersect(a),
        isAboveViewRoot: s
      }, true);
      var l = new Ze(e.x - a.x, e.y - a.y, e.width, e.height);
      u2(t.viewChildren || [], function(u) {
        pW(u, l, r, n, i + 1);
      });
    }
  }
  function vW(t) {
    return t.get(Lle) ? t.get($le) : 0;
  }
  function Wle(t) {
    t.registerSeriesModel(lle), t.registerChartView(_le), t.registerVisual(Ile), t.registerLayout(Rle), sle(t);
  }
  function Hle(t) {
    var e = t.findComponents({
      mainType: "legend"
    });
    !e || !e.length || t.eachSeriesByType("graph", function(r) {
      var n = r.getCategoriesData(), i = r.getGraph(), a = i.data, o = n.mapArray(n.getName);
      a.filterSelf(function(s) {
        var l = a.getItemModel(s), u = l.getShallow("category");
        if (u != null) {
          xt(u) && (u = o[u]);
          for (var c = 0; c < e.length; c++) if (!e[c].isSelected(u)) return false;
        }
        return true;
      });
    });
  }
  function Ule(t) {
    var e = {};
    t.eachSeriesByType("graph", function(r) {
      var n = r.getCategoriesData(), i = r.getData(), a = {};
      n.each(function(o) {
        var s = n.getName(o);
        a["ec-" + s] = o;
        var l = n.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
        u.fill || (u.fill = r.getColorFromPalette(s, e)), n.setItemVisual(o, "style", u);
        for (var c = [
          "symbol",
          "symbolSize",
          "symbolKeepAspect"
        ], h = 0; h < c.length; h++) {
          var f = l.getShallow(c[h], true);
          f != null && n.setItemVisual(o, c[h], f);
        }
      }), n.count() && i.each(function(o) {
        var s = i.getItemModel(o), l = s.getShallow("category");
        if (l != null) {
          me(l) && (l = a["ec-" + l]);
          var u = n.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(o, "style");
          te(c, u);
          for (var h = [
            "symbol",
            "symbolSize",
            "symbolKeepAspect"
          ], f = 0; f < h.length; f++) i.setItemVisual(o, h[f], n.getItemVisual(l, h[f]));
        }
      });
    });
  }
  function tv(t) {
    return t instanceof Array || (t = [
      t,
      t
    ]), t;
  }
  function Yle(t) {
    t.eachSeriesByType("graph", function(e) {
      var r = e.getGraph(), n = e.getEdgeData(), i = tv(e.get("edgeSymbol")), a = tv(e.get("edgeSymbolSize"));
      n.setVisual("fromSymbol", i && i[0]), n.setVisual("toSymbol", i && i[1]), n.setVisual("fromSymbolSize", a && a[0]), n.setVisual("toSymbolSize", a && a[1]), n.setVisual("style", e.getModel("lineStyle").getLineStyle()), n.each(function(o) {
        var s = n.getItemModel(o), l = r.getEdgeByIndex(o), u = tv(s.getShallow("symbol", true)), c = tv(s.getShallow("symbolSize", true)), h = s.getModel("lineStyle").getLineStyle(), f = n.ensureUniqueItemVisual(o, "style");
        switch (te(f, h), f.stroke) {
          case "source": {
            var d = l.node1.getVisual("style");
            f.stroke = d && d.fill;
            break;
          }
          case "target": {
            var d = l.node2.getVisual("style");
            f.stroke = d && d.fill;
            break;
          }
        }
        u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
      });
    });
  }
  var vw = "-->", my = function(t) {
    return t.get("autoCurveness") || null;
  }, gW = function(t, e) {
    var r = my(t), n = 20, i = [];
    if (xt(r)) n = r;
    else if (ae(r)) {
      t.__curvenessList = r;
      return;
    }
    e > n && (n = e);
    var a = n % 2 ? n + 2 : n + 3;
    i = [];
    for (var o = 0; o < a; o++) i.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
    t.__curvenessList = i;
  }, cd = function(t, e, r) {
    var n = [
      t.id,
      t.dataIndex
    ].join("."), i = [
      e.id,
      e.dataIndex
    ].join(".");
    return [
      r.uid,
      n,
      i
    ].join(vw);
  }, mW = function(t) {
    var e = t.split(vw);
    return [
      e[0],
      e[2],
      e[1]
    ].join(vw);
  }, qle = function(t, e) {
    var r = cd(t.node1, t.node2, e);
    return e.__edgeMap[r];
  }, Xle = function(t, e) {
    var r = gw(cd(t.node1, t.node2, e), e), n = gw(cd(t.node2, t.node1, e), e);
    return r + n;
  }, gw = function(t, e) {
    var r = e.__edgeMap;
    return r[t] ? r[t].length : 0;
  };
  function jle(t) {
    my(t) && (t.__curvenessList = [], t.__edgeMap = {}, gW(t));
  }
  function Kle(t, e, r, n) {
    if (my(r)) {
      var i = cd(t, e, r), a = r.__edgeMap, o = a[mW(i)];
      a[i] && !o ? a[i].isForward = true : o && a[i] && (o.isForward = true, a[i].isForward = false), a[i] = a[i] || [], a[i].push(n);
    }
  }
  function c2(t, e, r, n) {
    var i = my(e), a = ae(i);
    if (!i) return null;
    var o = qle(t, e);
    if (!o) return null;
    for (var s = -1, l = 0; l < o.length; l++) if (o[l] === r) {
      s = l;
      break;
    }
    var u = Xle(t, e);
    gW(e, u), t.lineStyle = t.lineStyle || {};
    var c = cd(t.node1, t.node2, e), h = e.__curvenessList, f = a || u % 2 ? 0 : 1;
    if (o.isForward) return h[f + s];
    var d = mW(c), p = gw(d, e), v = h[s + p + f];
    return n ? a ? i && i[0] === 0 ? (p + f) % 2 ? v : -v : ((p % 2 ? 0 : 1) + f) % 2 ? v : -v : (p + f) % 2 ? v : -v : h[s + p + f];
  }
  function yW(t) {
    var e = t.coordinateSystem;
    if (!(e && e.type !== "view")) {
      var r = t.getGraph();
      r.eachNode(function(n) {
        var i = n.getModel();
        n.setLayout([
          +i.get("x"),
          +i.get("y")
        ]);
      }), h2(r, t);
    }
  }
  function h2(t, e) {
    t.eachEdge(function(r, n) {
      var i = Aa(r.getModel().get([
        "lineStyle",
        "curveness"
      ]), -c2(r, e, n, true), 0), a = no(r.node1.getLayout()), o = no(r.node2.getLayout()), s = [
        a,
        o
      ];
      +i && s.push([
        (a[0] + o[0]) / 2 - (a[1] - o[1]) * i,
        (a[1] + o[1]) / 2 - (o[0] - a[0]) * i
      ]), r.setLayout(s);
    });
  }
  function Zle(t, e) {
    t.eachSeriesByType("graph", function(r) {
      var n = r.get("layout"), i = r.coordinateSystem;
      if (i && i.type !== "view") {
        var a = r.getData(), o = [];
        $(i.dimensions, function(f) {
          o = o.concat(a.mapDimensionsAll(f));
        });
        for (var s = 0; s < a.count(); s++) {
          for (var l = [], u = false, c = 0; c < o.length; c++) {
            var h = a.get(o[c], s);
            isNaN(h) || (u = true), l.push(h);
          }
          u ? a.setItemLayout(s, i.dataToPoint(l)) : a.setItemLayout(s, [
            NaN,
            NaN
          ]);
        }
        h2(a.graph, r);
      } else (!n || n === "none") && yW(r);
    });
  }
  function sf(t) {
    var e = t.coordinateSystem;
    if (e.type !== "view") return 1;
    var r = t.option.nodeScaleRatio, n = e.scaleX, i = e.getZoom(), a = (i - 1) * r + 1;
    return a / n;
  }
  function lf(t) {
    var e = t.getVisual("symbolSize");
    return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
  }
  var NP = Math.PI, C_ = [];
  function f2(t, e, r, n) {
    var i = t.coordinateSystem;
    if (!(i && i.type !== "view")) {
      var a = i.getBoundingRect(), o = t.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, c = Math.min(a.width, a.height) / 2, h = o.count();
      if (o.setLayout({
        cx: l,
        cy: u
      }), !!h) {
        if (r) {
          var f = i.pointToData(n), d = f[0], p = f[1], v = [
            d - l,
            p - u
          ];
          Bc(v, v), jv(v, v, c), r.setLayout([
            l + v[0],
            u + v[1]
          ], true);
          var g = t.get([
            "circular",
            "rotateLabel"
          ]);
          _W(r, g, l, u);
        }
        Qle[e](t, s, o, c, l, u, h), s.eachEdge(function(m, y) {
          var _ = Aa(m.getModel().get([
            "lineStyle",
            "curveness"
          ]), c2(m, t, y), 0), b = no(m.node1.getLayout()), w = no(m.node2.getLayout()), x, T = (b[0] + w[0]) / 2, A = (b[1] + w[1]) / 2;
          +_ && (_ *= 3, x = [
            l * _ + T * (1 - _),
            u * _ + A * (1 - _)
          ]), m.setLayout([
            b,
            w,
            x
          ]);
        });
      }
    }
  }
  var Qle = {
    value: function(t, e, r, n, i, a, o) {
      var s = 0, l = r.getSum("value"), u = Math.PI * 2 / (l || o);
      e.eachNode(function(c) {
        var h = c.getValue("value"), f = u * (l ? h : 1) / 2;
        s += f, c.setLayout([
          n * Math.cos(s) + i,
          n * Math.sin(s) + a
        ]), s += f;
      });
    },
    symbolSize: function(t, e, r, n, i, a, o) {
      var s = 0;
      C_.length = o;
      var l = sf(t);
      e.eachNode(function(h) {
        var f = lf(h);
        isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
        var d = Math.asin(f / 2 / n);
        isNaN(d) && (d = NP / 2), C_[h.dataIndex] = d, s += d * 2;
      });
      var u = (2 * NP - s) / o / 2, c = 0;
      e.eachNode(function(h) {
        var f = u + C_[h.dataIndex];
        c += f, (!h.getLayout() || !h.getLayout().fixed) && h.setLayout([
          n * Math.cos(c) + i,
          n * Math.sin(c) + a
        ]), c += f;
      });
    }
  };
  function _W(t, e, r, n) {
    var i = t.getGraphicEl();
    if (i) {
      var a = t.getModel(), o = a.get([
        "label",
        "rotate"
      ]) || 0, s = i.getSymbolPath();
      if (e) {
        var l = t.getLayout(), u = Math.atan2(l[1] - n, l[0] - r);
        u < 0 && (u = Math.PI * 2 + u);
        var c = l[0] < r;
        c && (u = u - Math.PI);
        var h = c ? "left" : "right";
        s.setTextConfig({
          rotation: -u,
          position: h,
          origin: "center"
        });
        var f = s.ensureState("emphasis");
        te(f.textConfig || (f.textConfig = {}), {
          position: h
        });
      } else s.setTextConfig({
        rotation: o *= Math.PI / 180
      });
    }
  }
  function Jle(t) {
    t.eachSeriesByType("graph", function(e) {
      e.get("layout") === "circular" && f2(e, "symbolSize");
    });
  }
  var ku = tx;
  function eue(t, e, r) {
    for (var n = t, i = e, a = r.rect, o = a.width, s = a.height, l = [
      a.x + o / 2,
      a.y + s / 2
    ], u = r.gravity == null ? 0.1 : r.gravity, c = 0; c < n.length; c++) {
      var h = n[c];
      h.p || (h.p = ru(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), h.pp = no(h.p), h.edges = null;
    }
    var f = r.friction == null ? 0.6 : r.friction, d = f, p, v;
    return {
      warmUp: function() {
        d = f * 0.8;
      },
      setFixed: function(g) {
        n[g].fixed = true;
      },
      setUnfixed: function(g) {
        n[g].fixed = false;
      },
      beforeStep: function(g) {
        p = g;
      },
      afterStep: function(g) {
        v = g;
      },
      step: function(g) {
        p && p(n, i);
        for (var m = [], y = n.length, _ = 0; _ < i.length; _++) {
          var b = i[_];
          if (!b.ignoreForceLayout) {
            var w = b.n1, x = b.n2;
            wl(m, x.p, w.p);
            var T = rx(m) - b.d, A = x.w / (w.w + x.w);
            isNaN(A) && (A = 0), Bc(m, m), !w.fixed && ku(w.p, w.p, m, A * T * d), !x.fixed && ku(x.p, x.p, m, -(1 - A) * T * d);
          }
        }
        for (var _ = 0; _ < y; _++) {
          var I = n[_];
          I.fixed || (wl(m, l, I.p), ku(I.p, I.p, m, u * d));
        }
        for (var _ = 0; _ < y; _++) for (var w = n[_], M = _ + 1; M < y; M++) {
          var x = n[M];
          wl(m, x.p, w.p);
          var T = rx(m);
          T === 0 && (CK(m, Math.random() - 0.5, Math.random() - 0.5), T = 1);
          var k = (w.rep + x.rep) / T / T;
          !w.fixed && ku(w.pp, w.pp, m, k), !x.fixed && ku(x.pp, x.pp, m, -k);
        }
        for (var B = [], _ = 0; _ < y; _++) {
          var I = n[_];
          I.fixed || (wl(B, I.p, I.pp), ku(I.p, I.p, B, d), fn(I.pp, I.p));
        }
        d = d * 0.992;
        var L = d < 0.01;
        v && v(n, i, L), g && g(L);
      }
    };
  }
  function tue(t) {
    t.eachSeriesByType("graph", function(e) {
      var r = e.coordinateSystem;
      if (!(r && r.type !== "view")) if (e.get("layout") === "force") {
        var n = e.preservedPoints || {}, i = e.getGraph(), a = i.data, o = i.edgeData, s = e.getModel("force"), l = s.get("initLayout");
        e.preservedPoints ? a.each(function(_) {
          var b = a.getId(_);
          a.setItemLayout(_, n[b] || [
            NaN,
            NaN
          ]);
        }) : !l || l === "none" ? yW(e) : l === "circular" && f2(e, "value");
        var u = a.getDataExtent("value"), c = o.getDataExtent("value"), h = s.get("repulsion"), f = s.get("edgeLength"), d = ae(h) ? h : [
          h,
          h
        ], p = ae(f) ? f : [
          f,
          f
        ];
        p = [
          p[1],
          p[0]
        ];
        var v = a.mapArray("value", function(_, b) {
          var w = a.getItemLayout(b), x = Et(_, u, d);
          return isNaN(x) && (x = (d[0] + d[1]) / 2), {
            w: x,
            rep: x,
            fixed: a.getItemModel(b).get("fixed"),
            p: !w || isNaN(w[0]) || isNaN(w[1]) ? null : w
          };
        }), g = o.mapArray("value", function(_, b) {
          var w = i.getEdgeByIndex(b), x = Et(_, c, p);
          isNaN(x) && (x = (p[0] + p[1]) / 2);
          var T = w.getModel(), A = Aa(w.getModel().get([
            "lineStyle",
            "curveness"
          ]), -c2(w, e, b, true), 0);
          return {
            n1: v[w.node1.dataIndex],
            n2: v[w.node2.dataIndex],
            d: x,
            curveness: A,
            ignoreForceLayout: T.get("ignoreForceLayout")
          };
        }), m = r.getBoundingRect(), y = eue(v, g, {
          rect: m,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(_, b) {
          for (var w = 0, x = _.length; w < x; w++) _[w].fixed && fn(_[w].p, i.getNodeByIndex(w).getLayout());
        }), y.afterStep(function(_, b, w) {
          for (var x = 0, T = _.length; x < T; x++) _[x].fixed || i.getNodeByIndex(x).setLayout(_[x].p), n[a.getId(x)] = _[x].p;
          for (var x = 0, T = b.length; x < T; x++) {
            var A = b[x], I = i.getEdgeByIndex(x), M = A.n1.p, k = A.n2.p, B = I.getLayout();
            B = B ? B.slice() : [], B[0] = B[0] || [], B[1] = B[1] || [], fn(B[0], M), fn(B[1], k), +A.curveness && (B[2] = [
              (M[0] + k[0]) / 2 - (M[1] - k[1]) * A.curveness,
              (M[1] + k[1]) / 2 - (k[0] - M[0]) * A.curveness
            ]), I.setLayout(B);
          }
        }), e.forceLayout = y, e.preservedPoints = n, y.step();
      } else e.forceLayout = null;
    });
  }
  function rue(t, e, r) {
    var n = te(t.getBoxLayoutParams(), {
      aspect: r
    });
    return Tr(n, {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function nue(t, e) {
    var r = [];
    return t.eachSeriesByType("graph", function(n) {
      var i = n.get("coordinateSystem");
      if (!i || i === "view") {
        var a = n.getData(), o = a.mapArray(function(g) {
          var m = a.getItemModel(g);
          return [
            +m.get("x"),
            +m.get("y")
          ];
        }), s = [], l = [];
        Hm(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
        var u = (l[0] - s[0]) / (l[1] - s[1]), c = rue(n, e, u);
        isNaN(u) && (s = [
          c.x,
          c.y
        ], l = [
          c.x + c.width,
          c.y + c.height
        ]);
        var h = l[0] - s[0], f = l[1] - s[1], d = c.width, p = c.height, v = n.coordinateSystem = new Xd();
        v.zoomLimit = n.get("scaleLimit"), v.setBoundingRect(s[0], s[1], h, f), v.setViewRect(c.x, c.y, d, p), v.setCenter(n.get("center"), e), v.setZoom(n.get("zoom")), r.push(v);
      }
    }), r;
  }
  var BP = Mr.prototype, A_ = Ld.prototype, bW = /* @__PURE__ */ function() {
    function t() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return t;
  }();
  (function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e;
  })(bW);
  function I_(t) {
    return isNaN(+t.cpx1) || isNaN(+t.cpy1);
  }
  var iue = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "ec-line", n;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new bW();
    }, e.prototype.buildPath = function(r, n) {
      I_(n) ? BP.buildPath.call(this, r, n) : A_.buildPath.call(this, r, n);
    }, e.prototype.pointAt = function(r) {
      return I_(this.shape) ? BP.pointAt.call(this, r) : A_.pointAt.call(this, r);
    }, e.prototype.tangentAt = function(r) {
      var n = this.shape, i = I_(n) ? [
        n.x2 - n.x1,
        n.y2 - n.y1
      ] : A_.tangentAt.call(this, r);
      return Bc(i, i);
    }, e;
  }(st), M_ = [
    "fromSymbol",
    "toSymbol"
  ];
  function zP(t) {
    return "_" + t + "Type";
  }
  function FP(t, e, r) {
    var n = e.getItemVisual(r, t);
    if (!n || n === "none") return n;
    var i = e.getItemVisual(r, t + "Size"), a = e.getItemVisual(r, t + "Rotate"), o = e.getItemVisual(r, t + "Offset"), s = e.getItemVisual(r, t + "KeepAspect"), l = Kc(i), u = ou(o || 0, l);
    return n + l + u + (a || "") + (s || "");
  }
  function VP(t, e, r) {
    var n = e.getItemVisual(r, t);
    if (!(!n || n === "none")) {
      var i = e.getItemVisual(r, t + "Size"), a = e.getItemVisual(r, t + "Rotate"), o = e.getItemVisual(r, t + "Offset"), s = e.getItemVisual(r, t + "KeepAspect"), l = Kc(i), u = ou(o || 0, l), c = mr(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
      return c.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, c.name = t, c;
    }
  }
  function aue(t) {
    var e = new iue({
      name: "line",
      subPixelOptimize: true
    });
    return mw(e.shape, t), e;
  }
  function mw(t, e) {
    t.x1 = e[0][0], t.y1 = e[0][1], t.x2 = e[1][0], t.y2 = e[1][1], t.percent = 1;
    var r = e[2];
    r ? (t.cpx1 = r[0], t.cpy1 = r[1]) : (t.cpx1 = NaN, t.cpy1 = NaN);
  }
  var d2 = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this) || this;
      return a._createLine(r, n, i), a;
    }
    return e.prototype._createLine = function(r, n, i) {
      var a = r.hostModel, o = r.getItemLayout(n), s = aue(o);
      s.shape.percent = 0, er(s, {
        shape: {
          percent: 1
        }
      }, a, n), this.add(s), $(M_, function(l) {
        var u = VP(l, r, n);
        this.add(u), this[zP(l)] = FP(l, r, n);
      }, this), this._updateCommonStl(r, n, i);
    }, e.prototype.updateData = function(r, n, i) {
      var a = r.hostModel, o = this.childOfName("line"), s = r.getItemLayout(n), l = {
        shape: {}
      };
      mw(l.shape, s), wt(o, l, a, n), $(M_, function(u) {
        var c = FP(u, r, n), h = zP(u);
        if (this[h] !== c) {
          this.remove(this.childOfName(u));
          var f = VP(u, r, n);
          this.add(f);
        }
        this[h] = c;
      }, this), this._updateCommonStl(r, n, i);
    }, e.prototype.getLinePath = function() {
      return this.childAt(0);
    }, e.prototype._updateCommonStl = function(r, n, i) {
      var a = r.hostModel, o = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, h = i && i.emphasisDisabled, f = i && i.focus, d = i && i.blurScope;
      if (!i || r.hasItemOption) {
        var p = r.getItemModel(n), v = p.getModel("emphasis");
        s = v.getModel("lineStyle").getLineStyle(), l = p.getModel([
          "blur",
          "lineStyle"
        ]).getLineStyle(), u = p.getModel([
          "select",
          "lineStyle"
        ]).getLineStyle(), h = v.get("disabled"), f = v.get("focus"), d = v.get("blurScope"), c = Lr(p);
      }
      var g = r.getItemVisual(n, "style"), m = g.stroke;
      o.useStyle(g), o.style.fill = null, o.style.strokeNoScale = true, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, $(M_, function(x) {
        var T = this.childOfName(x);
        if (T) {
          T.setColor(m), T.style.opacity = g.opacity;
          for (var A = 0; A < xn.length; A++) {
            var I = xn[A], M = o.getState(I);
            if (M) {
              var k = M.style || {}, B = T.ensureState(I), L = B.style || (B.style = {});
              k.stroke != null && (L[T.__isEmptyBrush ? "stroke" : "fill"] = k.stroke), k.opacity != null && (L.opacity = k.opacity);
            }
          }
          T.markRedraw();
        }
      }, this);
      var y = a.getRawValue(n);
      Xr(this, c, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function(x, T) {
            return a.getFormattedLabel(x, T, r.dataType);
          }
        },
        inheritColor: m || "#000",
        defaultOpacity: g.opacity,
        defaultText: (y == null ? r.getName(n) : isFinite(y) ? lr(y) : y) + ""
      });
      var _ = this.getTextContent();
      if (_) {
        var b = c.normal;
        _.__align = _.style.align, _.__verticalAlign = _.style.verticalAlign, _.__position = b.get("position") || "middle";
        var w = b.get("distance");
        ae(w) || (w = [
          w,
          w
        ]), _.__labelDistance = w;
      }
      this.setTextConfig({
        position: null,
        local: true,
        inside: false
      }), ir(this, f, d, h);
    }, e.prototype.highlight = function() {
      fo(this);
    }, e.prototype.downplay = function() {
      po(this);
    }, e.prototype.updateLayout = function(r, n) {
      this.setLinePoints(r.getItemLayout(n));
    }, e.prototype.setLinePoints = function(r) {
      var n = this.childOfName("line");
      mw(n.shape, r), n.dirty();
    }, e.prototype.beforeUpdate = function() {
      var r = this, n = r.childOfName("fromSymbol"), i = r.childOfName("toSymbol"), a = r.getTextContent();
      if (!n && !i && (!a || a.ignore)) return;
      for (var o = 1, s = this.parent; s; ) s.scaleX && (o /= s.scaleX), s = s.parent;
      var l = r.childOfName("line");
      if (!this.__dirty && !l.__dirty) return;
      var u = l.shape.percent, c = l.pointAt(0), h = l.pointAt(u), f = wl([], h, c);
      Bc(f, f);
      function d(M, k) {
        var B = M.__specifiedRotation;
        if (B == null) {
          var L = l.tangentAt(k);
          M.attr("rotation", (k === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(L[1], L[0]));
        } else M.attr("rotation", B);
      }
      if (n && (n.setPosition(c), d(n, 0), n.scaleX = n.scaleY = o * u, n.markRedraw()), i && (i.setPosition(h), d(i, 1), i.scaleX = i.scaleY = o * u, i.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var p = void 0, v = void 0, g = a.__labelDistance, m = g[0] * o, y = g[1] * o, _ = u / 2, b = l.tangentAt(_), w = [
          b[1],
          -b[0]
        ], x = l.pointAt(_);
        w[1] > 0 && (w[0] = -w[0], w[1] = -w[1]);
        var T = b[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var A = -Math.atan2(b[1], b[0]);
          h[0] < c[0] && (A = Math.PI + A), a.rotation = A;
        }
        var I = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            I = -y, v = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            I = y, v = "top";
            break;
          default:
            I = 0, v = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = f[0] * m + h[0], a.y = f[1] * y + h[1], p = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", v = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -f[0] * m + c[0], a.y = -f[1] * y + c[1], p = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", v = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = m * T + c[0], a.y = c[1] + I, p = b[0] < 0 ? "right" : "left", a.originX = -m * T, a.originY = -I;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = x[0], a.y = x[1] + I, p = "center", a.originY = -I;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -m * T + h[0], a.y = h[1] + I, p = b[0] >= 0 ? "right" : "left", a.originX = m * T, a.originY = -I;
            break;
        }
        a.scaleX = a.scaleY = o, a.setStyle({
          verticalAlign: a.__verticalAlign || v,
          align: a.__align || p
        });
      }
    }, e;
  }(Be), p2 = function() {
    function t(e) {
      this.group = new Be(), this._LineCtor = e || d2;
    }
    return t.prototype.updateData = function(e) {
      var r = this;
      this._progressiveEls = null;
      var n = this, i = n.group, a = n._lineData;
      n._lineData = e, a || i.removeAll();
      var o = GP(e);
      e.diff(a).add(function(s) {
        r._doAdd(e, s, o);
      }).update(function(s, l) {
        r._doUpdate(a, e, l, s, o);
      }).remove(function(s) {
        i.remove(a.getItemGraphicEl(s));
      }).execute();
    }, t.prototype.updateLayout = function() {
      var e = this._lineData;
      e && e.eachItemGraphicEl(function(r, n) {
        r.updateLayout(e, n);
      }, this);
    }, t.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = GP(e), this._lineData = null, this.group.removeAll();
    }, t.prototype.incrementalUpdate = function(e, r) {
      this._progressiveEls = [];
      function n(s) {
        !s.isGroup && !oue(s) && (s.incremental = true, s.ensureState("emphasis").hoverLayer = true);
      }
      for (var i = e.start; i < e.end; i++) {
        var a = r.getItemLayout(i);
        if (D_(a)) {
          var o = new this._LineCtor(r, i, this._seriesScope);
          o.traverse(n), this.group.add(o), r.setItemGraphicEl(i, o), this._progressiveEls.push(o);
        }
      }
    }, t.prototype.remove = function() {
      this.group.removeAll();
    }, t.prototype.eachRendered = function(e) {
      bs(this._progressiveEls || this.group, e);
    }, t.prototype._doAdd = function(e, r, n) {
      var i = e.getItemLayout(r);
      if (D_(i)) {
        var a = new this._LineCtor(e, r, n);
        e.setItemGraphicEl(r, a), this.group.add(a);
      }
    }, t.prototype._doUpdate = function(e, r, n, i, a) {
      var o = e.getItemGraphicEl(n);
      if (!D_(r.getItemLayout(i))) {
        this.group.remove(o);
        return;
      }
      o ? o.updateData(r, i, a) : o = new this._LineCtor(r, i, a), r.setItemGraphicEl(i, o), this.group.add(o);
    }, t;
  }();
  function oue(t) {
    return t.animators && t.animators.length > 0;
  }
  function GP(t) {
    var e = t.hostModel, r = e.getModel("emphasis");
    return {
      lineStyle: e.getModel("lineStyle").getLineStyle(),
      emphasisLineStyle: r.getModel([
        "lineStyle"
      ]).getLineStyle(),
      blurLineStyle: e.getModel([
        "blur",
        "lineStyle"
      ]).getLineStyle(),
      selectLineStyle: e.getModel([
        "select",
        "lineStyle"
      ]).getLineStyle(),
      emphasisDisabled: r.get("disabled"),
      blurScope: r.get("blurScope"),
      focus: r.get("focus"),
      labelStatesModels: Lr(e)
    };
  }
  function WP(t) {
    return isNaN(t[0]) || isNaN(t[1]);
  }
  function D_(t) {
    return t && !WP(t[0]) && !WP(t[1]);
  }
  var E_ = [], k_ = [], P_ = [], Pu = Br, L_ = Ll, HP = Math.abs;
  function UP(t, e, r) {
    for (var n = t[0], i = t[1], a = t[2], o = 1 / 0, s, l = r * r, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
      E_[0] = Pu(n[0], i[0], a[0], c), E_[1] = Pu(n[1], i[1], a[1], c);
      var h = HP(L_(E_, e) - l);
      h < o && (o = h, s = c);
    }
    for (var f = 0; f < 32; f++) {
      var d = s + u;
      k_[0] = Pu(n[0], i[0], a[0], s), k_[1] = Pu(n[1], i[1], a[1], s), P_[0] = Pu(n[0], i[0], a[0], d), P_[1] = Pu(n[1], i[1], a[1], d);
      var h = L_(k_, e) - l;
      if (HP(h) < 0.01) break;
      var p = L_(P_, e) - l;
      u /= 2, h < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
    }
    return s;
  }
  function $_(t, e) {
    var r = [], n = Gf, i = [
      [],
      [],
      []
    ], a = [
      [],
      []
    ], o = [];
    e /= 2, t.eachEdge(function(s, l) {
      var u = s.getLayout(), c = s.getVisual("fromSymbol"), h = s.getVisual("toSymbol");
      u.__original || (u.__original = [
        no(u[0]),
        no(u[1])
      ], u[2] && u.__original.push(no(u[2])));
      var f = u.__original;
      if (u[2] != null) {
        if (fn(i[0], f[0]), fn(i[1], f[2]), fn(i[2], f[1]), c && c !== "none") {
          var d = lf(s.node1), p = UP(i, f[0], d * e);
          n(i[0][0], i[1][0], i[2][0], p, r), i[0][0] = r[3], i[1][0] = r[4], n(i[0][1], i[1][1], i[2][1], p, r), i[0][1] = r[3], i[1][1] = r[4];
        }
        if (h && h !== "none") {
          var d = lf(s.node2), p = UP(i, f[1], d * e);
          n(i[0][0], i[1][0], i[2][0], p, r), i[1][0] = r[1], i[2][0] = r[2], n(i[0][1], i[1][1], i[2][1], p, r), i[1][1] = r[1], i[2][1] = r[2];
        }
        fn(u[0], i[0]), fn(u[1], i[2]), fn(u[2], i[1]);
      } else {
        if (fn(a[0], f[0]), fn(a[1], f[1]), wl(o, a[1], a[0]), Bc(o, o), c && c !== "none") {
          var d = lf(s.node1);
          tx(a[0], a[0], o, d * e);
        }
        if (h && h !== "none") {
          var d = lf(s.node2);
          tx(a[1], a[1], o, -d * e);
        }
        fn(u[0], a[0]), fn(u[1], a[1]);
      }
    });
  }
  function YP(t) {
    return t.type === "view";
  }
  var sue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r, n) {
      var i = new Gd(), a = new p2(), o = this.group;
      this._controller = new qd(n.getZr()), this._controllerHost = {
        target: o
      }, o.add(i.group), o.add(a.group), this._symbolDraw = i, this._lineDraw = a, this._firstRender = true;
    }, e.prototype.render = function(r, n, i) {
      var a = this, o = r.coordinateSystem;
      this._model = r;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (YP(o)) {
        var c = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY
        };
        this._firstRender ? u.attr(c) : wt(u, c, r);
      }
      $_(r.getGraph(), sf(r));
      var h = r.getData();
      s.updateData(h);
      var f = r.getEdgeData();
      l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(r, n, i), clearTimeout(this._layoutTimeout);
      var d = r.forceLayout, p = r.get([
        "force",
        "layoutAnimation"
      ]);
      d && this._startForceLayoutIteration(d, p);
      var v = r.get("layout");
      h.graph.eachNode(function(_) {
        var b = _.dataIndex, w = _.getGraphicEl(), x = _.getModel();
        if (w) {
          w.off("drag").off("dragend");
          var T = x.get("draggable");
          T && w.on("drag", function(I) {
            switch (v) {
              case "force":
                d.warmUp(), !a._layouting && a._startForceLayoutIteration(d, p), d.setFixed(b), h.setItemLayout(b, [
                  w.x,
                  w.y
                ]);
                break;
              case "circular":
                h.setItemLayout(b, [
                  w.x,
                  w.y
                ]), _.setLayout({
                  fixed: true
                }, true), f2(r, "symbolSize", _, [
                  I.offsetX,
                  I.offsetY
                ]), a.updateLayout(r);
                break;
              case "none":
              default:
                h.setItemLayout(b, [
                  w.x,
                  w.y
                ]), h2(r.getGraph(), r), a.updateLayout(r);
                break;
            }
          }).on("dragend", function() {
            d && d.setUnfixed(b);
          }), w.setDraggable(T, !!x.get("cursor"));
          var A = x.get([
            "emphasis",
            "focus"
          ]);
          A === "adjacency" && (Ge(w).focus = _.getAdjacentDataIndices());
        }
      }), h.graph.eachEdge(function(_) {
        var b = _.getGraphicEl(), w = _.getModel().get([
          "emphasis",
          "focus"
        ]);
        b && w === "adjacency" && (Ge(b).focus = {
          edge: [
            _.dataIndex
          ],
          node: [
            _.node1.dataIndex,
            _.node2.dataIndex
          ]
        });
      });
      var g = r.get("layout") === "circular" && r.get([
        "circular",
        "rotateLabel"
      ]), m = h.getLayout("cx"), y = h.getLayout("cy");
      h.graph.eachNode(function(_) {
        _W(_, g, m, y);
      }), this._firstRender = false;
    }, e.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype._startForceLayoutIteration = function(r, n) {
      var i = this;
      (function a() {
        r.step(function(o) {
          i.updateLayout(i._model), (i._layouting = !o) && (n ? i._layoutTimeout = setTimeout(a, 16) : a());
        });
      })();
    }, e.prototype._updateController = function(r, n, i) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      if (o.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !py(u, i, r);
      }), !YP(r.coordinateSystem)) {
        o.disable();
        return;
      }
      o.enable(r.get("roam")), s.zoomLimit = r.get("scaleLimit"), s.zoom = r.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        r2(s, u.dx, u.dy), i.dispatchAction({
          seriesId: r.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        n2(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: r.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(), $_(r.getGraph(), sf(r)), a._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function() {
      var r = this._model, n = r.getData(), i = sf(r);
      n.eachItemGraphicEl(function(a, o) {
        a && a.setSymbolScale(i);
      });
    }, e.prototype.updateLayout = function(r) {
      $_(r.getGraph(), sf(r)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, e.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = false, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, e.type = "graph", e;
  }(Ft);
  function Lu(t) {
    return "_EC_" + t;
  }
  var lue = function() {
    function t(e) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || false;
    }
    return t.prototype.isDirected = function() {
      return this._directed;
    }, t.prototype.addNode = function(e, r) {
      e = e == null ? "" + r : "" + e;
      var n = this._nodesMap;
      if (!n[Lu(e)]) {
        var i = new ul(e, r);
        return i.hostGraph = this, this.nodes.push(i), n[Lu(e)] = i, i;
      }
    }, t.prototype.getNodeByIndex = function(e) {
      var r = this.data.getRawIndex(e);
      return this.nodes[r];
    }, t.prototype.getNodeById = function(e) {
      return this._nodesMap[Lu(e)];
    }, t.prototype.addEdge = function(e, r, n) {
      var i = this._nodesMap, a = this._edgesMap;
      if (xt(e) && (e = this.nodes[e]), xt(r) && (r = this.nodes[r]), e instanceof ul || (e = i[Lu(e)]), r instanceof ul || (r = i[Lu(r)]), !(!e || !r)) {
        var o = e.id + "-" + r.id, s = new xW(e, r, n);
        return s.hostGraph = this, this._directed && (e.outEdges.push(s), r.inEdges.push(s)), e.edges.push(s), e !== r && r.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, t.prototype.getEdgeByIndex = function(e) {
      var r = this.edgeData.getRawIndex(e);
      return this.edges[r];
    }, t.prototype.getEdge = function(e, r) {
      e instanceof ul && (e = e.id), r instanceof ul && (r = r.id);
      var n = this._edgesMap;
      return this._directed ? n[e + "-" + r] : n[e + "-" + r] || n[r + "-" + e];
    }, t.prototype.eachNode = function(e, r) {
      for (var n = this.nodes, i = n.length, a = 0; a < i; a++) n[a].dataIndex >= 0 && e.call(r, n[a], a);
    }, t.prototype.eachEdge = function(e, r) {
      for (var n = this.edges, i = n.length, a = 0; a < i; a++) n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && e.call(r, n[a], a);
    }, t.prototype.breadthFirstTraverse = function(e, r, n, i) {
      if (r instanceof ul || (r = this._nodesMap[Lu(r)]), !!r) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++) this.nodes[o].__visited = false;
        if (!e.call(i, r, null)) for (var s = [
          r
        ]; s.length; ) for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
          var c = u[o], h = c.node1 === l ? c.node2 : c.node1;
          if (!h.__visited) {
            if (e.call(i, h, l)) return;
            s.push(h), h.__visited = true;
          }
        }
      }
    }, t.prototype.update = function() {
      for (var e = this.data, r = this.edgeData, n = this.nodes, i = this.edges, a = 0, o = n.length; a < o; a++) n[a].dataIndex = -1;
      for (var a = 0, o = e.count(); a < o; a++) n[e.getRawIndex(a)].dataIndex = a;
      r.filterSelf(function(s) {
        var l = i[r.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = i.length; a < o; a++) i[a].dataIndex = -1;
      for (var a = 0, o = r.count(); a < o; a++) i[r.getRawIndex(a)].dataIndex = a;
    }, t.prototype.clone = function() {
      for (var e = new t(this._directed), r = this.nodes, n = this.edges, i = 0; i < r.length; i++) e.addNode(r[i].id, r[i].dataIndex);
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        e.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return e;
    }, t;
  }(), ul = function() {
    function t(e, r) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = r ?? -1;
    }
    return t.prototype.degree = function() {
      return this.edges.length;
    }, t.prototype.inDegree = function() {
      return this.inEdges.length;
    }, t.prototype.outDegree = function() {
      return this.outEdges.length;
    }, t.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostGraph, n = r.data.getItemModel(this.dataIndex);
        return n.getModel(e);
      }
    }, t.prototype.getAdjacentDataIndices = function() {
      for (var e = {
        edge: [],
        node: []
      }, r = 0; r < this.edges.length; r++) {
        var n = this.edges[r];
        n.dataIndex < 0 || (e.edge.push(n.dataIndex), e.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return e;
    }, t.prototype.getTrajectoryDataIndices = function() {
      for (var e = Ce(), r = Ce(), n = 0; n < this.edges.length; n++) {
        var i = this.edges[n];
        if (!(i.dataIndex < 0)) {
          e.set(i.dataIndex, true);
          for (var a = [
            i.node1
          ], o = [
            i.node2
          ], s = 0; s < a.length; ) {
            var l = a[s];
            s++, r.set(l.dataIndex, true);
            for (var u = 0; u < l.inEdges.length; u++) e.set(l.inEdges[u].dataIndex, true), a.push(l.inEdges[u].node1);
          }
          for (s = 0; s < o.length; ) {
            var c = o[s];
            s++, r.set(c.dataIndex, true);
            for (var u = 0; u < c.outEdges.length; u++) e.set(c.outEdges[u].dataIndex, true), o.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: e.keys(),
        node: r.keys()
      };
    }, t;
  }(), xW = function() {
    function t(e, r, n) {
      this.dataIndex = -1, this.node1 = e, this.node2 = r, this.dataIndex = n ?? -1;
    }
    return t.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostGraph, n = r.edgeData.getItemModel(this.dataIndex);
        return n.getModel(e);
      }
    }, t.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [
          this.dataIndex
        ],
        node: [
          this.node1.dataIndex,
          this.node2.dataIndex
        ]
      };
    }, t.prototype.getTrajectoryDataIndices = function() {
      var e = Ce(), r = Ce();
      e.set(this.dataIndex, true);
      for (var n = [
        this.node1
      ], i = [
        this.node2
      ], a = 0; a < n.length; ) {
        var o = n[a];
        a++, r.set(o.dataIndex, true);
        for (var s = 0; s < o.inEdges.length; s++) e.set(o.inEdges[s].dataIndex, true), n.push(o.inEdges[s].node1);
      }
      for (a = 0; a < i.length; ) {
        var l = i[a];
        a++, r.set(l.dataIndex, true);
        for (var s = 0; s < l.outEdges.length; s++) e.set(l.outEdges[s].dataIndex, true), i.push(l.outEdges[s].node2);
      }
      return {
        edge: e.keys(),
        node: r.keys()
      };
    }, t;
  }();
  function wW(t, e) {
    return {
      getValue: function(r) {
        var n = this[t][e];
        return n.getStore().get(n.getDimensionIndex(r || "value"), this.dataIndex);
      },
      setVisual: function(r, n) {
        this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, r, n);
      },
      getVisual: function(r) {
        return this[t][e].getItemVisual(this.dataIndex, r);
      },
      setLayout: function(r, n) {
        this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, r, n);
      },
      getLayout: function() {
        return this[t][e].getItemLayout(this.dataIndex);
      },
      getGraphicEl: function() {
        return this[t][e].getItemGraphicEl(this.dataIndex);
      },
      getRawIndex: function() {
        return this[t][e].getRawIndex(this.dataIndex);
      }
    };
  }
  yr(ul, wW("hostGraph", "data"));
  yr(xW, wW("hostGraph", "edgeData"));
  function SW(t, e, r, n, i) {
    for (var a = new lue(n), o = 0; o < t.length; o++) a.addNode(Fr(t[o].id, t[o].name, o), o);
    for (var s = [], l = [], u = 0, o = 0; o < e.length; o++) {
      var c = e[o], h = c.source, f = c.target;
      a.addEdge(h, f, u) && (l.push(c), s.push(Fr(xr(c.id, null), h + " > " + f)), u++);
    }
    var d = r.get("coordinateSystem"), p;
    if (d === "cartesian2d" || d === "polar") p = So(t, r);
    else {
      var v = Nd.get(d), g = v ? v.dimensions || [] : [];
      et(g, "value") < 0 && g.concat([
        "value"
      ]);
      var m = zd(t, {
        coordDimensions: g,
        encodeDefine: r.getEncode()
      }).dimensions;
      p = new yn(m, r), p.initData(t);
    }
    var y = new yn([
      "value"
    ], r);
    return y.initData(l, s), i && i(p, y), iW({
      mainData: p,
      struct: a,
      structAttr: "graph",
      datas: {
        node: p,
        edge: y
      },
      datasAttr: {
        node: "data",
        edge: "edgeData"
      }
    }), a.update(), a;
  }
  var uue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.hasSymbolVisual = true, r;
    }
    return e.prototype.init = function(r) {
      t.prototype.init.apply(this, arguments);
      var n = this;
      function i() {
        return n._categoriesData;
      }
      this.legendVisualProvider = new Yd(i, i), this.fillDataTextStyle(r.edges || r.links), this._updateCategoriesData();
    }, e.prototype.mergeOption = function(r) {
      t.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(r.edges || r.links), this._updateCategoriesData();
    }, e.prototype.mergeDefaultAndTheme = function(r) {
      t.prototype.mergeDefaultAndTheme.apply(this, arguments), Ul(r, "edgeLabel", [
        "show"
      ]);
    }, e.prototype.getInitialData = function(r, n) {
      var i = r.edges || r.links || [], a = r.data || r.nodes || [], o = this;
      if (a && i) {
        jle(this);
        var s = SW(a, i, this, true, l);
        return $(s.edges, function(u) {
          Kle(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var v = o._categoriesModels, g = p.getShallow("category"), m = v[g];
          return m && (m.parentModel = p.parentModel, p.parentModel = m), p;
        });
        var h = kt.prototype.getModel;
        function f(p, v) {
          var g = h.call(this, p, v);
          return g.resolveParentPath = d, g;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = d, p.getModel = f, p;
        });
        function d(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var v = p.slice();
            return p[0] === "label" ? v[0] = "edgeLabel" : p[1] === "label" && (v[1] = "edgeLabel"), v;
          }
          return p;
        }
      }
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, e.prototype.formatTooltip = function(r, n, i) {
      if (i === "edge") {
        var a = this.getData(), o = this.getDataParams(r, i), s = a.graph.getEdgeByIndex(r), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), $r("nameValue", {
          name: c.join(" > "),
          value: o.value,
          noValue: o.value == null
        });
      }
      var h = qV({
        series: this,
        dataIndex: r,
        multipleSeries: n
      });
      return h;
    }, e.prototype._updateCategoriesData = function() {
      var r = oe(this.option.categories || [], function(i) {
        return i.value != null ? i : te({
          value: 0
        }, i);
      }), n = new yn([
        "value"
      ], this);
      n.initData(r), this._categoriesData = n, this._categoriesModels = n.mapArray(function(i) {
        return n.getItemModel(i);
      });
    }, e.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, e.prototype.setCenter = function(r) {
      this.option.center = r;
    }, e.prototype.isAnimationEnabled = function() {
      return t.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get([
        "force",
        "layoutAnimation"
      ]));
    }, e.type = "series.graph", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      legendHoverLink: true,
      layout: null,
      circular: {
        rotateLabel: false
      },
      force: {
        initLayout: null,
        repulsion: [
          0,
          50
        ],
        gravity: 0.1,
        friction: 0.6,
        edgeLength: 30,
        layoutAnimation: true
      },
      left: "center",
      top: "center",
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: [
        "none",
        "none"
      ],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: false,
      roam: false,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: {
        show: false,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: true,
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Xt), cue = {
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  };
  function hue(t) {
    t.registerChartView(sue), t.registerSeriesModel(uue), t.registerProcessor(Hle), t.registerVisual(Ule), t.registerVisual(Yle), t.registerLayout(Zle), t.registerLayout(t.PRIORITY.VISUAL.POST_CHART_LAYOUT, Jle), t.registerLayout(tue), t.registerCoordinateSystem("graphView", {
      dimensions: Xd.dimensions,
      create: nue
    }), t.registerAction({
      type: "focusNodeAdjacency",
      event: "focusNodeAdjacency",
      update: "series:focusNodeAdjacency"
    }, dr), t.registerAction({
      type: "unfocusNodeAdjacency",
      event: "unfocusNodeAdjacency",
      update: "series:unfocusNodeAdjacency"
    }, dr), t.registerAction(cue, function(e, r, n) {
      r.eachComponent({
        mainType: "series",
        query: e
      }, function(i) {
        var a = i.coordinateSystem, o = a2(a, e, void 0, n);
        i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom);
      });
    });
  }
  var fue = /* @__PURE__ */ function() {
    function t() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return t;
  }(), due = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "pointer", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new fue();
    }, e.prototype.buildPath = function(r, n) {
      var i = Math.cos, a = Math.sin, o = n.r, s = n.width, l = n.angle, u = n.x - i(l) * s * (s >= o / 3 ? 1 : 2), c = n.y - a(l) * s * (s >= o / 3 ? 1 : 2);
      l = n.angle - Math.PI / 2, r.moveTo(u, c), r.lineTo(n.x + i(l) * s, n.y + a(l) * s), r.lineTo(n.x + i(n.angle) * o, n.y + a(n.angle) * o), r.lineTo(n.x - i(l) * s, n.y - a(l) * s), r.lineTo(u, c);
    }, e;
  }(st);
  function pue(t, e) {
    var r = t.get("center"), n = e.getWidth(), i = e.getHeight(), a = Math.min(n, i), o = pe(r[0], e.getWidth()), s = pe(r[1], e.getHeight()), l = pe(t.get("radius"), a / 2);
    return {
      cx: o,
      cy: s,
      r: l
    };
  }
  function rv(t, e) {
    var r = t == null ? "" : t + "";
    return e && (me(e) ? r = e.replace("{value}", r) : De(e) && (r = e(t))), r;
  }
  var vue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      this.group.removeAll();
      var a = r.get([
        "axisLine",
        "lineStyle",
        "color"
      ]), o = pue(r, i);
      this._renderMain(r, n, i, a, o), this._data = r.getData();
    }, e.prototype.dispose = function() {
    }, e.prototype._renderMain = function(r, n, i, a, o) {
      var s = this.group, l = r.get("clockwise"), u = -r.get("startAngle") / 180 * Math.PI, c = -r.get("endAngle") / 180 * Math.PI, h = r.getModel("axisLine"), f = h.get("roundCap"), d = f ? Kg : wn, p = h.get("show"), v = h.getModel("lineStyle"), g = v.get("width"), m = [
        u,
        c
      ];
      sT(m, !l), u = m[0], c = m[1];
      for (var y = c - u, _ = u, b = [], w = 0; p && w < a.length; w++) {
        var x = Math.min(Math.max(a[w][0], 0), 1);
        c = u + y * x;
        var T = new d({
          shape: {
            startAngle: _,
            endAngle: c,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - g,
            r: o.r
          },
          silent: true
        });
        T.setStyle({
          fill: a[w][1]
        }), T.setStyle(v.getLineStyle([
          "color",
          "width"
        ])), b.push(T), _ = c;
      }
      b.reverse(), $(b, function(I) {
        return s.add(I);
      });
      var A = function(I) {
        if (I <= 0) return a[0][1];
        var M;
        for (M = 0; M < a.length; M++) if (a[M][0] >= I && (M === 0 ? 0 : a[M - 1][0]) < I) return a[M][1];
        return a[M - 1][1];
      };
      this._renderTicks(r, n, i, A, o, u, c, l, g), this._renderTitleAndDetail(r, n, i, A, o), this._renderAnchor(r, o), this._renderPointer(r, n, i, A, o, u, c, l, g);
    }, e.prototype._renderTicks = function(r, n, i, a, o, s, l, u, c) {
      for (var h = this.group, f = o.cx, d = o.cy, p = o.r, v = +r.get("min"), g = +r.get("max"), m = r.getModel("splitLine"), y = r.getModel("axisTick"), _ = r.getModel("axisLabel"), b = r.get("splitNumber"), w = y.get("splitNumber"), x = pe(m.get("length"), p), T = pe(y.get("length"), p), A = s, I = (l - s) / b, M = I / w, k = m.getModel("lineStyle").getLineStyle(), B = y.getModel("lineStyle").getLineStyle(), L = m.get("distance"), z, F, E = 0; E <= b; E++) {
        if (z = Math.cos(A), F = Math.sin(A), m.get("show")) {
          var O = L ? L + c : c, N = new Mr({
            shape: {
              x1: z * (p - O) + f,
              y1: F * (p - O) + d,
              x2: z * (p - x - O) + f,
              y2: F * (p - x - O) + d
            },
            style: k,
            silent: true
          });
          k.stroke === "auto" && N.setStyle({
            stroke: a(E / b)
          }), h.add(N);
        }
        if (_.get("show")) {
          var O = _.get("distance") + L, V = rv(lr(E / b * (g - v) + v), _.get("formatter")), H = a(E / b), G = z * (p - x - O) + f, Y = F * (p - x - O) + d, U = _.get("rotate"), Z = 0;
          U === "radial" ? (Z = -A + 2 * Math.PI, Z > Math.PI / 2 && (Z += Math.PI)) : U === "tangential" ? Z = -A - Math.PI / 2 : xt(U) && (Z = U * Math.PI / 180), Z === 0 ? h.add(new bt({
            style: Yt(_, {
              text: V,
              x: G,
              y: Y,
              verticalAlign: F < -0.8 ? "top" : F > 0.8 ? "bottom" : "middle",
              align: z < -0.4 ? "left" : z > 0.4 ? "right" : "center"
            }, {
              inheritColor: H
            }),
            silent: true
          })) : h.add(new bt({
            style: Yt(_, {
              text: V,
              x: G,
              y: Y,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: H
            }),
            silent: true,
            originX: G,
            originY: Y,
            rotation: Z
          }));
        }
        if (y.get("show") && E !== b) {
          var O = y.get("distance");
          O = O ? O + c : c;
          for (var ee = 0; ee <= w; ee++) {
            z = Math.cos(A), F = Math.sin(A);
            var we = new Mr({
              shape: {
                x1: z * (p - O) + f,
                y1: F * (p - O) + d,
                x2: z * (p - T - O) + f,
                y2: F * (p - T - O) + d
              },
              silent: true,
              style: B
            });
            B.stroke === "auto" && we.setStyle({
              stroke: a((E + ee / w) / b)
            }), h.add(we), A += M;
          }
          A -= M;
        } else A += I;
      }
    }, e.prototype._renderPointer = function(r, n, i, a, o, s, l, u, c) {
      var h = this.group, f = this._data, d = this._progressEls, p = [], v = r.get([
        "pointer",
        "show"
      ]), g = r.getModel("progress"), m = g.get("show"), y = r.getData(), _ = y.mapDimension("value"), b = +r.get("min"), w = +r.get("max"), x = [
        b,
        w
      ], T = [
        s,
        l
      ];
      function A(M, k) {
        var B = y.getItemModel(M), L = B.getModel("pointer"), z = pe(L.get("width"), o.r), F = pe(L.get("length"), o.r), E = r.get([
          "pointer",
          "icon"
        ]), O = L.get("offsetCenter"), N = pe(O[0], o.r), V = pe(O[1], o.r), H = L.get("keepAspect"), G;
        return E ? G = mr(E, N - z / 2, V - F, z, F, null, H) : G = new due({
          shape: {
            angle: -Math.PI / 2,
            width: z,
            r: F,
            x: N,
            y: V
          }
        }), G.rotation = -(k + Math.PI / 2), G.x = o.cx, G.y = o.cy, G;
      }
      function I(M, k) {
        var B = g.get("roundCap"), L = B ? Kg : wn, z = g.get("overlap"), F = z ? g.get("width") : c / y.count(), E = z ? o.r - F : o.r - (M + 1) * F, O = z ? o.r : o.r - M * F, N = new L({
          shape: {
            startAngle: s,
            endAngle: k,
            cx: o.cx,
            cy: o.cy,
            clockwise: u,
            r0: E,
            r: O
          }
        });
        return z && (N.z2 = Et(y.get(_, M), [
          b,
          w
        ], [
          100,
          0
        ], true)), N;
      }
      (m || v) && (y.diff(f).add(function(M) {
        var k = y.get(_, M);
        if (v) {
          var B = A(M, s);
          er(B, {
            rotation: -((isNaN(+k) ? T[0] : Et(k, x, T, true)) + Math.PI / 2)
          }, r), h.add(B), y.setItemGraphicEl(M, B);
        }
        if (m) {
          var L = I(M, s), z = g.get("clip");
          er(L, {
            shape: {
              endAngle: Et(k, x, T, z)
            }
          }, r), h.add(L), Mx(r.seriesIndex, y.dataType, M, L), p[M] = L;
        }
      }).update(function(M, k) {
        var B = y.get(_, M);
        if (v) {
          var L = f.getItemGraphicEl(k), z = L ? L.rotation : s, F = A(M, z);
          F.rotation = z, wt(F, {
            rotation: -((isNaN(+B) ? T[0] : Et(B, x, T, true)) + Math.PI / 2)
          }, r), h.add(F), y.setItemGraphicEl(M, F);
        }
        if (m) {
          var E = d[k], O = E ? E.shape.endAngle : s, N = I(M, O), V = g.get("clip");
          wt(N, {
            shape: {
              endAngle: Et(B, x, T, V)
            }
          }, r), h.add(N), Mx(r.seriesIndex, y.dataType, M, N), p[M] = N;
        }
      }).execute(), y.each(function(M) {
        var k = y.getItemModel(M), B = k.getModel("emphasis"), L = B.get("focus"), z = B.get("blurScope"), F = B.get("disabled");
        if (v) {
          var E = y.getItemGraphicEl(M), O = y.getItemVisual(M, "style"), N = O.fill;
          if (E instanceof Gr) {
            var V = E.style;
            E.useStyle(te({
              image: V.image,
              x: V.x,
              y: V.y,
              width: V.width,
              height: V.height
            }, O));
          } else E.useStyle(O), E.type !== "pointer" && E.setColor(N);
          E.setStyle(k.getModel([
            "pointer",
            "itemStyle"
          ]).getItemStyle()), E.style.fill === "auto" && E.setStyle("fill", a(Et(y.get(_, M), x, [
            0,
            1
          ], true))), E.z2EmphasisLift = 0, qr(E, k), ir(E, L, z, F);
        }
        if (m) {
          var H = p[M];
          H.useStyle(y.getItemVisual(M, "style")), H.setStyle(k.getModel([
            "progress",
            "itemStyle"
          ]).getItemStyle()), H.z2EmphasisLift = 0, qr(H, k), ir(H, L, z, F);
        }
      }), this._progressEls = p);
    }, e.prototype._renderAnchor = function(r, n) {
      var i = r.getModel("anchor"), a = i.get("show");
      if (a) {
        var o = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = mr(s, n.cx - o / 2 + pe(l[0], n.r), n.cy - o / 2 + pe(l[1], n.r), o, o, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, e.prototype._renderTitleAndDetail = function(r, n, i, a, o) {
      var s = this, l = r.getData(), u = l.mapDimension("value"), c = +r.get("min"), h = +r.get("max"), f = new Be(), d = [], p = [], v = r.isAnimationEnabled(), g = r.get([
        "pointer",
        "showAbove"
      ]);
      l.diff(this._data).add(function(m) {
        d[m] = new bt({
          silent: true
        }), p[m] = new bt({
          silent: true
        });
      }).update(function(m, y) {
        d[m] = s._titleEls[y], p[m] = s._detailEls[y];
      }).execute(), l.each(function(m) {
        var y = l.getItemModel(m), _ = l.get(u, m), b = new Be(), w = a(Et(_, [
          c,
          h
        ], [
          0,
          1
        ], true)), x = y.getModel("title");
        if (x.get("show")) {
          var T = x.get("offsetCenter"), A = o.cx + pe(T[0], o.r), I = o.cy + pe(T[1], o.r), M = d[m];
          M.attr({
            z2: g ? 0 : 2,
            style: Yt(x, {
              x: A,
              y: I,
              text: l.getName(m),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: w
            })
          }), b.add(M);
        }
        var k = y.getModel("detail");
        if (k.get("show")) {
          var B = k.get("offsetCenter"), L = o.cx + pe(B[0], o.r), z = o.cy + pe(B[1], o.r), F = pe(k.get("width"), o.r), E = pe(k.get("height"), o.r), O = r.get([
            "progress",
            "show"
          ]) ? l.getItemVisual(m, "style").fill : w, M = p[m], N = k.get("formatter");
          M.attr({
            z2: g ? 0 : 2,
            style: Yt(k, {
              x: L,
              y: z,
              text: rv(_, N),
              width: isNaN(F) ? null : F,
              height: isNaN(E) ? null : E,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: O
            })
          }), Z4(M, {
            normal: k
          }, _, function(H) {
            return rv(H, N);
          }), v && Q4(M, m, l, r, {
            getFormattedLabel: function(H, G, Y, U, Z, ee) {
              return rv(ee ? ee.interpolatedValue : _, N);
            }
          }), b.add(M);
        }
        f.add(b);
      }), this.group.add(f), this._titleEls = d, this._detailEls = p;
    }, e.type = "gauge", e;
  }(Ft), gue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.visualStyleAccessPath = "itemStyle", r;
    }
    return e.prototype.getInitialData = function(r, n) {
      return Qc(this, [
        "value"
      ]);
    }, e.type = "series.gauge", e.defaultOption = {
      z: 2,
      colorBy: "data",
      center: [
        "50%",
        "50%"
      ],
      legendHoverLink: true,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: true,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        show: true,
        roundCap: false,
        lineStyle: {
          color: [
            [
              1,
              "#E6EBF8"
            ]
          ],
          width: 10
        }
      },
      progress: {
        show: false,
        overlap: true,
        width: 10,
        roundCap: false,
        clip: true
      },
      splitLine: {
        show: true,
        length: 10,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      axisTick: {
        show: true,
        splitNumber: 5,
        length: 6,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: true,
        distance: 15,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [
          0,
          0
        ],
        show: true,
        showAbove: true,
        length: "60%",
        width: 6,
        keepAspect: false
      },
      anchor: {
        show: false,
        showAbove: false,
        size: 6,
        icon: "circle",
        offsetCenter: [
          0,
          0
        ],
        keepAspect: false,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: true,
        offsetCenter: [
          0,
          "20%"
        ],
        color: "#464646",
        fontSize: 16,
        valueAnimation: false
      },
      detail: {
        show: true,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [
          5,
          10
        ],
        offsetCenter: [
          0,
          "40%"
        ],
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: false
      }
    }, e;
  }(Xt);
  function mue(t) {
    t.registerChartView(vue), t.registerSeriesModel(gue);
  }
  var yue = [
    "itemStyle",
    "opacity"
  ], _ue = function(t) {
    K(e, t);
    function e(r, n) {
      var i = t.call(this) || this, a = i, o = new Tn(), s = new bt();
      return a.setTextContent(s), i.setTextGuideLine(o), i.updateData(r, n, true), i;
    }
    return e.prototype.updateData = function(r, n, i) {
      var a = this, o = r.hostModel, s = r.getItemModel(n), l = r.getItemLayout(n), u = s.getModel("emphasis"), c = s.get(yue);
      c = c ?? 1, i || Ki(a), a.useStyle(r.getItemVisual(n, "style")), a.style.lineJoin = "round", i ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, er(a, {
        style: {
          opacity: c
        }
      }, o, n)) : wt(a, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, o, n), qr(a, s), this._updateLabel(r, n), ir(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(r, n) {
      var i = this, a = this.getTextGuideLine(), o = i.getTextContent(), s = r.hostModel, l = r.getItemModel(n), u = r.getItemLayout(n), c = u.label, h = r.getItemVisual(n, "style"), f = h.fill;
      Xr(o, Lr(l), {
        labelFetcher: r.hostModel,
        labelDataIndex: n,
        defaultOpacity: h.opacity,
        defaultText: r.getName(n)
      }, {
        normal: {
          align: c.textAlign,
          verticalAlign: c.verticalAlign
        }
      }), i.setTextConfig({
        local: true,
        inside: !!c.inside,
        insideStroke: f,
        outsideFill: f
      });
      var d = c.linePoints;
      a.setShape({
        points: d
      }), i.textGuideLineConfig = {
        anchor: d ? new Ke(d[0][0], d[0][1]) : null
      }, wt(o, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, n), o.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), UT(i, YT(l), {
        stroke: f
      });
    }, e;
  }(Sn), bue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.ignoreLabelLineUpdate = true, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = r.getData(), o = this._data, s = this.group;
      a.diff(o).add(function(l) {
        var u = new _ue(a, l);
        a.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = o.getItemGraphicEl(u);
        c.updateData(a, l), s.add(c), a.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        jf(u, r, l);
      }).execute(), this._data = a;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.prototype.dispose = function() {
    }, e.type = "funnel", e;
  }(Ft), xue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r) {
      t.prototype.init.apply(this, arguments), this.legendVisualProvider = new Yd(_e(this.getData, this), _e(this.getRawData, this)), this._defaultLabelLine(r);
    }, e.prototype.getInitialData = function(r, n) {
      return Qc(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: Ye(TT, this)
      });
    }, e.prototype._defaultLabelLine = function(r) {
      Ul(r, "labelLine", [
        "show"
      ]);
      var n = r.labelLine, i = r.emphasis.labelLine;
      n.show = n.show && r.label.show, i.show = i.show && r.emphasis.label.show;
    }, e.prototype.getDataParams = function(r) {
      var n = this.getData(), i = t.prototype.getDataParams.call(this, r), a = n.mapDimension("value"), o = n.getSum(a);
      return i.percent = o ? +(n.get(a, r) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, e.type = "series.funnel", e.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: true,
        position: "outer"
      },
      labelLine: {
        show: true,
        length: 20,
        lineStyle: {
          width: 1
        }
      },
      itemStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Xt);
  function wue(t, e) {
    return Tr(t.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function Sue(t, e) {
    for (var r = t.mapDimension("value"), n = t.mapArray(r, function(l) {
      return l;
    }), i = [], a = e === "ascending", o = 0, s = t.count(); o < s; o++) i[o] = o;
    return De(e) ? i.sort(e) : e !== "none" && i.sort(function(l, u) {
      return a ? n[l] - n[u] : n[u] - n[l];
    }), i;
  }
  function Tue(t) {
    var e = t.hostModel, r = e.get("orient");
    t.each(function(n) {
      var i = t.getItemModel(n), a = i.getModel("label"), o = a.get("position"), s = i.getModel("labelLine"), l = t.getItemLayout(n), u = l.points, c = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", h, f, d, p;
      if (c) o === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, d = (u[0][1] + u[3][1]) / 2, h = "left") : o === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, d = (u[1][1] + u[2][1]) / 2, h = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, h = "center"), p = [
        [
          f,
          d
        ],
        [
          f,
          d
        ]
      ];
      else {
        var v = void 0, g = void 0, m = void 0, y = void 0, _ = s.get("length");
        o === "left" ? (v = (u[3][0] + u[0][0]) / 2, g = (u[3][1] + u[0][1]) / 2, m = v - _, f = m - 5, h = "right") : o === "right" ? (v = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, m = v + _, f = m + 5, h = "left") : o === "top" ? (v = (u[3][0] + u[0][0]) / 2, g = (u[3][1] + u[0][1]) / 2, y = g - _, d = y - 5, h = "center") : o === "bottom" ? (v = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, y = g + _, d = y + 5, h = "center") : o === "rightTop" ? (v = r === "horizontal" ? u[3][0] : u[1][0], g = r === "horizontal" ? u[3][1] : u[1][1], r === "horizontal" ? (y = g - _, d = y - 5, h = "center") : (m = v + _, f = m + 5, h = "top")) : o === "rightBottom" ? (v = u[2][0], g = u[2][1], r === "horizontal" ? (y = g + _, d = y + 5, h = "center") : (m = v + _, f = m + 5, h = "bottom")) : o === "leftTop" ? (v = u[0][0], g = r === "horizontal" ? u[0][1] : u[1][1], r === "horizontal" ? (y = g - _, d = y - 5, h = "center") : (m = v - _, f = m - 5, h = "right")) : o === "leftBottom" ? (v = r === "horizontal" ? u[1][0] : u[3][0], g = r === "horizontal" ? u[1][1] : u[2][1], r === "horizontal" ? (y = g + _, d = y + 5, h = "center") : (m = v - _, f = m - 5, h = "right")) : (v = (u[1][0] + u[2][0]) / 2, g = (u[1][1] + u[2][1]) / 2, r === "horizontal" ? (y = g + _, d = y + 5, h = "center") : (m = v + _, f = m + 5, h = "left")), r === "horizontal" ? (m = v, f = m) : (y = g, d = y), p = [
          [
            v,
            g
          ],
          [
            m,
            y
          ]
        ];
      }
      l.label = {
        linePoints: p,
        x: f,
        y: d,
        verticalAlign: "middle",
        textAlign: h,
        inside: c
      };
    });
  }
  function Cue(t, e) {
    t.eachSeriesByType("funnel", function(r) {
      var n = r.getData(), i = n.mapDimension("value"), a = r.get("sort"), o = wue(r, e), s = r.get("orient"), l = o.width, u = o.height, c = Sue(n, a), h = o.x, f = o.y, d = s === "horizontal" ? [
        pe(r.get("minSize"), u),
        pe(r.get("maxSize"), u)
      ] : [
        pe(r.get("minSize"), l),
        pe(r.get("maxSize"), l)
      ], p = n.getDataExtent(i), v = r.get("min"), g = r.get("max");
      v == null && (v = Math.min(p[0], 0)), g == null && (g = p[1]);
      var m = r.get("funnelAlign"), y = r.get("gap"), _ = s === "horizontal" ? l : u, b = (_ - y * (n.count() - 1)) / n.count(), w = function(z, F) {
        if (s === "horizontal") {
          var E = n.get(i, z) || 0, O = Et(E, [
            v,
            g
          ], d, true), N = void 0;
          switch (m) {
            case "top":
              N = f;
              break;
            case "center":
              N = f + (u - O) / 2;
              break;
            case "bottom":
              N = f + (u - O);
              break;
          }
          return [
            [
              F,
              N
            ],
            [
              F,
              N + O
            ]
          ];
        }
        var V = n.get(i, z) || 0, H = Et(V, [
          v,
          g
        ], d, true), G;
        switch (m) {
          case "left":
            G = h;
            break;
          case "center":
            G = h + (l - H) / 2;
            break;
          case "right":
            G = h + l - H;
            break;
        }
        return [
          [
            G,
            F
          ],
          [
            G + H,
            F
          ]
        ];
      };
      a === "ascending" && (b = -b, y = -y, s === "horizontal" ? h += l : f += u, c = c.reverse());
      for (var x = 0; x < c.length; x++) {
        var T = c[x], A = c[x + 1], I = n.getItemModel(T);
        if (s === "horizontal") {
          var M = I.get([
            "itemStyle",
            "width"
          ]);
          M == null ? M = b : (M = pe(M, l), a === "ascending" && (M = -M));
          var k = w(T, h), B = w(A, h + M);
          h += M + y, n.setItemLayout(T, {
            points: k.concat(B.slice().reverse())
          });
        } else {
          var L = I.get([
            "itemStyle",
            "height"
          ]);
          L == null ? L = b : (L = pe(L, u), a === "ascending" && (L = -L));
          var k = w(T, f), B = w(A, f + L);
          f += L + y, n.setItemLayout(T, {
            points: k.concat(B.slice().reverse())
          });
        }
      }
      Tue(n);
    });
  }
  function Aue(t) {
    t.registerChartView(bue), t.registerSeriesModel(xue), t.registerLayout(Cue), t.registerProcessor(Ud("funnel"));
  }
  var Iue = 0.3, Mue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._dataGroup = new Be(), r._initialized = false, r;
    }
    return e.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, e.prototype.render = function(r, n, i, a) {
      this._progressiveEls = null;
      var o = this._dataGroup, s = r.getData(), l = this._data, u = r.coordinateSystem, c = u.dimensions, h = XP(r);
      s.diff(l).add(f).update(d).remove(p).execute();
      function f(g) {
        var m = qP(s, o, g, c, u);
        R_(m, s, g, h);
      }
      function d(g, m) {
        var y = l.getItemGraphicEl(m), _ = TW(s, g, c, u);
        s.setItemGraphicEl(g, y), wt(y, {
          shape: {
            points: _
          }
        }, r, g), Ki(y), R_(y, s, g, h);
      }
      function p(g) {
        var m = l.getItemGraphicEl(g);
        o.remove(m);
      }
      if (!this._initialized) {
        this._initialized = true;
        var v = Due(u, r, function() {
          setTimeout(function() {
            o.removeClipPath();
          });
        });
        o.setClipPath(v);
      }
      this._data = s;
    }, e.prototype.incrementalPrepareRender = function(r, n, i) {
      this._initialized = true, this._data = null, this._dataGroup.removeAll();
    }, e.prototype.incrementalRender = function(r, n, i) {
      for (var a = n.getData(), o = n.coordinateSystem, s = o.dimensions, l = XP(n), u = this._progressiveEls = [], c = r.start; c < r.end; c++) {
        var h = qP(a, this._dataGroup, c, s, o);
        h.incremental = true, R_(h, a, c, l), u.push(h);
      }
    }, e.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, e.type = "parallel", e;
  }(Ft);
  function Due(t, e, r) {
    var n = t.model, i = t.getRect(), a = new yt({
      shape: {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      }
    }), o = n.get("layout") === "horizontal" ? "width" : "height";
    return a.setShape(o, 0), er(a, {
      shape: {
        width: i.width,
        height: i.height
      }
    }, e, r), a;
  }
  function TW(t, e, r, n) {
    for (var i = [], a = 0; a < r.length; a++) {
      var o = r[a], s = t.get(t.mapDimension(o), e);
      Eue(s, n.getAxis(o).type) || i.push(n.dataToPoint(s, o));
    }
    return i;
  }
  function qP(t, e, r, n, i) {
    var a = TW(t, r, n, i), o = new Tn({
      shape: {
        points: a
      },
      z2: 10
    });
    return e.add(o), t.setItemGraphicEl(r, o), o;
  }
  function XP(t) {
    var e = t.get("smooth", true);
    return e === true && (e = Iue), e = ho(e), Ff(e) && (e = 0), {
      smooth: e
    };
  }
  function R_(t, e, r, n) {
    t.useStyle(e.getItemVisual(r, "style")), t.style.fill = null, t.setShape("smooth", n.smooth);
    var i = e.getItemModel(r), a = i.getModel("emphasis");
    qr(t, i, "lineStyle"), ir(t, a.get("focus"), a.get("blurScope"), a.get("disabled"));
  }
  function Eue(t, e) {
    return e === "category" ? t == null : t == null || isNaN(t);
  }
  var kue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.visualStyleAccessPath = "lineStyle", r.visualDrawType = "stroke", r;
    }
    return e.prototype.getInitialData = function(r, n) {
      return So(null, this, {
        useEncodeDefaulter: _e(Pue, null, this)
      });
    }, e.prototype.getRawIndicesByActiveState = function(r) {
      var n = this.coordinateSystem, i = this.getData(), a = [];
      return n.eachActiveState(i, function(o, s) {
        r === o && a.push(i.getRawIndex(s));
      }), a;
    }, e.type = "series.parallel", e.dependencies = [
      "parallel"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: false
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: false
        }
      },
      progressive: 500,
      smooth: false,
      animationEasing: "linear"
    }, e;
  }(Xt);
  function Pue(t) {
    var e = t.ecModel.getComponent("parallel", t.get("parallelIndex"));
    if (e) {
      var r = {};
      return $(e.dimensions, function(n) {
        var i = Lue(n);
        r[n] = i;
      }), r;
    }
  }
  function Lue(t) {
    return +t.replace("dim", "");
  }
  var $ue = [
    "lineStyle",
    "opacity"
  ], Rue = {
    seriesType: "parallel",
    reset: function(t, e) {
      var r = t.coordinateSystem, n = {
        normal: t.get([
          "lineStyle",
          "opacity"
        ]),
        active: t.get("activeOpacity"),
        inactive: t.get("inactiveOpacity")
      };
      return {
        progress: function(i, a) {
          r.eachActiveState(a, function(o, s) {
            var l = n[o];
            if (o === "normal" && a.hasItemOption) {
              var u = a.getItemModel(s).get($ue, true);
              u != null && (l = u);
            }
            var c = a.ensureUniqueItemVisual(s, "style");
            c.opacity = l;
          }, i.start, i.end);
        }
      };
    }
  };
  function Oue(t) {
    Nue(t), Bue(t);
  }
  function Nue(t) {
    if (!t.parallel) {
      var e = false;
      $(t.series, function(r) {
        r && r.type === "parallel" && (e = true);
      }), e && (t.parallel = [
        {}
      ]);
    }
  }
  function Bue(t) {
    var e = Ot(t.parallelAxis);
    $(e, function(r) {
      if (Le(r)) {
        var n = r.parallelIndex || 0, i = Ot(t.parallel)[n];
        i && i.parallelAxisDefault && je(r, i.parallelAxisDefault, false);
      }
    });
  }
  var zue = 5, Fue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      this._model = r, this._api = i, this._handlers || (this._handlers = {}, $(Vue, function(a, o) {
        i.getZr().on(o, this._handlers[o] = _e(a, this));
      }, this)), jc(this, "_throttledDispatchExpand", r.get("axisExpandRate"), "fixRate");
    }, e.prototype.dispose = function(r, n) {
      Jf(this, "_throttledDispatchExpand"), $(this._handlers, function(i, a) {
        n.getZr().off(a, i);
      }), this._handlers = null;
    }, e.prototype._throttledDispatchExpand = function(r) {
      this._dispatchExpand(r);
    }, e.prototype._dispatchExpand = function(r) {
      r && this._api.dispatchAction(te({
        type: "parallelAxisExpand"
      }, r));
    }, e.type = "parallel", e;
  }(tr), Vue = {
    mousedown: function(t) {
      O_(this, "click") && (this._mouseDownPoint = [
        t.offsetX,
        t.offsetY
      ]);
    },
    mouseup: function(t) {
      var e = this._mouseDownPoint;
      if (O_(this, "click") && e) {
        var r = [
          t.offsetX,
          t.offsetY
        ], n = Math.pow(e[0] - r[0], 2) + Math.pow(e[1] - r[1], 2);
        if (n > zue) return;
        var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([
          t.offsetX,
          t.offsetY
        ]);
        i.behavior !== "none" && this._dispatchExpand({
          axisExpandWindow: i.axisExpandWindow
        });
      }
      this._mouseDownPoint = null;
    },
    mousemove: function(t) {
      if (!(this._mouseDownPoint || !O_(this, "mousemove"))) {
        var e = this._model, r = e.coordinateSystem.getSlidedAxisExpandWindow([
          t.offsetX,
          t.offsetY
        ]), n = r.behavior;
        n === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(n === "none" ? null : {
          axisExpandWindow: r.axisExpandWindow,
          animation: n === "jump" ? null : {
            duration: 0
          }
        });
      }
    }
  };
  function O_(t, e) {
    var r = t._model;
    return r.get("axisExpandable") && r.get("axisExpandTriggerOn") === e;
  }
  var Gue = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function() {
      t.prototype.init.apply(this, arguments), this.mergeOption({});
    }, e.prototype.mergeOption = function(r) {
      var n = this.option;
      r && je(n, r, true), this._initDimensions();
    }, e.prototype.contains = function(r, n) {
      var i = r.get("parallelIndex");
      return i != null && n.getComponent("parallel", i) === this;
    }, e.prototype.setAxisExpand = function(r) {
      $([
        "axisExpandable",
        "axisExpandCenter",
        "axisExpandCount",
        "axisExpandWidth",
        "axisExpandWindow"
      ], function(n) {
        r.hasOwnProperty(n) && (this.option[n] = r[n]);
      }, this);
    }, e.prototype._initDimensions = function() {
      var r = this.dimensions = [], n = this.parallelAxisIndex = [], i = Dt(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      $(i, function(a) {
        r.push("dim" + a.get("dim")), n.push(a.componentIndex);
      });
    }, e.type = "parallel", e.dependencies = [
      "parallelAxis"
    ], e.layoutMode = "box", e.defaultOption = {
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      layout: "horizontal",
      axisExpandable: false,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      axisExpandSlideTriggerArea: [
        -0.15,
        0.05,
        0.4
      ],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, e;
  }(vt), Wue = function(t) {
    K(e, t);
    function e(r, n, i, a, o) {
      var s = t.call(this, r, n, i) || this;
      return s.type = a || "value", s.axisIndex = o, s;
    }
    return e.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, e;
  }(Ji);
  function cu(t, e, r, n, i, a) {
    t = t || 0;
    var o = r[1] - r[0];
    if (i != null && (i = $u(i, [
      0,
      o
    ])), a != null && (a = Math.max(a, i ?? 0)), n === "all") {
      var s = Math.abs(e[1] - e[0]);
      s = $u(s, [
        0,
        o
      ]), i = a = $u(s, [
        i,
        a
      ]), n = 0;
    }
    e[0] = $u(e[0], r), e[1] = $u(e[1], r);
    var l = N_(e, n);
    e[n] += t;
    var u = i || 0, c = r.slice();
    l.sign < 0 ? c[0] += u : c[1] -= u, e[n] = $u(e[n], c);
    var h;
    return h = N_(e, n), i != null && (h.sign !== l.sign || h.span < i) && (e[1 - n] = e[n] + l.sign * i), h = N_(e, n), a != null && h.span > a && (e[1 - n] = e[n] + h.sign * a), e;
  }
  function N_(t, e) {
    var r = t[e] - t[1 - e];
    return {
      span: Math.abs(r),
      sign: r > 0 ? -1 : r < 0 ? 1 : e ? -1 : 1
    };
  }
  function $u(t, e) {
    return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, t));
  }
  var B_ = $, CW = Math.min, AW = Math.max, jP = Math.floor, Hue = Math.ceil, KP = lr, Uue = Math.PI, Yue = function() {
    function t(e, r, n) {
      this.type = "parallel", this._axesMap = Ce(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, r, n);
    }
    return t.prototype._init = function(e, r, n) {
      var i = e.dimensions, a = e.parallelAxisIndex;
      B_(i, function(o, s) {
        var l = a[s], u = r.getComponent("parallelAxis", l), c = this._axesMap.set(o, new Wue(o, fy(u), [
          0,
          0
        ], u.get("type"), l)), h = c.type === "category";
        c.onBand = h && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, t.prototype.update = function(e, r) {
      this._updateAxesFromSeries(this._model, e);
    }, t.prototype.containPoint = function(e) {
      var r = this._makeLayoutInfo(), n = r.axisBase, i = r.layoutBase, a = r.pixelDimIndex, o = e[1 - a], s = e[a];
      return o >= n && o <= n + r.axisLength && s >= i && s <= i + r.layoutLength;
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype._updateAxesFromSeries = function(e, r) {
      r.eachSeries(function(n) {
        if (e.contains(n, r)) {
          var i = n.getData();
          B_(this.dimensions, function(a) {
            var o = this._axesMap.get(a);
            o.scale.unionExtentFromData(i, i.mapDimension(a)), xc(o.scale, o.model);
          }, this);
        }
      }, this);
    }, t.prototype.resize = function(e, r) {
      this._rect = Tr(e.getBoxLayoutParams(), {
        width: r.getWidth(),
        height: r.getHeight()
      }), this._layoutAxes();
    }, t.prototype.getRect = function() {
      return this._rect;
    }, t.prototype._makeLayoutInfo = function() {
      var e = this._model, r = this._rect, n = [
        "x",
        "y"
      ], i = [
        "width",
        "height"
      ], a = e.get("layout"), o = a === "horizontal" ? 0 : 1, s = r[i[o]], l = [
        0,
        s
      ], u = this.dimensions.length, c = nv(e.get("axisExpandWidth"), l), h = nv(e.get("axisExpandCount") || 0, [
        0,
        u
      ]), f = e.get("axisExpandable") && u > 3 && u > h && h > 1 && c > 0 && s > 0, d = e.get("axisExpandWindow"), p;
      if (d) p = nv(d[1] - d[0], l), d[1] = d[0] + p;
      else {
        p = nv(c * (h - 1), l);
        var v = e.get("axisExpandCenter") || jP(u / 2);
        d = [
          c * v - p / 2
        ], d[1] = d[0] + p;
      }
      var g = (s - p) / (u - h);
      g < 3 && (g = 0);
      var m = [
        jP(KP(d[0] / c, 1)) + 1,
        Hue(KP(d[1] / c, 1)) - 1
      ], y = g / c * d[0];
      return {
        layout: a,
        pixelDimIndex: o,
        layoutBase: r[n[o]],
        layoutLength: s,
        axisBase: r[n[1 - o]],
        axisLength: r[i[1 - o]],
        axisExpandable: f,
        axisExpandWidth: c,
        axisCollapseWidth: g,
        axisExpandWindow: d,
        axisCount: u,
        winInnerIndices: m,
        axisExpandWindow0Pos: y
      };
    }, t.prototype._layoutAxes = function() {
      var e = this._rect, r = this._axesMap, n = this.dimensions, i = this._makeLayoutInfo(), a = i.layout;
      r.each(function(o) {
        var s = [
          0,
          i.axisLength
        ], l = o.inverse ? 1 : 0;
        o.setExtent(s[l], s[1 - l]);
      }), B_(n, function(o, s) {
        var l = (i.axisExpandable ? Xue : que)(s, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: Uue / 2,
          vertical: 0
        }, h = [
          u[a].x + e.x,
          u[a].y + e.y
        ], f = c[a], d = Hn();
        nu(d, d, f), Pa(d, d, h), this._axesLayout[o] = {
          position: h,
          rotation: f,
          transform: d,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, t.prototype.getAxis = function(e) {
      return this._axesMap.get(e);
    }, t.prototype.dataToPoint = function(e, r) {
      return this.axisCoordToPoint(this._axesMap.get(r).dataToCoord(e), r);
    }, t.prototype.eachActiveState = function(e, r, n, i) {
      n == null && (n = 0), i == null && (i = e.count());
      var a = this._axesMap, o = this.dimensions, s = [], l = [];
      $(o, function(g) {
        s.push(e.mapDimension(g)), l.push(a.get(g).model);
      });
      for (var u = this.hasAxisBrushed(), c = n; c < i; c++) {
        var h = void 0;
        if (!u) h = "normal";
        else {
          h = "active";
          for (var f = e.getValues(s, c), d = 0, p = o.length; d < p; d++) {
            var v = l[d].getActiveState(f[d]);
            if (v === "inactive") {
              h = "inactive";
              break;
            }
          }
        }
        r(h, c);
      }
    }, t.prototype.hasAxisBrushed = function() {
      for (var e = this.dimensions, r = this._axesMap, n = false, i = 0, a = e.length; i < a; i++) r.get(e[i]).model.getActiveState() !== "normal" && (n = true);
      return n;
    }, t.prototype.axisCoordToPoint = function(e, r) {
      var n = this._axesLayout[r];
      return Yi([
        e,
        0
      ], n.transform);
    }, t.prototype.getAxisLayout = function(e) {
      return Oe(this._axesLayout[e]);
    }, t.prototype.getSlidedAxisExpandWindow = function(e) {
      var r = this._makeLayoutInfo(), n = r.pixelDimIndex, i = r.axisExpandWindow.slice(), a = i[1] - i[0], o = [
        0,
        r.axisExpandWidth * (r.axisCount - 1)
      ];
      if (!this.containPoint(e)) return {
        behavior: "none",
        axisExpandWindow: i
      };
      var s = e[n] - r.layoutBase - r.axisExpandWindow0Pos, l, u = "slide", c = r.axisCollapseWidth, h = this._model.get("axisExpandSlideTriggerArea"), f = h[0] != null;
      if (c) f && c && s < a * h[0] ? (u = "jump", l = s - a * h[2]) : f && c && s > a * (1 - h[0]) ? (u = "jump", l = s - a * (1 - h[2])) : (l = s - a * h[1]) >= 0 && (l = s - a * (1 - h[1])) <= 0 && (l = 0), l *= r.axisExpandWidth / c, l ? cu(l, i, o, "all") : u = "none";
      else {
        var d = i[1] - i[0], p = o[1] * s / d;
        i = [
          AW(0, p - d / 2)
        ], i[1] = CW(o[1], i[0] + d), i[0] = i[1] - d;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, t;
  }();
  function nv(t, e) {
    return CW(AW(t, e[0]), e[1]);
  }
  function que(t, e) {
    var r = e.layoutLength / (e.axisCount - 1);
    return {
      position: r * t,
      axisNameAvailableWidth: r,
      axisLabelShow: true
    };
  }
  function Xue(t, e) {
    var r = e.layoutLength, n = e.axisExpandWidth, i = e.axisCount, a = e.axisCollapseWidth, o = e.winInnerIndices, s, l = a, u = false, c;
    return t < o[0] ? (s = t * a, c = a) : t <= o[1] ? (s = e.axisExpandWindow0Pos + t * n - e.axisExpandWindow[0], l = n, u = true) : (s = r - (i - 1 - t) * a, c = a), {
      position: s,
      axisNameAvailableWidth: l,
      axisLabelShow: u,
      nameTruncateMaxWidth: c
    };
  }
  function jue(t, e) {
    var r = [];
    return t.eachComponent("parallel", function(n, i) {
      var a = new Yue(n, t, e);
      a.name = "parallel_" + i, a.resize(n, e), n.coordinateSystem = a, a.model = n, r.push(a);
    }), t.eachSeries(function(n) {
      if (n.get("coordinateSystem") === "parallel") {
        var i = n.getReferringComponents("parallel", gr).models[0];
        n.coordinateSystem = i.coordinateSystem;
      }
    }), r;
  }
  var Kue = {
    create: jue
  }, yw = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.activeIntervals = [], r;
    }
    return e.prototype.getAreaSelectStyle = function() {
      return ql([
        [
          "fill",
          "color"
        ],
        [
          "lineWidth",
          "borderWidth"
        ],
        [
          "stroke",
          "borderColor"
        ],
        [
          "width",
          "width"
        ],
        [
          "opacity",
          "opacity"
        ]
      ])(this.getModel("areaSelectStyle"));
    }, e.prototype.setActiveIntervals = function(r) {
      var n = this.activeIntervals = Oe(r);
      if (n) for (var i = n.length - 1; i >= 0; i--) mi(n[i]);
    }, e.prototype.getActiveState = function(r) {
      var n = this.activeIntervals;
      if (!n.length) return "normal";
      if (r == null || isNaN(+r)) return "inactive";
      if (n.length === 1) {
        var i = n[0];
        if (i[0] <= r && r <= i[1]) return "active";
      } else for (var a = 0, o = n.length; a < o; a++) if (n[a][0] <= r && r <= n[a][1]) return "active";
      return "inactive";
    }, e;
  }(vt);
  yr(yw, Fd);
  var Kl = true, hd = Math.min, Tc = Math.max, Zue = Math.pow, Que = 1e4, Jue = 6, ece = 6, ZP = "globalPan", tce = {
    w: [
      0,
      0
    ],
    e: [
      0,
      1
    ],
    n: [
      1,
      0
    ],
    s: [
      1,
      1
    ]
  }, rce = {
    w: "ew",
    e: "ew",
    n: "ns",
    s: "ns",
    ne: "nesw",
    sw: "nesw",
    nw: "nwse",
    se: "nwse"
  }, QP = {
    brushStyle: {
      lineWidth: 2,
      stroke: "rgba(210,219,238,0.3)",
      fill: "#D2DBEE"
    },
    transformable: true,
    brushMode: "single",
    removeOnClick: false
  }, nce = 0, v2 = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this) || this;
      return n._track = [], n._covers = [], n._handlers = {}, n._zr = r, n.group = new Be(), n._uid = "brushController_" + nce++, $(cce, function(i, a) {
        this._handlers[a] = _e(i, this);
      }, n), n;
    }
    return e.prototype.enableBrush = function(r) {
      return this._brushType && this._doDisableBrush(), r.brushType && this._doEnableBrush(r), this;
    }, e.prototype._doEnableBrush = function(r) {
      var n = this._zr;
      this._enableGlobalPan || qoe(n, ZP, this._uid), $(this._handlers, function(i, a) {
        n.on(a, i);
      }), this._brushType = r.brushType, this._brushOption = je(Oe(QP), r, true);
    }, e.prototype._doDisableBrush = function() {
      var r = this._zr;
      Xoe(r, ZP, this._uid), $(this._handlers, function(n, i) {
        r.off(i, n);
      }), this._brushType = this._brushOption = null;
    }, e.prototype.setPanels = function(r) {
      if (r && r.length) {
        var n = this._panels = {};
        $(r, function(i) {
          n[i.panelId] = Oe(i);
        });
      } else this._panels = null;
      return this;
    }, e.prototype.mount = function(r) {
      r = r || {}, this._enableGlobalPan = r.enableGlobalPan;
      var n = this.group;
      return this._zr.add(n), n.attr({
        x: r.x || 0,
        y: r.y || 0,
        rotation: r.rotation || 0,
        scaleX: r.scaleX || 1,
        scaleY: r.scaleY || 1
      }), this._transform = n.getLocalTransform(), this;
    }, e.prototype.updateCovers = function(r) {
      r = oe(r, function(f) {
        return je(Oe(QP), f, true);
      });
      var n = "\0-brush-index-", i = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
      return new vo(i, r, u, l).add(c).update(c).remove(h).execute(), this;
      function l(f, d) {
        return (f.id != null ? f.id : n + d) + "-" + f.brushType;
      }
      function u(f, d) {
        return l(f.__brushOption, d);
      }
      function c(f, d) {
        var p = r[f];
        if (d != null && i[d] === s) a[f] = i[d];
        else {
          var v = a[f] = d != null ? (i[d].__brushOption = p, i[d]) : MW(o, IW(o, p));
          g2(o, v);
        }
      }
      function h(f) {
        i[f] !== s && o.group.remove(i[f]);
      }
    }, e.prototype.unmount = function() {
      return this.enableBrush(false), _w(this), this._zr.remove(this.group), this;
    }, e.prototype.dispose = function() {
      this.unmount(), this.off();
    }, e;
  }(xi);
  function IW(t, e) {
    var r = yy[e.brushType].createCover(t, e);
    return r.__brushOption = e, EW(r, e), t.group.add(r), r;
  }
  function MW(t, e) {
    var r = m2(e);
    return r.endCreating && (r.endCreating(t, e), EW(e, e.__brushOption)), e;
  }
  function DW(t, e) {
    var r = e.__brushOption;
    m2(e).updateCoverShape(t, e, r.range, r);
  }
  function EW(t, e) {
    var r = e.z;
    r == null && (r = Que), t.traverse(function(n) {
      n.z = r, n.z2 = r;
    });
  }
  function g2(t, e) {
    m2(e).updateCommon(t, e), DW(t, e);
  }
  function m2(t) {
    return yy[t.__brushOption.brushType];
  }
  function y2(t, e, r) {
    var n = t._panels;
    if (!n) return Kl;
    var i, a = t._transform;
    return $(n, function(o) {
      o.isTargetByCursor(e, r, a) && (i = o);
    }), i;
  }
  function kW(t, e) {
    var r = t._panels;
    if (!r) return Kl;
    var n = e.__brushOption.panelId;
    return n != null ? r[n] : Kl;
  }
  function _w(t) {
    var e = t._covers, r = e.length;
    return $(e, function(n) {
      t.group.remove(n);
    }, t), e.length = 0, !!r;
  }
  function Zl(t, e) {
    var r = oe(t._covers, function(n) {
      var i = n.__brushOption, a = Oe(i.range);
      return {
        brushType: i.brushType,
        panelId: i.panelId,
        range: a
      };
    });
    t.trigger("brush", {
      areas: r,
      isEnd: !!e.isEnd,
      removeOnClick: !!e.removeOnClick
    });
  }
  function ice(t) {
    var e = t._track;
    if (!e.length) return false;
    var r = e[e.length - 1], n = e[0], i = r[0] - n[0], a = r[1] - n[1], o = Zue(i * i + a * a, 0.5);
    return o > Jue;
  }
  function PW(t) {
    var e = t.length - 1;
    return e < 0 && (e = 0), [
      t[0],
      t[e]
    ];
  }
  function LW(t, e, r, n) {
    var i = new Be();
    return i.add(new yt({
      name: "main",
      style: _2(r),
      silent: true,
      draggable: true,
      cursor: "move",
      drift: Ye(JP, t, e, i, [
        "n",
        "s",
        "w",
        "e"
      ]),
      ondragend: Ye(Zl, e, {
        isEnd: true
      })
    })), $(n, function(a) {
      i.add(new yt({
        name: a.join(""),
        style: {
          opacity: 0
        },
        draggable: true,
        silent: true,
        invisible: true,
        drift: Ye(JP, t, e, i, a),
        ondragend: Ye(Zl, e, {
          isEnd: true
        })
      }));
    }), i;
  }
  function $W(t, e, r, n) {
    var i = n.brushStyle.lineWidth || 0, a = Tc(i, ece), o = r[0][0], s = r[1][0], l = o - i / 2, u = s - i / 2, c = r[0][1], h = r[1][1], f = c - a + i / 2, d = h - a + i / 2, p = c - o, v = h - s, g = p + i, m = v + i;
    Ua(t, e, "main", o, s, p, v), n.transformable && (Ua(t, e, "w", l, u, a, m), Ua(t, e, "e", f, u, a, m), Ua(t, e, "n", l, u, g, a), Ua(t, e, "s", l, d, g, a), Ua(t, e, "nw", l, u, a, a), Ua(t, e, "ne", f, u, a, a), Ua(t, e, "sw", l, d, a, a), Ua(t, e, "se", f, d, a, a));
  }
  function bw(t, e) {
    var r = e.__brushOption, n = r.transformable, i = e.childAt(0);
    i.useStyle(_2(r)), i.attr({
      silent: !n,
      cursor: n ? "move" : "default"
    }), $([
      [
        "w"
      ],
      [
        "e"
      ],
      [
        "n"
      ],
      [
        "s"
      ],
      [
        "s",
        "e"
      ],
      [
        "s",
        "w"
      ],
      [
        "n",
        "e"
      ],
      [
        "n",
        "w"
      ]
    ], function(a) {
      var o = e.childOfName(a.join("")), s = a.length === 1 ? xw(t, a[0]) : oce(t, a);
      o && o.attr({
        silent: !n,
        invisible: !n,
        cursor: n ? rce[s] + "-resize" : null
      });
    });
  }
  function Ua(t, e, r, n, i, a, o) {
    var s = e.childOfName(r);
    s && s.setShape(lce(b2(t, e, [
      [
        n,
        i
      ],
      [
        n + a,
        i + o
      ]
    ])));
  }
  function _2(t) {
    return Ee({
      strokeNoScale: true
    }, t.brushStyle);
  }
  function RW(t, e, r, n) {
    var i = [
      hd(t, r),
      hd(e, n)
    ], a = [
      Tc(t, r),
      Tc(e, n)
    ];
    return [
      [
        i[0],
        a[0]
      ],
      [
        i[1],
        a[1]
      ]
    ];
  }
  function ace(t) {
    return Bl(t.group);
  }
  function xw(t, e) {
    var r = {
      w: "left",
      e: "right",
      n: "top",
      s: "bottom"
    }, n = {
      left: "w",
      right: "e",
      top: "n",
      bottom: "s"
    }, i = Km(r[e], ace(t));
    return n[i];
  }
  function oce(t, e) {
    var r = [
      xw(t, e[0]),
      xw(t, e[1])
    ];
    return (r[0] === "e" || r[0] === "w") && r.reverse(), r.join("");
  }
  function JP(t, e, r, n, i, a) {
    var o = r.__brushOption, s = t.toRectRange(o.range), l = OW(e, i, a);
    $(n, function(u) {
      var c = tce[u];
      s[c[0]][c[1]] += l[c[0]];
    }), o.range = t.fromRectRange(RW(s[0][0], s[1][0], s[0][1], s[1][1])), g2(e, r), Zl(e, {
      isEnd: false
    });
  }
  function sce(t, e, r, n) {
    var i = e.__brushOption.range, a = OW(t, r, n);
    $(i, function(o) {
      o[0] += a[0], o[1] += a[1];
    }), g2(t, e), Zl(t, {
      isEnd: false
    });
  }
  function OW(t, e, r) {
    var n = t.group, i = n.transformCoordToLocal(e, r), a = n.transformCoordToLocal(0, 0);
    return [
      i[0] - a[0],
      i[1] - a[1]
    ];
  }
  function b2(t, e, r) {
    var n = kW(t, e);
    return n && n !== Kl ? n.clipPath(r, t._transform) : Oe(r);
  }
  function lce(t) {
    var e = hd(t[0][0], t[1][0]), r = hd(t[0][1], t[1][1]), n = Tc(t[0][0], t[1][0]), i = Tc(t[0][1], t[1][1]);
    return {
      x: e,
      y: r,
      width: n - e,
      height: i - r
    };
  }
  function uce(t, e, r) {
    if (!(!t._brushType || hce(t, e.offsetX, e.offsetY))) {
      var n = t._zr, i = t._covers, a = y2(t, e, r);
      if (!t._dragging) for (var o = 0; o < i.length; o++) {
        var s = i[o].__brushOption;
        if (a && (a === Kl || s.panelId === a.panelId) && yy[s.brushType].contain(i[o], r[0], r[1])) return;
      }
      a && n.setCursorStyle("crosshair");
    }
  }
  function ww(t) {
    var e = t.event;
    e.preventDefault && e.preventDefault();
  }
  function Sw(t, e, r) {
    return t.childOfName("main").contain(e, r);
  }
  function NW(t, e, r, n) {
    var i = t._creatingCover, a = t._creatingPanel, o = t._brushOption, s;
    if (t._track.push(r.slice()), ice(t) || i) {
      if (a && !i) {
        o.brushMode === "single" && _w(t);
        var l = Oe(o);
        l.brushType = eL(l.brushType, a), l.panelId = a === Kl ? null : a.panelId, i = t._creatingCover = IW(t, l), t._covers.push(i);
      }
      if (i) {
        var u = yy[eL(t._brushType, a)], c = i.__brushOption;
        c.range = u.getCreatingRange(b2(t, i, t._track)), n && (MW(t, i), u.updateCommon(t, i)), DW(t, i), s = {
          isEnd: n
        };
      }
    } else n && o.brushMode === "single" && o.removeOnClick && y2(t, e, r) && _w(t) && (s = {
      isEnd: n,
      removeOnClick: true
    });
    return s;
  }
  function eL(t, e) {
    return t === "auto" ? e.defaultBrushType : t;
  }
  var cce = {
    mousedown: function(t) {
      if (this._dragging) tL(this, t);
      else if (!t.target || !t.target.draggable) {
        ww(t);
        var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);
        this._creatingCover = null;
        var r = this._creatingPanel = y2(this, t, e);
        r && (this._dragging = true, this._track = [
          e.slice()
        ]);
      }
    },
    mousemove: function(t) {
      var e = t.offsetX, r = t.offsetY, n = this.group.transformCoordToLocal(e, r);
      if (uce(this, t, n), this._dragging) {
        ww(t);
        var i = NW(this, t, n, false);
        i && Zl(this, i);
      }
    },
    mouseup: function(t) {
      tL(this, t);
    }
  };
  function tL(t, e) {
    if (t._dragging) {
      ww(e);
      var r = e.offsetX, n = e.offsetY, i = t.group.transformCoordToLocal(r, n), a = NW(t, e, i, true);
      t._dragging = false, t._track = [], t._creatingCover = null, a && Zl(t, a);
    }
  }
  function hce(t, e, r) {
    var n = t._zr;
    return e < 0 || e > n.getWidth() || r < 0 || r > n.getHeight();
  }
  var yy = {
    lineX: rL(0),
    lineY: rL(1),
    rect: {
      createCover: function(t, e) {
        function r(n) {
          return n;
        }
        return LW({
          toRectRange: r,
          fromRectRange: r
        }, t, e, [
          [
            "w"
          ],
          [
            "e"
          ],
          [
            "n"
          ],
          [
            "s"
          ],
          [
            "s",
            "e"
          ],
          [
            "s",
            "w"
          ],
          [
            "n",
            "e"
          ],
          [
            "n",
            "w"
          ]
        ]);
      },
      getCreatingRange: function(t) {
        var e = PW(t);
        return RW(e[1][0], e[1][1], e[0][0], e[0][1]);
      },
      updateCoverShape: function(t, e, r, n) {
        $W(t, e, r, n);
      },
      updateCommon: bw,
      contain: Sw
    },
    polygon: {
      createCover: function(t, e) {
        var r = new Be();
        return r.add(new Tn({
          name: "main",
          style: _2(e),
          silent: true
        })), r;
      },
      getCreatingRange: function(t) {
        return t;
      },
      endCreating: function(t, e) {
        e.remove(e.childAt(0)), e.add(new Sn({
          name: "main",
          draggable: true,
          drift: Ye(sce, t, e),
          ondragend: Ye(Zl, t, {
            isEnd: true
          })
        }));
      },
      updateCoverShape: function(t, e, r, n) {
        e.childAt(0).setShape({
          points: b2(t, e, r)
        });
      },
      updateCommon: bw,
      contain: Sw
    }
  };
  function rL(t) {
    return {
      createCover: function(e, r) {
        return LW({
          toRectRange: function(n) {
            var i = [
              n,
              [
                0,
                100
              ]
            ];
            return t && i.reverse(), i;
          },
          fromRectRange: function(n) {
            return n[t];
          }
        }, e, r, [
          [
            [
              "w"
            ],
            [
              "e"
            ]
          ],
          [
            [
              "n"
            ],
            [
              "s"
            ]
          ]
        ][t]);
      },
      getCreatingRange: function(e) {
        var r = PW(e), n = hd(r[0][t], r[1][t]), i = Tc(r[0][t], r[1][t]);
        return [
          n,
          i
        ];
      },
      updateCoverShape: function(e, r, n, i) {
        var a, o = kW(e, r);
        if (o !== Kl && o.getLinearBrushOtherExtent) a = o.getLinearBrushOtherExtent(t);
        else {
          var s = e._zr;
          a = [
            0,
            [
              s.getWidth(),
              s.getHeight()
            ][1 - t]
          ];
        }
        var l = [
          n,
          a
        ];
        t && l.reverse(), $W(e, r, l, i);
      },
      updateCommon: bw,
      contain: Sw
    };
  }
  function BW(t) {
    return t = x2(t), function(e) {
      return X4(e, t);
    };
  }
  function zW(t, e) {
    return t = x2(t), function(r) {
      var n = e ?? r, i = n ? t.width : t.height, a = n ? t.x : t.y;
      return [
        a,
        a + (i || 0)
      ];
    };
  }
  function FW(t, e, r) {
    var n = x2(t);
    return function(i, a) {
      return n.contain(a[0], a[1]) && !py(i, e, r);
    };
  }
  function x2(t) {
    return Ze.create(t);
  }
  var fce = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], dce = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r, n) {
      t.prototype.init.apply(this, arguments), (this._brushController = new v2(n.getZr())).on("brush", _e(this._onBrush, this));
    }, e.prototype.render = function(r, n, i, a) {
      if (!pce(r, n, a)) {
        this.axisModel = r, this.api = i, this.group.removeAll();
        var o = this._axisGroup;
        if (this._axisGroup = new Be(), this.group.add(this._axisGroup), !!r.get("show")) {
          var s = gce(r, n), l = s.coordinateSystem, u = r.getAreaSelectStyle(), c = u.width, h = r.axis.dim, f = l.getAxisLayout(h), d = te({
            strokeContainThreshold: c
          }, f), p = new _n(r, d);
          $(fce, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(d, u, r, s, c, i), Rd(o, this._axisGroup, r);
        }
      }
    }, e.prototype._refreshBrushController = function(r, n, i, a, o, s) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), h = Ze.create({
        x: l[0],
        y: -o / 2,
        width: u,
        height: o
      });
      h.x -= c, h.width += 2 * c, this._brushController.mount({
        enableGlobalPan: true,
        rotation: r.rotation,
        x: r.position[0],
        y: r.position[1]
      }).setPanels([
        {
          panelId: "pl",
          clipPath: BW(h),
          isTargetByCursor: FW(h, s, a),
          getLinearBrushOtherExtent: zW(h, 0)
        }
      ]).enableBrush({
        brushType: "lineX",
        brushStyle: n,
        removeOnClick: true
      }).updateCovers(vce(i));
    }, e.prototype._onBrush = function(r) {
      var n = r.areas, i = this.axisModel, a = i.axis, o = oe(n, function(s) {
        return [
          a.coordToData(s.range[0], true),
          a.coordToData(s.range[1], true)
        ];
      });
      (!i.option.realtime === r.isEnd || r.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: o
      });
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.type = "parallelAxis", e;
  }(tr);
  function pce(t, e, r) {
    return r && r.type === "axisAreaSelect" && e.findComponents({
      mainType: "parallelAxis",
      query: r
    })[0] === t;
  }
  function vce(t) {
    var e = t.axis;
    return oe(t.activeIntervals, function(r) {
      return {
        brushType: "lineX",
        panelId: "pl",
        range: [
          e.dataToCoord(r[0], true),
          e.dataToCoord(r[1], true)
        ]
      };
    });
  }
  function gce(t, e) {
    return e.getComponent("parallel", t.get("parallelIndex"));
  }
  var mce = {
    type: "axisAreaSelect",
    event: "axisAreaSelected"
  };
  function yce(t) {
    t.registerAction(mce, function(e, r) {
      r.eachComponent({
        mainType: "parallelAxis",
        query: e
      }, function(n) {
        n.axis.model.setActiveIntervals(e.intervals);
      });
    }), t.registerAction("parallelAxisExpand", function(e, r) {
      r.eachComponent({
        mainType: "parallel",
        query: e
      }, function(n) {
        n.setAxisExpand(e);
      });
    });
  }
  var _ce = {
    type: "value",
    areaSelectStyle: {
      width: 20,
      borderWidth: 1,
      borderColor: "rgba(160,197,232)",
      color: "rgba(160,197,232)",
      opacity: 0.3
    },
    realtime: true,
    z: 10
  };
  function VW(t) {
    t.registerComponentView(Fue), t.registerComponentModel(Gue), t.registerCoordinateSystem("parallel", Kue), t.registerPreprocessor(Oue), t.registerComponentModel(yw), t.registerComponentView(dce), Sc(t, "parallel", yw, _ce), yce(t);
  }
  function bce(t) {
    rt(VW), t.registerChartView(Mue), t.registerSeriesModel(kue), t.registerVisual(t.PRIORITY.VISUAL.BRUSH, Rue);
  }
  var xce = /* @__PURE__ */ function() {
    function t() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return t;
  }(), wce = function(t) {
    K(e, t);
    function e(r) {
      return t.call(this, r) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new xce();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.extent;
      r.moveTo(n.x1, n.y1), r.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (r.lineTo(n.x2 + i, n.y2), r.bezierCurveTo(n.cpx2 + i, n.cpy2, n.cpx1 + i, n.cpy1, n.x1 + i, n.y1)) : (r.lineTo(n.x2, n.y2 + i), r.bezierCurveTo(n.cpx2, n.cpy2 + i, n.cpx1, n.cpy1 + i, n.x1, n.y1 + i)), r.closePath();
    }, e.prototype.highlight = function() {
      fo(this);
    }, e.prototype.downplay = function() {
      po(this);
    }, e;
  }(st), Sce = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._focusAdjacencyDisabled = false, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = this, o = r.getGraph(), s = this.group, l = r.layoutInfo, u = l.width, c = l.height, h = r.getData(), f = r.getData("edge"), d = r.get("orient");
      this._model = r, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function(p) {
        var v = new wce(), g = Ge(v);
        g.dataIndex = p.dataIndex, g.seriesIndex = r.seriesIndex, g.dataType = "edge";
        var m = p.getModel(), y = m.getModel("lineStyle"), _ = y.get("curveness"), b = p.node1.getLayout(), w = p.node1.getModel(), x = w.get("localX"), T = w.get("localY"), A = p.node2.getLayout(), I = p.node2.getModel(), M = I.get("localX"), k = I.get("localY"), B = p.getLayout(), L, z, F, E, O, N, V, H;
        v.shape.extent = Math.max(1, B.dy), v.shape.orient = d, d === "vertical" ? (L = (x != null ? x * u : b.x) + B.sy, z = (T != null ? T * c : b.y) + b.dy, F = (M != null ? M * u : A.x) + B.ty, E = k != null ? k * c : A.y, O = L, N = z * (1 - _) + E * _, V = F, H = z * _ + E * (1 - _)) : (L = (x != null ? x * u : b.x) + b.dx, z = (T != null ? T * c : b.y) + B.sy, F = M != null ? M * u : A.x, E = (k != null ? k * c : A.y) + B.ty, O = L * (1 - _) + F * _, N = z, V = L * _ + F * (1 - _), H = E), v.setShape({
          x1: L,
          y1: z,
          x2: F,
          y2: E,
          cpx1: O,
          cpy1: N,
          cpx2: V,
          cpy2: H
        }), v.useStyle(y.getItemStyle()), nL(v.style, d, p);
        var G = "" + m.get("value"), Y = Lr(m, "edgeLabel");
        Xr(v, Y, {
          labelFetcher: {
            getFormattedLabel: function(ee, we, Te, le, ue, ye) {
              return r.getFormattedLabel(ee, we, "edge", le, Aa(ue, Y.normal && Y.normal.get("formatter"), G), ye);
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: G
        }), v.setTextConfig({
          position: "inside"
        });
        var U = m.getModel("emphasis");
        qr(v, m, "lineStyle", function(ee) {
          var we = ee.getItemStyle();
          return nL(we, d, p), we;
        }), s.add(v), f.setItemGraphicEl(p.dataIndex, v);
        var Z = U.get("focus");
        ir(v, Z === "adjacency" ? p.getAdjacentDataIndices() : Z === "trajectory" ? p.getTrajectoryDataIndices() : Z, U.get("blurScope"), U.get("disabled"));
      }), o.eachNode(function(p) {
        var v = p.getLayout(), g = p.getModel(), m = g.get("localX"), y = g.get("localY"), _ = g.getModel("emphasis"), b = g.get([
          "itemStyle",
          "borderRadius"
        ]) || 0, w = new yt({
          shape: {
            x: m != null ? m * u : v.x,
            y: y != null ? y * c : v.y,
            width: v.dx,
            height: v.dy,
            r: b
          },
          style: g.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Xr(w, Lr(g), {
          labelFetcher: {
            getFormattedLabel: function(T, A) {
              return r.getFormattedLabel(T, A, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), w.disableLabelAnimation = true, w.setStyle("fill", p.getVisual("color")), w.setStyle("decal", p.getVisual("style").decal), qr(w, g), s.add(w), h.setItemGraphicEl(p.dataIndex, w), Ge(w).dataType = "node";
        var x = _.get("focus");
        ir(w, x === "adjacency" ? p.getAdjacentDataIndices() : x === "trajectory" ? p.getTrajectoryDataIndices() : x, _.get("blurScope"), _.get("disabled"));
      }), h.eachItemGraphicEl(function(p, v) {
        var g = h.getItemModel(v);
        g.get("draggable") && (p.drift = function(m, y) {
          a._focusAdjacencyDisabled = true, this.shape.x += m, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: r.id,
            dataIndex: h.getRawIndex(v),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          a._focusAdjacencyDisabled = false;
        }, p.draggable = true, p.cursor = "move");
      }), !this._data && r.isAnimationEnabled() && s.setClipPath(Tce(s.getBoundingRect(), r, function() {
        s.removeClipPath();
      })), this._data = r.getData();
    }, e.prototype.dispose = function() {
    }, e.type = "sankey", e;
  }(Ft);
  function nL(t, e, r) {
    switch (t.fill) {
      case "source":
        t.fill = r.node1.getVisual("color"), t.decal = r.node1.getVisual("style").decal;
        break;
      case "target":
        t.fill = r.node2.getVisual("color"), t.decal = r.node2.getVisual("style").decal;
        break;
      case "gradient":
        var n = r.node1.getVisual("color"), i = r.node2.getVisual("color");
        me(n) && me(i) && (t.fill = new $d(0, 0, +(e === "horizontal"), +(e === "vertical"), [
          {
            color: n,
            offset: 0
          },
          {
            color: i,
            offset: 1
          }
        ]));
    }
  }
  function Tce(t, e, r) {
    var n = new yt({
      shape: {
        x: t.x - 10,
        y: t.y - 10,
        width: 0,
        height: t.height + 20
      }
    });
    return er(n, {
      shape: {
        width: t.width + 20
      }
    }, e, r), n;
  }
  var Cce = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.getInitialData = function(r, n) {
      var i = r.edges || r.links || [], a = r.data || r.nodes || [], o = r.levels || [];
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++) o[l].depth != null && o[l].depth >= 0 && (s[o[l].depth] = new kt(o[l], this, n));
      var u = SW(a, i, this, true, c);
      return u.data;
      function c(h, f) {
        h.wrapMethod("getItemModel", function(d, p) {
          var v = d.parentModel, g = v.getData().getItemLayout(p);
          if (g) {
            var m = g.depth, y = v.levelModels[m];
            y && (d.parentModel = y);
          }
          return d;
        }), f.wrapMethod("getItemModel", function(d, p) {
          var v = d.parentModel, g = v.getGraph().getEdgeByIndex(p), m = g.node1.getLayout();
          if (m) {
            var y = m.depth, _ = v.levelModels[y];
            _ && (d.parentModel = _);
          }
          return d;
        });
      }
    }, e.prototype.setNodePosition = function(r, n) {
      var i = this.option.data || this.option.nodes, a = i[r];
      a.localX = n[0], a.localY = n[1];
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.formatTooltip = function(r, n, i) {
      function a(d) {
        return isNaN(d) || d == null;
      }
      if (i === "edge") {
        var o = this.getDataParams(r, i), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return $r("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(r), h = c.getLayout().value, f = this.getDataParams(r, i).data.name;
        return $r("nameValue", {
          name: f != null ? f + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, e.prototype.optionUpdated = function() {
    }, e.prototype.getDataParams = function(r, n) {
      var i = t.prototype.getDataParams.call(this, r, n);
      if (i.value == null && n === "node") {
        var a = this.getGraph().getNodeByIndex(r), o = a.getLayout().value;
        i.value = o;
      }
      return i;
    }, e.type = "series.sankey", e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: true,
      layoutIterations: 32,
      label: {
        show: true,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: false,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, e;
  }(Xt);
  function Ace(t, e) {
    t.eachSeriesByType("sankey", function(r) {
      var n = r.get("nodeWidth"), i = r.get("nodeGap"), a = Ice(r, e);
      r.layoutInfo = a;
      var o = a.width, s = a.height, l = r.getGraph(), u = l.nodes, c = l.edges;
      Dce(u);
      var h = Dt(u, function(v) {
        return v.getLayout().value === 0;
      }), f = h.length !== 0 ? 0 : r.get("layoutIterations"), d = r.get("orient"), p = r.get("nodeAlign");
      Mce(u, c, n, i, o, s, f, d, p);
    });
  }
  function Ice(t, e) {
    return Tr(t.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function Mce(t, e, r, n, i, a, o, s, l) {
    Ece(t, e, r, i, a, s, l), $ce(t, e, a, i, n, o, s), Wce(t, s);
  }
  function Dce(t) {
    $(t, function(e) {
      var r = ls(e.outEdges, rm), n = ls(e.inEdges, rm), i = e.getValue() || 0, a = Math.max(r, n, i);
      e.setLayout({
        value: a
      }, true);
    });
  }
  function Ece(t, e, r, n, i, a, o) {
    for (var s = [], l = [], u = [], c = [], h = 0, f = 0; f < e.length; f++) s[f] = 1;
    for (var f = 0; f < t.length; f++) l[f] = t[f].inEdges.length, l[f] === 0 && u.push(t[f]);
    for (var d = -1; u.length; ) {
      for (var p = 0; p < u.length; p++) {
        var v = u[p], g = v.hostGraph.data.getRawDataItem(v.dataIndex), m = g.depth != null && g.depth >= 0;
        m && g.depth > d && (d = g.depth), v.setLayout({
          depth: m ? g.depth : h
        }, true), a === "vertical" ? v.setLayout({
          dy: r
        }, true) : v.setLayout({
          dx: r
        }, true);
        for (var y = 0; y < v.outEdges.length; y++) {
          var _ = v.outEdges[y], b = e.indexOf(_);
          s[b] = 0;
          var w = _.node2, x = t.indexOf(w);
          --l[x] === 0 && c.indexOf(w) < 0 && c.push(w);
        }
      }
      ++h, u = c, c = [];
    }
    for (var f = 0; f < s.length; f++) if (s[f] === 1) throw new Error("Sankey is a DAG, the original data has cycle!");
    var T = d > h - 1 ? d : h - 1;
    o && o !== "left" && kce(t, o, a, T);
    var A = a === "vertical" ? (i - r) / T : (n - r) / T;
    Lce(t, A, a);
  }
  function GW(t) {
    var e = t.hostGraph.data.getRawDataItem(t.dataIndex);
    return e.depth != null && e.depth >= 0;
  }
  function kce(t, e, r, n) {
    if (e === "right") {
      for (var i = [], a = t, o = 0; a.length; ) {
        for (var s = 0; s < a.length; s++) {
          var l = a[s];
          l.setLayout({
            skNodeHeight: o
          }, true);
          for (var u = 0; u < l.inEdges.length; u++) {
            var c = l.inEdges[u];
            i.indexOf(c.node1) < 0 && i.push(c.node1);
          }
        }
        a = i, i = [], ++o;
      }
      $(t, function(h) {
        GW(h) || h.setLayout({
          depth: Math.max(0, n - h.getLayout().skNodeHeight)
        }, true);
      });
    } else e === "justify" && Pce(t, n);
  }
  function Pce(t, e) {
    $(t, function(r) {
      !GW(r) && !r.outEdges.length && r.setLayout({
        depth: e
      }, true);
    });
  }
  function Lce(t, e, r) {
    $(t, function(n) {
      var i = n.getLayout().depth * e;
      r === "vertical" ? n.setLayout({
        y: i
      }, true) : n.setLayout({
        x: i
      }, true);
    });
  }
  function $ce(t, e, r, n, i, a, o) {
    var s = Rce(t, o);
    Oce(s, e, r, n, i, o), z_(s, i, r, n, o);
    for (var l = 1; a > 0; a--) l *= 0.99, Nce(s, l, o), z_(s, i, r, n, o), Gce(s, l, o), z_(s, i, r, n, o);
  }
  function Rce(t, e) {
    var r = [], n = e === "vertical" ? "y" : "x", i = Tx(t, function(a) {
      return a.getLayout()[n];
    });
    return i.keys.sort(function(a, o) {
      return a - o;
    }), $(i.keys, function(a) {
      r.push(i.buckets.get(a));
    }), r;
  }
  function Oce(t, e, r, n, i, a) {
    var o = 1 / 0;
    $(t, function(s) {
      var l = s.length, u = 0;
      $(s, function(h) {
        u += h.getLayout().value;
      });
      var c = a === "vertical" ? (n - (l - 1) * i) / u : (r - (l - 1) * i) / u;
      c < o && (o = c);
    }), $(t, function(s) {
      $(s, function(l, u) {
        var c = l.getLayout().value * o;
        a === "vertical" ? (l.setLayout({
          x: u
        }, true), l.setLayout({
          dx: c
        }, true)) : (l.setLayout({
          y: u
        }, true), l.setLayout({
          dy: c
        }, true));
      });
    }), $(e, function(s) {
      var l = +s.getValue() * o;
      s.setLayout({
        dy: l
      }, true);
    });
  }
  function z_(t, e, r, n, i) {
    var a = i === "vertical" ? "x" : "y";
    $(t, function(o) {
      o.sort(function(v, g) {
        return v.getLayout()[a] - g.getLayout()[a];
      });
      for (var s, l, u, c = 0, h = o.length, f = i === "vertical" ? "dx" : "dy", d = 0; d < h; d++) l = o[d], u = c - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, i === "vertical" ? l.setLayout({
        x: s
      }, true) : l.setLayout({
        y: s
      }, true)), c = l.getLayout()[a] + l.getLayout()[f] + e;
      var p = i === "vertical" ? n : r;
      if (u = c - e - p, u > 0) {
        s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: s
        }, true) : l.setLayout({
          y: s
        }, true), c = s;
        for (var d = h - 2; d >= 0; --d) l = o[d], u = l.getLayout()[a] + l.getLayout()[f] + e - c, u > 0 && (s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: s
        }, true) : l.setLayout({
          y: s
        }, true)), c = l.getLayout()[a];
      }
    });
  }
  function Nce(t, e, r) {
    $(t.slice().reverse(), function(n) {
      $(n, function(i) {
        if (i.outEdges.length) {
          var a = ls(i.outEdges, Bce, r) / ls(i.outEdges, rm);
          if (isNaN(a)) {
            var o = i.outEdges.length;
            a = o ? ls(i.outEdges, zce, r) / o : 0;
          }
          if (r === "vertical") {
            var s = i.getLayout().x + (a - gs(i, r)) * e;
            i.setLayout({
              x: s
            }, true);
          } else {
            var l = i.getLayout().y + (a - gs(i, r)) * e;
            i.setLayout({
              y: l
            }, true);
          }
        }
      });
    });
  }
  function Bce(t, e) {
    return gs(t.node2, e) * t.getValue();
  }
  function zce(t, e) {
    return gs(t.node2, e);
  }
  function Fce(t, e) {
    return gs(t.node1, e) * t.getValue();
  }
  function Vce(t, e) {
    return gs(t.node1, e);
  }
  function gs(t, e) {
    return e === "vertical" ? t.getLayout().x + t.getLayout().dx / 2 : t.getLayout().y + t.getLayout().dy / 2;
  }
  function rm(t) {
    return t.getValue();
  }
  function ls(t, e, r) {
    for (var n = 0, i = t.length, a = -1; ++a < i; ) {
      var o = +e(t[a], r);
      isNaN(o) || (n += o);
    }
    return n;
  }
  function Gce(t, e, r) {
    $(t, function(n) {
      $(n, function(i) {
        if (i.inEdges.length) {
          var a = ls(i.inEdges, Fce, r) / ls(i.inEdges, rm);
          if (isNaN(a)) {
            var o = i.inEdges.length;
            a = o ? ls(i.inEdges, Vce, r) / o : 0;
          }
          if (r === "vertical") {
            var s = i.getLayout().x + (a - gs(i, r)) * e;
            i.setLayout({
              x: s
            }, true);
          } else {
            var l = i.getLayout().y + (a - gs(i, r)) * e;
            i.setLayout({
              y: l
            }, true);
          }
        }
      });
    });
  }
  function Wce(t, e) {
    var r = e === "vertical" ? "x" : "y";
    $(t, function(n) {
      n.outEdges.sort(function(i, a) {
        return i.node2.getLayout()[r] - a.node2.getLayout()[r];
      }), n.inEdges.sort(function(i, a) {
        return i.node1.getLayout()[r] - a.node1.getLayout()[r];
      });
    }), $(t, function(n) {
      var i = 0, a = 0;
      $(n.outEdges, function(o) {
        o.setLayout({
          sy: i
        }, true), i += o.getLayout().dy;
      }), $(n.inEdges, function(o) {
        o.setLayout({
          ty: a
        }, true), a += o.getLayout().dy;
      });
    });
  }
  function Hce(t) {
    t.eachSeriesByType("sankey", function(e) {
      var r = e.getGraph(), n = r.nodes, i = r.edges;
      if (n.length) {
        var a = 1 / 0, o = -1 / 0;
        $(n, function(s) {
          var l = s.getLayout().value;
          l < a && (a = l), l > o && (o = l);
        }), $(n, function(s) {
          var l = new Er({
            type: "color",
            mappingMethod: "linear",
            dataExtent: [
              a,
              o
            ],
            visual: e.get("color")
          }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get([
            "itemStyle",
            "color"
          ]);
          c != null ? (s.setVisual("color", c), s.setVisual("style", {
            fill: c
          })) : (s.setVisual("color", u), s.setVisual("style", {
            fill: u
          }));
        });
      }
      i.length && $(i, function(s) {
        var l = s.getModel().get("lineStyle");
        s.setVisual("style", l);
      });
    });
  }
  function Uce(t) {
    t.registerChartView(Sce), t.registerSeriesModel(Cce), t.registerLayout(Ace), t.registerVisual(Hce), t.registerAction({
      type: "dragNode",
      event: "dragnode",
      update: "update"
    }, function(e, r) {
      r.eachComponent({
        mainType: "series",
        subType: "sankey",
        query: e
      }, function(n) {
        n.setNodePosition(e.dataIndex, [
          e.localX,
          e.localY
        ]);
      });
    });
  }
  var WW = function() {
    function t() {
    }
    return t.prototype._hasEncodeRule = function(e) {
      var r = this.getEncode();
      return r && r.get(e) != null;
    }, t.prototype.getInitialData = function(e, r) {
      var n, i = r.getComponent("xAxis", this.get("xAxisIndex")), a = r.getComponent("yAxis", this.get("yAxisIndex")), o = i.get("type"), s = a.get("type"), l;
      o === "category" ? (e.layout = "horizontal", n = i.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : s === "category" ? (e.layout = "vertical", n = a.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : e.layout = e.layout || "horizontal";
      var u = [
        "x",
        "y"
      ], c = e.layout === "horizontal" ? 0 : 1, h = this._baseAxisDim = u[c], f = u[1 - c], d = [
        i,
        a
      ], p = d[c].get("type"), v = d[1 - c].get("type"), g = e.data;
      if (g && l) {
        var m = [];
        $(g, function(b, w) {
          var x;
          ae(b) ? (x = b.slice(), b.unshift(w)) : ae(b.value) ? (x = te({}, b), x.value = x.value.slice(), b.value.unshift(w)) : x = b, m.push(x);
        }), e.data = m;
      }
      var y = this.defaultValueDimensions, _ = [
        {
          name: h,
          type: Ug(p),
          ordinalMeta: n,
          otherDims: {
            tooltip: false,
            itemName: 0
          },
          dimsDef: [
            "base"
          ]
        },
        {
          name: f,
          type: Ug(v),
          dimsDef: y.slice()
        }
      ];
      return Qc(this, {
        coordDimensions: _,
        dimensionsCount: y.length + 1,
        encodeDefaulter: Ye(bV, _, this)
      });
    }, t.prototype.getBaseAxis = function() {
      var e = this._baseAxisDim;
      return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis;
    }, t;
  }(), HW = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.defaultValueDimensions = [
        {
          name: "min",
          defaultTooltip: true
        },
        {
          name: "Q1",
          defaultTooltip: true
        },
        {
          name: "median",
          defaultTooltip: true
        },
        {
          name: "Q3",
          defaultTooltip: true
        },
        {
          name: "max",
          defaultTooltip: true
        }
      ], r.visualDrawType = "stroke", r;
    }
    return e.type = "series.boxplot", e.dependencies = [
      "xAxis",
      "yAxis",
      "grid"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      boxWidth: [
        7,
        50
      ],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: true,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, e;
  }(Xt);
  yr(HW, WW, true);
  var Yce = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = r.getData(), o = this.group, s = this._data;
      this._data || o.removeAll();
      var l = r.get("layout") === "horizontal" ? 1 : 0;
      a.diff(s).add(function(u) {
        if (a.hasValue(u)) {
          var c = a.getItemLayout(u), h = iL(c, a, u, l, true);
          a.setItemGraphicEl(u, h), o.add(h);
        }
      }).update(function(u, c) {
        var h = s.getItemGraphicEl(c);
        if (!a.hasValue(u)) {
          o.remove(h);
          return;
        }
        var f = a.getItemLayout(u);
        h ? (Ki(h), UW(f, h, a, u)) : h = iL(f, a, u, l), o.add(h), a.setItemGraphicEl(u, h);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && o.remove(c);
      }).execute(), this._data = a;
    }, e.prototype.remove = function(r) {
      var n = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(a) {
        a && n.remove(a);
      });
    }, e.type = "boxplot", e;
  }(Ft), qce = /* @__PURE__ */ function() {
    function t() {
    }
    return t;
  }(), Xce = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "boxplotBoxPath", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new qce();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.points, a = 0;
      for (r.moveTo(i[a][0], i[a][1]), a++; a < 4; a++) r.lineTo(i[a][0], i[a][1]);
      for (r.closePath(); a < i.length; a++) r.moveTo(i[a][0], i[a][1]), a++, r.lineTo(i[a][0], i[a][1]);
    }, e;
  }(st);
  function iL(t, e, r, n, i) {
    var a = t.ends, o = new Xce({
      shape: {
        points: i ? jce(a, n, t) : a
      }
    });
    return UW(t, o, e, r, i), o;
  }
  function UW(t, e, r, n, i) {
    var a = r.hostModel, o = au[i ? "initProps" : "updateProps"];
    o(e, {
      shape: {
        points: t.ends
      }
    }, a, n), e.useStyle(r.getItemVisual(n, "style")), e.style.strokeNoScale = true, e.z2 = 100;
    var s = r.getItemModel(n), l = s.getModel("emphasis");
    qr(e, s), ir(e, l.get("focus"), l.get("blurScope"), l.get("disabled"));
  }
  function jce(t, e, r) {
    return oe(t, function(n) {
      return n = n.slice(), n[e] = r.initBaseline, n;
    });
  }
  var kf = $;
  function Kce(t) {
    var e = Zce(t);
    kf(e, function(r) {
      var n = r.seriesModels;
      n.length && (Qce(r), kf(n, function(i, a) {
        Jce(i, r.boxOffsetList[a], r.boxWidthList[a]);
      }));
    });
  }
  function Zce(t) {
    var e = [], r = [];
    return t.eachSeriesByType("boxplot", function(n) {
      var i = n.getBaseAxis(), a = et(r, i);
      a < 0 && (a = r.length, r[a] = i, e[a] = {
        axis: i,
        seriesModels: []
      }), e[a].seriesModels.push(n);
    }), e;
  }
  function Qce(t) {
    var e = t.axis, r = t.seriesModels, n = r.length, i = t.boxWidthList = [], a = t.boxOffsetList = [], o = [], s;
    if (e.type === "category") s = e.getBandWidth();
    else {
      var l = 0;
      kf(r, function(p) {
        l = Math.max(l, p.getData().count());
      });
      var u = e.getExtent();
      s = Math.abs(u[1] - u[0]) / l;
    }
    kf(r, function(p) {
      var v = p.get("boxWidth");
      ae(v) || (v = [
        v,
        v
      ]), o.push([
        pe(v[0], s) || 0,
        pe(v[1], s) || 0
      ]);
    });
    var c = s * 0.8 - 2, h = c / n * 0.3, f = (c - h * (n - 1)) / n, d = f / 2 - c / 2;
    kf(r, function(p, v) {
      a.push(d), d += h + f, i.push(Math.min(Math.max(f, o[v][0]), o[v][1]));
    });
  }
  function Jce(t, e, r) {
    var n = t.coordinateSystem, i = t.getData(), a = r / 2, o = t.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = [
      "x",
      "y"
    ], u = i.mapDimension(l[o]), c = i.mapDimensionsAll(l[s]);
    if (u == null || c.length < 5) return;
    for (var h = 0; h < i.count(); h++) {
      var f = i.get(u, h), d = _(f, c[2], h), p = _(f, c[0], h), v = _(f, c[1], h), g = _(f, c[3], h), m = _(f, c[4], h), y = [];
      b(y, v, false), b(y, g, true), y.push(p, v, m, g), w(y, p), w(y, m), w(y, d), i.setItemLayout(h, {
        initBaseline: d[s],
        ends: y
      });
    }
    function _(x, T, A) {
      var I = i.get(T, A), M = [];
      M[o] = x, M[s] = I;
      var k;
      return isNaN(x) || isNaN(I) ? k = [
        NaN,
        NaN
      ] : (k = n.dataToPoint(M), k[o] += e), k;
    }
    function b(x, T, A) {
      var I = T.slice(), M = T.slice();
      I[o] += a, M[o] -= a, A ? x.push(I, M) : x.push(M, I);
    }
    function w(x, T) {
      var A = T.slice(), I = T.slice();
      A[o] -= a, I[o] += a, x.push(A, I);
    }
  }
  function ehe(t, e) {
    e = e || {};
    for (var r = [], n = [], i = e.boundIQR, a = i === "none" || i === 0, o = 0; o < t.length; o++) {
      var s = mi(t[o].slice()), l = p0(s, 0.25), u = p0(s, 0.5), c = p0(s, 0.75), h = s[0], f = s[s.length - 1], d = (i ?? 1.5) * (c - l), p = a ? h : Math.max(h, l - d), v = a ? f : Math.min(f, c + d), g = e.itemNameFormatter, m = De(g) ? g({
        value: o
      }) : me(g) ? g.replace("{value}", o + "") : o + "";
      r.push([
        m,
        p,
        l,
        u,
        c,
        v
      ]);
      for (var y = 0; y < s.length; y++) {
        var _ = s[y];
        if (_ < p || _ > v) {
          var b = [
            m,
            _
          ];
          n.push(b);
        }
      }
    }
    return {
      boxData: r,
      outliers: n
    };
  }
  var the = {
    type: "echarts:boxplot",
    transform: function(e) {
      var r = e.upstream;
      if (r.sourceFormat !== sn) {
        var n = "";
        It(n);
      }
      var i = ehe(r.getRawData(), e.config);
      return [
        {
          dimensions: [
            "ItemName",
            "Low",
            "Q1",
            "Q2",
            "Q3",
            "High"
          ],
          data: i.boxData
        },
        {
          data: i.outliers
        }
      ];
    }
  };
  function rhe(t) {
    t.registerSeriesModel(HW), t.registerChartView(Yce), t.registerLayout(Kce), t.registerTransform(the);
  }
  var nhe = [
    "itemStyle",
    "borderColor"
  ], ihe = [
    "itemStyle",
    "borderColor0"
  ], ahe = [
    "itemStyle",
    "borderColorDoji"
  ], ohe = [
    "itemStyle",
    "color"
  ], she = [
    "itemStyle",
    "color0"
  ];
  function w2(t, e) {
    return e.get(t > 0 ? ohe : she);
  }
  function S2(t, e) {
    return e.get(t === 0 ? ahe : t > 0 ? nhe : ihe);
  }
  var lhe = {
    seriesType: "candlestick",
    plan: Xc(),
    performRawSeries: true,
    reset: function(t, e) {
      if (!e.isSeriesFiltered(t)) {
        var r = t.pipelineContext.large;
        return !r && {
          progress: function(n, i) {
            for (var a; (a = n.next()) != null; ) {
              var o = i.getItemModel(a), s = i.getItemLayout(a).sign, l = o.getItemStyle();
              l.fill = w2(s, o), l.stroke = S2(s, o) || l.fill;
              var u = i.ensureUniqueItemVisual(a, "style");
              te(u, l);
            }
          }
        };
      }
    }
  }, uhe = [
    "color",
    "borderColor"
  ], che = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(r), this._isLargeDraw ? this._renderLarge(r) : this._renderNormal(r);
    }, e.prototype.incrementalPrepareRender = function(r, n, i) {
      this._clear(), this._updateDrawMode(r);
    }, e.prototype.incrementalRender = function(r, n, i, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(r, n) : this._incrementalRenderNormal(r, n);
    }, e.prototype.eachRendered = function(r) {
      bs(this._progressiveEls || this.group, r);
    }, e.prototype._updateDrawMode = function(r) {
      var n = r.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, e.prototype._renderNormal = function(r) {
      var n = r.getData(), i = this._data, a = this.group, o = n.getLayout("isSimpleBox"), s = r.get("clip", true), l = r.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), n.diff(i).add(function(c) {
        if (n.hasValue(c)) {
          var h = n.getItemLayout(c);
          if (s && aL(u, h)) return;
          var f = F_(h, c, true);
          er(f, {
            shape: {
              points: h.ends
            }
          }, r, c), V_(f, n, c, o), a.add(f), n.setItemGraphicEl(c, f);
        }
      }).update(function(c, h) {
        var f = i.getItemGraphicEl(h);
        if (!n.hasValue(c)) {
          a.remove(f);
          return;
        }
        var d = n.getItemLayout(c);
        if (s && aL(u, d)) {
          a.remove(f);
          return;
        }
        f ? (wt(f, {
          shape: {
            points: d.ends
          }
        }, r, c), Ki(f)) : f = F_(d), V_(f, n, c, o), a.add(f), n.setItemGraphicEl(c, f);
      }).remove(function(c) {
        var h = i.getItemGraphicEl(c);
        h && a.remove(h);
      }).execute(), this._data = n;
    }, e.prototype._renderLarge = function(r) {
      this._clear(), oL(r, this.group);
      var n = r.get("clip", true) ? Wd(r.coordinateSystem, false, r) : null;
      n ? this.group.setClipPath(n) : this.group.removeClipPath();
    }, e.prototype._incrementalRenderNormal = function(r, n) {
      for (var i = n.getData(), a = i.getLayout("isSimpleBox"), o; (o = r.next()) != null; ) {
        var s = i.getItemLayout(o), l = F_(s);
        V_(l, i, o, a), l.incremental = true, this.group.add(l), this._progressiveEls.push(l);
      }
    }, e.prototype._incrementalRenderLarge = function(r, n) {
      oL(n, this.group, this._progressiveEls, true);
    }, e.prototype.remove = function(r) {
      this._clear();
    }, e.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "candlestick", e;
  }(Ft), hhe = /* @__PURE__ */ function() {
    function t() {
    }
    return t;
  }(), fhe = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "normalCandlestickBox", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new hhe();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.points;
      this.__simpleBox ? (r.moveTo(i[4][0], i[4][1]), r.lineTo(i[6][0], i[6][1])) : (r.moveTo(i[0][0], i[0][1]), r.lineTo(i[1][0], i[1][1]), r.lineTo(i[2][0], i[2][1]), r.lineTo(i[3][0], i[3][1]), r.closePath(), r.moveTo(i[4][0], i[4][1]), r.lineTo(i[5][0], i[5][1]), r.moveTo(i[6][0], i[6][1]), r.lineTo(i[7][0], i[7][1]));
    }, e;
  }(st);
  function F_(t, e, r) {
    var n = t.ends;
    return new fhe({
      shape: {
        points: r ? dhe(n, t) : n
      },
      z2: 100
    });
  }
  function aL(t, e) {
    for (var r = true, n = 0; n < e.ends.length; n++) if (t.contain(e.ends[n][0], e.ends[n][1])) {
      r = false;
      break;
    }
    return r;
  }
  function V_(t, e, r, n) {
    var i = e.getItemModel(r);
    t.useStyle(e.getItemVisual(r, "style")), t.style.strokeNoScale = true, t.__simpleBox = n, qr(t, i);
    var a = e.getItemLayout(r).sign;
    $(t.states, function(s, l) {
      var u = i.getModel(l), c = w2(a, u), h = S2(a, u) || c, f = s.style || (s.style = {});
      c && (f.fill = c), h && (f.stroke = h);
    });
    var o = i.getModel("emphasis");
    ir(t, o.get("focus"), o.get("blurScope"), o.get("disabled"));
  }
  function dhe(t, e) {
    return oe(t, function(r) {
      return r = r.slice(), r[1] = e.initBaseline, r;
    });
  }
  var phe = /* @__PURE__ */ function() {
    function t() {
    }
    return t;
  }(), G_ = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n.type = "largeCandlestickBox", n;
    }
    return e.prototype.getDefaultShape = function() {
      return new phe();
    }, e.prototype.buildPath = function(r, n) {
      for (var i = n.points, a = 0; a < i.length; ) if (this.__sign === i[a++]) {
        var o = i[a++];
        r.moveTo(o, i[a++]), r.lineTo(o, i[a++]);
      } else a += 3;
    }, e;
  }(st);
  function oL(t, e, r, n) {
    var i = t.getData(), a = i.getLayout("largePoints"), o = new G_({
      shape: {
        points: a
      },
      __sign: 1,
      ignoreCoarsePointer: true
    });
    e.add(o);
    var s = new G_({
      shape: {
        points: a
      },
      __sign: -1,
      ignoreCoarsePointer: true
    });
    e.add(s);
    var l = new G_({
      shape: {
        points: a
      },
      __sign: 0,
      ignoreCoarsePointer: true
    });
    e.add(l), W_(1, o, t), W_(-1, s, t), W_(0, l, t), n && (o.incremental = true, s.incremental = true), r && r.push(o, s);
  }
  function W_(t, e, r, n) {
    var i = S2(t, r) || w2(t, r), a = r.getModel("itemStyle").getItemStyle(uhe);
    e.useStyle(a), e.style.fill = null, e.style.stroke = i;
  }
  var YW = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.defaultValueDimensions = [
        {
          name: "open",
          defaultTooltip: true
        },
        {
          name: "close",
          defaultTooltip: true
        },
        {
          name: "lowest",
          defaultTooltip: true
        },
        {
          name: "highest",
          defaultTooltip: true
        }
      ], r;
    }
    return e.prototype.getShadowDim = function() {
      return "open";
    }, e.prototype.brushSelector = function(r, n, i) {
      var a = n.getItemLayout(r);
      return a && i.rect(a.brushRect);
    }, e.type = "series.candlestick", e.dependencies = [
      "xAxis",
      "yAxis",
      "grid"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      clip: true,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: true,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, e;
  }(Xt);
  yr(YW, WW, true);
  function vhe(t) {
    !t || !ae(t.series) || $(t.series, function(e) {
      Le(e) && e.type === "k" && (e.type = "candlestick");
    });
  }
  var ghe = {
    seriesType: "candlestick",
    plan: Xc(),
    reset: function(t) {
      var e = t.coordinateSystem, r = t.getData(), n = mhe(t, r), i = 0, a = 1, o = [
        "x",
        "y"
      ], s = r.getDimensionIndex(r.mapDimension(o[i])), l = oe(r.mapDimensionsAll(o[a]), r.getDimensionIndex, r), u = l[0], c = l[1], h = l[2], f = l[3];
      if (r.setLayout({
        candleWidth: n,
        isSimpleBox: n <= 1.3
      }), s < 0 || l.length < 4) return;
      return {
        progress: t.pipelineContext.large ? p : d
      };
      function d(v, g) {
        for (var m, y = g.getStore(); (m = v.next()) != null; ) {
          var _ = y.get(s, m), b = y.get(u, m), w = y.get(c, m), x = y.get(h, m), T = y.get(f, m), A = Math.min(b, w), I = Math.max(b, w), M = O(A, _), k = O(I, _), B = O(x, _), L = O(T, _), z = [];
          N(z, k, 0), N(z, M, 1), z.push(H(L), H(k), H(B), H(M));
          var F = g.getItemModel(m), E = !!F.get([
            "itemStyle",
            "borderColorDoji"
          ]);
          g.setItemLayout(m, {
            sign: sL(y, m, b, w, c, E),
            initBaseline: b > w ? k[a] : M[a],
            ends: z,
            brushRect: V(x, T, _)
          });
        }
        function O(G, Y) {
          var U = [];
          return U[i] = Y, U[a] = G, isNaN(Y) || isNaN(G) ? [
            NaN,
            NaN
          ] : e.dataToPoint(U);
        }
        function N(G, Y, U) {
          var Z = Y.slice(), ee = Y.slice();
          Z[i] = ag(Z[i] + n / 2, 1, false), ee[i] = ag(ee[i] - n / 2, 1, true), U ? G.push(Z, ee) : G.push(ee, Z);
        }
        function V(G, Y, U) {
          var Z = O(G, U), ee = O(Y, U);
          return Z[i] -= n / 2, ee[i] -= n / 2, {
            x: Z[0],
            y: Z[1],
            width: n,
            height: ee[1] - Z[1]
          };
        }
        function H(G) {
          return G[i] = ag(G[i], 1), G;
        }
      }
      function p(v, g) {
        for (var m = Ta(v.count * 4), y = 0, _, b = [], w = [], x, T = g.getStore(), A = !!t.get([
          "itemStyle",
          "borderColorDoji"
        ]); (x = v.next()) != null; ) {
          var I = T.get(s, x), M = T.get(u, x), k = T.get(c, x), B = T.get(h, x), L = T.get(f, x);
          if (isNaN(I) || isNaN(B) || isNaN(L)) {
            m[y++] = NaN, y += 3;
            continue;
          }
          m[y++] = sL(T, x, M, k, c, A), b[i] = I, b[a] = B, _ = e.dataToPoint(b, null, w), m[y++] = _ ? _[0] : NaN, m[y++] = _ ? _[1] : NaN, b[a] = L, _ = e.dataToPoint(b, null, w), m[y++] = _ ? _[1] : NaN;
        }
        g.setLayout("largePoints", m);
      }
    }
  };
  function sL(t, e, r, n, i, a) {
    var o;
    return r > n ? o = -1 : r < n ? o = 1 : o = a ? 0 : e > 0 ? t.get(i, e - 1) <= n ? 1 : -1 : 1, o;
  }
  function mhe(t, e) {
    var r = t.getBaseAxis(), n, i = r.type === "category" ? r.getBandWidth() : (n = r.getExtent(), Math.abs(n[1] - n[0]) / e.count()), a = pe(We(t.get("barMaxWidth"), i), i), o = pe(We(t.get("barMinWidth"), 1), i), s = t.get("barWidth");
    return s != null ? pe(s, i) : Math.max(Math.min(i / 2, a), o);
  }
  function yhe(t) {
    t.registerChartView(che), t.registerSeriesModel(YW), t.registerPreprocessor(vhe), t.registerVisual(lhe), t.registerLayout(ghe);
  }
  function lL(t, e) {
    var r = e.rippleEffectColor || e.color;
    t.eachChild(function(n) {
      n.attr({
        z: e.z,
        zlevel: e.zlevel,
        style: {
          stroke: e.brushType === "stroke" ? r : null,
          fill: e.brushType === "fill" ? r : null
        }
      });
    });
  }
  var _he = function(t) {
    K(e, t);
    function e(r, n) {
      var i = t.call(this) || this, a = new Vd(r, n), o = new Be();
      return i.add(a), i.add(o), i.updateData(r, n), i;
    }
    return e.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, e.prototype.startEffectAnimation = function(r) {
      for (var n = r.symbolType, i = r.color, a = r.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
        var l = mr(n, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: true
          },
          z2: 99,
          silent: true,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / a * r.period + r.effectOffset;
        l.animate("", true).when(r.period, {
          scaleX: r.rippleScale / 2,
          scaleY: r.rippleScale / 2
        }).delay(u).start(), l.animateStyle(true).when(r.period, {
          opacity: 0
        }).delay(u).start(), o.add(l);
      }
      lL(o, r);
    }, e.prototype.updateEffectAnimation = function(r) {
      for (var n = this._effectCfg, i = this.childAt(1), a = [
        "symbolType",
        "period",
        "rippleScale",
        "rippleNumber"
      ], o = 0; o < a.length; o++) {
        var s = a[o];
        if (n[s] !== r[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(r);
          return;
        }
      }
      lL(i, r);
    }, e.prototype.highlight = function() {
      fo(this);
    }, e.prototype.downplay = function() {
      po(this);
    }, e.prototype.getSymbolType = function() {
      var r = this.childAt(0);
      return r && r.getSymbolType();
    }, e.prototype.updateData = function(r, n) {
      var i = this, a = r.hostModel;
      this.childAt(0).updateData(r, n);
      var o = this.childAt(1), s = r.getItemModel(n), l = r.getItemVisual(n, "symbol"), u = Kc(r.getItemVisual(n, "symbolSize")), c = r.getItemVisual(n, "style"), h = c && c.fill, f = s.getModel("emphasis");
      o.setScale(u), o.traverse(function(g) {
        g.setStyle("fill", h);
      });
      var d = ou(r.getItemVisual(n, "symbolOffset"), u);
      d && (o.x = d[0], o.y = d[1]);
      var p = r.getItemVisual(n, "symbolRotate");
      o.rotation = (p || 0) * Math.PI / 180 || 0;
      var v = {};
      v.showEffectOn = a.get("showEffectOn"), v.rippleScale = s.get([
        "rippleEffect",
        "scale"
      ]), v.brushType = s.get([
        "rippleEffect",
        "brushType"
      ]), v.period = s.get([
        "rippleEffect",
        "period"
      ]) * 1e3, v.effectOffset = n / r.count(), v.z = a.getShallow("z") || 0, v.zlevel = a.getShallow("zlevel") || 0, v.symbolType = l, v.color = h, v.rippleEffectColor = s.get([
        "rippleEffect",
        "color"
      ]), v.rippleNumber = s.get([
        "rippleEffect",
        "number"
      ]), v.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(v) : this.startEffectAnimation(v), this._effectCfg = v) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(g) {
        g === "emphasis" ? v.showEffectOn !== "render" && i.startEffectAnimation(v) : g === "normal" && v.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = v, ir(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
    }, e.prototype.fadeOut = function(r) {
      r && r();
    }, e;
  }(Be), bhe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function() {
      this._symbolDraw = new Gd(_he);
    }, e.prototype.render = function(r, n, i) {
      var a = r.getData(), o = this._symbolDraw;
      o.updateData(a, {
        clipShape: this._getClipShape(r)
      }), this.group.add(o.group);
    }, e.prototype._getClipShape = function(r) {
      var n = r.coordinateSystem, i = n && n.getArea && n.getArea();
      return r.get("clip", true) ? i : null;
    }, e.prototype.updateTransform = function(r, n, i) {
      var a = r.getData();
      this.group.dirty();
      var o = Hd("").reset(r, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, e.prototype._updateGroupTransform = function(r) {
      var n = r.coordinateSystem;
      n && n.getRoamTransform && (this.group.transform = VK(n.getRoamTransform()), this.group.decomposeTransform());
    }, e.prototype.remove = function(r, n) {
      this._symbolDraw && this._symbolDraw.remove(true);
    }, e.type = "effectScatter", e;
  }(Ft), xhe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.hasSymbolVisual = true, r;
    }
    return e.prototype.getInitialData = function(r, n) {
      return So(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.brushSelector = function(r, n, i) {
      return i.point(n.getItemLayout(r));
    }, e.type = "series.effectScatter", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      effectType: "ripple",
      progressive: 0,
      showEffectOn: "render",
      clip: true,
      rippleEffect: {
        period: 4,
        scale: 2.5,
        brushType: "fill",
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      symbolSize: 10
    }, e;
  }(Xt);
  function whe(t) {
    t.registerChartView(bhe), t.registerSeriesModel(xhe), t.registerLayout(Hd("effectScatter"));
  }
  var qW = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this) || this;
      return a.add(a.createLine(r, n, i)), a._updateEffectSymbol(r, n), a;
    }
    return e.prototype.createLine = function(r, n, i) {
      return new d2(r, n, i);
    }, e.prototype._updateEffectSymbol = function(r, n) {
      var i = r.getItemModel(n), a = i.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
      ae(o) || (o = [
        o,
        o
      ]);
      var l = r.getItemVisual(n, "style"), u = a.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = mr(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = true, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(a.getItemStyle([
        "color"
      ])), c.scaleX = o[0], c.scaleY = o[1], c.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(r, a, n));
    }, e.prototype._updateEffectAnimation = function(r, n, i) {
      var a = this.childAt(1);
      if (a) {
        var o = r.getItemLayout(i), s = n.get("period") * 1e3, l = n.get("loop"), u = n.get("roundTrip"), c = n.get("constantSpeed"), h = Fr(n.get("delay"), function(d) {
          return d / r.count() * s / 3;
        });
        if (a.ignore = true, this._updateAnimationPoints(a, o), c > 0 && (s = this._getLineLength(a) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var f = void 0;
          De(h) ? f = h(i) : f = h, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, e.prototype._animateSymbol = function(r, n, i, a, o) {
      if (n > 0) {
        r.__t = 0;
        var s = this, l = r.animate("", a).when(o ? n * 2 : n, {
          __t: o ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(r);
        });
        a || l.done(function() {
          s.remove(r);
        }), l.start();
      }
    }, e.prototype._getLineLength = function(r) {
      return jo(r.__p1, r.__cp1) + jo(r.__cp1, r.__p2);
    }, e.prototype._updateAnimationPoints = function(r, n) {
      r.__p1 = n[0], r.__p2 = n[1], r.__cp1 = n[2] || [
        (n[0][0] + n[1][0]) / 2,
        (n[0][1] + n[1][1]) / 2
      ];
    }, e.prototype.updateData = function(r, n, i) {
      this.childAt(0).updateData(r, n, i), this._updateEffectSymbol(r, n);
    }, e.prototype._updateSymbolPosition = function(r) {
      var n = r.__p1, i = r.__p2, a = r.__cp1, o = r.__t < 1 ? r.__t : 2 - r.__t, s = [
        r.x,
        r.y
      ], l = s.slice(), u = Br, c = lx;
      s[0] = u(n[0], a[0], i[0], o), s[1] = u(n[1], a[1], i[1], o);
      var h = r.__t < 1 ? c(n[0], a[0], i[0], o) : c(i[0], a[0], n[0], 1 - o), f = r.__t < 1 ? c(n[1], a[1], i[1], o) : c(i[1], a[1], n[1], 1 - o);
      r.rotation = -Math.atan2(f, h) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (r.__lastT !== void 0 && r.__lastT < r.__t ? (r.scaleY = jo(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : r.__lastT === 1 ? r.scaleY = 2 * jo(n, s) : r.scaleY = this._symbolScale[1]), r.__lastT = r.__t, r.ignore = false, r.x = s[0], r.y = s[1];
    }, e.prototype.updateLayout = function(r, n) {
      this.childAt(0).updateLayout(r, n);
      var i = r.getItemModel(n).getModel("effect");
      this._updateEffectAnimation(r, i, n);
    }, e;
  }(Be), XW = function(t) {
    K(e, t);
    function e(r, n, i) {
      var a = t.call(this) || this;
      return a._createPolyline(r, n, i), a;
    }
    return e.prototype._createPolyline = function(r, n, i) {
      var a = r.getItemLayout(n), o = new Tn({
        shape: {
          points: a
        }
      });
      this.add(o), this._updateCommonStl(r, n, i);
    }, e.prototype.updateData = function(r, n, i) {
      var a = r.hostModel, o = this.childAt(0), s = {
        shape: {
          points: r.getItemLayout(n)
        }
      };
      wt(o, s, a, n), this._updateCommonStl(r, n, i);
    }, e.prototype._updateCommonStl = function(r, n, i) {
      var a = this.childAt(0), o = r.getItemModel(n), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || r.hasItemOption) {
        var h = o.getModel("emphasis");
        s = h.getModel("lineStyle").getLineStyle(), c = h.get("disabled"), l = h.get("focus"), u = h.get("blurScope");
      }
      a.useStyle(r.getItemVisual(n, "style")), a.style.fill = null, a.style.strokeNoScale = true;
      var f = a.ensureState("emphasis");
      f.style = s, ir(this, l, u, c);
    }, e.prototype.updateLayout = function(r, n) {
      var i = this.childAt(0);
      i.setShape("points", r.getItemLayout(n));
    }, e;
  }(Be), She = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r._lastFrame = 0, r._lastFramePercent = 0, r;
    }
    return e.prototype.createLine = function(r, n, i) {
      return new XW(r, n, i);
    }, e.prototype._updateAnimationPoints = function(r, n) {
      this._points = n;
      for (var i = [
        0
      ], a = 0, o = 1; o < n.length; o++) {
        var s = n[o - 1], l = n[o];
        a += jo(s, l), i.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var o = 0; o < i.length; o++) i[o] /= a;
      this._offsets = i, this._length = a;
    }, e.prototype._getLineLength = function() {
      return this._length;
    }, e.prototype._updateSymbolPosition = function(r) {
      var n = r.__t < 1 ? r.__t : 2 - r.__t, i = this._points, a = this._offsets, o = i.length;
      if (a) {
        var s = this._lastFrame, l;
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1);
          for (l = u; l >= 0 && !(a[l] <= n); l--) ;
          l = Math.min(l, o - 2);
        } else {
          for (l = s; l < o && !(a[l] > n); l++) ;
          l = Math.min(l - 1, o - 2);
        }
        var c = (n - a[l]) / (a[l + 1] - a[l]), h = i[l], f = i[l + 1];
        r.x = h[0] * (1 - c) + c * f[0], r.y = h[1] * (1 - c) + c * f[1];
        var d = r.__t < 1 ? f[0] - h[0] : h[0] - f[0], p = r.__t < 1 ? f[1] - h[1] : h[1] - f[1];
        r.rotation = -Math.atan2(p, d) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = n, r.ignore = false;
      }
    }, e;
  }(qW), The = /* @__PURE__ */ function() {
    function t() {
      this.polyline = false, this.curveness = 0, this.segs = [];
    }
    return t;
  }(), Che = function(t) {
    K(e, t);
    function e(r) {
      var n = t.call(this, r) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return e.prototype.reset = function() {
      this.notClear = false, this._off = 0;
    }, e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new The();
    }, e.prototype.buildPath = function(r, n) {
      var i = n.segs, a = n.curveness, o;
      if (n.polyline) for (o = this._off; o < i.length; ) {
        var s = i[o++];
        if (s > 0) {
          r.moveTo(i[o++], i[o++]);
          for (var l = 1; l < s; l++) r.lineTo(i[o++], i[o++]);
        }
      }
      else for (o = this._off; o < i.length; ) {
        var u = i[o++], c = i[o++], h = i[o++], f = i[o++];
        if (r.moveTo(u, c), a > 0) {
          var d = (u + h) / 2 - (c - f) * a, p = (c + f) / 2 - (h - u) * a;
          r.quadraticCurveTo(d, p, h, f);
        } else r.lineTo(h, f);
      }
      this.incremental && (this._off = o, this.notClear = true);
    }, e.prototype.findDataIndex = function(r, n) {
      var i = this.shape, a = i.segs, o = i.curveness, s = this.style.lineWidth;
      if (i.polyline) for (var l = 0, u = 0; u < a.length; ) {
        var c = a[u++];
        if (c > 0) for (var h = a[u++], f = a[u++], d = 1; d < c; d++) {
          var p = a[u++], v = a[u++];
          if (qo(h, f, p, v, s, r, n)) return l;
        }
        l++;
      }
      else for (var l = 0, u = 0; u < a.length; ) {
        var h = a[u++], f = a[u++], p = a[u++], v = a[u++];
        if (o > 0) {
          var g = (h + p) / 2 - (f - v) * o, m = (f + v) / 2 - (p - h) * o;
          if (b4(h, f, g, m, p, v, s, r, n)) return l;
        } else if (qo(h, f, p, v, s, r, n)) return l;
        l++;
      }
      return -1;
    }, e.prototype.contain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), a = this.getBoundingRect();
      if (r = i[0], n = i[1], a.contain(r, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(r, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, false;
    }, e.prototype.getBoundingRect = function() {
      var r = this._rect;
      if (!r) {
        for (var n = this.shape, i = n.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], h = i[u++];
          a = Math.min(c, a), s = Math.max(c, s), o = Math.min(h, o), l = Math.max(h, l);
        }
        r = this._rect = new Ze(a, o, s, l);
      }
      return r;
    }, e;
  }(st), Ahe = function() {
    function t() {
      this.group = new Be();
    }
    return t.prototype.updateData = function(e) {
      this._clear();
      var r = this._create();
      r.setShape({
        segs: e.getLayout("linesPoints")
      }), this._setCommon(r, e);
    }, t.prototype.incrementalPrepareUpdate = function(e) {
      this.group.removeAll(), this._clear();
    }, t.prototype.incrementalUpdate = function(e, r) {
      var n = this._newAdded[0], i = r.getLayout("linesPoints"), a = n && n.shape.segs;
      if (a && a.length < 2e4) {
        var o = a.length, s = new Float32Array(o + i.length);
        s.set(a), s.set(i, o), n.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = true, l.setShape({
          segs: i
        }), this._setCommon(l, r), l.__startIndex = e.start;
      }
    }, t.prototype.remove = function() {
      this._clear();
    }, t.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, t.prototype._create = function() {
      var e = new Che({
        cursor: "default",
        ignoreCoarsePointer: true
      });
      return this._newAdded.push(e), this.group.add(e), e;
    }, t.prototype._setCommon = function(e, r, n) {
      var i = r.hostModel;
      e.setShape({
        polyline: i.get("polyline"),
        curveness: i.get([
          "lineStyle",
          "curveness"
        ])
      }), e.useStyle(i.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = true;
      var a = r.getVisual("style");
      a && a.stroke && e.setStyle("stroke", a.stroke), e.setStyle("fill", null);
      var o = Ge(e);
      o.seriesIndex = i.seriesIndex, e.on("mousemove", function(s) {
        o.dataIndex = null;
        var l = e.hoverDataIdx;
        l > 0 && (o.dataIndex = l + e.__startIndex);
      });
    }, t.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, t;
  }(), jW = {
    seriesType: "lines",
    plan: Xc(),
    reset: function(t) {
      var e = t.coordinateSystem;
      if (e) {
        var r = t.get("polyline"), n = t.pipelineContext.large;
        return {
          progress: function(i, a) {
            var o = [];
            if (n) {
              var s = void 0, l = i.end - i.start;
              if (r) {
                for (var u = 0, c = i.start; c < i.end; c++) u += t.getLineCoordsCount(c);
                s = new Float32Array(l + u * 2);
              } else s = new Float32Array(l * 4);
              for (var h = 0, f = [], c = i.start; c < i.end; c++) {
                var d = t.getLineCoords(c, o);
                r && (s[h++] = d);
                for (var p = 0; p < d; p++) f = e.dataToPoint(o[p], false, f), s[h++] = f[0], s[h++] = f[1];
              }
              a.setLayout("linesPoints", s);
            } else for (var c = i.start; c < i.end; c++) {
              var v = a.getItemModel(c), d = t.getLineCoords(c, o), g = [];
              if (r) for (var m = 0; m < d; m++) g.push(e.dataToPoint(o[m]));
              else {
                g[0] = e.dataToPoint(o[0]), g[1] = e.dataToPoint(o[1]);
                var y = v.get([
                  "lineStyle",
                  "curveness"
                ]);
                +y && (g[2] = [
                  (g[0][0] + g[1][0]) / 2 - (g[0][1] - g[1][1]) * y,
                  (g[0][1] + g[1][1]) / 2 - (g[1][0] - g[0][0]) * y
                ]);
              }
              a.setItemLayout(c, g);
            }
          }
        };
      }
    }
  }, Ihe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = r.getData(), o = this._updateLineDraw(a, r), s = r.get("zlevel"), l = r.get([
        "effect",
        "trailLength"
      ]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(true), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: false
      }), this._showEffect(r) && l > 0 && (c || u.configLayer(s, {
        motionBlur: true,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), o.updateData(a);
      var h = r.get("clip", true) && Wd(r.coordinateSystem, false, r);
      h ? this.group.setClipPath(h) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = true;
    }, e.prototype.incrementalPrepareRender = function(r, n, i) {
      var a = r.getData(), o = this._updateLineDraw(a, r);
      o.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = false;
    }, e.prototype.incrementalRender = function(r, n, i) {
      this._lineDraw.incrementalUpdate(r, n.getData()), this._finished = r.end === n.getData().count();
    }, e.prototype.eachRendered = function(r) {
      this._lineDraw && this._lineDraw.eachRendered(r);
    }, e.prototype.updateTransform = function(r, n, i) {
      var a = r.getData(), o = r.pipelineContext;
      if (!this._finished || o.large || o.progressiveRender) return {
        update: true
      };
      var s = jW.reset(r, n, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, e.prototype._updateLineDraw = function(r, n) {
      var i = this._lineDraw, a = this._showEffect(n), o = !!n.get("polyline"), s = n.pipelineContext, l = s.large;
      return (!i || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new Ahe() : new p2(o ? a ? She : XW : a ? qW : d2), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(i.group), i;
    }, e.prototype._showEffect = function(r) {
      return !!r.get([
        "effect",
        "show"
      ]);
    }, e.prototype._clearLayer = function(r) {
      var n = r.getZr(), i = n.painter.getType() === "svg";
      !i && this._lastZlevel != null && n.painter.getLayer(this._lastZlevel).clear(true);
    }, e.prototype.remove = function(r, n) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(n);
    }, e.prototype.dispose = function(r, n) {
      this.remove(r, n);
    }, e.type = "lines", e;
  }(Ft), Mhe = typeof Uint32Array > "u" ? Array : Uint32Array, Dhe = typeof Float64Array > "u" ? Array : Float64Array;
  function uL(t) {
    var e = t.data;
    e && e[0] && e[0][0] && e[0][0].coord && (t.data = oe(e, function(r) {
      var n = [
        r[0].coord,
        r[1].coord
      ], i = {
        coords: n
      };
      return r[0].name && (i.fromName = r[0].name), r[1].name && (i.toName = r[1].name), qS([
        i,
        r[0],
        r[1]
      ]);
    }));
  }
  var Ehe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.visualStyleAccessPath = "lineStyle", r.visualDrawType = "stroke", r;
    }
    return e.prototype.init = function(r) {
      r.data = r.data || [], uL(r);
      var n = this._processFlatCoordsArray(r.data);
      this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (r.data = new Float32Array(n.count)), t.prototype.init.apply(this, arguments);
    }, e.prototype.mergeOption = function(r) {
      if (uL(r), r.data) {
        var n = this._processFlatCoordsArray(r.data);
        this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (r.data = new Float32Array(n.count));
      }
      t.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.appendData = function(r) {
      var n = this._processFlatCoordsArray(r.data);
      n.flatCoords && (this._flatCoords ? (this._flatCoords = Vf(this._flatCoords, n.flatCoords), this._flatCoordsOffset = Vf(this._flatCoordsOffset, n.flatCoordsOffset)) : (this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset), r.data = new Float32Array(n.count)), this.getRawData().appendData(r.data);
    }, e.prototype._getCoordsFromItemModel = function(r) {
      var n = this.getData().getItemModel(r), i = n.option instanceof Array ? n.option : n.getShallow("coords");
      return i;
    }, e.prototype.getLineCoordsCount = function(r) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[r * 2 + 1] : this._getCoordsFromItemModel(r).length;
    }, e.prototype.getLineCoords = function(r, n) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[r * 2], a = this._flatCoordsOffset[r * 2 + 1], o = 0; o < a; o++) n[o] = n[o] || [], n[o][0] = this._flatCoords[i + o * 2], n[o][1] = this._flatCoords[i + o * 2 + 1];
        return a;
      } else {
        for (var s = this._getCoordsFromItemModel(r), o = 0; o < s.length; o++) n[o] = n[o] || [], n[o][0] = s[o][0], n[o][1] = s[o][1];
        return s.length;
      }
    }, e.prototype._processFlatCoordsArray = function(r) {
      var n = 0;
      if (this._flatCoords && (n = this._flatCoords.length), xt(r[0])) {
        for (var i = r.length, a = new Mhe(i), o = new Dhe(i), s = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var h = r[c++];
          a[l++] = s + n, a[l++] = h;
          for (var f = 0; f < h; f++) {
            var d = r[c++], p = r[c++];
            o[s++] = d, o[s++] = p;
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: r.length
      };
    }, e.prototype.getInitialData = function(r, n) {
      var i = new yn([
        "value"
      ], this);
      return i.hasItemOption = false, i.initData(r.data, [], function(a, o, s, l) {
        if (a instanceof Array) return NaN;
        i.hasItemOption = true;
        var u = a.value;
        if (u != null) return u instanceof Array ? u[l] : u;
      }), i;
    }, e.prototype.formatTooltip = function(r, n, i) {
      var a = this.getData(), o = a.getItemModel(r), s = o.get("name");
      if (s) return s;
      var l = o.get("fromName"), u = o.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), $r("nameValue", {
        name: c.join(" > ")
      });
    }, e.prototype.preventIncremental = function() {
      return !!this.get([
        "effect",
        "show"
      ]);
    }, e.prototype.getProgressive = function() {
      var r = this.option.progressive;
      return r ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var r = this.option.progressiveThreshold;
      return r ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, e.prototype.getZLevelKey = function() {
      var r = this.getModel("effect"), n = r.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : r.get("show") && n > 0 ? n + "" : "";
    }, e.type = "series.lines", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "geo",
      z: 2,
      legendHoverLink: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: [
        "none",
        "none"
      ],
      symbolSize: [
        10,
        10
      ],
      geoIndex: 0,
      effect: {
        show: false,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: true,
        trailLength: 0.2
      },
      large: false,
      largeThreshold: 2e3,
      polyline: false,
      clip: true,
      label: {
        show: false,
        position: "end"
      },
      lineStyle: {
        opacity: 0.5
      }
    }, e;
  }(Xt);
  function iv(t) {
    return t instanceof Array || (t = [
      t,
      t
    ]), t;
  }
  var khe = {
    seriesType: "lines",
    reset: function(t) {
      var e = iv(t.get("symbol")), r = iv(t.get("symbolSize")), n = t.getData();
      n.setVisual("fromSymbol", e && e[0]), n.setVisual("toSymbol", e && e[1]), n.setVisual("fromSymbolSize", r && r[0]), n.setVisual("toSymbolSize", r && r[1]);
      function i(a, o) {
        var s = a.getItemModel(o), l = iv(s.getShallow("symbol", true)), u = iv(s.getShallow("symbolSize", true));
        l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
      }
      return {
        dataEach: n.hasItemOption ? i : null
      };
    }
  };
  function Phe(t) {
    t.registerChartView(Ihe), t.registerSeriesModel(Ehe), t.registerLayout(jW), t.registerVisual(khe);
  }
  var Lhe = 256, $he = function() {
    function t() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var e = hs.createCanvas();
      this.canvas = e;
    }
    return t.prototype.update = function(e, r, n, i, a, o) {
      var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), c = this.pointSize + this.blurSize, h = this.canvas, f = h.getContext("2d"), d = e.length;
      h.width = r, h.height = n;
      for (var p = 0; p < d; ++p) {
        var v = e[p], g = v[0], m = v[1], y = v[2], _ = i(y);
        f.globalAlpha = _, f.drawImage(s, g - c, m - c);
      }
      if (!h.width || !h.height) return h;
      for (var b = f.getImageData(0, 0, h.width, h.height), w = b.data, x = 0, T = w.length, A = this.minOpacity, I = this.maxOpacity, M = I - A; x < T; ) {
        var _ = w[x + 3] / 256, k = Math.floor(_ * (Lhe - 1)) * 4;
        if (_ > 0) {
          var B = o(_) ? l : u;
          _ > 0 && (_ = _ * M + A), w[x++] = B[k], w[x++] = B[k + 1], w[x++] = B[k + 2], w[x++] = B[k + 3] * _ * 256;
        } else x += 4;
      }
      return f.putImageData(b, 0, 0), h;
    }, t.prototype._getBrush = function() {
      var e = this._brushCanvas || (this._brushCanvas = hs.createCanvas()), r = this.pointSize + this.blurSize, n = r * 2;
      e.width = n, e.height = n;
      var i = e.getContext("2d");
      return i.clearRect(0, 0, n, n), i.shadowOffsetX = n, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-r, r, this.pointSize, 0, Math.PI * 2, true), i.closePath(), i.fill(), e;
    }, t.prototype._getGradient = function(e, r) {
      for (var n = this._gradientPixels, i = n[r] || (n[r] = new Uint8ClampedArray(256 * 4)), a = [
        0,
        0,
        0,
        0
      ], o = 0, s = 0; s < 256; s++) e[r](s / 255, true, a), i[o++] = a[0], i[o++] = a[1], i[o++] = a[2], i[o++] = a[3];
      return i;
    }, t;
  }();
  function Rhe(t, e, r) {
    var n = t[1] - t[0];
    e = oe(e, function(o) {
      return {
        interval: [
          (o.interval[0] - t[0]) / n,
          (o.interval[1] - t[0]) / n
        ]
      };
    });
    var i = e.length, a = 0;
    return function(o) {
      var s;
      for (s = a; s < i; s++) {
        var l = e[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
      if (s === i) for (s = a - 1; s >= 0; s--) {
        var l = e[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
      return s >= 0 && s < i && r[s];
    };
  }
  function Ohe(t, e) {
    var r = t[1] - t[0];
    return e = [
      (e[0] - t[0]) / r,
      (e[1] - t[0]) / r
    ], function(n) {
      return n >= e[0] && n <= e[1];
    };
  }
  function cL(t) {
    var e = t.dimensions;
    return e[0] === "lng" && e[1] === "lat";
  }
  var Nhe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a;
      n.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === r && (a = s);
        });
      }), this._progressiveEls = null, this.group.removeAll();
      var o = r.coordinateSystem;
      o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(r, i, 0, r.getData().count()) : cL(o) && this._renderOnGeo(o, r, a, i);
    }, e.prototype.incrementalPrepareRender = function(r, n, i) {
      this.group.removeAll();
    }, e.prototype.incrementalRender = function(r, n, i, a) {
      var o = n.coordinateSystem;
      o && (cL(o) ? this.render(n, i, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(n, a, r.start, r.end, true)));
    }, e.prototype.eachRendered = function(r) {
      bs(this._progressiveEls || this.group, r);
    }, e.prototype._renderOnCartesianAndCalendar = function(r, n, i, a, o) {
      var s = r.coordinateSystem, l = lu(s, "cartesian2d"), u, c, h, f;
      if (l) {
        var d = s.getAxis("x"), p = s.getAxis("y");
        u = d.getBandWidth() + 0.5, c = p.getBandWidth() + 0.5, h = d.scale.getExtent(), f = p.scale.getExtent();
      }
      for (var v = this.group, g = r.getData(), m = r.getModel([
        "emphasis",
        "itemStyle"
      ]).getItemStyle(), y = r.getModel([
        "blur",
        "itemStyle"
      ]).getItemStyle(), _ = r.getModel([
        "select",
        "itemStyle"
      ]).getItemStyle(), b = r.get([
        "itemStyle",
        "borderRadius"
      ]), w = Lr(r), x = r.getModel("emphasis"), T = x.get("focus"), A = x.get("blurScope"), I = x.get("disabled"), M = l ? [
        g.mapDimension("x"),
        g.mapDimension("y"),
        g.mapDimension("value")
      ] : [
        g.mapDimension("time"),
        g.mapDimension("value")
      ], k = i; k < a; k++) {
        var B = void 0, L = g.getItemVisual(k, "style");
        if (l) {
          var z = g.get(M[0], k), F = g.get(M[1], k);
          if (isNaN(g.get(M[2], k)) || isNaN(z) || isNaN(F) || z < h[0] || z > h[1] || F < f[0] || F > f[1]) continue;
          var E = s.dataToPoint([
            z,
            F
          ]);
          B = new yt({
            shape: {
              x: E[0] - u / 2,
              y: E[1] - c / 2,
              width: u,
              height: c
            },
            style: L
          });
        } else {
          if (isNaN(g.get(M[1], k))) continue;
          B = new yt({
            z2: 1,
            shape: s.dataToRect([
              g.get(M[0], k)
            ]).contentShape,
            style: L
          });
        }
        if (g.hasItemOption) {
          var O = g.getItemModel(k), N = O.getModel("emphasis");
          m = N.getModel("itemStyle").getItemStyle(), y = O.getModel([
            "blur",
            "itemStyle"
          ]).getItemStyle(), _ = O.getModel([
            "select",
            "itemStyle"
          ]).getItemStyle(), b = O.get([
            "itemStyle",
            "borderRadius"
          ]), T = N.get("focus"), A = N.get("blurScope"), I = N.get("disabled"), w = Lr(O);
        }
        B.shape.r = b;
        var V = r.getRawValue(k), H = "-";
        V && V[2] != null && (H = V[2] + ""), Xr(B, w, {
          labelFetcher: r,
          labelDataIndex: k,
          defaultOpacity: L.opacity,
          defaultText: H
        }), B.ensureState("emphasis").style = m, B.ensureState("blur").style = y, B.ensureState("select").style = _, ir(B, T, A, I), B.incremental = o, o && (B.states.emphasis.hoverLayer = true), v.add(B), g.setItemGraphicEl(k, B), this._progressiveEls && this._progressiveEls.push(B);
      }
    }, e.prototype._renderOnGeo = function(r, n, i, a) {
      var o = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = n.getData(), u = this._hmLayer || this._hmLayer || new $he();
      u.blurSize = n.get("blurSize"), u.pointSize = n.get("pointSize"), u.minOpacity = n.get("minOpacity"), u.maxOpacity = n.get("maxOpacity");
      var c = r.getViewRect().clone(), h = r.getRoamTransform();
      c.applyTransform(h);
      var f = Math.max(c.x, 0), d = Math.max(c.y, 0), p = Math.min(c.width + c.x, a.getWidth()), v = Math.min(c.height + c.y, a.getHeight()), g = p - f, m = v - d, y = [
        l.mapDimension("lng"),
        l.mapDimension("lat"),
        l.mapDimension("value")
      ], _ = l.mapArray(y, function(T, A, I) {
        var M = r.dataToPoint([
          T,
          A
        ]);
        return M[0] -= f, M[1] -= d, M.push(I), M;
      }), b = i.getExtent(), w = i.type === "visualMap.continuous" ? Ohe(b, i.option.range) : Rhe(b, i.getPieceList(), i.option.selected);
      u.update(_, g, m, o.color.getNormalizer(), {
        inRange: o.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, w);
      var x = new Gr({
        style: {
          width: g,
          height: m,
          x: f,
          y: d,
          image: u.canvas
        },
        silent: true
      });
      this.group.add(x);
    }, e.type = "heatmap", e;
  }(Ft), Bhe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.getInitialData = function(r, n) {
      return So(null, this, {
        generateCoord: "value"
      });
    }, e.prototype.preventIncremental = function() {
      var r = Nd.get(this.get("coordinateSystem"));
      if (r && r.dimensions) return r.dimensions[0] === "lng" && r.dimensions[1] === "lat";
    }, e.type = "series.heatmap", e.dependencies = [
      "grid",
      "geo",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Xt);
  function zhe(t) {
    t.registerChartView(Nhe), t.registerSeriesModel(Bhe);
  }
  var Fhe = [
    "itemStyle",
    "borderWidth"
  ], hL = [
    {
      xy: "x",
      wh: "width",
      index: 0,
      posDesc: [
        "left",
        "right"
      ]
    },
    {
      xy: "y",
      wh: "height",
      index: 1,
      posDesc: [
        "top",
        "bottom"
      ]
    }
  ], H_ = new wo(), Vhe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = this.group, o = r.getData(), s = this._data, l = r.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), h = l.master.getRect(), f = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: r,
        coordSys: l,
        coordSysExtent: [
          [
            h.x,
            h.x + h.width
          ],
          [
            h.y,
            h.y + h.height
          ]
        ],
        isHorizontal: c,
        valueDim: hL[+c],
        categoryDim: hL[1 - +c]
      };
      o.diff(s).add(function(p) {
        if (o.hasValue(p)) {
          var v = dL(o, p), g = fL(o, p, v, f), m = pL(o, f, g);
          o.setItemGraphicEl(p, m), a.add(m), gL(m, f, g);
        }
      }).update(function(p, v) {
        var g = s.getItemGraphicEl(v);
        if (!o.hasValue(p)) {
          a.remove(g);
          return;
        }
        var m = dL(o, p), y = fL(o, p, m, f), _ = tH(o, y);
        g && _ !== g.__pictorialShapeStr && (a.remove(g), o.setItemGraphicEl(p, null), g = null), g ? Xhe(g, f, y) : g = pL(o, f, y, true), o.setItemGraphicEl(p, g), g.__pictorialSymbolMeta = y, a.add(g), gL(g, f, y);
      }).remove(function(p) {
        var v = s.getItemGraphicEl(p);
        v && vL(s, p, v.__pictorialSymbolMeta.animationModel, v);
      }).execute();
      var d = r.get("clip", true) ? Wd(r.coordinateSystem, false, r) : null;
      return d ? a.setClipPath(d) : a.removeClipPath(), this._data = o, this.group;
    }, e.prototype.remove = function(r, n) {
      var i = this.group, a = this._data;
      r.get("animation") ? a && a.eachItemGraphicEl(function(o) {
        vL(a, Ge(o).dataIndex, r, o);
      }) : i.removeAll();
    }, e.type = "pictorialBar", e;
  }(Ft);
  function fL(t, e, r, n) {
    var i = t.getItemLayout(e), a = r.get("symbolRepeat"), o = r.get("symbolClip"), s = r.get("symbolPosition") || "start", l = r.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = r.get("symbolPatternSize") || 2, h = r.isAnimationEnabled(), f = {
      dataIndex: e,
      layout: i,
      itemModel: r,
      symbolType: t.getItemVisual(e, "symbol") || "circle",
      style: t.getItemVisual(e, "style"),
      symbolClip: o,
      symbolRepeat: a,
      symbolRepeatDirection: r.get("symbolRepeatDirection"),
      symbolPatternSize: c,
      rotation: u,
      animationModel: h ? r : null,
      hoverScale: h && r.get([
        "emphasis",
        "scale"
      ]),
      z2: r.getShallow("z", true) || 0
    };
    Ghe(r, a, i, n, f), Whe(t, e, i, a, o, f.boundingLength, f.pxSign, c, n, f), Hhe(r, f.symbolScale, u, n, f);
    var d = f.symbolSize, p = ou(r.get("symbolOffset"), d);
    return Uhe(r, d, i, a, o, p, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, n, f), f;
  }
  function Ghe(t, e, r, n, i) {
    var a = n.valueDim, o = t.get("symbolBoundingData"), s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(r[a.wh] <= 0), c;
    if (ae(o)) {
      var h = [
        U_(s, o[0]) - l,
        U_(s, o[1]) - l
      ];
      h[1] < h[0] && h.reverse(), c = h[u];
    } else o != null ? c = U_(s, o) - l : e ? c = n.coordSysExtent[a.index][u] - l : c = r[a.wh];
    i.boundingLength = c, e && (i.repeatCutLength = r[a.wh]);
    var f = a.xy === "x", d = s.inverse;
    i.pxSign = f && !d || !f && d ? c >= 0 ? 1 : -1 : c > 0 ? 1 : -1;
  }
  function U_(t, e) {
    return t.toGlobalCoord(t.dataToCoord(t.scale.parse(e)));
  }
  function Whe(t, e, r, n, i, a, o, s, l, u) {
    var c = l.valueDim, h = l.categoryDim, f = Math.abs(r[h.wh]), d = t.getItemVisual(e, "symbolSize"), p;
    ae(d) ? p = d.slice() : d == null ? p = [
      "100%",
      "100%"
    ] : p = [
      d,
      d
    ], p[h.index] = pe(p[h.index], f), p[c.index] = pe(p[c.index], n ? f : Math.abs(a)), u.symbolSize = p;
    var v = u.symbolScale = [
      p[0] / s,
      p[1] / s
    ];
    v[c.index] *= (l.isHorizontal ? -1 : 1) * o;
  }
  function Hhe(t, e, r, n, i) {
    var a = t.get(Fhe) || 0;
    a && (H_.attr({
      scaleX: e[0],
      scaleY: e[1],
      rotation: r
    }), H_.updateTransform(), a /= H_.getLineScale(), a *= e[n.valueDim.index]), i.valueLineWidth = a || 0;
  }
  function Uhe(t, e, r, n, i, a, o, s, l, u, c, h) {
    var f = c.categoryDim, d = c.valueDim, p = h.pxSign, v = Math.max(e[d.index] + s, 0), g = v;
    if (n) {
      var m = Math.abs(l), y = Fr(t.get("symbolMargin"), "15%") + "", _ = false;
      y.lastIndexOf("!") === y.length - 1 && (_ = true, y = y.slice(0, y.length - 1));
      var b = pe(y, e[d.index]), w = Math.max(v + b * 2, 0), x = _ ? 0 : b * 2, T = o4(n), A = T ? n : mL((m + x) / w), I = m - A * v;
      b = I / 2 / (_ ? A : Math.max(A - 1, 1)), w = v + b * 2, x = _ ? 0 : b * 2, !T && n !== "fixed" && (A = u ? mL((Math.abs(u) + x) / w) : 0), g = A * w - x, h.repeatTimes = A, h.symbolMargin = b;
    }
    var M = p * (g / 2), k = h.pathPosition = [];
    k[f.index] = r[f.wh] / 2, k[d.index] = o === "start" ? M : o === "end" ? l - M : l / 2, a && (k[0] += a[0], k[1] += a[1]);
    var B = h.bundlePosition = [];
    B[f.index] = r[f.xy], B[d.index] = r[d.xy];
    var L = h.barRectShape = te({}, r);
    L[d.wh] = p * Math.max(Math.abs(r[d.wh]), Math.abs(k[d.index] + M)), L[f.wh] = r[f.wh];
    var z = h.clipShape = {};
    z[f.xy] = -r[f.xy], z[f.wh] = c.ecSize[f.wh], z[d.xy] = 0, z[d.wh] = r[d.wh];
  }
  function KW(t) {
    var e = t.symbolPatternSize, r = mr(t.symbolType, -e / 2, -e / 2, e, e);
    return r.attr({
      culling: true
    }), r.type !== "image" && r.setStyle({
      strokeNoScale: true
    }), r;
  }
  function ZW(t, e, r, n) {
    var i = t.__pictorialBundle, a = r.symbolSize, o = r.valueLineWidth, s = r.pathPosition, l = e.valueDim, u = r.repeatTimes || 0, c = 0, h = a[e.valueDim.index] + o + r.symbolMargin * 2;
    for (T2(t, function(v) {
      v.__pictorialAnimationIndex = c, v.__pictorialRepeatTimes = u, c < u ? vc(v, null, p(c), r, n) : vc(v, null, {
        scaleX: 0,
        scaleY: 0
      }, r, n, function() {
        i.remove(v);
      }), c++;
    }); c < u; c++) {
      var f = KW(r);
      f.__pictorialAnimationIndex = c, f.__pictorialRepeatTimes = u, i.add(f);
      var d = p(c);
      vc(f, {
        x: d.x,
        y: d.y,
        scaleX: 0,
        scaleY: 0
      }, {
        scaleX: d.scaleX,
        scaleY: d.scaleY,
        rotation: d.rotation
      }, r, n);
    }
    function p(v) {
      var g = s.slice(), m = r.pxSign, y = v;
      return (r.symbolRepeatDirection === "start" ? m > 0 : m < 0) && (y = u - 1 - v), g[l.index] = h * (y - u / 2 + 0.5) + s[l.index], {
        x: g[0],
        y: g[1],
        scaleX: r.symbolScale[0],
        scaleY: r.symbolScale[1],
        rotation: r.rotation
      };
    }
  }
  function QW(t, e, r, n) {
    var i = t.__pictorialBundle, a = t.__pictorialMainPath;
    a ? vc(a, null, {
      x: r.pathPosition[0],
      y: r.pathPosition[1],
      scaleX: r.symbolScale[0],
      scaleY: r.symbolScale[1],
      rotation: r.rotation
    }, r, n) : (a = t.__pictorialMainPath = KW(r), i.add(a), vc(a, {
      x: r.pathPosition[0],
      y: r.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: r.rotation
    }, {
      scaleX: r.symbolScale[0],
      scaleY: r.symbolScale[1]
    }, r, n));
  }
  function JW(t, e, r) {
    var n = te({}, e.barRectShape), i = t.__pictorialBarRect;
    i ? vc(i, null, {
      shape: n
    }, e, r) : (i = t.__pictorialBarRect = new yt({
      z2: 2,
      shape: n,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    }), i.disableMorphing = true, t.add(i));
  }
  function eH(t, e, r, n) {
    if (r.symbolClip) {
      var i = t.__pictorialClipPath, a = te({}, r.clipShape), o = e.valueDim, s = r.animationModel, l = r.dataIndex;
      if (i) wt(i, {
        shape: a
      }, s, l);
      else {
        a[o.wh] = 0, i = new yt({
          shape: a
        }), t.__pictorialBundle.setClipPath(i), t.__pictorialClipPath = i;
        var u = {};
        u[o.wh] = r.clipShape[o.wh], au[n ? "updateProps" : "initProps"](i, {
          shape: u
        }, s, l);
      }
    }
  }
  function dL(t, e) {
    var r = t.getItemModel(e);
    return r.getAnimationDelayParams = Yhe, r.isAnimationEnabled = qhe, r;
  }
  function Yhe(t) {
    return {
      index: t.__pictorialAnimationIndex,
      count: t.__pictorialRepeatTimes
    };
  }
  function qhe() {
    return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
  }
  function pL(t, e, r, n) {
    var i = new Be(), a = new Be();
    return i.add(a), i.__pictorialBundle = a, a.x = r.bundlePosition[0], a.y = r.bundlePosition[1], r.symbolRepeat ? ZW(i, e, r) : QW(i, e, r), JW(i, r, n), eH(i, e, r, n), i.__pictorialShapeStr = tH(t, r), i.__pictorialSymbolMeta = r, i;
  }
  function Xhe(t, e, r) {
    var n = r.animationModel, i = r.dataIndex, a = t.__pictorialBundle;
    wt(a, {
      x: r.bundlePosition[0],
      y: r.bundlePosition[1]
    }, n, i), r.symbolRepeat ? ZW(t, e, r, true) : QW(t, e, r, true), JW(t, r, true), eH(t, e, r, true);
  }
  function vL(t, e, r, n) {
    var i = n.__pictorialBarRect;
    i && i.removeTextContent();
    var a = [];
    T2(n, function(o) {
      a.push(o);
    }), n.__pictorialMainPath && a.push(n.__pictorialMainPath), n.__pictorialClipPath && (r = null), $(a, function(o) {
      ds(o, {
        scaleX: 0,
        scaleY: 0
      }, r, e, function() {
        n.parent && n.parent.remove(n);
      });
    }), t.setItemGraphicEl(e, null);
  }
  function tH(t, e) {
    return [
      t.getItemVisual(e.dataIndex, "symbol") || "none",
      !!e.symbolRepeat,
      !!e.symbolClip
    ].join(":");
  }
  function T2(t, e, r) {
    $(t.__pictorialBundle.children(), function(n) {
      n !== t.__pictorialBarRect && e.call(r, n);
    });
  }
  function vc(t, e, r, n, i, a) {
    e && t.attr(e), n.symbolClip && !i ? r && t.attr(r) : r && au[i ? "updateProps" : "initProps"](t, r, n.animationModel, n.dataIndex, a);
  }
  function gL(t, e, r) {
    var n = r.dataIndex, i = r.itemModel, a = i.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = i.getModel([
      "blur",
      "itemStyle"
    ]).getItemStyle(), l = i.getModel([
      "select",
      "itemStyle"
    ]).getItemStyle(), u = i.getShallow("cursor"), c = a.get("focus"), h = a.get("blurScope"), f = a.get("scale");
    T2(t, function(v) {
      if (v instanceof Gr) {
        var g = v.style;
        v.useStyle(te({
          image: g.image,
          x: g.x,
          y: g.y,
          width: g.width,
          height: g.height
        }, r.style));
      } else v.useStyle(r.style);
      var m = v.ensureState("emphasis");
      m.style = o, f && (m.scaleX = v.scaleX * 1.1, m.scaleY = v.scaleY * 1.1), v.ensureState("blur").style = s, v.ensureState("select").style = l, u && (v.cursor = u), v.z2 = r.z2;
    });
    var d = e.valueDim.posDesc[+(r.boundingLength > 0)], p = t.__pictorialBarRect;
    p.ignoreClip = true, Xr(p, Lr(i), {
      labelFetcher: e.seriesModel,
      labelDataIndex: n,
      defaultText: wc(e.seriesModel.getData(), n),
      inheritColor: r.style.fill,
      defaultOpacity: r.style.opacity,
      defaultOutsidePosition: d
    }), ir(t, c, h, a.get("disabled"));
  }
  function mL(t) {
    var e = Math.round(t);
    return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t);
  }
  var jhe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.hasSymbolVisual = true, r.defaultSymbol = "roundRect", r;
    }
    return e.prototype.getInitialData = function(r) {
      return r.stack = null, t.prototype.getInitialData.apply(this, arguments);
    }, e.type = "series.pictorialBar", e.dependencies = [
      "grid"
    ], e.defaultOption = xs(ad.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: false,
      symbolRepeatDirection: "end",
      symbolClip: false,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      clip: false,
      progressive: 0,
      emphasis: {
        scale: false
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), e;
  }(ad);
  function Khe(t) {
    t.registerChartView(Vhe), t.registerSeriesModel(jhe), t.registerLayout(t.PRIORITY.VISUAL.LAYOUT, Ye(B5, "pictorialBar")), t.registerLayout(t.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, z5("pictorialBar"));
  }
  var Zhe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._layers = [], r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = r.getData(), o = this, s = this.group, l = r.getLayerSeries(), u = a.getLayout("layoutInfo"), c = u.rect, h = u.boundaryGap;
      s.x = 0, s.y = c.y + h[0];
      function f(g) {
        return g.name;
      }
      var d = new vo(this._layersSeries || [], l, f, f), p = [];
      d.add(_e(v, this, "add")).update(_e(v, this, "update")).remove(_e(v, this, "remove")).execute();
      function v(g, m, y) {
        var _ = o._layers;
        if (g === "remove") {
          s.remove(_[m]);
          return;
        }
        for (var b = [], w = [], x, T = l[m].indices, A = 0; A < T.length; A++) {
          var I = a.getItemLayout(T[A]), M = I.x, k = I.y0, B = I.y;
          b.push(M, k), w.push(M, k + B), x = a.getItemVisual(T[A], "style");
        }
        var L, z = a.getItemLayout(T[0]), F = r.getModel("label"), E = F.get("margin"), O = r.getModel("emphasis");
        if (g === "add") {
          var N = p[m] = new Be();
          L = new IG({
            shape: {
              points: b,
              stackedOnPoints: w,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: false
            },
            z2: 0
          }), N.add(L), s.add(N), r.isAnimationEnabled() && L.setClipPath(Qhe(L.getBoundingRect(), r, function() {
            L.removeClipPath();
          }));
        } else {
          var N = _[y];
          L = N.childAt(0), s.add(N), p[m] = N, wt(L, {
            shape: {
              points: b,
              stackedOnPoints: w
            }
          }, r), Ki(L);
        }
        Xr(L, Lr(r), {
          labelDataIndex: T[A - 1],
          defaultText: a.getName(T[A - 1]),
          inheritColor: x.fill
        }, {
          normal: {
            verticalAlign: "middle"
          }
        }), L.setTextConfig({
          position: null,
          local: true
        });
        var V = L.getTextContent();
        V && (V.x = z.x - E, V.y = z.y0 + z.y / 2), L.useStyle(x), a.setItemGraphicEl(m, L), qr(L, r), ir(L, O.get("focus"), O.get("blurScope"), O.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, e.type = "themeRiver", e;
  }(Ft);
  function Qhe(t, e, r) {
    var n = new yt({
      shape: {
        x: t.x - 10,
        y: t.y - 10,
        width: 0,
        height: t.height + 20
      }
    });
    return er(n, {
      shape: {
        x: t.x - 50,
        width: t.width + 100,
        height: t.height + 20
      }
    }, e, r), n;
  }
  var Y_ = 2, Jhe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r) {
      t.prototype.init.apply(this, arguments), this.legendVisualProvider = new Yd(_e(this.getData, this), _e(this.getRawData, this));
    }, e.prototype.fixData = function(r) {
      var n = r.length, i = {}, a = Tx(r, function(f) {
        return i.hasOwnProperty(f[0] + "") || (i[f[0] + ""] = -1), f[2];
      }), o = [];
      a.buckets.each(function(f, d) {
        o.push({
          name: d,
          dataList: f
        });
      });
      for (var s = o.length, l = 0; l < s; ++l) {
        for (var u = o[l].name, c = 0; c < o[l].dataList.length; ++c) {
          var h = o[l].dataList[c][0] + "";
          i[h] = l;
        }
        for (var h in i) i.hasOwnProperty(h) && i[h] !== l && (i[h] = l, r[n] = [
          h,
          0,
          u
        ], n++);
      }
      return r;
    }, e.prototype.getInitialData = function(r, n) {
      for (var i = this.getReferringComponents("singleAxis", gr).models[0], a = i.get("type"), o = Dt(r.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(o || []), l = [], u = this.nameMap = Ce(), c = 0, h = 0; h < s.length; ++h) l.push(s[h][Y_]), u.get(s[h][Y_]) || (u.set(s[h][Y_], c), c++);
      var f = zd(s, {
        coordDimensions: [
          "single"
        ],
        dimensionsDefine: [
          {
            name: "time",
            type: Ug(a)
          },
          {
            name: "value",
            type: "float"
          },
          {
            name: "name",
            type: "ordinal"
          }
        ],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, d = new yn(f, this);
      return d.initData(s), d;
    }, e.prototype.getLayerSeries = function() {
      for (var r = this.getData(), n = r.count(), i = [], a = 0; a < n; ++a) i[a] = a;
      var o = r.mapDimension("single"), s = Tx(i, function(u) {
        return r.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(h, f) {
          return r.get(o, h) - r.get(o, f);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, e.prototype.getAxisTooltipData = function(r, n, i) {
      ae(r) || (r = r ? [
        r
      ] : []);
      for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, c = 0; c < l; ++c) {
        for (var h = Number.MAX_VALUE, f = -1, d = o[c].indices.length, p = 0; p < d; ++p) {
          var v = a.get(r[0], o[c].indices[p]), g = Math.abs(v - n);
          g <= h && (u = v, h = g, f = o[c].indices[p]);
        }
        s.push(f);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, e.prototype.formatTooltip = function(r, n, i) {
      var a = this.getData(), o = a.getName(r), s = a.get(a.mapDimension("value"), r);
      return $r("nameValue", {
        name: o,
        value: s
      });
    }, e.type = "series.themeRiver", e.dependencies = [
      "singleAxis"
    ], e.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      boundaryGap: [
        "10%",
        "10%"
      ],
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: true,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }, e;
  }(Xt);
  function efe(t, e) {
    t.eachSeriesByType("themeRiver", function(r) {
      var n = r.getData(), i = r.coordinateSystem, a = {}, o = i.getRect();
      a.rect = o;
      var s = r.get("boundaryGap"), l = i.getAxis();
      if (a.boundaryGap = s, l.orient === "horizontal") {
        s[0] = pe(s[0], o.height), s[1] = pe(s[1], o.height);
        var u = o.height - s[0] - s[1];
        yL(n, r, u);
      } else {
        s[0] = pe(s[0], o.width), s[1] = pe(s[1], o.width);
        var c = o.width - s[0] - s[1];
        yL(n, r, c);
      }
      n.setLayout("layoutInfo", a);
    });
  }
  function yL(t, e, r) {
    if (t.count()) for (var n = e.coordinateSystem, i = e.getLayerSeries(), a = t.mapDimension("single"), o = t.mapDimension("value"), s = oe(i, function(g) {
      return oe(g.indices, function(m) {
        var y = n.dataToPoint(t.get(a, m));
        return y[1] = t.get(o, m), y;
      });
    }), l = tfe(s), u = l.y0, c = r / l.max, h = i.length, f = i[0].indices.length, d, p = 0; p < f; ++p) {
      d = u[p] * c, t.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: d,
        y: s[0][p][1] * c
      });
      for (var v = 1; v < h; ++v) d += s[v - 1][p][1] * c, t.setItemLayout(i[v].indices[p], {
        layerIndex: v,
        x: s[v][p][0],
        y0: d,
        y: s[v][p][1] * c
      });
    }
  }
  function tfe(t) {
    for (var e = t.length, r = t[0].length, n = [], i = [], a = 0, o = 0; o < r; ++o) {
      for (var s = 0, l = 0; l < e; ++l) s += t[l][o][1];
      s > a && (a = s), n.push(s);
    }
    for (var u = 0; u < r; ++u) i[u] = (a - n[u]) / 2;
    a = 0;
    for (var c = 0; c < r; ++c) {
      var h = n[c] + i[c];
      h > a && (a = h);
    }
    return {
      y0: i,
      max: a
    };
  }
  function rfe(t) {
    t.registerChartView(Zhe), t.registerSeriesModel(Jhe), t.registerLayout(efe), t.registerProcessor(Ud("themeRiver"));
  }
  var nfe = 2, ife = 4, _L = function(t) {
    K(e, t);
    function e(r, n, i, a) {
      var o = t.call(this) || this;
      o.z2 = nfe, o.textConfig = {
        inside: true
      }, Ge(o).seriesIndex = n.seriesIndex;
      var s = new bt({
        z2: ife,
        silent: r.getModel().get([
          "label",
          "silent"
        ])
      });
      return o.setTextContent(s), o.updateData(true, r, n, i, a), o;
    }
    return e.prototype.updateData = function(r, n, i, a, o) {
      this.node = n, n.piece = this, i = i || this._seriesModel, a = a || this._ecModel;
      var s = this;
      Ge(s).dataIndex = n.dataIndex;
      var l = n.getModel(), u = l.getModel("emphasis"), c = n.getLayout(), h = te({}, c);
      h.label = null;
      var f = n.getVisual("style");
      f.lineJoin = "bevel";
      var d = n.getVisual("decal");
      d && (f.decal = bc(d, o));
      var p = Dl(l.getModel("itemStyle"), h, true);
      te(h, p), $(xn, function(y) {
        var _ = s.ensureState(y), b = l.getModel([
          y,
          "itemStyle"
        ]);
        _.style = b.getItemStyle();
        var w = Dl(b, h);
        w && (_.shape = w);
      }), r ? (s.setShape(h), s.shape.r = c.r0, er(s, {
        shape: {
          r: c.r
        }
      }, i, n.dataIndex)) : (wt(s, {
        shape: h
      }, i), Ki(s)), s.useStyle(f), this._updateLabel(i);
      var v = l.getShallow("cursor");
      v && s.attr("cursor", v), this._seriesModel = i || this._seriesModel, this._ecModel = a || this._ecModel;
      var g = u.get("focus"), m = g === "relative" ? Vf(n.getAncestorsIndices(), n.getDescendantIndices()) : g === "ancestor" ? n.getAncestorsIndices() : g === "descendant" ? n.getDescendantIndices() : g;
      ir(this, m, u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(r) {
      var n = this, i = this.node.getModel(), a = i.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), h = this, f = h.getTextContent(), d = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, v = a.get("show") && !(p != null && Math.abs(s) < p);
      f.ignore = !v, $(qf, function(m) {
        var y = m === "normal" ? i.getModel("label") : i.getModel([
          m,
          "label"
        ]), _ = m === "normal", b = _ ? f : f.ensureState(m), w = r.getFormattedLabel(d, m);
        _ && (w = w || n.node.name), b.style = Yt(y, {}, null, m !== "normal", true), w && (b.style.text = w);
        var x = y.get("show");
        x != null && !_ && (b.ignore = !x);
        var T = g(y, "position"), A = _ ? h : h.states[m], I = A.style.fill;
        A.textConfig = {
          outsideFill: y.get("color") === "inherit" ? I : null,
          inside: T !== "outside"
        };
        var M, k = g(y, "distance") || 0, B = g(y, "align"), L = g(y, "rotate"), z = Math.PI * 0.5, F = Math.PI * 1.5, E = Wn(L === "tangential" ? Math.PI / 2 - l : l), O = E > z && !Uf(E - z) && E < F;
        T === "outside" ? (M = o.r + k, B = O ? "right" : "left") : !B || B === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? M = 0 : M = (o.r + o.r0) / 2, B = "center") : B === "left" ? (M = o.r0 + k, B = O ? "right" : "left") : B === "right" && (M = o.r - k, B = O ? "left" : "right"), b.style.align = B, b.style.verticalAlign = g(y, "verticalAlign") || "middle", b.x = M * u + o.cx, b.y = M * c + o.cy;
        var N = 0;
        L === "radial" ? N = Wn(-l) + (O ? Math.PI : 0) : L === "tangential" ? N = Wn(Math.PI / 2 - l) + (O ? Math.PI : 0) : xt(L) && (N = L * Math.PI / 180), b.rotation = Wn(N);
      });
      function g(m, y) {
        var _ = m.get(y);
        return _ ?? a.get(y);
      }
      f.dirtyStyle();
    }, e;
  }(wn), Tw = "sunburstRootToNode", bL = "sunburstHighlight", afe = "sunburstUnhighlight";
  function ofe(t) {
    t.registerAction({
      type: Tw,
      update: "updateView"
    }, function(e, r) {
      r.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: e
      }, n);
      function n(i, a) {
        var o = sd(e, [
          Tw
        ], i);
        if (o) {
          var s = i.getViewRoot();
          s && (e.direction = l2(s, o.node) ? "rollUp" : "drillDown"), i.resetViewRoot(o.node);
        }
      }
    }), t.registerAction({
      type: bL,
      update: "none"
    }, function(e, r, n) {
      e = te({}, e), r.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: e
      }, i);
      function i(a) {
        var o = sd(e, [
          bL
        ], a);
        o && (e.dataIndex = o.node.dataIndex);
      }
      n.dispatchAction(te(e, {
        type: "highlight"
      }));
    }), t.registerAction({
      type: afe,
      update: "updateView"
    }, function(e, r, n) {
      e = te({}, e), n.dispatchAction(te(e, {
        type: "downplay"
      }));
    });
  }
  var sfe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i, a) {
      var o = this;
      this.seriesModel = r, this.api = i, this.ecModel = n;
      var s = r.getData(), l = s.tree.root, u = r.getViewRoot(), c = this.group, h = r.get("renderLabelForZeroData"), f = [];
      u.eachNode(function(y) {
        f.push(y);
      });
      var d = this._oldChildren || [];
      p(f, d), m(l, u), this._initEvents(), this._oldChildren = f;
      function p(y, _) {
        if (y.length === 0 && _.length === 0) return;
        new vo(_, y, b, b).add(w).update(w).remove(Ye(w, null)).execute();
        function b(x) {
          return x.getId();
        }
        function w(x, T) {
          var A = x == null ? null : y[x], I = T == null ? null : _[T];
          v(A, I);
        }
      }
      function v(y, _) {
        if (!h && y && !y.getValue() && (y = null), y !== l && _ !== l) {
          if (_ && _.piece) y ? (_.piece.updateData(false, y, r, n, i), s.setItemGraphicEl(y.dataIndex, _.piece)) : g(_);
          else if (y) {
            var b = new _L(y, r, n, i);
            c.add(b), s.setItemGraphicEl(y.dataIndex, b);
          }
        }
      }
      function g(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function m(y, _) {
        _.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(false, y, r, n, i) : (o.virtualPiece = new _L(y, r, n, i), c.add(o.virtualPiece)), _.piece.off("click"), o.virtualPiece.on("click", function(b) {
          o._rootToNode(_.parentNode);
        })) : o.virtualPiece && (c.remove(o.virtualPiece), o.virtualPiece = null);
      }
    }, e.prototype._initEvents = function() {
      var r = this;
      this.group.off("click"), this.group.on("click", function(n) {
        var i = false, a = r.seriesModel.getViewRoot();
        a.eachNode(function(o) {
          if (!i && o.piece && o.piece === n.target) {
            var s = o.getModel().get("nodeClick");
            if (s === "rootToNode") r._rootToNode(o);
            else if (s === "link") {
              var l = o.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", true) || "_blank";
                Ng(u, c);
              }
            }
            i = true;
          }
        });
      });
    }, e.prototype._rootToNode = function(r) {
      r !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: Tw,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r
      });
    }, e.prototype.containPoint = function(r, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = r[0] - a.cx, s = r[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "sunburst", e;
  }(Ft), lfe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.ignoreStyleOnData = true, r;
    }
    return e.prototype.getInitialData = function(r, n) {
      var i = {
        name: r.name,
        children: r.data
      };
      rH(i);
      var a = this._levelModels = oe(r.levels || [], function(l) {
        return new kt(l, this, n);
      }, this), o = s2.createTree(i, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var h = o.getNodeByDataIndex(c), f = a[h.depth];
          return f && (u.parentModel = f), u;
        });
      }
      return o.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.getDataParams = function(r) {
      var n = t.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treePathInfo = gy(i, this), n;
    }, e.prototype.getLevelModel = function(r) {
      return this._levelModels && this._levelModels[r.depth];
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(r) {
      r ? this._viewRoot = r : r = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!r || r !== n && !n.contains(r)) && (this._viewRoot = n);
    }, e.prototype.enableAriaDecal = function() {
      sW(this);
    }, e.type = "series.sunburst", e.defaultOption = {
      z: 2,
      center: [
        "50%",
        "50%"
      ],
      radius: [
        0,
        "75%"
      ],
      clockwise: true,
      startAngle: 90,
      minAngle: 0,
      stillShowZeroSum: true,
      nodeClick: "rootToNode",
      renderLabelForZeroData: false,
      label: {
        rotate: "radial",
        show: true,
        opacity: 1,
        align: "center",
        position: "inside",
        distance: 5,
        silent: true
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      sort: "desc"
    }, e;
  }(Xt);
  function rH(t) {
    var e = 0;
    $(t.children, function(n) {
      rH(n);
      var i = n.value;
      ae(i) && (i = i[0]), e += i;
    });
    var r = t.value;
    ae(r) && (r = r[0]), (r == null || isNaN(r)) && (r = e), r < 0 && (r = 0), ae(t.value) ? t.value[0] = r : t.value = r;
  }
  var xL = Math.PI / 180;
  function ufe(t, e, r) {
    e.eachSeriesByType(t, function(n) {
      var i = n.get("center"), a = n.get("radius");
      ae(a) || (a = [
        0,
        a
      ]), ae(i) || (i = [
        i,
        i
      ]);
      var o = r.getWidth(), s = r.getHeight(), l = Math.min(o, s), u = pe(i[0], o), c = pe(i[1], s), h = pe(a[0], l / 2), f = pe(a[1], l / 2), d = -n.get("startAngle") * xL, p = n.get("minAngle") * xL, v = n.getData().tree.root, g = n.getViewRoot(), m = g.depth, y = n.get("sort");
      y != null && nH(g, y);
      var _ = 0;
      $(g.children, function(E) {
        !isNaN(E.getValue()) && _++;
      });
      var b = g.getValue(), w = Math.PI / (b || _) * 2, x = g.depth > 0, T = g.height - (x ? -1 : 1), A = (f - h) / (T || 1), I = n.get("clockwise"), M = n.get("stillShowZeroSum"), k = I ? 1 : -1, B = function(E, O) {
        if (E) {
          var N = O;
          if (E !== v) {
            var V = E.getValue(), H = b === 0 && M ? w : V * w;
            H < p && (H = p), N = O + k * H;
            var G = E.depth - m - (x ? -1 : 1), Y = h + A * G, U = h + A * (G + 1), Z = n.getLevelModel(E);
            if (Z) {
              var ee = Z.get("r0", true), we = Z.get("r", true), Te = Z.get("radius", true);
              Te != null && (ee = Te[0], we = Te[1]), ee != null && (Y = pe(ee, l / 2)), we != null && (U = pe(we, l / 2));
            }
            E.setLayout({
              angle: H,
              startAngle: O,
              endAngle: N,
              clockwise: I,
              cx: u,
              cy: c,
              r0: Y,
              r: U
            });
          }
          if (E.children && E.children.length) {
            var le = 0;
            $(E.children, function(ue) {
              le += B(ue, O + le);
            });
          }
          return N - O;
        }
      };
      if (x) {
        var L = h, z = h + A, F = Math.PI * 2;
        v.setLayout({
          angle: F,
          startAngle: d,
          endAngle: d + F,
          clockwise: I,
          cx: u,
          cy: c,
          r0: L,
          r: z
        });
      }
      B(g, d);
    });
  }
  function nH(t, e) {
    var r = t.children || [];
    t.children = cfe(r, e), r.length && $(t.children, function(n) {
      nH(n, e);
    });
  }
  function cfe(t, e) {
    if (De(e)) {
      var r = oe(t, function(i, a) {
        var o = i.getValue();
        return {
          params: {
            depth: i.depth,
            height: i.height,
            dataIndex: i.dataIndex,
            getValue: function() {
              return o;
            }
          },
          index: a
        };
      });
      return r.sort(function(i, a) {
        return e(i.params, a.params);
      }), oe(r, function(i) {
        return t[i.index];
      });
    } else {
      var n = e === "asc";
      return t.sort(function(i, a) {
        var o = (i.getValue() - a.getValue()) * (n ? 1 : -1);
        return o === 0 ? (i.dataIndex - a.dataIndex) * (n ? -1 : 1) : o;
      });
    }
  }
  function hfe(t) {
    var e = {};
    function r(n, i, a) {
      for (var o = n; o && o.depth > 1; ) o = o.parentNode;
      var s = i.getColorFromPalette(o.name || o.dataIndex + "", e);
      return n.depth > 1 && me(s) && (s = hx(s, (n.depth - 1) / (a - 1) * 0.5)), s;
    }
    t.eachSeriesByType("sunburst", function(n) {
      var i = n.getData(), a = i.tree;
      a.eachNode(function(o) {
        var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
        l.fill || (l.fill = r(o, n, a.root.height));
        var u = i.ensureUniqueItemVisual(o.dataIndex, "style");
        te(u, l);
      });
    });
  }
  function ffe(t) {
    t.registerChartView(sfe), t.registerSeriesModel(lfe), t.registerLayout(Ye(ufe, "sunburst")), t.registerProcessor(Ye(Ud, "sunburst")), t.registerVisual(hfe), ofe(t);
  }
  var wL = {
    color: "fill",
    borderColor: "stroke"
  }, dfe = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1
  }, oo = _t(), pfe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", true), this.currentZ = this.get("z", true);
    }, e.prototype.getInitialData = function(r, n) {
      return So(null, this);
    }, e.prototype.getDataParams = function(r, n, i) {
      var a = t.prototype.getDataParams.call(this, r, n);
      return i && (a.info = oo(i).info), a;
    }, e.type = "series.custom", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      clip: false
    }, e;
  }(Xt);
  function vfe(t, e) {
    return e = e || [
      0,
      0
    ], oe([
      "x",
      "y"
    ], function(r, n) {
      var i = this.getAxis(r), a = e[n], o = t[n] / 2;
      return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(a - o) - i.dataToCoord(a + o));
    }, this);
  }
  function gfe(t) {
    var e = t.master.getRect();
    return {
      coordSys: {
        type: "cartesian2d",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      api: {
        coord: function(r) {
          return t.dataToPoint(r);
        },
        size: _e(vfe, t)
      }
    };
  }
  function mfe(t, e) {
    return e = e || [
      0,
      0
    ], oe([
      0,
      1
    ], function(r) {
      var n = e[r], i = t[r] / 2, a = [], o = [];
      return a[r] = n - i, o[r] = n + i, a[1 - r] = o[1 - r] = e[1 - r], Math.abs(this.dataToPoint(a)[r] - this.dataToPoint(o)[r]);
    }, this);
  }
  function yfe(t) {
    var e = t.getBoundingRect();
    return {
      coordSys: {
        type: "geo",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height,
        zoom: t.getZoom()
      },
      api: {
        coord: function(r) {
          return t.dataToPoint(r);
        },
        size: _e(mfe, t)
      }
    };
  }
  function _fe(t, e) {
    var r = this.getAxis(), n = e instanceof Array ? e[0] : e, i = (t instanceof Array ? t[0] : t) / 2;
    return r.type === "category" ? r.getBandWidth() : Math.abs(r.dataToCoord(n - i) - r.dataToCoord(n + i));
  }
  function bfe(t) {
    var e = t.getRect();
    return {
      coordSys: {
        type: "singleAxis",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      api: {
        coord: function(r) {
          return t.dataToPoint(r);
        },
        size: _e(_fe, t)
      }
    };
  }
  function xfe(t, e) {
    return e = e || [
      0,
      0
    ], oe([
      "Radius",
      "Angle"
    ], function(r, n) {
      var i = "get" + r + "Axis", a = this[i](), o = e[n], s = t[n] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
      return r === "Angle" && (l = l * Math.PI / 180), l;
    }, this);
  }
  function wfe(t) {
    var e = t.getRadiusAxis(), r = t.getAngleAxis(), n = e.getExtent();
    return n[0] > n[1] && n.reverse(), {
      coordSys: {
        type: "polar",
        cx: t.cx,
        cy: t.cy,
        r: n[1],
        r0: n[0]
      },
      api: {
        coord: function(i) {
          var a = e.dataToRadius(i[0]), o = r.dataToAngle(i[1]), s = t.coordToPoint([
            a,
            o
          ]);
          return s.push(a, o * Math.PI / 180), s;
        },
        size: _e(xfe, t)
      }
    };
  }
  function Sfe(t) {
    var e = t.getRect(), r = t.getRangeInfo();
    return {
      coordSys: {
        type: "calendar",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height,
        cellWidth: t.getCellWidth(),
        cellHeight: t.getCellHeight(),
        rangeInfo: {
          start: r.start,
          end: r.end,
          weeks: r.weeks,
          dayCount: r.allDay
        }
      },
      api: {
        coord: function(n, i) {
          return t.dataToPoint(n, i);
        }
      }
    };
  }
  function iH(t, e, r, n) {
    return t && (t.legacy || t.legacy !== false && !r && !n && e !== "tspan" && (e === "text" || xe(t, "text")));
  }
  function aH(t, e, r) {
    var n = t, i, a, o;
    if (e === "text") o = n;
    else {
      o = {}, xe(n, "text") && (o.text = n.text), xe(n, "rich") && (o.rich = n.rich), xe(n, "textFill") && (o.fill = n.textFill), xe(n, "textStroke") && (o.stroke = n.textStroke), xe(n, "fontFamily") && (o.fontFamily = n.fontFamily), xe(n, "fontSize") && (o.fontSize = n.fontSize), xe(n, "fontStyle") && (o.fontStyle = n.fontStyle), xe(n, "fontWeight") && (o.fontWeight = n.fontWeight), a = {
        type: "text",
        style: o,
        silent: true
      }, i = {};
      var s = xe(n, "textPosition");
      r ? i.position = s ? n.textPosition : "inside" : s && (i.position = n.textPosition), xe(n, "textPosition") && (i.position = n.textPosition), xe(n, "textOffset") && (i.offset = n.textOffset), xe(n, "textRotation") && (i.rotation = n.textRotation), xe(n, "textDistance") && (i.distance = n.textDistance);
    }
    return SL(o, t), $(o.rich, function(l) {
      SL(l, l);
    }), {
      textConfig: i,
      textContent: a
    };
  }
  function SL(t, e) {
    e && (e.font = e.textFont || e.font, xe(e, "textStrokeWidth") && (t.lineWidth = e.textStrokeWidth), xe(e, "textAlign") && (t.align = e.textAlign), xe(e, "textVerticalAlign") && (t.verticalAlign = e.textVerticalAlign), xe(e, "textLineHeight") && (t.lineHeight = e.textLineHeight), xe(e, "textWidth") && (t.width = e.textWidth), xe(e, "textHeight") && (t.height = e.textHeight), xe(e, "textBackgroundColor") && (t.backgroundColor = e.textBackgroundColor), xe(e, "textPadding") && (t.padding = e.textPadding), xe(e, "textBorderColor") && (t.borderColor = e.textBorderColor), xe(e, "textBorderWidth") && (t.borderWidth = e.textBorderWidth), xe(e, "textBorderRadius") && (t.borderRadius = e.textBorderRadius), xe(e, "textBoxShadowColor") && (t.shadowColor = e.textBoxShadowColor), xe(e, "textBoxShadowBlur") && (t.shadowBlur = e.textBoxShadowBlur), xe(e, "textBoxShadowOffsetX") && (t.shadowOffsetX = e.textBoxShadowOffsetX), xe(e, "textBoxShadowOffsetY") && (t.shadowOffsetY = e.textBoxShadowOffsetY));
  }
  function TL(t, e, r) {
    var n = t;
    n.textPosition = n.textPosition || r.position || "inside", r.offset != null && (n.textOffset = r.offset), r.rotation != null && (n.textRotation = r.rotation), r.distance != null && (n.textDistance = r.distance);
    var i = n.textPosition.indexOf("inside") >= 0, a = t.fill || "#000";
    CL(n, e);
    var o = n.textFill == null;
    return i ? o && (n.textFill = r.insideFill || "#fff", !n.textStroke && r.insideStroke && (n.textStroke = r.insideStroke), !n.textStroke && (n.textStroke = a), n.textStrokeWidth == null && (n.textStrokeWidth = 2)) : (o && (n.textFill = t.fill || r.outsideFill || "#000"), !n.textStroke && r.outsideStroke && (n.textStroke = r.outsideStroke)), n.text = e.text, n.rich = e.rich, $(e.rich, function(s) {
      CL(s, s);
    }), n;
  }
  function CL(t, e) {
    e && (xe(e, "fill") && (t.textFill = e.fill), xe(e, "stroke") && (t.textStroke = e.fill), xe(e, "lineWidth") && (t.textStrokeWidth = e.lineWidth), xe(e, "font") && (t.font = e.font), xe(e, "fontStyle") && (t.fontStyle = e.fontStyle), xe(e, "fontWeight") && (t.fontWeight = e.fontWeight), xe(e, "fontSize") && (t.fontSize = e.fontSize), xe(e, "fontFamily") && (t.fontFamily = e.fontFamily), xe(e, "align") && (t.textAlign = e.align), xe(e, "verticalAlign") && (t.textVerticalAlign = e.verticalAlign), xe(e, "lineHeight") && (t.textLineHeight = e.lineHeight), xe(e, "width") && (t.textWidth = e.width), xe(e, "height") && (t.textHeight = e.height), xe(e, "backgroundColor") && (t.textBackgroundColor = e.backgroundColor), xe(e, "padding") && (t.textPadding = e.padding), xe(e, "borderColor") && (t.textBorderColor = e.borderColor), xe(e, "borderWidth") && (t.textBorderWidth = e.borderWidth), xe(e, "borderRadius") && (t.textBorderRadius = e.borderRadius), xe(e, "shadowColor") && (t.textBoxShadowColor = e.shadowColor), xe(e, "shadowBlur") && (t.textBoxShadowBlur = e.shadowBlur), xe(e, "shadowOffsetX") && (t.textBoxShadowOffsetX = e.shadowOffsetX), xe(e, "shadowOffsetY") && (t.textBoxShadowOffsetY = e.shadowOffsetY), xe(e, "textShadowColor") && (t.textShadowColor = e.textShadowColor), xe(e, "textShadowBlur") && (t.textShadowBlur = e.textShadowBlur), xe(e, "textShadowOffsetX") && (t.textShadowOffsetX = e.textShadowOffsetX), xe(e, "textShadowOffsetY") && (t.textShadowOffsetY = e.textShadowOffsetY));
  }
  var oH = {
    position: [
      "x",
      "y"
    ],
    scale: [
      "scaleX",
      "scaleY"
    ],
    origin: [
      "originX",
      "originY"
    ]
  }, AL = gt(oH);
  ka(La, function(t, e) {
    return t[e] = 1, t;
  }, {});
  La.join(", ");
  var nm = [
    "",
    "style",
    "shape",
    "extra"
  ], Cc = _t();
  function C2(t, e, r, n, i) {
    var a = t + "Animation", o = Gc(t, n, i) || {}, s = Cc(e).userDuring;
    return o.duration > 0 && (o.during = s ? _e(Mfe, {
      el: e,
      userDuring: s
    }) : null, o.setToFinal = true, o.scope = t), te(o, r[a]), o;
  }
  function hg(t, e, r, n) {
    n = n || {};
    var i = n.dataIndex, a = n.isInit, o = n.clearStyle, s = r.isAnimationEnabled(), l = Cc(t), u = e.style;
    l.userDuring = e.during;
    var c = {}, h = {};
    if (Efe(t, e, h), ML("shape", e, h), ML("extra", e, h), !a && s && (Dfe(t, e, c), IL("shape", t, e, c), IL("extra", t, e, c), kfe(t, e, u, c)), h.style = u, Tfe(t, h, o), Afe(t, e), s) if (a) {
      var f = {};
      $(nm, function(p) {
        var v = p ? e[p] : e;
        v && v.enterFrom && (p && (f[p] = f[p] || {}), te(p ? f[p] : f, v.enterFrom));
      });
      var d = C2("enter", t, e, r, i);
      d.duration > 0 && t.animateFrom(f, d);
    } else Cfe(t, e, i || 0, r, c);
    sH(t, e), u ? t.dirty() : t.markRedraw();
  }
  function sH(t, e) {
    for (var r = Cc(t).leaveToProps, n = 0; n < nm.length; n++) {
      var i = nm[n], a = i ? e[i] : e;
      a && a.leaveTo && (r || (r = Cc(t).leaveToProps = {}), i && (r[i] = r[i] || {}), te(i ? r[i] : r, a.leaveTo));
    }
  }
  function _y(t, e, r, n) {
    if (t) {
      var i = t.parent, a = Cc(t).leaveToProps;
      if (a) {
        var o = C2("update", t, e, r, 0);
        o.done = function() {
          i.remove(t);
        }, t.animateTo(a, o);
      } else i.remove(t);
    }
  }
  function Vl(t) {
    return t === "all";
  }
  function Tfe(t, e, r) {
    var n = e.style;
    if (!t.isGroup && n) {
      if (r) {
        t.useStyle({});
        for (var i = t.animators, a = 0; a < i.length; a++) {
          var o = i[a];
          o.targetName === "style" && o.changeTarget(t.style);
        }
      }
      t.setStyle(n);
    }
    e && (e.style = null, e && t.attr(e), e.style = n);
  }
  function Cfe(t, e, r, n, i) {
    if (i) {
      var a = C2("update", t, e, n, r);
      a.duration > 0 && t.animateFrom(i, a);
    }
  }
  function Afe(t, e) {
    xe(e, "silent") && (t.silent = e.silent), xe(e, "ignore") && (t.ignore = e.ignore), t instanceof bi && xe(e, "invisible") && (t.invisible = e.invisible), t instanceof st && xe(e, "autoBatch") && (t.autoBatch = e.autoBatch);
  }
  var da = {}, Ife = {
    setTransform: function(t, e) {
      return da.el[t] = e, this;
    },
    getTransform: function(t) {
      return da.el[t];
    },
    setShape: function(t, e) {
      var r = da.el, n = r.shape || (r.shape = {});
      return n[t] = e, r.dirtyShape && r.dirtyShape(), this;
    },
    getShape: function(t) {
      var e = da.el.shape;
      if (e) return e[t];
    },
    setStyle: function(t, e) {
      var r = da.el, n = r.style;
      return n && (n[t] = e, r.dirtyStyle && r.dirtyStyle()), this;
    },
    getStyle: function(t) {
      var e = da.el.style;
      if (e) return e[t];
    },
    setExtra: function(t, e) {
      var r = da.el.extra || (da.el.extra = {});
      return r[t] = e, this;
    },
    getExtra: function(t) {
      var e = da.el.extra;
      if (e) return e[t];
    }
  };
  function Mfe() {
    var t = this, e = t.el;
    if (e) {
      var r = Cc(e).userDuring, n = t.userDuring;
      if (r !== n) {
        t.el = t.userDuring = null;
        return;
      }
      da.el = e, n(Ife);
    }
  }
  function IL(t, e, r, n) {
    var i = r[t];
    if (i) {
      var a = e[t], o;
      if (a) {
        var s = r.transition, l = i.transition;
        if (l) if (!o && (o = n[t] = {}), Vl(l)) te(o, a);
        else for (var u = Ot(l), c = 0; c < u.length; c++) {
          var h = u[c], f = a[h];
          o[h] = f;
        }
        else if (Vl(s) || et(s, t) >= 0) {
          !o && (o = n[t] = {});
          for (var d = gt(a), c = 0; c < d.length; c++) {
            var h = d[c], f = a[h];
            Pfe(i[h], f) && (o[h] = f);
          }
        }
      }
    }
  }
  function ML(t, e, r) {
    var n = e[t];
    if (n) for (var i = r[t] = {}, a = gt(n), o = 0; o < a.length; o++) {
      var s = a[o];
      i[s] = bf(n[s]);
    }
  }
  function Dfe(t, e, r) {
    for (var n = e.transition, i = Vl(n) ? La : Ot(n || []), a = 0; a < i.length; a++) {
      var o = i[a];
      if (!(o === "style" || o === "shape" || o === "extra")) {
        var s = t[o];
        r[o] = s;
      }
    }
  }
  function Efe(t, e, r) {
    for (var n = 0; n < AL.length; n++) {
      var i = AL[n], a = oH[i], o = e[i];
      o && (r[a[0]] = o[0], r[a[1]] = o[1]);
    }
    for (var n = 0; n < La.length; n++) {
      var s = La[n];
      e[s] != null && (r[s] = e[s]);
    }
  }
  function kfe(t, e, r, n) {
    if (r) {
      var i = t.style, a;
      if (i) {
        var o = r.transition, s = e.transition;
        if (o && !Vl(o)) {
          var l = Ot(o);
          !a && (a = n.style = {});
          for (var u = 0; u < l.length; u++) {
            var c = l[u], h = i[c];
            a[c] = h;
          }
        } else if (t.getAnimationStyleProps && (Vl(s) || Vl(o) || et(s, "style") >= 0)) {
          var f = t.getAnimationStyleProps(), d = f ? f.style : null;
          if (d) {
            !a && (a = n.style = {});
            for (var p = gt(r), u = 0; u < p.length; u++) {
              var c = p[u];
              if (d[c]) {
                var h = i[c];
                a[c] = h;
              }
            }
          }
        }
      }
    }
  }
  function Pfe(t, e) {
    return on(t) ? t !== e : t != null && isFinite(t);
  }
  var lH = _t(), Lfe = [
    "percent",
    "easing",
    "shape",
    "style",
    "extra"
  ];
  function uH(t) {
    t.stopAnimation("keyframe"), t.attr(lH(t));
  }
  function im(t, e, r) {
    if (!(!r.isAnimationEnabled() || !e)) {
      if (ae(e)) {
        $(e, function(s) {
          im(t, s, r);
        });
        return;
      }
      var n = e.keyframes, i = e.duration;
      if (r && i == null) {
        var a = Gc("enter", r, 0);
        i = a && a.duration;
      }
      if (!(!n || !i)) {
        var o = lH(t);
        $(nm, function(s) {
          if (!(s && !t[s])) {
            var l;
            n.sort(function(u, c) {
              return u.percent - c.percent;
            }), $(n, function(u) {
              var c = t.animators, h = s ? u[s] : u;
              if (h) {
                var f = gt(h);
                if (s || (f = Dt(f, function(v) {
                  return et(Lfe, v) < 0;
                })), !!f.length) {
                  l || (l = t.animate(s, e.loop, true), l.scope = "keyframe");
                  for (var d = 0; d < c.length; d++) c[d] !== l && c[d].targetName === l.targetName && c[d].stopTracks(f);
                  s && (o[s] = o[s] || {});
                  var p = s ? o[s] : o;
                  $(f, function(v) {
                    p[v] = ((s ? t[s] : t) || {})[v];
                  }), l.whenWithKeys(i * u.percent, h, f, u.easing);
                }
              }
            }), l && l.delay(e.delay || 0).duration(i).start(e.easing);
          }
        });
      }
    }
  }
  var so = "emphasis", rs = "normal", A2 = "blur", I2 = "select", ms = [
    rs,
    so,
    A2,
    I2
  ], q_ = {
    normal: [
      "itemStyle"
    ],
    emphasis: [
      so,
      "itemStyle"
    ],
    blur: [
      A2,
      "itemStyle"
    ],
    select: [
      I2,
      "itemStyle"
    ]
  }, X_ = {
    normal: [
      "label"
    ],
    emphasis: [
      so,
      "label"
    ],
    blur: [
      A2,
      "label"
    ],
    select: [
      I2,
      "label"
    ]
  }, $fe = [
    "x",
    "y"
  ], Rfe = "e\0\0", ii = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {}
  }, Ofe = {
    cartesian2d: gfe,
    geo: yfe,
    single: bfe,
    polar: wfe,
    calendar: Sfe
  };
  function Cw(t) {
    return t instanceof st;
  }
  function Aw(t) {
    return t instanceof bi;
  }
  function Nfe(t, e) {
    e.copyTransform(t), Aw(e) && Aw(t) && (e.setStyle(t.style), e.z = t.z, e.z2 = t.z2, e.zlevel = t.zlevel, e.invisible = t.invisible, e.ignore = t.ignore, Cw(e) && Cw(t) && e.setShape(t.shape));
  }
  var Bfe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i, a) {
      this._progressiveEls = null;
      var o = this._data, s = r.getData(), l = this.group, u = DL(r, s, n, i);
      o || l.removeAll(), s.diff(o).add(function(h) {
        j_(i, null, h, u(h, a), r, l, s);
      }).remove(function(h) {
        var f = o.getItemGraphicEl(h);
        f && _y(f, oo(f).option, r);
      }).update(function(h, f) {
        var d = o.getItemGraphicEl(f);
        j_(i, d, h, u(h, a), r, l, s);
      }).execute();
      var c = r.get("clip", true) ? Wd(r.coordinateSystem, false, r) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, e.prototype.incrementalPrepareRender = function(r, n, i) {
      this.group.removeAll(), this._data = null;
    }, e.prototype.incrementalRender = function(r, n, i, a, o) {
      var s = n.getData(), l = DL(n, s, i, a), u = this._progressiveEls = [];
      function c(d) {
        d.isGroup || (d.incremental = true, d.ensureState("emphasis").hoverLayer = true);
      }
      for (var h = r.start; h < r.end; h++) {
        var f = j_(null, null, h, l(h, o), n, this.group, s);
        f && (f.traverse(c), u.push(f));
      }
    }, e.prototype.eachRendered = function(r) {
      bs(this._progressiveEls || this.group, r);
    }, e.prototype.filterForExposedEvent = function(r, n, i, a) {
      var o = n.element;
      if (o == null || i.name === o) return true;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; ) if (i.name === o) return true;
      return false;
    }, e.type = "custom", e;
  }(Ft);
  function M2(t) {
    var e = t.type, r;
    if (e === "path") {
      var n = t.shape, i = n.width != null && n.height != null ? {
        x: n.x || 0,
        y: n.y || 0,
        width: n.width,
        height: n.height
      } : null, a = fH(n);
      r = jm(a, null, i, n.layout || "center"), oo(r).customPathData = a;
    } else if (e === "image") r = new Gr({}), oo(r).customImagePath = t.style.image;
    else if (e === "text") r = new bt({});
    else if (e === "group") r = new Be();
    else {
      if (e === "compoundPath") throw new Error('"compoundPath" is not supported yet.');
      var o = gT(e);
      if (!o) {
        var s = "";
        It(s);
      }
      r = new o();
    }
    return oo(r).customGraphicType = e, r.name = t.name, r.z2EmphasisLift = 1, r.z2SelectLift = 1, r;
  }
  function D2(t, e, r, n, i, a, o) {
    uH(e);
    var s = i && i.normal.cfg;
    s && e.setTextConfig(s), n && n.transition == null && (n.transition = $fe);
    var l = n && n.style;
    if (l) {
      if (e.type === "text") {
        var u = l;
        xe(u, "textFill") && (u.fill = u.textFill), xe(u, "textStroke") && (u.stroke = u.textStroke);
      }
      var c = void 0, h = Cw(e) ? l.decal : null;
      t && h && (h.dirty = true, c = bc(h, t)), l.__decalPattern = c;
    }
    if (Aw(e) && l) {
      var c = l.__decalPattern;
      c && (l.decal = c);
    }
    hg(e, n, a, {
      dataIndex: r,
      isInit: o,
      clearStyle: true
    }), im(e, n.keyframeAnimation, a);
  }
  function cH(t, e, r, n, i) {
    var a = e.isGroup ? null : e, o = i && i[t].cfg;
    if (a) {
      var s = a.ensureState(t);
      if (n === false) {
        var l = a.getState(t);
        l && (l.style = null);
      } else s.style = n || null;
      o && (s.textConfig = o), Xl(a);
    }
  }
  function zfe(t, e, r) {
    if (!t.isGroup) {
      var n = t, i = r.currentZ, a = r.currentZLevel;
      n.z = i, n.zlevel = a;
      var o = e.z2;
      o != null && (n.z2 = o || 0);
      for (var s = 0; s < ms.length; s++) Ffe(n, e, ms[s]);
    }
  }
  function Ffe(t, e, r) {
    var n = r === rs, i = n ? e : am(e, r), a = i ? i.z2 : null, o;
    a != null && (o = n ? t : t.ensureState(r), o.z2 = a || 0);
  }
  function DL(t, e, r, n) {
    var i = t.get("renderItem"), a = t.coordinateSystem, o = {};
    a && (o = a.prepareCustoms ? a.prepareCustoms(a) : Ofe[a.type](a));
    for (var s = Ee({
      getWidth: n.getWidth,
      getHeight: n.getHeight,
      getZr: n.getZr,
      getDevicePixelRatio: n.getDevicePixelRatio,
      value: b,
      style: x,
      ordinalRawValue: w,
      styleEmphasis: T,
      visual: M,
      barLayout: k,
      currentSeriesIndices: B,
      font: L
    }, o.api || {}), l = {
      context: {},
      seriesId: t.id,
      seriesName: t.name,
      seriesIndex: t.seriesIndex,
      coordSys: o.coordSys,
      dataInsideLength: e.count(),
      encode: Vfe(t.getData())
    }, u, c, h = {}, f = {}, d = {}, p = {}, v = 0; v < ms.length; v++) {
      var g = ms[v];
      d[g] = t.getModel(q_[g]), p[g] = t.getModel(X_[g]);
    }
    function m(z) {
      return z === u ? c || (c = e.getItemModel(z)) : e.getItemModel(z);
    }
    function y(z, F) {
      return e.hasItemOption ? z === u ? h[F] || (h[F] = m(z).getModel(q_[F])) : m(z).getModel(q_[F]) : d[F];
    }
    function _(z, F) {
      return e.hasItemOption ? z === u ? f[F] || (f[F] = m(z).getModel(X_[F])) : m(z).getModel(X_[F]) : p[F];
    }
    return function(z, F) {
      return u = z, c = null, h = {}, f = {}, i && i(Ee({
        dataIndexInside: z,
        dataIndex: e.getRawIndex(z),
        actionType: F ? F.type : null
      }, l), s);
    };
    function b(z, F) {
      return F == null && (F = u), e.getStore().get(e.getDimensionIndex(z || 0), F);
    }
    function w(z, F) {
      F == null && (F = u), z = z || 0;
      var E = e.getDimensionInfo(z);
      if (!E) {
        var O = e.getDimensionIndex(z);
        return O >= 0 ? e.getStore().get(O, F) : void 0;
      }
      var N = e.get(E.name, F), V = E && E.ordinalMeta;
      return V ? V.categories[N] : N;
    }
    function x(z, F) {
      F == null && (F = u);
      var E = e.getItemVisual(F, "style"), O = E && E.fill, N = E && E.opacity, V = y(F, rs).getItemStyle();
      O != null && (V.fill = O), N != null && (V.opacity = N);
      var H = {
        inheritColor: me(O) ? O : "#000"
      }, G = _(F, rs), Y = Yt(G, null, H, false, true);
      Y.text = G.getShallow("show") ? We(t.getFormattedLabel(F, rs), wc(e, F)) : null;
      var U = Rg(G, H, false);
      return I(z, V), V = TL(V, Y, U), z && A(V, z), V.legacy = true, V;
    }
    function T(z, F) {
      F == null && (F = u);
      var E = y(F, so).getItemStyle(), O = _(F, so), N = Yt(O, null, null, true, true);
      N.text = O.getShallow("show") ? Aa(t.getFormattedLabel(F, so), t.getFormattedLabel(F, rs), wc(e, F)) : null;
      var V = Rg(O, null, true);
      return I(z, E), E = TL(E, N, V), z && A(E, z), E.legacy = true, E;
    }
    function A(z, F) {
      for (var E in F) xe(F, E) && (z[E] = F[E]);
    }
    function I(z, F) {
      z && (z.textFill && (F.textFill = z.textFill), z.textPosition && (F.textPosition = z.textPosition));
    }
    function M(z, F) {
      if (F == null && (F = u), xe(wL, z)) {
        var E = e.getItemVisual(F, "style");
        return E ? E[wL[z]] : null;
      }
      if (xe(dfe, z)) return e.getItemVisual(F, z);
    }
    function k(z) {
      if (a.type === "cartesian2d") {
        var F = a.getBaseAxis();
        return Ene(Ee({
          axis: F
        }, z));
      }
    }
    function B() {
      return r.getCurrentSeriesIndices();
    }
    function L(z) {
      return mT(z, r);
    }
  }
  function Vfe(t) {
    var e = {};
    return $(t.dimensions, function(r) {
      var n = t.getDimensionInfo(r);
      if (!n.isExtraCoord) {
        var i = n.coordDim, a = e[i] = e[i] || [];
        a[n.coordDimIndex] = t.getDimensionIndex(r);
      }
    }), e;
  }
  function j_(t, e, r, n, i, a, o) {
    if (!n) {
      a.remove(e);
      return;
    }
    var s = E2(t, e, r, n, i, a);
    return s && o.setItemGraphicEl(r, s), s && ir(s, n.focus, n.blurScope, n.emphasisDisabled), s;
  }
  function E2(t, e, r, n, i, a) {
    var o = -1, s = e;
    e && hH(e, n, i) && (o = et(a.childrenRef(), e), e = null);
    var l = !e, u = e;
    u ? u.clearStates() : (u = M2(n), s && Nfe(s, u)), n.morph === false ? u.disableMorphing = true : u.disableMorphing && (u.disableMorphing = false), ii.normal.cfg = ii.normal.conOpt = ii.emphasis.cfg = ii.emphasis.conOpt = ii.blur.cfg = ii.blur.conOpt = ii.select.cfg = ii.select.conOpt = null, ii.isLegacy = false, Wfe(u, r, n, i, l, ii), Gfe(u, r, n, i, l), D2(t, u, r, n, ii, i, l), xe(n, "info") && (oo(u).info = n.info);
    for (var c = 0; c < ms.length; c++) {
      var h = ms[c];
      if (h !== rs) {
        var f = am(n, h), d = k2(n, f, h);
        cH(h, u, f, d, ii);
      }
    }
    return zfe(u, n, i), n.type === "group" && Hfe(t, u, r, n, i), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
  }
  function hH(t, e, r) {
    var n = oo(t), i = e.type, a = e.shape, o = e.style;
    return r.isUniversalTransitionEnabled() || i != null && i !== n.customGraphicType || i === "path" && Xfe(a) && fH(a) !== n.customPathData || i === "image" && xe(o, "image") && o.image !== n.customImagePath;
  }
  function Gfe(t, e, r, n, i) {
    var a = r.clipPath;
    if (a === false) t && t.getClipPath() && t.removeClipPath();
    else if (a) {
      var o = t.getClipPath();
      o && hH(o, a, n) && (o = null), o || (o = M2(a), t.setClipPath(o)), D2(null, o, e, a, null, n, i);
    }
  }
  function Wfe(t, e, r, n, i, a) {
    if (!t.isGroup) {
      EL(r, null, a), EL(r, so, a);
      var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
      if (o != null || s != null || u != null || l != null) {
        var c = t.getTextContent();
        if (o === false) c && t.removeTextContent();
        else {
          o = a.normal.conOpt = o || {
            type: "text"
          }, c ? c.clearStates() : (c = M2(o), t.setTextContent(c)), D2(null, c, e, o, null, n, i);
          for (var h = o && o.style, f = 0; f < ms.length; f++) {
            var d = ms[f];
            if (d !== rs) {
              var p = a[d].conOpt;
              cH(d, c, p, k2(o, p, d), null);
            }
          }
          h ? c.dirty() : c.markRedraw();
        }
      }
    }
  }
  function EL(t, e, r) {
    var n = e ? am(t, e) : t, i = e ? k2(t, n, so) : t.style, a = t.type, o = n ? n.textConfig : null, s = t.textContent, l = s ? e ? am(s, e) : s : null;
    if (i && (r.isLegacy || iH(i, a, !!o, !!l))) {
      r.isLegacy = true;
      var u = aH(i, a, !e);
      !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
    }
    if (!e && l) {
      var c = l;
      !c.type && (c.type = "text");
    }
    var h = e ? r[e] : r.normal;
    h.cfg = o, h.conOpt = l;
  }
  function am(t, e) {
    return e ? t ? t[e] : null : t;
  }
  function k2(t, e, r) {
    var n = e && e.style;
    return n == null && r === so && t && (n = t.styleEmphasis), n;
  }
  function Hfe(t, e, r, n, i) {
    var a = n.children, o = a ? a.length : 0, s = n.$mergeChildren, l = s === "byName" || n.diffChildrenByName, u = s === false;
    if (!(!o && !l && !u)) {
      if (l) {
        Yfe({
          api: t,
          oldChildren: e.children() || [],
          newChildren: a || [],
          dataIndex: r,
          seriesModel: i,
          group: e
        });
        return;
      }
      u && e.removeAll();
      for (var c = 0; c < o; c++) {
        var h = a[c], f = e.childAt(c);
        h ? (h.ignore == null && (h.ignore = false), E2(t, f, r, h, i, e)) : f.ignore = true;
      }
      for (var d = e.childCount() - 1; d >= c; d--) {
        var p = e.childAt(d);
        Ufe(e, p, i);
      }
    }
  }
  function Ufe(t, e, r) {
    e && _y(e, oo(t).option, r);
  }
  function Yfe(t) {
    new vo(t.oldChildren, t.newChildren, kL, kL, t).add(PL).update(PL).remove(qfe).execute();
  }
  function kL(t, e) {
    var r = t && t.name;
    return r ?? Rfe + e;
  }
  function PL(t, e) {
    var r = this.context, n = t != null ? r.newChildren[t] : null, i = e != null ? r.oldChildren[e] : null;
    E2(r.api, i, r.dataIndex, n, r.seriesModel, r.group);
  }
  function qfe(t) {
    var e = this.context, r = e.oldChildren[t];
    r && _y(r, oo(r).option, e.seriesModel);
  }
  function fH(t) {
    return t && (t.pathData || t.d);
  }
  function Xfe(t) {
    return t && (xe(t, "pathData") || xe(t, "d"));
  }
  function jfe(t) {
    t.registerChartView(Bfe), t.registerSeriesModel(pfe);
  }
  var ml = _t(), LL = Oe, K_ = _e, P2 = function() {
    function t() {
      this._dragging = false, this.animationThreshold = 15;
    }
    return t.prototype.render = function(e, r, n, i) {
      var a = r.get("value"), o = r.get("status");
      if (this._axisModel = e, this._axisPointerModel = r, this._api = n, !(!i && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, e, r, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(e, r);
        if (!s) s = this._group = new Be(), this.createPointerEl(s, u, e, r), this.createLabelEl(s, u, e, r), n.getZr().add(s);
        else {
          var f = Ye($L, r, h);
          this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, r);
        }
        OL(s, r, true), this._renderHandle(a);
      }
    }, t.prototype.remove = function(e) {
      this.clear(e);
    }, t.prototype.dispose = function(e) {
      this.clear(e);
    }, t.prototype.determineAnimation = function(e, r) {
      var n = r.get("animation"), i = e.axis, a = i.type === "category", o = r.get("snap");
      if (!o && !a) return false;
      if (n === "auto" || n == null) {
        var s = this.animationThreshold;
        if (a && i.getBandWidth() > s) return true;
        if (o) {
          var l = e2(e).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return false;
      }
      return n === true;
    }, t.prototype.makeElOption = function(e, r, n, i, a) {
    }, t.prototype.createPointerEl = function(e, r, n, i) {
      var a = r.pointer;
      if (a) {
        var o = ml(e).pointerEl = new au[a.type](LL(r.pointer));
        e.add(o);
      }
    }, t.prototype.createLabelEl = function(e, r, n, i) {
      if (r.label) {
        var a = ml(e).labelEl = new bt(LL(r.label));
        e.add(a), RL(a, i);
      }
    }, t.prototype.updatePointerEl = function(e, r, n) {
      var i = ml(e).pointerEl;
      i && r.pointer && (i.setStyle(r.pointer.style), n(i, {
        shape: r.pointer.shape
      }));
    }, t.prototype.updateLabelEl = function(e, r, n, i) {
      var a = ml(e).labelEl;
      a && (a.setStyle(r.label.style), n(a, {
        x: r.label.x,
        y: r.label.y
      }), RL(a, i));
    }, t.prototype._renderHandle = function(e) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var r = this._axisPointerModel, n = this._api.getZr(), i = this._handle, a = r.getModel("handle"), o = r.get("status");
        if (!a.get("show") || !o || o === "hide") {
          i && n.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = true, i = this._handle = Od(a.get("icon"), {
          cursor: "move",
          draggable: true,
          onmousemove: function(u) {
            co(u.event);
          },
          onmousedown: K_(this._onHandleDragMove, this, 0, 0),
          drift: K_(this._onHandleDragMove, this),
          ondragend: K_(this._onHandleDragEnd, this)
        }), n.add(i)), OL(i, r, false), i.setStyle(a.getItemStyle(null, [
          "color",
          "borderColor",
          "borderWidth",
          "opacity",
          "shadowColor",
          "shadowBlur",
          "shadowOffsetX",
          "shadowOffsetY"
        ]));
        var l = a.get("size");
        ae(l) || (l = [
          l,
          l
        ]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, jc(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s);
      }
    }, t.prototype._moveHandleToValue = function(e, r) {
      $L(this._axisPointerModel, !r && this._moveAnimation, this._handle, Z_(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)));
    }, t.prototype._onHandleDragMove = function(e, r) {
      var n = this._handle;
      if (n) {
        this._dragging = true;
        var i = this.updateHandleTransform(Z_(n), [
          e,
          r
        ], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, n.stopAnimation(), n.attr(Z_(i)), ml(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, t.prototype._doDispatchAxisPointer = function() {
      var e = this._handle;
      if (e) {
        var r = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: r.cursorPoint[0],
          y: r.cursorPoint[1],
          tooltipOption: r.tooltipOption,
          axesInfo: [
            {
              axisDim: n.axis.dim,
              axisIndex: n.componentIndex
            }
          ]
        });
      }
    }, t.prototype._onHandleDragEnd = function() {
      this._dragging = false;
      var e = this._handle;
      if (e) {
        var r = this._axisPointerModel.get("value");
        this._moveHandleToValue(r), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, t.prototype.clear = function(e) {
      this._lastValue = null, this._lastStatus = null;
      var r = e.getZr(), n = this._group, i = this._handle;
      r && n && (this._lastGraphicKey = null, n && r.remove(n), i && r.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), Jf(this, "_doDispatchAxisPointer");
    }, t.prototype.doClear = function() {
    }, t.prototype.buildLabel = function(e, r, n) {
      return n = n || 0, {
        x: e[n],
        y: e[1 - n],
        width: r[n],
        height: r[1 - n]
      };
    }, t;
  }();
  function $L(t, e, r, n) {
    dH(ml(r).lastProp, n) || (ml(r).lastProp = n, e ? wt(r, n, t) : (r.stopAnimation(), r.attr(n)));
  }
  function dH(t, e) {
    if (Le(t) && Le(e)) {
      var r = true;
      return $(e, function(n, i) {
        r = r && dH(t[i], n);
      }), !!r;
    } else return t === e;
  }
  function RL(t, e) {
    t[e.get([
      "label",
      "show"
    ]) ? "show" : "hide"]();
  }
  function Z_(t) {
    return {
      x: t.x || 0,
      y: t.y || 0,
      rotation: t.rotation || 0
    };
  }
  function OL(t, e, r) {
    var n = e.get("z"), i = e.get("zlevel");
    t && t.traverse(function(a) {
      a.type !== "group" && (n != null && (a.z = n), i != null && (a.zlevel = i), a.silent = r);
    });
  }
  function L2(t) {
    var e = t.get("type"), r = t.getModel(e + "Style"), n;
    return e === "line" ? (n = r.getLineStyle(), n.fill = null) : e === "shadow" && (n = r.getAreaStyle(), n.stroke = null), n;
  }
  function pH(t, e, r, n, i) {
    var a = r.get("value"), o = vH(a, e.axis, e.ecModel, r.get("seriesDataIndices"), {
      precision: r.get([
        "label",
        "precision"
      ]),
      formatter: r.get([
        "label",
        "formatter"
      ])
    }), s = r.getModel("label"), l = Uc(s.get("padding") || 0), u = s.getFont(), c = Dd(o, u), h = i.position, f = c.width + l[1] + l[3], d = c.height + l[0] + l[2], p = i.align;
    p === "right" && (h[0] -= f), p === "center" && (h[0] -= f / 2);
    var v = i.verticalAlign;
    v === "bottom" && (h[1] -= d), v === "middle" && (h[1] -= d / 2), Kfe(h, f, d, n);
    var g = s.get("backgroundColor");
    (!g || g === "auto") && (g = e.get([
      "axisLine",
      "lineStyle",
      "color"
    ])), t.label = {
      x: h[0],
      y: h[1],
      style: Yt(s, {
        text: o,
        font: u,
        fill: s.getTextColor(),
        padding: l,
        backgroundColor: g
      }),
      z2: 10
    };
  }
  function Kfe(t, e, r, n) {
    var i = n.getWidth(), a = n.getHeight();
    t[0] = Math.min(t[0] + e, i) - e, t[1] = Math.min(t[1] + r, a) - r, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0);
  }
  function vH(t, e, r, n, i) {
    t = e.scale.parse(t);
    var a = e.scale.getLabel({
      value: t
    }, {
      precision: i.precision
    }), o = i.formatter;
    if (o) {
      var s = {
        value: WT(e, {
          value: t
        }),
        axisDimension: e.dim,
        axisIndex: e.index,
        seriesData: []
      };
      $(n, function(l) {
        var u = r.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
        h && s.seriesData.push(h);
      }), me(o) ? a = o.replace("{value}", a) : De(o) && (a = o(s));
    }
    return a;
  }
  function $2(t, e, r) {
    var n = Hn();
    return nu(n, n, r.rotation), Pa(n, n, r.position), Yi([
      t.dataToCoord(e),
      (r.labelOffset || 0) + (r.labelDirection || 1) * (r.labelMargin || 0)
    ], n);
  }
  function gH(t, e, r, n, i, a) {
    var o = _n.innerTextLayout(r.rotation, 0, r.labelDirection);
    r.labelMargin = i.get([
      "label",
      "margin"
    ]), pH(e, n, i, a, {
      position: $2(n.axis, t, r),
      align: o.textAlign,
      verticalAlign: o.textVerticalAlign
    });
  }
  function R2(t, e, r) {
    return r = r || 0, {
      x1: t[r],
      y1: t[1 - r],
      x2: e[r],
      y2: e[1 - r]
    };
  }
  function mH(t, e, r) {
    return r = r || 0, {
      x: t[r],
      y: t[1 - r],
      width: e[r],
      height: e[1 - r]
    };
  }
  function NL(t, e, r, n, i, a) {
    return {
      cx: t,
      cy: e,
      r0: r,
      r: n,
      startAngle: i,
      endAngle: a,
      clockwise: true
    };
  }
  var Zfe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(r, n, i, a, o) {
      var s = i.axis, l = s.grid, u = a.get("type"), c = BL(l, s).getOtherAxis(s).getGlobalExtent(), h = s.toGlobalCoord(s.dataToCoord(n, true));
      if (u && u !== "none") {
        var f = L2(a), d = Qfe[u](s, h, c);
        d.style = f, r.graphicKey = d.type, r.pointer = d;
      }
      var p = ow(l.model, i);
      gH(n, r, p, i, a, o);
    }, e.prototype.getHandleTransform = function(r, n, i) {
      var a = ow(n.axis.grid.model, n, {
        labelInside: false
      });
      a.labelMargin = i.get([
        "handle",
        "margin"
      ]);
      var o = $2(n.axis, r, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(r, n, i, a) {
      var o = i.axis, s = o.grid, l = o.getGlobalExtent(true), u = BL(s, o).getOtherAxis(o).getGlobalExtent(), c = o.dim === "x" ? 0 : 1, h = [
        r.x,
        r.y
      ];
      h[c] += n[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var f = (u[1] + u[0]) / 2, d = [
        f,
        f
      ];
      d[c] = h[c];
      var p = [
        {
          verticalAlign: "middle"
        },
        {
          align: "center"
        }
      ];
      return {
        x: h[0],
        y: h[1],
        rotation: r.rotation,
        cursorPoint: d,
        tooltipOption: p[c]
      };
    }, e;
  }(P2);
  function BL(t, e) {
    var r = {};
    return r[e.dim + "AxisIndex"] = e.index, t.getCartesian(r);
  }
  var Qfe = {
    line: function(t, e, r) {
      var n = R2([
        e,
        r[0]
      ], [
        e,
        r[1]
      ], zL(t));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: n
      };
    },
    shadow: function(t, e, r) {
      var n = Math.max(1, t.getBandWidth()), i = r[1] - r[0];
      return {
        type: "Rect",
        shape: mH([
          e - n / 2,
          r[0]
        ], [
          n,
          i
        ], zL(t))
      };
    }
  };
  function zL(t) {
    return t.dim === "x" ? 0 : 1;
  }
  var Jfe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "axisPointer", e.defaultOption = {
      show: "auto",
      z: 50,
      type: "line",
      snap: false,
      triggerTooltip: true,
      triggerEmphasis: true,
      value: null,
      status: null,
      link: [],
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: true,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [
          5,
          7,
          5,
          7
        ],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: false,
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        margin: 50,
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        throttle: 40
      }
    }, e;
  }(vt), Ja = _t(), ede = $;
  function yH(t, e, r) {
    if (!ct.node) {
      var n = e.getZr();
      Ja(n).records || (Ja(n).records = {}), tde(n, e);
      var i = Ja(n).records[t] || (Ja(n).records[t] = {});
      i.handler = r;
    }
  }
  function tde(t, e) {
    if (Ja(t).initialized) return;
    Ja(t).initialized = true, r("click", Ye(FL, "click")), r("mousemove", Ye(FL, "mousemove")), r("globalout", nde);
    function r(n, i) {
      t.on(n, function(a) {
        var o = ide(e);
        ede(Ja(t).records, function(s) {
          s && i(s, a, o.dispatchAction);
        }), rde(o.pendings, e);
      });
    }
  }
  function rde(t, e) {
    var r = t.showTip.length, n = t.hideTip.length, i;
    r ? i = t.showTip[r - 1] : n && (i = t.hideTip[n - 1]), i && (i.dispatchAction = null, e.dispatchAction(i));
  }
  function nde(t, e, r) {
    t.handler("leave", null, r);
  }
  function FL(t, e, r, n) {
    e.handler(t, r, n);
  }
  function ide(t) {
    var e = {
      showTip: [],
      hideTip: []
    }, r = function(n) {
      var i = e[n.type];
      i ? i.push(n) : (n.dispatchAction = r, t.dispatchAction(n));
    };
    return {
      dispatchAction: r,
      pendings: e
    };
  }
  function Iw(t, e) {
    if (!ct.node) {
      var r = e.getZr(), n = (Ja(r).records || {})[t];
      n && (Ja(r).records[t] = null);
    }
  }
  var ade = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = n.getComponent("tooltip"), o = r.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      yH("axisPointer", i, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, e.prototype.remove = function(r, n) {
      Iw("axisPointer", n);
    }, e.prototype.dispose = function(r, n) {
      Iw("axisPointer", n);
    }, e.type = "axisPointer", e;
  }(tr);
  function _H(t, e) {
    var r = [], n = t.seriesIndex, i;
    if (n == null || !(i = e.getSeriesByIndex(n))) return {
      point: []
    };
    var a = i.getData(), o = Yl(a, t);
    if (o == null || o < 0 || ae(o)) return {
      point: []
    };
    var s = a.getItemGraphicEl(o), l = i.coordinateSystem;
    if (i.getTooltipPosition) r = i.getTooltipPosition(o) || [];
    else if (l && l.dataToPoint) if (t.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, f = u.dim, d = h === "x" || h === "radius" ? 1 : 0, p = a.mapDimension(f), v = [];
      v[d] = a.get(p, o), v[1 - d] = a.get(a.getCalculationInfo("stackResultDimension"), o), r = l.dataToPoint(v) || [];
    } else r = l.dataToPoint(a.getValues(oe(l.dimensions, function(m) {
      return a.mapDimension(m);
    }), o)) || [];
    else if (s) {
      var g = s.getBoundingRect().clone();
      g.applyTransform(s.transform), r = [
        g.x + g.width / 2,
        g.y + g.height / 2
      ];
    }
    return {
      point: r,
      el: s
    };
  }
  var VL = _t();
  function ode(t, e, r) {
    var n = t.currTrigger, i = [
      t.x,
      t.y
    ], a = t, o = t.dispatchAction || _e(r.dispatchAction, r), s = e.getComponent("axisPointer").coordSysAxesInfo;
    if (s) {
      fg(i) && (i = _H({
        seriesIndex: a.seriesIndex,
        dataIndex: a.dataIndex
      }, e).point);
      var l = fg(i), u = a.axesInfo, c = s.axesInfo, h = n === "leave" || fg(i), f = {}, d = {}, p = {
        list: [],
        map: {}
      }, v = {
        showPointer: Ye(lde, d),
        showTooltip: Ye(ude, p)
      };
      $(s.coordSysMap, function(m, y) {
        var _ = l || m.containPoint(i);
        $(s.coordSysAxesInfo[y], function(b, w) {
          var x = b.axis, T = dde(u, b);
          if (!h && _ && (!u || T)) {
            var A = T && T.value;
            A == null && !l && (A = x.pointToData(i)), A != null && GL(b, A, v, false, f);
          }
        });
      });
      var g = {};
      return $(c, function(m, y) {
        var _ = m.linkGroup;
        _ && !d[y] && $(_.axesInfo, function(b, w) {
          var x = d[w];
          if (b !== m && x) {
            var T = x.value;
            _.mapper && (T = m.axis.scale.parse(_.mapper(T, WL(b), WL(m)))), g[m.key] = T;
          }
        });
      }), $(g, function(m, y) {
        GL(c[y], m, v, true, f);
      }), cde(d, c, f), hde(p, i, t, o), fde(c, o, r), f;
    }
  }
  function GL(t, e, r, n, i) {
    var a = t.axis;
    if (!(a.scale.isBlank() || !a.containData(e))) {
      if (!t.involveSeries) {
        r.showPointer(t, e);
        return;
      }
      var o = sde(e, t), s = o.payloadBatch, l = o.snapToValue;
      s[0] && i.seriesIndex == null && te(i, s[0]), !n && t.snap && a.containData(l) && l != null && (e = l), r.showPointer(t, e, s), r.showTooltip(t, o, l);
    }
  }
  function sde(t, e) {
    var r = e.axis, n = r.dim, i = t, a = [], o = Number.MAX_VALUE, s = -1;
    return $(e.seriesModels, function(l, u) {
      var c = l.getData().mapDimensionsAll(n), h, f;
      if (l.getAxisTooltipData) {
        var d = l.getAxisTooltipData(c, t, r);
        f = d.dataIndices, h = d.nestestValue;
      } else {
        if (f = l.getData().indicesOfNearest(c[0], t, r.type === "category" ? 0.5 : null), !f.length) return;
        h = l.getData().get(c[0], f[0]);
      }
      if (!(h == null || !isFinite(h))) {
        var p = t - h, v = Math.abs(p);
        v <= o && ((v < o || p >= 0 && s < 0) && (o = v, s = p, i = h, a.length = 0), $(f, function(g) {
          a.push({
            seriesIndex: l.seriesIndex,
            dataIndexInside: g,
            dataIndex: l.getData().getRawIndex(g)
          });
        }));
      }
    }), {
      payloadBatch: a,
      snapToValue: i
    };
  }
  function lde(t, e, r, n) {
    t[e.key] = {
      value: r,
      payloadBatch: n
    };
  }
  function ude(t, e, r, n) {
    var i = r.payloadBatch, a = e.axis, o = a.model, s = e.axisPointerModel;
    if (!(!e.triggerTooltip || !i.length)) {
      var l = e.coordSys.model, u = od(l), c = t.map[u];
      c || (c = t.map[u] = {
        coordSysId: l.id,
        coordSysIndex: l.componentIndex,
        coordSysType: l.type,
        coordSysMainType: l.mainType,
        dataByAxis: []
      }, t.list.push(c)), c.dataByAxis.push({
        axisDim: a.dim,
        axisIndex: o.componentIndex,
        axisType: o.type,
        axisId: o.id,
        value: n,
        valueLabelOpt: {
          precision: s.get([
            "label",
            "precision"
          ]),
          formatter: s.get([
            "label",
            "formatter"
          ])
        },
        seriesDataIndices: i.slice()
      });
    }
  }
  function cde(t, e, r) {
    var n = r.axesInfo = [];
    $(e, function(i, a) {
      var o = i.axisPointerModel.option, s = t[a];
      s ? (!i.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (o.status = "hide"), o.status === "show" && n.push({
        axisDim: i.axis.dim,
        axisIndex: i.axis.model.componentIndex,
        value: o.value
      });
    });
  }
  function hde(t, e, r, n) {
    if (fg(e) || !t.list.length) {
      n({
        type: "hideTip"
      });
      return;
    }
    var i = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    n({
      type: "showTip",
      escapeConnect: true,
      x: e[0],
      y: e[1],
      tooltipOption: r.tooltipOption,
      position: r.position,
      dataIndexInside: i.dataIndexInside,
      dataIndex: i.dataIndex,
      seriesIndex: i.seriesIndex,
      dataByCoordSys: t.list
    });
  }
  function fde(t, e, r) {
    var n = r.getZr(), i = "axisPointerLastHighlights", a = VL(n)[i] || {}, o = VL(n)[i] = {};
    $(t, function(u, c) {
      var h = u.axisPointerModel.option;
      h.status === "show" && u.triggerEmphasis && $(h.seriesDataIndices, function(f) {
        var d = f.seriesIndex + " | " + f.dataIndex;
        o[d] = f;
      });
    });
    var s = [], l = [];
    $(a, function(u, c) {
      !o[c] && l.push(u);
    }), $(o, function(u, c) {
      !a[c] && s.push(u);
    }), l.length && r.dispatchAction({
      type: "downplay",
      escapeConnect: true,
      notBlur: true,
      batch: l
    }), s.length && r.dispatchAction({
      type: "highlight",
      escapeConnect: true,
      notBlur: true,
      batch: s
    });
  }
  function dde(t, e) {
    for (var r = 0; r < (t || []).length; r++) {
      var n = t[r];
      if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n;
    }
  }
  function WL(t) {
    var e = t.axis.model, r = {}, n = r.axisDim = t.axis.dim;
    return r.axisIndex = r[n + "AxisIndex"] = e.componentIndex, r.axisName = r[n + "AxisName"] = e.name, r.axisId = r[n + "AxisId"] = e.id, r;
  }
  function fg(t) {
    return !t || t[0] == null || isNaN(t[0]) || t[1] == null || isNaN(t[1]);
  }
  function jd(t) {
    uu.registerAxisPointerClass("CartesianAxisPointer", Zfe), t.registerComponentModel(Jfe), t.registerComponentView(ade), t.registerPreprocessor(function(e) {
      if (e) {
        (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
        var r = e.axisPointer.link;
        r && !ae(r) && (e.axisPointer.link = [
          r
        ]);
      }
    }), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, function(e, r) {
      e.getComponent("axisPointer").coordSysAxesInfo = Soe(e, r);
    }), t.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, ode);
  }
  function pde(t) {
    rt(qG), rt(jd);
  }
  var vde = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(r, n, i, a, o) {
      var s = i.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), h = s.dataToCoord(n), f = a.get("type");
      if (f && f !== "none") {
        var d = L2(a), p = mde[f](s, l, h, c);
        p.style = d, r.graphicKey = p.type, r.pointer = p;
      }
      var v = a.get([
        "label",
        "margin"
      ]), g = gde(n, i, a, l, v);
      pH(r, i, a, o, g);
    }, e;
  }(P2);
  function gde(t, e, r, n, i) {
    var a = e.axis, o = a.dataToCoord(t), s = n.getAngleAxis().getExtent()[0];
    s = s / 180 * Math.PI;
    var l = n.getRadiusAxis().getExtent(), u, c, h;
    if (a.dim === "radius") {
      var f = Hn();
      nu(f, f, s), Pa(f, f, [
        n.cx,
        n.cy
      ]), u = Yi([
        o,
        -i
      ], f);
      var d = e.getModel("axisLabel").get("rotate") || 0, p = _n.innerTextLayout(s, d * Math.PI / 180, -1);
      c = p.textAlign, h = p.textVerticalAlign;
    } else {
      var v = l[1];
      u = n.coordToPoint([
        v + i,
        o
      ]);
      var g = n.cx, m = n.cy;
      c = Math.abs(u[0] - g) / v < 0.3 ? "center" : u[0] > g ? "left" : "right", h = Math.abs(u[1] - m) / v < 0.3 ? "middle" : u[1] > m ? "top" : "bottom";
    }
    return {
      position: u,
      align: c,
      verticalAlign: h
    };
  }
  var mde = {
    line: function(t, e, r, n) {
      return t.dim === "angle" ? {
        type: "Line",
        shape: R2(e.coordToPoint([
          n[0],
          r
        ]), e.coordToPoint([
          n[1],
          r
        ]))
      } : {
        type: "Circle",
        shape: {
          cx: e.cx,
          cy: e.cy,
          r
        }
      };
    },
    shadow: function(t, e, r, n) {
      var i = Math.max(1, t.getBandWidth()), a = Math.PI / 180;
      return t.dim === "angle" ? {
        type: "Sector",
        shape: NL(e.cx, e.cy, n[0], n[1], (-r - i / 2) * a, (-r + i / 2) * a)
      } : {
        type: "Sector",
        shape: NL(e.cx, e.cy, r - i / 2, r + i / 2, 0, Math.PI * 2)
      };
    }
  }, yde = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.findAxisModel = function(r) {
      var n, i = this.ecModel;
      return i.eachComponent(r, function(a) {
        a.getCoordSysModel() === this && (n = a);
      }, this), n;
    }, e.type = "polar", e.dependencies = [
      "radiusAxis",
      "angleAxis"
    ], e.defaultOption = {
      z: 0,
      center: [
        "50%",
        "50%"
      ],
      radius: "80%"
    }, e;
  }(vt), O2 = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", gr).models[0];
    }, e.type = "polarAxis", e;
  }(vt);
  yr(O2, Fd);
  var _de = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "angleAxis", e;
  }(O2), bde = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "radiusAxis", e;
  }(O2), N2 = function(t) {
    K(e, t);
    function e(r, n) {
      return t.call(this, "radius", r, n) || this;
    }
    return e.prototype.pointToData = function(r, n) {
      return this.polar.pointToData(r, n)[this.dim === "radius" ? 0 : 1];
    }, e;
  }(Ji);
  N2.prototype.dataToRadius = Ji.prototype.dataToCoord;
  N2.prototype.radiusToData = Ji.prototype.coordToData;
  var xde = _t(), B2 = function(t) {
    K(e, t);
    function e(r, n) {
      return t.call(this, "angle", r, n || [
        0,
        360
      ]) || this;
    }
    return e.prototype.pointToData = function(r, n) {
      return this.polar.pointToData(r, n)[this.dim === "radius" ? 0 : 1];
    }, e.prototype.calculateCategoryInterval = function() {
      var r = this, n = r.getLabelModel(), i = r.scale, a = i.getExtent(), o = i.count();
      if (a[1] - a[0] < 1) return 0;
      var s = a[0], l = r.dataToCoord(s + 1) - r.dataToCoord(s), u = Math.abs(l), c = Dd(s == null ? "" : s + "", n.getFont(), "center", "top"), h = Math.max(c.height, 7), f = h / u;
      isNaN(f) && (f = 1 / 0);
      var d = Math.max(0, Math.floor(f)), p = xde(r.model), v = p.lastAutoInterval, g = p.lastTickCount;
      return v != null && g != null && Math.abs(v - d) <= 1 && Math.abs(g - o) <= 1 && v > d ? d = v : (p.lastTickCount = o, p.lastAutoInterval = d), d;
    }, e;
  }(Ji);
  B2.prototype.dataToAngle = Ji.prototype.dataToCoord;
  B2.prototype.angleToData = Ji.prototype.coordToData;
  var bH = [
    "radius",
    "angle"
  ], wde = function() {
    function t(e) {
      this.dimensions = bH, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new N2(), this._angleAxis = new B2(), this.axisPointerEnabled = true, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return t.prototype.containPoint = function(e) {
      var r = this.pointToCoord(e);
      return this._radiusAxis.contain(r[0]) && this._angleAxis.contain(r[1]);
    }, t.prototype.containData = function(e) {
      return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]);
    }, t.prototype.getAxis = function(e) {
      var r = "_" + e + "Axis";
      return this[r];
    }, t.prototype.getAxes = function() {
      return [
        this._radiusAxis,
        this._angleAxis
      ];
    }, t.prototype.getAxesByScale = function(e) {
      var r = [], n = this._angleAxis, i = this._radiusAxis;
      return n.scale.type === e && r.push(n), i.scale.type === e && r.push(i), r;
    }, t.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, t.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, t.prototype.getOtherAxis = function(e) {
      var r = this._angleAxis;
      return e === r ? this._radiusAxis : r;
    }, t.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, t.prototype.getTooltipAxes = function(e) {
      var r = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis();
      return {
        baseAxes: [
          r
        ],
        otherAxes: [
          this.getOtherAxis(r)
        ]
      };
    }, t.prototype.dataToPoint = function(e, r) {
      return this.coordToPoint([
        this._radiusAxis.dataToRadius(e[0], r),
        this._angleAxis.dataToAngle(e[1], r)
      ]);
    }, t.prototype.pointToData = function(e, r) {
      var n = this.pointToCoord(e);
      return [
        this._radiusAxis.radiusToData(n[0], r),
        this._angleAxis.angleToData(n[1], r)
      ];
    }, t.prototype.pointToCoord = function(e) {
      var r = e[0] - this.cx, n = e[1] - this.cy, i = this.getAngleAxis(), a = i.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
      i.inverse ? o = s - 360 : s = o + 360;
      var l = Math.sqrt(r * r + n * n);
      r /= l, n /= l;
      for (var u = Math.atan2(-n, r) / Math.PI * 180, c = u < o ? 1 : -1; u < o || u > s; ) u += c * 360;
      return [
        l,
        u
      ];
    }, t.prototype.coordToPoint = function(e) {
      var r = e[0], n = e[1] / 180 * Math.PI, i = Math.cos(n) * r + this.cx, a = -Math.sin(n) * r + this.cy;
      return [
        i,
        a
      ];
    }, t.prototype.getArea = function() {
      var e = this.getAngleAxis(), r = this.getRadiusAxis(), n = r.getExtent().slice();
      n[0] > n[1] && n.reverse();
      var i = e.getExtent(), a = Math.PI / 180, o = 1e-4;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: n[0],
        r: n[1],
        startAngle: -i[0] * a,
        endAngle: -i[1] * a,
        clockwise: e.inverse,
        contain: function(s, l) {
          var u = s - this.cx, c = l - this.cy, h = u * u + c * c, f = this.r, d = this.r0;
          return f !== d && h - o <= f * f && h + o >= d * d;
        }
      };
    }, t.prototype.convertToPixel = function(e, r, n) {
      var i = HL(r);
      return i === this ? this.dataToPoint(n) : null;
    }, t.prototype.convertFromPixel = function(e, r, n) {
      var i = HL(r);
      return i === this ? this.pointToData(n) : null;
    }, t;
  }();
  function HL(t) {
    var e = t.seriesModel, r = t.polarModel;
    return r && r.coordinateSystem || e && e.coordinateSystem;
  }
  function Sde(t, e, r) {
    var n = e.get("center"), i = r.getWidth(), a = r.getHeight();
    t.cx = pe(n[0], i), t.cy = pe(n[1], a);
    var o = t.getRadiusAxis(), s = Math.min(i, a) / 2, l = e.get("radius");
    l == null ? l = [
      0,
      "100%"
    ] : ae(l) || (l = [
      0,
      l
    ]);
    var u = [
      pe(l[0], s),
      pe(l[1], s)
    ];
    o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1]);
  }
  function Tde(t, e) {
    var r = this, n = r.getAngleAxis(), i = r.getRadiusAxis();
    if (n.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), t.eachSeries(function(s) {
      if (s.coordinateSystem === r) {
        var l = s.getData();
        $(Yg(l, "radius"), function(u) {
          i.scale.unionExtentFromData(l, u);
        }), $(Yg(l, "angle"), function(u) {
          n.scale.unionExtentFromData(l, u);
        });
      }
    }), xc(n.scale, n.model), xc(i.scale, i.model), n.type === "category" && !n.onBand) {
      var a = n.getExtent(), o = 360 / n.scale.count();
      n.inverse ? a[1] += o : a[1] -= o, n.setExtent(a[0], a[1]);
    }
  }
  function Cde(t) {
    return t.mainType === "angleAxis";
  }
  function UL(t, e) {
    var r;
    if (t.type = e.get("type"), t.scale = fy(e), t.onBand = e.get("boundaryGap") && t.type === "category", t.inverse = e.get("inverse"), Cde(e)) {
      t.inverse = t.inverse !== e.get("clockwise");
      var n = e.get("startAngle"), i = (r = e.get("endAngle")) !== null && r !== void 0 ? r : n + (t.inverse ? -360 : 360);
      t.setExtent(n, i);
    }
    e.axis = t, t.model = e;
  }
  var Ade = {
    dimensions: bH,
    create: function(t, e) {
      var r = [];
      return t.eachComponent("polar", function(n, i) {
        var a = new wde(i + "");
        a.update = Tde;
        var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = n.findAxisModel("radiusAxis"), u = n.findAxisModel("angleAxis");
        UL(o, l), UL(s, u), Sde(a, n, e), r.push(a), n.coordinateSystem = a, a.model = n;
      }), t.eachSeries(function(n) {
        if (n.get("coordinateSystem") === "polar") {
          var i = n.getReferringComponents("polar", gr).models[0];
          n.coordinateSystem = i.coordinateSystem;
        }
      }), r;
    }
  }, Ide = [
    "axisLine",
    "axisLabel",
    "axisTick",
    "minorTick",
    "splitLine",
    "minorSplitLine",
    "splitArea"
  ];
  function av(t, e, r) {
    e[1] > e[0] && (e = e.slice().reverse());
    var n = t.coordToPoint([
      e[0],
      r
    ]), i = t.coordToPoint([
      e[1],
      r
    ]);
    return {
      x1: n[0],
      y1: n[1],
      x2: i[0],
      y2: i[1]
    };
  }
  function ov(t) {
    var e = t.getRadiusAxis();
    return e.inverse ? 0 : 1;
  }
  function YL(t) {
    var e = t[0], r = t[t.length - 1];
    e && r && Math.abs(Math.abs(e.coord - r.coord) - 360) < 1e-4 && t.pop();
  }
  var Mde = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.axisPointerClass = "PolarAxisPointer", r;
    }
    return e.prototype.render = function(r, n) {
      if (this.group.removeAll(), !!r.get("show")) {
        var i = r.axis, a = i.polar, o = a.getRadiusAxis().getExtent(), s = i.getTicksCoords(), l = i.getMinorTicksCoords(), u = oe(i.getViewLabels(), function(c) {
          c = Oe(c);
          var h = i.scale, f = h.type === "ordinal" ? h.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(f), c;
        });
        YL(u), YL(s), $(Ide, function(c) {
          r.get([
            c,
            "show"
          ]) && (!i.scale.isBlank() || c === "axisLine") && Dde[c](this.group, r, a, s, l, o, u);
        }, this);
      }
    }, e.type = "angleAxis", e;
  }(uu), Dde = {
    axisLine: function(t, e, r, n, i, a) {
      var o = e.getModel([
        "axisLine",
        "lineStyle"
      ]), s = r.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), c = ov(r), h = c ? 0 : 1, f, d = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
      a[h] === 0 ? f = new au[d]({
        shape: {
          cx: r.cx,
          cy: r.cy,
          r: a[c],
          startAngle: -u[0] * l,
          endAngle: -u[1] * l,
          clockwise: s.inverse
        },
        style: o.getLineStyle(),
        z2: 1,
        silent: true
      }) : f = new Pd({
        shape: {
          cx: r.cx,
          cy: r.cy,
          r: a[c],
          r0: a[h]
        },
        style: o.getLineStyle(),
        z2: 1,
        silent: true
      }), f.style.fill = null, t.add(f);
    },
    axisTick: function(t, e, r, n, i, a) {
      var o = e.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[ov(r)], u = oe(n, function(c) {
        return new Mr({
          shape: av(r, [
            l,
            l + s
          ], c.coord)
        });
      });
      t.add(vi(u, {
        style: Ee(o.getModel("lineStyle").getLineStyle(), {
          stroke: e.get([
            "axisLine",
            "lineStyle",
            "color"
          ])
        })
      }));
    },
    minorTick: function(t, e, r, n, i, a) {
      if (i.length) {
        for (var o = e.getModel("axisTick"), s = e.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[ov(r)], c = [], h = 0; h < i.length; h++) for (var f = 0; f < i[h].length; f++) c.push(new Mr({
          shape: av(r, [
            u,
            u + l
          ], i[h][f].coord)
        }));
        t.add(vi(c, {
          style: Ee(s.getModel("lineStyle").getLineStyle(), Ee(o.getLineStyle(), {
            stroke: e.get([
              "axisLine",
              "lineStyle",
              "color"
            ])
          }))
        }));
      }
    },
    axisLabel: function(t, e, r, n, i, a, o) {
      var s = e.getCategories(true), l = e.getModel("axisLabel"), u = l.get("margin"), c = e.get("triggerEvent");
      $(o, function(h, f) {
        var d = l, p = h.tickValue, v = a[ov(r)], g = r.coordToPoint([
          v + u,
          h.coord
        ]), m = r.cx, y = r.cy, _ = Math.abs(g[0] - m) / v < 0.3 ? "center" : g[0] > m ? "left" : "right", b = Math.abs(g[1] - y) / v < 0.3 ? "middle" : g[1] > y ? "top" : "bottom";
        if (s && s[p]) {
          var w = s[p];
          Le(w) && w.textStyle && (d = new kt(w.textStyle, l, l.ecModel));
        }
        var x = new bt({
          silent: _n.isLabelSilent(e),
          style: Yt(d, {
            x: g[0],
            y: g[1],
            fill: d.getTextColor() || e.get([
              "axisLine",
              "lineStyle",
              "color"
            ]),
            text: h.formattedLabel,
            align: _,
            verticalAlign: b
          })
        });
        if (t.add(x), c) {
          var T = _n.makeAxisEventDataBase(e);
          T.targetType = "axisLabel", T.value = h.rawLabel, Ge(x).eventData = T;
        }
      }, this);
    },
    splitLine: function(t, e, r, n, i, a) {
      var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [
        l
      ];
      for (var c = [], h = 0; h < n.length; h++) {
        var f = u++ % l.length;
        c[f] = c[f] || [], c[f].push(new Mr({
          shape: av(r, a, n[h].coord)
        }));
      }
      for (var h = 0; h < c.length; h++) t.add(vi(c[h], {
        style: Ee({
          stroke: l[h % l.length]
        }, s.getLineStyle()),
        silent: true,
        z: e.get("z")
      }));
    },
    minorSplitLine: function(t, e, r, n, i, a) {
      if (i.length) {
        for (var o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < i.length; u++) for (var c = 0; c < i[u].length; c++) l.push(new Mr({
          shape: av(r, a, i[u][c].coord)
        }));
        t.add(vi(l, {
          style: s.getLineStyle(),
          silent: true,
          z: e.get("z")
        }));
      }
    },
    splitArea: function(t, e, r, n, i, a) {
      if (n.length) {
        var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
        l = l instanceof Array ? l : [
          l
        ];
        for (var c = [], h = Math.PI / 180, f = -n[0].coord * h, d = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), v = e.get("clockwise"), g = 1, m = n.length; g <= m; g++) {
          var y = g === m ? n[0].coord : n[g].coord, _ = u++ % l.length;
          c[_] = c[_] || [], c[_].push(new wn({
            shape: {
              cx: r.cx,
              cy: r.cy,
              r0: d,
              r: p,
              startAngle: f,
              endAngle: -y * h,
              clockwise: v
            },
            silent: true
          })), f = -y * h;
        }
        for (var g = 0; g < c.length; g++) t.add(vi(c[g], {
          style: Ee({
            fill: l[g % l.length]
          }, s.getAreaStyle()),
          silent: true
        }));
      }
    }
  }, Ede = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], kde = [
    "splitLine",
    "splitArea",
    "minorSplitLine"
  ], Pde = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.axisPointerClass = "PolarAxisPointer", r;
    }
    return e.prototype.render = function(r, n) {
      if (this.group.removeAll(), !!r.get("show")) {
        var i = this._axisGroup, a = this._axisGroup = new Be();
        this.group.add(a);
        var o = r.axis, s = o.polar, l = s.getAngleAxis(), u = o.getTicksCoords(), c = o.getMinorTicksCoords(), h = l.getExtent()[0], f = o.getExtent(), d = $de(s, r, h), p = new _n(r, d);
        $(Ede, p.add, p), a.add(p.getGroup()), Rd(i, a, r), $(kde, function(v) {
          r.get([
            v,
            "show"
          ]) && !o.scale.isBlank() && Lde[v](this.group, r, s, h, f, u, c);
        }, this);
      }
    }, e.type = "radiusAxis", e;
  }(uu), Lde = {
    splitLine: function(t, e, r, n, i, a) {
      var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0, c = r.getAngleAxis(), h = Math.PI / 180, f = c.getExtent(), d = Math.abs(f[1] - f[0]) === 360 ? "Circle" : "Arc";
      l = l instanceof Array ? l : [
        l
      ];
      for (var p = [], v = 0; v < a.length; v++) {
        var g = u++ % l.length;
        p[g] = p[g] || [], p[g].push(new au[d]({
          shape: {
            cx: r.cx,
            cy: r.cy,
            r: Math.max(a[v].coord, 0),
            startAngle: -f[0] * h,
            endAngle: -f[1] * h,
            clockwise: c.inverse
          }
        }));
      }
      for (var v = 0; v < p.length; v++) t.add(vi(p[v], {
        style: Ee({
          stroke: l[v % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: true
      }));
    },
    minorSplitLine: function(t, e, r, n, i, a, o) {
      if (o.length) {
        for (var s = e.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < o.length; c++) for (var h = 0; h < o[c].length; h++) u.push(new wo({
          shape: {
            cx: r.cx,
            cy: r.cy,
            r: o[c][h].coord
          }
        }));
        t.add(vi(u, {
          style: Ee({
            fill: null
          }, l.getLineStyle()),
          silent: true
        }));
      }
    },
    splitArea: function(t, e, r, n, i, a) {
      if (a.length) {
        var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
        l = l instanceof Array ? l : [
          l
        ];
        for (var c = [], h = a[0].coord, f = 1; f < a.length; f++) {
          var d = u++ % l.length;
          c[d] = c[d] || [], c[d].push(new wn({
            shape: {
              cx: r.cx,
              cy: r.cy,
              r0: h,
              r: a[f].coord,
              startAngle: 0,
              endAngle: Math.PI * 2
            },
            silent: true
          })), h = a[f].coord;
        }
        for (var f = 0; f < c.length; f++) t.add(vi(c[f], {
          style: Ee({
            fill: l[f % l.length]
          }, s.getAreaStyle()),
          silent: true
        }));
      }
    }
  };
  function $de(t, e, r) {
    return {
      position: [
        t.cx,
        t.cy
      ],
      rotation: r / 180 * Math.PI,
      labelDirection: -1,
      tickDirection: -1,
      nameDirection: 1,
      labelRotate: e.getModel("axisLabel").get("rotate"),
      z2: 1
    };
  }
  function xH(t) {
    return t.get("stack") || "__ec_stack_" + t.seriesIndex;
  }
  function wH(t, e) {
    return e.dim + t.model.componentIndex;
  }
  function Rde(t, e, r) {
    var n = {}, i = Ode(Dt(e.getSeriesByType(t), function(a) {
      return !e.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
    }));
    e.eachSeriesByType(t, function(a) {
      if (a.coordinateSystem.type === "polar") {
        var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = wH(s, l), c = xH(a), h = i[u][c], f = h.offset, d = h.width, p = s.getOtherAxis(l), v = a.coordinateSystem.cx, g = a.coordinateSystem.cy, m = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
        n[c] = n[c] || [];
        for (var _ = o.mapDimension(p.dim), b = o.mapDimension(l.dim), w = vs(o, _), x = l.dim !== "radius" || !a.get("roundCap", true), T = p.model, A = T.get("startValue"), I = p.dataToCoord(A || 0), M = 0, k = o.count(); M < k; M++) {
          var B = o.get(_, M), L = o.get(b, M), z = B >= 0 ? "p" : "n", F = I;
          w && (n[c][L] || (n[c][L] = {
            p: I,
            n: I
          }), F = n[c][L][z]);
          var E = void 0, O = void 0, N = void 0, V = void 0;
          if (p.dim === "radius") {
            var H = p.dataToCoord(B) - I, G = l.dataToCoord(L);
            Math.abs(H) < m && (H = (H < 0 ? -1 : 1) * m), E = F, O = F + H, N = G - f, V = N - d, w && (n[c][L][z] = O);
          } else {
            var Y = p.dataToCoord(B, x) - I, U = l.dataToCoord(L);
            Math.abs(Y) < y && (Y = (Y < 0 ? -1 : 1) * y), E = U + f, O = E + d, N = F, V = F + Y, w && (n[c][L][z] = V);
          }
          o.setItemLayout(M, {
            cx: v,
            cy: g,
            r0: E,
            r: O,
            startAngle: -N * Math.PI / 180,
            endAngle: -V * Math.PI / 180,
            clockwise: N >= V
          });
        }
      }
    });
  }
  function Ode(t) {
    var e = {};
    $(t, function(n, i) {
      var a = n.getData(), o = n.coordinateSystem, s = o.getBaseAxis(), l = wH(o, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), h = e[l] || {
        bandWidth: c,
        remainedWidth: c,
        autoWidthCount: 0,
        categoryGap: "20%",
        gap: "30%",
        stacks: {}
      }, f = h.stacks;
      e[l] = h;
      var d = xH(n);
      f[d] || h.autoWidthCount++, f[d] = f[d] || {
        width: 0,
        maxWidth: 0
      };
      var p = pe(n.get("barWidth"), c), v = pe(n.get("barMaxWidth"), c), g = n.get("barGap"), m = n.get("barCategoryGap");
      p && !f[d].width && (p = Math.min(h.remainedWidth, p), f[d].width = p, h.remainedWidth -= p), v && (f[d].maxWidth = v), g != null && (h.gap = g), m != null && (h.categoryGap = m);
    });
    var r = {};
    return $(e, function(n, i) {
      r[i] = {};
      var a = n.stacks, o = n.bandWidth, s = pe(n.categoryGap, o), l = pe(n.gap, 1), u = n.remainedWidth, c = n.autoWidthCount, h = (u - s) / (c + (c - 1) * l);
      h = Math.max(h, 0), $(a, function(v, g) {
        var m = v.maxWidth;
        m && m < h && (m = Math.min(m, u), v.width && (m = Math.min(m, v.width)), u -= m, v.width = m, c--);
      }), h = (u - s) / (c + (c - 1) * l), h = Math.max(h, 0);
      var f = 0, d;
      $(a, function(v, g) {
        v.width || (v.width = h), d = v, f += v.width * (1 + l);
      }), d && (f -= d.width * l);
      var p = -f / 2;
      $(a, function(v, g) {
        r[i][g] = r[i][g] || {
          offset: p,
          width: v.width
        }, p += v.width * (1 + l);
      });
    }), r;
  }
  var Nde = {
    startAngle: 90,
    clockwise: true,
    splitNumber: 12,
    axisLabel: {
      rotate: 0
    }
  }, Bde = {
    splitNumber: 5
  }, zde = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "polar", e;
  }(tr);
  function Fde(t) {
    rt(jd), uu.registerAxisPointerClass("PolarAxisPointer", vde), t.registerCoordinateSystem("polar", Ade), t.registerComponentModel(yde), t.registerComponentView(zde), Sc(t, "angle", _de, Nde), Sc(t, "radius", bde, Bde), t.registerComponentView(Mde), t.registerComponentView(Pde), t.registerLayout(Ye(Rde, "bar"));
  }
  function Mw(t, e) {
    e = e || {};
    var r = t.coordinateSystem, n = t.axis, i = {}, a = n.position, o = n.orient, s = r.getRect(), l = [
      s.x,
      s.x + s.width,
      s.y,
      s.y + s.height
    ], u = {
      horizontal: {
        top: l[2],
        bottom: l[3]
      },
      vertical: {
        left: l[0],
        right: l[1]
      }
    };
    i.position = [
      o === "vertical" ? u.vertical[a] : l[0],
      o === "horizontal" ? u.horizontal[a] : l[3]
    ];
    var c = {
      horizontal: 0,
      vertical: 1
    };
    i.rotation = Math.PI / 2 * c[o];
    var h = {
      top: -1,
      bottom: 1,
      right: 1,
      left: -1
    };
    i.labelDirection = i.tickDirection = i.nameDirection = h[a], t.get([
      "axisTick",
      "inside"
    ]) && (i.tickDirection = -i.tickDirection), Fr(e.labelInside, t.get([
      "axisLabel",
      "inside"
    ])) && (i.labelDirection = -i.labelDirection);
    var f = e.rotate;
    return f == null && (f = t.get([
      "axisLabel",
      "rotate"
    ])), i.labelRotation = a === "top" ? -f : f, i.z2 = 1, i;
  }
  var Vde = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], Gde = [
    "splitArea",
    "splitLine"
  ], Wde = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.axisPointerClass = "SingleAxisPointer", r;
    }
    return e.prototype.render = function(r, n, i, a) {
      var o = this.group;
      o.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new Be();
      var l = Mw(r), u = new _n(r, l);
      $(Vde, u.add, u), o.add(this._axisGroup), o.add(u.getGroup()), $(Gde, function(c) {
        r.get([
          c,
          "show"
        ]) && Hde[c](this, this.group, this._axisGroup, r);
      }, this), Rd(s, this._axisGroup, r), t.prototype.render.call(this, r, n, i, a);
    }, e.prototype.remove = function() {
      HG(this);
    }, e.type = "singleAxis", e;
  }(uu), Hde = {
    splitLine: function(t, e, r, n) {
      var i = n.axis;
      if (!i.scale.isBlank()) {
        var a = n.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
        s = s instanceof Array ? s : [
          s
        ];
        for (var l = o.get("width"), u = n.coordinateSystem.getRect(), c = i.isHorizontal(), h = [], f = 0, d = i.getTicksCoords({
          tickModel: a
        }), p = [], v = [], g = 0; g < d.length; ++g) {
          var m = i.toGlobalCoord(d[g].coord);
          c ? (p[0] = m, p[1] = u.y, v[0] = m, v[1] = u.y + u.height) : (p[0] = u.x, p[1] = m, v[0] = u.x + u.width, v[1] = m);
          var y = new Mr({
            shape: {
              x1: p[0],
              y1: p[1],
              x2: v[0],
              y2: v[1]
            },
            silent: true
          });
          yc(y.shape, l);
          var _ = f++ % s.length;
          h[_] = h[_] || [], h[_].push(y);
        }
        for (var b = o.getLineStyle([
          "color"
        ]), g = 0; g < h.length; ++g) e.add(vi(h[g], {
          style: Ee({
            stroke: s[g % s.length]
          }, b),
          silent: true
        }));
      }
    },
    splitArea: function(t, e, r, n) {
      WG(t, r, n, n);
    }
  }, dg = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.getCoordSysModel = function() {
      return this;
    }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: true,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      tooltip: {
        show: true
      },
      axisTick: {
        show: true,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        interval: "auto"
      },
      splitLine: {
        show: true,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, e;
  }(vt);
  yr(dg, Fd.prototype);
  var Ude = function(t) {
    K(e, t);
    function e(r, n, i, a, o) {
      var s = t.call(this, r, n, i) || this;
      return s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var r = this.position;
      return r === "top" || r === "bottom";
    }, e.prototype.pointToData = function(r, n) {
      return this.coordinateSystem.pointToData(r)[0];
    }, e;
  }(Ji), SH = [
    "single"
  ], Yde = function() {
    function t(e, r, n) {
      this.type = "single", this.dimension = "single", this.dimensions = SH, this.axisPointerEnabled = true, this.model = e, this._init(e, r, n);
    }
    return t.prototype._init = function(e, r, n) {
      var i = this.dimension, a = new Ude(i, fy(e), [
        0,
        0
      ], e.get("type"), e.get("position")), o = a.type === "category";
      a.onBand = o && e.get("boundaryGap"), a.inverse = e.get("inverse"), a.orient = e.get("orient"), e.axis = a, a.model = e, a.coordinateSystem = this, this._axis = a;
    }, t.prototype.update = function(e, r) {
      e.eachSeries(function(n) {
        if (n.coordinateSystem === this) {
          var i = n.getData();
          $(i.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(i, a);
          }, this), xc(this._axis.scale, this._axis.model);
        }
      }, this);
    }, t.prototype.resize = function(e, r) {
      this._rect = Tr({
        left: e.get("left"),
        top: e.get("top"),
        right: e.get("right"),
        bottom: e.get("bottom"),
        width: e.get("width"),
        height: e.get("height")
      }, {
        width: r.getWidth(),
        height: r.getHeight()
      }), this._adjustAxis();
    }, t.prototype.getRect = function() {
      return this._rect;
    }, t.prototype._adjustAxis = function() {
      var e = this._rect, r = this._axis, n = r.isHorizontal(), i = n ? [
        0,
        e.width
      ] : [
        0,
        e.height
      ], a = r.inverse ? 1 : 0;
      r.setExtent(i[a], i[1 - a]), this._updateAxisTransform(r, n ? e.x : e.y);
    }, t.prototype._updateAxisTransform = function(e, r) {
      var n = e.getExtent(), i = n[0] + n[1], a = e.isHorizontal();
      e.toGlobalCoord = a ? function(o) {
        return o + r;
      } : function(o) {
        return i - o + r;
      }, e.toLocalCoord = a ? function(o) {
        return o - r;
      } : function(o) {
        return i - o + r;
      };
    }, t.prototype.getAxis = function() {
      return this._axis;
    }, t.prototype.getBaseAxis = function() {
      return this._axis;
    }, t.prototype.getAxes = function() {
      return [
        this._axis
      ];
    }, t.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [
          this.getAxis()
        ],
        otherAxes: []
      };
    }, t.prototype.containPoint = function(e) {
      var r = this.getRect(), n = this.getAxis(), i = n.orient;
      return i === "horizontal" ? n.contain(n.toLocalCoord(e[0])) && e[1] >= r.y && e[1] <= r.y + r.height : n.contain(n.toLocalCoord(e[1])) && e[0] >= r.y && e[0] <= r.y + r.height;
    }, t.prototype.pointToData = function(e) {
      var r = this.getAxis();
      return [
        r.coordToData(r.toLocalCoord(e[r.orient === "horizontal" ? 0 : 1]))
      ];
    }, t.prototype.dataToPoint = function(e) {
      var r = this.getAxis(), n = this.getRect(), i = [], a = r.orient === "horizontal" ? 0 : 1;
      return e instanceof Array && (e = e[0]), i[a] = r.toGlobalCoord(r.dataToCoord(+e)), i[1 - a] = a === 0 ? n.y + n.height / 2 : n.x + n.width / 2, i;
    }, t.prototype.convertToPixel = function(e, r, n) {
      var i = qL(r);
      return i === this ? this.dataToPoint(n) : null;
    }, t.prototype.convertFromPixel = function(e, r, n) {
      var i = qL(r);
      return i === this ? this.pointToData(n) : null;
    }, t;
  }();
  function qL(t) {
    var e = t.seriesModel, r = t.singleAxisModel;
    return r && r.coordinateSystem || e && e.coordinateSystem;
  }
  function qde(t, e) {
    var r = [];
    return t.eachComponent("singleAxis", function(n, i) {
      var a = new Yde(n, t, e);
      a.name = "single_" + i, a.resize(n, e), n.coordinateSystem = a, r.push(a);
    }), t.eachSeries(function(n) {
      if (n.get("coordinateSystem") === "singleAxis") {
        var i = n.getReferringComponents("singleAxis", gr).models[0];
        n.coordinateSystem = i && i.coordinateSystem;
      }
    }), r;
  }
  var Xde = {
    create: qde,
    dimensions: SH
  }, XL = [
    "x",
    "y"
  ], jde = [
    "width",
    "height"
  ], Kde = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(r, n, i, a, o) {
      var s = i.axis, l = s.coordinateSystem, u = Q_(l, 1 - om(s)), c = l.dataToPoint(n)[0], h = a.get("type");
      if (h && h !== "none") {
        var f = L2(a), d = Zde[h](s, c, u);
        d.style = f, r.graphicKey = d.type, r.pointer = d;
      }
      var p = Mw(i);
      gH(n, r, p, i, a, o);
    }, e.prototype.getHandleTransform = function(r, n, i) {
      var a = Mw(n, {
        labelInside: false
      });
      a.labelMargin = i.get([
        "handle",
        "margin"
      ]);
      var o = $2(n.axis, r, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(r, n, i, a) {
      var o = i.axis, s = o.coordinateSystem, l = om(o), u = Q_(s, l), c = [
        r.x,
        r.y
      ];
      c[l] += n[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var h = Q_(s, 1 - l), f = (h[1] + h[0]) / 2, d = [
        f,
        f
      ];
      return d[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: r.rotation,
        cursorPoint: d,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, e;
  }(P2), Zde = {
    line: function(t, e, r) {
      var n = R2([
        e,
        r[0]
      ], [
        e,
        r[1]
      ], om(t));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: n
      };
    },
    shadow: function(t, e, r) {
      var n = t.getBandWidth(), i = r[1] - r[0];
      return {
        type: "Rect",
        shape: mH([
          e - n / 2,
          r[0]
        ], [
          n,
          i
        ], om(t))
      };
    }
  };
  function om(t) {
    return t.isHorizontal() ? 0 : 1;
  }
  function Q_(t, e) {
    var r = t.getRect();
    return [
      r[XL[e]],
      r[XL[e]] + r[jde[e]]
    ];
  }
  var Qde = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "single", e;
  }(tr);
  function Jde(t) {
    rt(jd), uu.registerAxisPointerClass("SingleAxisPointer", Kde), t.registerComponentView(Qde), t.registerComponentView(Wde), t.registerComponentModel(dg), Sc(t, "single", dg, dg.defaultOption), t.registerCoordinateSystem("single", Xde);
  }
  var epe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r, n, i) {
      var a = Yc(r);
      t.prototype.init.apply(this, arguments), jL(r, a);
    }, e.prototype.mergeOption = function(r) {
      t.prototype.mergeOption.apply(this, arguments), jL(this.option, r);
    }, e.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, e.type = "calendar", e.defaultOption = {
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: "horizontal",
      splitLine: {
        show: true,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      dayLabel: {
        show: true,
        firstDay: 0,
        position: "start",
        margin: "50%",
        color: "#000"
      },
      monthLabel: {
        show: true,
        position: "start",
        margin: 5,
        align: "center",
        formatter: null,
        color: "#000"
      },
      yearLabel: {
        show: true,
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, e;
  }(vt);
  function jL(t, e) {
    var r = t.cellSize, n;
    ae(r) ? n = r : n = t.cellSize = [
      r,
      r
    ], n.length === 1 && (n[1] = n[0]);
    var i = oe([
      0,
      1
    ], function(a) {
      return bee(e, a) && (n[a] = "auto"), n[a] != null && n[a] !== "auto";
    });
    ps(t, e, {
      type: "box",
      ignoreSize: i
    });
  }
  var tpe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      var a = this.group;
      a.removeAll();
      var o = r.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = n.getLocaleModel();
      this._renderDayRect(r, s, a), this._renderLines(r, s, l, a), this._renderYearText(r, s, l, a), this._renderMonthText(r, u, l, a), this._renderWeekText(r, u, s, l, a);
    }, e.prototype._renderDayRect = function(r, n, i) {
      for (var a = r.coordinateSystem, o = r.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = n.start.time; u <= n.end.time; u = a.getNextNDay(u, 1).time) {
        var c = a.dataToRect([
          u
        ], false).tl, h = new yt({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: o
        });
        i.add(h);
      }
    }, e.prototype._renderLines = function(r, n, i, a) {
      var o = this, s = r.coordinateSystem, l = r.getModel([
        "splitLine",
        "lineStyle"
      ]).getLineStyle(), u = r.get([
        "splitLine",
        "show"
      ]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var h = n.start, f = 0; h.time <= n.end.time; f++) {
        p(h.formatedDate), f === 0 && (h = s.getDateInfo(n.start.y + "-" + n.start.m));
        var d = h.date;
        d.setMonth(d.getMonth() + 1), h = s.getDateInfo(d);
      }
      p(s.getNextNDay(n.end.time, 1).formatedDate);
      function p(v) {
        o._firstDayOfMonth.push(s.getDateInfo(v)), o._firstDayPoints.push(s.dataToRect([
          v
        ], false).tl);
        var g = o._getLinePointsOfOneWeek(r, v, i);
        o._tlpoints.push(g[0]), o._blpoints.push(g[g.length - 1]), u && o._drawSplitline(g, l, a);
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, c, i), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, c, i), l, a);
    }, e.prototype._getEdgesPoints = function(r, n, i) {
      var a = [
        r[0].slice(),
        r[r.length - 1].slice()
      ], o = i === "horizontal" ? 0 : 1;
      return a[0][o] = a[0][o] - n / 2, a[1][o] = a[1][o] + n / 2, a;
    }, e.prototype._drawSplitline = function(r, n, i) {
      var a = new Tn({
        z2: 20,
        shape: {
          points: r
        },
        style: n
      });
      i.add(a);
    }, e.prototype._getLinePointsOfOneWeek = function(r, n, i) {
      for (var a = r.coordinateSystem, o = a.getDateInfo(n), s = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(o.time, l), c = a.dataToRect([
          u.time
        ], false);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, e.prototype._formatterLabel = function(r, n) {
      return me(r) && r ? mee(r, n) : De(r) ? r(n) : n.nameMap;
    }, e.prototype._yearTextPositionControl = function(r, n, i, a, o) {
      var s = n[0], l = n[1], u = [
        "center",
        "bottom"
      ];
      a === "bottom" ? (l += o, u = [
        "center",
        "top"
      ]) : a === "left" ? s -= o : a === "right" ? (s += o, u = [
        "center",
        "top"
      ]) : l -= o;
      var c = 0;
      return (a === "left" || a === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, e.prototype._renderYearText = function(r, n, i, a) {
      var o = r.getModel("yearLabel");
      if (o.get("show")) {
        var s = o.get("margin"), l = o.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [
          this._tlpoints[this._tlpoints.length - 1],
          this._blpoints[0]
        ], c = (u[0][0] + u[1][0]) / 2, h = (u[0][1] + u[1][1]) / 2, f = i === "horizontal" ? 0 : 1, d = {
          top: [
            c,
            u[f][1]
          ],
          bottom: [
            c,
            u[1 - f][1]
          ],
          left: [
            u[1 - f][0],
            h
          ],
          right: [
            u[f][0],
            h
          ]
        }, p = n.start.y;
        +n.end.y > +n.start.y && (p = p + "-" + n.end.y);
        var v = o.get("formatter"), g = {
          start: n.start.y,
          end: n.end.y,
          nameMap: p
        }, m = this._formatterLabel(v, g), y = new bt({
          z2: 30,
          style: Yt(o, {
            text: m
          }),
          silent: o.get("silent")
        });
        y.attr(this._yearTextPositionControl(y, d[l], i, l, s)), a.add(y);
      }
    }, e.prototype._monthTextPositionControl = function(r, n, i, a, o) {
      var s = "left", l = "top", u = r[0], c = r[1];
      return i === "horizontal" ? (c = c + o, n && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, n && (l = "middle"), a === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderMonthText = function(r, n, i, a) {
      var o = r.getModel("monthLabel");
      if (o.get("show")) {
        var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), c = o.get("align"), h = [
          this._tlpoints,
          this._blpoints
        ];
        (!s || me(s)) && (s && (n = Ox(s) || n), s = n.get([
          "time",
          "monthAbbr"
        ]) || []);
        var f = u === "start" ? 0 : 1, d = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", v = o.get("silent"), g = 0; g < h[f].length - 1; g++) {
          var m = h[f][g].slice(), y = this._firstDayOfMonth[g];
          if (p) {
            var _ = this._firstDayPoints[g];
            m[d] = (_[d] + h[0][g + 1][d]) / 2;
          }
          var b = o.get("formatter"), w = s[+y.m - 1], x = {
            yyyy: y.y,
            yy: (y.y + "").slice(2),
            MM: y.m,
            M: +y.m,
            nameMap: w
          }, T = this._formatterLabel(b, x), A = new bt({
            z2: 30,
            style: te(Yt(o, {
              text: T
            }), this._monthTextPositionControl(m, p, i, u, l)),
            silent: v
          });
          a.add(A);
        }
      }
    }, e.prototype._weekTextPositionControl = function(r, n, i, a, o) {
      var s = "center", l = "middle", u = r[0], c = r[1], h = i === "start";
      return n === "horizontal" ? (u = u + a + (h ? 1 : -1) * o[0] / 2, s = h ? "right" : "left") : (c = c + a + (h ? 1 : -1) * o[1] / 2, l = h ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderWeekText = function(r, n, i, a, o) {
      var s = r.getModel("dayLabel");
      if (s.get("show")) {
        var l = r.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), h = s.get("margin"), f = l.getFirstDayOfWeek();
        if (!c || me(c)) {
          c && (n = Ox(c) || n);
          var d = n.get([
            "time",
            "dayOfWeekShort"
          ]);
          c = d || oe(n.get([
            "time",
            "dayOfWeekAbbr"
          ]), function(x) {
            return x[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, v = [
          l.getCellWidth(),
          l.getCellHeight()
        ];
        h = pe(h, Math.min(v[1], v[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, h = -h);
        for (var g = s.get("silent"), m = 0; m < 7; m++) {
          var y = l.getNextNDay(p, m), _ = l.dataToRect([
            y.time
          ], false).center, b = m;
          b = Math.abs((m + f) % 7);
          var w = new bt({
            z2: 30,
            style: te(Yt(s, {
              text: c[b]
            }), this._weekTextPositionControl(_, a, u, h, v)),
            silent: g
          });
          o.add(w);
        }
      }
    }, e.type = "calendar", e;
  }(tr), J_ = 864e5, rpe = function() {
    function t(e, r, n) {
      this.type = "calendar", this.dimensions = t.dimensions, this.getDimensionsInfo = t.getDimensionsInfo, this._model = e;
    }
    return t.getDimensionsInfo = function() {
      return [
        {
          name: "time",
          type: "time"
        },
        "value"
      ];
    }, t.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getRect = function() {
      return this._rect;
    }, t.prototype.getCellWidth = function() {
      return this._sw;
    }, t.prototype.getCellHeight = function() {
      return this._sh;
    }, t.prototype.getOrient = function() {
      return this._orient;
    }, t.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, t.prototype.getDateInfo = function(e) {
      e = $a(e);
      var r = e.getFullYear(), n = e.getMonth() + 1, i = n < 10 ? "0" + n : "" + n, a = e.getDate(), o = a < 10 ? "0" + a : "" + a, s = e.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: r + "",
        m: i,
        d: o,
        day: s,
        time: e.getTime(),
        formatedDate: r + "-" + i + "-" + o,
        date: e
      };
    }, t.prototype.getNextNDay = function(e, r) {
      return r = r || 0, r === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + r), this.getDateInfo(e));
    }, t.prototype.update = function(e, r) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var n = this._rangeInfo.weeks || 1, i = [
        "width",
        "height"
      ], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [
        n,
        7
      ] : [
        7,
        n
      ];
      $([
        0,
        1
      ], function(h) {
        c(a, h) && (o[i[h]] = a[h] * s[h]);
      });
      var l = {
        width: r.getWidth(),
        height: r.getHeight()
      }, u = this._rect = Tr(o, l);
      $([
        0,
        1
      ], function(h) {
        c(a, h) || (a[h] = u[i[h]] / s[h]);
      });
      function c(h, f) {
        return h[f] != null && h[f] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, t.prototype.dataToPoint = function(e, r) {
      ae(e) && (e = e[0]), r == null && (r = true);
      var n = this.getDateInfo(e), i = this._rangeInfo, a = n.formatedDate;
      if (r && !(n.time >= i.start.time && n.time < i.end.time + J_)) return [
        NaN,
        NaN
      ];
      var o = n.day, s = this._getRangeInfo([
        i.start.time,
        a
      ]).nthWeek;
      return this._orient === "vertical" ? [
        this._rect.x + o * this._sw + this._sw / 2,
        this._rect.y + s * this._sh + this._sh / 2
      ] : [
        this._rect.x + s * this._sw + this._sw / 2,
        this._rect.y + o * this._sh + this._sh / 2
      ];
    }, t.prototype.pointToData = function(e) {
      var r = this.pointToDate(e);
      return r && r.time;
    }, t.prototype.dataToRect = function(e, r) {
      var n = this.dataToPoint(e, r);
      return {
        contentShape: {
          x: n[0] - (this._sw - this._lineWidth) / 2,
          y: n[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: n,
        tl: [
          n[0] - this._sw / 2,
          n[1] - this._sh / 2
        ],
        tr: [
          n[0] + this._sw / 2,
          n[1] - this._sh / 2
        ],
        br: [
          n[0] + this._sw / 2,
          n[1] + this._sh / 2
        ],
        bl: [
          n[0] - this._sw / 2,
          n[1] + this._sh / 2
        ]
      };
    }, t.prototype.pointToDate = function(e) {
      var r = Math.floor((e[0] - this._rect.x) / this._sw) + 1, n = Math.floor((e[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(n, r - 1, i) : this._getDateByWeeksAndDay(r, n - 1, i);
    }, t.prototype.convertToPixel = function(e, r, n) {
      var i = KL(r);
      return i === this ? i.dataToPoint(n) : null;
    }, t.prototype.convertFromPixel = function(e, r, n) {
      var i = KL(r);
      return i === this ? i.pointToData(n) : null;
    }, t.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), false;
    }, t.prototype._initRangeOption = function() {
      var e = this._model.get("range"), r;
      if (ae(e) && e.length === 1 && (e = e[0]), ae(e)) r = e;
      else {
        var n = e.toString();
        if (/^\d{4}$/.test(n) && (r = [
          n + "-01-01",
          n + "-12-31"
        ]), /^\d{4}[\/|-]\d{1,2}$/.test(n)) {
          var i = this.getDateInfo(n), a = i.date;
          a.setMonth(a.getMonth() + 1);
          var o = this.getNextNDay(a, -1);
          r = [
            i.formatedDate,
            o.formatedDate
          ];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (r = [
          n,
          n
        ]);
      }
      if (!r) return e;
      var s = this._getRangeInfo(r);
      return s.start.time > s.end.time && r.reverse(), r;
    }, t.prototype._getRangeInfo = function(e) {
      var r = [
        this.getDateInfo(e[0]),
        this.getDateInfo(e[1])
      ], n;
      r[0].time > r[1].time && (n = true, r.reverse());
      var i = Math.floor(r[1].time / J_) - Math.floor(r[0].time / J_) + 1, a = new Date(r[0].time), o = a.getDate(), s = r[1].date.getDate();
      a.setDate(o + i - 1);
      var l = a.getDate();
      if (l !== s) for (var u = a.getTime() - r[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - r[1].time) * u > 0; ) i -= u, a.setDate(l - u);
      var c = Math.floor((i + r[0].day + 6) / 7), h = n ? -c + 1 : c - 1;
      return n && r.reverse(), {
        range: [
          r[0].formatedDate,
          r[1].formatedDate
        ],
        start: r[0],
        end: r[1],
        allDay: i,
        weeks: c,
        nthWeek: h,
        fweek: r[0].day,
        lweek: r[1].day
      };
    }, t.prototype._getDateByWeeksAndDay = function(e, r, n) {
      var i = this._getRangeInfo(n);
      if (e > i.weeks || e === 0 && r < i.fweek || e === i.weeks && r > i.lweek) return null;
      var a = (e - 1) * 7 - i.fweek + r, o = new Date(i.start.time);
      return o.setDate(+i.start.d + a), this.getDateInfo(o);
    }, t.create = function(e, r) {
      var n = [];
      return e.eachComponent("calendar", function(i) {
        var a = new t(i);
        n.push(a), i.coordinateSystem = a;
      }), e.eachSeries(function(i) {
        i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = n[i.get("calendarIndex") || 0]);
      }), n;
    }, t.dimensions = [
      "time",
      "value"
    ], t;
  }();
  function KL(t) {
    var e = t.calendarModel, r = t.seriesModel, n = e ? e.coordinateSystem : r ? r.coordinateSystem : null;
    return n;
  }
  function npe(t) {
    t.registerComponentModel(epe), t.registerComponentView(tpe), t.registerCoordinateSystem("calendar", rpe);
  }
  function ipe(t, e) {
    var r = t.existing;
    if (e.id = t.keyInfo.id, !e.type && r && (e.type = r.type), e.parentId == null) {
      var n = e.parentOption;
      n ? e.parentId = n.id : r && (e.parentId = r.parentId);
    }
    e.parentOption = null;
  }
  function ZL(t, e) {
    var r;
    return $(e, function(n) {
      t[n] != null && t[n] !== "auto" && (r = true);
    }), r;
  }
  function ape(t, e, r) {
    var n = te({}, r), i = t[e], a = r.$action || "merge";
    a === "merge" ? i ? (je(i, n, true), ps(i, n, {
      ignoreSize: true
    }), vV(r, i), sv(r, i), sv(r, i, "shape"), sv(r, i, "style"), sv(r, i, "extra"), r.clipPath = i.clipPath) : t[e] = n : a === "replace" ? t[e] = n : a === "remove" && i && (t[e] = null);
  }
  var TH = [
    "transition",
    "enterFrom",
    "leaveTo"
  ], ope = TH.concat([
    "enterAnimation",
    "updateAnimation",
    "leaveAnimation"
  ]);
  function sv(t, e, r) {
    if (r && (!t[r] && e[r] && (t[r] = {}), t = t[r], e = e[r]), !(!t || !e)) for (var n = r ? TH : ope, i = 0; i < n.length; i++) {
      var a = n[i];
      t[a] == null && e[a] != null && (t[a] = e[a]);
    }
  }
  function spe(t, e) {
    if (t && (t.hv = e.hv = [
      ZL(e, [
        "left",
        "right"
      ]),
      ZL(e, [
        "top",
        "bottom"
      ])
    ], t.type === "group")) {
      var r = t, n = e;
      r.width == null && (r.width = n.width = 0), r.height == null && (r.height = n.height = 0);
    }
  }
  var lpe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.preventAutoZ = true, r;
    }
    return e.prototype.mergeOption = function(r, n) {
      var i = this.option.elements;
      this.option.elements = null, t.prototype.mergeOption.call(this, r, n), this.option.elements = i;
    }, e.prototype.optionUpdated = function(r, n) {
      var i = this.option, a = (n ? i : r).elements, o = i.elements = n ? [] : i.elements, s = [];
      this._flatten(a, s, null);
      var l = h4(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      $(l, function(c, h) {
        var f = c.newOption;
        f && (u.push(f), ipe(c, f), ape(o, h, f), spe(o[h], f));
      }, this), i.elements = Dt(o, function(c) {
        return c && delete c.$action, c != null;
      });
    }, e.prototype._flatten = function(r, n, i) {
      $(r, function(a) {
        if (a) {
          i && (a.parentOption = i), n.push(a);
          var o = a.children;
          o && o.length && this._flatten(o, n, a), delete a.children;
        }
      }, this);
    }, e.prototype.useElOptionsToUpdate = function() {
      var r = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, r;
    }, e.type = "graphic", e.defaultOption = {
      elements: []
    }, e;
  }(vt), QL = {
    path: null,
    compoundPath: null,
    group: Be,
    image: Gr,
    text: bt
  }, hi = _t(), upe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function() {
      this._elMap = Ce();
    }, e.prototype.render = function(r, n, i) {
      r !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = r, this._updateElements(r), this._relocate(r, i);
    }, e.prototype._updateElements = function(r) {
      var n = r.useElOptionsToUpdate();
      if (n) {
        var i = this._elMap, a = this.group, o = r.get("z"), s = r.get("zlevel");
        $(n, function(l) {
          var u = xr(l.id, null), c = u != null ? i.get(u) : null, h = xr(l.parentId, null), f = h != null ? i.get(h) : a, d = l.type, p = l.style;
          d === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var v = l.textContent, g = l.textConfig;
          if (p && iH(p, d, !!g, !!v)) {
            var m = aH(p, d, true);
            !g && m.textConfig && (g = l.textConfig = m.textConfig), !v && m.textContent && (v = m.textContent);
          }
          var y = cpe(l), _ = l.$action || "merge", b = _ === "merge", w = _ === "replace";
          if (b) {
            var x = !c, T = c;
            x ? T = JL(u, f, l.type, i) : (T && (hi(T).isNew = false), uH(T)), T && (hg(T, y, r, {
              isInit: x
            }), e$(T, l, o, s));
          } else if (w) {
            pg(c, l, i, r);
            var A = JL(u, f, l.type, i);
            A && (hg(A, y, r, {
              isInit: true
            }), e$(A, l, o, s));
          } else _ === "remove" && (sH(c, l), pg(c, l, i, r));
          var I = i.get(u);
          if (I && v) if (b) {
            var M = I.getTextContent();
            M ? M.attr(v) : I.setTextContent(new bt(v));
          } else w && I.setTextContent(new bt(v));
          if (I) {
            var k = l.clipPath;
            if (k) {
              var B = k.type, L = void 0, x = false;
              if (b) {
                var z = I.getClipPath();
                x = !z || hi(z).type !== B, L = x ? Dw(B) : z;
              } else w && (x = true, L = Dw(B));
              I.setClipPath(L), hg(L, k, r, {
                isInit: x
              }), im(L, k.keyframeAnimation, r);
            }
            var F = hi(I);
            I.setTextConfig(g), F.option = l, hpe(I, r, l), iu({
              el: I,
              componentModel: r,
              itemName: I.name,
              itemTooltipOption: l.tooltip
            }), im(I, l.keyframeAnimation, r);
          }
        });
      }
    }, e.prototype._relocate = function(r, n) {
      for (var i = r.option.elements, a = this.group, o = this._elMap, s = n.getWidth(), l = n.getHeight(), u = [
        "x",
        "y"
      ], c = 0; c < i.length; c++) {
        var h = i[c], f = xr(h.id, null), d = f != null ? o.get(f) : null;
        if (!(!d || !d.isGroup)) {
          var p = d.parent, v = p === a, g = hi(d), m = hi(p);
          g.width = pe(g.option.width, v ? s : m.width) || 0, g.height = pe(g.option.height, v ? l : m.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var h = i[c], f = xr(h.id, null), d = f != null ? o.get(f) : null;
        if (d) {
          var p = d.parent, m = hi(p), y = p === a ? {
            width: s,
            height: l
          } : {
            width: m.width,
            height: m.height
          }, _ = {}, b = ny(d, h, y, null, {
            hv: h.hv,
            boundingMode: h.bounding
          }, _);
          if (!hi(d).isNew && b) {
            for (var w = h.transition, x = {}, T = 0; T < u.length; T++) {
              var A = u[T], I = _[A];
              w && (Vl(w) || et(w, A) >= 0) ? x[A] = I : d[A] = I;
            }
            wt(d, x, r, 0);
          } else d.attr(_);
        }
      }
    }, e.prototype._clear = function() {
      var r = this, n = this._elMap;
      n.each(function(i) {
        pg(i, hi(i).option, n, r._lastGraphicModel);
      }), this._elMap = Ce();
    }, e.prototype.dispose = function() {
      this._clear();
    }, e.type = "graphic", e;
  }(tr);
  function Dw(t) {
    var e = xe(QL, t) ? QL[t] : gT(t), r = new e({});
    return hi(r).type = t, r;
  }
  function JL(t, e, r, n) {
    var i = Dw(r);
    return e.add(i), n.set(t, i), hi(i).id = t, hi(i).isNew = true, i;
  }
  function pg(t, e, r, n) {
    var i = t && t.parent;
    i && (t.type === "group" && t.traverse(function(a) {
      pg(a, e, r, n);
    }), _y(t, e, n), r.removeKey(hi(t).id));
  }
  function e$(t, e, r, n) {
    t.isGroup || $([
      [
        "cursor",
        bi.prototype.cursor
      ],
      [
        "zlevel",
        n || 0
      ],
      [
        "z",
        r || 0
      ],
      [
        "z2",
        0
      ]
    ], function(i) {
      var a = i[0];
      xe(e, a) ? t[a] = We(e[a], i[1]) : t[a] == null && (t[a] = i[1]);
    }), $(gt(e), function(i) {
      if (i.indexOf("on") === 0) {
        var a = e[i];
        t[i] = De(a) ? a : null;
      }
    }), xe(e, "draggable") && (t.draggable = e.draggable), e.name != null && (t.name = e.name), e.id != null && (t.id = e.id);
  }
  function cpe(t) {
    return t = te({}, t), $([
      "id",
      "parentId",
      "$action",
      "hv",
      "bounding",
      "textContent",
      "clipPath"
    ].concat(pV), function(e) {
      delete t[e];
    }), t;
  }
  function hpe(t, e, r) {
    var n = Ge(t).eventData;
    !t.silent && !t.ignore && !n && (n = Ge(t).eventData = {
      componentType: "graphic",
      componentIndex: e.componentIndex,
      name: t.name
    }), n && (n.info = r.info);
  }
  function fpe(t) {
    t.registerComponentModel(lpe), t.registerComponentView(upe), t.registerPreprocessor(function(e) {
      var r = e.graphic;
      ae(r) ? !r[0] || !r[0].elements ? e.graphic = [
        {
          elements: r
        }
      ] : e.graphic = [
        e.graphic[0]
      ] : r && !r.elements && (e.graphic = [
        {
          elements: [
            r
          ]
        }
      ]);
    });
  }
  var t$ = [
    "x",
    "y",
    "radius",
    "angle",
    "single"
  ], dpe = [
    "cartesian2d",
    "polar",
    "singleAxis"
  ];
  function ppe(t) {
    var e = t.get("coordinateSystem");
    return et(dpe, e) >= 0;
  }
  function ns(t) {
    return t + "Axis";
  }
  function vpe(t, e) {
    var r = Ce(), n = [], i = Ce();
    t.eachComponent({
      mainType: "dataZoom",
      query: e
    }, function(c) {
      i.get(c.uid) || s(c);
    });
    var a;
    do
      a = false, t.eachComponent("dataZoom", o);
    while (a);
    function o(c) {
      !i.get(c.uid) && l(c) && (s(c), a = true);
    }
    function s(c) {
      i.set(c.uid, true), n.push(c), u(c);
    }
    function l(c) {
      var h = false;
      return c.eachTargetAxis(function(f, d) {
        var p = r.get(f);
        p && p[d] && (h = true);
      }), h;
    }
    function u(c) {
      c.eachTargetAxis(function(h, f) {
        (r.get(h) || r.set(h, []))[f] = true;
      });
    }
    return n;
  }
  function CH(t) {
    var e = t.ecModel, r = {
      infoList: [],
      infoMap: Ce()
    };
    return t.eachTargetAxis(function(n, i) {
      var a = e.getComponent(ns(n), i);
      if (a) {
        var o = a.getCoordSysModel();
        if (o) {
          var s = o.uid, l = r.infoMap.get(s);
          l || (l = {
            model: o,
            axisModels: []
          }, r.infoList.push(l), r.infoMap.set(s, l)), l.axisModels.push(a);
        }
      }
    }), r;
  }
  var eb = function() {
    function t() {
      this.indexList = [], this.indexMap = [];
    }
    return t.prototype.add = function(e) {
      this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = true);
    }, t;
  }(), fd = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._autoThrottle = true, r._noTarget = true, r._rangePropMode = [
        "percent",
        "percent"
      ], r;
    }
    return e.prototype.init = function(r, n, i) {
      var a = r$(r);
      this.settledOption = a, this.mergeDefaultAndTheme(r, i), this._doInit(a);
    }, e.prototype.mergeOption = function(r) {
      var n = r$(r);
      je(this.option, r, true), je(this.settledOption, n, true), this._doInit(n);
    }, e.prototype._doInit = function(r) {
      var n = this.option;
      this._setDefaultThrottle(r), this._updateRangeUse(r);
      var i = this.settledOption;
      $([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a, o) {
        this._rangePropMode[o] === "value" && (n[a[0]] = i[a[0]] = null);
      }, this), this._resetTarget();
    }, e.prototype._resetTarget = function() {
      var r = this.get("orient", true), n = this._targetAxisInfoMap = Ce(), i = this._fillSpecifiedTargetAxis(n);
      i ? this._orient = r || this._makeAutoOrientByTargetAxis() : (this._orient = r || "horizontal", this._fillAutoTargetAxisByOrient(n, this._orient)), this._noTarget = true, n.each(function(a) {
        a.indexList.length && (this._noTarget = false);
      }, this);
    }, e.prototype._fillSpecifiedTargetAxis = function(r) {
      var n = false;
      return $(t$, function(i) {
        var a = this.getReferringComponents(ns(i), oQ);
        if (a.specified) {
          n = true;
          var o = new eb();
          $(a.models, function(s) {
            o.add(s.componentIndex);
          }), r.set(i, o);
        }
      }, this), n;
    }, e.prototype._fillAutoTargetAxisByOrient = function(r, n) {
      var i = this.ecModel, a = true;
      if (a) {
        var o = n === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: o + "Axis"
        });
        l(s, o);
      }
      if (a) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", true) === n;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var h = u[0];
        if (h) {
          var f = new eb();
          if (f.add(h.componentIndex), r.set(c, f), a = false, c === "x" || c === "y") {
            var d = h.getReferringComponents("grid", gr).models[0];
            d && $(u, function(p) {
              h.componentIndex !== p.componentIndex && d === p.getReferringComponents("grid", gr).models[0] && f.add(p.componentIndex);
            });
          }
        }
      }
      a && $(t$, function(u) {
        if (a) {
          var c = i.findComponents({
            mainType: ns(u),
            filter: function(f) {
              return f.get("type", true) === "category";
            }
          });
          if (c[0]) {
            var h = new eb();
            h.add(c[0].componentIndex), r.set(u, h), a = false;
          }
        }
      }, this);
    }, e.prototype._makeAutoOrientByTargetAxis = function() {
      var r;
      return this.eachTargetAxis(function(n) {
        !r && (r = n);
      }, this), r === "y" ? "vertical" : "horizontal";
    }, e.prototype._setDefaultThrottle = function(r) {
      if (r.hasOwnProperty("throttle") && (this._autoThrottle = false), this._autoThrottle) {
        var n = this.ecModel.option;
        this.option.throttle = n.animation && n.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, e.prototype._updateRangeUse = function(r) {
      var n = this._rangePropMode, i = this.get("rangeMode");
      $([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a, o) {
        var s = r[a[0]] != null, l = r[a[1]] != null;
        s && !l ? n[o] = "percent" : !s && l ? n[o] = "value" : i ? n[o] = i[o] : s && (n[o] = "percent");
      });
    }, e.prototype.noTarget = function() {
      return this._noTarget;
    }, e.prototype.getFirstTargetAxisModel = function() {
      var r;
      return this.eachTargetAxis(function(n, i) {
        r == null && (r = this.ecModel.getComponent(ns(n), i));
      }, this), r;
    }, e.prototype.eachTargetAxis = function(r, n) {
      this._targetAxisInfoMap.each(function(i, a) {
        $(i.indexList, function(o) {
          r.call(n, a, o);
        });
      });
    }, e.prototype.getAxisProxy = function(r, n) {
      var i = this.getAxisModel(r, n);
      if (i) return i.__dzAxisProxy;
    }, e.prototype.getAxisModel = function(r, n) {
      var i = this._targetAxisInfoMap.get(r);
      if (i && i.indexMap[n]) return this.ecModel.getComponent(ns(r), n);
    }, e.prototype.setRawRange = function(r) {
      var n = this.option, i = this.settledOption;
      $([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a) {
        (r[a[0]] != null || r[a[1]] != null) && (n[a[0]] = i[a[0]] = r[a[0]], n[a[1]] = i[a[1]] = r[a[1]]);
      }, this), this._updateRangeUse(r);
    }, e.prototype.setCalculatedRange = function(r) {
      var n = this.option;
      $([
        "start",
        "startValue",
        "end",
        "endValue"
      ], function(i) {
        n[i] = r[i];
      });
    }, e.prototype.getPercentRange = function() {
      var r = this.findRepresentativeAxisProxy();
      if (r) return r.getDataPercentWindow();
    }, e.prototype.getValueRange = function(r, n) {
      if (r == null && n == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i) return i.getDataValueWindow();
      } else return this.getAxisProxy(r, n).getDataValueWindow();
    }, e.prototype.findRepresentativeAxisProxy = function(r) {
      if (r) return r.__dzAxisProxy;
      for (var n, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++) for (var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
        var u = this.getAxisProxy(o, s.indexList[l]);
        if (u.hostedBy(this)) return u;
        n || (n = u);
      }
      return n;
    }, e.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, e.prototype.getOrient = function() {
      return this._orient;
    }, e.type = "dataZoom", e.dependencies = [
      "xAxis",
      "yAxis",
      "radiusAxis",
      "angleAxis",
      "singleAxis",
      "series",
      "toolbox"
    ], e.defaultOption = {
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, e;
  }(vt);
  function r$(t) {
    var e = {};
    return $([
      "start",
      "end",
      "startValue",
      "endValue",
      "throttle"
    ], function(r) {
      t.hasOwnProperty(r) && (e[r] = t[r]);
    }), e;
  }
  var gpe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "dataZoom.select", e;
  }(fd), z2 = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i, a) {
      this.dataZoomModel = r, this.ecModel = n, this.api = i;
    }, e.type = "dataZoom", e;
  }(tr), mpe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "dataZoom.select", e;
  }(z2), Xu = $, n$ = mi, ype = function() {
    function t(e, r, n, i) {
      this._dimName = e, this._axisIndex = r, this.ecModel = i, this._dataZoomModel = n;
    }
    return t.prototype.hostedBy = function(e) {
      return this._dataZoomModel === e;
    }, t.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, t.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, t.prototype.getTargetSeriesModels = function() {
      var e = [];
      return this.ecModel.eachSeries(function(r) {
        if (ppe(r)) {
          var n = ns(this._dimName), i = r.getReferringComponents(n, gr).models[0];
          i && this._axisIndex === i.componentIndex && e.push(r);
        }
      }, this), e;
    }, t.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, t.prototype.getMinMaxSpan = function() {
      return Oe(this._minMaxSpan);
    }, t.prototype.calculateDataWindow = function(e) {
      var r = this._dataExtent, n = this.getAxisModel(), i = n.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [
        0,
        100
      ], s = [], l = [], u;
      Xu([
        "start",
        "end"
      ], function(f, d) {
        var p = e[f], v = e[f + "Value"];
        a[d] === "percent" ? (p == null && (p = o[d]), v = i.parse(Et(p, o, r))) : (u = true, v = v == null ? r[d] : i.parse(v), p = Et(v, r, o)), l[d] = v == null || isNaN(v) ? r[d] : v, s[d] = p == null || isNaN(p) ? o[d] : p;
      }), n$(l), n$(s);
      var c = this._minMaxSpan;
      u ? h(l, s, r, o, false) : h(s, l, o, r, true);
      function h(f, d, p, v, g) {
        var m = g ? "Span" : "ValueSpan";
        cu(0, f, p, "all", c["min" + m], c["max" + m]);
        for (var y = 0; y < 2; y++) d[y] = Et(f[y], p, v, true), g && (d[y] = i.parse(d[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, t.prototype.reset = function(e) {
      if (e === this._dataZoomModel) {
        var r = this.getTargetSeriesModels();
        this._dataExtent = _pe(this, this._dimName, r), this._updateMinMaxSpan();
        var n = this.calculateDataWindow(e.settledOption);
        this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, this._setAxisModel();
      }
    }, t.prototype.filterData = function(e, r) {
      if (e !== this._dataZoomModel) return;
      var n = this._dimName, i = this.getTargetSeriesModels(), a = e.get("filterMode"), o = this._valueWindow;
      if (a === "none") return;
      Xu(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(n);
        if (c.length) {
          if (a === "weakFilter") {
            var h = u.getStore(), f = oe(c, function(d) {
              return u.getDimensionIndex(d);
            }, u);
            u.filterSelf(function(d) {
              for (var p, v, g, m = 0; m < c.length; m++) {
                var y = h.get(f[m], d), _ = !isNaN(y), b = y < o[0], w = y > o[1];
                if (_ && !b && !w) return true;
                _ && (g = true), b && (p = true), w && (v = true);
              }
              return g && p && v;
            });
          } else Xu(c, function(d) {
            if (a === "empty") l.setData(u = u.map(d, function(v) {
              return s(v) ? v : NaN;
            }));
            else {
              var p = {};
              p[d] = o, u.selectRange(p);
            }
          });
          Xu(c, function(d) {
            u.setApproximateExtent(o, d);
          });
        }
      });
      function s(l) {
        return l >= o[0] && l <= o[1];
      }
    }, t.prototype._updateMinMaxSpan = function() {
      var e = this._minMaxSpan = {}, r = this._dataZoomModel, n = this._dataExtent;
      Xu([
        "min",
        "max"
      ], function(i) {
        var a = r.get(i + "Span"), o = r.get(i + "ValueSpan");
        o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = Et(n[0] + o, n, [
          0,
          100
        ], true) : a != null && (o = Et(a, [
          0,
          100
        ], n, true) - n[0]), e[i + "Span"] = a, e[i + "ValueSpan"] = o;
      }, this);
    }, t.prototype._setAxisModel = function() {
      var e = this.getAxisModel(), r = this._percentWindow, n = this._valueWindow;
      if (r) {
        var i = n4(n, [
          0,
          500
        ]);
        i = Math.min(i, 20);
        var a = e.axis.scale.rawExtentInfo;
        r[0] !== 0 && a.setDeterminedMinMax("min", +n[0].toFixed(i)), r[1] !== 100 && a.setDeterminedMinMax("max", +n[1].toFixed(i)), a.freeze();
      }
    }, t;
  }();
  function _pe(t, e, r) {
    var n = [
      1 / 0,
      -1 / 0
    ];
    Xu(r, function(o) {
      Qne(n, o.getData(), e);
    });
    var i = t.getAxisModel(), a = W5(i.axis.scale, i, n).calculate();
    return [
      a.min,
      a.max
    ];
  }
  var bpe = {
    getTargetSeries: function(t) {
      function e(i) {
        t.eachComponent("dataZoom", function(a) {
          a.eachTargetAxis(function(o, s) {
            var l = t.getComponent(ns(o), s);
            i(o, s, l, a);
          });
        });
      }
      e(function(i, a, o, s) {
        o.__dzAxisProxy = null;
      });
      var r = [];
      e(function(i, a, o, s) {
        o.__dzAxisProxy || (o.__dzAxisProxy = new ype(i, a, s, t), r.push(o.__dzAxisProxy));
      });
      var n = Ce();
      return $(r, function(i) {
        $(i.getTargetSeriesModels(), function(a) {
          n.set(a.uid, a);
        });
      }), n;
    },
    overallReset: function(t, e) {
      t.eachComponent("dataZoom", function(r) {
        r.eachTargetAxis(function(n, i) {
          r.getAxisProxy(n, i).reset(r);
        }), r.eachTargetAxis(function(n, i) {
          r.getAxisProxy(n, i).filterData(r, e);
        });
      }), t.eachComponent("dataZoom", function(r) {
        var n = r.findRepresentativeAxisProxy();
        if (n) {
          var i = n.getDataPercentWindow(), a = n.getDataValueWindow();
          r.setCalculatedRange({
            start: i[0],
            end: i[1],
            startValue: a[0],
            endValue: a[1]
          });
        }
      });
    }
  };
  function xpe(t) {
    t.registerAction("dataZoom", function(e, r) {
      var n = vpe(r, e);
      $(n, function(i) {
        i.setRawRange({
          start: e.start,
          end: e.end,
          startValue: e.startValue,
          endValue: e.endValue
        });
      });
    });
  }
  var i$ = false;
  function F2(t) {
    i$ || (i$ = true, t.registerProcessor(t.PRIORITY.PROCESSOR.FILTER, bpe), xpe(t), t.registerSubTypeDefaulter("dataZoom", function() {
      return "slider";
    }));
  }
  function wpe(t) {
    t.registerComponentModel(gpe), t.registerComponentView(mpe), F2(t);
  }
  var di = /* @__PURE__ */ function() {
    function t() {
    }
    return t;
  }(), AH = {};
  function ju(t, e) {
    AH[t] = e;
  }
  function IH(t) {
    return AH[t];
  }
  var Spe = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.optionUpdated = function() {
      t.prototype.optionUpdated.apply(this, arguments);
      var r = this.ecModel;
      $(this.option.feature, function(n, i) {
        var a = IH(i);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(r)), je(n, a.defaultOption));
      });
    }, e.type = "toolbox", e.layoutMode = {
      type: "box",
      ignoreSize: true
    }, e.defaultOption = {
      show: true,
      z: 6,
      orient: "horizontal",
      left: "right",
      top: "top",
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: true,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      tooltip: {
        show: false,
        position: "bottom"
      }
    }, e;
  }(vt);
  function Tpe(t, e, r) {
    var n = e.getBoxLayoutParams(), i = e.get("padding"), a = {
      width: r.getWidth(),
      height: r.getHeight()
    }, o = Tr(n, a, i);
    zl(e.get("orient"), t, e.get("itemGap"), o.width, o.height), ny(t, n, a, i);
  }
  function MH(t, e) {
    var r = Uc(e.get("padding")), n = e.getItemStyle([
      "color",
      "opacity"
    ]);
    return n.fill = e.get("backgroundColor"), t = new yt({
      shape: {
        x: t.x - r[3],
        y: t.y - r[0],
        width: t.width + r[1] + r[3],
        height: t.height + r[0] + r[2],
        r: e.get("borderRadius")
      },
      style: n,
      silent: true,
      z2: -1
    }), t;
  }
  var Cpe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.render = function(r, n, i, a) {
      var o = this.group;
      if (o.removeAll(), !r.get("show")) return;
      var s = +r.get("itemSize"), l = r.get("orient") === "vertical", u = r.get("feature") || {}, c = this._features || (this._features = {}), h = [];
      $(u, function(p, v) {
        h.push(v);
      }), new vo(this._featureNames || [], h).add(f).update(f).remove(Ye(f, null)).execute(), this._featureNames = h;
      function f(p, v) {
        var g = h[p], m = h[v], y = u[g], _ = new kt(y, r, r.ecModel), b;
        if (a && a.newTitle != null && a.featureName === g && (y.title = a.newTitle), g && !m) {
          if (Ape(g)) b = {
            onclick: _.option.onclick,
            featureName: g
          };
          else {
            var w = IH(g);
            if (!w) return;
            b = new w();
          }
          c[g] = b;
        } else if (b = c[m], !b) return;
        b.uid = Hc("toolbox-feature"), b.model = _, b.ecModel = n, b.api = i;
        var x = b instanceof di;
        if (!g && m) {
          x && b.dispose && b.dispose(n, i);
          return;
        }
        if (!_.get("show") || x && b.unusable) {
          x && b.remove && b.remove(n, i);
          return;
        }
        d(_, b, g), _.setIconStatus = function(T, A) {
          var I = this.option, M = this.iconPaths;
          I.iconStatus = I.iconStatus || {}, I.iconStatus[T] = A, M[T] && (A === "emphasis" ? fo : po)(M[T]);
        }, b instanceof di && b.render && b.render(_, n, i, a);
      }
      function d(p, v, g) {
        var m = p.getModel("iconStyle"), y = p.getModel([
          "emphasis",
          "iconStyle"
        ]), _ = v instanceof di && v.getIcons ? v.getIcons() : p.get("icon"), b = p.get("title") || {}, w, x;
        me(_) ? (w = {}, w[g] = _) : w = _, me(b) ? (x = {}, x[g] = b) : x = b;
        var T = p.iconPaths = {};
        $(w, function(A, I) {
          var M = Od(A, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          M.setStyle(m.getItemStyle());
          var k = M.ensureState("emphasis");
          k.style = y.getItemStyle();
          var B = new bt({
            style: {
              text: x[I],
              align: y.get("textAlign"),
              borderRadius: y.get("textBorderRadius"),
              padding: y.get("textPadding"),
              fill: null,
              font: mT({
                fontStyle: y.get("textFontStyle"),
                fontFamily: y.get("textFontFamily"),
                fontSize: y.get("textFontSize"),
                fontWeight: y.get("textFontWeight")
              }, n)
            },
            ignore: true
          });
          M.setTextContent(B), iu({
            el: M,
            componentModel: r,
            itemName: I,
            formatterParamsExtra: {
              title: x[I]
            }
          }), M.__title = x[I], M.on("mouseover", function() {
            var L = y.getItemStyle(), z = l ? r.get("right") == null && r.get("left") !== "right" ? "right" : "left" : r.get("bottom") == null && r.get("top") !== "bottom" ? "bottom" : "top";
            B.setStyle({
              fill: y.get("textFill") || L.fill || L.stroke || "#000",
              backgroundColor: y.get("textBackgroundColor")
            }), M.setTextConfig({
              position: y.get("textPosition") || z
            }), B.ignore = !r.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get([
              "iconStatus",
              I
            ]) !== "emphasis" && i.leaveEmphasis(this), B.hide();
          }), (p.get([
            "iconStatus",
            I
          ]) === "emphasis" ? fo : po)(M), o.add(M), M.on("click", _e(v.onclick, v, n, i, I)), T[I] = M;
        });
      }
      Tpe(o, r, i), o.add(MH(o.getBoundingRect(), r)), l || o.eachChild(function(p) {
        var v = p.__title, g = p.ensureState("emphasis"), m = g.textConfig || (g.textConfig = {}), y = p.getTextContent(), _ = y && y.ensureState("emphasis");
        if (_ && !De(_) && v) {
          var b = _.style || (_.style = {}), w = Dd(v, bt.makeFont(b)), x = p.x + o.x, T = p.y + o.y + s, A = false;
          T + w.height > i.getHeight() && (m.position = "top", A = true);
          var I = A ? -5 - w.height : s + 10;
          x + w.width / 2 > i.getWidth() ? (m.position = [
            "100%",
            I
          ], b.align = "right") : x - w.width / 2 < 0 && (m.position = [
            0,
            I
          ], b.align = "left");
        }
      });
    }, e.prototype.updateView = function(r, n, i, a) {
      $(this._features, function(o) {
        o instanceof di && o.updateView && o.updateView(o.model, n, i, a);
      });
    }, e.prototype.remove = function(r, n) {
      $(this._features, function(i) {
        i instanceof di && i.remove && i.remove(r, n);
      }), this.group.removeAll();
    }, e.prototype.dispose = function(r, n) {
      $(this._features, function(i) {
        i instanceof di && i.dispose && i.dispose(r, n);
      });
    }, e.type = "toolbox", e;
  }(tr);
  function Ape(t) {
    return t.indexOf("my") === 0;
  }
  var Ipe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(r, n) {
      var i = this.model, a = i.get("name") || r.get("title.0.text") || "echarts", o = n.getZr().painter.getType() === "svg", s = o ? "svg" : i.get("type", true) || "png", l = n.getConnectedDataURL({
        type: s,
        backgroundColor: i.get("backgroundColor", true) || r.get("backgroundColor") || "#fff",
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = ct.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = a + "." + s, c.target = "_blank", c.href = l;
        var h = new MouseEvent("click", {
          view: document.defaultView,
          bubbles: true,
          cancelable: false
        });
        c.dispatchEvent(h);
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var f = l.split(","), d = f[0].indexOf("base64") > -1, p = o ? decodeURIComponent(f[1]) : f[1];
        d && (p = window.atob(p));
        var v = a + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var g = p.length, m = new Uint8Array(g); g--; ) m[g] = p.charCodeAt(g);
          var y = new Blob([
            m
          ]);
          window.navigator.msSaveOrOpenBlob(y, v);
        } else {
          var _ = document.createElement("iframe");
          document.body.appendChild(_);
          var b = _.contentWindow, w = b.document;
          w.open("image/svg+xml", "replace"), w.write(p), w.close(), b.focus(), w.execCommand("SaveAs", true, v), document.body.removeChild(_);
        }
      } else {
        var x = i.get("lang"), T = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (x && x[0] || "") + '" /></body>', A = window.open();
        A.document.write(T), A.document.title = a;
      }
    }, e.getDefaultOption = function(r) {
      var n = {
        show: true,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: r.getLocaleModel().get([
          "toolbox",
          "saveAsImage",
          "title"
        ]),
        type: "png",
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: [
          "toolbox"
        ],
        lang: r.getLocaleModel().get([
          "toolbox",
          "saveAsImage",
          "lang"
        ])
      };
      return n;
    }, e;
  }(di), a$ = "__ec_magicType_stack__", Mpe = [
    [
      "line",
      "bar"
    ],
    [
      "stack"
    ]
  ], Dpe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.getIcons = function() {
      var r = this.model, n = r.get("icon"), i = {};
      return $(r.get("type"), function(a) {
        n[a] && (i[a] = n[a]);
      }), i;
    }, e.getDefaultOption = function(r) {
      var n = {
        show: true,
        type: [],
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
        },
        title: r.getLocaleModel().get([
          "toolbox",
          "magicType",
          "title"
        ]),
        option: {},
        seriesIndex: {}
      };
      return n;
    }, e.prototype.onclick = function(r, n, i) {
      var a = this.model, o = a.get([
        "seriesIndex",
        i
      ]);
      if (o$[i]) {
        var s = {
          series: []
        }, l = function(h) {
          var f = h.subType, d = h.id, p = o$[i](f, d, h, a);
          p && (Ee(p, h.option), s.series.push(p));
          var v = h.coordinateSystem;
          if (v && v.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var g = v.getAxesByScale("ordinal")[0];
            if (g) {
              var m = g.dim, y = m + "Axis", _ = h.getReferringComponents(y, gr).models[0], b = _.componentIndex;
              s[y] = s[y] || [];
              for (var w = 0; w <= b; w++) s[y][b] = s[y][b] || {};
              s[y][b].boundaryGap = i === "bar";
            }
          }
        };
        $(Mpe, function(h) {
          et(h, i) >= 0 && $(h, function(f) {
            a.setIconStatus(f, "normal");
          });
        }), a.setIconStatus(i, "emphasis"), r.eachComponent({
          mainType: "series",
          query: o == null ? null : {
            seriesIndex: o
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = je({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get([
          "iconStatus",
          i
        ]) !== "emphasis" && (c = "tiled")), n.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, e;
  }(di), o$ = {
    line: function(t, e, r, n) {
      if (t === "bar") return je({
        id: e,
        type: "line",
        data: r.get("data"),
        stack: r.get("stack"),
        markPoint: r.get("markPoint"),
        markLine: r.get("markLine")
      }, n.get([
        "option",
        "line"
      ]) || {}, true);
    },
    bar: function(t, e, r, n) {
      if (t === "line") return je({
        id: e,
        type: "bar",
        data: r.get("data"),
        stack: r.get("stack"),
        markPoint: r.get("markPoint"),
        markLine: r.get("markLine")
      }, n.get([
        "option",
        "bar"
      ]) || {}, true);
    },
    stack: function(t, e, r, n) {
      var i = r.get("stack") === a$;
      if (t === "line" || t === "bar") return n.setIconStatus("stack", i ? "normal" : "emphasis"), je({
        id: e,
        stack: i ? "" : a$
      }, n.get([
        "option",
        "stack"
      ]) || {}, true);
    }
  };
  Ba({
    type: "changeMagicType",
    event: "magicTypeChanged",
    update: "prepareAndUpdate"
  }, function(t, e) {
    e.mergeOption(t.newOption);
  });
  var by = new Array(60).join("-"), Ac = "	";
  function Epe(t) {
    var e = {}, r = [], n = [];
    return t.eachRawSeries(function(i) {
      var a = i.coordinateSystem;
      if (a && (a.type === "cartesian2d" || a.type === "polar")) {
        var o = a.getBaseAxis();
        if (o.type === "category") {
          var s = o.dim + "_" + o.index;
          e[s] || (e[s] = {
            categoryAxis: o,
            valueAxis: a.getOtherAxis(o),
            series: []
          }, n.push({
            axisDim: o.dim,
            axisIndex: o.index
          })), e[s].series.push(i);
        } else r.push(i);
      } else r.push(i);
    }), {
      seriesGroupByCategoryAxis: e,
      other: r,
      meta: n
    };
  }
  function kpe(t) {
    var e = [];
    return $(t, function(r, n) {
      var i = r.categoryAxis, a = r.valueAxis, o = a.dim, s = [
        " "
      ].concat(oe(r.series, function(d) {
        return d.name;
      })), l = [
        i.model.getCategories()
      ];
      $(r.series, function(d) {
        var p = d.getRawData();
        l.push(d.getRawData().mapArray(p.mapDimension(o), function(v) {
          return v;
        }));
      });
      for (var u = [
        s.join(Ac)
      ], c = 0; c < l[0].length; c++) {
        for (var h = [], f = 0; f < l.length; f++) h.push(l[f][c]);
        u.push(h.join(Ac));
      }
      e.push(u.join(`
`));
    }), e.join(`

` + by + `

`);
  }
  function Ppe(t) {
    return oe(t, function(e) {
      var r = e.getRawData(), n = [
        e.name
      ], i = [];
      return r.each(r.dimensions, function() {
        for (var a = arguments.length, o = arguments[a - 1], s = r.getName(o), l = 0; l < a - 1; l++) i[l] = arguments[l];
        n.push((s ? s + Ac : "") + i.join(Ac));
      }), n.join(`
`);
    }).join(`

` + by + `

`);
  }
  function Lpe(t) {
    var e = Epe(t);
    return {
      value: Dt([
        kpe(e.seriesGroupByCategoryAxis),
        Ppe(e.other)
      ], function(r) {
        return !!r.replace(/[\n\t\s]/g, "");
      }).join(`

` + by + `

`),
      meta: e.meta
    };
  }
  function sm(t) {
    return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function $pe(t) {
    var e = t.slice(0, t.indexOf(`
`));
    if (e.indexOf(Ac) >= 0) return true;
  }
  var Ew = new RegExp("[" + Ac + "]+", "g");
  function Rpe(t) {
    for (var e = t.split(/\n+/g), r = sm(e.shift()).split(Ew), n = [], i = oe(r, function(l) {
      return {
        name: l,
        data: []
      };
    }), a = 0; a < e.length; a++) {
      var o = sm(e[a]).split(Ew);
      n.push(o.shift());
      for (var s = 0; s < o.length; s++) i[s] && (i[s].data[a] = o[s]);
    }
    return {
      series: i,
      categories: n
    };
  }
  function Ope(t) {
    for (var e = t.split(/\n+/g), r = sm(e.shift()), n = [], i = 0; i < e.length; i++) {
      var a = sm(e[i]);
      if (a) {
        var o = a.split(Ew), s = "", l = void 0, u = false;
        isNaN(o[0]) ? (u = true, s = o[0], o = o.slice(1), n[i] = {
          name: s,
          value: []
        }, l = n[i].value) : l = n[i] = [];
        for (var c = 0; c < o.length; c++) l.push(+o[c]);
        l.length === 1 && (u ? n[i].value = l[0] : n[i] = l[0]);
      }
    }
    return {
      name: r,
      data: n
    };
  }
  function Npe(t, e) {
    var r = t.split(new RegExp(`
*` + by + `
*`, "g")), n = {
      series: []
    };
    return $(r, function(i, a) {
      if ($pe(i)) {
        var o = Rpe(i), s = e[a], l = s.axisDim + "Axis";
        s && (n[l] = n[l] || [], n[l][s.axisIndex] = {
          data: o.categories
        }, n.series = n.series.concat(o.series));
      } else {
        var o = Ope(i);
        n.series.push(o);
      }
    }), n;
  }
  var Bpe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(r, n) {
      setTimeout(function() {
        n.dispatchAction({
          type: "hideTip"
        });
      });
      var i = n.getDom(), a = this.model;
      this._dom && i.removeChild(this._dom);
      var o = document.createElement("div");
      o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
      var s = document.createElement("h4"), l = a.get("lang") || [];
      s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var h = a.get("optionToContent"), f = a.get("contentToOption"), d = Lpe(r);
      if (De(h)) {
        var p = h(n.getOption());
        me(p) ? u.innerHTML = p : gc(p) && u.appendChild(p);
      } else {
        c.readOnly = a.get("readOnly");
        var v = c.style;
        v.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", v.color = a.get("textColor"), v.borderColor = a.get("textareaBorderColor"), v.backgroundColor = a.get("textareaColor"), c.value = d.value, u.appendChild(c);
      }
      var g = d.meta, m = document.createElement("div");
      m.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", _ = document.createElement("div"), b = document.createElement("div");
      y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
      var w = this;
      function x() {
        i.removeChild(o), w._dom = null;
      }
      sx(_, "click", x), sx(b, "click", function() {
        if (f == null && h != null || f != null && h == null) {
          x();
          return;
        }
        var T;
        try {
          De(f) ? T = f(u, n.getOption()) : T = Npe(c.value, g);
        } catch (A) {
          throw x(), new Error("Data view format error " + A);
        }
        T && n.dispatchAction({
          type: "changeDataView",
          newOption: T
        }), x();
      }), _.innerHTML = l[1], b.innerHTML = l[2], b.style.cssText = _.style.cssText = y, !a.get("readOnly") && m.appendChild(b), m.appendChild(_), o.appendChild(s), o.appendChild(u), o.appendChild(m), u.style.height = i.clientHeight - 80 + "px", i.appendChild(o), this._dom = o;
    }, e.prototype.remove = function(r, n) {
      this._dom && n.getDom().removeChild(this._dom);
    }, e.prototype.dispose = function(r, n) {
      this.remove(r, n);
    }, e.getDefaultOption = function(r) {
      var n = {
        show: true,
        readOnly: false,
        optionToContent: null,
        contentToOption: null,
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: r.getLocaleModel().get([
          "toolbox",
          "dataView",
          "title"
        ]),
        lang: r.getLocaleModel().get([
          "toolbox",
          "dataView",
          "lang"
        ]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return n;
    }, e;
  }(di);
  function zpe(t, e) {
    return oe(t, function(r, n) {
      var i = e && e[n];
      if (Le(i) && !ae(i)) {
        var a = Le(r) && !ae(r);
        a || (r = {
          value: r
        });
        var o = i.name != null && r.name == null;
        return r = Ee(r, i), o && delete r.name, r;
      } else return r;
    });
  }
  Ba({
    type: "changeDataView",
    event: "dataViewChanged",
    update: "prepareAndUpdate"
  }, function(t, e) {
    var r = [];
    $(t.newOption.series, function(n) {
      var i = e.getSeriesByName(n.name)[0];
      if (!i) r.push(te({
        type: "scatter"
      }, n));
      else {
        var a = i.get("data");
        r.push({
          name: n.name,
          data: zpe(n.data, a)
        });
      }
    }), e.mergeOption(Ee({
      series: r
    }, t.newOption));
  });
  var DH = $, EH = _t();
  function Fpe(t, e) {
    var r = V2(t);
    DH(e, function(n, i) {
      for (var a = r.length - 1; a >= 0; a--) {
        var o = r[a];
        if (o[i]) break;
      }
      if (a < 0) {
        var s = t.queryComponents({
          mainType: "dataZoom",
          subType: "select",
          id: i
        })[0];
        if (s) {
          var l = s.getPercentRange();
          r[0][i] = {
            dataZoomId: i,
            start: l[0],
            end: l[1]
          };
        }
      }
    }), r.push(e);
  }
  function Vpe(t) {
    var e = V2(t), r = e[e.length - 1];
    e.length > 1 && e.pop();
    var n = {};
    return DH(r, function(i, a) {
      for (var o = e.length - 1; o >= 0; o--) if (i = e[o][a], i) {
        n[a] = i;
        break;
      }
    }), n;
  }
  function Gpe(t) {
    EH(t).snapshots = null;
  }
  function Wpe(t) {
    return V2(t).length;
  }
  function V2(t) {
    var e = EH(t);
    return e.snapshots || (e.snapshots = [
      {}
    ]), e.snapshots;
  }
  var Hpe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(r, n) {
      Gpe(r), n.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, e.getDefaultOption = function(r) {
      var n = {
        show: true,
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: r.getLocaleModel().get([
          "toolbox",
          "restore",
          "title"
        ])
      };
      return n;
    }, e;
  }(di);
  Ba({
    type: "restore",
    event: "restore",
    update: "prepareAndUpdate"
  }, function(t, e) {
    e.resetOption("recreate");
  });
  var Upe = [
    "grid",
    "xAxis",
    "yAxis",
    "geo",
    "graph",
    "polar",
    "radiusAxis",
    "angleAxis",
    "bmap"
  ], G2 = function() {
    function t(e, r, n) {
      var i = this;
      this._targetInfoList = [];
      var a = s$(r, e);
      $(Ype, function(o, s) {
        (!n || !n.include || et(n.include, s) >= 0) && o(a, i._targetInfoList);
      });
    }
    return t.prototype.setOutputRanges = function(e, r) {
      return this.matchOutputRanges(e, r, function(n, i, a) {
        if ((n.coordRanges || (n.coordRanges = [])).push(i), !n.coordRange) {
          n.coordRange = i;
          var o = tb[n.brushType](0, a, i);
          n.__rangeOffset = {
            offset: h$[n.brushType](o.values, n.range, [
              1,
              1
            ]),
            xyMinMax: o.xyMinMax
          };
        }
      }), e;
    }, t.prototype.matchOutputRanges = function(e, r, n) {
      $(e, function(i) {
        var a = this.findTargetInfo(i, r);
        a && a !== true && $(a.coordSyses, function(o) {
          var s = tb[i.brushType](1, o, i.range, true);
          n(i, s.values, o, r);
        });
      }, this);
    }, t.prototype.setInputRanges = function(e, r) {
      $(e, function(n) {
        var i = this.findTargetInfo(n, r);
        if (n.range = n.range || [], i && i !== true) {
          n.panelId = i.panelId;
          var a = tb[n.brushType](0, i.coordSys, n.coordRange), o = n.__rangeOffset;
          n.range = o ? h$[n.brushType](a.values, o.offset, qpe(a.xyMinMax, o.xyMinMax)) : a.values;
        }
      }, this);
    }, t.prototype.makePanelOpts = function(e, r) {
      return oe(this._targetInfoList, function(n) {
        var i = n.getPanelRect();
        return {
          panelId: n.panelId,
          defaultBrushType: r ? r(n) : null,
          clipPath: BW(i),
          isTargetByCursor: FW(i, e, n.coordSysModel),
          getLinearBrushOtherExtent: zW(i)
        };
      });
    }, t.prototype.controlSeries = function(e, r, n) {
      var i = this.findTargetInfo(e, n);
      return i === true || i && et(i.coordSyses, r.coordinateSystem) >= 0;
    }, t.prototype.findTargetInfo = function(e, r) {
      for (var n = this._targetInfoList, i = s$(r, e), a = 0; a < n.length; a++) {
        var o = n[a], s = e.panelId;
        if (s) {
          if (o.panelId === s) return o;
        } else for (var l = 0; l < l$.length; l++) if (l$[l](i, o)) return o;
      }
      return true;
    }, t;
  }();
  function kw(t) {
    return t[0] > t[1] && t.reverse(), t;
  }
  function s$(t, e) {
    return wf(t, e, {
      includeMainTypes: Upe
    });
  }
  var Ype = {
    grid: function(t, e) {
      var r = t.xAxisModels, n = t.yAxisModels, i = t.gridModels, a = Ce(), o = {}, s = {};
      !r && !n && !i || ($(r, function(l) {
        var u = l.axis.grid.model;
        a.set(u.id, u), o[u.id] = true;
      }), $(n, function(l) {
        var u = l.axis.grid.model;
        a.set(u.id, u), s[u.id] = true;
      }), $(i, function(l) {
        a.set(l.id, l), o[l.id] = true, s[l.id] = true;
      }), a.each(function(l) {
        var u = l.coordinateSystem, c = [];
        $(u.getCartesians(), function(h, f) {
          (et(r, h.getAxis("x").model) >= 0 || et(n, h.getAxis("y").model) >= 0) && c.push(h);
        }), e.push({
          panelId: "grid--" + l.id,
          gridModel: l,
          coordSysModel: l,
          coordSys: c[0],
          coordSyses: c,
          getPanelRect: u$.grid,
          xAxisDeclared: o[l.id],
          yAxisDeclared: s[l.id]
        });
      }));
    },
    geo: function(t, e) {
      $(t.geoModels, function(r) {
        var n = r.coordinateSystem;
        e.push({
          panelId: "geo--" + r.id,
          geoModel: r,
          coordSysModel: r,
          coordSys: n,
          coordSyses: [
            n
          ],
          getPanelRect: u$.geo
        });
      });
    }
  }, l$ = [
    function(t, e) {
      var r = t.xAxisModel, n = t.yAxisModel, i = t.gridModel;
      return !i && r && (i = r.axis.grid.model), !i && n && (i = n.axis.grid.model), i && i === e.gridModel;
    },
    function(t, e) {
      var r = t.geoModel;
      return r && r === e.geoModel;
    }
  ], u$ = {
    grid: function() {
      return this.coordSys.master.getRect().clone();
    },
    geo: function() {
      var t = this.coordSys, e = t.getBoundingRect().clone();
      return e.applyTransform(Bl(t)), e;
    }
  }, tb = {
    lineX: Ye(c$, 0),
    lineY: Ye(c$, 1),
    rect: function(t, e, r, n) {
      var i = t ? e.pointToData([
        r[0][0],
        r[1][0]
      ], n) : e.dataToPoint([
        r[0][0],
        r[1][0]
      ], n), a = t ? e.pointToData([
        r[0][1],
        r[1][1]
      ], n) : e.dataToPoint([
        r[0][1],
        r[1][1]
      ], n), o = [
        kw([
          i[0],
          a[0]
        ]),
        kw([
          i[1],
          a[1]
        ])
      ];
      return {
        values: o,
        xyMinMax: o
      };
    },
    polygon: function(t, e, r, n) {
      var i = [
        [
          1 / 0,
          -1 / 0
        ],
        [
          1 / 0,
          -1 / 0
        ]
      ], a = oe(r, function(o) {
        var s = t ? e.pointToData(o, n) : e.dataToPoint(o, n);
        return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s;
      });
      return {
        values: a,
        xyMinMax: i
      };
    }
  };
  function c$(t, e, r, n) {
    var i = r.getAxis([
      "x",
      "y"
    ][t]), a = kw(oe([
      0,
      1
    ], function(s) {
      return e ? i.coordToData(i.toLocalCoord(n[s]), true) : i.toGlobalCoord(i.dataToCoord(n[s]));
    })), o = [];
    return o[t] = a, o[1 - t] = [
      NaN,
      NaN
    ], {
      values: a,
      xyMinMax: o
    };
  }
  var h$ = {
    lineX: Ye(f$, 0),
    lineY: Ye(f$, 1),
    rect: function(t, e, r) {
      return [
        [
          t[0][0] - r[0] * e[0][0],
          t[0][1] - r[0] * e[0][1]
        ],
        [
          t[1][0] - r[1] * e[1][0],
          t[1][1] - r[1] * e[1][1]
        ]
      ];
    },
    polygon: function(t, e, r) {
      return oe(t, function(n, i) {
        return [
          n[0] - r[0] * e[i][0],
          n[1] - r[1] * e[i][1]
        ];
      });
    }
  };
  function f$(t, e, r, n) {
    return [
      e[0] - n[t] * r[0],
      e[1] - n[t] * r[1]
    ];
  }
  function qpe(t, e) {
    var r = d$(t), n = d$(e), i = [
      r[0] / n[0],
      r[1] / n[1]
    ];
    return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
  }
  function d$(t) {
    return t ? [
      t[0][1] - t[0][0],
      t[1][1] - t[1][0]
    ] : [
      NaN,
      NaN
    ];
  }
  var Pw = $, Xpe = tQ("toolbox-dataZoom_"), jpe = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.render = function(r, n, i, a) {
      this._brushController || (this._brushController = new v2(i.getZr()), this._brushController.on("brush", _e(this._onBrush, this)).mount()), Qpe(r, n, this, a, i), Zpe(r, n);
    }, e.prototype.onclick = function(r, n, i) {
      Kpe[i].call(this);
    }, e.prototype.remove = function(r, n) {
      this._brushController && this._brushController.unmount();
    }, e.prototype.dispose = function(r, n) {
      this._brushController && this._brushController.dispose();
    }, e.prototype._onBrush = function(r) {
      var n = r.areas;
      if (!r.isEnd || !n.length) return;
      var i = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var o = new G2(W2(this.model), a, {
        include: [
          "grid"
        ]
      });
      o.matchOutputRanges(n, a, function(u, c, h) {
        if (h.type === "cartesian2d") {
          var f = u.brushType;
          f === "rect" ? (s("x", h, c[0]), s("y", h, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[f], h, c);
        }
      }), Fpe(a, i), this._dispatchZoomAction(i);
      function s(u, c, h) {
        var f = c.getAxis(u), d = f.model, p = l(u, d, a), v = p.findRepresentativeAxisProxy(d).getMinMaxSpan();
        (v.minValueSpan != null || v.maxValueSpan != null) && (h = cu(0, h.slice(), f.scale.getExtent(), 0, v.minValueSpan, v.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: h[0],
          endValue: h[1]
        });
      }
      function l(u, c, h) {
        var f;
        return h.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(d) {
          var p = d.getAxisModel(u, c.componentIndex);
          p && (f = d);
        }), f;
      }
    }, e.prototype._dispatchZoomAction = function(r) {
      var n = [];
      Pw(r, function(i, a) {
        n.push(Oe(i));
      }), n.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: n
      });
    }, e.getDefaultOption = function(r) {
      var n = {
        show: true,
        filterMode: "filter",
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        title: r.getLocaleModel().get([
          "toolbox",
          "dataZoom",
          "title"
        ]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return n;
    }, e;
  }(di), Kpe = {
    zoom: function() {
      var t = !this._isZoomActive;
      this.api.dispatchAction({
        type: "takeGlobalCursor",
        key: "dataZoomSelect",
        dataZoomSelectActive: t
      });
    },
    back: function() {
      this._dispatchZoomAction(Vpe(this.ecModel));
    }
  };
  function W2(t) {
    var e = {
      xAxisIndex: t.get("xAxisIndex", true),
      yAxisIndex: t.get("yAxisIndex", true),
      xAxisId: t.get("xAxisId", true),
      yAxisId: t.get("yAxisId", true)
    };
    return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e;
  }
  function Zpe(t, e) {
    t.setIconStatus("back", Wpe(e) > 1 ? "emphasis" : "normal");
  }
  function Qpe(t, e, r, n, i) {
    var a = r._isZoomActive;
    n && n.type === "takeGlobalCursor" && (a = n.key === "dataZoomSelect" ? n.dataZoomSelectActive : false), r._isZoomActive = a, t.setIconStatus("zoom", a ? "emphasis" : "normal");
    var o = new G2(W2(t), e, {
      include: [
        "grid"
      ]
    }), s = o.makePanelOpts(i, function(l) {
      return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
    });
    r._brushController.setPanels(s).enableBrush(a && s.length ? {
      brushType: "auto",
      brushStyle: t.getModel("brushStyle").getItemStyle()
    } : false);
  }
  Aee("dataZoom", function(t) {
    var e = t.getComponent("toolbox", 0), r = [
      "feature",
      "dataZoom"
    ];
    if (!e || e.get(r) == null) return;
    var n = e.getModel(r), i = [], a = W2(n), o = wf(t, a);
    Pw(o.xAxisModels, function(l) {
      return s(l, "xAxis", "xAxisIndex");
    }), Pw(o.yAxisModels, function(l) {
      return s(l, "yAxis", "yAxisIndex");
    });
    function s(l, u, c) {
      var h = l.componentIndex, f = {
        type: "select",
        $fromToolbox: true,
        filterMode: n.get("filterMode", true) || "filter",
        id: Xpe + u + h
      };
      f[c] = h, i.push(f);
    }
    return i;
  });
  function Jpe(t) {
    t.registerComponentModel(Spe), t.registerComponentView(Cpe), ju("saveAsImage", Ipe), ju("magicType", Dpe), ju("dataView", Bpe), ju("dataZoom", jpe), ju("restore", Hpe), rt(wpe);
  }
  var eve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "tooltip", e.dependencies = [
      "axisPointer"
    ], e.defaultOption = {
      z: 60,
      show: true,
      showContent: true,
      trigger: "item",
      triggerOn: "mousemove|click",
      alwaysShowContent: false,
      displayMode: "single",
      renderMode: "auto",
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: false,
      backgroundColor: "#fff",
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      borderRadius: 4,
      borderWidth: 1,
      padding: null,
      extraCssText: "",
      axisPointer: {
        type: "line",
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          textStyle: {}
        }
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, e;
  }(vt);
  function kH(t) {
    var e = t.get("confine");
    return e != null ? !!e : t.get("renderMode") === "richText";
  }
  function PH(t) {
    if (ct.domSupported) {
      for (var e = document.documentElement.style, r = 0, n = t.length; r < n; r++) if (t[r] in e) return t[r];
    }
  }
  var LH = PH([
    "transform",
    "webkitTransform",
    "OTransform",
    "MozTransform",
    "msTransform"
  ]), tve = PH([
    "webkitTransition",
    "transition",
    "OTransition",
    "MozTransition",
    "msTransition"
  ]);
  function $H(t, e) {
    if (!t) return e;
    e = fV(e, true);
    var r = t.indexOf(e);
    return t = r === -1 ? e : "-" + t.slice(0, r) + "-" + e, t.toLowerCase();
  }
  function rve(t, e) {
    var r = t.currentStyle || document.defaultView && document.defaultView.getComputedStyle(t);
    return r ? r[e] : null;
  }
  var nve = $H(tve, "transition"), H2 = $H(LH, "transform"), ive = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (ct.transform3dSupported ? "will-change:transform;" : "");
  function ave(t) {
    return t = t === "left" ? "right" : t === "right" ? "left" : t === "top" ? "bottom" : "top", t;
  }
  function ove(t, e, r) {
    if (!me(r) || r === "inside") return "";
    var n = t.get("backgroundColor"), i = t.get("borderWidth");
    e = jl(e);
    var a = ave(r), o = Math.max(Math.round(i) * 1.5, 6), s = "", l = H2 + ":", u;
    et([
      "left",
      "right"
    ], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
    var c = u * Math.PI / 180, h = o + i, f = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), d = Math.round(((f - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (f - h) / 2) * 100) / 100;
    s += ";" + a + ":-" + d + "px";
    var p = e + " solid " + i + "px;", v = [
      "position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;",
      s + ";" + l + ";",
      "border-bottom:" + p,
      "border-right:" + p,
      "background-color:" + n + ";"
    ];
    return '<div style="' + v.join("") + '"></div>';
  }
  function sve(t, e) {
    var r = "cubic-bezier(0.23,1,0.32,1)", n = " " + t / 2 + "s " + r, i = "opacity" + n + ",visibility" + n;
    return e || (n = " " + t + "s " + r, i += ct.transformSupported ? "," + H2 + n : ",left" + n + ",top" + n), nve + ":" + i;
  }
  function p$(t, e, r) {
    var n = t.toFixed(0) + "px", i = e.toFixed(0) + "px";
    if (!ct.transformSupported) return r ? "top:" + i + ";left:" + n + ";" : [
      [
        "top",
        i
      ],
      [
        "left",
        n
      ]
    ];
    var a = ct.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + n + "," + i + (a ? ",0" : "") + ")";
    return r ? "top:0;left:0;" + H2 + ":" + o + ";" : [
      [
        "top",
        0
      ],
      [
        "left",
        0
      ],
      [
        LH,
        o
      ]
    ];
  }
  function lve(t) {
    var e = [], r = t.get("fontSize"), n = t.getTextColor();
    n && e.push("color:" + n), e.push("font:" + t.getFont());
    var i = We(t.get("lineHeight"), Math.round(r * 3 / 2));
    r && e.push("line-height:" + i + "px");
    var a = t.get("textShadowColor"), o = t.get("textShadowBlur") || 0, s = t.get("textShadowOffsetX") || 0, l = t.get("textShadowOffsetY") || 0;
    return a && o && e.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), $([
      "decoration",
      "align"
    ], function(u) {
      var c = t.get(u);
      c && e.push("text-" + u + ":" + c);
    }), e.join(";");
  }
  function uve(t, e, r) {
    var n = [], i = t.get("transitionDuration"), a = t.get("backgroundColor"), o = t.get("shadowBlur"), s = t.get("shadowColor"), l = t.get("shadowOffsetX"), u = t.get("shadowOffsetY"), c = t.getModel("textStyle"), h = YV(t, "html"), f = l + "px " + u + "px " + o + "px " + s;
    return n.push("box-shadow:" + f), e && i && n.push(sve(i, r)), a && n.push("background-color:" + a), $([
      "width",
      "color",
      "radius"
    ], function(d) {
      var p = "border-" + d, v = fV(p), g = t.get(v);
      g != null && n.push(p + ":" + g + (d === "color" ? "" : "px"));
    }), n.push(lve(c)), h != null && n.push("padding:" + Uc(h).join("px ") + "px"), n.join(";") + ";";
  }
  function v$(t, e, r, n, i) {
    var a = e && e.painter;
    if (r) {
      var o = a && a.getViewportRoot();
      o && EK(t, o, r, n, i);
    } else {
      t[0] = n, t[1] = i;
      var s = a && a.getViewportRootOffset();
      s && (t[0] += s.offsetLeft, t[1] += s.offsetTop);
    }
    t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight();
  }
  var cve = function() {
    function t(e, r) {
      if (this._show = false, this._styleCoord = [
        0,
        0,
        0,
        0
      ], this._enterable = true, this._alwaysShowContent = false, this._firstShow = true, this._longHide = true, ct.wxa) return null;
      var n = document.createElement("div");
      n.domBelongToZr = true, this.el = n;
      var i = this._zr = e.getZr(), a = r.appendTo, o = a && (me(a) ? document.querySelector(a) : gc(a) ? a : De(a) && a(e.getDom()));
      v$(this._styleCoord, i, o, e.getWidth() / 2, e.getHeight() / 2), (o || e.getDom()).appendChild(n), this._api = e, this._container = o;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = true), s._inContent = true;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          si(c, l, true), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = false, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return t.prototype.update = function(e) {
      if (!this._container) {
        var r = this._api.getDom(), n = rve(r, "position"), i = r.style;
        i.position !== "absolute" && n !== "absolute" && (i.position = "relative");
      }
      var a = e.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = e.get("className") || "";
    }, t.prototype.show = function(e, r) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, i = n.style, a = this._styleCoord;
      n.innerHTML ? i.cssText = ive + uve(e, !this._firstShow, this._longHide) + p$(a[0], a[1], true) + ("border-color:" + jl(r) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = true, this._firstShow = false, this._longHide = false;
    }, t.prototype.setContent = function(e, r, n, i, a) {
      var o = this.el;
      if (e == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (me(a) && n.get("trigger") === "item" && !kH(n) && (s = ove(n, i, a)), me(e)) o.innerHTML = e + s;
      else if (e) {
        o.innerHTML = "", ae(e) || (e = [
          e
        ]);
        for (var l = 0; l < e.length; l++) gc(e[l]) && e[l].parentNode !== o && o.appendChild(e[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, t.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, t.prototype.getSize = function() {
      var e = this.el;
      return e ? [
        e.offsetWidth,
        e.offsetHeight
      ] : [
        0,
        0
      ];
    }, t.prototype.moveTo = function(e, r) {
      if (this.el) {
        var n = this._styleCoord;
        if (v$(n, this._zr, this._container, e, r), n[0] != null && n[1] != null) {
          var i = this.el.style, a = p$(n[0], n[1]);
          $(a, function(o) {
            i[o[0]] = o[1];
          });
        }
      }
    }, t.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], r = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), r * this._zr.getHeight());
    }, t.prototype.hide = function() {
      var e = this, r = this.el.style;
      r.visibility = "hidden", r.opacity = "0", ct.transform3dSupported && (r.willChange = ""), this._show = false, this._longHideTimeout = setTimeout(function() {
        return e._longHide = true;
      }, 500);
    }, t.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = false, this._hideTimeout = setTimeout(_e(this.hide, this), e)) : this.hide());
    }, t.prototype.isShow = function() {
      return this._show;
    }, t.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var e = this.el.parentNode;
      e && e.removeChild(this.el), this.el = this._container = null;
    }, t;
  }(), hve = function() {
    function t(e) {
      this._show = false, this._styleCoord = [
        0,
        0,
        0,
        0
      ], this._alwaysShowContent = false, this._enterable = true, this._zr = e.getZr(), m$(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2);
    }
    return t.prototype.update = function(e) {
      var r = e.get("alwaysShowContent");
      r && this._moveIfResized(), this._alwaysShowContent = r;
    }, t.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = true;
    }, t.prototype.setContent = function(e, r, n, i, a) {
      var o = this;
      Le(e) && It(""), this.el && this._zr.remove(this.el);
      var s = n.getModel("textStyle");
      this.el = new bt({
        style: {
          rich: r.richTextStyles,
          text: e,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: n.get([
            "textStyle",
            "color"
          ]),
          padding: YV(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), $([
        "backgroundColor",
        "borderRadius",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY"
      ], function(u) {
        o.el.style[u] = n.get(u);
      }), $([
        "textShadowBlur",
        "textShadowOffsetX",
        "textShadowOffsetY"
      ], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = true), l._inContent = true;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = false;
      });
    }, t.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, t.prototype.getSize = function() {
      var e = this.el, r = this.el.getBoundingRect(), n = g$(e.style);
      return [
        r.width + n.left + n.right,
        r.height + n.top + n.bottom
      ];
    }, t.prototype.moveTo = function(e, r) {
      var n = this.el;
      if (n) {
        var i = this._styleCoord;
        m$(i, this._zr, e, r), e = i[0], r = i[1];
        var a = n.style, o = Uo(a.borderWidth || 0), s = g$(a);
        n.x = e + o + s.left, n.y = r + o + s.top, n.markRedraw();
      }
    }, t.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], r = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), r * this._zr.getHeight());
    }, t.prototype.hide = function() {
      this.el && this.el.hide(), this._show = false;
    }, t.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = false, this._hideTimeout = setTimeout(_e(this.hide, this), e)) : this.hide());
    }, t.prototype.isShow = function() {
      return this._show;
    }, t.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, t;
  }();
  function Uo(t) {
    return Math.max(0, t);
  }
  function g$(t) {
    var e = Uo(t.shadowBlur || 0), r = Uo(t.shadowOffsetX || 0), n = Uo(t.shadowOffsetY || 0);
    return {
      left: Uo(e - r),
      right: Uo(e + r),
      top: Uo(e - n),
      bottom: Uo(e + n)
    };
  }
  function m$(t, e, r, n) {
    t[0] = r, t[1] = n, t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight();
  }
  var fve = new yt({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  }), dve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r, n) {
      if (!(ct.node || !n.getDom())) {
        var i = r.getComponent("tooltip"), a = this._renderMode = lQ(i.get("renderMode"));
        this._tooltipContent = a === "richText" ? new hve(n) : new cve(n, {
          appendTo: i.get("appendToBody", true) ? "body" : i.get("appendTo", true)
        });
      }
    }, e.prototype.render = function(r, n, i) {
      if (!(ct.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = r, this._ecModel = n, this._api = i;
        var a = this._tooltipContent;
        a.update(r), a.setEnterable(r.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && r.get("transitionDuration") ? jc(this, "_updatePosition", 50, "fixRate") : Jf(this, "_updatePosition");
      }
    }, e.prototype._initGlobalListener = function() {
      var r = this._tooltipModel, n = r.get("triggerOn");
      yH("itemTooltip", this._api, _e(function(i, a, o) {
        n !== "none" && (n.indexOf(i) >= 0 ? this._tryShow(a, o) : i === "leave" && this._hide(o));
      }, this));
    }, e.prototype._keepShow = function() {
      var r = this._tooltipModel, n = this._ecModel, i = this._api, a = r.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && o.manuallyShowTip(r, n, i, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, e.prototype.manuallyShowTip = function(r, n, i, a) {
      if (!(a.from === this.uid || ct.node || !i.getDom())) {
        var o = y$(a, i);
        this._ticket = "";
        var s = a.dataByCoordSys, l = mve(a, n, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = fve;
          c.x = a.x, c.y = a.y, c.update(), Ge(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, o);
        } else if (s) this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          dataByCoordSys: s,
          tooltipOption: a.tooltipOption
        }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(r, n, i, a)) return;
          var h = _H(a, n), f = h.point[0], d = h.point[1];
          f != null && d != null && this._tryShow({
            offsetX: f,
            offsetY: d,
            target: h.el,
            position: a.position,
            positionDefault: "bottom"
          }, o);
        } else a.x != null && a.y != null && (i.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: i.getZr().findHover(a.x, a.y).target
        }, o));
      }
    }, e.prototype.manuallyHideTip = function(r, n, i, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(y$(a, i));
    }, e.prototype._manuallyAxisShowTip = function(r, n, i, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = n.getSeriesByIndex(o);
        if (u) {
          var c = u.getData(), h = Dh([
            c.getItemModel(s),
            u,
            (u.coordinateSystem || {}).model
          ], this._tooltipModel);
          if (h.get("trigger") === "axis") return i.dispatchAction({
            type: "updateAxisPointer",
            seriesIndex: o,
            dataIndex: s,
            position: a.position
          }), true;
        }
      }
    }, e.prototype._tryShow = function(r, n) {
      var i = r.target, a = this._tooltipModel;
      if (a) {
        this._lastX = r.offsetX, this._lastY = r.offsetY;
        var o = r.dataByCoordSys;
        if (o && o.length) this._showAxisTooltip(o, r);
        else if (i) {
          var s = Ge(i);
          if (s.ssrType === "legend") return;
          this._lastDataByCoordSys = null;
          var l, u;
          Al(i, function(c) {
            if (Ge(c).dataIndex != null) return l = c, true;
            if (Ge(c).tooltipConfig != null) return u = c, true;
          }, true), l ? this._showSeriesItemTooltip(r, l, n) : u ? this._showComponentItemTooltip(r, u, n) : this._hide(n);
        } else this._lastDataByCoordSys = null, this._hide(n);
      }
    }, e.prototype._showOrMove = function(r, n) {
      var i = r.get("showDelay");
      n = _e(n, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(n, i) : n();
    }, e.prototype._showAxisTooltip = function(r, n) {
      var i = this._ecModel, a = this._tooltipModel, o = [
        n.offsetX,
        n.offsetY
      ], s = Dh([
        n.tooltipOption
      ], a), l = this._renderMode, u = [], c = $r("section", {
        blocks: [],
        noHeader: true
      }), h = [], f = new F0();
      $(r, function(y) {
        $(y.dataByAxis, function(_) {
          var b = i.getComponent(_.axisDim + "Axis", _.axisIndex), w = _.value;
          if (!(!b || w == null)) {
            var x = vH(w, b.axis, i, _.seriesDataIndices, _.valueLabelOpt), T = $r("section", {
              header: x,
              noHeader: !Vi(x),
              sortBlocks: true,
              blocks: []
            });
            c.blocks.push(T), $(_.seriesDataIndices, function(A) {
              var I = i.getSeriesByIndex(A.seriesIndex), M = A.dataIndexInside, k = I.getDataParams(M);
              if (!(k.dataIndex < 0)) {
                k.axisDim = _.axisDim, k.axisIndex = _.axisIndex, k.axisType = _.axisType, k.axisId = _.axisId, k.axisValue = WT(b.axis, {
                  value: w
                }), k.axisValueLabel = x, k.marker = f.makeTooltipMarker("item", jl(k.color), l);
                var B = iE(I.formatTooltip(M, true, null)), L = B.frag;
                if (L) {
                  var z = Dh([
                    I
                  ], a).get("valueFormatter");
                  T.blocks.push(z ? te({
                    valueFormatter: z
                  }, L) : L);
                }
                B.text && h.push(B.text), u.push(k);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var d = n.position, p = s.get("order"), v = cE(c, f, l, p, i.get("useUTC"), s.get("textStyle"));
      v && h.unshift(v);
      var g = l === "richText" ? `

` : "<br/>", m = h.join(g);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(r, u) ? this._updatePosition(s, d, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, m, u, Math.random() + "", o[0], o[1], d, null, f);
      });
    }, e.prototype._showSeriesItemTooltip = function(r, n, i) {
      var a = this._ecModel, o = Ge(n), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, c = o.dataIndex, h = o.dataType, f = u.getData(h), d = this._renderMode, p = r.positionDefault, v = Dh([
        f.getItemModel(c),
        u,
        l && (l.coordinateSystem || {}).model
      ], this._tooltipModel, p ? {
        position: p
      } : null), g = v.get("trigger");
      if (!(g != null && g !== "item")) {
        var m = u.getDataParams(c, h), y = new F0();
        m.marker = y.makeTooltipMarker("item", jl(m.color), d);
        var _ = iE(u.formatTooltip(c, false, h)), b = v.get("order"), w = v.get("valueFormatter"), x = _.frag, T = x ? cE(w ? te({
          valueFormatter: w
        }, x) : x, y, d, b, a.get("useUTC"), v.get("textStyle")) : _.text, A = "item_" + u.name + "_" + c;
        this._showOrMove(v, function() {
          this._showTooltipContent(v, T, m, A, r.offsetX, r.offsetY, r.position, r.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: f.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, e.prototype._showComponentItemTooltip = function(r, n, i) {
      var a = this._renderMode === "html", o = Ge(n), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (me(l)) {
        var c = l;
        l = {
          content: c,
          formatter: c
        }, u = true;
      }
      u && a && l.content && (l = Oe(l), l.content = vn(l.content));
      var h = [
        l
      ], f = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
      f && h.push(f), h.push({
        formatter: l.content
      });
      var d = r.positionDefault, p = Dh(h, this._tooltipModel, d ? {
        position: d
      } : null), v = p.get("content"), g = Math.random() + "", m = new F0();
      this._showOrMove(p, function() {
        var y = Oe(p.get("formatterParams") || {});
        this._showTooltipContent(p, v, y, g, r.offsetX, r.offsetY, r.position, n, m);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, e.prototype._showTooltipContent = function(r, n, i, a, o, s, l, u, c) {
      if (this._ticket = "", !(!r.get("showContent") || !r.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(r.get("enterable"));
        var f = r.get("formatter");
        l = l || r.get("position");
        var d = n, p = this._getNearestPoint([
          o,
          s
        ], i, r.get("trigger"), r.get("borderColor")), v = p.color;
        if (f) if (me(f)) {
          var g = r.ecModel.get("useUTC"), m = ae(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
          d = f, y && (d = Qm(m.axisValue, d, g)), d = dV(d, i, true);
        } else if (De(f)) {
          var _ = _e(function(b, w) {
            b === this._ticket && (h.setContent(w, c, r, v, l), this._updatePosition(r, l, o, s, h, i, u));
          }, this);
          this._ticket = a, d = f(i, a, _);
        } else d = f;
        h.setContent(d, c, r, v, l), h.show(r, v), this._updatePosition(r, l, o, s, h, i, u);
      }
    }, e.prototype._getNearestPoint = function(r, n, i, a) {
      if (i === "axis" || ae(n)) return {
        color: a || (this._renderMode === "html" ? "#fff" : "none")
      };
      if (!ae(n)) return {
        color: a || n.color || n.borderColor
      };
    }, e.prototype._updatePosition = function(r, n, i, a, o, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || r.get("position");
      var h = o.getSize(), f = r.get("align"), d = r.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), De(n) && (n = n([
        i,
        a
      ], s, o.el, p, {
        viewSize: [
          u,
          c
        ],
        contentSize: h.slice()
      })), ae(n)) i = pe(n[0], u), a = pe(n[1], c);
      else if (Le(n)) {
        var v = n;
        v.width = h[0], v.height = h[1];
        var g = Tr(v, {
          width: u,
          height: c
        });
        i = g.x, a = g.y, f = null, d = null;
      } else if (me(n) && l) {
        var m = gve(n, p, h, r.get("borderWidth"));
        i = m[0], a = m[1];
      } else {
        var m = pve(i, a, o, u, c, f ? null : 20, d ? null : 20);
        i = m[0], a = m[1];
      }
      if (f && (i -= _$(f) ? h[0] / 2 : f === "right" ? h[0] : 0), d && (a -= _$(d) ? h[1] / 2 : d === "bottom" ? h[1] : 0), kH(r)) {
        var m = vve(i, a, o, u, c);
        i = m[0], a = m[1];
      }
      o.moveTo(i, a);
    }, e.prototype._updateContentNotChangedOnAxis = function(r, n) {
      var i = this._lastDataByCoordSys, a = this._cbParamsList, o = !!i && i.length === r.length;
      return o && $(i, function(s, l) {
        var u = s.dataByAxis || [], c = r[l] || {}, h = c.dataByAxis || [];
        o = o && u.length === h.length, o && $(u, function(f, d) {
          var p = h[d] || {}, v = f.seriesDataIndices || [], g = p.seriesDataIndices || [];
          o = o && f.value === p.value && f.axisType === p.axisType && f.axisId === p.axisId && v.length === g.length, o && $(v, function(m, y) {
            var _ = g[y];
            o = o && m.seriesIndex === _.seriesIndex && m.dataIndex === _.dataIndex;
          }), a && $(f.seriesDataIndices, function(m) {
            var y = m.seriesIndex, _ = n[y], b = a[y];
            _ && b && b.data !== _.data && (o = false);
          });
        });
      }), this._lastDataByCoordSys = r, this._cbParamsList = n, !!o;
    }, e.prototype._hide = function(r) {
      this._lastDataByCoordSys = null, r({
        type: "hideTip",
        from: this.uid
      });
    }, e.prototype.dispose = function(r, n) {
      ct.node || !n.getDom() || (Jf(this, "_updatePosition"), this._tooltipContent.dispose(), Iw("itemTooltip", n));
    }, e.type = "tooltip", e;
  }(tr);
  function Dh(t, e, r) {
    var n = e.ecModel, i;
    r ? (i = new kt(r, n, n), i = new kt(e.option, i, n)) : i = e;
    for (var a = t.length - 1; a >= 0; a--) {
      var o = t[a];
      o && (o instanceof kt && (o = o.get("tooltip", true)), me(o) && (o = {
        formatter: o
      }), o && (i = new kt(o, i, n)));
    }
    return i;
  }
  function y$(t, e) {
    return t.dispatchAction || _e(e.dispatchAction, e);
  }
  function pve(t, e, r, n, i, a, o) {
    var s = r.getSize(), l = s[0], u = s[1];
    return a != null && (t + l + a + 2 > n ? t -= l + a : t += a), o != null && (e + u + o > i ? e -= u + o : e += o), [
      t,
      e
    ];
  }
  function vve(t, e, r, n, i) {
    var a = r.getSize(), o = a[0], s = a[1];
    return t = Math.min(t + o, n) - o, e = Math.min(e + s, i) - s, t = Math.max(t, 0), e = Math.max(e, 0), [
      t,
      e
    ];
  }
  function gve(t, e, r, n) {
    var i = r[0], a = r[1], o = Math.ceil(Math.SQRT2 * n) + 8, s = 0, l = 0, u = e.width, c = e.height;
    switch (t) {
      case "inside":
        s = e.x + u / 2 - i / 2, l = e.y + c / 2 - a / 2;
        break;
      case "top":
        s = e.x + u / 2 - i / 2, l = e.y - a - o;
        break;
      case "bottom":
        s = e.x + u / 2 - i / 2, l = e.y + c + o;
        break;
      case "left":
        s = e.x - i - o, l = e.y + c / 2 - a / 2;
        break;
      case "right":
        s = e.x + u + o, l = e.y + c / 2 - a / 2;
    }
    return [
      s,
      l
    ];
  }
  function _$(t) {
    return t === "center" || t === "middle";
  }
  function mve(t, e, r) {
    var n = iT(t).queryOptionMap, i = n.keys()[0];
    if (!(!i || i === "series")) {
      var a = Ed(e, i, n.get(i), {
        useDefault: false,
        enableAll: false,
        enableNone: false
      }), o = a.models[0];
      if (o) {
        var s = r.getViewOfComponentModel(o), l;
        if (s.group.traverse(function(u) {
          var c = Ge(u).tooltipConfig;
          if (c && c.name === t.name) return l = u, true;
        }), l) return {
          componentMainType: i,
          componentIndex: o.componentIndex,
          el: l
        };
      }
    }
  }
  function yve(t) {
    rt(jd), t.registerComponentModel(eve), t.registerComponentView(dve), t.registerAction({
      type: "showTip",
      event: "showTip",
      update: "tooltip:manuallyShowTip"
    }, dr), t.registerAction({
      type: "hideTip",
      event: "hideTip",
      update: "tooltip:manuallyHideTip"
    }, dr);
  }
  var _ve = [
    "rect",
    "polygon",
    "keep",
    "clear"
  ];
  function bve(t, e) {
    var r = Ot(t ? t.brush : []);
    if (r.length) {
      var n = [];
      $(r, function(l) {
        var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
        u instanceof Array && (n = n.concat(u));
      });
      var i = t && t.toolbox;
      ae(i) && (i = i[0]), i || (i = {
        feature: {}
      }, t.toolbox = [
        i
      ]);
      var a = i.feature || (i.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
      s.push.apply(s, n), xve(s), e && !s.length && s.push.apply(s, _ve);
    }
  }
  function xve(t) {
    var e = {};
    $(t, function(r) {
      e[r] = 1;
    }), t.length = 0, $(e, function(r, n) {
      t.push(n);
    });
  }
  var b$ = $;
  function x$(t) {
    if (t) {
      for (var e in t) if (t.hasOwnProperty(e)) return true;
    }
  }
  function Lw(t, e, r) {
    var n = {};
    return b$(e, function(a) {
      var o = n[a] = i();
      b$(t[a], function(s, l) {
        if (Er.isValidType(l)) {
          var u = {
            type: l,
            visual: s
          };
          r && r(u, a), o[l] = new Er(u), l === "opacity" && (u = Oe(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new Er(u));
        }
      });
    }), n;
    function i() {
      var a = function() {
      };
      a.prototype.__hidden = a.prototype;
      var o = new a();
      return o;
    }
  }
  function RH(t, e, r) {
    var n;
    $(r, function(i) {
      e.hasOwnProperty(i) && x$(e[i]) && (n = true);
    }), n && $(r, function(i) {
      e.hasOwnProperty(i) && x$(e[i]) ? t[i] = Oe(e[i]) : delete t[i];
    });
  }
  function wve(t, e, r, n, i, a) {
    var o = {};
    $(t, function(h) {
      var f = Er.prepareVisualTypes(e[h]);
      o[h] = f;
    });
    var s;
    function l(h) {
      return LT(r, s, h);
    }
    function u(h, f) {
      r5(r, s, h, f);
    }
    r.each(c);
    function c(h, f) {
      s = h;
      var d = r.getRawDataItem(s);
      if (!(d && d.visualMap === false)) for (var p = n.call(i, h), v = e[p], g = o[p], m = 0, y = g.length; m < y; m++) {
        var _ = g[m];
        v[_] && v[_].applyVisual(h, l, u);
      }
    }
  }
  function Sve(t, e, r, n) {
    var i = {};
    return $(t, function(a) {
      var o = Er.prepareVisualTypes(e[a]);
      i[a] = o;
    }), {
      progress: function(o, s) {
        var l;
        n != null && (l = s.getDimensionIndex(n));
        function u(w) {
          return LT(s, h, w);
        }
        function c(w, x) {
          r5(s, h, w, x);
        }
        for (var h, f = s.getStore(); (h = o.next()) != null; ) {
          var d = s.getRawDataItem(h);
          if (!(d && d.visualMap === false)) for (var p = n != null ? f.get(l, h) : h, v = r(p), g = e[v], m = i[v], y = 0, _ = m.length; y < _; y++) {
            var b = m[y];
            g[b] && g[b].applyVisual(p, u, c);
          }
        }
      }
    };
  }
  function Tve(t) {
    var e = t.brushType, r = {
      point: function(n) {
        return w$[e].point(n, r, t);
      },
      rect: function(n) {
        return w$[e].rect(n, r, t);
      }
    };
    return r;
  }
  var w$ = {
    lineX: S$(0),
    lineY: S$(1),
    rect: {
      point: function(t, e, r) {
        return t && r.boundingRect.contain(t[0], t[1]);
      },
      rect: function(t, e, r) {
        return t && r.boundingRect.intersect(t);
      }
    },
    polygon: {
      point: function(t, e, r) {
        return t && r.boundingRect.contain(t[0], t[1]) && vl(r.range, t[0], t[1]);
      },
      rect: function(t, e, r) {
        var n = r.range;
        if (!t || n.length <= 1) return false;
        var i = t.x, a = t.y, o = t.width, s = t.height, l = n[0];
        if (vl(n, i, a) || vl(n, i + o, a) || vl(n, i, a + s) || vl(n, i + o, a + s) || Ze.create(t).contain(l[0], l[1]) || ef(i, a, i + o, a, n) || ef(i, a, i, a + s, n) || ef(i + o, a, i + o, a + s, n) || ef(i, a + s, i + o, a + s, n)) return true;
      }
    }
  };
  function S$(t) {
    var e = [
      "x",
      "y"
    ], r = [
      "width",
      "height"
    ];
    return {
      point: function(n, i, a) {
        if (n) {
          var o = a.range, s = n[t];
          return Eh(s, o);
        }
      },
      rect: function(n, i, a) {
        if (n) {
          var o = a.range, s = [
            n[e[t]],
            n[e[t]] + n[r[t]]
          ];
          return s[1] < s[0] && s.reverse(), Eh(s[0], o) || Eh(s[1], o) || Eh(o[0], s) || Eh(o[1], s);
        }
      }
    };
  }
  function Eh(t, e) {
    return e[0] <= t && t <= e[1];
  }
  var T$ = [
    "inBrush",
    "outOfBrush"
  ], rb = "__ecBrushSelect", $w = "__ecInBrushSelectEvent";
  function OH(t) {
    t.eachComponent({
      mainType: "brush"
    }, function(e) {
      var r = e.brushTargetManager = new G2(e.option, t);
      r.setInputRanges(e.areas, t);
    });
  }
  function Cve(t, e, r) {
    var n = [], i, a;
    t.eachComponent({
      mainType: "brush"
    }, function(o) {
      r && r.type === "takeGlobalCursor" && o.setBrushOption(r.key === "brush" ? r.brushOption : {
        brushType: false
      });
    }), OH(t), t.eachComponent({
      mainType: "brush"
    }, function(o, s) {
      var l = {
        brushId: o.id,
        brushIndex: s,
        brushName: o.name,
        areas: Oe(o.areas),
        selected: []
      };
      n.push(l);
      var u = o.option, c = u.brushLink, h = [], f = [], d = [], p = false;
      s || (i = u.throttleType, a = u.throttleDelay);
      var v = oe(o.areas, function(w) {
        var x = Dve[w.brushType], T = Ee({
          boundingRect: x ? x(w) : void 0
        }, w);
        return T.selectors = Tve(T), T;
      }), g = Lw(o.option, T$, function(w) {
        w.mappingMethod = "fixed";
      });
      ae(c) && $(c, function(w) {
        h[w] = 1;
      });
      function m(w) {
        return c === "all" || !!h[w];
      }
      function y(w) {
        return !!w.length;
      }
      t.eachSeries(function(w, x) {
        var T = d[x] = [];
        w.subType === "parallel" ? _(w, x) : b(w, x, T);
      });
      function _(w, x) {
        var T = w.coordinateSystem;
        p = p || T.hasAxisBrushed(), m(x) && T.eachActiveState(w.getData(), function(A, I) {
          A === "active" && (f[I] = 1);
        });
      }
      function b(w, x, T) {
        if (!(!w.brushSelector || Mve(o, x)) && ($(v, function(I) {
          o.brushTargetManager.controlSeries(I, w, t) && T.push(I), p = p || y(T);
        }), m(x) && y(T))) {
          var A = w.getData();
          A.each(function(I) {
            C$(w, T, A, I) && (f[I] = 1);
          });
        }
      }
      t.eachSeries(function(w, x) {
        var T = {
          seriesId: w.id,
          seriesIndex: x,
          seriesName: w.name,
          dataIndex: []
        };
        l.selected.push(T);
        var A = d[x], I = w.getData(), M = m(x) ? function(k) {
          return f[k] ? (T.dataIndex.push(I.getRawIndex(k)), "inBrush") : "outOfBrush";
        } : function(k) {
          return C$(w, A, I, k) ? (T.dataIndex.push(I.getRawIndex(k)), "inBrush") : "outOfBrush";
        };
        (m(x) ? p : y(A)) && wve(T$, g, I, M);
      });
    }), Ave(e, i, a, n, r);
  }
  function Ave(t, e, r, n, i) {
    if (i) {
      var a = t.getZr();
      if (!a[$w]) {
        a[rb] || (a[rb] = Ive);
        var o = jc(a, rb, r, e);
        o(t, n);
      }
    }
  }
  function Ive(t, e) {
    if (!t.isDisposed()) {
      var r = t.getZr();
      r[$w] = true, t.dispatchAction({
        type: "brushSelect",
        batch: e
      }), r[$w] = false;
    }
  }
  function C$(t, e, r, n) {
    for (var i = 0, a = e.length; i < a; i++) {
      var o = e[i];
      if (t.brushSelector(n, r, o.selectors, o)) return true;
    }
  }
  function Mve(t, e) {
    var r = t.option.seriesIndex;
    return r != null && r !== "all" && (ae(r) ? et(r, e) < 0 : e !== r);
  }
  var Dve = {
    rect: function(t) {
      return A$(t.range);
    },
    polygon: function(t) {
      for (var e, r = t.range, n = 0, i = r.length; n < i; n++) {
        e = e || [
          [
            1 / 0,
            -1 / 0
          ],
          [
            1 / 0,
            -1 / 0
          ]
        ];
        var a = r[n];
        a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]);
      }
      return e && A$(e);
    }
  };
  function A$(t) {
    return new Ze(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
  }
  var Eve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r, n) {
      this.ecModel = r, this.api = n, this.model, (this._brushController = new v2(n.getZr())).on("brush", _e(this._onBrush, this)).mount();
    }, e.prototype.render = function(r, n, i, a) {
      this.model = r, this._updateController(r, n, i, a);
    }, e.prototype.updateTransform = function(r, n, i, a) {
      OH(n), this._updateController(r, n, i, a);
    }, e.prototype.updateVisual = function(r, n, i, a) {
      this.updateTransform(r, n, i, a);
    }, e.prototype.updateView = function(r, n, i, a) {
      this._updateController(r, n, i, a);
    }, e.prototype._updateController = function(r, n, i, a) {
      (!a || a.$from !== r.id) && this._brushController.setPanels(r.brushTargetManager.makePanelOpts(i)).enableBrush(r.brushOption).updateCovers(r.areas.slice());
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.prototype._onBrush = function(r) {
      var n = this.model.id, i = this.model.brushTargetManager.setOutputRanges(r.areas, this.ecModel);
      (!r.isEnd || r.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: n,
        areas: Oe(i),
        $from: n
      }), r.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: n,
        areas: Oe(i),
        $from: n
      });
    }, e.type = "brush", e;
  }(tr), kve = "#ddd", Pve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.areas = [], r.brushOption = {}, r;
    }
    return e.prototype.optionUpdated = function(r, n) {
      var i = this.option;
      !n && RH(i, r, [
        "inBrush",
        "outOfBrush"
      ]);
      var a = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: kve
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, e.prototype.setAreas = function(r) {
      r && (this.areas = oe(r, function(n) {
        return I$(this.option, n);
      }, this));
    }, e.prototype.setBrushOption = function(r) {
      this.brushOption = I$(this.option, r), this.brushType = this.brushOption.brushType;
    }, e.type = "brush", e.dependencies = [
      "geo",
      "grid",
      "xAxis",
      "yAxis",
      "parallel",
      "series"
    ], e.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: true,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: true,
      z: 1e4
    }, e;
  }(vt);
  function I$(t, e) {
    return je({
      brushType: t.brushType,
      brushMode: t.brushMode,
      transformable: t.transformable,
      brushStyle: new kt(t.brushStyle).getItemStyle(),
      removeOnClick: t.removeOnClick,
      z: t.z
    }, e, true);
  }
  var Lve = [
    "rect",
    "polygon",
    "lineX",
    "lineY",
    "keep",
    "clear"
  ], $ve = function(t) {
    K(e, t);
    function e() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return e.prototype.render = function(r, n, i) {
      var a, o, s;
      n.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = a, this._brushMode = o, $(r.get("type", true), function(l) {
        r.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
      });
    }, e.prototype.updateView = function(r, n, i) {
      this.render(r, n, i);
    }, e.prototype.getIcons = function() {
      var r = this.model, n = r.get("icon", true), i = {};
      return $(r.get("type", true), function(a) {
        n[a] && (i[a] = n[a]);
      }), i;
    }, e.prototype.onclick = function(r, n, i) {
      var a = this._brushType, o = this._brushMode;
      i === "clear" ? (n.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), n.dispatchAction({
        type: "brush",
        command: "clear",
        areas: []
      })) : n.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? a : a === i ? false : i,
          brushMode: i === "keep" ? o === "multiple" ? "single" : "multiple" : o
        }
      });
    }, e.getDefaultOption = function(r) {
      var n = {
        show: true,
        type: Lve.slice(),
        icon: {
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        },
        title: r.getLocaleModel().get([
          "toolbox",
          "brush",
          "title"
        ])
      };
      return n;
    }, e;
  }(di);
  function Rve(t) {
    t.registerComponentView(Eve), t.registerComponentModel(Pve), t.registerPreprocessor(bve), t.registerVisual(t.PRIORITY.VISUAL.BRUSH, Cve), t.registerAction({
      type: "brush",
      event: "brush",
      update: "updateVisual"
    }, function(e, r) {
      r.eachComponent({
        mainType: "brush",
        query: e
      }, function(n) {
        n.setAreas(e.areas);
      });
    }), t.registerAction({
      type: "brushSelect",
      event: "brushSelected",
      update: "none"
    }, dr), t.registerAction({
      type: "brushEnd",
      event: "brushEnd",
      update: "none"
    }, dr), ju("brush", $ve);
  }
  var Ove = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.layoutMode = {
        type: "box",
        ignoreSize: true
      }, r;
    }
    return e.type = "title", e.defaultOption = {
      z: 6,
      show: true,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, e;
  }(vt), Nve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.render = function(r, n, i) {
      if (this.group.removeAll(), !!r.get("show")) {
        var a = this.group, o = r.getModel("textStyle"), s = r.getModel("subtextStyle"), l = r.get("textAlign"), u = We(r.get("textBaseline"), r.get("textVerticalAlign")), c = new bt({
          style: Yt(o, {
            text: r.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        }), h = c.getBoundingRect(), f = r.get("subtext"), d = new bt({
          style: Yt(s, {
            text: f,
            fill: s.getTextColor(),
            y: h.height + r.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: true
          }),
          z2: 10
        }), p = r.get("link"), v = r.get("sublink"), g = r.get("triggerEvent", true);
        c.silent = !p && !g, d.silent = !v && !g, p && c.on("click", function() {
          Ng(p, "_" + r.get("target"));
        }), v && d.on("click", function() {
          Ng(v, "_" + r.get("subtarget"));
        }), Ge(c).eventData = Ge(d).eventData = g ? {
          componentType: "title",
          componentIndex: r.componentIndex
        } : null, a.add(c), f && a.add(d);
        var m = a.getBoundingRect(), y = r.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var _ = Tr(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, r.get("padding"));
        l || (l = r.get("left") || r.get("right"), l === "middle" && (l = "center"), l === "right" ? _.x += _.width : l === "center" && (_.x += _.width / 2)), u || (u = r.get("top") || r.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? _.y += _.height : u === "middle" && (_.y += _.height / 2), u = u || "top"), a.x = _.x, a.y = _.y, a.markRedraw();
        var b = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(b), d.setStyle(b), m = a.getBoundingRect();
        var w = _.margin, x = r.getItemStyle([
          "color",
          "opacity"
        ]);
        x.fill = r.get("backgroundColor");
        var T = new yt({
          shape: {
            x: m.x - w[3],
            y: m.y - w[0],
            width: m.width + w[1] + w[3],
            height: m.height + w[0] + w[2],
            r: r.get("borderRadius")
          },
          style: x,
          subPixelOptimize: true,
          silent: true
        });
        a.add(T);
      }
    }, e.type = "title", e;
  }(tr);
  function Bve(t) {
    t.registerComponentModel(Ove), t.registerComponentView(Nve);
  }
  var M$ = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.layoutMode = "box", r;
    }
    return e.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i), this._initData();
    }, e.prototype.mergeOption = function(r) {
      t.prototype.mergeOption.apply(this, arguments), this._initData();
    }, e.prototype.setCurrentIndex = function(r) {
      r == null && (r = this.option.currentIndex);
      var n = this._data.count();
      this.option.loop ? r = (r % n + n) % n : (r >= n && (r = n - 1), r < 0 && (r = 0)), this.option.currentIndex = r;
    }, e.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, e.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, e.prototype.setPlayState = function(r) {
      this.option.autoPlay = !!r;
    }, e.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, e.prototype._initData = function() {
      var r = this.option, n = r.data || [], i = r.axisType, a = this._names = [], o;
      i === "category" ? (o = [], $(n, function(u, c) {
        var h = xr(Fc(u), ""), f;
        Le(u) ? (f = Oe(u), f.value = c) : f = c, o.push(f), a.push(h);
      })) : o = n;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new yn([
        {
          name: "value",
          type: s
        }
      ], this);
      l.initData(o, a);
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.getCategories = function() {
      if (this.get("axisType") === "category") return this._names.slice();
    }, e.type = "timeline", e.defaultOption = {
      z: 4,
      show: true,
      axisType: "time",
      realtime: true,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: false,
      rewind: false,
      loop: true,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, e;
  }(vt), NH = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "timeline.slider", e.defaultOption = xs(M$.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: false,
      tooltip: {
        trigger: "item"
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: true,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        show: true,
        interval: "auto",
        rotate: 0,
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        animation: true,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: true,
        showPlayBtn: true,
        showPrevBtn: true,
        showNextBtn: true,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true,
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), e;
  }(M$);
  yr(NH, ay.prototype);
  var zve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "timeline", e;
  }(tr), Fve = function(t) {
    K(e, t);
    function e(r, n, i, a) {
      var o = t.call(this, r, n, i) || this;
      return o.type = a || "value", o;
    }
    return e.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, e.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, e;
  }(Ji), nb = Math.PI, D$ = _t(), Vve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function(r, n) {
      this.api = n;
    }, e.prototype.render = function(r, n, i) {
      if (this.model = r, this.api = i, this.ecModel = n, this.group.removeAll(), r.get("show", true)) {
        var a = this._layout(r, i), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, r);
        r.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return $r("nameValue", {
            noName: true,
            value: c
          });
        }, $([
          "AxisLine",
          "AxisTick",
          "Control",
          "CurrentPointer"
        ], function(u) {
          this["_render" + u](a, o, l, r);
        }, this), this._renderAxisLabel(a, s, l, r), this._position(a, r);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, e.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._clearTimer();
    }, e.prototype._layout = function(r, n) {
      var i = r.get([
        "label",
        "position"
      ]), a = r.get("orient"), o = Wve(r, n), s;
      i == null || i === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < n.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < n.getWidth() / 2 ? "+" : "-" : me(i) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][i] : s = i;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: nb / 2
      }, h = a === "vertical" ? o.height : o.width, f = r.getModel("controlStyle"), d = f.get("show", true), p = d ? f.get("itemSize") : 0, v = d ? f.get("itemGap") : 0, g = p + v, m = r.get([
        "label",
        "rotate"
      ]) || 0;
      m = m * nb / 180;
      var y, _, b, w = f.get("position", true), x = d && f.get("showPlayBtn", true), T = d && f.get("showPrevBtn", true), A = d && f.get("showNextBtn", true), I = 0, M = h;
      w === "left" || w === "bottom" ? (x && (y = [
        0,
        0
      ], I += g), T && (_ = [
        I,
        0
      ], I += g), A && (b = [
        M - p,
        0
      ], M -= g)) : (x && (y = [
        M - p,
        0
      ], M -= g), T && (_ = [
        0,
        0
      ], I += g), A && (b = [
        M - p,
        0
      ], M -= g));
      var k = [
        I,
        M
      ];
      return r.get("inverse") && k.reverse(), {
        viewRect: o,
        mainLength: h,
        orient: a,
        rotation: c[a],
        labelRotation: m,
        labelPosOpt: s,
        labelAlign: r.get([
          "label",
          "align"
        ]) || l[a],
        labelBaseline: r.get([
          "label",
          "verticalAlign"
        ]) || r.get([
          "label",
          "baseline"
        ]) || u[a],
        playPosition: y,
        prevBtnPosition: _,
        nextBtnPosition: b,
        axisExtent: k,
        controlSize: p,
        controlGap: v
      };
    }, e.prototype._position = function(r, n) {
      var i = this._mainGroup, a = this._labelGroup, o = r.viewRect;
      if (r.orient === "vertical") {
        var s = Hn(), l = o.x, u = o.y + o.height;
        Pa(s, s, [
          -l,
          -u
        ]), nu(s, s, -nb / 2), Pa(s, s, [
          l,
          u
        ]), o = o.clone(), o.applyTransform(s);
      }
      var c = y(o), h = y(i.getBoundingRect()), f = y(a.getBoundingRect()), d = [
        i.x,
        i.y
      ], p = [
        a.x,
        a.y
      ];
      p[0] = d[0] = c[0][0];
      var v = r.labelPosOpt;
      if (v == null || me(v)) {
        var g = v === "+" ? 0 : 1;
        _(d, h, c, 1, g), _(p, f, c, 1, 1 - g);
      } else {
        var g = v >= 0 ? 0 : 1;
        _(d, h, c, 1, g), p[1] = d[1] + v;
      }
      i.setPosition(d), a.setPosition(p), i.rotation = a.rotation = r.rotation, m(i), m(a);
      function m(b) {
        b.originX = c[0][0] - b.x, b.originY = c[1][0] - b.y;
      }
      function y(b) {
        return [
          [
            b.x,
            b.x + b.width
          ],
          [
            b.y,
            b.y + b.height
          ]
        ];
      }
      function _(b, w, x, T, A) {
        b[T] += x[T][A] - w[T][A];
      }
    }, e.prototype._createAxis = function(r, n) {
      var i = n.getData(), a = n.get("axisType"), o = Gve(n, a);
      o.getTicks = function() {
        return i.mapArray([
          "value"
        ], function(u) {
          return {
            value: u
          };
        });
      };
      var s = i.getDataExtent("value");
      o.setExtent(s[0], s[1]), o.calcNiceTicks();
      var l = new Fve("value", o, r.axisExtent, a);
      return l.model = n, l;
    }, e.prototype._createGroup = function(r) {
      var n = this[r] = new Be();
      return this.group.add(n), n;
    }, e.prototype._renderAxisLine = function(r, n, i, a) {
      var o = i.getExtent();
      if (a.get([
        "lineStyle",
        "show"
      ])) {
        var s = new Mr({
          shape: {
            x1: o[0],
            y1: 0,
            x2: o[1],
            y2: 0
          },
          style: te({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: true,
          z2: 1
        });
        n.add(s);
        var l = this._progressLine = new Mr({
          shape: {
            x1: o[0],
            x2: this._currentPointer ? this._currentPointer.x : o[0],
            y1: 0,
            y2: 0
          },
          style: Ee({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, a.getModel([
            "progress",
            "lineStyle"
          ]).getLineStyle()),
          silent: true,
          z2: 1
        });
        n.add(l);
      }
    }, e.prototype._renderAxisTick = function(r, n, i, a) {
      var o = this, s = a.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], $(l, function(u) {
        var c = i.dataToCoord(u.value), h = s.getItemModel(u.value), f = h.getModel("itemStyle"), d = h.getModel([
          "emphasis",
          "itemStyle"
        ]), p = h.getModel([
          "progress",
          "itemStyle"
        ]), v = {
          x: c,
          y: 0,
          onclick: _e(o._changeTimeline, o, u.value)
        }, g = E$(h, f, n, v);
        g.ensureState("emphasis").style = d.getItemStyle(), g.ensureState("progress").style = p.getItemStyle(), Nl(g);
        var m = Ge(g);
        h.get("tooltip") ? (m.dataIndex = u.value, m.dataModel = a) : m.dataIndex = m.dataModel = null, o._tickSymbols.push(g);
      });
    }, e.prototype._renderAxisLabel = function(r, n, i, a) {
      var o = this, s = i.getLabelModel();
      if (s.get("show")) {
        var l = a.getData(), u = i.getViewLabels();
        this._tickLabels = [], $(u, function(c) {
          var h = c.tickValue, f = l.getItemModel(h), d = f.getModel("label"), p = f.getModel([
            "emphasis",
            "label"
          ]), v = f.getModel([
            "progress",
            "label"
          ]), g = i.dataToCoord(c.tickValue), m = new bt({
            x: g,
            y: 0,
            rotation: r.labelRotation - r.rotation,
            onclick: _e(o._changeTimeline, o, h),
            silent: false,
            style: Yt(d, {
              text: c.formattedLabel,
              align: r.labelAlign,
              verticalAlign: r.labelBaseline
            })
          });
          m.ensureState("emphasis").style = Yt(p), m.ensureState("progress").style = Yt(v), n.add(m), Nl(m), D$(m).dataIndex = h, o._tickLabels.push(m);
        });
      }
    }, e.prototype._renderControl = function(r, n, i, a) {
      var o = r.controlSize, s = r.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel([
        "emphasis",
        "controlStyle"
      ]).getItemStyle(), c = a.getPlayState(), h = a.get("inverse", true);
      f(r.nextBtnPosition, "next", _e(this._changeTimeline, this, h ? "-" : "+")), f(r.prevBtnPosition, "prev", _e(this._changeTimeline, this, h ? "+" : "-")), f(r.playPosition, c ? "stop" : "play", _e(this._handlePlayClick, this, !c), true);
      function f(d, p, v, g) {
        if (d) {
          var m = ji(We(a.get([
            "controlStyle",
            p + "BtnSize"
          ]), o), o), y = [
            0,
            -m / 2,
            m,
            m
          ], _ = Hve(a, p + "Icon", y, {
            x: d[0],
            y: d[1],
            originX: o / 2,
            originY: 0,
            rotation: g ? -s : 0,
            rectHover: true,
            style: l,
            onclick: v
          });
          _.ensureState("emphasis").style = u, n.add(_), Nl(_);
        }
      }
    }, e.prototype._renderCurrentPointer = function(r, n, i, a) {
      var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(h) {
          h.draggable = true, h.drift = _e(u._handlePointerDrag, u), h.ondragend = _e(u._handlePointerDragend, u), k$(h, u._progressLine, s, i, a, true);
        },
        onUpdate: function(h) {
          k$(h, u._progressLine, s, i, a);
        }
      };
      this._currentPointer = E$(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, e.prototype._handlePlayClick = function(r) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: r,
        from: this.uid
      });
    }, e.prototype._handlePointerDrag = function(r, n, i) {
      this._clearTimer(), this._pointerChangeTimeline([
        i.offsetX,
        i.offsetY
      ]);
    }, e.prototype._handlePointerDragend = function(r) {
      this._pointerChangeTimeline([
        r.offsetX,
        r.offsetY
      ], true);
    }, e.prototype._pointerChangeTimeline = function(r, n) {
      var i = this._toAxisCoord(r)[0], a = this._axis, o = mi(a.getExtent().slice());
      i > o[1] && (i = o[1]), i < o[0] && (i = o[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = i, s.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (n || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, e.prototype._doPlayStop = function() {
      var r = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var n = r.model;
        r._changeTimeline(n.getCurrentIndex() + (n.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, e.prototype._toAxisCoord = function(r) {
      var n = this._mainGroup.getLocalTransform();
      return Yi(r, n, true);
    }, e.prototype._findNearestTick = function(r) {
      var n = this.model.getData(), i = 1 / 0, a, o = this._axis;
      return n.each([
        "value"
      ], function(s, l) {
        var u = o.dataToCoord(s), c = Math.abs(u - r);
        c < i && (i = c, a = l);
      }), a;
    }, e.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, e.prototype._changeTimeline = function(r) {
      var n = this.model.getCurrentIndex();
      r === "+" ? r = n + 1 : r === "-" && (r = n - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: r,
        from: this.uid
      });
    }, e.prototype._updateTicksStatus = function() {
      var r = this.model.getCurrentIndex(), n = this._tickSymbols, i = this._tickLabels;
      if (n) for (var a = 0; a < n.length; a++) n && n[a] && n[a].toggleState("progress", a < r);
      if (i) for (var a = 0; a < i.length; a++) i && i[a] && i[a].toggleState("progress", D$(i[a]).dataIndex <= r);
    }, e.type = "timeline.slider", e;
  }(zve);
  function Gve(t, e) {
    if (e = e || t.get("type"), e) switch (e) {
      case "category":
        return new hy({
          ordinalMeta: t.getCategories(),
          extent: [
            1 / 0,
            -1 / 0
          ]
        });
      case "time":
        return new VT({
          locale: t.ecModel.getLocaleModel(),
          useUTC: t.ecModel.get("useUTC")
        });
      default:
        return new go();
    }
  }
  function Wve(t, e) {
    return Tr(t.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    }, t.get("padding"));
  }
  function Hve(t, e, r, n) {
    var i = n.style, a = Od(t.get([
      "controlStyle",
      e
    ]), n || {}, new Ze(r[0], r[1], r[2], r[3]));
    return i && a.setStyle(i), a;
  }
  function E$(t, e, r, n, i, a) {
    var o = e.get("color");
    if (i) i.setColor(o), r.add(i), a && a.onUpdate(i);
    else {
      var s = t.get("symbol");
      i = mr(s, -1, -1, 2, 2, o), i.setStyle("strokeNoScale", true), r.add(i), a && a.onCreate(i);
    }
    var l = e.getItemStyle([
      "color"
    ]);
    i.setStyle(l), n = je({
      rectHover: true,
      z2: 100
    }, n, true);
    var u = Kc(t.get("symbolSize"));
    n.scaleX = u[0] / 2, n.scaleY = u[1] / 2;
    var c = ou(t.get("symbolOffset"), u);
    c && (n.x = (n.x || 0) + c[0], n.y = (n.y || 0) + c[1]);
    var h = t.get("symbolRotate");
    return n.rotation = (h || 0) * Math.PI / 180 || 0, i.attr(n), i.updateTransform(), i;
  }
  function k$(t, e, r, n, i, a) {
    if (!t.dragging) {
      var o = i.getModel("checkpointStyle"), s = n.dataToCoord(i.getData().get("value", r));
      if (a || !o.get("animation", true)) t.attr({
        x: s,
        y: 0
      }), e && e.attr({
        shape: {
          x2: s
        }
      });
      else {
        var l = {
          duration: o.get("animationDuration", true),
          easing: o.get("animationEasing", true)
        };
        t.stopAnimation(null, true), t.animateTo({
          x: s,
          y: 0
        }, l), e && e.animateTo({
          shape: {
            x2: s
          }
        }, l);
      }
    }
  }
  function Uve(t) {
    t.registerAction({
      type: "timelineChange",
      event: "timelineChanged",
      update: "prepareAndUpdate"
    }, function(e, r, n) {
      var i = r.getComponent("timeline");
      return i && e.currentIndex != null && (i.setCurrentIndex(e.currentIndex), !i.get("loop", true) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(false), n.dispatchAction({
        type: "timelinePlayChange",
        playState: false,
        from: e.from
      }))), r.resetOption("timeline", {
        replaceMerge: i.get("replaceMerge", true)
      }), Ee({
        currentIndex: i.option.currentIndex
      }, e);
    }), t.registerAction({
      type: "timelinePlayChange",
      event: "timelinePlayChanged",
      update: "update"
    }, function(e, r) {
      var n = r.getComponent("timeline");
      n && e.playState != null && n.setPlayState(e.playState);
    });
  }
  function Yve(t) {
    var e = t && t.timeline;
    ae(e) || (e = e ? [
      e
    ] : []), $(e, function(r) {
      r && qve(r);
    });
  }
  function qve(t) {
    var e = t.type, r = {
      number: "value",
      time: "time"
    };
    if (r[e] && (t.axisType = r[e], delete t.type), P$(t), yl(t, "controlPosition")) {
      var n = t.controlStyle || (t.controlStyle = {});
      yl(n, "position") || (n.position = t.controlPosition), n.position === "none" && !yl(n, "show") && (n.show = false, delete n.position), delete t.controlPosition;
    }
    $(t.data || [], function(i) {
      Le(i) && !ae(i) && (!yl(i, "value") && yl(i, "name") && (i.value = i.name), P$(i));
    });
  }
  function P$(t) {
    var e = t.itemStyle || (t.itemStyle = {}), r = e.emphasis || (e.emphasis = {}), n = t.label || t.label || {}, i = n.normal || (n.normal = {}), a = {
      normal: 1,
      emphasis: 1
    };
    $(n, function(o, s) {
      !a[s] && !yl(i, s) && (i[s] = o);
    }), r.label && !yl(n, "emphasis") && (n.emphasis = r.label, delete r.label);
  }
  function yl(t, e) {
    return t.hasOwnProperty(e);
  }
  function Xve(t) {
    t.registerComponentModel(NH), t.registerComponentView(Vve), t.registerSubTypeDefaulter("timeline", function() {
      return "slider";
    }), Uve(t), t.registerPreprocessor(Yve);
  }
  function U2(t, e) {
    if (!t) return false;
    for (var r = ae(t) ? t : [
      t
    ], n = 0; n < r.length; n++) if (r[n] && r[n][e]) return true;
    return false;
  }
  function lv(t) {
    Ul(t, "label", [
      "show"
    ]);
  }
  var uv = _t(), yo = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.createdBySelf = false, r;
    }
    return e.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i), this._mergeOption(r, i, false, true);
    }, e.prototype.isAnimationEnabled = function() {
      if (ct.node) return false;
      var r = this.__hostSeries;
      return this.getShallow("animation") && r && r.isAnimationEnabled();
    }, e.prototype.mergeOption = function(r, n) {
      this._mergeOption(r, n, false, false);
    }, e.prototype._mergeOption = function(r, n, i, a) {
      var o = this.mainType;
      i || n.eachSeries(function(s) {
        var l = s.get(this.mainType, true), u = uv(s)[o];
        if (!l || !l.data) {
          uv(s)[o] = null;
          return;
        }
        u ? u._mergeOption(l, n, true) : (a && lv(l), $(l.data, function(c) {
          c instanceof Array ? (lv(c[0]), lv(c[1])) : lv(c);
        }), u = this.createMarkerModelFromSeries(l, this, n), te(u, {
          mainType: this.mainType,
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: true
        }), u.__hostSeries = s), uv(s)[o] = u;
      }, this);
    }, e.prototype.formatTooltip = function(r, n, i) {
      var a = this.getData(), o = this.getRawValue(r), s = a.getName(r);
      return $r("section", {
        header: this.name,
        blocks: [
          $r("nameValue", {
            name: s,
            value: o,
            noName: !s,
            noValue: o == null
          })
        ]
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.setData = function(r) {
      this._data = r;
    }, e.prototype.getDataParams = function(r, n) {
      var i = ay.prototype.getDataParams.call(this, r, n), a = this.__hostSeries;
      return a && (i.seriesId = a.id, i.seriesName = a.name, i.seriesType = a.subType), i;
    }, e.getMarkerModelFromSeries = function(r, n) {
      return uv(r)[n];
    }, e.type = "marker", e.dependencies = [
      "series",
      "grid",
      "polar",
      "geo"
    ], e;
  }(vt);
  yr(yo, ay.prototype);
  var jve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new e(r, n, i);
    }, e.type = "markPoint", e.defaultOption = {
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }, e;
  }(yo);
  function Rw(t) {
    return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)));
  }
  function Kve(t) {
    return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y));
  }
  function cv(t, e, r, n, i, a) {
    var o = [], s = vs(e, n), l = s ? e.getCalculationInfo("stackResultDimension") : n, u = Y2(e, l, t), c = e.indicesOfNearest(l, u)[0];
    o[i] = e.get(r, c), o[a] = e.get(l, c);
    var h = e.get(n, c), f = wa(e.get(n, c));
    return f = Math.min(f, 20), f >= 0 && (o[a] = +o[a].toFixed(f)), [
      o,
      h
    ];
  }
  var ib = {
    min: Ye(cv, "min"),
    max: Ye(cv, "max"),
    average: Ye(cv, "average"),
    median: Ye(cv, "median")
  };
  function dd(t, e) {
    if (e) {
      var r = t.getData(), n = t.coordinateSystem, i = n && n.dimensions;
      if (!Kve(e) && !ae(e.coord) && ae(i)) {
        var a = BH(e, r, n, t);
        if (e = Oe(e), e.type && ib[e.type] && a.baseAxis && a.valueAxis) {
          var o = et(i, a.baseAxis.dim), s = et(i, a.valueAxis.dim), l = ib[e.type](r, a.baseDataDim, a.valueDataDim, o, s);
          e.coord = l[0], e.value = l[1];
        } else e.coord = [
          e.xAxis != null ? e.xAxis : e.radiusAxis,
          e.yAxis != null ? e.yAxis : e.angleAxis
        ];
      }
      if (e.coord == null || !ae(i)) e.coord = [];
      else for (var u = e.coord, c = 0; c < 2; c++) ib[u[c]] && (u[c] = Y2(r, r.mapDimension(i[c]), u[c]));
      return e;
    }
  }
  function BH(t, e, r, n) {
    var i = {};
    return t.valueIndex != null || t.valueDim != null ? (i.valueDataDim = t.valueIndex != null ? e.getDimension(t.valueIndex) : t.valueDim, i.valueAxis = r.getAxis(Zve(n, i.valueDataDim)), i.baseAxis = r.getOtherAxis(i.valueAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim)) : (i.baseAxis = n.getBaseAxis(), i.valueAxis = r.getOtherAxis(i.baseAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim), i.valueDataDim = e.mapDimension(i.valueAxis.dim)), i;
  }
  function Zve(t, e) {
    var r = t.getData().getDimensionInfo(e);
    return r && r.coordDim;
  }
  function pd(t, e) {
    return t && t.containData && e.coord && !Rw(e) ? t.containData(e.coord) : true;
  }
  function Qve(t, e, r) {
    return t && t.containZone && e.coord && r.coord && !Rw(e) && !Rw(r) ? t.containZone(e.coord, r.coord) : true;
  }
  function zH(t, e) {
    return t ? function(r, n, i, a) {
      var o = a < 2 ? r.coord && r.coord[a] : r.value;
      return ss(o, e[a]);
    } : function(r, n, i, a) {
      return ss(r.value, e[a]);
    };
  }
  function Y2(t, e, r) {
    if (r === "average") {
      var n = 0, i = 0;
      return t.each(e, function(a, o) {
        isNaN(a) || (n += a, i++);
      }), n / i;
    } else return r === "median" ? t.getMedian(e) : t.getDataExtent(e)[r === "max" ? 1 : 0];
  }
  var ab = _t(), q2 = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.init = function() {
      this.markerGroupMap = Ce();
    }, e.prototype.render = function(r, n, i) {
      var a = this, o = this.markerGroupMap;
      o.each(function(s) {
        ab(s).keep = false;
      }), n.eachSeries(function(s) {
        var l = yo.getMarkerModelFromSeries(s, a.type);
        l && a.renderSeries(s, l, n, i);
      }), o.each(function(s) {
        !ab(s).keep && a.group.remove(s.group);
      });
    }, e.prototype.markKeep = function(r) {
      ab(r).keep = true;
    }, e.prototype.toggleBlurSeries = function(r, n) {
      var i = this;
      $(r, function(a) {
        var o = yo.getMarkerModelFromSeries(a, i.type);
        if (o) {
          var s = o.getData();
          s.eachItemGraphicEl(function(l) {
            l && (n ? E4(l) : hT(l));
          });
        }
      });
    }, e.type = "marker", e;
  }(tr);
  function L$(t, e, r) {
    var n = e.coordinateSystem;
    t.each(function(i) {
      var a = t.getItemModel(i), o, s = pe(a.get("x"), r.getWidth()), l = pe(a.get("y"), r.getHeight());
      if (!isNaN(s) && !isNaN(l)) o = [
        s,
        l
      ];
      else if (e.getMarkerPosition) o = e.getMarkerPosition(t.getValues(t.dimensions, i));
      else if (n) {
        var u = t.get(n.dimensions[0], i), c = t.get(n.dimensions[1], i);
        o = n.dataToPoint([
          u,
          c
        ]);
      }
      isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), t.setItemLayout(i, o);
    });
  }
  var Jve = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(a) {
        var o = yo.getMarkerModelFromSeries(a, "markPoint");
        o && (L$(o.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, e.prototype.renderSeries = function(r, n, i, a) {
      var o = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Gd()), h = ege(o, r, n);
      n.setData(h), L$(n.getData(), r, a), h.each(function(f) {
        var d = h.getItemModel(f), p = d.getShallow("symbol"), v = d.getShallow("symbolSize"), g = d.getShallow("symbolRotate"), m = d.getShallow("symbolOffset"), y = d.getShallow("symbolKeepAspect");
        if (De(p) || De(v) || De(g) || De(m)) {
          var _ = n.getRawValue(f), b = n.getDataParams(f);
          De(p) && (p = p(_, b)), De(v) && (v = v(_, b)), De(g) && (g = g(_, b)), De(m) && (m = m(_, b));
        }
        var w = d.getModel("itemStyle").getItemStyle(), x = Bd(l, "color");
        w.fill || (w.fill = x), h.setItemVisual(f, {
          symbol: p,
          symbolSize: v,
          symbolRotate: g,
          symbolOffset: m,
          symbolKeepAspect: y,
          style: w
        });
      }), c.updateData(h), this.group.add(c.group), h.eachItemGraphicEl(function(f) {
        f.traverse(function(d) {
          Ge(d).dataModel = n;
        });
      }), this.markKeep(c), c.group.silent = n.get("silent") || r.get("silent");
    }, e.type = "markPoint", e;
  }(q2);
  function ege(t, e, r) {
    var n;
    t ? n = oe(t && t.dimensions, function(s) {
      var l = e.getData().getDimensionInfo(e.getData().mapDimension(s)) || {};
      return te(te({}, l), {
        name: s,
        ordinalMeta: null
      });
    }) : n = [
      {
        name: "value",
        type: "float"
      }
    ];
    var i = new yn(n, r), a = oe(r.get("data"), Ye(dd, e));
    t && (a = Dt(a, Ye(pd, t)));
    var o = zH(!!t, n);
    return i.initData(a, null, o), i;
  }
  function tge(t) {
    t.registerComponentModel(jve), t.registerComponentView(Jve), t.registerPreprocessor(function(e) {
      U2(e.series, "markPoint") && (e.markPoint = e.markPoint || {});
    });
  }
  var rge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new e(r, n, i);
    }, e.type = "markLine", e.defaultOption = {
      z: 5,
      symbol: [
        "circle",
        "arrow"
      ],
      symbolSize: [
        8,
        16
      ],
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, e;
  }(yo), hv = _t(), nge = function(t, e, r, n) {
    var i = t.getData(), a;
    if (ae(n)) a = n;
    else {
      var o = n.type;
      if (o === "min" || o === "max" || o === "average" || o === "median" || n.xAxis != null || n.yAxis != null) {
        var s = void 0, l = void 0;
        if (n.yAxis != null || n.xAxis != null) s = e.getAxis(n.yAxis != null ? "y" : "x"), l = Fr(n.yAxis, n.xAxis);
        else {
          var u = BH(n, i, e, t);
          s = u.valueAxis;
          var c = k5(i, u.valueDataDim);
          l = Y2(i, c, o);
        }
        var h = s.dim === "x" ? 0 : 1, f = 1 - h, d = Oe(n), p = {
          coord: []
        };
        d.type = null, d.coord = [], d.coord[f] = -1 / 0, p.coord[f] = 1 / 0;
        var v = r.get("precision");
        v >= 0 && xt(l) && (l = +l.toFixed(Math.min(v, 20))), d.coord[h] = p.coord[h] = l, a = [
          d,
          p,
          {
            type: o,
            valueIndex: n.valueIndex,
            value: l
          }
        ];
      } else a = [];
    }
    var g = [
      dd(t, a[0]),
      dd(t, a[1]),
      te({}, a[2])
    ];
    return g[2].type = g[2].type || null, je(g[2], g[0]), je(g[2], g[1]), g;
  };
  function lm(t) {
    return !isNaN(t) && !isFinite(t);
  }
  function $$(t, e, r, n) {
    var i = 1 - t, a = n.dimensions[t];
    return lm(e[i]) && lm(r[i]) && e[t] === r[t] && n.getAxis(a).containData(e[t]);
  }
  function ige(t, e) {
    if (t.type === "cartesian2d") {
      var r = e[0].coord, n = e[1].coord;
      if (r && n && ($$(1, r, n, t) || $$(0, r, n, t))) return true;
    }
    return pd(t, e[0]) && pd(t, e[1]);
  }
  function ob(t, e, r, n, i) {
    var a = n.coordinateSystem, o = t.getItemModel(e), s, l = pe(o.get("x"), i.getWidth()), u = pe(o.get("y"), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) s = [
      l,
      u
    ];
    else {
      if (n.getMarkerPosition) s = n.getMarkerPosition(t.getValues(t.dimensions, e));
      else {
        var c = a.dimensions, h = t.get(c[0], e), f = t.get(c[1], e);
        s = a.dataToPoint([
          h,
          f
        ]);
      }
      if (lu(a, "cartesian2d")) {
        var d = a.getAxis("x"), p = a.getAxis("y"), c = a.dimensions;
        lm(t.get(c[0], e)) ? s[0] = d.toGlobalCoord(d.getExtent()[r ? 0 : 1]) : lm(t.get(c[1], e)) && (s[1] = p.toGlobalCoord(p.getExtent()[r ? 0 : 1]));
      }
      isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
    }
    t.setItemLayout(e, s);
  }
  var age = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(a) {
        var o = yo.getMarkerModelFromSeries(a, "markLine");
        if (o) {
          var s = o.getData(), l = hv(o).from, u = hv(o).to;
          l.each(function(c) {
            ob(l, c, true, a, i), ob(u, c, false, a, i);
          }), s.each(function(c) {
            s.setItemLayout(c, [
              l.getItemLayout(c),
              u.getItemLayout(c)
            ]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, e.prototype.renderSeries = function(r, n, i, a) {
      var o = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new p2());
      this.group.add(c.group);
      var h = oge(o, r, n), f = h.from, d = h.to, p = h.line;
      hv(n).from = f, hv(n).to = d, n.setData(p);
      var v = n.get("symbol"), g = n.get("symbolSize"), m = n.get("symbolRotate"), y = n.get("symbolOffset");
      ae(v) || (v = [
        v,
        v
      ]), ae(g) || (g = [
        g,
        g
      ]), ae(m) || (m = [
        m,
        m
      ]), ae(y) || (y = [
        y,
        y
      ]), h.from.each(function(b) {
        _(f, b, true), _(d, b, false);
      }), p.each(function(b) {
        var w = p.getItemModel(b).getModel("lineStyle").getLineStyle();
        p.setItemLayout(b, [
          f.getItemLayout(b),
          d.getItemLayout(b)
        ]), w.stroke == null && (w.stroke = f.getItemVisual(b, "style").fill), p.setItemVisual(b, {
          fromSymbolKeepAspect: f.getItemVisual(b, "symbolKeepAspect"),
          fromSymbolOffset: f.getItemVisual(b, "symbolOffset"),
          fromSymbolRotate: f.getItemVisual(b, "symbolRotate"),
          fromSymbolSize: f.getItemVisual(b, "symbolSize"),
          fromSymbol: f.getItemVisual(b, "symbol"),
          toSymbolKeepAspect: d.getItemVisual(b, "symbolKeepAspect"),
          toSymbolOffset: d.getItemVisual(b, "symbolOffset"),
          toSymbolRotate: d.getItemVisual(b, "symbolRotate"),
          toSymbolSize: d.getItemVisual(b, "symbolSize"),
          toSymbol: d.getItemVisual(b, "symbol"),
          style: w
        });
      }), c.updateData(p), h.line.eachItemGraphicEl(function(b) {
        Ge(b).dataModel = n, b.traverse(function(w) {
          Ge(w).dataModel = n;
        });
      });
      function _(b, w, x) {
        var T = b.getItemModel(w);
        ob(b, w, x, r, a);
        var A = T.getModel("itemStyle").getItemStyle();
        A.fill == null && (A.fill = Bd(l, "color")), b.setItemVisual(w, {
          symbolKeepAspect: T.get("symbolKeepAspect"),
          symbolOffset: We(T.get("symbolOffset", true), y[x ? 0 : 1]),
          symbolRotate: We(T.get("symbolRotate", true), m[x ? 0 : 1]),
          symbolSize: We(T.get("symbolSize"), g[x ? 0 : 1]),
          symbol: We(T.get("symbol", true), v[x ? 0 : 1]),
          style: A
        });
      }
      this.markKeep(c), c.group.silent = n.get("silent") || r.get("silent");
    }, e.type = "markLine", e;
  }(q2);
  function oge(t, e, r) {
    var n;
    t ? n = oe(t && t.dimensions, function(u) {
      var c = e.getData().getDimensionInfo(e.getData().mapDimension(u)) || {};
      return te(te({}, c), {
        name: u,
        ordinalMeta: null
      });
    }) : n = [
      {
        name: "value",
        type: "float"
      }
    ];
    var i = new yn(n, r), a = new yn(n, r), o = new yn([], r), s = oe(r.get("data"), Ye(nge, e, t, r));
    t && (s = Dt(s, Ye(ige, t)));
    var l = zH(!!t, n);
    return i.initData(oe(s, function(u) {
      return u[0];
    }), null, l), a.initData(oe(s, function(u) {
      return u[1];
    }), null, l), o.initData(oe(s, function(u) {
      return u[2];
    })), o.hasItemOption = true, {
      from: i,
      to: a,
      line: o
    };
  }
  function sge(t) {
    t.registerComponentModel(rge), t.registerComponentView(age), t.registerPreprocessor(function(e) {
      U2(e.series, "markLine") && (e.markLine = e.markLine || {});
    });
  }
  var lge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new e(r, n, i);
    }, e.type = "markArea", e.defaultOption = {
      z: 1,
      tooltip: {
        trigger: "item"
      },
      animation: false,
      label: {
        show: true,
        position: "top"
      },
      itemStyle: {
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: true,
          position: "top"
        }
      }
    }, e;
  }(yo), fv = _t(), uge = function(t, e, r, n) {
    var i = n[0], a = n[1];
    if (!(!i || !a)) {
      var o = dd(t, i), s = dd(t, a), l = o.coord, u = s.coord;
      l[0] = Fr(l[0], -1 / 0), l[1] = Fr(l[1], -1 / 0), u[0] = Fr(u[0], 1 / 0), u[1] = Fr(u[1], 1 / 0);
      var c = qS([
        {},
        o,
        s
      ]);
      return c.coord = [
        o.coord,
        s.coord
      ], c.x0 = o.x, c.y0 = o.y, c.x1 = s.x, c.y1 = s.y, c;
    }
  };
  function um(t) {
    return !isNaN(t) && !isFinite(t);
  }
  function R$(t, e, r, n) {
    var i = 1 - t;
    return um(e[i]) && um(r[i]);
  }
  function cge(t, e) {
    var r = e.coord[0], n = e.coord[1], i = {
      coord: r,
      x: e.x0,
      y: e.y0
    }, a = {
      coord: n,
      x: e.x1,
      y: e.y1
    };
    return lu(t, "cartesian2d") ? r && n && (R$(1, r, n) || R$(0, r, n)) ? true : Qve(t, i, a) : pd(t, i) || pd(t, a);
  }
  function O$(t, e, r, n, i) {
    var a = n.coordinateSystem, o = t.getItemModel(e), s, l = pe(o.get(r[0]), i.getWidth()), u = pe(o.get(r[1]), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) s = [
      l,
      u
    ];
    else {
      if (n.getMarkerPosition) {
        var c = t.getValues([
          "x0",
          "y0"
        ], e), h = t.getValues([
          "x1",
          "y1"
        ], e), f = a.clampData(c), d = a.clampData(h), p = [];
        r[0] === "x0" ? p[0] = f[0] > d[0] ? h[0] : c[0] : p[0] = f[0] > d[0] ? c[0] : h[0], r[1] === "y0" ? p[1] = f[1] > d[1] ? h[1] : c[1] : p[1] = f[1] > d[1] ? c[1] : h[1], s = n.getMarkerPosition(p, r, true);
      } else {
        var v = t.get(r[0], e), g = t.get(r[1], e), m = [
          v,
          g
        ];
        a.clampData && a.clampData(m, m), s = a.dataToPoint(m, true);
      }
      if (lu(a, "cartesian2d")) {
        var y = a.getAxis("x"), _ = a.getAxis("y"), v = t.get(r[0], e), g = t.get(r[1], e);
        um(v) ? s[0] = y.toGlobalCoord(y.getExtent()[r[0] === "x0" ? 0 : 1]) : um(g) && (s[1] = _.toGlobalCoord(_.getExtent()[r[1] === "y0" ? 0 : 1]));
      }
      isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
    }
    return s;
  }
  var N$ = [
    [
      "x0",
      "y0"
    ],
    [
      "x1",
      "y0"
    ],
    [
      "x1",
      "y1"
    ],
    [
      "x0",
      "y1"
    ]
  ], hge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(a) {
        var o = yo.getMarkerModelFromSeries(a, "markArea");
        if (o) {
          var s = o.getData();
          s.each(function(l) {
            var u = oe(N$, function(h) {
              return O$(s, l, h, a, i);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, e.prototype.renderSeries = function(r, n, i, a) {
      var o = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new Be()
      });
      this.group.add(c.group), this.markKeep(c);
      var h = fge(o, r, n);
      n.setData(h), h.each(function(f) {
        var d = oe(N$, function(A) {
          return O$(h, f, A, r, a);
        }), p = o.getAxis("x").scale, v = o.getAxis("y").scale, g = p.getExtent(), m = v.getExtent(), y = [
          p.parse(h.get("x0", f)),
          p.parse(h.get("x1", f))
        ], _ = [
          v.parse(h.get("y0", f)),
          v.parse(h.get("y1", f))
        ];
        mi(y), mi(_);
        var b = !(g[0] > y[1] || g[1] < y[0] || m[0] > _[1] || m[1] < _[0]), w = !b;
        h.setItemLayout(f, {
          points: d,
          allClipped: w
        });
        var x = h.getItemModel(f).getModel("itemStyle").getItemStyle(), T = Bd(l, "color");
        x.fill || (x.fill = T, me(x.fill) && (x.fill = Cg(x.fill, 0.4))), x.stroke || (x.stroke = T), h.setItemVisual(f, "style", x);
      }), h.diff(fv(c).data).add(function(f) {
        var d = h.getItemLayout(f);
        if (!d.allClipped) {
          var p = new Sn({
            shape: {
              points: d.points
            }
          });
          h.setItemGraphicEl(f, p), c.group.add(p);
        }
      }).update(function(f, d) {
        var p = fv(c).data.getItemGraphicEl(d), v = h.getItemLayout(f);
        v.allClipped ? p && c.group.remove(p) : (p ? wt(p, {
          shape: {
            points: v.points
          }
        }, n, f) : p = new Sn({
          shape: {
            points: v.points
          }
        }), h.setItemGraphicEl(f, p), c.group.add(p));
      }).remove(function(f) {
        var d = fv(c).data.getItemGraphicEl(f);
        c.group.remove(d);
      }).execute(), h.eachItemGraphicEl(function(f, d) {
        var p = h.getItemModel(d), v = h.getItemVisual(d, "style");
        f.useStyle(h.getItemVisual(d, "style")), Xr(f, Lr(p), {
          labelFetcher: n,
          labelDataIndex: d,
          defaultText: h.getName(d) || "",
          inheritColor: me(v.fill) ? Cg(v.fill, 1) : "#000"
        }), qr(f, p), ir(f, null, null, p.get([
          "emphasis",
          "disabled"
        ])), Ge(f).dataModel = n;
      }), fv(c).data = h, c.group.silent = n.get("silent") || r.get("silent");
    }, e.type = "markArea", e;
  }(q2);
  function fge(t, e, r) {
    var n, i, a = [
      "x0",
      "y0",
      "x1",
      "y1"
    ];
    if (t) {
      var o = oe(t && t.dimensions, function(u) {
        var c = e.getData(), h = c.getDimensionInfo(c.mapDimension(u)) || {};
        return te(te({}, h), {
          name: u,
          ordinalMeta: null
        });
      });
      i = oe(a, function(u, c) {
        return {
          name: u,
          type: o[c % 2].type
        };
      }), n = new yn(i, r);
    } else i = [
      {
        name: "value",
        type: "float"
      }
    ], n = new yn(i, r);
    var s = oe(r.get("data"), Ye(uge, e, t, r));
    t && (s = Dt(s, Ye(cge, t)));
    var l = t ? function(u, c, h, f) {
      var d = u.coord[Math.floor(f / 2)][f % 2];
      return ss(d, i[f]);
    } : function(u, c, h, f) {
      return ss(u.value, i[f]);
    };
    return n.initData(s, null, l), n.hasItemOption = true, n;
  }
  function dge(t) {
    t.registerComponentModel(lge), t.registerComponentView(hge), t.registerPreprocessor(function(e) {
      U2(e.series, "markArea") && (e.markArea = e.markArea || {});
    });
  }
  var pge = function(t, e) {
    if (e === "all") return {
      type: "all",
      title: t.getLocaleModel().get([
        "legend",
        "selector",
        "all"
      ])
    };
    if (e === "inverse") return {
      type: "inverse",
      title: t.getLocaleModel().get([
        "legend",
        "selector",
        "inverse"
      ])
    };
  }, Ow = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.layoutMode = {
        type: "box",
        ignoreSize: true
      }, r;
    }
    return e.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i), r.selected = r.selected || {}, this._updateSelector(r);
    }, e.prototype.mergeOption = function(r, n) {
      t.prototype.mergeOption.call(this, r, n), this._updateSelector(r);
    }, e.prototype._updateSelector = function(r) {
      var n = r.selector, i = this.ecModel;
      n === true && (n = r.selector = [
        "all",
        "inverse"
      ]), ae(n) && $(n, function(a, o) {
        me(a) && (a = {
          type: a
        }), n[o] = je(a, pge(i, a.type));
      });
    }, e.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var r = this._data;
      if (r[0] && this.get("selectedMode") === "single") {
        for (var n = false, i = 0; i < r.length; i++) {
          var a = r[i].get("name");
          if (this.isSelected(a)) {
            this.select(a), n = true;
            break;
          }
        }
        !n && this.select(r[0].get("name"));
      }
    }, e.prototype._updateData = function(r) {
      var n = [], i = [];
      r.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var h = l.legendVisualProvider, f = h.getAllNames();
          r.isSeriesFiltered(l) || (i = i.concat(f)), f.length ? n = n.concat(f) : c = true;
        } else c = true;
        c && nT(l) && n.push(l.name);
      }), this._availableNames = i;
      var a = this.get("data") || n, o = Ce(), s = oe(a, function(l) {
        return (me(l) || xt(l)) && (l = {
          name: l
        }), o.get(l.name) ? null : (o.set(l.name, true), new kt(l, this, this.ecModel));
      }, this);
      this._data = Dt(s, function(l) {
        return !!l;
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.select = function(r) {
      var n = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var a = this._data;
        $(a, function(o) {
          n[o.get("name")] = false;
        });
      }
      n[r] = true;
    }, e.prototype.unSelect = function(r) {
      this.get("selectedMode") !== "single" && (this.option.selected[r] = false);
    }, e.prototype.toggleSelected = function(r) {
      var n = this.option.selected;
      n.hasOwnProperty(r) || (n[r] = true), this[n[r] ? "unSelect" : "select"](r);
    }, e.prototype.allSelect = function() {
      var r = this._data, n = this.option.selected;
      $(r, function(i) {
        n[i.get("name", true)] = true;
      });
    }, e.prototype.inverseSelect = function() {
      var r = this._data, n = this.option.selected;
      $(r, function(i) {
        var a = i.get("name", true);
        n.hasOwnProperty(a) || (n[a] = true), n[a] = !n[a];
      });
    }, e.prototype.isSelected = function(r) {
      var n = this.option.selected;
      return !(n.hasOwnProperty(r) && !n[r]) && et(this._availableNames, r) >= 0;
    }, e.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, e.type = "legend.plain", e.dependencies = [
      "series"
    ], e.defaultOption = {
      z: 4,
      show: true,
      orient: "horizontal",
      left: "center",
      top: 0,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: true,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: true,
      selector: false,
      selectorLabel: {
        show: true,
        borderRadius: 10,
        padding: [
          3,
          5,
          3,
          5
        ],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: true,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: false
      }
    }, e;
  }(vt), Ru = Ye, Nw = $, dv = Be, FH = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.newlineDisabled = false, r;
    }
    return e.prototype.init = function() {
      this.group.add(this._contentGroup = new dv()), this.group.add(this._selectorGroup = new dv()), this._isFirstRender = true;
    }, e.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, e.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, e.prototype.render = function(r, n, i) {
      var a = this._isFirstRender;
      if (this._isFirstRender = false, this.resetInner(), !!r.get("show", true)) {
        var o = r.get("align"), s = r.get("orient");
        (!o || o === "auto") && (o = r.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = r.get("selector", true), u = r.get("selectorPosition", true);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, r, n, i, l, s, u);
        var c = r.getBoxLayoutParams(), h = {
          width: i.getWidth(),
          height: i.getHeight()
        }, f = r.get("padding"), d = Tr(c, h, f), p = this.layoutInner(r, o, d, a, l, u), v = Tr(Ee({
          width: p.width,
          height: p.height
        }, c), h, f);
        this.group.x = v.x - p.x, this.group.y = v.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = MH(p, r));
      }
    }, e.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, e.prototype.renderInner = function(r, n, i, a, o, s, l) {
      var u = this.getContentGroup(), c = Ce(), h = n.get("selectedMode"), f = [];
      i.eachRawSeries(function(d) {
        !d.get("legendHoverLink") && f.push(d.id);
      }), Nw(n.getData(), function(d, p) {
        var v = d.get("name");
        if (!this.newlineDisabled && (v === "" || v === `
`)) {
          var g = new dv();
          g.newline = true, u.add(g);
          return;
        }
        var m = i.getSeriesByName(v)[0];
        if (!c.get(v)) if (m) {
          var y = m.getData(), _ = y.getVisual("legendLineStyle") || {}, b = y.getVisual("legendIcon"), w = y.getVisual("style"), x = this._createItem(m, v, p, d, n, r, _, w, b, h, a);
          x.on("click", Ru(B$, v, null, a, f)).on("mouseover", Ru(Bw, m.name, null, a, f)).on("mouseout", Ru(zw, m.name, null, a, f)), i.ssr && x.eachChild(function(T) {
            var A = Ge(T);
            A.seriesIndex = m.seriesIndex, A.dataIndex = p, A.ssrType = "legend";
          }), c.set(v, true);
        } else i.eachRawSeries(function(T) {
          if (!c.get(v) && T.legendVisualProvider) {
            var A = T.legendVisualProvider;
            if (!A.containName(v)) return;
            var I = A.indexOfName(v), M = A.getItemVisual(I, "style"), k = A.getItemVisual(I, "legendIcon"), B = Un(M.fill);
            B && B[3] === 0 && (B[3] = 0.2, M = te(te({}, M), {
              fill: ao(B, "rgba")
            }));
            var L = this._createItem(T, v, p, d, n, r, {}, M, k, h, a);
            L.on("click", Ru(B$, null, v, a, f)).on("mouseover", Ru(Bw, null, v, a, f)).on("mouseout", Ru(zw, null, v, a, f)), i.ssr && L.eachChild(function(z) {
              var F = Ge(z);
              F.seriesIndex = T.seriesIndex, F.dataIndex = p, F.ssrType = "legend";
            }), c.set(v, true);
          }
        }, this);
      }, this), o && this._createSelector(o, n, a, s, l);
    }, e.prototype._createSelector = function(r, n, i, a, o) {
      var s = this.getSelectorGroup();
      Nw(r, function(u) {
        var c = u.type, h = new bt({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect",
              legendId: n.id
            });
          }
        });
        s.add(h);
        var f = n.getModel("selectorLabel"), d = n.getModel([
          "emphasis",
          "selectorLabel"
        ]);
        Xr(h, {
          normal: f,
          emphasis: d
        }, {
          defaultText: u.title
        }), Nl(h);
      });
    }, e.prototype._createItem = function(r, n, i, a, o, s, l, u, c, h, f) {
      var d = r.visualDrawType, p = o.get("itemWidth"), v = o.get("itemHeight"), g = o.isSelected(n), m = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), _ = a.get("icon");
      c = _ || c || "roundRect";
      var b = vge(c, a, l, u, d, g, f), w = new dv(), x = a.getModel("textStyle");
      if (De(r.getLegendIcon) && (!_ || _ === "inherit")) w.add(r.getLegendIcon({
        itemWidth: p,
        itemHeight: v,
        icon: c,
        iconRotate: m,
        itemStyle: b.itemStyle,
        lineStyle: b.lineStyle,
        symbolKeepAspect: y
      }));
      else {
        var T = _ === "inherit" && r.getData().getVisual("symbol") ? m === "inherit" ? r.getData().getVisual("symbolRotate") : m : 0;
        w.add(gge({
          itemWidth: p,
          itemHeight: v,
          icon: c,
          iconRotate: T,
          itemStyle: b.itemStyle,
          symbolKeepAspect: y
        }));
      }
      var A = s === "left" ? p + 5 : -5, I = s, M = o.get("formatter"), k = n;
      me(M) && M ? k = M.replace("{name}", n ?? "") : De(M) && (k = M(n));
      var B = g ? x.getTextColor() : a.get("inactiveColor");
      w.add(new bt({
        style: Yt(x, {
          text: k,
          x: A,
          y: v / 2,
          fill: B,
          align: I,
          verticalAlign: "middle"
        }, {
          inheritColor: B
        })
      }));
      var L = new yt({
        shape: w.getBoundingRect(),
        style: {
          fill: "transparent"
        }
      }), z = a.getModel("tooltip");
      return z.get("show") && iu({
        el: L,
        componentModel: o,
        itemName: n,
        itemTooltipOption: z.option
      }), w.add(L), w.eachChild(function(F) {
        F.silent = true;
      }), L.silent = !h, this.getContentGroup().add(w), Nl(w), w.__legendDataIndex = i, w;
    }, e.prototype.layoutInner = function(r, n, i, a, o, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      zl(r.get("orient"), l, r.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), h = [
        -c.x,
        -c.y
      ];
      if (u.markRedraw(), l.markRedraw(), o) {
        zl("horizontal", u, r.get("selectorItemGap", true));
        var f = u.getBoundingRect(), d = [
          -f.x,
          -f.y
        ], p = r.get("selectorButtonGap", true), v = r.getOrient().index, g = v === 0 ? "width" : "height", m = v === 0 ? "height" : "width", y = v === 0 ? "y" : "x";
        s === "end" ? d[v] += c[g] + p : h[v] += f[g] + p, d[1 - v] += c[m] / 2 - f[m] / 2, u.x = d[0], u.y = d[1], l.x = h[0], l.y = h[1];
        var _ = {
          x: 0,
          y: 0
        };
        return _[g] = c[g] + p + f[g], _[m] = Math.max(c[m], f[m]), _[y] = Math.min(0, f[y] + d[1 - v]), _;
      } else return l.x = h[0], l.y = h[1], this.group.getBoundingRect();
    }, e.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = true;
    }, e.type = "legend.plain", e;
  }(tr);
  function vge(t, e, r, n, i, a, o) {
    function s(g, m) {
      g.lineWidth === "auto" && (g.lineWidth = m.lineWidth > 0 ? 2 : 0), Nw(g, function(y, _) {
        g[_] === "inherit" && (g[_] = m[_]);
      });
    }
    var l = e.getModel("itemStyle"), u = l.getItemStyle(), c = t.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", h = l.getShallow("decal");
    u.decal = !h || h === "inherit" ? n.decal : bc(h, o), u.fill === "inherit" && (u.fill = n[i]), u.stroke === "inherit" && (u.stroke = n[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? n : r).opacity), s(u, n);
    var f = e.getModel("lineStyle"), d = f.getLineStyle();
    if (s(d, r), u.fill === "auto" && (u.fill = n.fill), u.stroke === "auto" && (u.stroke = n.fill), d.stroke === "auto" && (d.stroke = n.fill), !a) {
      var p = e.get("inactiveBorderWidth"), v = u[c];
      u.lineWidth = p === "auto" ? n.lineWidth > 0 && v ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), d.stroke = f.get("inactiveColor"), d.lineWidth = f.get("inactiveWidth");
    }
    return {
      itemStyle: u,
      lineStyle: d
    };
  }
  function gge(t) {
    var e = t.icon || "roundRect", r = mr(e, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill, t.symbolKeepAspect);
    return r.setStyle(t.itemStyle), r.rotation = (t.iconRotate || 0) * Math.PI / 180, r.setOrigin([
      t.itemWidth / 2,
      t.itemHeight / 2
    ]), e.indexOf("empty") > -1 && (r.style.stroke = r.style.fill, r.style.fill = "#fff", r.style.lineWidth = 2), r;
  }
  function B$(t, e, r, n) {
    zw(t, e, r, n), r.dispatchAction({
      type: "legendToggleSelect",
      name: t ?? e
    }), Bw(t, e, r, n);
  }
  function VH(t) {
    for (var e = t.getZr().storage.getDisplayList(), r, n = 0, i = e.length; n < i && !(r = e[n].states.emphasis); ) n++;
    return r && r.hoverLayer;
  }
  function Bw(t, e, r, n) {
    VH(r) || r.dispatchAction({
      type: "highlight",
      seriesName: t,
      name: e,
      excludeSeriesId: n
    });
  }
  function zw(t, e, r, n) {
    VH(r) || r.dispatchAction({
      type: "downplay",
      seriesName: t,
      name: e,
      excludeSeriesId: n
    });
  }
  function mge(t) {
    var e = t.findComponents({
      mainType: "legend"
    });
    e && e.length && t.filterSeries(function(r) {
      for (var n = 0; n < e.length; n++) if (!e[n].isSelected(r.name)) return false;
      return true;
    });
  }
  function kh(t, e, r) {
    var n = t === "allSelect" || t === "inverseSelect", i = {}, a = [];
    r.eachComponent({
      mainType: "legend",
      query: e
    }, function(s) {
      n ? s[t]() : s[t](e.name), z$(s, i), a.push(s.componentIndex);
    });
    var o = {};
    return r.eachComponent("legend", function(s) {
      $(i, function(l, u) {
        s[l ? "select" : "unSelect"](u);
      }), z$(s, o);
    }), n ? {
      selected: o,
      legendIndex: a
    } : {
      name: e.name,
      selected: o
    };
  }
  function z$(t, e) {
    var r = e || {};
    return $(t.getData(), function(n) {
      var i = n.get("name");
      if (!(i === `
` || i === "")) {
        var a = t.isSelected(i);
        xe(r, i) ? r[i] = r[i] && a : r[i] = a;
      }
    }), r;
  }
  function yge(t) {
    t.registerAction("legendToggleSelect", "legendselectchanged", Ye(kh, "toggleSelected")), t.registerAction("legendAllSelect", "legendselectall", Ye(kh, "allSelect")), t.registerAction("legendInverseSelect", "legendinverseselect", Ye(kh, "inverseSelect")), t.registerAction("legendSelect", "legendselected", Ye(kh, "select")), t.registerAction("legendUnSelect", "legendunselected", Ye(kh, "unSelect"));
  }
  function GH(t) {
    t.registerComponentModel(Ow), t.registerComponentView(FH), t.registerProcessor(t.PRIORITY.PROCESSOR.SERIES_FILTER, mge), t.registerSubTypeDefaulter("legend", function() {
      return "plain";
    }), yge(t);
  }
  var _ge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.setScrollDataIndex = function(r) {
      this.option.scrollDataIndex = r;
    }, e.prototype.init = function(r, n, i) {
      var a = Yc(r);
      t.prototype.init.call(this, r, n, i), F$(this, r, a);
    }, e.prototype.mergeOption = function(r, n) {
      t.prototype.mergeOption.call(this, r, n), F$(this, this.option, r);
    }, e.type = "legend.scroll", e.defaultOption = xs(Ow.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: [
          "M0,0L12,-10L12,10z",
          "M0,0L-12,-10L-12,10z"
        ],
        vertical: [
          "M0,0L20,0L10,-20z",
          "M0,0L20,0L10,20z"
        ]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), e;
  }(Ow);
  function F$(t, e, r) {
    var n = t.getOrient(), i = [
      1,
      1
    ];
    i[n.index] = 0, ps(e, r, {
      type: "box",
      ignoreSize: !!i
    });
  }
  var V$ = Be, sb = [
    "width",
    "height"
  ], lb = [
    "x",
    "y"
  ], bge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.newlineDisabled = true, r._currentIndex = 0, r;
    }
    return e.prototype.init = function() {
      t.prototype.init.call(this), this.group.add(this._containerGroup = new V$()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new V$());
    }, e.prototype.resetInner = function() {
      t.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, e.prototype.renderInner = function(r, n, i, a, o, s, l) {
      var u = this;
      t.prototype.renderInner.call(this, r, n, i, a, o, s, l);
      var c = this._controllerGroup, h = n.get("pageIconSize", true), f = ae(h) ? h : [
        h,
        h
      ];
      p("pagePrev", 0);
      var d = n.getModel("pageTextStyle");
      c.add(new bt({
        name: "pageText",
        style: {
          text: "xx/xx",
          fill: d.getTextColor(),
          font: d.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: true
      })), p("pageNext", 1);
      function p(v, g) {
        var m = v + "DataIndex", y = Od(n.get("pageIcons", true)[n.getOrient().name][g], {
          onclick: _e(u._pageGo, u, m, n, a)
        }, {
          x: -f[0] / 2,
          y: -f[1] / 2,
          width: f[0],
          height: f[1]
        });
        y.name = v, c.add(y);
      }
    }, e.prototype.layoutInner = function(r, n, i, a, o, s) {
      var l = this.getSelectorGroup(), u = r.getOrient().index, c = sb[u], h = lb[u], f = sb[1 - u], d = lb[1 - u];
      o && zl("horizontal", l, r.get("selectorItemGap", true));
      var p = r.get("selectorButtonGap", true), v = l.getBoundingRect(), g = [
        -v.x,
        -v.y
      ], m = Oe(i);
      o && (m[c] = i[c] - v[c] - p);
      var y = this._layoutContentAndController(r, a, m, u, c, f, d, h);
      if (o) {
        if (s === "end") g[u] += y[c] + p;
        else {
          var _ = v[c] + p;
          g[u] -= _, y[h] -= _;
        }
        y[c] += v[c] + p, g[1 - u] += y[d] + y[f] / 2 - v[f] / 2, y[f] = Math.max(y[f], v[f]), y[d] = Math.min(y[d], v[d] + g[1 - u]), l.x = g[0], l.y = g[1], l.markRedraw();
      }
      return y;
    }, e.prototype._layoutContentAndController = function(r, n, i, a, o, s, l, u) {
      var c = this.getContentGroup(), h = this._containerGroup, f = this._controllerGroup;
      zl(r.get("orient"), c, r.get("itemGap"), a ? i.width : null, a ? null : i.height), zl("horizontal", f, r.get("pageButtonItemGap", true));
      var d = c.getBoundingRect(), p = f.getBoundingRect(), v = this._showController = d[o] > i[o], g = [
        -d.x,
        -d.y
      ];
      n || (g[a] = c[u]);
      var m = [
        0,
        0
      ], y = [
        -p.x,
        -p.y
      ], _ = We(r.get("pageButtonGap", true), r.get("itemGap", true));
      if (v) {
        var b = r.get("pageButtonPosition", true);
        b === "end" ? y[a] += i[o] - p[o] : m[a] += p[o] + _;
      }
      y[1 - a] += d[s] / 2 - p[s] / 2, c.setPosition(g), h.setPosition(m), f.setPosition(y);
      var w = {
        x: 0,
        y: 0
      };
      if (w[o] = v ? i[o] : d[o], w[s] = Math.max(d[s], p[s]), w[l] = Math.min(0, p[l] + y[1 - a]), h.__rectSize = i[o], v) {
        var x = {
          x: 0,
          y: 0
        };
        x[o] = Math.max(i[o] - p[o] - _, 0), x[s] = w[s], h.setClipPath(new yt({
          shape: x
        })), h.__rectSize = x[o];
      } else f.eachChild(function(A) {
        A.attr({
          invisible: true,
          silent: true
        });
      });
      var T = this._getPageInfo(r);
      return T.pageIndex != null && wt(c, {
        x: T.contentPosition[0],
        y: T.contentPosition[1]
      }, v ? r : null), this._updatePageInfoView(r, T), w;
    }, e.prototype._pageGo = function(r, n, i) {
      var a = this._getPageInfo(n)[r];
      a != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: n.id
      });
    }, e.prototype._updatePageInfoView = function(r, n) {
      var i = this._controllerGroup;
      $([
        "pagePrev",
        "pageNext"
      ], function(c) {
        var h = c + "DataIndex", f = n[h] != null, d = i.childOfName(c);
        d && (d.setStyle("fill", f ? r.get("pageIconColor", true) : r.get("pageIconInactiveColor", true)), d.cursor = f ? "pointer" : "default");
      });
      var a = i.childOfName("pageText"), o = r.get("pageFormatter"), s = n.pageIndex, l = s != null ? s + 1 : 0, u = n.pageCount;
      a && o && a.setStyle("text", me(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
        current: l,
        total: u
      }));
    }, e.prototype._getPageInfo = function(r) {
      var n = r.get("scrollDataIndex", true), i = this.getContentGroup(), a = this._containerGroup.__rectSize, o = r.getOrient().index, s = sb[o], l = lb[o], u = this._findTargetItemIndex(n), c = i.children(), h = c[u], f = c.length, d = f ? 1 : 0, p = {
        contentPosition: [
          i.x,
          i.y
        ],
        pageCount: d,
        pageIndex: d - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!h) return p;
      var v = b(h);
      p.contentPosition[o] = -v.s;
      for (var g = u + 1, m = v, y = v, _ = null; g <= f; ++g) _ = b(c[g]), (!_ && y.e > m.s + a || _ && !w(_, m.s)) && (y.i > m.i ? m = y : m = _, m && (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = _;
      for (var g = u - 1, m = v, y = v, _ = null; g >= -1; --g) _ = b(c[g]), (!_ || !w(y, _.s)) && m.i < y.i && (y = m, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = _;
      return p;
      function b(x) {
        if (x) {
          var T = x.getBoundingRect(), A = T[l] + x[l];
          return {
            s: A,
            e: A + T[s],
            i: x.__legendDataIndex
          };
        }
      }
      function w(x, T) {
        return x.e >= T && x.s <= T + a;
      }
    }, e.prototype._findTargetItemIndex = function(r) {
      if (!this._showController) return 0;
      var n, i = this.getContentGroup(), a;
      return i.eachChild(function(o, s) {
        var l = o.__legendDataIndex;
        a == null && l != null && (a = s), l === r && (n = s);
      }), n ?? a;
    }, e.type = "legend.scroll", e;
  }(FH);
  function xge(t) {
    t.registerAction("legendScroll", "legendscroll", function(e, r) {
      var n = e.scrollDataIndex;
      n != null && r.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: e
      }, function(i) {
        i.setScrollDataIndex(n);
      });
    });
  }
  function wge(t) {
    rt(GH), t.registerComponentModel(_ge), t.registerComponentView(bge), xge(t);
  }
  function Sge(t) {
    rt(GH), rt(wge);
  }
  var Tge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "dataZoom.inside", e.defaultOption = xs(fd.defaultOption, {
      disabled: false,
      zoomLock: false,
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: false,
      preventDefaultMouseMove: true
    }), e;
  }(fd), X2 = _t();
  function Cge(t, e, r) {
    X2(t).coordSysRecordMap.each(function(n) {
      var i = n.dataZoomInfoMap.get(e.uid);
      i && (i.getRange = r);
    });
  }
  function Age(t, e) {
    for (var r = X2(t).coordSysRecordMap, n = r.keys(), i = 0; i < n.length; i++) {
      var a = n[i], o = r.get(a), s = o.dataZoomInfoMap;
      if (s) {
        var l = e.uid, u = s.get(l);
        u && (s.removeKey(l), s.keys().length || WH(r, o));
      }
    }
  }
  function WH(t, e) {
    if (e) {
      t.removeKey(e.model.uid);
      var r = e.controller;
      r && r.dispose();
    }
  }
  function Ige(t, e) {
    var r = {
      model: e,
      containsPoint: Ye(Dge, e),
      dispatchAction: Ye(Mge, t),
      dataZoomInfoMap: null,
      controller: null
    }, n = r.controller = new qd(t.getZr());
    return $([
      "pan",
      "zoom",
      "scrollMove"
    ], function(i) {
      n.on(i, function(a) {
        var o = [];
        r.dataZoomInfoMap.each(function(s) {
          if (a.isAvailableBehavior(s.model.option)) {
            var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, r.model.mainType, r.controller, a);
            !s.model.get("disabled", true) && u && o.push({
              dataZoomId: s.model.id,
              start: u[0],
              end: u[1]
            });
          }
        }), o.length && r.dispatchAction(o);
      });
    }), r;
  }
  function Mge(t, e) {
    t.isDisposed() || t.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch: e
    });
  }
  function Dge(t, e, r, n) {
    return t.coordinateSystem.containPoint([
      r,
      n
    ]);
  }
  function Ege(t) {
    var e, r = "type_", n = {
      type_true: 2,
      type_move: 1,
      type_false: 0,
      type_undefined: -1
    }, i = true;
    return t.each(function(a) {
      var o = a.model, s = o.get("disabled", true) ? false : o.get("zoomLock", true) ? "move" : true;
      n[r + s] > n[r + e] && (e = s), i = i && o.get("preventDefaultMouseMove", true);
    }), {
      controlType: e,
      opt: {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: true,
        preventDefaultMouseMove: !!i
      }
    };
  }
  function kge(t) {
    t.registerProcessor(t.PRIORITY.PROCESSOR.FILTER, function(e, r) {
      var n = X2(r), i = n.coordSysRecordMap || (n.coordSysRecordMap = Ce());
      i.each(function(a) {
        a.dataZoomInfoMap = null;
      }), e.eachComponent({
        mainType: "dataZoom",
        subType: "inside"
      }, function(a) {
        var o = CH(a);
        $(o.infoList, function(s) {
          var l = s.model.uid, u = i.get(l) || i.set(l, Ige(r, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = Ce());
          c.set(a.uid, {
            dzReferCoordSysInfo: s,
            model: a,
            getRange: null
          });
        });
      }), i.each(function(a) {
        var o = a.controller, s, l = a.dataZoomInfoMap;
        if (l) {
          var u = l.keys()[0];
          u != null && (s = l.get(u));
        }
        if (!s) {
          WH(i, a);
          return;
        }
        var c = Ege(l);
        o.enable(c.controlType, c.opt), o.setPointerChecker(a.containsPoint), jc(a, "dispatchAction", s.model.get("throttle", true), "fixRate");
      });
    });
  }
  var Pge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = "dataZoom.inside", r;
    }
    return e.prototype.render = function(r, n, i) {
      if (t.prototype.render.apply(this, arguments), r.noTarget()) {
        this._clear();
        return;
      }
      this.range = r.getPercentRange(), Cge(i, r, {
        pan: _e(ub.pan, this),
        zoom: _e(ub.zoom, this),
        scrollMove: _e(ub.scrollMove, this)
      });
    }, e.prototype.dispose = function() {
      this._clear(), t.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      Age(this.api, this.dataZoomModel), this.range = null;
    }, e.type = "dataZoom.inside", e;
  }(z2), ub = {
    zoom: function(t, e, r, n) {
      var i = this.range, a = i.slice(), o = t.axisModels[0];
      if (o) {
        var s = cb[e](null, [
          n.originX,
          n.originY
        ], o, r, t), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / n.scale, 0);
        a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
        var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        if (cu(0, a, [
          0,
          100
        ], 0, c.minSpan, c.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1]) return a;
      }
    },
    pan: G$(function(t, e, r, n, i, a) {
      var o = cb[n]([
        a.oldX,
        a.oldY
      ], [
        a.newX,
        a.newY
      ], e, i, r);
      return o.signal * (t[1] - t[0]) * o.pixel / o.pixelLength;
    }),
    scrollMove: G$(function(t, e, r, n, i, a) {
      var o = cb[n]([
        0,
        0
      ], [
        a.scrollDelta,
        a.scrollDelta
      ], e, i, r);
      return o.signal * (t[1] - t[0]) * a.scrollDelta;
    })
  };
  function G$(t) {
    return function(e, r, n, i) {
      var a = this.range, o = a.slice(), s = e.axisModels[0];
      if (s) {
        var l = t(o, s, e, r, n, i);
        if (cu(l, o, [
          0,
          100
        ], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1]) return o;
      }
    };
  }
  var cb = {
    grid: function(t, e, r, n, i) {
      var a = r.axis, o = {}, s = i.model.coordinateSystem.getRect();
      return t = t || [
        0,
        0
      ], a.dim === "x" ? (o.pixel = e[0] - t[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - t[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
    },
    polar: function(t, e, r, n, i) {
      var a = r.axis, o = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
      return t = t ? s.pointToCoord(t) : [
        0,
        0
      ], e = s.pointToCoord(e), r.mainType === "radiusAxis" ? (o.pixel = e[0] - t[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - t[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
    },
    singleAxis: function(t, e, r, n, i) {
      var a = r.axis, o = i.model.coordinateSystem.getRect(), s = {};
      return t = t || [
        0,
        0
      ], a.orient === "horizontal" ? (s.pixel = e[0] - t[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - t[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
    }
  };
  function HH(t) {
    F2(t), t.registerComponentModel(Tge), t.registerComponentView(Pge), kge(t);
  }
  var Lge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = xs(fd.defaultOption, {
      show: true,
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: true,
      showDataShadow: "auto",
      realtime: true,
      zoomLock: false,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: true,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleLabel: {
          show: true
        },
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), e;
  }(fd), Ph = yt, W$ = 7, $ge = 1, hb = 30, Rge = 7, Lh = "horizontal", H$ = "vertical", Oge = 5, Nge = [
    "line",
    "bar",
    "candlestick",
    "scatter"
  ], Bge = {
    easing: "cubicOut",
    duration: 100,
    delay: 0
  }, zge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._displayables = {}, r;
    }
    return e.prototype.init = function(r, n) {
      this.api = n, this._onBrush = _e(this._onBrush, this), this._onBrushEnd = _e(this._onBrushEnd, this);
    }, e.prototype.render = function(r, n, i, a) {
      if (t.prototype.render.apply(this, arguments), jc(this, "_dispatchZoomAction", r.get("throttle"), "fixRate"), this._orient = r.getOrient(), r.get("show") === false) {
        this.group.removeAll();
        return;
      }
      if (r.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, e.prototype.dispose = function() {
      this._clear(), t.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      Jf(this, "_dispatchZoomAction");
      var r = this.api.getZr();
      r.off("mousemove", this._onBrush), r.off("mouseup", this._onBrushEnd);
    }, e.prototype._buildView = function() {
      var r = this.group;
      r.removeAll(), this._brushing = false, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var n = this._displayables.sliderGroup = new Be();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), r.add(n), this._positionGroup();
    }, e.prototype._resetLocation = function() {
      var r = this.dataZoomModel, n = this.api, i = r.get("brushSelect"), a = i ? Rge : 0, o = this._findCoordRect(), s = {
        width: n.getWidth(),
        height: n.getHeight()
      }, l = this._orient === Lh ? {
        right: s.width - o.x - o.width,
        top: s.height - hb - W$ - a,
        width: o.width,
        height: hb
      } : {
        right: W$,
        top: o.y,
        width: hb,
        height: o.height
      }, u = Yc(r.option);
      $([
        "right",
        "top",
        "width",
        "height"
      ], function(h) {
        u[h] === "ph" && (u[h] = l[h]);
      });
      var c = Tr(u, s);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [
        c.width,
        c.height
      ], this._orient === H$ && this._size.reverse();
    }, e.prototype._positionGroup = function() {
      var r = this.group, n = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === Lh && !o ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === Lh && o ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === H$ && !o ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = r.getBoundingRect([
        s
      ]);
      r.x = n.x - u.x, r.y = n.y - u.y, r.markRedraw();
    }, e.prototype._getViewExtent = function() {
      return [
        0,
        this._size[0]
      ];
    }, e.prototype._renderBackground = function() {
      var r = this.dataZoomModel, n = this._size, i = this._displayables.sliderGroup, a = r.get("brushSelect");
      i.add(new Ph({
        silent: true,
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: r.get("backgroundColor")
        },
        z2: -40
      }));
      var o = new Ph({
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: _e(this._onClickPanel, this)
      }), s = this.api.getZr();
      a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(o);
    }, e.prototype._renderDataShadow = function() {
      var r = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !r) return;
      var n = this._size, i = this._shadowSize || [], a = r.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : r.otherDim;
      if (l == null) return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (o !== this._shadowData || l !== this._shadowDim || n[0] !== i[0] || n[1] !== i[1]) {
        var h = o.getDataExtent(l), f = (h[1] - h[0]) * 0.3;
        h = [
          h[0] - f,
          h[1] + f
        ];
        var d = [
          0,
          n[1]
        ], p = [
          0,
          n[0]
        ], v = [
          [
            n[0],
            0
          ],
          [
            0,
            0
          ]
        ], g = [], m = p[1] / (o.count() - 1), y = 0, _ = Math.round(o.count() / n[0]), b;
        o.each([
          l
        ], function(I, M) {
          if (_ > 0 && M % _) {
            y += m;
            return;
          }
          var k = I == null || isNaN(I) || I === "", B = k ? 0 : Et(I, h, d, true);
          k && !b && M ? (v.push([
            v[v.length - 1][0],
            0
          ]), g.push([
            g[g.length - 1][0],
            0
          ])) : !k && b && (v.push([
            y,
            0
          ]), g.push([
            y,
            0
          ])), v.push([
            y,
            B
          ]), g.push([
            y,
            B
          ]), y += m, b = k;
        }), u = this._shadowPolygonPts = v, c = this._shadowPolylinePts = g;
      }
      this._shadowData = o, this._shadowDim = l, this._shadowSize = [
        n[0],
        n[1]
      ];
      var w = this.dataZoomModel;
      function x(I) {
        var M = w.getModel(I ? "selectedDataBackground" : "dataBackground"), k = new Be(), B = new Sn({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: M.getModel("areaStyle").getAreaStyle(),
          silent: true,
          z2: -20
        }), L = new Tn({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: M.getModel("lineStyle").getLineStyle(),
          silent: true,
          z2: -19
        });
        return k.add(B), k.add(L), k;
      }
      for (var T = 0; T < 3; T++) {
        var A = x(T === 1);
        this._displayables.sliderGroup.add(A), this._displayables.dataShadowSegs.push(A);
      }
    }, e.prototype._prepareDataShadowInfo = function() {
      var r = this.dataZoomModel, n = r.get("showDataShadow");
      if (n !== false) {
        var i, a = this.ecModel;
        return r.eachTargetAxis(function(o, s) {
          var l = r.getAxisProxy(o, s).getTargetSeriesModels();
          $(l, function(u) {
            if (!i && !(n !== true && et(Nge, u.get("type")) < 0)) {
              var c = a.getComponent(ns(o), s).axis, h = Fge(o), f, d = u.coordinateSystem;
              h != null && d.getOtherAxis && (f = d.getOtherAxis(c).inverse), h = u.getData().mapDimension(h), i = {
                thisAxis: c,
                series: u,
                thisDim: o,
                otherDim: h,
                otherAxisInverse: f
              };
            }
          }, this);
        }, this), i;
      }
    }, e.prototype._renderHandle = function() {
      var r = this.group, n = this._displayables, i = n.handles = [
        null,
        null
      ], a = n.handleLabels = [
        null,
        null
      ], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, h = l.get("brushSelect"), f = n.filler = new Ph({
        silent: h,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      o.add(f), o.add(new Ph({
        silent: true,
        subPixelOptimize: true,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: $ge,
          fill: "rgba(0,0,0,0)"
        }
      })), $([
        0,
        1
      ], function(_) {
        var b = l.get("handleIcon");
        !Fg[b] && b.indexOf("path://") < 0 && b.indexOf("image://") < 0 && (b = "path://" + b);
        var w = mr(b, -1, 0, 2, 2, null, true);
        w.attr({
          cursor: U$(this._orient),
          draggable: true,
          drift: _e(this._onDragMove, this, _),
          ondragend: _e(this._onDragEnd, this),
          onmouseover: _e(this._showDataInfo, this, true),
          onmouseout: _e(this._showDataInfo, this, false),
          z2: 5
        });
        var x = w.getBoundingRect(), T = l.get("handleSize");
        this._handleHeight = pe(T, this._size[1]), this._handleWidth = x.width / x.height * this._handleHeight, w.setStyle(l.getModel("handleStyle").getItemStyle()), w.style.strokeNoScale = true, w.rectHover = true, w.ensureState("emphasis").style = l.getModel([
          "emphasis",
          "handleStyle"
        ]).getItemStyle(), Nl(w);
        var A = l.get("handleColor");
        A != null && (w.style.fill = A), o.add(i[_] = w);
        var I = l.getModel("textStyle"), M = l.get("handleLabel") || {}, k = M.show || false;
        r.add(a[_] = new bt({
          silent: true,
          invisible: !k,
          style: Yt(I, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: I.getTextColor(),
            font: I.getFont()
          }),
          z2: 10
        }));
      }, this);
      var d = f;
      if (h) {
        var p = pe(l.get("moveHandleSize"), s[1]), v = n.moveHandle = new yt({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: true,
          shape: {
            r: [
              0,
              0,
              2,
              2
            ],
            y: s[1] - 0.5,
            height: p
          }
        }), g = p * 0.8, m = n.moveHandleIcon = mr(l.get("moveHandleIcon"), -g / 2, -g / 2, g, g, "#fff", true);
        m.silent = true, m.y = s[1] + p / 2 - 0.5, v.ensureState("emphasis").style = l.getModel([
          "emphasis",
          "moveHandleStyle"
        ]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(p, 10));
        d = n.moveZone = new yt({
          invisible: true,
          shape: {
            y: s[1] - y,
            height: p + y
          }
        }), d.on("mouseover", function() {
          u.enterEmphasis(v);
        }).on("mouseout", function() {
          u.leaveEmphasis(v);
        }), o.add(v), o.add(m), o.add(d);
      }
      d.attr({
        draggable: true,
        cursor: U$(this._orient),
        drift: _e(this._onDragMove, this, "all"),
        ondragstart: _e(this._showDataInfo, this, true),
        ondragend: _e(this._onDragEnd, this),
        onmouseover: _e(this._showDataInfo, this, true),
        onmouseout: _e(this._showDataInfo, this, false)
      });
    }, e.prototype._resetInterval = function() {
      var r = this._range = this.dataZoomModel.getPercentRange(), n = this._getViewExtent();
      this._handleEnds = [
        Et(r[0], [
          0,
          100
        ], n, true),
        Et(r[1], [
          0,
          100
        ], n, true)
      ];
    }, e.prototype._updateInterval = function(r, n) {
      var i = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [
        0,
        100
      ];
      cu(n, a, o, i.get("zoomLock") ? "all" : r, s.minSpan != null ? Et(s.minSpan, l, o, true) : null, s.maxSpan != null ? Et(s.maxSpan, l, o, true) : null);
      var u = this._range, c = this._range = mi([
        Et(a[0], o, l, true),
        Et(a[1], o, l, true)
      ]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, e.prototype._updateView = function(r) {
      var n = this._displayables, i = this._handleEnds, a = mi(i.slice()), o = this._size;
      $([
        0,
        1
      ], function(d) {
        var p = n.handles[d], v = this._handleHeight;
        p.attr({
          scaleX: v / 2,
          scaleY: v / 2,
          x: i[d] + (d ? -1 : 1),
          y: o[1] / 2 - v / 2
        });
      }, this), n.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: o[1]
      });
      var s = {
        x: a[0],
        width: a[1] - a[0]
      };
      n.moveHandle && (n.moveHandle.setShape(s), n.moveZone.setShape(s), n.moveZone.getBoundingRect(), n.moveHandleIcon && n.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = n.dataShadowSegs, u = [
        0,
        a[0],
        a[1],
        o[0]
      ], c = 0; c < l.length; c++) {
        var h = l[c], f = h.getClipPath();
        f || (f = new yt(), h.setClipPath(f)), f.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: o[1]
        });
      }
      this._updateDataInfo(r);
    }, e.prototype._updateDataInfo = function(r) {
      var n = this.dataZoomModel, i = this._displayables, a = i.handleLabels, o = this._orient, s = [
        "",
        ""
      ];
      if (n.get("showDetail")) {
        var l = n.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, h = r ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [
            this._formatLabel(h[0], u),
            this._formatLabel(h[1], u)
          ];
        }
      }
      var f = mi(this._handleEnds.slice());
      d.call(this, 0), d.call(this, 1);
      function d(p) {
        var v = Bl(i.handles[p].parent, this.group), g = Km(p === 0 ? "right" : "left", v), m = this._handleWidth / 2 + Oge, y = Yi([
          f[p] + (p === 0 ? -m : m),
          this._size[1] / 2
        ], v);
        a[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: o === Lh ? "middle" : g,
          align: o === Lh ? g : "center",
          text: s[p]
        });
      }
    }, e.prototype._formatLabel = function(r, n) {
      var i = this.dataZoomModel, a = i.get("labelFormatter"), o = i.get("labelPrecision");
      (o == null || o === "auto") && (o = n.getPixelPrecision());
      var s = r == null || isNaN(r) ? "" : n.type === "category" || n.type === "time" ? n.scale.getLabel({
        value: Math.round(r)
      }) : r.toFixed(Math.min(o, 20));
      return De(a) ? a(r, s) : me(a) ? a.replace("{value}", s) : s;
    }, e.prototype._showDataInfo = function(r) {
      var n = this.dataZoomModel.get("handleLabel") || {}, i = n.show || false, a = this.dataZoomModel.getModel([
        "emphasis",
        "handleLabel"
      ]), o = a.get("show") || false, s = r || this._dragging ? o : i, l = this._displayables, u = l.handleLabels;
      u[0].attr("invisible", !s), u[1].attr("invisible", !s), l.moveHandle && this.api[s ? "enterEmphasis" : "leaveEmphasis"](l.moveHandle, 1);
    }, e.prototype._onDragMove = function(r, n, i, a) {
      this._dragging = true, co(a.event);
      var o = this._displayables.sliderGroup.getLocalTransform(), s = Yi([
        n,
        i
      ], o, true), l = this._updateInterval(r, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(true);
    }, e.prototype._onDragEnd = function() {
      this._dragging = false, this._showDataInfo(false);
      var r = this.dataZoomModel.get("realtime");
      !r && this._dispatchZoomAction(false);
    }, e.prototype._onClickPanel = function(r) {
      var n = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(r.offsetX, r.offsetY);
      if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
        var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", i[0] - o);
        this._updateView(), s && this._dispatchZoomAction(false);
      }
    }, e.prototype._onBrushStart = function(r) {
      var n = r.offsetX, i = r.offsetY;
      this._brushStart = new Ke(n, i), this._brushing = true, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, e.prototype._onBrushEnd = function(r) {
      if (this._brushing) {
        var n = this._displayables.brushRect;
        if (this._brushing = false, !!n) {
          n.attr("ignore", true);
          var i = n.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var o = this._getViewExtent(), s = [
              0,
              100
            ];
            this._range = mi([
              Et(i.x, o, s, true),
              Et(i.x + i.width, o, s, true)
            ]), this._handleEnds = [
              i.x,
              i.x + i.width
            ], this._updateView(), this._dispatchZoomAction(false);
          }
        }
      }
    }, e.prototype._onBrush = function(r) {
      this._brushing && (co(r.event), this._updateBrushRect(r.offsetX, r.offsetY));
    }, e.prototype._updateBrushRect = function(r, n) {
      var i = this._displayables, a = this.dataZoomModel, o = i.brushRect;
      o || (o = i.brushRect = new Ph({
        silent: true,
        style: a.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(o)), o.attr("ignore", false);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(r, n), c = l.transformCoordToLocal(s.x, s.y), h = this._size;
      u[0] = Math.max(Math.min(h[0], u[0]), 0), o.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: h[1]
      });
    }, e.prototype._dispatchZoomAction = function(r) {
      var n = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: r ? Bge : null,
        start: n[0],
        end: n[1]
      });
    }, e.prototype._findCoordRect = function() {
      var r, n = CH(this.dataZoomModel).infoList;
      if (!r && n.length) {
        var i = n[0].model.coordinateSystem;
        r = i.getRect && i.getRect();
      }
      if (!r) {
        var a = this.api.getWidth(), o = this.api.getHeight();
        r = {
          x: a * 0.2,
          y: o * 0.2,
          width: a * 0.6,
          height: o * 0.6
        };
      }
      return r;
    }, e.type = "dataZoom.slider", e;
  }(z2);
  function Fge(t) {
    var e = {
      x: "y",
      y: "x",
      radius: "angle",
      angle: "radius"
    };
    return e[t];
  }
  function U$(t) {
    return t === "vertical" ? "ns-resize" : "ew-resize";
  }
  function UH(t) {
    t.registerComponentModel(Lge), t.registerComponentView(zge), F2(t);
  }
  function Vge(t) {
    rt(HH), rt(UH);
  }
  var YH = {
    get: function(t, e, r) {
      var n = Oe((Gge[t] || {})[e]);
      return r && ae(n) ? n[n.length - 1] : n;
    }
  }, Gge = {
    color: {
      active: [
        "#006edd",
        "#e0ffff"
      ],
      inactive: [
        "rgba(0,0,0,0)"
      ]
    },
    colorHue: {
      active: [
        0,
        360
      ],
      inactive: [
        0,
        0
      ]
    },
    colorSaturation: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    colorLightness: {
      active: [
        0.9,
        0.5
      ],
      inactive: [
        0,
        0
      ]
    },
    colorAlpha: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    opacity: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    symbol: {
      active: [
        "circle",
        "roundRect",
        "diamond"
      ],
      inactive: [
        "none"
      ]
    },
    symbolSize: {
      active: [
        10,
        50
      ],
      inactive: [
        0,
        0
      ]
    }
  }, Y$ = Er.mapVisual, Wge = Er.eachVisual, Hge = ae, q$ = $, Uge = mi, Yge = Et, cm = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.stateList = [
        "inRange",
        "outOfRange"
      ], r.replacableOptionKeys = [
        "inRange",
        "outOfRange",
        "target",
        "controller",
        "color"
      ], r.layoutMode = {
        type: "box",
        ignoreSize: true
      }, r.dataBound = [
        -1 / 0,
        1 / 0
      ], r.targetVisuals = {}, r.controllerVisuals = {}, r;
    }
    return e.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i);
    }, e.prototype.optionUpdated = function(r, n) {
      var i = this.option;
      !n && RH(i, r, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, e.prototype.resetVisual = function(r) {
      var n = this.stateList;
      r = _e(r, this), this.controllerVisuals = Lw(this.option.controller, n, r), this.targetVisuals = Lw(this.option.target, n, r);
    }, e.prototype.getItemSymbol = function() {
      return null;
    }, e.prototype.getTargetSeriesIndices = function() {
      var r = this.option.seriesIndex, n = [];
      return r == null || r === "all" ? this.ecModel.eachSeries(function(i, a) {
        n.push(a);
      }) : n = Ot(r), n;
    }, e.prototype.eachTargetSeries = function(r, n) {
      $(this.getTargetSeriesIndices(), function(i) {
        var a = this.ecModel.getSeriesByIndex(i);
        a && r.call(n, a);
      }, this);
    }, e.prototype.isTargetSeries = function(r) {
      var n = false;
      return this.eachTargetSeries(function(i) {
        i === r && (n = true);
      }), n;
    }, e.prototype.formatValueText = function(r, n, i) {
      var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
      i = i || [
        "<",
        ">"
      ], ae(r) && (r = r.slice(), u = true);
      var c = n ? r : u ? [
        h(r[0]),
        h(r[1])
      ] : h(r);
      if (me(l)) return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (De(l)) return u ? l(r[0], r[1]) : l(r);
      if (u) return r[0] === s[0] ? i[0] + " " + c[1] : r[1] === s[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function h(f) {
        return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(o, 20));
      }
    }, e.prototype.resetExtent = function() {
      var r = this.option, n = Uge([
        r.min,
        r.max
      ]);
      this._dataExtent = n;
    }, e.prototype.getDataDimensionIndex = function(r) {
      var n = this.option.dimension;
      if (n != null) return r.getDimensionIndex(n);
      for (var i = r.dimensions, a = i.length - 1; a >= 0; a--) {
        var o = i[a], s = r.getDimensionInfo(o);
        if (!s.isCalculationCoord) return s.storeDimIndex;
      }
    }, e.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, e.prototype.completeVisualOption = function() {
      var r = this.ecModel, n = this.option, i = {
        inRange: n.inRange,
        outOfRange: n.outOfRange
      }, a = n.target || (n.target = {}), o = n.controller || (n.controller = {});
      je(a, i), je(o, i);
      var s = this.isCategory();
      l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), c.call(this, o);
      function l(h) {
        Hge(n.color) && !h.inRange && (h.inRange = {
          color: n.color.slice().reverse()
        }), h.inRange = h.inRange || {
          color: r.get("gradientColor")
        };
      }
      function u(h, f, d) {
        var p = h[f], v = h[d];
        p && !v && (v = h[d] = {}, q$(p, function(g, m) {
          if (Er.isValidType(m)) {
            var y = YH.get(m, "inactive", s);
            y != null && (v[m] = y, m === "color" && !v.hasOwnProperty("opacity") && !v.hasOwnProperty("colorAlpha") && (v.opacity = [
              0,
              0
            ]));
          }
        }));
      }
      function c(h) {
        var f = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol, d = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), v = this.getItemSymbol(), g = v || "roundRect";
        q$(this.stateList, function(m) {
          var y = this.itemSize, _ = h[m];
          _ || (_ = h[m] = {
            color: s ? p : [
              p
            ]
          }), _.symbol == null && (_.symbol = f && Oe(f) || (s ? g : [
            g
          ])), _.symbolSize == null && (_.symbolSize = d && Oe(d) || (s ? y[0] : [
            y[0],
            y[0]
          ])), _.symbol = Y$(_.symbol, function(x) {
            return x === "none" ? g : x;
          });
          var b = _.symbolSize;
          if (b != null) {
            var w = -1 / 0;
            Wge(b, function(x) {
              x > w && (w = x);
            }), _.symbolSize = Y$(b, function(x) {
              return Yge(x, [
                0,
                w
              ], [
                0,
                y[0]
              ], true);
            });
          }
        }, this);
      }
    }, e.prototype.resetItemSize = function() {
      this.itemSize = [
        parseFloat(this.get("itemWidth")),
        parseFloat(this.get("itemHeight"))
      ];
    }, e.prototype.isCategory = function() {
      return !!this.option.categories;
    }, e.prototype.setSelected = function(r) {
    }, e.prototype.getSelected = function() {
      return null;
    }, e.prototype.getValueState = function(r) {
      return null;
    }, e.prototype.getVisualMeta = function(r) {
      return null;
    }, e.type = "visualMap", e.dependencies = [
      "series"
    ], e.defaultOption = {
      show: true,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: false,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
      }
    }, e;
  }(vt), X$ = [
    20,
    140
  ], qge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.optionUpdated = function(r, n) {
      t.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, e.prototype.resetItemSize = function() {
      t.prototype.resetItemSize.apply(this, arguments);
      var r = this.itemSize;
      (r[0] == null || isNaN(r[0])) && (r[0] = X$[0]), (r[1] == null || isNaN(r[1])) && (r[1] = X$[1]);
    }, e.prototype._resetRange = function() {
      var r = this.getExtent(), n = this.option.range;
      !n || n.auto ? (r.auto = 1, this.option.range = r) : ae(n) && (n[0] > n[1] && n.reverse(), n[0] = Math.max(n[0], r[0]), n[1] = Math.min(n[1], r[1]));
    }, e.prototype.completeVisualOption = function() {
      t.prototype.completeVisualOption.apply(this, arguments), $(this.stateList, function(r) {
        var n = this.option.controller[r].symbolSize;
        n && n[0] !== n[1] && (n[0] = n[1] / 3);
      }, this);
    }, e.prototype.setSelected = function(r) {
      this.option.range = r.slice(), this._resetRange();
    }, e.prototype.getSelected = function() {
      var r = this.getExtent(), n = mi((this.get("range") || []).slice());
      return n[0] > r[1] && (n[0] = r[1]), n[1] > r[1] && (n[1] = r[1]), n[0] < r[0] && (n[0] = r[0]), n[1] < r[0] && (n[1] = r[0]), n;
    }, e.prototype.getValueState = function(r) {
      var n = this.option.range, i = this.getExtent();
      return (n[0] <= i[0] || n[0] <= r) && (n[1] >= i[1] || r <= n[1]) ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(r) {
      var n = [];
      return this.eachTargetSeries(function(i) {
        var a = [], o = i.getData();
        o.each(this.getDataDimensionIndex(o), function(s, l) {
          r[0] <= s && s <= r[1] && a.push(l);
        }, this), n.push({
          seriesId: i.id,
          dataIndex: a
        });
      }, this), n;
    }, e.prototype.getVisualMeta = function(r) {
      var n = j$(this, "outOfRange", this.getExtent()), i = j$(this, "inRange", this.option.range.slice()), a = [];
      function o(d, p) {
        a.push({
          value: d,
          color: r(d, p)
        });
      }
      for (var s = 0, l = 0, u = i.length, c = n.length; l < c && (!i.length || n[l] <= i[0]); l++) n[l] < i[s] && o(n[l], "outOfRange");
      for (var h = 1; s < u; s++, h = 0) h && a.length && o(i[s], "outOfRange"), o(i[s], "inRange");
      for (var h = 1; l < c; l++) (!i.length || i[i.length - 1] < n[l]) && (h && (a.length && o(a[a.length - 1].value, "outOfRange"), h = 0), o(n[l], "outOfRange"));
      var f = a.length;
      return {
        stops: a,
        outerColors: [
          f ? a[0].color : "transparent",
          f ? a[f - 1].color : "transparent"
        ]
      };
    }, e.type = "visualMap.continuous", e.defaultOption = xs(cm.defaultOption, {
      align: "auto",
      calculable: false,
      hoverLink: true,
      realtime: true,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
    }), e;
  }(cm);
  function j$(t, e, r) {
    if (r[0] === r[1]) return r.slice();
    for (var n = 200, i = (r[1] - r[0]) / n, a = r[0], o = [], s = 0; s <= n && a < r[1]; s++) o.push(a), a += i;
    return o.push(r[1]), o;
  }
  var qH = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, r;
    }
    return e.prototype.init = function(r, n) {
      this.ecModel = r, this.api = n;
    }, e.prototype.render = function(r, n, i, a) {
      if (this.visualMapModel = r, r.get("show") === false) {
        this.group.removeAll();
        return;
      }
      this.doRender(r, n, i, a);
    }, e.prototype.renderBackground = function(r) {
      var n = this.visualMapModel, i = Uc(n.get("padding") || 0), a = r.getBoundingRect();
      r.add(new yt({
        z2: -1,
        silent: true,
        shape: {
          x: a.x - i[3],
          y: a.y - i[0],
          width: a.width + i[3] + i[1],
          height: a.height + i[0] + i[2]
        },
        style: {
          fill: n.get("backgroundColor"),
          stroke: n.get("borderColor"),
          lineWidth: n.get("borderWidth")
        }
      }));
    }, e.prototype.getControllerVisual = function(r, n, i) {
      i = i || {};
      var a = i.forceState, o = this.visualMapModel, s = {};
      if (n === "color") {
        var l = o.get("contentColor");
        s.color = l;
      }
      function u(d) {
        return s[d];
      }
      function c(d, p) {
        s[d] = p;
      }
      var h = o.controllerVisuals[a || o.getValueState(r)], f = Er.prepareVisualTypes(h);
      return $(f, function(d) {
        var p = h[d];
        i.convertOpacityToAlpha && d === "opacity" && (d = "colorAlpha", p = h.__alphaForOpacity), Er.dependsOn(d, n) && p && p.applyVisual(r, u, c);
      }), s[n];
    }, e.prototype.positionGroup = function(r) {
      var n = this.visualMapModel, i = this.api;
      ny(r, n.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, e.prototype.doRender = function(r, n, i, a) {
    }, e.type = "visualMap", e;
  }(tr), K$ = [
    [
      "left",
      "right",
      "width"
    ],
    [
      "top",
      "bottom",
      "height"
    ]
  ];
  function XH(t, e, r) {
    var n = t.option, i = n.align;
    if (i != null && i !== "auto") return i;
    for (var a = {
      width: e.getWidth(),
      height: e.getHeight()
    }, o = n.orient === "horizontal" ? 1 : 0, s = K$[o], l = [
      0,
      null,
      10
    ], u = {}, c = 0; c < 3; c++) u[K$[1 - o][c]] = l[c], u[s[c]] = c === 2 ? r[0] : n[s[c]];
    var h = [
      [
        "x",
        "width",
        3
      ],
      [
        "y",
        "height",
        0
      ]
    ][o], f = Tr(u, a, n.padding);
    return s[(f.margin[h[2]] || 0) + f[h[0]] + f[h[1]] * 0.5 < a[h[1]] * 0.5 ? 0 : 1];
  }
  function vg(t, e) {
    return $(t || [], function(r) {
      r.dataIndex != null && (r.dataIndexInside = r.dataIndex, r.dataIndex = null), r.highlightKey = "visualMap" + (e ? e.componentIndex : "");
    }), t;
  }
  var pa = Et, Xge = $, Z$ = Math.min, fb = Math.max, jge = 12, Kge = 6, Zge = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._shapes = {}, r._dataInterval = [], r._handleEnds = [], r._hoverLinkDataIndices = [], r;
    }
    return e.prototype.init = function(r, n) {
      t.prototype.init.call(this, r, n), this._hoverLinkFromSeriesMouseOver = _e(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = _e(this._hideIndicator, this);
    }, e.prototype.doRender = function(r, n, i, a) {
      (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, e.prototype._buildView = function() {
      this.group.removeAll();
      var r = this.visualMapModel, n = this.group;
      this._orient = r.get("orient"), this._useHandle = r.get("calculable"), this._resetInterval(), this._renderBar(n);
      var i = r.get("text");
      this._renderEndsText(n, i, 0), this._renderEndsText(n, i, 1), this._updateView(true), this.renderBackground(n), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(n);
    }, e.prototype._renderEndsText = function(r, n, i) {
      if (n) {
        var a = n[1 - i];
        a = a != null ? a + "" : "";
        var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([
          l[0] / 2,
          i === 0 ? -s : l[1] + s
        ], u), h = this._applyTransform(i === 0 ? "bottom" : "top", u), f = this._orient, d = this.visualMapModel.textStyleModel;
        this.group.add(new bt({
          style: Yt(d, {
            x: c[0],
            y: c[1],
            verticalAlign: f === "horizontal" ? "middle" : h,
            align: f === "horizontal" ? h : "center",
            text: a
          })
        }));
      }
    }, e.prototype._renderBar = function(r) {
      var n = this.visualMapModel, i = this._shapes, a = n.itemSize, o = this._orient, s = this._useHandle, l = XH(n, this.api, a), u = i.mainGroup = this._createBarGroup(l), c = new Be();
      u.add(c), c.add(i.outOfRange = Q$()), c.add(i.inRange = Q$(null, s ? eR(this._orient) : null, _e(this._dragHandle, this, "all", false), _e(this._dragHandle, this, "all", true))), c.setClipPath(new yt({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var h = n.textStyleModel.getTextRect("\u56FD"), f = fb(h.width, h.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(n, u, 0, a, f, o), this._createHandle(n, u, 1, a, f, o)), this._createIndicator(n, u, a, f, o), r.add(u);
    }, e.prototype._createHandle = function(r, n, i, a, o, s) {
      var l = _e(this._dragHandle, this, i, false), u = _e(this._dragHandle, this, i, true), c = ji(r.get("handleSize"), a[0]), h = mr(r.get("handleIcon"), -c / 2, -c / 2, c, c, null, true), f = eR(this._orient);
      h.attr({
        cursor: f,
        draggable: true,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          co(m.event);
        }
      }), h.x = a[0] / 2, h.useStyle(r.getModel("handleStyle").getItemStyle()), h.setStyle({
        strokeNoScale: true,
        strokeFirst: true
      }), h.style.lineWidth *= 2, h.ensureState("emphasis").style = r.getModel([
        "emphasis",
        "handleStyle"
      ]).getItemStyle(), Tl(h, true), n.add(h);
      var d = this.visualMapModel.textStyleModel, p = new bt({
        cursor: f,
        draggable: true,
        drift: l,
        onmousemove: function(m) {
          co(m.event);
        },
        ondragend: u,
        style: Yt(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var v = [
        c,
        0
      ], g = this._shapes;
      g.handleThumbs[i] = h, g.handleLabelPoints[i] = v, g.handleLabels[i] = p;
    }, e.prototype._createIndicator = function(r, n, i, a, o) {
      var s = ji(r.get("indicatorSize"), i[0]), l = mr(r.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, true);
      l.attr({
        cursor: "move",
        invisible: true,
        silent: true,
        x: i[0] / 2
      });
      var u = r.getModel("indicatorStyle").getItemStyle();
      if (l instanceof Gr) {
        var c = l.style;
        l.useStyle(te({
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else l.useStyle(u);
      n.add(l);
      var h = this.visualMapModel.textStyleModel, f = new bt({
        silent: true,
        invisible: true,
        style: Yt(h, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(f);
      var d = [
        (o === "horizontal" ? a / 2 : Kge) + i[0] / 2,
        0
      ], p = this._shapes;
      p.indicator = l, p.indicatorLabel = f, p.indicatorLabelPoint = d, this._firstShowIndicator = true;
    }, e.prototype._dragHandle = function(r, n, i, a) {
      if (this._useHandle) {
        if (this._dragging = !n, !n) {
          var o = this._applyTransform([
            i,
            a
          ], this._shapes.mainGroup, true);
          this._updateInterval(r, o[1]), this._hideIndicator(), this._updateView();
        }
        n === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), n ? !this._hovering && this._clearHoverLinkToSeries() : J$(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[r], false);
      }
    }, e.prototype._resetInterval = function() {
      var r = this.visualMapModel, n = this._dataInterval = r.getSelected(), i = r.getExtent(), a = [
        0,
        r.itemSize[1]
      ];
      this._handleEnds = [
        pa(n[0], i, a, true),
        pa(n[1], i, a, true)
      ];
    }, e.prototype._updateInterval = function(r, n) {
      n = n || 0;
      var i = this.visualMapModel, a = this._handleEnds, o = [
        0,
        i.itemSize[1]
      ];
      cu(n, a, o, r, 0);
      var s = i.getExtent();
      this._dataInterval = [
        pa(a[0], o, s, true),
        pa(a[1], o, s, true)
      ];
    }, e.prototype._updateView = function(r) {
      var n = this.visualMapModel, i = n.getExtent(), a = this._shapes, o = [
        0,
        n.itemSize[1]
      ], s = r ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, o, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, e.prototype._createBarVisual = function(r, n, i, a) {
      var o = {
        forceState: a,
        convertOpacityToAlpha: true
      }, s = this._makeColorGradient(r, o), l = [
        this.getControllerVisual(r[0], "symbolSize", o),
        this.getControllerVisual(r[1], "symbolSize", o)
      ], u = this._createBarPoints(i, l);
      return {
        barColor: new $d(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [
          s[0].color,
          s[s.length - 1].color
        ]
      };
    }, e.prototype._makeColorGradient = function(r, n) {
      var i = 100, a = [], o = (r[1] - r[0]) / i;
      a.push({
        color: this.getControllerVisual(r[0], "color", n),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = r[0] + o * s;
        if (l > r[1]) break;
        a.push({
          color: this.getControllerVisual(l, "color", n),
          offset: s / i
        });
      }
      return a.push({
        color: this.getControllerVisual(r[1], "color", n),
        offset: 1
      }), a;
    }, e.prototype._createBarPoints = function(r, n) {
      var i = this.visualMapModel.itemSize;
      return [
        [
          i[0] - n[0],
          r[0]
        ],
        [
          i[0],
          r[0]
        ],
        [
          i[0],
          r[1]
        ],
        [
          i[0] - n[1],
          r[1]
        ]
      ];
    }, e.prototype._createBarGroup = function(r) {
      var n = this._orient, i = this.visualMapModel.get("inverse");
      return new Be(n === "horizontal" && !i ? {
        scaleX: r === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : n === "horizontal" && i ? {
        scaleX: r === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : n === "vertical" && !i ? {
        scaleX: r === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: r === "left" ? 1 : -1
      });
    }, e.prototype._updateHandle = function(r, n) {
      if (this._useHandle) {
        var i = this._shapes, a = this.visualMapModel, o = i.handleThumbs, s = i.handleLabels, l = a.itemSize, u = a.getExtent(), c = this._applyTransform("left", i.mainGroup);
        Xge([
          0,
          1
        ], function(h) {
          var f = o[h];
          f.setStyle("fill", n.handlesColor[h]), f.y = r[h];
          var d = pa(r[h], [
            0,
            l[1]
          ], u, true), p = this.getControllerVisual(d, "symbolSize");
          f.scaleX = f.scaleY = p / l[0], f.x = l[0] - p / 2;
          var v = Yi(i.handleLabelPoints[h], Bl(f, this.group));
          if (this._orient === "horizontal") {
            var g = c === "left" || c === "top" ? (l[0] - p) / 2 : (l[0] - p) / -2;
            v[1] += g;
          }
          s[h].setStyle({
            x: v[0],
            y: v[1],
            text: a.formatValueText(this._dataInterval[h]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, e.prototype._showIndicator = function(r, n, i, a) {
      var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [
        0,
        l[1]
      ], c = this._shapes, h = c.indicator;
      if (h) {
        h.attr("invisible", false);
        var f = {
          convertOpacityToAlpha: true
        }, d = this.getControllerVisual(r, "color", f), p = this.getControllerVisual(r, "symbolSize"), v = pa(r, s, u, true), g = l[0] - p / 2, m = {
          x: h.x,
          y: h.y
        };
        h.y = v, h.x = g;
        var y = Yi(c.indicatorLabelPoint, Bl(h, this.group)), _ = c.indicatorLabel;
        _.attr("invisible", false);
        var b = this._applyTransform("left", c.mainGroup), w = this._orient, x = w === "horizontal";
        _.setStyle({
          text: (i || "") + o.formatValueText(n),
          verticalAlign: x ? b : "middle",
          align: x ? "center" : b
        });
        var T = {
          x: g,
          y: v,
          style: {
            fill: d
          }
        }, A = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var I = {
            duration: 100,
            easing: "cubicInOut",
            additive: true
          };
          h.x = m.x, h.y = m.y, h.animateTo(T, I), _.animateTo(A, I);
        } else h.attr(T), _.attr(A);
        this._firstShowIndicator = false;
        var M = this._shapes.handleLabels;
        if (M) for (var k = 0; k < M.length; k++) this.api.enterBlur(M[k]);
      }
    }, e.prototype._enableHoverLinkToSeries = function() {
      var r = this;
      this._shapes.mainGroup.on("mousemove", function(n) {
        if (r._hovering = true, !r._dragging) {
          var i = r.visualMapModel.itemSize, a = r._applyTransform([
            n.offsetX,
            n.offsetY
          ], r._shapes.mainGroup, true, true);
          a[1] = Z$(fb(0, a[1]), i[1]), r._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]);
        }
      }).on("mouseout", function() {
        r._hovering = false, !r._dragging && r._clearHoverLinkToSeries();
      });
    }, e.prototype._enableHoverLinkFromSeries = function() {
      var r = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (r.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), r.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, e.prototype._doHoverLinkToSeries = function(r, n) {
      var i = this.visualMapModel, a = i.itemSize;
      if (i.option.hoverLink) {
        var o = [
          0,
          a[1]
        ], s = i.getExtent();
        r = Z$(fb(o[0], r), o[1]);
        var l = Qge(i, s, o), u = [
          r - l,
          r + l
        ], c = pa(r, o, s, true), h = [
          pa(u[0], o, s, true),
          pa(u[1], o, s, true)
        ];
        u[0] < o[0] && (h[0] = -1 / 0), u[1] > o[1] && (h[1] = 1 / 0), n && (h[0] === -1 / 0 ? this._showIndicator(c, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, "\u2248 ", l));
        var f = this._hoverLinkDataIndices, d = [];
        (n || J$(i)) && (d = this._hoverLinkDataIndices = i.findTargetDataIndices(h));
        var p = iQ(f, d);
        this._dispatchHighDown("downplay", vg(p[0], i)), this._dispatchHighDown("highlight", vg(p[1], i));
      }
    }, e.prototype._hoverLinkFromSeriesMouseOver = function(r) {
      var n;
      if (Al(r.target, function(l) {
        var u = Ge(l);
        if (u.dataIndex != null) return n = u, true;
      }, true), !!n) {
        var i = this.ecModel.getSeriesByIndex(n.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(i)) {
          var o = i.getData(n.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), n.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, e.prototype._hideIndicator = function() {
      var r = this._shapes;
      r.indicator && r.indicator.attr("invisible", true), r.indicatorLabel && r.indicatorLabel.attr("invisible", true);
      var n = this._shapes.handleLabels;
      if (n) for (var i = 0; i < n.length; i++) this.api.leaveBlur(n[i]);
    }, e.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var r = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", vg(r, this.visualMapModel)), r.length = 0;
    }, e.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var r = this.api.getZr();
      r.off("mouseover", this._hoverLinkFromSeriesMouseOver), r.off("mouseout", this._hideIndicator);
    }, e.prototype._applyTransform = function(r, n, i, a) {
      var o = Bl(n, a ? null : this.group);
      return ae(r) ? Yi(r, o, i) : Km(r, o, i);
    }, e.prototype._dispatchHighDown = function(r, n) {
      n && n.length && this.api.dispatchAction({
        type: r,
        batch: n
      });
    }, e.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.type = "visualMap.continuous", e;
  }(qH);
  function Q$(t, e, r, n) {
    return new Sn({
      shape: {
        points: t
      },
      draggable: !!r,
      cursor: e,
      drift: r,
      onmousemove: function(i) {
        co(i.event);
      },
      ondragend: n
    });
  }
  function Qge(t, e, r) {
    var n = jge / 2, i = t.get("hoverLinkDataSize");
    return i && (n = pa(i, e, r, true) / 2), n;
  }
  function J$(t) {
    var e = t.get("hoverLinkOnHandle");
    return !!(e ?? t.get("realtime"));
  }
  function eR(t) {
    return t === "vertical" ? "ns-resize" : "ew-resize";
  }
  var Jge = {
    type: "selectDataRange",
    event: "dataRangeSelected",
    update: "update"
  }, eme = function(t, e) {
    e.eachComponent({
      mainType: "visualMap",
      query: t
    }, function(r) {
      r.setSelected(t.selected);
    });
  }, tme = [
    {
      createOnAllSeries: true,
      reset: function(t, e) {
        var r = [];
        return e.eachComponent("visualMap", function(n) {
          var i = t.pipelineContext;
          !n.isTargetSeries(t) || i && i.large || r.push(Sve(n.stateList, n.targetVisuals, _e(n.getValueState, n), n.getDataDimensionIndex(t.getData())));
        }), r;
      }
    },
    {
      createOnAllSeries: true,
      reset: function(t, e) {
        var r = t.getData(), n = [];
        e.eachComponent("visualMap", function(i) {
          if (i.isTargetSeries(t)) {
            var a = i.getVisualMeta(_e(rme, null, t, i)) || {
              stops: [],
              outerColors: []
            }, o = i.getDataDimensionIndex(r);
            o >= 0 && (a.dimension = o, n.push(a));
          }
        }), t.getData().setVisual("visualMeta", n);
      }
    }
  ];
  function rme(t, e, r, n) {
    for (var i = e.targetVisuals[n], a = Er.prepareVisualTypes(i), o = {
      color: Bd(t.getData(), "color")
    }, s = 0, l = a.length; s < l; s++) {
      var u = a[s], c = i[u === "opacity" ? "__alphaForOpacity" : u];
      c && c.applyVisual(r, h, f);
    }
    return o.color;
    function h(d) {
      return o[d];
    }
    function f(d, p) {
      o[d] = p;
    }
  }
  var tR = $;
  function nme(t) {
    var e = t && t.visualMap;
    ae(e) || (e = e ? [
      e
    ] : []), tR(e, function(r) {
      if (r) {
        Ou(r, "splitList") && !Ou(r, "pieces") && (r.pieces = r.splitList, delete r.splitList);
        var n = r.pieces;
        n && ae(n) && tR(n, function(i) {
          Le(i) && (Ou(i, "start") && !Ou(i, "min") && (i.min = i.start), Ou(i, "end") && !Ou(i, "max") && (i.max = i.end));
        });
      }
    });
  }
  function Ou(t, e) {
    return t && t.hasOwnProperty && t.hasOwnProperty(e);
  }
  var rR = false;
  function jH(t) {
    rR || (rR = true, t.registerSubTypeDefaulter("visualMap", function(e) {
      return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise";
    }), t.registerAction(Jge, eme), $(tme, function(e) {
      t.registerVisual(t.PRIORITY.VISUAL.COMPONENT, e);
    }), t.registerPreprocessor(nme));
  }
  function KH(t) {
    t.registerComponentModel(qge), t.registerComponentView(Zge), jH(t);
  }
  var ime = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r._pieceList = [], r;
    }
    return e.prototype.optionUpdated = function(r, n) {
      t.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], ame[this._mode].call(this, this._pieceList), this._resetSelected(r, n);
      var a = this.option.categories;
      this.resetVisual(function(o, s) {
        i === "categories" ? (o.mappingMethod = "category", o.categories = Oe(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = oe(this._pieceList, function(l) {
          return l = Oe(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, e.prototype.completeVisualOption = function() {
      var r = this.option, n = {}, i = Er.listVisualTypes(), a = this.isCategory();
      $(r.pieces, function(s) {
        $(i, function(l) {
          s.hasOwnProperty(l) && (n[l] = 1);
        });
      }), $(n, function(s, l) {
        var u = false;
        $(this.stateList, function(c) {
          u = u || o(r, c, l) || o(r.target, c, l);
        }, this), !u && $(this.stateList, function(c) {
          (r[c] || (r[c] = {}))[l] = YH.get(l, c === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function o(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      t.prototype.completeVisualOption.apply(this, arguments);
    }, e.prototype._resetSelected = function(r, n) {
      var i = this.option, a = this._pieceList, o = (n ? i : r).selected || {};
      if (i.selected = o, $(a, function(l, u) {
        var c = this.getSelectedMapKey(l);
        o.hasOwnProperty(c) || (o[c] = true);
      }, this), i.selectedMode === "single") {
        var s = false;
        $(a, function(l, u) {
          var c = this.getSelectedMapKey(l);
          o[c] && (s ? o[c] = false : s = true);
        }, this);
      }
    }, e.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, e.prototype.getSelectedMapKey = function(r) {
      return this._mode === "categories" ? r.value + "" : r.index + "";
    }, e.prototype.getPieceList = function() {
      return this._pieceList;
    }, e.prototype._determineMode = function() {
      var r = this.option;
      return r.pieces && r.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, e.prototype.setSelected = function(r) {
      this.option.selected = Oe(r);
    }, e.prototype.getValueState = function(r) {
      var n = Er.findPieceIndex(r, this._pieceList);
      return n != null && this.option.selected[this.getSelectedMapKey(this._pieceList[n])] ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(r) {
      var n = [], i = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var o = [], s = a.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = Er.findPieceIndex(l, i);
          c === r && o.push(u);
        }, this), n.push({
          seriesId: a.id,
          dataIndex: o
        });
      }, this), n;
    }, e.prototype.getRepresentValue = function(r) {
      var n;
      if (this.isCategory()) n = r.value;
      else if (r.value != null) n = r.value;
      else {
        var i = r.interval || [];
        n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return n;
    }, e.prototype.getVisualMeta = function(r) {
      if (this.isCategory()) return;
      var n = [], i = [
        "",
        ""
      ], a = this;
      function o(c, h) {
        var f = a.getRepresentValue({
          interval: c
        });
        h || (h = a.getValueState(f));
        var d = r(f, h);
        c[0] === -1 / 0 ? i[0] = d : c[1] === 1 / 0 ? i[1] = d : n.push({
          value: c[0],
          color: d
        }, {
          value: c[1],
          color: d
        });
      }
      var s = this._pieceList.slice();
      if (!s.length) s.push({
        interval: [
          -1 / 0,
          1 / 0
        ]
      });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [
            -1 / 0,
            l
          ]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [
            l,
            1 / 0
          ]
        });
      }
      var u = -1 / 0;
      return $(s, function(c) {
        var h = c.interval;
        h && (h[0] > u && o([
          u,
          h[0]
        ], "outOfRange"), o(h.slice()), u = h[1]);
      }, this), {
        stops: n,
        outerColors: i
      };
    }, e.type = "visualMap.piecewise", e.defaultOption = xs(cm.defaultOption, {
      selected: null,
      minOpen: false,
      maxOpen: false,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: true
    }), e;
  }(cm), ame = {
    splitNumber: function(t) {
      var e = this.option, r = Math.min(e.precision, 20), n = this.getExtent(), i = e.splitNumber;
      i = Math.max(parseInt(i, 10), 1), e.splitNumber = i;
      for (var a = (n[1] - n[0]) / i; +a.toFixed(r) !== a && r < 5; ) r++;
      e.precision = r, a = +a.toFixed(r), e.minOpen && t.push({
        interval: [
          -1 / 0,
          n[0]
        ],
        close: [
          0,
          0
        ]
      });
      for (var o = 0, s = n[0]; o < i; s += a, o++) {
        var l = o === i - 1 ? n[1] : s + a;
        t.push({
          interval: [
            s,
            l
          ],
          close: [
            1,
            1
          ]
        });
      }
      e.maxOpen && t.push({
        interval: [
          n[1],
          1 / 0
        ],
        close: [
          0,
          0
        ]
      }), KM(t), $(t, function(u, c) {
        u.index = c, u.text = this.formatValueText(u.interval);
      }, this);
    },
    categories: function(t) {
      var e = this.option;
      $(e.categories, function(r) {
        t.push({
          text: this.formatValueText(r, true),
          value: r
        });
      }, this), nR(e, t);
    },
    pieces: function(t) {
      var e = this.option;
      $(e.pieces, function(r, n) {
        Le(r) || (r = {
          value: r
        });
        var i = {
          text: "",
          index: n
        };
        if (r.label != null && (i.text = r.label), r.hasOwnProperty("value")) {
          var a = i.value = r.value;
          i.interval = [
            a,
            a
          ], i.close = [
            1,
            1
          ];
        } else {
          for (var o = i.interval = [], s = i.close = [
            0,
            0
          ], l = [
            1,
            0,
            1
          ], u = [
            -1 / 0,
            1 / 0
          ], c = [], h = 0; h < 2; h++) {
            for (var f = [
              [
                "gte",
                "gt",
                "min"
              ],
              [
                "lte",
                "lt",
                "max"
              ]
            ][h], d = 0; d < 3 && o[h] == null; d++) o[h] = r[f[d]], s[h] = l[d], c[h] = d === 2;
            o[h] == null && (o[h] = u[h]);
          }
          c[0] && o[1] === 1 / 0 && (s[0] = 0), c[1] && o[0] === -1 / 0 && (s[1] = 0), o[0] === o[1] && s[0] && s[1] && (i.value = o[0]);
        }
        i.visual = Er.retrieveVisuals(r), t.push(i);
      }, this), nR(e, t), KM(t), $(t, function(r) {
        var n = r.close, i = [
          [
            "<",
            "\u2264"
          ][n[1]],
          [
            ">",
            "\u2265"
          ][n[0]]
        ];
        r.text = r.text || this.formatValueText(r.value != null ? r.value : r.interval, false, i);
      }, this);
    }
  };
  function nR(t, e) {
    var r = t.inverse;
    (t.orient === "vertical" ? !r : r) && e.reverse();
  }
  var ome = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = e.type, r;
    }
    return e.prototype.doRender = function() {
      var r = this.group;
      r.removeAll();
      var n = this.visualMapModel, i = n.get("textGap"), a = n.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), u = n.itemSize, c = this._getViewData(), h = c.endsText, f = Fr(n.get("showLabel", true), !h), d = !n.get("selectedMode");
      h && this._renderEndsText(r, h[0], u, f, l), $(c.viewPieceList, function(p) {
        var v = p.piece, g = new Be();
        g.onclick = _e(this._onItemClick, this, v), this._enableHoverLink(g, p.indexInModelPieceList);
        var m = n.getRepresentValue(v);
        if (this._createItemSymbol(g, m, [
          0,
          0,
          u[0],
          u[1]
        ], d), f) {
          var y = this.visualMapModel.getValueState(m);
          g.add(new bt({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: v.text,
              verticalAlign: "middle",
              align: l,
              font: o,
              fill: s,
              opacity: y === "outOfRange" ? 0.5 : 1
            },
            silent: d
          }));
        }
        r.add(g);
      }, this), h && this._renderEndsText(r, h[1], u, f, l), zl(n.get("orient"), r, n.get("itemGap")), this.renderBackground(r), this.positionGroup(r);
    }, e.prototype._enableHoverLink = function(r, n) {
      var i = this;
      r.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(o) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: o,
          batch: vg(s.findTargetDataIndices(n), s)
        });
      };
    }, e.prototype._getItemAlign = function() {
      var r = this.visualMapModel, n = r.option;
      if (n.orient === "vertical") return XH(r, this.api, r.itemSize);
      var i = n.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, e.prototype._renderEndsText = function(r, n, i, a, o) {
      if (n) {
        var s = new Be(), l = this.visualMapModel.textStyleModel;
        s.add(new bt({
          style: Yt(l, {
            x: a ? o === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: a ? o : "center",
            text: n
          })
        })), r.add(s);
      }
    }, e.prototype._getViewData = function() {
      var r = this.visualMapModel, n = oe(r.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = r.get("text"), a = r.get("orient"), o = r.get("inverse");
      return (a === "horizontal" ? o : !o) ? n.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: n,
        endsText: i
      };
    }, e.prototype._createItemSymbol = function(r, n, i, a) {
      var o = mr(this.getControllerVisual(n, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(n, "color"));
      o.silent = a, r.add(o);
    }, e.prototype._onItemClick = function(r) {
      var n = this.visualMapModel, i = n.option, a = i.selectedMode;
      if (a) {
        var o = Oe(i.selected), s = n.getSelectedMapKey(r);
        a === "single" || a === true ? (o[s] = true, $(o, function(l, u) {
          o[u] = u === s;
        })) : o[s] = !o[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: o
        });
      }
    }, e.type = "visualMap.piecewise", e;
  }(qH);
  function ZH(t) {
    t.registerComponentModel(ime), t.registerComponentView(ome), jH(t);
  }
  function sme(t) {
    rt(KH), rt(ZH);
  }
  var lme = {
    label: {
      enabled: true
    },
    decal: {
      show: false
    }
  }, iR = _t(), ume = {};
  function cme(t, e) {
    var r = t.getModel("aria");
    if (!r.get("enabled")) return;
    var n = Oe(lme);
    je(n.label, t.getLocaleModel().get("aria"), false), je(r.option, n, false), i(), a();
    function i() {
      var u = r.getModel("decal"), c = u.get("show");
      if (c) {
        var h = Ce();
        t.eachSeries(function(f) {
          if (!f.isColorBySeries()) {
            var d = h.get(f.type);
            d || (d = {}, h.set(f.type, d)), iR(f).scope = d;
          }
        }), t.eachRawSeries(function(f) {
          if (t.isSeriesFiltered(f)) return;
          if (De(f.enableAriaDecal)) {
            f.enableAriaDecal();
            return;
          }
          var d = f.getData();
          if (f.isColorBySeries()) {
            var y = zx(f.ecModel, f.name, ume, t.getSeriesCount()), _ = d.getVisual("decal");
            d.setVisual("decal", b(_, y));
          } else {
            var p = f.getRawData(), v = {}, g = iR(f).scope;
            d.each(function(w) {
              var x = d.getRawIndex(w);
              v[x] = w;
            });
            var m = p.count();
            p.each(function(w) {
              var x = v[w], T = p.getName(w) || w + "", A = zx(f.ecModel, T, g, m), I = d.getItemVisual(x, "decal");
              d.setItemVisual(x, "decal", b(I, A));
            });
          }
          function b(w, x) {
            var T = w ? te(te({}, x), w) : x;
            return T.dirty = true, T;
          }
        });
      }
    }
    function a() {
      var u = e.getZr().dom;
      if (u) {
        var c = t.getLocaleModel().get("aria"), h = r.getModel("label");
        if (h.option = Ee(h.option, c), !!h.get("enabled")) {
          if (u.setAttribute("role", "img"), h.get("description")) {
            u.setAttribute("aria-label", h.get("description"));
            return;
          }
          var f = t.getSeriesCount(), d = h.get([
            "data",
            "maxCount"
          ]) || 10, p = h.get([
            "series",
            "maxCount"
          ]) || 10, v = Math.min(f, p), g;
          if (!(f < 1)) {
            var m = s();
            if (m) {
              var y = h.get([
                "general",
                "withTitle"
              ]);
              g = o(y, {
                title: m
              });
            } else g = h.get([
              "general",
              "withoutTitle"
            ]);
            var _ = [], b = f > 1 ? h.get([
              "series",
              "multiple",
              "prefix"
            ]) : h.get([
              "series",
              "single",
              "prefix"
            ]);
            g += o(b, {
              seriesCount: f
            }), t.eachSeries(function(A, I) {
              if (I < v) {
                var M = void 0, k = A.get("name"), B = k ? "withName" : "withoutName";
                M = f > 1 ? h.get([
                  "series",
                  "multiple",
                  B
                ]) : h.get([
                  "series",
                  "single",
                  B
                ]), M = o(M, {
                  seriesId: A.seriesIndex,
                  seriesName: A.get("name"),
                  seriesType: l(A.subType)
                });
                var L = A.getData();
                if (L.count() > d) {
                  var z = h.get([
                    "data",
                    "partialData"
                  ]);
                  M += o(z, {
                    displayCnt: d
                  });
                } else M += h.get([
                  "data",
                  "allData"
                ]);
                for (var F = h.get([
                  "data",
                  "separator",
                  "middle"
                ]), E = h.get([
                  "data",
                  "separator",
                  "end"
                ]), O = h.get([
                  "data",
                  "excludeDimensionId"
                ]), N = [], V = 0; V < L.count(); V++) if (V < d) {
                  var H = L.getName(V), G = O ? Dt(L.getValues(V), function(U, Z) {
                    return et(O, Z) === -1;
                  }) : L.getValues(V), Y = h.get([
                    "data",
                    H ? "withName" : "withoutName"
                  ]);
                  N.push(o(Y, {
                    name: H,
                    value: G.join(F)
                  }));
                }
                M += N.join(F) + E, _.push(M);
              }
            });
            var w = h.getModel([
              "series",
              "multiple",
              "separator"
            ]), x = w.get("middle"), T = w.get("end");
            g += _.join(x) + T, u.setAttribute("aria-label", g);
          }
        }
      }
    }
    function o(u, c) {
      if (!me(u)) return u;
      var h = u;
      return $(c, function(f, d) {
        h = h.replace(new RegExp("\\{\\s*" + d + "\\s*\\}", "g"), f);
      }), h;
    }
    function s() {
      var u = t.get("title");
      return u && u.length && (u = u[0]), u && u.text;
    }
    function l(u) {
      var c = t.getLocaleModel().get([
        "series",
        "typeNames"
      ]);
      return c[u] || c.chart;
    }
  }
  function hme(t) {
    if (!(!t || !t.aria)) {
      var e = t.aria;
      e.show != null && (e.enabled = e.show), e.label = e.label || {}, $([
        "description",
        "general",
        "series",
        "data"
      ], function(r) {
        e[r] != null && (e.label[r] = e[r]);
      });
    }
  }
  function fme(t) {
    t.registerPreprocessor(hme), t.registerVisual(t.PRIORITY.VISUAL.ARIA, cme);
  }
  var aR = {
    value: "eq",
    "<": "lt",
    "<=": "lte",
    ">": "gt",
    ">=": "gte",
    "=": "eq",
    "!=": "ne",
    "<>": "ne"
  }, dme = function() {
    function t(e) {
      var r = this._condVal = me(e) ? new RegExp(e) : xK(e) ? e : null;
      if (r == null) {
        var n = "";
        It(n);
      }
    }
    return t.prototype.evaluate = function(e) {
      var r = typeof e;
      return me(r) ? this._condVal.test(e) : xt(r) ? this._condVal.test(e + "") : false;
    }, t;
  }(), pme = function() {
    function t() {
    }
    return t.prototype.evaluate = function() {
      return this.value;
    }, t;
  }(), vme = function() {
    function t() {
    }
    return t.prototype.evaluate = function() {
      for (var e = this.children, r = 0; r < e.length; r++) if (!e[r].evaluate()) return false;
      return true;
    }, t;
  }(), gme = function() {
    function t() {
    }
    return t.prototype.evaluate = function() {
      for (var e = this.children, r = 0; r < e.length; r++) if (e[r].evaluate()) return true;
      return false;
    }, t;
  }(), mme = function() {
    function t() {
    }
    return t.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, t;
  }(), yme = function() {
    function t() {
    }
    return t.prototype.evaluate = function() {
      for (var e = !!this.valueParser, r = this.getValue, n = r(this.valueGetterParam), i = e ? this.valueParser(n) : null, a = 0; a < this.subCondList.length; a++) if (!this.subCondList[a].evaluate(e ? i : n)) return false;
      return true;
    }, t;
  }();
  function j2(t, e) {
    if (t === true || t === false) {
      var r = new pme();
      return r.value = t, r;
    }
    var n = "";
    return QH(t) || It(n), t.and ? oR("and", t, e) : t.or ? oR("or", t, e) : t.not ? _me(t, e) : bme(t, e);
  }
  function oR(t, e, r) {
    var n = e[t], i = "";
    ae(n) || It(i), n.length || It(i);
    var a = t === "and" ? new vme() : new gme();
    return a.children = oe(n, function(o) {
      return j2(o, r);
    }), a.children.length || It(i), a;
  }
  function _me(t, e) {
    var r = t.not, n = "";
    QH(r) || It(n);
    var i = new mme();
    return i.child = j2(r, e), i.child || It(n), i;
  }
  function bme(t, e) {
    for (var r = "", n = e.prepareGetValue(t), i = [], a = gt(t), o = t.parser, s = o ? LV(o) : null, l = 0; l < a.length; l++) {
      var u = a[l];
      if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
        var c = xe(aR, u) ? aR[u] : u, h = t[u], f = s ? s(h) : h, d = ste(c, f) || c === "reg" && new dme(f);
        d || It(r), i.push(d);
      }
    }
    i.length || It(r);
    var p = new yme();
    return p.valueGetterParam = n, p.valueParser = s, p.getValue = e.getValue, p.subCondList = i, p;
  }
  function QH(t) {
    return Le(t) && !on(t);
  }
  var xme = function() {
    function t(e, r) {
      this._cond = j2(e, r);
    }
    return t.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, t;
  }();
  function wme(t, e) {
    return new xme(t, e);
  }
  var Sme = {
    type: "echarts:filter",
    transform: function(t) {
      for (var e = t.upstream, r, n = wme(t.config, {
        valueGetterAttrMap: Ce({
          dimension: true
        }),
        prepareGetValue: function(s) {
          var l = "", u = s.dimension;
          xe(s, "dimension") || It(l);
          var c = e.getDimensionInfo(u);
          return c || It(l), {
            dimIdx: c.index
          };
        },
        getValue: function(s) {
          return e.retrieveValueFromItem(r, s.dimIdx);
        }
      }), i = [], a = 0, o = e.count(); a < o; a++) r = e.getRawDataItem(a), n.evaluate() && i.push(r);
      return {
        data: i
      };
    }
  }, Tme = {
    type: "echarts:sort",
    transform: function(t) {
      var e = t.upstream, r = t.config, n = "", i = Ot(r);
      i.length || It(n);
      var a = [];
      $(i, function(c) {
        var h = c.dimension, f = c.order, d = c.parser, p = c.incomparable;
        if (h == null && It(n), f !== "asc" && f !== "desc" && It(n), p && p !== "min" && p !== "max") {
          var v = "";
          It(v);
        }
        if (f !== "asc" && f !== "desc") {
          var g = "";
          It(g);
        }
        var m = e.getDimensionInfo(h);
        m || It(n);
        var y = d ? LV(d) : null;
        d && !y && It(n), a.push({
          dimIdx: m.index,
          parser: y,
          comparator: new RV(f, p)
        });
      });
      var o = e.sourceFormat;
      o !== sn && o !== Si && It(n);
      for (var s = [], l = 0, u = e.count(); l < u; l++) s.push(e.getRawDataItem(l));
      return s.sort(function(c, h) {
        for (var f = 0; f < a.length; f++) {
          var d = a[f], p = e.retrieveValueFromItem(c, d.dimIdx), v = e.retrieveValueFromItem(h, d.dimIdx);
          d.parser && (p = d.parser(p), v = d.parser(v));
          var g = d.comparator.evaluate(p, v);
          if (g !== 0) return g;
        }
        return 0;
      }), {
        data: s
      };
    }
  };
  function Cme(t) {
    t.registerTransform(Sme), t.registerTransform(Tme);
  }
  var Ame = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = "dataset", r;
    }
    return e.prototype.init = function(r, n, i) {
      t.prototype.init.call(this, r, n, i), this._sourceManager = new zV(this), lE(this);
    }, e.prototype.mergeOption = function(r, n) {
      t.prototype.mergeOption.call(this, r, n), lE(this);
    }, e.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, e.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, e.type = "dataset", e.defaultOption = {
      seriesLayoutBy: Ma
    }, e;
  }(vt), Ime = function(t) {
    K(e, t);
    function e() {
      var r = t !== null && t.apply(this, arguments) || this;
      return r.type = "dataset", r;
    }
    return e.type = "dataset", e;
  }(tr);
  function Mme(t) {
    t.registerComponentModel(Ame), t.registerComponentView(Ime);
  }
  var ca = Ra.CMD;
  function ac(t, e) {
    return Math.abs(t - e) < 1e-5;
  }
  function Fw(t) {
    var e = t.data, r = t.len(), n = [], i, a = 0, o = 0, s = 0, l = 0;
    function u(L, z) {
      i && i.length > 2 && n.push(i), i = [
        L,
        z
      ];
    }
    function c(L, z, F, E) {
      ac(L, F) && ac(z, E) || i.push(L, z, F, E, F, E);
    }
    function h(L, z, F, E, O, N) {
      var V = Math.abs(z - L), H = Math.tan(V / 4) * 4 / 3, G = z < L ? -1 : 1, Y = Math.cos(L), U = Math.sin(L), Z = Math.cos(z), ee = Math.sin(z), we = Y * O + F, Te = U * N + E, le = Z * O + F, ue = ee * N + E, ye = O * H * G, ve = N * H * G;
      i.push(we - ye * U, Te + ve * Y, le + ye * ee, ue - ve * Z, le, ue);
    }
    for (var f, d, p, v, g = 0; g < r; ) {
      var m = e[g++], y = g === 1;
      switch (y && (a = e[g], o = e[g + 1], s = a, l = o, (m === ca.L || m === ca.C || m === ca.Q) && (i = [
        s,
        l
      ])), m) {
        case ca.M:
          a = s = e[g++], o = l = e[g++], u(s, l);
          break;
        case ca.L:
          f = e[g++], d = e[g++], c(a, o, f, d), a = f, o = d;
          break;
        case ca.C:
          i.push(e[g++], e[g++], e[g++], e[g++], a = e[g++], o = e[g++]);
          break;
        case ca.Q:
          f = e[g++], d = e[g++], p = e[g++], v = e[g++], i.push(a + 2 / 3 * (f - a), o + 2 / 3 * (d - o), p + 2 / 3 * (f - p), v + 2 / 3 * (d - v), p, v), a = p, o = v;
          break;
        case ca.A:
          var _ = e[g++], b = e[g++], w = e[g++], x = e[g++], T = e[g++], A = e[g++] + T;
          g += 1;
          var I = !e[g++];
          f = Math.cos(T) * w + _, d = Math.sin(T) * x + b, y ? (s = f, l = d, u(s, l)) : c(a, o, f, d), a = Math.cos(A) * w + _, o = Math.sin(A) * x + b;
          for (var M = (I ? -1 : 1) * Math.PI / 2, k = T; I ? k > A : k < A; k += M) {
            var B = I ? Math.max(k + M, A) : Math.min(k + M, A);
            h(k, B, _, b, w, x);
          }
          break;
        case ca.R:
          s = a = e[g++], l = o = e[g++], f = s + e[g++], d = l + e[g++], u(f, l), c(f, l, f, d), c(f, d, s, d), c(s, d, s, l), c(s, l, f, l);
          break;
        case ca.Z:
          i && c(a, o, s, l), a = s, o = l;
          break;
      }
    }
    return i && i.length > 2 && n.push(i), n;
  }
  function Vw(t, e, r, n, i, a, o, s, l, u) {
    if (ac(t, r) && ac(e, n) && ac(i, o) && ac(a, s)) {
      l.push(o, s);
      return;
    }
    var c = 2 / u, h = c * c, f = o - t, d = s - e, p = Math.sqrt(f * f + d * d);
    f /= p, d /= p;
    var v = r - t, g = n - e, m = i - o, y = a - s, _ = v * v + g * g, b = m * m + y * y;
    if (_ < h && b < h) {
      l.push(o, s);
      return;
    }
    var w = f * v + d * g, x = -f * m - d * y, T = _ - w * w, A = b - x * x;
    if (T < h && w >= 0 && A < h && x >= 0) {
      l.push(o, s);
      return;
    }
    var I = [], M = [];
    fs(t, r, i, o, 0.5, I), fs(e, n, a, s, 0.5, M), Vw(I[0], M[0], I[1], M[1], I[2], M[2], I[3], M[3], l, u), Vw(I[4], M[4], I[5], M[5], I[6], M[6], I[7], M[7], l, u);
  }
  function Dme(t, e) {
    var r = Fw(t), n = [];
    e = e || 1;
    for (var i = 0; i < r.length; i++) {
      var a = r[i], o = [], s = a[0], l = a[1];
      o.push(s, l);
      for (var u = 2; u < a.length; ) {
        var c = a[u++], h = a[u++], f = a[u++], d = a[u++], p = a[u++], v = a[u++];
        Vw(s, l, c, h, f, d, p, v, o, e), s = p, l = v;
      }
      n.push(o);
    }
    return n;
  }
  function JH(t, e, r) {
    var n = t[e], i = t[1 - e], a = Math.abs(n / i), o = Math.ceil(Math.sqrt(a * r)), s = Math.floor(r / o);
    s === 0 && (s = 1, o = r);
    for (var l = [], u = 0; u < o; u++) l.push(s);
    var c = o * s, h = r - c;
    if (h > 0) for (var u = 0; u < h; u++) l[u % o] += 1;
    return l;
  }
  function sR(t, e, r) {
    for (var n = t.r0, i = t.r, a = t.startAngle, o = t.endAngle, s = Math.abs(o - a), l = s * i, u = i - n, c = l > Math.abs(u), h = JH([
      l,
      u
    ], c ? 0 : 1, e), f = (c ? s : u) / h.length, d = 0; d < h.length; d++) for (var p = (c ? u : s) / h[d], v = 0; v < h[d]; v++) {
      var g = {};
      c ? (g.startAngle = a + f * d, g.endAngle = a + f * (d + 1), g.r0 = n + p * v, g.r = n + p * (v + 1)) : (g.startAngle = a + p * v, g.endAngle = a + p * (v + 1), g.r0 = n + f * d, g.r = n + f * (d + 1)), g.clockwise = t.clockwise, g.cx = t.cx, g.cy = t.cy, r.push(g);
    }
  }
  function Eme(t, e, r) {
    for (var n = t.width, i = t.height, a = n > i, o = JH([
      n,
      i
    ], a ? 0 : 1, e), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", c = a ? "y" : "x", h = t[s] / o.length, f = 0; f < o.length; f++) for (var d = t[l] / o[f], p = 0; p < o[f]; p++) {
      var v = {};
      v[u] = f * h, v[c] = p * d, v[s] = h, v[l] = d, v.x += t.x, v.y += t.y, r.push(v);
    }
  }
  function lR(t, e, r, n) {
    return t * n - r * e;
  }
  function kme(t, e, r, n, i, a, o, s) {
    var l = r - t, u = n - e, c = o - i, h = s - a, f = lR(c, h, l, u);
    if (Math.abs(f) < 1e-6) return null;
    var d = t - i, p = e - a, v = lR(d, p, c, h) / f;
    return v < 0 || v > 1 ? null : new Ke(v * l + t, v * u + e);
  }
  function Pme(t, e, r) {
    var n = new Ke();
    Ke.sub(n, r, e), n.normalize();
    var i = new Ke();
    Ke.sub(i, t, e);
    var a = i.dot(n);
    return a;
  }
  function Nu(t, e) {
    var r = t[t.length - 1];
    r && r[0] === e[0] && r[1] === e[1] || t.push(e);
  }
  function Lme(t, e, r) {
    for (var n = t.length, i = [], a = 0; a < n; a++) {
      var o = t[a], s = t[(a + 1) % n], l = kme(o[0], o[1], s[0], s[1], e.x, e.y, r.x, r.y);
      l && i.push({
        projPt: Pme(l, e, r),
        pt: l,
        idx: a
      });
    }
    if (i.length < 2) return [
      {
        points: t
      },
      {
        points: t
      }
    ];
    i.sort(function(g, m) {
      return g.projPt - m.projPt;
    });
    var u = i[0], c = i[i.length - 1];
    if (c.idx < u.idx) {
      var h = u;
      u = c, c = h;
    }
    for (var f = [
      u.pt.x,
      u.pt.y
    ], d = [
      c.pt.x,
      c.pt.y
    ], p = [
      f
    ], v = [
      d
    ], a = u.idx + 1; a <= c.idx; a++) Nu(p, t[a].slice());
    Nu(p, d), Nu(p, f);
    for (var a = c.idx + 1; a <= u.idx + n; a++) Nu(v, t[a % n].slice());
    return Nu(v, f), Nu(v, d), [
      {
        points: p
      },
      {
        points: v
      }
    ];
  }
  function uR(t) {
    var e = t.points, r = [], n = [];
    Hm(e, r, n);
    var i = new Ze(r[0], r[1], n[0] - r[0], n[1] - r[1]), a = i.width, o = i.height, s = i.x, l = i.y, u = new Ke(), c = new Ke();
    return a > o ? (u.x = c.x = s + a / 2, u.y = l, c.y = l + o) : (u.y = c.y = l + o / 2, u.x = s, c.x = s + a), Lme(e, u, c);
  }
  function hm(t, e, r, n) {
    if (r === 1) n.push(e);
    else {
      var i = Math.floor(r / 2), a = t(e);
      hm(t, a[0], i, n), hm(t, a[1], r - i, n);
    }
    return n;
  }
  function $me(t, e) {
    for (var r = [], n = 0; n < e; n++) r.push(dT(t));
    return r;
  }
  function Rme(t, e) {
    e.setStyle(t.style), e.z = t.z, e.z2 = t.z2, e.zlevel = t.zlevel;
  }
  function Ome(t) {
    for (var e = [], r = 0; r < t.length; ) e.push([
      t[r++],
      t[r++]
    ]);
    return e;
  }
  function Nme(t, e) {
    var r = [], n = t.shape, i;
    switch (t.type) {
      case "rect":
        Eme(n, e, r), i = yt;
        break;
      case "sector":
        sR(n, e, r), i = wn;
        break;
      case "circle":
        sR({
          r0: 0,
          r: n.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: n.cx,
          cy: n.cy
        }, e, r), i = wn;
        break;
      default:
        var a = t.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = oe(Dme(t.getUpdatedPathProxy(), o), function(m) {
          return Ome(m);
        }), l = s.length;
        if (l === 0) hm(uR, {
          points: s[0]
        }, e, r);
        else if (l === e) for (var u = 0; u < l; u++) r.push({
          points: s[u]
        });
        else {
          var c = 0, h = oe(s, function(m) {
            var y = [], _ = [];
            Hm(m, y, _);
            var b = (_[1] - y[1]) * (_[0] - y[0]);
            return c += b, {
              poly: m,
              area: b
            };
          });
          h.sort(function(m, y) {
            return y.area - m.area;
          });
          for (var f = e, u = 0; u < l; u++) {
            var d = h[u];
            if (f <= 0) break;
            var p = u === l - 1 ? f : Math.ceil(d.area / c * e);
            p < 0 || (hm(uR, {
              points: d.poly
            }, p, r), f -= p);
          }
        }
        i = Sn;
        break;
    }
    if (!i) return $me(t, e);
    for (var v = [], u = 0; u < r.length; u++) {
      var g = new i();
      g.setShape(r[u]), Rme(t, g), v.push(g);
    }
    return v;
  }
  function Bme(t, e) {
    var r = t.length, n = e.length;
    if (r === n) return [
      t,
      e
    ];
    for (var i = [], a = [], o = r < n ? t : e, s = Math.min(r, n), l = Math.abs(n - r) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, h = [
      o[0],
      o[1]
    ], f = l, d = 2; d < s; ) {
      var p = o[d - 2], v = o[d - 1], g = o[d++], m = o[d++], y = o[d++], _ = o[d++], b = o[d++], w = o[d++];
      if (f <= 0) {
        h.push(g, m, y, _, b, w);
        continue;
      }
      for (var x = Math.min(f, c - 1) + 1, T = 1; T <= x; T++) {
        var A = T / x;
        fs(p, g, y, b, A, i), fs(v, m, _, w, A, a), p = i[3], v = a[3], h.push(i[1], a[1], i[2], a[2], p, v), g = i[5], m = a[5], y = i[6], _ = a[6];
      }
      f -= x - 1;
    }
    return o === t ? [
      h,
      e
    ] : [
      t,
      h
    ];
  }
  function cR(t, e) {
    for (var r = t.length, n = t[r - 2], i = t[r - 1], a = [], o = 0; o < e.length; ) a[o++] = n, a[o++] = i;
    return a;
  }
  function zme(t, e) {
    for (var r, n, i, a = [], o = [], s = 0; s < Math.max(t.length, e.length); s++) {
      var l = t[s], u = e[s], c = void 0, h = void 0;
      l ? u ? (r = Bme(l, u), c = r[0], h = r[1], n = c, i = h) : (h = cR(i || l, l), c = l) : (c = cR(n || u, u), h = u), a.push(c), o.push(h);
    }
    return [
      a,
      o
    ];
  }
  function hR(t) {
    for (var e = 0, r = 0, n = 0, i = t.length, a = 0, o = i - 2; a < i; o = a, a += 2) {
      var s = t[o], l = t[o + 1], u = t[a], c = t[a + 1], h = s * c - u * l;
      e += h, r += (s + u) * h, n += (l + c) * h;
    }
    return e === 0 ? [
      t[0] || 0,
      t[1] || 0
    ] : [
      r / e / 3,
      n / e / 3,
      e
    ];
  }
  function Fme(t, e, r, n) {
    for (var i = (t.length - 2) / 6, a = 1 / 0, o = 0, s = t.length, l = s - 2, u = 0; u < i; u++) {
      for (var c = u * 6, h = 0, f = 0; f < s; f += 2) {
        var d = f === 0 ? c : (c + f - 2) % l + 2, p = t[d] - r[0], v = t[d + 1] - r[1], g = e[f] - n[0], m = e[f + 1] - n[1], y = g - p, _ = m - v;
        h += y * y + _ * _;
      }
      h < a && (a = h, o = u);
    }
    return o;
  }
  function Vme(t) {
    for (var e = [], r = t.length, n = 0; n < r; n += 2) e[n] = t[r - n - 2], e[n + 1] = t[r - n - 1];
    return e;
  }
  function Gme(t, e, r, n) {
    for (var i = [], a, o = 0; o < t.length; o++) {
      var s = t[o], l = e[o], u = hR(s), c = hR(l);
      a == null && (a = u[2] < 0 != c[2] < 0);
      var h = [], f = [], d = 0, p = 1 / 0, v = [], g = s.length;
      a && (s = Vme(s));
      for (var m = Fme(s, l, u, c) * 6, y = g - 2, _ = 0; _ < y; _ += 2) {
        var b = (m + _) % y + 2;
        h[_ + 2] = s[b] - u[0], h[_ + 3] = s[b + 1] - u[1];
      }
      h[0] = s[m] - u[0], h[1] = s[m + 1] - u[1];
      for (var w = n / r, x = -n / 2; x <= n / 2; x += w) {
        for (var T = Math.sin(x), A = Math.cos(x), I = 0, _ = 0; _ < s.length; _ += 2) {
          var M = h[_], k = h[_ + 1], B = l[_] - c[0], L = l[_ + 1] - c[1], z = B * A - L * T, F = B * T + L * A;
          v[_] = z, v[_ + 1] = F;
          var E = z - M, O = F - k;
          I += E * E + O * O;
        }
        if (I < p) {
          p = I, d = x;
          for (var N = 0; N < v.length; N++) f[N] = v[N];
        }
      }
      i.push({
        from: h,
        to: f,
        fromCp: u,
        toCp: c,
        rotation: -d
      });
    }
    return i;
  }
  function fm(t) {
    return t.__isCombineMorphing;
  }
  var eU = "__mOriginal_";
  function dm(t, e, r) {
    var n = eU + e, i = t[n] || t[e];
    t[n] || (t[n] = t[e]);
    var a = r.replace, o = r.after, s = r.before;
    t[e] = function() {
      var l = arguments, u;
      return s && s.apply(this, l), a ? u = a.apply(this, l) : u = i.apply(this, l), o && o.apply(this, l), u;
    };
  }
  function Pf(t, e) {
    var r = eU + e;
    t[r] && (t[e] = t[r], t[r] = null);
  }
  function fR(t, e) {
    for (var r = 0; r < t.length; r++) for (var n = t[r], i = 0; i < n.length; ) {
      var a = n[i], o = n[i + 1];
      n[i++] = e[0] * a + e[2] * o + e[4], n[i++] = e[1] * a + e[3] * o + e[5];
    }
  }
  function tU(t, e) {
    var r = t.getUpdatedPathProxy(), n = e.getUpdatedPathProxy(), i = zme(Fw(r), Fw(n)), a = i[0], o = i[1], s = t.getComputedTransform(), l = e.getComputedTransform();
    function u() {
      this.transform = null;
    }
    s && fR(a, s), l && fR(o, l), dm(e, "updateTransform", {
      replace: u
    }), e.transform = null;
    var c = Gme(a, o, 10, Math.PI), h = [];
    dm(e, "buildPath", {
      replace: function(f) {
        for (var d = e.__morphT, p = 1 - d, v = [], g = 0; g < c.length; g++) {
          var m = c[g], y = m.from, _ = m.to, b = m.rotation * d, w = m.fromCp, x = m.toCp, T = Math.sin(b), A = Math.cos(b);
          Kv(v, w, x, d);
          for (var I = 0; I < y.length; I += 2) {
            var M = y[I], k = y[I + 1], B = _[I], L = _[I + 1], z = M * p + B * d, F = k * p + L * d;
            h[I] = z * A - F * T + v[0], h[I + 1] = z * T + F * A + v[1];
          }
          var E = h[0], O = h[1];
          f.moveTo(E, O);
          for (var I = 2; I < y.length; ) {
            var B = h[I++], L = h[I++], N = h[I++], V = h[I++], H = h[I++], G = h[I++];
            E === B && O === L && N === H && V === G ? f.lineTo(H, G) : f.bezierCurveTo(B, L, N, V, H, G), E = H, O = G;
          }
        }
      }
    });
  }
  function K2(t, e, r) {
    if (!t || !e) return e;
    var n = r.done, i = r.during;
    tU(t, e), e.__morphT = 0;
    function a() {
      Pf(e, "buildPath"), Pf(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape();
    }
    return e.animateTo({
      __morphT: 1
    }, Ee({
      during: function(o) {
        e.dirtyShape(), i && i(o);
      },
      done: function() {
        a(), n && n();
      }
    }, r)), e;
  }
  function Wme(t, e, r, n, i, a) {
    var o = 16;
    t = i === r ? 0 : Math.round(32767 * (t - r) / (i - r)), e = a === n ? 0 : Math.round(32767 * (e - n) / (a - n));
    for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
      var c = 0, h = 0;
      (t & u) > 0 && (c = 1), (e & u) > 0 && (h = 1), s += u * u * (3 * c ^ h), h === 0 && (c === 1 && (t = u - 1 - t, e = u - 1 - e), l = t, t = e, e = l);
    }
    return s;
  }
  function pm(t) {
    var e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, a = oe(t, function(s) {
      var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), h = l.y + l.height / 2 + (u ? u[5] : 0);
      return e = Math.min(c, e), r = Math.min(h, r), n = Math.max(c, n), i = Math.max(h, i), [
        c,
        h
      ];
    }), o = oe(a, function(s, l) {
      return {
        cp: s,
        z: Wme(s[0], s[1], e, r, n, i),
        path: t[l]
      };
    });
    return o.sort(function(s, l) {
      return s.z - l.z;
    }).map(function(s) {
      return s.path;
    });
  }
  function rU(t) {
    return Nme(t.path, t.count);
  }
  function Gw() {
    return {
      fromIndividuals: [],
      toIndividuals: [],
      count: 0
    };
  }
  function Hme(t, e, r) {
    var n = [];
    function i(w) {
      for (var x = 0; x < w.length; x++) {
        var T = w[x];
        fm(T) ? i(T.childrenRef()) : T instanceof st && n.push(T);
      }
    }
    i(t);
    var a = n.length;
    if (!a) return Gw();
    var o = r.dividePath || rU, s = o({
      path: e,
      count: a
    });
    if (s.length !== a) return console.error("Invalid morphing: unmatched splitted path"), Gw();
    n = pm(n), s = pm(s);
    for (var l = r.done, u = r.during, c = r.individualDelay, h = new Qa(), f = 0; f < a; f++) {
      var d = n[f], p = s[f];
      p.parent = e, p.copyTransform(h), c || tU(d, p);
    }
    e.__isCombineMorphing = true, e.childrenRef = function() {
      return s;
    };
    function v(w) {
      for (var x = 0; x < s.length; x++) s[x].addSelfToZr(w);
    }
    dm(e, "addSelfToZr", {
      after: function(w) {
        v(w);
      }
    }), dm(e, "removeSelfFromZr", {
      after: function(w) {
        for (var x = 0; x < s.length; x++) s[x].removeSelfFromZr(w);
      }
    });
    function g() {
      e.__isCombineMorphing = false, e.__morphT = -1, e.childrenRef = null, Pf(e, "addSelfToZr"), Pf(e, "removeSelfFromZr");
    }
    var m = s.length;
    if (c) for (var y = m, _ = function() {
      y--, y === 0 && (g(), l && l());
    }, f = 0; f < m; f++) {
      var b = c ? Ee({
        delay: (r.delay || 0) + c(f, m, n[f], s[f]),
        done: _
      }, r) : r;
      K2(n[f], s[f], b);
    }
    else e.__morphT = 0, e.animateTo({
      __morphT: 1
    }, Ee({
      during: function(w) {
        for (var x = 0; x < m; x++) {
          var T = s[x];
          T.__morphT = e.__morphT, T.dirtyShape();
        }
        u && u(w);
      },
      done: function() {
        g();
        for (var w = 0; w < t.length; w++) Pf(t[w], "updateTransform");
        l && l();
      }
    }, r));
    return e.__zr && v(e.__zr), {
      fromIndividuals: n,
      toIndividuals: s,
      count: m
    };
  }
  function Ume(t, e, r) {
    var n = e.length, i = [], a = r.dividePath || rU;
    function o(d) {
      for (var p = 0; p < d.length; p++) {
        var v = d[p];
        fm(v) ? o(v.childrenRef()) : v instanceof st && i.push(v);
      }
    }
    if (fm(t)) {
      o(t.childrenRef());
      var s = i.length;
      if (s < n) for (var l = 0, u = s; u < n; u++) i.push(dT(i[l++ % s]));
      i.length = n;
    } else {
      i = a({
        path: t,
        count: n
      });
      for (var c = t.getComputedTransform(), u = 0; u < i.length; u++) i[u].setLocalTransform(c);
      if (i.length !== n) return console.error("Invalid morphing: unmatched splitted path"), Gw();
    }
    i = pm(i), e = pm(e);
    for (var h = r.individualDelay, u = 0; u < n; u++) {
      var f = h ? Ee({
        delay: (r.delay || 0) + h(u, n, i[u], e[u])
      }, r) : r;
      K2(i[u], e[u], f);
    }
    return {
      fromIndividuals: i,
      toIndividuals: e,
      count: e.length
    };
  }
  function dR(t) {
    return ae(t[0]);
  }
  function pR(t, e) {
    for (var r = [], n = t.length, i = 0; i < n; i++) r.push({
      one: t[i],
      many: []
    });
    for (var i = 0; i < e.length; i++) {
      var a = e[i].length, o = void 0;
      for (o = 0; o < a; o++) r[o % n].many.push(e[i][o]);
    }
    for (var s = 0, i = n - 1; i >= 0; i--) if (!r[i].many.length) {
      var l = r[s].many;
      if (l.length <= 1) if (s) s = 0;
      else return r;
      var a = l.length, u = Math.ceil(a / 2);
      r[i].many = l.slice(u, a), r[s].many = l.slice(0, u), s++;
    }
    return r;
  }
  var Yme = {
    clone: function(t) {
      for (var e = [], r = 1 - Math.pow(1 - t.path.style.opacity, 1 / t.count), n = 0; n < t.count; n++) {
        var i = dT(t.path);
        i.setStyle("opacity", r), e.push(i);
      }
      return e;
    },
    split: null
  };
  function db(t, e, r, n, i, a) {
    if (!t.length || !e.length) return;
    var o = Gc("update", n, i);
    if (!(o && o.duration > 0)) return;
    var s = n.getModel("universalTransition").get("delay"), l = Object.assign({
      setToFinal: true
    }, o), u, c;
    dR(t) && (u = t, c = e), dR(e) && (u = e, c = t);
    function h(m, y, _, b, w) {
      var x = m.many, T = m.one;
      if (x.length === 1 && !w) {
        var A = y ? x[0] : T, I = y ? T : x[0];
        if (fm(A)) h({
          many: [
            A
          ],
          one: I
        }, true, _, b, true);
        else {
          var M = s ? Ee({
            delay: s(_, b)
          }, l) : l;
          K2(A, I, M), a(A, I, A, I, M);
        }
      } else for (var k = Ee({
        dividePath: Yme[r],
        individualDelay: s && function(O, N, V, H) {
          return s(O + _, b);
        }
      }, l), B = y ? Hme(x, T, k) : Ume(T, x, k), L = B.fromIndividuals, z = B.toIndividuals, F = L.length, E = 0; E < F; E++) {
        var M = s ? Ee({
          delay: s(E, F)
        }, l) : l;
        a(L[E], z[E], y ? x[E] : m.one, y ? m.one : x[E], M);
      }
    }
    for (var f = u ? u === t : t.length > e.length, d = u ? pR(c, u) : pR(f ? e : t, [
      f ? t : e
    ]), p = 0, v = 0; v < d.length; v++) p += d[v].many.length;
    for (var g = 0, v = 0; v < d.length; v++) h(d[v], f, g, p), g += d[v].many.length;
  }
  function cl(t) {
    if (!t) return [];
    if (ae(t)) {
      for (var e = [], r = 0; r < t.length; r++) e.push(cl(t[r]));
      return e;
    }
    var n = [];
    return t.traverse(function(i) {
      i instanceof st && !i.disableMorphing && !i.invisible && !i.ignore && n.push(i);
    }), n;
  }
  var nU = 1e4, qme = 0, vR = 1, gR = 2, Xme = _t();
  function jme(t, e) {
    for (var r = t.dimensions, n = 0; n < r.length; n++) {
      var i = t.getDimensionInfo(r[n]);
      if (i && i.otherDims[e] === 0) return r[n];
    }
  }
  function Kme(t, e, r) {
    var n = t.getDimensionInfo(r), i = n && n.ordinalMeta;
    if (n) {
      var a = t.get(n.name, e);
      return i && i.categories[a] || a + "";
    }
  }
  function mR(t, e, r, n) {
    var i = n ? "itemChildGroupId" : "itemGroupId", a = jme(t, i);
    if (a) {
      var o = Kme(t, e, a);
      return o;
    }
    var s = t.getRawDataItem(e), l = n ? "childGroupId" : "groupId";
    if (s && s[l]) return s[l] + "";
    if (!n) return r || t.getId(e);
  }
  function yR(t) {
    var e = [];
    return $(t, function(r) {
      var n = r.data, i = r.dataGroupId;
      if (!(n.count() > nU)) for (var a = n.getIndices(), o = 0; o < a.length; o++) e.push({
        data: n,
        groupId: mR(n, o, i, false),
        childGroupId: mR(n, o, i, true),
        divide: r.divide,
        dataIndex: o
      });
    }), e;
  }
  function pb(t, e, r) {
    t.traverse(function(n) {
      n instanceof st && er(n, {
        style: {
          opacity: 0
        }
      }, e, {
        dataIndex: r,
        isFrom: true
      });
    });
  }
  function vb(t) {
    if (t.parent) {
      var e = t.getComputedTransform();
      t.setLocalTransform(e), t.parent.remove(t);
    }
  }
  function Bu(t) {
    t.stopAnimation(), t.isGroup && t.traverse(function(e) {
      e.stopAnimation();
    });
  }
  function Zme(t, e, r) {
    var n = Gc("update", r, e);
    n && t.traverse(function(i) {
      if (i instanceof bi) {
        var a = HJ(i);
        a && i.animateFrom({
          style: a
        }, n);
      }
    });
  }
  function Qme(t, e) {
    var r = t.length;
    if (r !== e.length) return false;
    for (var n = 0; n < r; n++) {
      var i = t[n], a = e[n];
      if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex)) return false;
    }
    return true;
  }
  function iU(t, e, r) {
    var n = yR(t), i = yR(e);
    function a(_, b, w, x, T) {
      (w || _) && b.animateFrom({
        style: w && w !== _ ? te(te({}, w.style), _.style) : _.style
      }, T);
    }
    var o = false, s = qme, l = Ce(), u = Ce();
    n.forEach(function(_) {
      _.groupId && l.set(_.groupId, true), _.childGroupId && u.set(_.childGroupId, true);
    });
    for (var c = 0; c < i.length; c++) {
      var h = i[c].groupId;
      if (u.get(h)) {
        s = vR;
        break;
      }
      var f = i[c].childGroupId;
      if (f && l.get(f)) {
        s = gR;
        break;
      }
    }
    function d(_, b) {
      return function(w) {
        var x = w.data, T = w.dataIndex;
        return b ? x.getId(T) : _ ? s === vR ? w.childGroupId : w.groupId : s === gR ? w.childGroupId : w.groupId;
      };
    }
    var p = Qme(n, i), v = {};
    if (!p) for (var c = 0; c < i.length; c++) {
      var g = i[c], m = g.data.getItemGraphicEl(g.dataIndex);
      m && (v[m.id] = true);
    }
    function y(_, b) {
      var w = n[b], x = i[_], T = x.data.hostModel, A = w.data.getItemGraphicEl(w.dataIndex), I = x.data.getItemGraphicEl(x.dataIndex);
      if (A === I) {
        I && Zme(I, x.dataIndex, T);
        return;
      }
      A && v[A.id] || I && (Bu(I), A ? (Bu(A), vb(A), o = true, db(cl(A), cl(I), x.divide, T, _, a)) : pb(I, T, _));
    }
    new vo(n, i, d(true, p), d(false, p), null, "multiple").update(y).updateManyToOne(function(_, b) {
      var w = i[_], x = w.data, T = x.hostModel, A = x.getItemGraphicEl(w.dataIndex), I = Dt(oe(b, function(M) {
        return n[M].data.getItemGraphicEl(n[M].dataIndex);
      }), function(M) {
        return M && M !== A && !v[M.id];
      });
      A && (Bu(A), I.length ? ($(I, function(M) {
        Bu(M), vb(M);
      }), o = true, db(cl(I), cl(A), w.divide, T, _, a)) : pb(A, T, w.dataIndex));
    }).updateOneToMany(function(_, b) {
      var w = n[b], x = w.data.getItemGraphicEl(w.dataIndex);
      if (!(x && v[x.id])) {
        var T = Dt(oe(_, function(I) {
          return i[I].data.getItemGraphicEl(i[I].dataIndex);
        }), function(I) {
          return I && I !== x;
        }), A = i[_[0]].data.hostModel;
        T.length && ($(T, function(I) {
          return Bu(I);
        }), x ? (Bu(x), vb(x), o = true, db(cl(x), cl(T), w.divide, A, _[0], a)) : $(T, function(I) {
          return pb(I, A, _[0]);
        }));
      }
    }).updateManyToMany(function(_, b) {
      new vo(b, _, function(w) {
        return n[w].data.getId(n[w].dataIndex);
      }, function(w) {
        return i[w].data.getId(i[w].dataIndex);
      }).update(function(w, x) {
        y(_[w], b[x]);
      }).execute();
    }).execute(), o && $(e, function(_) {
      var b = _.data, w = b.hostModel, x = w && r.getViewOfSeriesModel(w), T = Gc("update", w, 0);
      x && w.isAnimationEnabled() && T && T.duration > 0 && x.group.traverse(function(A) {
        A instanceof st && !A.animators.length && A.animateFrom({
          style: {
            opacity: 0
          }
        }, T);
      });
    });
  }
  function _R(t) {
    var e = t.getModel("universalTransition").get("seriesKey");
    return e || t.id;
  }
  function bR(t) {
    return ae(t) ? t.sort().join(",") : t;
  }
  function Xo(t) {
    if (t.hostModel) return t.hostModel.getModel("universalTransition").get("divideShape");
  }
  function Jme(t, e) {
    var r = Ce(), n = Ce(), i = Ce();
    return $(t.oldSeries, function(a, o) {
      var s = t.oldDataGroupIds[o], l = t.oldData[o], u = _R(a), c = bR(u);
      n.set(c, {
        dataGroupId: s,
        data: l
      }), ae(u) && $(u, function(h) {
        i.set(h, {
          key: c,
          dataGroupId: s,
          data: l
        });
      });
    }), $(e.updatedSeries, function(a) {
      if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
        var o = a.get("dataGroupId"), s = a.getData(), l = _R(a), u = bR(l), c = n.get(u);
        if (c) r.set(u, {
          oldSeries: [
            {
              dataGroupId: c.dataGroupId,
              divide: Xo(c.data),
              data: c.data
            }
          ],
          newSeries: [
            {
              dataGroupId: o,
              divide: Xo(s),
              data: s
            }
          ]
        });
        else if (ae(l)) {
          var h = [];
          $(l, function(p) {
            var v = n.get(p);
            v.data && h.push({
              dataGroupId: v.dataGroupId,
              divide: Xo(v.data),
              data: v.data
            });
          }), h.length && r.set(u, {
            oldSeries: h,
            newSeries: [
              {
                dataGroupId: o,
                data: s,
                divide: Xo(s)
              }
            ]
          });
        } else {
          var f = i.get(l);
          if (f) {
            var d = r.get(f.key);
            d || (d = {
              oldSeries: [
                {
                  dataGroupId: f.dataGroupId,
                  data: f.data,
                  divide: Xo(f.data)
                }
              ],
              newSeries: []
            }, r.set(f.key, d)), d.newSeries.push({
              dataGroupId: o,
              data: s,
              divide: Xo(s)
            });
          }
        }
      }
    }), r;
  }
  function xR(t, e) {
    for (var r = 0; r < t.length; r++) {
      var n = e.seriesIndex != null && e.seriesIndex === t[r].seriesIndex || e.seriesId != null && e.seriesId === t[r].id;
      if (n) return r;
    }
  }
  function eye(t, e, r, n) {
    var i = [], a = [];
    $(Ot(t.from), function(o) {
      var s = xR(e.oldSeries, o);
      s >= 0 && i.push({
        dataGroupId: e.oldDataGroupIds[s],
        data: e.oldData[s],
        divide: Xo(e.oldData[s]),
        groupIdDim: o.dimension
      });
    }), $(Ot(t.to), function(o) {
      var s = xR(r.updatedSeries, o);
      if (s >= 0) {
        var l = r.updatedSeries[s].getData();
        a.push({
          dataGroupId: e.oldDataGroupIds[s],
          data: l,
          divide: Xo(l),
          groupIdDim: o.dimension
        });
      }
    }), i.length > 0 && a.length > 0 && iU(i, a, n);
  }
  function tye(t) {
    t.registerUpdateLifecycle("series:beforeupdate", function(e, r, n) {
      $(Ot(n.seriesTransition), function(i) {
        $(Ot(i.to), function(a) {
          for (var o = n.updatedSeries, s = 0; s < o.length; s++) (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][lg] = true);
        });
      });
    }), t.registerUpdateLifecycle("series:transition", function(e, r, n) {
      var i = Xme(r);
      if (i.oldSeries && n.updatedSeries && n.optionChanged) {
        var a = n.seriesTransition;
        if (a) $(Ot(a), function(d) {
          eye(d, i, n, r);
        });
        else {
          var o = Jme(i, n);
          $(o.keys(), function(d) {
            var p = o.get(d);
            iU(p.oldSeries, p.newSeries, r);
          });
        }
        $(n.updatedSeries, function(d) {
          d[lg] && (d[lg] = false);
        });
      }
      for (var s = e.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], h = 0; h < s.length; h++) {
        var f = s[h].getData();
        f.count() < nU && (l.push(s[h]), u.push(s[h].get("dataGroupId")), c.push(f));
      }
    });
  }
  rt([
    hae
  ]);
  rt([
    oae
  ]);
  rt([
    kae,
    Yae,
    roe,
    Roe,
    Yoe,
    Pse,
    ole,
    Wle,
    hue,
    mue,
    Aue,
    bce,
    Uce,
    rhe,
    yhe,
    whe,
    Phe,
    zhe,
    Khe,
    rfe,
    ffe,
    jfe
  ]);
  rt(pde);
  rt(Fde);
  rt(rW);
  rt(Jde);
  rt(VW);
  rt(npe);
  rt(fpe);
  rt(Jpe);
  rt(yve);
  rt(jd);
  rt(Rve);
  rt(Bve);
  rt(Xve);
  rt(tge);
  rt(sge);
  rt(dge);
  rt(Sge);
  rt(Vge);
  rt(HH);
  rt(UH);
  rt(sme);
  rt(KH);
  rt(ZH);
  rt(fme);
  rt(Cme);
  rt(Mme);
  rt(tye);
  rt(Aie);
  const rye = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var pv = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };
  const nye = ({ size: t, strokeWidth: e = 2, absoluteStrokeWidth: r, color: n, iconNode: i, name: a, class: o, ...s }, { slots: l }) => Hi("svg", {
    ...pv,
    width: t || pv.width,
    height: t || pv.height,
    stroke: n || pv.stroke,
    "stroke-width": r ? Number(e) * 24 / Number(t) : e,
    class: [
      "lucide",
      `lucide-${rye(a ?? "icon")}`
    ],
    ...s
  }, [
    ...i.map((u) => Hi(...u)),
    ...l.default ? [
      l.default()
    ] : []
  ]);
  const Z2 = (t, e) => (r, { slots: n }) => Hi(nye, {
    ...r,
    iconNode: e,
    name: t
  }, n);
  const iye = Z2("LoaderIcon", [
    [
      "path",
      {
        d: "M12 2v4",
        key: "3427ic"
      }
    ],
    [
      "path",
      {
        d: "m16.2 7.8 2.9-2.9",
        key: "r700ao"
      }
    ],
    [
      "path",
      {
        d: "M18 12h4",
        key: "wj9ykh"
      }
    ],
    [
      "path",
      {
        d: "m16.2 16.2 2.9 2.9",
        key: "1bxg5t"
      }
    ],
    [
      "path",
      {
        d: "M12 18v4",
        key: "jadmvz"
      }
    ],
    [
      "path",
      {
        d: "m4.9 19.1 2.9-2.9",
        key: "bwix9q"
      }
    ],
    [
      "path",
      {
        d: "M2 12h4",
        key: "j09sii"
      }
    ],
    [
      "path",
      {
        d: "m4.9 4.9 2.9 2.9",
        key: "giyufr"
      }
    ]
  ]);
  const aye = Z2("UploadIcon", [
    [
      "path",
      {
        d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
        key: "ih7n3h"
      }
    ],
    [
      "polyline",
      {
        points: "17 8 12 3 7 8",
        key: "t8dd8p"
      }
    ],
    [
      "line",
      {
        x1: "12",
        x2: "12",
        y1: "3",
        y2: "15",
        key: "widbto"
      }
    ]
  ]);
  const oye = Z2("XIcon", [
    [
      "path",
      {
        d: "M18 6 6 18",
        key: "1bl5f8"
      }
    ],
    [
      "path",
      {
        d: "m6 6 12 12",
        key: "d8bk6v"
      }
    ]
  ]);
  Gj();
  var Q2 = Object.defineProperty, sye = Object.getOwnPropertyDescriptor, lye = Object.getOwnPropertyNames, uye = Object.prototype.hasOwnProperty, cye = ((t) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(t, {
    get: (e, r) => (typeof require < "u" ? require : e)[r]
  }) : t)(function(t) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + t + '" is not supported');
  }), ge = (t, e) => () => (t && (e = t(t = 0)), e), Kd = (t, e) => {
    for (var r in e) Q2(t, r, {
      get: e[r],
      enumerable: true
    });
  }, hye = (t, e, r, n) => {
    if (e && typeof e == "object" || typeof e == "function") for (let i of lye(e)) !uye.call(t, i) && i !== r && Q2(t, i, {
      get: () => e[i],
      enumerable: !(n = sye(e, i)) || n.enumerable
    });
    return t;
  }, vm = (t) => hye(Q2({}, "__esModule", {
    value: true
  }), t), $h, Bo, oc, wR, aU, oU = ge(() => {
    $h = /* @__PURE__ */ new Map(), Bo = [], oc = (t, e, r) => {
      if (e && typeof e.init == "function" && typeof e.createInferenceSessionHandler == "function") {
        let n = $h.get(t);
        if (n === void 0) $h.set(t, {
          backend: e,
          priority: r
        });
        else {
          if (n.priority > r) return;
          if (n.priority === r && n.backend !== e) throw new Error(`cannot register backend "${t}" using priority ${r}`);
        }
        if (r >= 0) {
          let i = Bo.indexOf(t);
          i !== -1 && Bo.splice(i, 1);
          for (let a = 0; a < Bo.length; a++) if ($h.get(Bo[a]).priority <= r) {
            Bo.splice(a, 0, t);
            return;
          }
          Bo.push(t);
        }
        return;
      }
      throw new TypeError("not a valid backend");
    }, wR = async (t) => {
      let e = $h.get(t);
      if (!e) return "backend not found.";
      if (e.initialized) return e.backend;
      if (e.aborted) return e.error;
      {
        let r = !!e.initPromise;
        try {
          return r || (e.initPromise = e.backend.init(t)), await e.initPromise, e.initialized = true, e.backend;
        } catch (n) {
          return r || (e.error = `${n}`, e.aborted = true), e.error;
        } finally {
          delete e.initPromise;
        }
      }
    }, aU = async (t) => {
      let e = t.executionProviders || [], r = e.map((l) => typeof l == "string" ? l : l.name), n = r.length === 0 ? Bo : r, i, a = [], o = /* @__PURE__ */ new Set();
      for (let l of n) {
        let u = await wR(l);
        typeof u == "string" ? a.push({
          name: l,
          err: u
        }) : (i || (i = u), i === u && o.add(l));
      }
      if (!i) throw new Error(`no available backend found. ERR: ${a.map((l) => `[${l.name}] ${l.err}`).join(", ")}`);
      for (let { name: l, err: u } of a) r.includes(l) && console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);
      let s = e.filter((l) => o.has(typeof l == "string" ? l : l.name));
      return [
        i,
        new Proxy(t, {
          get: (l, u) => u === "executionProviders" ? s : Reflect.get(l, u)
        })
      ];
    };
  }), fye = ge(() => {
    oU();
  }), sU, dye = ge(() => {
    sU = "1.21.0";
  }), gb, ui, lU = ge(() => {
    dye(), gb = "warning", ui = {
      wasm: {},
      webgl: {},
      webgpu: {},
      versions: {
        common: sU
      },
      set logLevel(t) {
        if (t !== void 0) {
          if (typeof t != "string" || [
            "verbose",
            "info",
            "warning",
            "error",
            "fatal"
          ].indexOf(t) === -1) throw new Error(`Unsupported logging level: ${t}`);
          gb = t;
        }
      },
      get logLevel() {
        return gb;
      }
    }, Object.defineProperty(ui, "logLevel", {
      enumerable: true
    });
  }), rr, pye = ge(() => {
    lU(), rr = ui;
  }), uU, cU, vye = ge(() => {
    uU = (t, e) => {
      let r = typeof document < "u" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
      r.width = t.dims[3], r.height = t.dims[2];
      let n = r.getContext("2d");
      if (n != null) {
        let i, a;
        (e == null ? void 0 : e.tensorLayout) !== void 0 && e.tensorLayout === "NHWC" ? (i = t.dims[2], a = t.dims[3]) : (i = t.dims[3], a = t.dims[2]);
        let o = (e == null ? void 0 : e.format) !== void 0 ? e.format : "RGB", s = e == null ? void 0 : e.norm, l, u;
        s === void 0 || s.mean === void 0 ? l = [
          255,
          255,
          255,
          255
        ] : typeof s.mean == "number" ? l = [
          s.mean,
          s.mean,
          s.mean,
          s.mean
        ] : (l = [
          s.mean[0],
          s.mean[1],
          s.mean[2],
          0
        ], s.mean[3] !== void 0 && (l[3] = s.mean[3])), s === void 0 || s.bias === void 0 ? u = [
          0,
          0,
          0,
          0
        ] : typeof s.bias == "number" ? u = [
          s.bias,
          s.bias,
          s.bias,
          s.bias
        ] : (u = [
          s.bias[0],
          s.bias[1],
          s.bias[2],
          0
        ], s.bias[3] !== void 0 && (u[3] = s.bias[3]));
        let c = a * i, h = 0, f = c, d = c * 2, p = -1;
        o === "RGBA" ? (h = 0, f = c, d = c * 2, p = c * 3) : o === "RGB" ? (h = 0, f = c, d = c * 2) : o === "RBG" && (h = 0, d = c, f = c * 2);
        for (let v = 0; v < a; v++) for (let g = 0; g < i; g++) {
          let m = (t.data[h++] - u[0]) * l[0], y = (t.data[f++] - u[1]) * l[1], _ = (t.data[d++] - u[2]) * l[2], b = p === -1 ? 255 : (t.data[p++] - u[3]) * l[3];
          n.fillStyle = "rgba(" + m + "," + y + "," + _ + "," + b + ")", n.fillRect(g, v, 1, 1);
        }
        if ("toDataURL" in r) return r.toDataURL();
        throw new Error("toDataURL is not supported");
      } else throw new Error("Can not access image data");
    }, cU = (t, e) => {
      let r = typeof document < "u" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d"), n;
      if (r != null) {
        let i, a, o;
        (e == null ? void 0 : e.tensorLayout) !== void 0 && e.tensorLayout === "NHWC" ? (i = t.dims[2], a = t.dims[1], o = t.dims[3]) : (i = t.dims[3], a = t.dims[2], o = t.dims[1]);
        let s = e !== void 0 && e.format !== void 0 ? e.format : "RGB", l = e == null ? void 0 : e.norm, u, c;
        l === void 0 || l.mean === void 0 ? u = [
          255,
          255,
          255,
          255
        ] : typeof l.mean == "number" ? u = [
          l.mean,
          l.mean,
          l.mean,
          l.mean
        ] : (u = [
          l.mean[0],
          l.mean[1],
          l.mean[2],
          255
        ], l.mean[3] !== void 0 && (u[3] = l.mean[3])), l === void 0 || l.bias === void 0 ? c = [
          0,
          0,
          0,
          0
        ] : typeof l.bias == "number" ? c = [
          l.bias,
          l.bias,
          l.bias,
          l.bias
        ] : (c = [
          l.bias[0],
          l.bias[1],
          l.bias[2],
          0
        ], l.bias[3] !== void 0 && (c[3] = l.bias[3]));
        let h = a * i;
        if (e !== void 0 && (e.format !== void 0 && o === 4 && e.format !== "RGBA" || o === 3 && e.format !== "RGB" && e.format !== "BGR")) throw new Error("Tensor format doesn't match input tensor dims");
        let f = 4, d = 0, p = 1, v = 2, g = 3, m = 0, y = h, _ = h * 2, b = -1;
        s === "RGBA" ? (m = 0, y = h, _ = h * 2, b = h * 3) : s === "RGB" ? (m = 0, y = h, _ = h * 2) : s === "RBG" && (m = 0, _ = h, y = h * 2), n = r.createImageData(i, a);
        for (let w = 0; w < a * i; d += f, p += f, v += f, g += f, w++) n.data[d] = (t.data[m++] - c[0]) * u[0], n.data[p] = (t.data[y++] - c[1]) * u[1], n.data[v] = (t.data[_++] - c[2]) * u[2], n.data[g] = b === -1 ? 255 : (t.data[b++] - c[3]) * u[3];
      } else throw new Error("Can not access image data");
      return n;
    };
  }), vv, hU, fU, dU, pU, vU, gye = ge(() => {
    J2(), vv = (t, e) => {
      if (t === void 0) throw new Error("Image buffer must be defined");
      if (e.height === void 0 || e.width === void 0) throw new Error("Image height and width must be defined");
      if (e.tensorLayout === "NHWC") throw new Error("NHWC Tensor layout is not supported yet");
      let { height: r, width: n } = e, i = e.norm ?? {
        mean: 255,
        bias: 0
      }, a, o;
      typeof i.mean == "number" ? a = [
        i.mean,
        i.mean,
        i.mean,
        i.mean
      ] : a = [
        i.mean[0],
        i.mean[1],
        i.mean[2],
        i.mean[3] ?? 255
      ], typeof i.bias == "number" ? o = [
        i.bias,
        i.bias,
        i.bias,
        i.bias
      ] : o = [
        i.bias[0],
        i.bias[1],
        i.bias[2],
        i.bias[3] ?? 0
      ];
      let s = e.format !== void 0 ? e.format : "RGBA", l = e.tensorFormat !== void 0 && e.tensorFormat !== void 0 ? e.tensorFormat : "RGB", u = r * n, c = l === "RGBA" ? new Float32Array(u * 4) : new Float32Array(u * 3), h = 4, f = 0, d = 1, p = 2, v = 3, g = 0, m = u, y = u * 2, _ = -1;
      s === "RGB" && (h = 3, f = 0, d = 1, p = 2, v = -1), l === "RGBA" ? _ = u * 3 : l === "RBG" ? (g = 0, y = u, m = u * 2) : l === "BGR" && (y = 0, m = u, g = u * 2);
      for (let b = 0; b < u; b++, f += h, p += h, d += h, v += h) c[g++] = (t[f] + o[0]) / a[0], c[m++] = (t[d] + o[1]) / a[1], c[y++] = (t[p] + o[2]) / a[2], _ !== -1 && v !== -1 && (c[_++] = (t[v] + o[3]) / a[3]);
      return l === "RGBA" ? new Gn("float32", c, [
        1,
        4,
        r,
        n
      ]) : new Gn("float32", c, [
        1,
        3,
        r,
        n
      ]);
    }, hU = async (t, e) => {
      let r = typeof HTMLImageElement < "u" && t instanceof HTMLImageElement, n = typeof ImageData < "u" && t instanceof ImageData, i = typeof ImageBitmap < "u" && t instanceof ImageBitmap, a = typeof t == "string", o, s = e ?? {}, l = () => {
        if (typeof document < "u") return document.createElement("canvas");
        if (typeof OffscreenCanvas < "u") return new OffscreenCanvas(1, 1);
        throw new Error("Canvas is not supported");
      }, u = (c) => typeof HTMLCanvasElement < "u" && c instanceof HTMLCanvasElement || c instanceof OffscreenCanvas ? c.getContext("2d") : null;
      if (r) {
        let c = l();
        c.width = t.width, c.height = t.height;
        let h = u(c);
        if (h != null) {
          let f = t.height, d = t.width;
          if (e !== void 0 && e.resizedHeight !== void 0 && e.resizedWidth !== void 0 && (f = e.resizedHeight, d = e.resizedWidth), e !== void 0) {
            if (s = e, e.tensorFormat !== void 0) throw new Error("Image input config format must be RGBA for HTMLImageElement");
            s.tensorFormat = "RGBA", s.height = f, s.width = d;
          } else s.tensorFormat = "RGBA", s.height = f, s.width = d;
          h.drawImage(t, 0, 0), o = h.getImageData(0, 0, d, f).data;
        } else throw new Error("Can not access image data");
      } else if (n) {
        let c, h;
        if (e !== void 0 && e.resizedWidth !== void 0 && e.resizedHeight !== void 0 ? (c = e.resizedHeight, h = e.resizedWidth) : (c = t.height, h = t.width), e !== void 0 && (s = e), s.format = "RGBA", s.height = c, s.width = h, e !== void 0) {
          let f = l();
          f.width = h, f.height = c;
          let d = u(f);
          if (d != null) d.putImageData(t, 0, 0), o = d.getImageData(0, 0, h, c).data;
          else throw new Error("Can not access image data");
        } else o = t.data;
      } else if (i) {
        if (e === void 0) throw new Error("Please provide image config with format for Imagebitmap");
        let c = l();
        c.width = t.width, c.height = t.height;
        let h = u(c);
        if (h != null) {
          let f = t.height, d = t.width;
          return h.drawImage(t, 0, 0, d, f), o = h.getImageData(0, 0, d, f).data, s.height = f, s.width = d, vv(o, s);
        } else throw new Error("Can not access image data");
      } else {
        if (a) return new Promise((c, h) => {
          let f = l(), d = u(f);
          if (!t || !d) return h();
          let p = new Image();
          p.crossOrigin = "Anonymous", p.src = t, p.onload = () => {
            f.width = p.width, f.height = p.height, d.drawImage(p, 0, 0, f.width, f.height);
            let v = d.getImageData(0, 0, f.width, f.height);
            s.height = f.height, s.width = f.width, c(vv(v.data, s));
          };
        });
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
      if (o !== void 0) return vv(o, s);
      throw new Error("Input data provided is not supported - aborted tensor creation");
    }, fU = (t, e) => {
      let { width: r, height: n, download: i, dispose: a } = e, o = [
        1,
        n,
        r,
        4
      ];
      return new Gn({
        location: "texture",
        type: "float32",
        texture: t,
        dims: o,
        download: i,
        dispose: a
      });
    }, dU = (t, e) => {
      let { dataType: r, dims: n, download: i, dispose: a } = e;
      return new Gn({
        location: "gpu-buffer",
        type: r ?? "float32",
        gpuBuffer: t,
        dims: n,
        download: i,
        dispose: a
      });
    }, pU = (t, e) => {
      let { dataType: r, dims: n, download: i, dispose: a } = e;
      return new Gn({
        location: "ml-tensor",
        type: r ?? "float32",
        mlTensor: t,
        dims: n,
        download: i,
        dispose: a
      });
    }, vU = (t, e, r) => new Gn({
      location: "cpu-pinned",
      type: t,
      data: e,
      dims: r ?? [
        e.length
      ]
    });
  }), _l, uf, mb, gU, mye = ge(() => {
    _l = /* @__PURE__ */ new Map([
      [
        "float32",
        Float32Array
      ],
      [
        "uint8",
        Uint8Array
      ],
      [
        "int8",
        Int8Array
      ],
      [
        "uint16",
        Uint16Array
      ],
      [
        "int16",
        Int16Array
      ],
      [
        "int32",
        Int32Array
      ],
      [
        "bool",
        Uint8Array
      ],
      [
        "float64",
        Float64Array
      ],
      [
        "uint32",
        Uint32Array
      ],
      [
        "int4",
        Uint8Array
      ],
      [
        "uint4",
        Uint8Array
      ]
    ]), uf = /* @__PURE__ */ new Map([
      [
        Float32Array,
        "float32"
      ],
      [
        Uint8Array,
        "uint8"
      ],
      [
        Int8Array,
        "int8"
      ],
      [
        Uint16Array,
        "uint16"
      ],
      [
        Int16Array,
        "int16"
      ],
      [
        Int32Array,
        "int32"
      ],
      [
        Float64Array,
        "float64"
      ],
      [
        Uint32Array,
        "uint32"
      ]
    ]), mb = false, gU = () => {
      if (!mb) {
        mb = true;
        let t = typeof BigInt64Array < "u" && BigInt64Array.from, e = typeof BigUint64Array < "u" && BigUint64Array.from, r = globalThis.Float16Array, n = typeof r < "u" && r.from;
        t && (_l.set("int64", BigInt64Array), uf.set(BigInt64Array, "int64")), e && (_l.set("uint64", BigUint64Array), uf.set(BigUint64Array, "uint64")), n ? (_l.set("float16", r), uf.set(r, "float16")) : _l.set("float16", Uint16Array);
      }
    };
  }), mU, yU, yye = ge(() => {
    J2(), mU = (t) => {
      let e = 1;
      for (let r = 0; r < t.length; r++) {
        let n = t[r];
        if (typeof n != "number" || !Number.isSafeInteger(n)) throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);
        if (n < 0) throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);
        e *= n;
      }
      return e;
    }, yU = (t, e) => {
      switch (t.location) {
        case "cpu":
          return new Gn(t.type, t.data, e);
        case "cpu-pinned":
          return new Gn({
            location: "cpu-pinned",
            data: t.data,
            type: t.type,
            dims: e
          });
        case "texture":
          return new Gn({
            location: "texture",
            texture: t.texture,
            type: t.type,
            dims: e
          });
        case "gpu-buffer":
          return new Gn({
            location: "gpu-buffer",
            gpuBuffer: t.gpuBuffer,
            type: t.type,
            dims: e
          });
        case "ml-tensor":
          return new Gn({
            location: "ml-tensor",
            mlTensor: t.mlTensor,
            type: t.type,
            dims: e
          });
        default:
          throw new Error(`tensorReshape: tensor location ${t.location} is not supported`);
      }
    };
  }), Gn, J2 = ge(() => {
    vye(), gye(), mye(), yye(), Gn = class {
      constructor(t, e, r) {
        gU();
        let n, i;
        if (typeof t == "object" && "location" in t) switch (this.dataLocation = t.location, n = t.type, i = t.dims, t.location) {
          case "cpu-pinned": {
            let o = _l.get(n);
            if (!o) throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);
            if (!(t.data instanceof o)) throw new TypeError(`buffer should be of type ${o.name}`);
            this.cpuData = t.data;
            break;
          }
          case "texture": {
            if (n !== "float32") throw new TypeError(`unsupported type "${n}" to create tensor from texture`);
            this.gpuTextureData = t.texture, this.downloader = t.download, this.disposer = t.dispose;
            break;
          }
          case "gpu-buffer": {
            if (n !== "float32" && n !== "float16" && n !== "int32" && n !== "int64" && n !== "uint32" && n !== "uint8" && n !== "bool" && n !== "uint4" && n !== "int4") throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);
            this.gpuBufferData = t.gpuBuffer, this.downloader = t.download, this.disposer = t.dispose;
            break;
          }
          case "ml-tensor": {
            if (n !== "float32" && n !== "float16" && n !== "int32" && n !== "int64" && n !== "uint32" && n !== "uint64" && n !== "int8" && n !== "uint8" && n !== "bool" && n !== "uint4" && n !== "int4") throw new TypeError(`unsupported type "${n}" to create tensor from MLTensor`);
            this.mlTensorData = t.mlTensor, this.downloader = t.download, this.disposer = t.dispose;
            break;
          }
          default:
            throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
        }
        else {
          let o, s;
          if (typeof t == "string") if (n = t, s = r, t === "string") {
            if (!Array.isArray(e)) throw new TypeError("A string tensor's data must be a string array.");
            o = e;
          } else {
            let l = _l.get(t);
            if (l === void 0) throw new TypeError(`Unsupported tensor type: ${t}.`);
            if (Array.isArray(e)) {
              if (t === "float16" && l === Uint16Array || t === "uint4" || t === "int4") throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${l.name} as data.`);
              t === "uint64" || t === "int64" ? o = l.from(e, BigInt) : o = l.from(e);
            } else if (e instanceof l) o = e;
            else if (e instanceof Uint8ClampedArray) if (t === "uint8") o = Uint8Array.from(e);
            else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");
            else if (t === "float16" && e instanceof Uint16Array && l !== Uint16Array) o = new globalThis.Float16Array(e.buffer, e.byteOffset, e.length);
            else throw new TypeError(`A ${n} tensor's data must be type of ${l}`);
          }
          else if (s = e, Array.isArray(t)) {
            if (t.length === 0) throw new TypeError("Tensor type cannot be inferred from an empty array.");
            let l = typeof t[0];
            if (l === "string") n = "string", o = t;
            else if (l === "boolean") n = "bool", o = Uint8Array.from(t);
            else throw new TypeError(`Invalid element type of data array: ${l}.`);
          } else if (t instanceof Uint8ClampedArray) n = "uint8", o = Uint8Array.from(t);
          else {
            let l = uf.get(t.constructor);
            if (l === void 0) throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);
            n = l, o = t;
          }
          if (s === void 0) s = [
            o.length
          ];
          else if (!Array.isArray(s)) throw new TypeError("A tensor's dims must be a number array");
          i = s, this.cpuData = o, this.dataLocation = "cpu";
        }
        let a = mU(i);
        if (this.cpuData && a !== this.cpuData.length && !((n === "uint4" || n === "int4") && Math.ceil(a / 2) === this.cpuData.length)) throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);
        this.type = n, this.dims = i, this.size = a;
      }
      static async fromImage(t, e) {
        return hU(t, e);
      }
      static fromTexture(t, e) {
        return fU(t, e);
      }
      static fromGpuBuffer(t, e) {
        return dU(t, e);
      }
      static fromMLTensor(t, e) {
        return pU(t, e);
      }
      static fromPinnedBuffer(t, e, r) {
        return vU(t, e, r);
      }
      toDataURL(t) {
        return uU(this, t);
      }
      toImageData(t) {
        return cU(this, t);
      }
      get data() {
        if (this.ensureValid(), !this.cpuData) throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
        return this.cpuData;
      }
      get location() {
        return this.dataLocation;
      }
      get texture() {
        if (this.ensureValid(), !this.gpuTextureData) throw new Error("The data is not stored as a WebGL texture.");
        return this.gpuTextureData;
      }
      get gpuBuffer() {
        if (this.ensureValid(), !this.gpuBufferData) throw new Error("The data is not stored as a WebGPU buffer.");
        return this.gpuBufferData;
      }
      get mlTensor() {
        if (this.ensureValid(), !this.mlTensorData) throw new Error("The data is not stored as a WebNN MLTensor.");
        return this.mlTensorData;
      }
      async getData(t) {
        switch (this.ensureValid(), this.dataLocation) {
          case "cpu":
          case "cpu-pinned":
            return this.data;
          case "texture":
          case "gpu-buffer":
          case "ml-tensor": {
            if (!this.downloader) throw new Error("The current tensor is not created with a specified data downloader.");
            if (this.isDownloading) throw new Error("The current tensor is being downloaded.");
            try {
              this.isDownloading = true;
              let e = await this.downloader();
              return this.downloader = void 0, this.dataLocation = "cpu", this.cpuData = e, t && this.disposer && (this.disposer(), this.disposer = void 0), e;
            } finally {
              this.isDownloading = false;
            }
          }
          default:
            throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
      }
      dispose() {
        if (this.isDownloading) throw new Error("The current tensor is being downloaded.");
        this.disposer && (this.disposer(), this.disposer = void 0), this.cpuData = void 0, this.gpuTextureData = void 0, this.gpuBufferData = void 0, this.mlTensorData = void 0, this.downloader = void 0, this.isDownloading = void 0, this.dataLocation = "none";
      }
      ensureValid() {
        if (this.dataLocation === "none") throw new Error("The tensor is disposed.");
      }
      reshape(t) {
        if (this.ensureValid(), this.downloader || this.disposer) throw new Error("Cannot reshape a tensor that owns GPU resource.");
        return yU(this, t);
      }
    };
  }), ba, _U = ge(() => {
    J2(), ba = Gn;
  }), gm, yb, Oa, qi, bU = ge(() => {
    lU(), gm = (t, e) => {
      (typeof ui.trace > "u" ? !ui.wasm.trace : !ui.trace) || console.timeStamp(`${t}::ORT::${e}`);
    }, yb = (t, e) => {
      var _a2;
      let r = ((_a2 = new Error().stack) == null ? void 0 : _a2.split(/\r\n|\r|\n/g)) || [], n = false;
      for (let i = 0; i < r.length; i++) {
        if (n && !r[i].includes("TRACE_FUNC")) {
          let a = `FUNC_${t}::${r[i].trim().split(" ")[1]}`;
          e && (a += `::${e}`), gm("CPU", a);
          return;
        }
        r[i].includes("TRACE_FUNC") && (n = true);
      }
    }, Oa = (t) => {
      (typeof ui.trace > "u" ? !ui.wasm.trace : !ui.trace) || yb("BEGIN", t);
    }, qi = (t) => {
      (typeof ui.trace > "u" ? !ui.wasm.trace : !ui.trace) || yb("END", t);
    };
  }), xU, _ye = ge(() => {
    oU(), _U(), bU(), xU = class wU {
      constructor(e) {
        this.handler = e;
      }
      async run(e, r, n) {
        Oa();
        let i = {}, a = {};
        if (typeof e != "object" || e === null || e instanceof ba || Array.isArray(e)) throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        let o = true;
        if (typeof r == "object") {
          if (r === null) throw new TypeError("Unexpected argument[1]: cannot be null.");
          if (r instanceof ba) throw new TypeError("'fetches' cannot be a Tensor");
          if (Array.isArray(r)) {
            if (r.length === 0) throw new TypeError("'fetches' cannot be an empty array.");
            o = false;
            for (let u of r) {
              if (typeof u != "string") throw new TypeError("'fetches' must be a string array or an object.");
              if (this.outputNames.indexOf(u) === -1) throw new RangeError(`'fetches' contains invalid output name: ${u}.`);
              i[u] = null;
            }
            if (typeof n == "object" && n !== null) a = n;
            else if (typeof n < "u") throw new TypeError("'options' must be an object.");
          } else {
            let u = false, c = Object.getOwnPropertyNames(r);
            for (let h of this.outputNames) if (c.indexOf(h) !== -1) {
              let f = r[h];
              (f === null || f instanceof ba) && (u = true, o = false, i[h] = f);
            }
            if (u) {
              if (typeof n == "object" && n !== null) a = n;
              else if (typeof n < "u") throw new TypeError("'options' must be an object.");
            } else a = r;
          }
        } else if (typeof r < "u") throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        for (let u of this.inputNames) if (typeof e[u] > "u") throw new Error(`input '${u}' is missing in 'feeds'.`);
        if (o) for (let u of this.outputNames) i[u] = null;
        let s = await this.handler.run(e, i, a), l = {};
        for (let u in s) if (Object.hasOwnProperty.call(s, u)) {
          let c = s[u];
          c instanceof ba ? l[u] = c : l[u] = new ba(c.type, c.data, c.dims);
        }
        return qi(), l;
      }
      async release() {
        return this.handler.dispose();
      }
      static async create(e, r, n, i) {
        Oa();
        let a, o = {};
        if (typeof e == "string") {
          if (a = e, typeof r == "object" && r !== null) o = r;
          else if (typeof r < "u") throw new TypeError("'options' must be an object.");
        } else if (e instanceof Uint8Array) {
          if (a = e, typeof r == "object" && r !== null) o = r;
          else if (typeof r < "u") throw new TypeError("'options' must be an object.");
        } else if (e instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer) {
          let c = e, h = 0, f = e.byteLength;
          if (typeof r == "object" && r !== null) o = r;
          else if (typeof r == "number") {
            if (h = r, !Number.isSafeInteger(h)) throw new RangeError("'byteOffset' must be an integer.");
            if (h < 0 || h >= c.byteLength) throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);
            if (f = e.byteLength - h, typeof n == "number") {
              if (f = n, !Number.isSafeInteger(f)) throw new RangeError("'byteLength' must be an integer.");
              if (f <= 0 || h + f > c.byteLength) throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength - h}].`);
              if (typeof i == "object" && i !== null) o = i;
              else if (typeof i < "u") throw new TypeError("'options' must be an object.");
            } else if (typeof n < "u") throw new TypeError("'byteLength' must be a number.");
          } else if (typeof r < "u") throw new TypeError("'options' must be an object.");
          a = new Uint8Array(c, h, f);
        } else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        let [s, l] = await aU(o), u = await s.createInferenceSessionHandler(a, l);
        return qi(), new wU(u);
      }
      startProfiling() {
        this.handler.startProfiling();
      }
      endProfiling() {
        this.handler.endProfiling();
      }
      get inputNames() {
        return this.handler.inputNames;
      }
      get outputNames() {
        return this.handler.outputNames;
      }
    };
  }), SU, bye = ge(() => {
    _ye(), SU = xU;
  }), xye = ge(() => {
  }), wye = ge(() => {
  }), Sye = ge(() => {
  }), Tye = ge(() => {
  }), Cye = {};
  Kd(Cye, {
    InferenceSession: () => SU,
    TRACE: () => gm,
    TRACE_FUNC_BEGIN: () => Oa,
    TRACE_FUNC_END: () => qi,
    Tensor: () => ba,
    env: () => rr,
    registerBackend: () => oc
  });
  var ea = ge(() => {
    fye(), pye(), bye(), _U(), xye(), wye(), bU(), Sye(), Tye();
  }), eC = ge(() => {
  }), TU = {};
  Kd(TU, {
    default: () => CU
  });
  var _b, bb, CU, Aye = ge(() => {
    var _a2;
    MY(), hu(), tC(), _b = "ort-wasm-proxy-worker", bb = ((_a2 = globalThis.self) == null ? void 0 : _a2.name) === _b, bb && (self.onmessage = (t) => {
      let { type: e, in: r } = t.data;
      try {
        switch (e) {
          case "init-wasm":
            rC(r.wasm).then(() => {
              bC(r).then(() => {
                postMessage({
                  type: e
                });
              }, (n) => {
                postMessage({
                  type: e,
                  err: n
                });
              });
            }, (n) => {
              postMessage({
                type: e,
                err: n
              });
            });
            break;
          case "init-ep": {
            let { epName: n, env: i } = r;
            xC(i, n).then(() => {
              postMessage({
                type: e
              });
            }, (a) => {
              postMessage({
                type: e,
                err: a
              });
            });
            break;
          }
          case "copy-from": {
            let { buffer: n } = r, i = wm(n);
            postMessage({
              type: e,
              out: i
            });
            break;
          }
          case "create": {
            let { model: n, options: i } = r;
            wC(n, i).then((a) => {
              postMessage({
                type: e,
                out: a
              });
            }, (a) => {
              postMessage({
                type: e,
                err: a
              });
            });
            break;
          }
          case "release":
            SC(r), postMessage({
              type: e
            });
            break;
          case "run": {
            let { sessionId: n, inputIndices: i, inputs: a, outputIndices: o, options: s } = r;
            TC(n, i, a, o, new Array(o.length).fill(null), s).then((l) => {
              l.some((u) => u[3] !== "cpu") ? postMessage({
                type: e,
                err: "Proxy does not support non-cpu tensor location."
              }) : postMessage({
                type: e,
                out: l
              }, AC([
                ...a,
                ...l
              ]));
            }, (l) => {
              postMessage({
                type: e,
                err: l
              });
            });
            break;
          }
          case "end-profiling":
            CC(r), postMessage({
              type: e
            });
            break;
          default:
        }
      } catch (n) {
        postMessage({
          type: e,
          err: n
        });
      }
    }), CU = bb ? null : (t) => new Worker(t ?? Fn, {
      type: "module",
      name: _b
    });
  }), AU = {};
  Kd(AU, {
    default: () => IU
  });
  var xb, wb, IU, SR, Iye = ge(() => {
    var _a2, _b2;
    wb = (xb = import.meta.url, async function(t = {}) {
      var _a3;
      var e, r, n = t, i = new Promise((S, C) => {
        e = S, r = C;
      }), a = typeof window == "object", o = typeof WorkerGlobalScope < "u", s = o && ((_a3 = self.name) == null ? void 0 : _a3.startsWith("em-pthread"));
      n.mountExternalData = (S, C) => {
        S.startsWith("./") && (S = S.substring(2)), (n.Bd || (n.Bd = /* @__PURE__ */ new Map())).set(S, C);
      }, n.unmountExternalData = () => {
        delete n.Bd;
      };
      var l = globalThis.SharedArrayBuffer ?? new WebAssembly.Memory({
        initial: 0,
        maximum: 0,
        shared: true
      }).buffer.constructor;
      let u = () => {
        let S = (D, P, R) => (...W) => {
          let q = ia, J = P == null ? void 0 : P();
          W = D(...W);
          let ie = P == null ? void 0 : P();
          return J !== ie && (D = ie, R(J), P = R = null), ia != q ? new Promise((de, Ae) => {
            zy = {
              resolve: de,
              reject: Ae
            };
          }) : W;
        }, C = (D) => async (...P) => {
          var _a4;
          try {
            if (n.Cd) throw Error("Session already started");
            let R = n.Cd = {
              be: P[0],
              errors: []
            }, W = await D(...P);
            if (n.Cd !== R) throw Error("Session mismatch");
            (_a4 = n.Dd) == null ? void 0 : _a4.flush();
            let q = R.errors;
            if (0 < q.length) {
              let J = await Promise.all(q);
              if (J = J.filter((ie) => ie), 0 < J.length) throw Error(J.join(`
`));
            }
            return W;
          } finally {
            n.Cd = null;
          }
        };
        n._OrtCreateSession = S(n._OrtCreateSession, () => n._OrtCreateSession, (D) => n._OrtCreateSession = D), n._OrtRun = C(S(n._OrtRun, () => n._OrtRun, (D) => n._OrtRun = D)), n._OrtRunWithBinding = C(S(n._OrtRunWithBinding, () => n._OrtRunWithBinding, (D) => n._OrtRunWithBinding = D)), n._OrtBindInput = S(n._OrtBindInput, () => n._OrtBindInput, (D) => n._OrtBindInput = D), u = void 0;
      };
      n.jsepInit = (S, C) => {
        if (u == null ? void 0 : u(), S === "webgpu") {
          [n.Dd, n.Rd, n.Vd, n.Hd, n.Ud, n.hc, n.Wd, n.Zd, n.Sd, n.Td, n.Xd] = C;
          let D = n.Dd;
          n.jsepRegisterBuffer = (P, R, W, q) => D.registerBuffer(P, R, W, q), n.jsepGetBuffer = (P) => D.getBuffer(P), n.jsepCreateDownloader = (P, R, W) => D.createDownloader(P, R, W), n.jsepOnCreateSession = (P) => {
            D.onCreateSession(P);
          }, n.jsepOnReleaseSession = (P) => {
            D.onReleaseSession(P);
          }, n.jsepOnRunStart = (P) => D.onRunStart(P), n.$d = (P, R) => {
            D.upload(P, R);
          };
        } else if (S === "webnn") {
          [n.Dd, n.Yd, n.Id, n.jsepEnsureTensor, n.Jd, n.jsepDownloadTensor] = C, n.jsepReleaseTensorId = n.Id, n.jsepUploadTensor = n.Jd;
          let D = n.Dd;
          n.jsepOnRunStart = (P) => D.onRunStart(P), n.jsepOnRunEnd = D.onRunEnd.bind(D), n.jsepRegisterMLContext = (P, R) => {
            D.registerMLContext(P, R);
          }, n.jsepOnReleaseSession = (P) => {
            D.onReleaseSession(P);
          }, n.jsepCreateMLTensorDownloader = (P, R) => D.createMLTensorDownloader(P, R), n.jsepRegisterMLTensor = (P, R, W, q) => D.registerMLTensor(P, R, W, q), n.jsepCreateMLContext = (P) => D.createMLContext(P), n.jsepRegisterMLConstant = (P, R, W, q, J) => D.registerMLConstant(P, R, W, q, J, n.Bd), n.jsepRegisterGraphInput = D.registerGraphInput.bind(D), n.jsepIsGraphInput = D.isGraphInput.bind(D), n.jsepCreateTemporaryTensor = D.createTemporaryTensor.bind(D);
        }
      };
      var c, h, f = Object.assign({}, n), d = (S, C) => {
        throw C;
      }, p = "";
      (a || o) && (o ? p = self.location.href : typeof document < "u" && document.currentScript && (p = document.currentScript.src), xb && (p = xb), p = p.startsWith("blob:") ? "" : p.slice(0, p.replace(/[?#].*/, "").lastIndexOf("/") + 1), o && (h = (S) => {
        var C = new XMLHttpRequest();
        return C.open("GET", S, false), C.responseType = "arraybuffer", C.send(null), new Uint8Array(C.response);
      }), c = async (S) => {
        if (N(S)) return new Promise((D, P) => {
          var R = new XMLHttpRequest();
          R.open("GET", S, true), R.responseType = "arraybuffer", R.onload = () => {
            R.status == 200 || R.status == 0 && R.response ? D(R.response) : P(R.status);
          }, R.onerror = P, R.send(null);
        });
        var C = await fetch(S, {
          credentials: "same-origin"
        });
        if (C.ok) return C.arrayBuffer();
        throw Error(C.status + " : " + C.url);
      });
      var v = console.log.bind(console), g = console.error.bind(console), m = v, y = g;
      Object.assign(n, f), f = null;
      var _, b, w, x, T, A, I, M, k, B, L, z, F, E = n.wasmBinary, O = false, N = (S) => S.startsWith("file://");
      function V() {
        return _.buffer != x.buffer && ue(), x;
      }
      function H() {
        return _.buffer != x.buffer && ue(), T;
      }
      function G() {
        return _.buffer != x.buffer && ue(), A;
      }
      function Y() {
        return _.buffer != x.buffer && ue(), I;
      }
      function U() {
        return _.buffer != x.buffer && ue(), M;
      }
      function Z() {
        return _.buffer != x.buffer && ue(), k;
      }
      function ee() {
        return _.buffer != x.buffer && ue(), B;
      }
      function we() {
        return _.buffer != x.buffer && ue(), F;
      }
      if (s) {
        let S = function(C) {
          try {
            var D = C.data, P = D.yd;
            if (P === "load") {
              let R = [];
              self.onmessage = (W) => R.push(W), self.startWorker = () => {
                postMessage({
                  yd: "loaded"
                });
                for (let W of R) S(W);
                self.onmessage = S;
              };
              for (let W of D.Od) n[W] && !n[W].proxy || (n[W] = (...q) => {
                postMessage({
                  yd: "callHandler",
                  Nd: W,
                  args: q
                });
              }, W == "print" && (m = n[W]), W == "printErr" && (y = n[W]));
              _ = D.he, ue(), Te(D.ie);
            } else if (P === "run") {
              M7(D.xd), Wy(D.xd, 0, 0, 1, 0, 0), bA(), Ny(D.xd), le || (pI(), le = true);
              try {
                D7(D.de, D.Fd);
              } catch (R) {
                if (R != "unwind") throw R;
              }
            } else D.target !== "setimmediate" && (P === "checkMailbox" ? le && tp() : P && (y(`worker: received unknown command ${P}`), y(D)));
          } catch (R) {
            throw vI(), R;
          }
        };
        var Te, le = false;
        y = function(...C) {
          C = C.join(" "), console.error(C);
        }, self.alert = function(...C) {
          postMessage({
            yd: "alert",
            text: C.join(" "),
            fe: up()
          });
        }, self.onunhandledrejection = (C) => {
          throw C.reason || C;
        }, self.onmessage = S;
      }
      function ue() {
        var S = _.buffer;
        n.HEAP8 = x = new Int8Array(S), n.HEAP16 = A = new Int16Array(S), n.HEAPU8 = T = new Uint8Array(S), n.HEAPU16 = I = new Uint16Array(S), n.HEAP32 = M = new Int32Array(S), n.HEAPU32 = k = new Uint32Array(S), n.HEAPF32 = B = new Float32Array(S), n.HEAPF64 = F = new Float64Array(S), n.HEAP64 = L = new BigInt64Array(S), n.HEAPU64 = z = new BigUint64Array(S);
      }
      function ye() {
        s ? startWorker(n) : fe.Bb();
      }
      s || (_ = new WebAssembly.Memory({
        initial: 256,
        maximum: 65536,
        shared: true
      }), ue());
      var ve, Se = 0, Qe = null;
      function Xe() {
        if (--Se == 0 && Qe) {
          var S = Qe;
          Qe = null, S();
        }
      }
      function be(S) {
        throw y(S = "Aborted(" + S + ")"), O = true, S = new WebAssembly.RuntimeError(S + ". Build with -sASSERTIONS for more info."), r(S), S;
      }
      function ke() {
        return {
          a: {
            Ta: j,
            Va: X,
            W: E7,
            la: k7,
            b: L7,
            u: $7,
            R: R7,
            Za: O7,
            d: N7,
            pb: TA,
            g: P7,
            T: IA,
            Ga: MA,
            lb: EA,
            nb: kA,
            Ha: PA,
            Ea: LA,
            wb: $A,
            Da: RA,
            pa: OA,
            mb: NA,
            jb: BA,
            Fa: zA,
            kb: FA,
            Ma: B7,
            za: z7,
            eb: F7,
            cb: G7,
            ya: H7,
            V: U7,
            N: Y7,
            db: q7,
            ma: eX,
            fb: tX,
            zb: rX,
            hb: nX,
            qb: iX,
            ab: aX,
            Aa: oX,
            yb: Ny,
            Ja: sX,
            S: lX,
            Wa: uX,
            $: fX,
            G: dX,
            E: vX,
            m: $y,
            H: gX,
            B: _X,
            X: bX,
            J: xX,
            v: wX,
            O: SX,
            D: TX,
            t: CX,
            A: AX,
            z: IX,
            w: MX,
            r: DX,
            tb: EX,
            ub: kX,
            vb: PX,
            rb: eI,
            sb: tI,
            bb: rI,
            Oa: $X,
            La: OX,
            y: NX,
            ja: BX,
            Ba: zX,
            Ka: RX,
            qa: FX,
            Ia: VX,
            ib: GX,
            U: LX,
            fa: WX,
            Sa: HX,
            gb: UX,
            Qa: YX,
            Pa: qX,
            Ab: oI,
            Ca: sI,
            ob: Ai,
            aa: lI,
            oa: uI,
            xb: cI,
            na: hI,
            $a: bj,
            ia: Lj,
            sa: Bj,
            ga: yj,
            da: Aj,
            ua: Oj,
            p: gj,
            e: ej,
            c: QX,
            ea: Tj,
            f: tj,
            n: nj,
            k: fj,
            Y: aj,
            ka: dj,
            j: mj,
            wa: Sj,
            Ra: Vj,
            ca: kj,
            Ua: Fj,
            P: Cj,
            K: sj,
            _: Ej,
            Q: _j,
            Z: $j,
            x: oj,
            l: JX,
            va: Dj,
            i: ZX,
            h: ij,
            ra: zj,
            ta: Nj,
            o: rj,
            q: lj,
            s: cj,
            I: hj,
            C: vj,
            L: pj,
            xa: wj,
            _a: xj,
            F: Pj,
            Ya: Ij,
            ba: Rj,
            M: uj,
            Xa: Mj,
            ha: jX,
            a: _,
            Na: Nt
          }
        };
      }
      var Vt = {
        1319426: () => typeof wasmOffsetConverter < "u",
        1319483: (S, C, D, P, R) => {
          if (n === void 0 || !n.Bd) return 1;
          if ((S = pr(Number(S >>> 0))).startsWith("./") && (S = S.substring(2)), !(S = n.Bd.get(S))) return 2;
          if (C = Number(C >>> 0), D = Number(D >>> 0), P = Number(P >>> 0), C + D > S.byteLength) return 3;
          try {
            let W = S.subarray(C, C + D);
            switch (R) {
              case 0:
                H().set(W, P >>> 0);
                break;
              case 1:
                n.$d(P, W);
                break;
              default:
                return 4;
            }
            return 0;
          } catch {
            return 4;
          }
        },
        1320198: (S, C, D) => {
          n.Jd(S, H().subarray(C >>> 0, C + D >>> 0));
        },
        1320261: () => n.Yd(),
        1320302: (S) => {
          n.Id(S);
        },
        1320338: () => {
          n.Sd();
        },
        1320369: () => {
          n.Td();
        },
        1320398: () => {
          n.Xd();
        },
        1320423: (S) => n.Rd(S),
        1320456: (S) => n.Vd(S),
        1320488: (S, C, D) => {
          n.Hd(Number(S), Number(C), Number(D), true);
        },
        1320551: (S, C, D) => {
          n.Hd(Number(S), Number(C), Number(D));
        },
        1320608: (S) => {
          n.hc("Abs", S, void 0);
        },
        1320659: (S) => {
          n.hc("Neg", S, void 0);
        },
        1320710: (S) => {
          n.hc("Floor", S, void 0);
        },
        1320763: (S) => {
          n.hc("Ceil", S, void 0);
        },
        1320815: (S) => {
          n.hc("Reciprocal", S, void 0);
        },
        1320873: (S) => {
          n.hc("Sqrt", S, void 0);
        },
        1320925: (S) => {
          n.hc("Exp", S, void 0);
        },
        1320976: (S) => {
          n.hc("Erf", S, void 0);
        },
        1321027: (S) => {
          n.hc("Sigmoid", S, void 0);
        },
        1321082: (S, C, D) => {
          n.hc("HardSigmoid", S, {
            alpha: C,
            beta: D
          });
        },
        1321161: (S) => {
          n.hc("Log", S, void 0);
        },
        1321212: (S) => {
          n.hc("Sin", S, void 0);
        },
        1321263: (S) => {
          n.hc("Cos", S, void 0);
        },
        1321314: (S) => {
          n.hc("Tan", S, void 0);
        },
        1321365: (S) => {
          n.hc("Asin", S, void 0);
        },
        1321417: (S) => {
          n.hc("Acos", S, void 0);
        },
        1321469: (S) => {
          n.hc("Atan", S, void 0);
        },
        1321521: (S) => {
          n.hc("Sinh", S, void 0);
        },
        1321573: (S) => {
          n.hc("Cosh", S, void 0);
        },
        1321625: (S) => {
          n.hc("Asinh", S, void 0);
        },
        1321678: (S) => {
          n.hc("Acosh", S, void 0);
        },
        1321731: (S) => {
          n.hc("Atanh", S, void 0);
        },
        1321784: (S) => {
          n.hc("Tanh", S, void 0);
        },
        1321836: (S) => {
          n.hc("Not", S, void 0);
        },
        1321887: (S, C, D) => {
          n.hc("Clip", S, {
            min: C,
            max: D
          });
        },
        1321956: (S) => {
          n.hc("Clip", S, void 0);
        },
        1322008: (S, C) => {
          n.hc("Elu", S, {
            alpha: C
          });
        },
        1322066: (S) => {
          n.hc("Gelu", S, void 0);
        },
        1322118: (S) => {
          n.hc("Relu", S, void 0);
        },
        1322170: (S, C) => {
          n.hc("LeakyRelu", S, {
            alpha: C
          });
        },
        1322234: (S, C) => {
          n.hc("ThresholdedRelu", S, {
            alpha: C
          });
        },
        1322304: (S, C) => {
          n.hc("Cast", S, {
            to: C
          });
        },
        1322362: (S) => {
          n.hc("Add", S, void 0);
        },
        1322413: (S) => {
          n.hc("Sub", S, void 0);
        },
        1322464: (S) => {
          n.hc("Mul", S, void 0);
        },
        1322515: (S) => {
          n.hc("Div", S, void 0);
        },
        1322566: (S) => {
          n.hc("Pow", S, void 0);
        },
        1322617: (S) => {
          n.hc("Equal", S, void 0);
        },
        1322670: (S) => {
          n.hc("Greater", S, void 0);
        },
        1322725: (S) => {
          n.hc("GreaterOrEqual", S, void 0);
        },
        1322787: (S) => {
          n.hc("Less", S, void 0);
        },
        1322839: (S) => {
          n.hc("LessOrEqual", S, void 0);
        },
        1322898: (S, C, D, P, R) => {
          n.hc("ReduceMean", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1323073: (S, C, D, P, R) => {
          n.hc("ReduceMax", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1323247: (S, C, D, P, R) => {
          n.hc("ReduceMin", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1323421: (S, C, D, P, R) => {
          n.hc("ReduceProd", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1323596: (S, C, D, P, R) => {
          n.hc("ReduceSum", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1323770: (S, C, D, P, R) => {
          n.hc("ReduceL1", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1323943: (S, C, D, P, R) => {
          n.hc("ReduceL2", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1324116: (S, C, D, P, R) => {
          n.hc("ReduceLogSum", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1324293: (S, C, D, P, R) => {
          n.hc("ReduceSumSquare", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1324473: (S, C, D, P, R) => {
          n.hc("ReduceLogSumExp", S, {
            keepDims: !!C,
            noopWithEmptyAxes: !!D,
            axes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1324653: (S) => {
          n.hc("Where", S, void 0);
        },
        1324706: (S, C, D) => {
          n.hc("Transpose", S, {
            perm: C ? Array.from(U().subarray(Number(C) >>> 0, Number(D) >>> 0)) : []
          });
        },
        1324830: (S, C, D, P) => {
          n.hc("DepthToSpace", S, {
            blocksize: C,
            mode: pr(D),
            format: P ? "NHWC" : "NCHW"
          });
        },
        1324963: (S, C, D, P) => {
          n.hc("DepthToSpace", S, {
            blocksize: C,
            mode: pr(D),
            format: P ? "NHWC" : "NCHW"
          });
        },
        1325096: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt, ei) => {
          n.hc("ConvTranspose", S, {
            format: ie ? "NHWC" : "NCHW",
            autoPad: C,
            dilations: [
              D
            ],
            group: P,
            kernelShape: [
              R
            ],
            pads: [
              W,
              q
            ],
            strides: [
              J
            ],
            wIsConst: () => !!V()[de >>> 0],
            outputPadding: Ae ? Array.from(U().subarray(Number(Ae) >>> 0, Number(He) >>> 0)) : [],
            outputShape: ut ? Array.from(U().subarray(Number(ut) >>> 0, Number(Qt) >>> 0)) : [],
            activation: pr(ei)
          });
        },
        1325529: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt) => {
          n.hc("ConvTranspose", S, {
            format: J ? "NHWC" : "NCHW",
            autoPad: C,
            dilations: Array.from(U().subarray(Number(D) >>> 0, 2 + (Number(D) >>> 0) >>> 0)),
            group: P,
            kernelShape: Array.from(U().subarray(Number(R) >>> 0, 2 + (Number(R) >>> 0) >>> 0)),
            pads: Array.from(U().subarray(Number(W) >>> 0, 4 + (Number(W) >>> 0) >>> 0)),
            strides: Array.from(U().subarray(Number(q) >>> 0, 2 + (Number(q) >>> 0) >>> 0)),
            wIsConst: () => !!V()[ie >>> 0],
            outputPadding: de ? Array.from(U().subarray(Number(de) >>> 0, Number(Ae) >>> 0)) : [],
            outputShape: He ? Array.from(U().subarray(Number(He) >>> 0, Number(ut) >>> 0)) : [],
            activation: pr(Qt)
          });
        },
        1326190: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt, ei) => {
          n.hc("ConvTranspose", S, {
            format: ie ? "NHWC" : "NCHW",
            autoPad: C,
            dilations: [
              D
            ],
            group: P,
            kernelShape: [
              R
            ],
            pads: [
              W,
              q
            ],
            strides: [
              J
            ],
            wIsConst: () => !!V()[de >>> 0],
            outputPadding: Ae ? Array.from(U().subarray(Number(Ae) >>> 0, Number(He) >>> 0)) : [],
            outputShape: ut ? Array.from(U().subarray(Number(ut) >>> 0, Number(Qt) >>> 0)) : [],
            activation: pr(ei)
          });
        },
        1326623: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt) => {
          n.hc("ConvTranspose", S, {
            format: J ? "NHWC" : "NCHW",
            autoPad: C,
            dilations: Array.from(U().subarray(Number(D) >>> 0, 2 + (Number(D) >>> 0) >>> 0)),
            group: P,
            kernelShape: Array.from(U().subarray(Number(R) >>> 0, 2 + (Number(R) >>> 0) >>> 0)),
            pads: Array.from(U().subarray(Number(W) >>> 0, 4 + (Number(W) >>> 0) >>> 0)),
            strides: Array.from(U().subarray(Number(q) >>> 0, 2 + (Number(q) >>> 0) >>> 0)),
            wIsConst: () => !!V()[ie >>> 0],
            outputPadding: de ? Array.from(U().subarray(Number(de) >>> 0, Number(Ae) >>> 0)) : [],
            outputShape: He ? Array.from(U().subarray(Number(He) >>> 0, Number(ut) >>> 0)) : [],
            activation: pr(Qt)
          });
        },
        1327284: (S, C) => {
          n.hc("GlobalAveragePool", S, {
            format: C ? "NHWC" : "NCHW"
          });
        },
        1327375: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt) => {
          n.hc("AveragePool", S, {
            format: Qt ? "NHWC" : "NCHW",
            auto_pad: C,
            ceil_mode: D,
            count_include_pad: P,
            storage_order: R,
            dilations: W ? Array.from(U().subarray(Number(W) >>> 0, Number(q) >>> 0)) : [],
            kernel_shape: J ? Array.from(U().subarray(Number(J) >>> 0, Number(ie) >>> 0)) : [],
            pads: de ? Array.from(U().subarray(Number(de) >>> 0, Number(Ae) >>> 0)) : [],
            strides: He ? Array.from(U().subarray(Number(He) >>> 0, Number(ut) >>> 0)) : []
          });
        },
        1327854: (S, C) => {
          n.hc("GlobalAveragePool", S, {
            format: C ? "NHWC" : "NCHW"
          });
        },
        1327945: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt) => {
          n.hc("AveragePool", S, {
            format: Qt ? "NHWC" : "NCHW",
            auto_pad: C,
            ceil_mode: D,
            count_include_pad: P,
            storage_order: R,
            dilations: W ? Array.from(U().subarray(Number(W) >>> 0, Number(q) >>> 0)) : [],
            kernel_shape: J ? Array.from(U().subarray(Number(J) >>> 0, Number(ie) >>> 0)) : [],
            pads: de ? Array.from(U().subarray(Number(de) >>> 0, Number(Ae) >>> 0)) : [],
            strides: He ? Array.from(U().subarray(Number(He) >>> 0, Number(ut) >>> 0)) : []
          });
        },
        1328424: (S, C) => {
          n.hc("GlobalMaxPool", S, {
            format: C ? "NHWC" : "NCHW"
          });
        },
        1328511: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt) => {
          n.hc("MaxPool", S, {
            format: Qt ? "NHWC" : "NCHW",
            auto_pad: C,
            ceil_mode: D,
            count_include_pad: P,
            storage_order: R,
            dilations: W ? Array.from(U().subarray(Number(W) >>> 0, Number(q) >>> 0)) : [],
            kernel_shape: J ? Array.from(U().subarray(Number(J) >>> 0, Number(ie) >>> 0)) : [],
            pads: de ? Array.from(U().subarray(Number(de) >>> 0, Number(Ae) >>> 0)) : [],
            strides: He ? Array.from(U().subarray(Number(He) >>> 0, Number(ut) >>> 0)) : []
          });
        },
        1328986: (S, C) => {
          n.hc("GlobalMaxPool", S, {
            format: C ? "NHWC" : "NCHW"
          });
        },
        1329073: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt) => {
          n.hc("MaxPool", S, {
            format: Qt ? "NHWC" : "NCHW",
            auto_pad: C,
            ceil_mode: D,
            count_include_pad: P,
            storage_order: R,
            dilations: W ? Array.from(U().subarray(Number(W) >>> 0, Number(q) >>> 0)) : [],
            kernel_shape: J ? Array.from(U().subarray(Number(J) >>> 0, Number(ie) >>> 0)) : [],
            pads: de ? Array.from(U().subarray(Number(de) >>> 0, Number(Ae) >>> 0)) : [],
            strides: He ? Array.from(U().subarray(Number(He) >>> 0, Number(ut) >>> 0)) : []
          });
        },
        1329548: (S, C, D, P, R) => {
          n.hc("Gemm", S, {
            alpha: C,
            beta: D,
            transA: P,
            transB: R
          });
        },
        1329652: (S) => {
          n.hc("MatMul", S, void 0);
        },
        1329706: (S, C, D, P) => {
          n.hc("ArgMax", S, {
            keepDims: !!C,
            selectLastIndex: !!D,
            axis: P
          });
        },
        1329814: (S, C, D, P) => {
          n.hc("ArgMin", S, {
            keepDims: !!C,
            selectLastIndex: !!D,
            axis: P
          });
        },
        1329922: (S, C) => {
          n.hc("Softmax", S, {
            axis: C
          });
        },
        1329985: (S, C) => {
          n.hc("Concat", S, {
            axis: C
          });
        },
        1330045: (S, C, D, P, R) => {
          n.hc("Split", S, {
            axis: C,
            numOutputs: D,
            splitSizes: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1330201: (S) => {
          n.hc("Expand", S, void 0);
        },
        1330255: (S, C) => {
          n.hc("Gather", S, {
            axis: Number(C)
          });
        },
        1330326: (S, C) => {
          n.hc("GatherElements", S, {
            axis: Number(C)
          });
        },
        1330405: (S, C) => {
          n.hc("GatherND", S, {
            batch_dims: Number(C)
          });
        },
        1330484: (S, C, D, P, R, W, q, J, ie, de, Ae) => {
          n.hc("Resize", S, {
            antialias: C,
            axes: D ? Array.from(U().subarray(Number(D) >>> 0, Number(P) >>> 0)) : [],
            coordinateTransformMode: pr(R),
            cubicCoeffA: W,
            excludeOutside: q,
            extrapolationValue: J,
            keepAspectRatioPolicy: pr(ie),
            mode: pr(de),
            nearestMode: pr(Ae)
          });
        },
        1330846: (S, C, D, P, R, W, q) => {
          n.hc("Slice", S, {
            starts: C ? Array.from(U().subarray(Number(C) >>> 0, Number(D) >>> 0)) : [],
            ends: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : [],
            axes: W ? Array.from(U().subarray(Number(W) >>> 0, Number(q) >>> 0)) : []
          });
        },
        1331110: (S) => {
          n.hc("Tile", S, void 0);
        },
        1331162: (S, C, D) => {
          n.hc("InstanceNormalization", S, {
            epsilon: C,
            format: D ? "NHWC" : "NCHW"
          });
        },
        1331276: (S, C, D) => {
          n.hc("InstanceNormalization", S, {
            epsilon: C,
            format: D ? "NHWC" : "NCHW"
          });
        },
        1331390: (S) => {
          n.hc("Range", S, void 0);
        },
        1331443: (S, C) => {
          n.hc("Einsum", S, {
            equation: pr(C)
          });
        },
        1331524: (S, C, D, P, R) => {
          n.hc("Pad", S, {
            mode: C,
            value: D,
            pads: P ? Array.from(U().subarray(Number(P) >>> 0, Number(R) >>> 0)) : []
          });
        },
        1331667: (S, C, D, P, R, W) => {
          n.hc("BatchNormalization", S, {
            epsilon: C,
            momentum: D,
            spatial: !!R,
            trainingMode: !!P,
            format: W ? "NHWC" : "NCHW"
          });
        },
        1331836: (S, C, D, P, R, W) => {
          n.hc("BatchNormalization", S, {
            epsilon: C,
            momentum: D,
            spatial: !!R,
            trainingMode: !!P,
            format: W ? "NHWC" : "NCHW"
          });
        },
        1332005: (S, C, D) => {
          n.hc("CumSum", S, {
            exclusive: Number(C),
            reverse: Number(D)
          });
        },
        1332102: (S, C, D) => {
          n.hc("DequantizeLinear", S, {
            axis: C,
            blockSize: D
          });
        },
        1332192: (S, C, D, P, R) => {
          n.hc("GridSample", S, {
            align_corners: C,
            mode: pr(D),
            padding_mode: pr(P),
            format: R ? "NHWC" : "NCHW"
          });
        },
        1332362: (S, C, D, P, R) => {
          n.hc("GridSample", S, {
            align_corners: C,
            mode: pr(D),
            padding_mode: pr(P),
            format: R ? "NHWC" : "NCHW"
          });
        },
        1332532: (S, C) => {
          n.hc("ScatterND", S, {
            reduction: pr(C)
          });
        },
        1332617: (S, C, D, P, R, W, q, J, ie) => {
          n.hc("Attention", S, {
            numHeads: C,
            isUnidirectional: D,
            maskFilterValue: P,
            scale: R,
            doRotary: W,
            qkvHiddenSizes: q ? Array.from(U().subarray(Number(J) >>> 0, Number(J) + q >>> 0)) : [],
            pastPresentShareBuffer: !!ie
          });
        },
        1332889: (S) => {
          n.hc("BiasAdd", S, void 0);
        },
        1332944: (S) => {
          n.hc("BiasSplitGelu", S, void 0);
        },
        1333005: (S) => {
          n.hc("FastGelu", S, void 0);
        },
        1333061: (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt, ei, ih) => {
          n.hc("Conv", S, {
            format: He ? "NHWC" : "NCHW",
            auto_pad: C,
            dilations: D ? Array.from(U().subarray(Number(D) >>> 0, Number(P) >>> 0)) : [],
            group: R,
            kernel_shape: W ? Array.from(U().subarray(Number(W) >>> 0, Number(q) >>> 0)) : [],
            pads: J ? Array.from(U().subarray(Number(J) >>> 0, Number(ie) >>> 0)) : [],
            strides: de ? Array.from(U().subarray(Number(de) >>> 0, Number(Ae) >>> 0)) : [],
            w_is_const: () => !!V()[Number(ut) >>> 0],
            activation: pr(Qt),
            activation_params: ei ? Array.from(ee().subarray(Number(ei) >>> 0, Number(ih) >>> 0)) : []
          });
        },
        1333645: (S) => {
          n.hc("Gelu", S, void 0);
        },
        1333697: (S, C, D, P, R, W, q, J, ie) => {
          n.hc("GroupQueryAttention", S, {
            numHeads: C,
            kvNumHeads: D,
            scale: P,
            softcap: R,
            doRotary: W,
            rotaryInterleaved: q,
            smoothSoftmax: J,
            localWindowSize: ie
          });
        },
        1333914: (S, C, D, P) => {
          n.hc("LayerNormalization", S, {
            axis: C,
            epsilon: D,
            simplified: !!P
          });
        },
        1334025: (S, C, D, P) => {
          n.hc("LayerNormalization", S, {
            axis: C,
            epsilon: D,
            simplified: !!P
          });
        },
        1334136: (S, C, D, P, R, W) => {
          n.hc("MatMulNBits", S, {
            k: C,
            n: D,
            accuracyLevel: P,
            bits: R,
            blockSize: W
          });
        },
        1334263: (S, C, D, P, R, W) => {
          n.hc("MultiHeadAttention", S, {
            numHeads: C,
            isUnidirectional: D,
            maskFilterValue: P,
            scale: R,
            doRotary: W
          });
        },
        1334422: (S, C) => {
          n.hc("QuickGelu", S, {
            alpha: C
          });
        },
        1334486: (S, C, D, P, R) => {
          n.hc("RotaryEmbedding", S, {
            interleaved: !!C,
            numHeads: D,
            rotaryEmbeddingDim: P,
            scale: R
          });
        },
        1334625: (S, C, D) => {
          n.hc("SkipLayerNormalization", S, {
            epsilon: C,
            simplified: !!D
          });
        },
        1334727: (S, C, D) => {
          n.hc("SkipLayerNormalization", S, {
            epsilon: C,
            simplified: !!D
          });
        },
        1334829: (S, C, D, P) => {
          n.hc("GatherBlockQuantized", S, {
            gatherAxis: C,
            quantizeAxis: D,
            blockSize: P
          });
        },
        1334950: (S) => {
          n.Wd(S);
        },
        1334984: (S, C) => n.Zd(Number(S), Number(C), n.Cd.be, n.Cd.errors)
      };
      function X(S, C, D) {
        return XA(async () => {
          await n.Ud(Number(S), Number(C), Number(D));
        });
      }
      function j() {
        return typeof wasmOffsetConverter < "u";
      }
      class he {
        constructor(C) {
          __publicField(this, "name", "ExitStatus");
          this.message = `Program terminated with exit(${C})`, this.status = C;
        }
      }
      var $e = (S) => {
        S.terminate(), S.onmessage = () => {
        };
      }, jt = [], pt = (S) => {
        Nn.length == 0 && (wA(), xA(Nn[0]));
        var C = Nn.pop();
        if (!C) return 6;
        Qn.push(C), Co[S.xd] = C, C.xd = S.xd;
        var D = {
          yd: "run",
          de: S.ce,
          Fd: S.Fd,
          xd: S.xd
        };
        return C.postMessage(D, S.Ld), 0;
      }, ne = 0, ce = (S, C, ...D) => {
        for (var P = 2 * D.length, R = nt(), W = Uy(8 * P), q = W >>> 3, J = 0; J < D.length; J++) {
          var ie = D[J];
          typeof ie == "bigint" ? (L[q + 2 * J] = 1n, L[q + 2 * J + 1] = ie) : (L[q + 2 * J] = 0n, we()[q + 2 * J + 1 >>> 0] = ie);
        }
        return S = gI(S, 0, P, W, C), tt(R), S;
      };
      function Nt(S) {
        if (s) return ce(0, 1, S);
        if (w = S, !(0 < ne)) {
          for (var C of Qn) $e(C);
          for (C of Nn) $e(C);
          Nn = [], Qn = [], Co = {}, O = true;
        }
        d(0, new he(S));
      }
      function ar(S) {
        if (s) return ce(1, 0, S);
        Ai(S);
      }
      var Ai = (S) => {
        if (w = S, s) throw ar(S), "unwind";
        Nt(S);
      }, Nn = [], Qn = [], Jd = [], Co = {}, _A = (S) => {
        var C = S.xd;
        delete Co[C], Nn.push(S), Qn.splice(Qn.indexOf(S), 1), S.xd = 0, mI(C);
      };
      function bA() {
        Jd.forEach((S) => S());
      }
      var xA = (S) => new Promise((C) => {
        S.onmessage = (R) => {
          var W = (R = R.data).yd;
          if (R.Ed && R.Ed != up()) {
            var q = Co[R.Ed];
            q ? q.postMessage(R, R.Ld) : y(`Internal error! Worker sent a message "${W}" to target pthread ${R.Ed}, but that thread no longer exists!`);
          } else W === "checkMailbox" ? tp() : W === "spawnThread" ? pt(R) : W === "cleanupThread" ? _A(Co[R.ee]) : W === "loaded" ? (S.loaded = true, C(S)) : W === "alert" ? alert(`Thread ${R.fe}: ${R.text}`) : R.target === "setimmediate" ? S.postMessage(R) : W === "callHandler" ? n[R.Nd](...R.args) : W && y(`worker sent an unknown command ${W}`);
        }, S.onerror = (R) => {
          throw y(`worker sent an error! ${R.filename}:${R.lineno}: ${R.message}`), R;
        };
        var D, P = [];
        for (D of []) n.propertyIsEnumerable(D) && P.push(D);
        S.postMessage({
          yd: "load",
          Od: P,
          he: _,
          ie: b
        });
      });
      function wA() {
        var S = new Worker(import.meta.url.startsWith("file:") ? new URL("/assets/ort.bundle.min-OfoG_cy9.mjs", import.meta.url) : new URL(import.meta.url), {
          type: "module",
          workerData: "em-pthread",
          name: "em-pthread"
        });
        Nn.push(S);
      }
      var M7 = (S) => {
        ue();
        var C = Z()[S + 52 >>> 2 >>> 0];
        S = Z()[S + 56 >>> 2 >>> 0], bI(C, C - S), tt(C);
      }, D7 = (S, C) => {
        ne = 0, S = Yy(S, C), 0 < ne ? w = S : Hy(S);
      }, ep = [];
      function E7(S) {
        var C = new Dy(S >>>= 0);
        if (V()[C.wd + 12 >>> 0] == 0) {
          var D = 1;
          V()[C.wd + 12 >>> 0] = D;
        }
        return D = 0, V()[C.wd + 13 >>> 0] = D, ep.push(C), wI(S), TI(S);
      }
      var vu = 0, k7 = () => {
        lt(0, 0);
        var S = ep.pop();
        xI(S.Gd), vu = 0;
      };
      class Dy {
        constructor(C) {
          this.Gd = C, this.wd = C - 24;
        }
      }
      function P7(S) {
        throw vu || (vu = S >>> 0), vu;
      }
      var Ey = (S) => {
        var C = vu;
        if (!C) return nh(0), 0;
        var D = new Dy(C);
        Z()[D.wd + 16 >>> 2 >>> 0] = C;
        var P = Z()[D.wd + 4 >>> 2 >>> 0];
        if (!P) return nh(0), C;
        for (var R of S) {
          if (R === 0 || R === P) break;
          if (SI(R, P, D.wd + 16)) return nh(R), C;
        }
        return nh(P), C;
      };
      function L7() {
        return Ey([]);
      }
      function $7(S) {
        return Ey([
          S >>> 0
        ]);
      }
      function R7(S, C) {
        return Ey([
          S >>> 0,
          C >>> 0
        ]);
      }
      var O7 = () => {
        var S = ep.pop();
        S || be("no exception to throw");
        var C = S.Gd;
        if (V()[S.wd + 13 >>> 0] == 0) {
          ep.push(S);
          var D = 1;
          V()[S.wd + 13 >>> 0] = D, D = 0, V()[S.wd + 12 >>> 0] = D;
        }
        throw vu = C;
      };
      function N7(S, C, D) {
        var P = new Dy(S >>>= 0);
        throw C >>>= 0, D >>>= 0, Z()[P.wd + 16 >>> 2 >>> 0] = 0, Z()[P.wd + 4 >>> 2 >>> 0] = C, Z()[P.wd + 8 >>> 2 >>> 0] = D, vu = S;
      }
      function SA(S, C, D, P) {
        return s ? ce(2, 1, S, C, D, P) : TA(S, C, D, P);
      }
      function TA(S, C, D, P) {
        if (S >>>= 0, D >>>= 0, P >>>= 0, l === void 0) return 6;
        var R = [];
        return s && R.length === 0 ? SA(S, C >>>= 0, D, P) : (S = {
          ce: D,
          xd: S,
          Fd: P,
          Ld: R
        }, s ? (S.yd = "spawnThread", postMessage(S, R), 0) : pt(S));
      }
      var CA = typeof TextDecoder < "u" ? new TextDecoder() : void 0, AA = (S, C = 0, D = NaN) => {
        var P = (C >>>= 0) + D;
        for (D = C; S[D] && !(D >= P); ) ++D;
        if (16 < D - C && S.buffer && CA) return CA.decode(S.buffer instanceof ArrayBuffer ? S.subarray(C, D) : S.slice(C, D));
        for (P = ""; C < D; ) {
          var R = S[C++];
          if (128 & R) {
            var W = 63 & S[C++];
            if ((224 & R) == 192) P += String.fromCharCode((31 & R) << 6 | W);
            else {
              var q = 63 & S[C++];
              65536 > (R = (240 & R) == 224 ? (15 & R) << 12 | W << 6 | q : (7 & R) << 18 | W << 12 | q << 6 | 63 & S[C++]) ? P += String.fromCharCode(R) : (R -= 65536, P += String.fromCharCode(55296 | R >> 10, 56320 | 1023 & R));
            }
          } else P += String.fromCharCode(R);
        }
        return P;
      }, pr = (S, C) => (S >>>= 0) ? AA(H(), S, C) : "";
      function IA(S, C, D) {
        return s ? ce(3, 1, S, C, D) : 0;
      }
      function MA(S, C) {
        if (s) return ce(4, 1, S, C);
      }
      var DA = (S) => {
        for (var C = 0, D = 0; D < S.length; ++D) {
          var P = S.charCodeAt(D);
          127 >= P ? C++ : 2047 >= P ? C += 2 : 55296 <= P && 57343 >= P ? (C += 4, ++D) : C += 3;
        }
        return C;
      }, gu = (S, C, D) => {
        var P = H();
        if (C >>>= 0, 0 < D) {
          var R = C;
          D = C + D - 1;
          for (var W = 0; W < S.length; ++W) {
            var q = S.charCodeAt(W);
            if (55296 <= q && 57343 >= q && (q = 65536 + ((1023 & q) << 10) | 1023 & S.charCodeAt(++W)), 127 >= q) {
              if (C >= D) break;
              P[C++ >>> 0] = q;
            } else {
              if (2047 >= q) {
                if (C + 1 >= D) break;
                P[C++ >>> 0] = 192 | q >> 6;
              } else {
                if (65535 >= q) {
                  if (C + 2 >= D) break;
                  P[C++ >>> 0] = 224 | q >> 12;
                } else {
                  if (C + 3 >= D) break;
                  P[C++ >>> 0] = 240 | q >> 18, P[C++ >>> 0] = 128 | q >> 12 & 63;
                }
                P[C++ >>> 0] = 128 | q >> 6 & 63;
              }
              P[C++ >>> 0] = 128 | 63 & q;
            }
          }
          P[C >>> 0] = 0, S = C - R;
        } else S = 0;
        return S;
      };
      function EA(S, C) {
        if (s) return ce(5, 1, S, C);
      }
      function kA(S, C, D) {
        if (s) return ce(6, 1, S, C, D);
      }
      function PA(S, C, D) {
        return s ? ce(7, 1, S, C, D) : 0;
      }
      function LA(S, C) {
        if (s) return ce(8, 1, S, C);
      }
      function $A(S, C, D) {
        if (s) return ce(9, 1, S, C, D);
      }
      function RA(S, C, D, P) {
        if (s) return ce(10, 1, S, C, D, P);
      }
      function OA(S, C, D, P) {
        if (s) return ce(11, 1, S, C, D, P);
      }
      function NA(S, C, D, P) {
        if (s) return ce(12, 1, S, C, D, P);
      }
      function BA(S) {
        if (s) return ce(13, 1, S);
      }
      function zA(S, C) {
        if (s) return ce(14, 1, S, C);
      }
      function FA(S, C, D) {
        if (s) return ce(15, 1, S, C, D);
      }
      var VA, Ao, B7 = () => be(""), na = (S) => {
        for (var C = ""; H()[S >>> 0]; ) C += VA[H()[S++ >>> 0]];
        return C;
      }, ky = {}, Py = {};
      function Va(S, C, D = {}) {
        return function(P, R, W = {}) {
          var q = R.name;
          if (!P) throw new Ao(`type "${q}" must have a positive integer typeid pointer`);
          if (Py.hasOwnProperty(P)) {
            if (W.Pd) return;
            throw new Ao(`Cannot register type '${q}' twice`);
          }
          Py[P] = R, ky.hasOwnProperty(P) && (R = ky[P], delete ky[P], R.forEach((J) => J()));
        }(S, C, D);
      }
      var GA = (S, C, D) => {
        switch (C) {
          case 1:
            return D ? (P) => V()[P >>> 0] : (P) => H()[P >>> 0];
          case 2:
            return D ? (P) => G()[P >>> 1 >>> 0] : (P) => Y()[P >>> 1 >>> 0];
          case 4:
            return D ? (P) => U()[P >>> 2 >>> 0] : (P) => Z()[P >>> 2 >>> 0];
          case 8:
            return D ? (P) => L[P >>> 3] : (P) => z[P >>> 3];
          default:
            throw new TypeError(`invalid integer width (${C}): ${S}`);
        }
      };
      function z7(S, C, D) {
        D >>>= 0, Va(S >>>= 0, {
          name: C = na(C >>> 0),
          fromWireType: (P) => P,
          toWireType: function(P, R) {
            if (typeof R != "bigint" && typeof R != "number") throw R = R === null ? "null" : (P = typeof R) == "object" || P === "array" || P === "function" ? R.toString() : "" + R, new TypeError(`Cannot convert "${R}" to ${this.name}`);
            return typeof R == "number" && (R = BigInt(R)), R;
          },
          zd: Io,
          readValueFromPointer: GA(C, D, C.indexOf("u") == -1),
          Ad: null
        });
      }
      var Io = 8;
      function F7(S, C, D, P) {
        Va(S >>>= 0, {
          name: C = na(C >>> 0),
          fromWireType: function(R) {
            return !!R;
          },
          toWireType: function(R, W) {
            return W ? D : P;
          },
          zd: Io,
          readValueFromPointer: function(R) {
            return this.fromWireType(H()[R >>> 0]);
          },
          Ad: null
        });
      }
      var Ly = [], Ga = [];
      function $y(S) {
        9 < (S >>>= 0) && --Ga[S + 1] == 0 && (Ga[S] = void 0, Ly.push(S));
      }
      var Bn = (S) => {
        if (!S) throw new Ao("Cannot use deleted val. handle = " + S);
        return Ga[S];
      }, Jn = (S) => {
        switch (S) {
          case void 0:
            return 2;
          case null:
            return 4;
          case true:
            return 6;
          case false:
            return 8;
          default:
            let C = Ly.pop() || Ga.length;
            return Ga[C] = S, Ga[C + 1] = 1, C;
        }
      };
      function Ry(S) {
        return this.fromWireType(Z()[S >>> 2 >>> 0]);
      }
      var V7 = {
        name: "emscripten::val",
        fromWireType: (S) => {
          var C = Bn(S);
          return $y(S), C;
        },
        toWireType: (S, C) => Jn(C),
        zd: Io,
        readValueFromPointer: Ry,
        Ad: null
      };
      function G7(S) {
        return Va(S >>> 0, V7);
      }
      var W7 = (S, C) => {
        switch (C) {
          case 4:
            return function(D) {
              return this.fromWireType(ee()[D >>> 2 >>> 0]);
            };
          case 8:
            return function(D) {
              return this.fromWireType(we()[D >>> 3 >>> 0]);
            };
          default:
            throw new TypeError(`invalid float width (${C}): ${S}`);
        }
      };
      function H7(S, C, D) {
        D >>>= 0, Va(S >>>= 0, {
          name: C = na(C >>> 0),
          fromWireType: (P) => P,
          toWireType: (P, R) => R,
          zd: Io,
          readValueFromPointer: W7(C, D),
          Ad: null
        });
      }
      function U7(S, C, D, P, R) {
        if (S >>>= 0, D >>>= 0, C = na(C >>> 0), R === -1 && (R = 4294967295), R = (J) => J, P === 0) {
          var W = 32 - 8 * D;
          R = (J) => J << W >>> W;
        }
        var q = C.includes("unsigned") ? function(J, ie) {
          return ie >>> 0;
        } : function(J, ie) {
          return ie;
        };
        Va(S, {
          name: C,
          fromWireType: R,
          toWireType: q,
          zd: Io,
          readValueFromPointer: GA(C, D, P !== 0),
          Ad: null
        });
      }
      function Y7(S, C, D) {
        function P(W) {
          var q = Z()[W >>> 2 >>> 0];
          return W = Z()[W + 4 >>> 2 >>> 0], new R(V().buffer, W, q);
        }
        var R = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
          BigInt64Array,
          BigUint64Array
        ][C];
        Va(S >>>= 0, {
          name: D = na(D >>> 0),
          fromWireType: P,
          zd: Io,
          readValueFromPointer: P
        }, {
          Pd: true
        });
      }
      function q7(S, C) {
        Va(S >>>= 0, {
          name: C = na(C >>> 0),
          fromWireType: function(D) {
            for (var P, R = Z()[D >>> 2 >>> 0], W = D + 4, q = W, J = 0; J <= R; ++J) {
              var ie = W + J;
              J != R && H()[ie >>> 0] != 0 || (q = pr(q, ie - q), P === void 0 ? P = q : (P += "\0", P += q), q = ie + 1);
            }
            return aa(D), P;
          },
          toWireType: function(D, P) {
            P instanceof ArrayBuffer && (P = new Uint8Array(P));
            var R = typeof P == "string";
            if (!(R || P instanceof Uint8Array || P instanceof Uint8ClampedArray || P instanceof Int8Array)) throw new Ao("Cannot pass non-string to std::string");
            var W = R ? DA(P) : P.length, q = cp(4 + W + 1), J = q + 4;
            if (Z()[q >>> 2 >>> 0] = W, R) gu(P, J, W + 1);
            else if (R) for (R = 0; R < W; ++R) {
              var ie = P.charCodeAt(R);
              if (255 < ie) throw aa(q), new Ao("String has UTF-16 code units that do not fit in 8 bits");
              H()[J + R >>> 0] = ie;
            }
            else for (R = 0; R < W; ++R) H()[J + R >>> 0] = P[R];
            return D !== null && D.push(aa, q), q;
          },
          zd: Io,
          readValueFromPointer: Ry,
          Ad(D) {
            aa(D);
          }
        });
      }
      var WA = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, X7 = (S, C) => {
        for (var D = S >> 1, P = D + C / 2; !(D >= P) && Y()[D >>> 0]; ) ++D;
        if (32 < (D <<= 1) - S && WA) return WA.decode(H().slice(S, D));
        for (D = "", P = 0; !(P >= C / 2); ++P) {
          var R = G()[S + 2 * P >>> 1 >>> 0];
          if (R == 0) break;
          D += String.fromCharCode(R);
        }
        return D;
      }, j7 = (S, C, D) => {
        if (D ?? (D = 2147483647), 2 > D) return 0;
        var P = C;
        D = (D -= 2) < 2 * S.length ? D / 2 : S.length;
        for (var R = 0; R < D; ++R) {
          var W = S.charCodeAt(R);
          G()[C >>> 1 >>> 0] = W, C += 2;
        }
        return G()[C >>> 1 >>> 0] = 0, C - P;
      }, K7 = (S) => 2 * S.length, Z7 = (S, C) => {
        for (var D = 0, P = ""; !(D >= C / 4); ) {
          var R = U()[S + 4 * D >>> 2 >>> 0];
          if (R == 0) break;
          ++D, 65536 <= R ? (R -= 65536, P += String.fromCharCode(55296 | R >> 10, 56320 | 1023 & R)) : P += String.fromCharCode(R);
        }
        return P;
      }, Q7 = (S, C, D) => {
        if (C >>>= 0, D ?? (D = 2147483647), 4 > D) return 0;
        var P = C;
        D = P + D - 4;
        for (var R = 0; R < S.length; ++R) {
          var W = S.charCodeAt(R);
          if (55296 <= W && 57343 >= W && (W = 65536 + ((1023 & W) << 10) | 1023 & S.charCodeAt(++R)), U()[C >>> 2 >>> 0] = W, (C += 4) + 4 > D) break;
        }
        return U()[C >>> 2 >>> 0] = 0, C - P;
      }, J7 = (S) => {
        for (var C = 0, D = 0; D < S.length; ++D) {
          var P = S.charCodeAt(D);
          55296 <= P && 57343 >= P && ++D, C += 4;
        }
        return C;
      };
      function eX(S, C, D) {
        if (S >>>= 0, C >>>= 0, D = na(D >>>= 0), C === 2) var P = X7, R = j7, W = K7, q = (J) => Y()[J >>> 1 >>> 0];
        else C === 4 && (P = Z7, R = Q7, W = J7, q = (J) => Z()[J >>> 2 >>> 0]);
        Va(S, {
          name: D,
          fromWireType: (J) => {
            for (var ie, de = Z()[J >>> 2 >>> 0], Ae = J + 4, He = 0; He <= de; ++He) {
              var ut = J + 4 + He * C;
              He != de && q(ut) != 0 || (Ae = P(Ae, ut - Ae), ie === void 0 ? ie = Ae : (ie += "\0", ie += Ae), Ae = ut + C);
            }
            return aa(J), ie;
          },
          toWireType: (J, ie) => {
            if (typeof ie != "string") throw new Ao(`Cannot pass non-string to C++ string type ${D}`);
            var de = W(ie), Ae = cp(4 + de + C);
            return Z()[Ae >>> 2 >>> 0] = de / C, R(ie, Ae + 4, de + C), J !== null && J.push(aa, Ae), Ae;
          },
          zd: Io,
          readValueFromPointer: Ry,
          Ad(J) {
            aa(J);
          }
        });
      }
      function tX(S, C) {
        Va(S >>>= 0, {
          Qd: true,
          name: C = na(C >>> 0),
          zd: 0,
          fromWireType: () => {
          },
          toWireType: () => {
          }
        });
      }
      function rX(S) {
        Wy(S >>> 0, !o, 1, !a, 131072, false), bA();
      }
      var Oy = (S) => {
        if (!O) try {
          if (S(), !(0 < ne)) try {
            s ? Hy(w) : Ai(w);
          } catch (C) {
            C instanceof he || C == "unwind" || d(0, C);
          }
        } catch (C) {
          C instanceof he || C == "unwind" || d(0, C);
        }
      };
      function Ny(S) {
        S >>>= 0, typeof Atomics.ge == "function" && (Atomics.ge(U(), S >>> 2, S).value.then(tp), S += 128, Atomics.store(U(), S >>> 2, 1));
      }
      var tp = () => {
        var S = up();
        S && (Ny(S), Oy(_I));
      };
      function nX(S, C) {
        (S >>>= 0) == C >>> 0 ? setTimeout(tp) : s ? postMessage({
          Ed: S,
          yd: "checkMailbox"
        }) : (S = Co[S]) && S.postMessage({
          yd: "checkMailbox"
        });
      }
      var By = [];
      function iX(S, C, D, P, R) {
        for (C >>>= 0, P /= 2, By.length = P, D = R >>> 0 >>> 3, R = 0; R < P; R++) By[R] = L[D + 2 * R] ? L[D + 2 * R + 1] : we()[D + 2 * R + 1 >>> 0];
        return (C ? Vt[C] : KX[S])(...By);
      }
      var aX = () => {
        ne = 0;
      };
      function oX(S) {
        S >>>= 0, s ? postMessage({
          yd: "cleanupThread",
          ee: S
        }) : _A(Co[S]);
      }
      function sX(S) {
      }
      var rp = (S, C) => {
        var D = Py[S];
        if (D === void 0) throw S = dI(S), D = na(S), aa(S), new Ao(`${C} has unknown type ${D}`);
        return D;
      }, HA = (S, C, D) => {
        var P = [];
        return S = S.toWireType(P, D), P.length && (Z()[C >>> 2 >>> 0] = Jn(P)), S;
      };
      function lX(S, C, D) {
        return C >>>= 0, D >>>= 0, S = Bn(S >>> 0), C = rp(C, "emval::as"), HA(C, D, S);
      }
      function uX(S, C) {
        return C >>>= 0, S = Bn(S >>> 0), (C = rp(C, "emval::as")).toWireType(null, S);
      }
      var np = (S) => {
        try {
          S();
        } catch (C) {
          be(C);
        }
      }, Mo = 0, ia = null, UA = 0, ip = [], YA = {}, qA = {}, cX = 0, zy = null, hX = [];
      function XA(S) {
        return function(C) {
          if (!O) {
            if (Mo === 0) {
              var D = false, P = false;
              C((R = 0) => {
                if (!O && (UA = R, D = true, P)) {
                  Mo = 2, np(() => mM(ia)), typeof MainLoop < "u" && MainLoop.Md && MainLoop.resume(), R = false;
                  try {
                    var W = function() {
                      var ie = U()[ia + 8 >>> 2 >>> 0];
                      return ie = fe[qA[ie]], --ne, ie();
                    }();
                  } catch (ie) {
                    W = ie, R = true;
                  }
                  var q = false;
                  if (!ia) {
                    var J = zy;
                    J && (zy = null, (R ? J.reject : J.resolve)(W), q = true);
                  }
                  if (R && !q) throw W;
                }
              }), P = true, D || (Mo = 1, ia = function() {
                var R = cp(65548), W = R + 12;
                Z()[R >>> 2 >>> 0] = W, Z()[R + 4 >>> 2 >>> 0] = W + 65536, W = ip[0];
                var q = YA[W];
                return q === void 0 && (q = cX++, YA[W] = q, qA[q] = W), W = q, U()[R + 8 >>> 2 >>> 0] = W, R;
              }(), typeof MainLoop < "u" && MainLoop.Md && MainLoop.pause(), np(() => vM(ia)));
            } else Mo === 2 ? (Mo = 0, np(yM), aa(ia), ia = null, hX.forEach(Oy)) : be(`invalid state: ${Mo}`);
            return UA;
          }
        }((C) => {
          S().then(C);
        });
      }
      function fX(S) {
        return S >>>= 0, XA(async () => {
          var C = await Bn(S);
          return Jn(C);
        });
      }
      var ap = [];
      function dX(S, C, D, P) {
        return D >>>= 0, P >>>= 0, (S = ap[S >>> 0])(null, C = Bn(C >>> 0), D, P);
      }
      var pX = {}, op = (S) => {
        var C = pX[S];
        return C === void 0 ? na(S) : C;
      };
      function vX(S, C, D, P, R) {
        return D >>>= 0, P >>>= 0, R >>>= 0, (S = ap[S >>> 0])(C = Bn(C >>> 0), C[D = op(D)], P, R);
      }
      var jA = () => typeof globalThis == "object" ? globalThis : Function("return this")();
      function gX(S) {
        return (S >>>= 0) == 0 ? Jn(jA()) : (S = op(S), Jn(jA()[S]));
      }
      var mX = (S) => {
        var C = ap.length;
        return ap.push(S), C;
      }, yX = (S, C) => {
        for (var D = Array(S), P = 0; P < S; ++P) D[P] = rp(Z()[C + 4 * P >>> 2 >>> 0], "parameter " + P);
        return D;
      }, KA = (S, C) => Object.defineProperty(C, "name", {
        value: S
      });
      function _X(S, C, D) {
        var P = (C = yX(S, C >>> 0)).shift();
        S--;
        var R = `return function (obj, func, destructorsRef, args) {
`, W = 0, q = [];
        D === 0 && q.push("obj");
        for (var J = [
          "retType"
        ], ie = [
          P
        ], de = 0; de < S; ++de) q.push("arg" + de), J.push("argType" + de), ie.push(C[de]), R += `  var arg${de} = argType${de}.readValueFromPointer(args${W ? "+" + W : ""});
`, W += C[de].zd;
        return R += `  var rv = ${D === 1 ? "new func" : "func.call"}(${q.join(", ")});
`, P.Qd || (J.push("emval_returnValue"), ie.push(HA), R += `  return emval_returnValue(retType, destructorsRef, rv);
`), J.push(R + `};
`), S = function(Ae) {
          var He = Function;
          if (!(He instanceof Function)) throw new TypeError(`new_ called with constructor type ${typeof He} which is not a function`);
          var ut = KA(He.name || "unknownFunctionName", function() {
          });
          return ut.prototype = He.prototype, ut = new ut(), (Ae = He.apply(ut, Ae)) instanceof Object ? Ae : ut;
        }(J)(...ie), D = `methodCaller<(${C.map((Ae) => Ae.name).join(", ")}) => ${P.name}>`, mX(KA(D, S));
      }
      function bX(S) {
        return S = op(S >>> 0), Jn(n[S]);
      }
      function xX(S, C) {
        return C >>>= 0, S = Bn(S >>> 0), C = Bn(C), Jn(S[C]);
      }
      function wX(S) {
        9 < (S >>>= 0) && (Ga[S + 1] += 1);
      }
      function SX() {
        return Jn([]);
      }
      function TX(S) {
        S = Bn(S >>> 0);
        for (var C = Array(S.length), D = 0; D < S.length; D++) C[D] = S[D];
        return Jn(C);
      }
      function CX(S) {
        return Jn(op(S >>> 0));
      }
      function AX() {
        return Jn({});
      }
      function IX(S) {
        for (var C = Bn(S >>>= 0); C.length; ) {
          var D = C.pop();
          C.pop()(D);
        }
        $y(S);
      }
      function MX(S, C, D) {
        C >>>= 0, D >>>= 0, S = Bn(S >>> 0), C = Bn(C), D = Bn(D), S[C] = D;
      }
      function DX(S, C) {
        return C >>>= 0, S = (S = rp(S >>> 0, "_emval_take_value")).readValueFromPointer(C), Jn(S);
      }
      function EX(S, C) {
        S = -9007199254740992 > S || 9007199254740992 < S ? NaN : Number(S), C >>>= 0, S = new Date(1e3 * S), U()[C >>> 2 >>> 0] = S.getUTCSeconds(), U()[C + 4 >>> 2 >>> 0] = S.getUTCMinutes(), U()[C + 8 >>> 2 >>> 0] = S.getUTCHours(), U()[C + 12 >>> 2 >>> 0] = S.getUTCDate(), U()[C + 16 >>> 2 >>> 0] = S.getUTCMonth(), U()[C + 20 >>> 2 >>> 0] = S.getUTCFullYear() - 1900, U()[C + 24 >>> 2 >>> 0] = S.getUTCDay(), S = (S.getTime() - Date.UTC(S.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, U()[C + 28 >>> 2 >>> 0] = S;
      }
      var ZA = (S) => S % 4 == 0 && (S % 100 != 0 || S % 400 == 0), QA = [
        0,
        31,
        60,
        91,
        121,
        152,
        182,
        213,
        244,
        274,
        305,
        335
      ], JA = [
        0,
        31,
        59,
        90,
        120,
        151,
        181,
        212,
        243,
        273,
        304,
        334
      ];
      function kX(S, C) {
        S = -9007199254740992 > S || 9007199254740992 < S ? NaN : Number(S), C >>>= 0, S = new Date(1e3 * S), U()[C >>> 2 >>> 0] = S.getSeconds(), U()[C + 4 >>> 2 >>> 0] = S.getMinutes(), U()[C + 8 >>> 2 >>> 0] = S.getHours(), U()[C + 12 >>> 2 >>> 0] = S.getDate(), U()[C + 16 >>> 2 >>> 0] = S.getMonth(), U()[C + 20 >>> 2 >>> 0] = S.getFullYear() - 1900, U()[C + 24 >>> 2 >>> 0] = S.getDay();
        var D = (ZA(S.getFullYear()) ? QA : JA)[S.getMonth()] + S.getDate() - 1 | 0;
        U()[C + 28 >>> 2 >>> 0] = D, U()[C + 36 >>> 2 >>> 0] = -60 * S.getTimezoneOffset(), D = new Date(S.getFullYear(), 6, 1).getTimezoneOffset();
        var P = new Date(S.getFullYear(), 0, 1).getTimezoneOffset();
        S = 0 | (D != P && S.getTimezoneOffset() == Math.min(P, D)), U()[C + 32 >>> 2 >>> 0] = S;
      }
      function PX(S) {
        S >>>= 0;
        var C = new Date(U()[S + 20 >>> 2 >>> 0] + 1900, U()[S + 16 >>> 2 >>> 0], U()[S + 12 >>> 2 >>> 0], U()[S + 8 >>> 2 >>> 0], U()[S + 4 >>> 2 >>> 0], U()[S >>> 2 >>> 0], 0), D = U()[S + 32 >>> 2 >>> 0], P = C.getTimezoneOffset(), R = new Date(C.getFullYear(), 6, 1).getTimezoneOffset(), W = new Date(C.getFullYear(), 0, 1).getTimezoneOffset(), q = Math.min(W, R);
        return 0 > D ? U()[S + 32 >>> 2 >>> 0] = +(R != W && q == P) : 0 < D != (q == P) && (R = Math.max(W, R), C.setTime(C.getTime() + 6e4 * ((0 < D ? q : R) - P))), U()[S + 24 >>> 2 >>> 0] = C.getDay(), D = (ZA(C.getFullYear()) ? QA : JA)[C.getMonth()] + C.getDate() - 1 | 0, U()[S + 28 >>> 2 >>> 0] = D, U()[S >>> 2 >>> 0] = C.getSeconds(), U()[S + 4 >>> 2 >>> 0] = C.getMinutes(), U()[S + 8 >>> 2 >>> 0] = C.getHours(), U()[S + 12 >>> 2 >>> 0] = C.getDate(), U()[S + 16 >>> 2 >>> 0] = C.getMonth(), U()[S + 20 >>> 2 >>> 0] = C.getYear(), S = C.getTime(), BigInt(isNaN(S) ? -1 : S / 1e3);
      }
      function eI(S, C, D, P, R, W, q) {
        return s ? ce(16, 1, S, C, D, P, R, W, q) : -52;
      }
      function tI(S, C, D, P, R, W) {
        if (s) return ce(17, 1, S, C, D, P, R, W);
      }
      var th = {}, LX = () => performance.timeOrigin + performance.now();
      function rI(S, C) {
        if (s) return ce(18, 1, S, C);
        if (th[S] && (clearTimeout(th[S].id), delete th[S]), !C) return 0;
        var D = setTimeout(() => {
          delete th[S], Oy(() => yI(S, performance.timeOrigin + performance.now()));
        }, C);
        return th[S] = {
          id: D,
          ke: C
        }, 0;
      }
      function $X(S, C, D, P) {
        S >>>= 0, C >>>= 0, D >>>= 0, P >>>= 0;
        var R = (/* @__PURE__ */ new Date()).getFullYear(), W = new Date(R, 0, 1).getTimezoneOffset();
        R = new Date(R, 6, 1).getTimezoneOffset();
        var q = Math.max(W, R);
        Z()[S >>> 2 >>> 0] = 60 * q, U()[C >>> 2 >>> 0] = +(W != R), S = (C = (J) => {
          var ie = Math.abs(J);
          return `UTC${0 <= J ? "-" : "+"}${String(Math.floor(ie / 60)).padStart(2, "0")}${String(ie % 60).padStart(2, "0")}`;
        })(W), C = C(R), R < W ? (gu(S, D, 17), gu(C, P, 17)) : (gu(S, P, 17), gu(C, D, 17));
      }
      var RX = () => Date.now();
      function OX(S, C, D) {
        return 0 <= S && 3 >= S ? (S === 0 ? S = Date.now() : S = performance.timeOrigin + performance.now(), L[D >>> 0 >>> 3] = BigInt(Math.round(1e6 * S)), 0) : 28;
      }
      var Fy = [], nI = (S, C) => {
        Fy.length = 0;
        for (var D; D = H()[S++ >>> 0]; ) {
          var P = D != 105;
          C += (P &= D != 112) && C % 8 ? 4 : 0, Fy.push(D == 112 ? Z()[C >>> 2 >>> 0] : D == 106 ? L[C >>> 3] : D == 105 ? U()[C >>> 2 >>> 0] : we()[C >>> 3 >>> 0]), C += P ? 8 : 4;
        }
        return Fy;
      };
      function NX(S, C, D) {
        return S >>>= 0, C = nI(C >>> 0, D >>> 0), Vt[S](...C);
      }
      function BX(S, C, D) {
        return S >>>= 0, C = nI(C >>> 0, D >>> 0), Vt[S](...C);
      }
      var zX = () => {
      };
      function FX(S, C) {
        return y(pr(S >>> 0, C >>> 0));
      }
      var VX = () => {
        throw ne += 1, "unwind";
      };
      function GX() {
        return 4294901760;
      }
      var WX = () => navigator.hardwareConcurrency;
      function HX() {
        return be("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"), 0;
      }
      function UX(S) {
        S >>>= 0;
        var C = H().length;
        if (S <= C || 4294901760 < S) return false;
        for (var D = 1; 4 >= D; D *= 2) {
          var P = C * (1 + 0.2 / D);
          P = Math.min(P, S + 100663296);
          e: {
            P = (Math.min(4294901760, 65536 * Math.ceil(Math.max(S, P) / 65536)) - _.buffer.byteLength + 65535) / 65536 | 0;
            try {
              _.grow(P), ue();
              var R = 1;
              break e;
            } catch {
            }
            R = void 0;
          }
          if (R) return true;
        }
        return false;
      }
      var sp = () => (be("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"), 0), rh = {}, iI = (S) => {
        S.forEach((C) => {
          sp();
        });
      };
      function YX() {
        var S = Error().stack.toString().split(`
`);
        return S[0] == "Error" && S.shift(), iI(S), rh.Kd = sp(), rh.ae = S, rh.Kd;
      }
      function qX(S, C, D) {
        if (S >>>= 0, C >>>= 0, rh.Kd == S) var P = rh.ae;
        else (P = Error().stack.toString().split(`
`))[0] == "Error" && P.shift(), iI(P);
        for (var R = 3; P[R] && sp() != S; ) ++R;
        for (S = 0; S < D && P[S + R]; ++S) U()[C + 4 * S >>> 2 >>> 0] = sp();
        return S;
      }
      var Vy, Gy = {}, aI = () => {
        if (!Vy) {
          var S, C = {
            USER: "web_user",
            LOGNAME: "web_user",
            PATH: "/",
            PWD: "/",
            HOME: "/home/web_user",
            LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
            _: "./this.program"
          };
          for (S in Gy) Gy[S] === void 0 ? delete C[S] : C[S] = Gy[S];
          var D = [];
          for (S in C) D.push(`${S}=${C[S]}`);
          Vy = D;
        }
        return Vy;
      };
      function oI(S, C) {
        if (s) return ce(19, 1, S, C);
        S >>>= 0, C >>>= 0;
        var D = 0;
        return aI().forEach((P, R) => {
          var W = C + D;
          for (R = Z()[S + 4 * R >>> 2 >>> 0] = W, W = 0; W < P.length; ++W) V()[R++ >>> 0] = P.charCodeAt(W);
          V()[R >>> 0] = 0, D += P.length + 1;
        }), 0;
      }
      function sI(S, C) {
        if (s) return ce(20, 1, S, C);
        S >>>= 0, C >>>= 0;
        var D = aI();
        Z()[S >>> 2 >>> 0] = D.length;
        var P = 0;
        return D.forEach((R) => P += R.length + 1), Z()[C >>> 2 >>> 0] = P, 0;
      }
      function lI(S) {
        return s ? ce(21, 1, S) : 52;
      }
      function uI(S, C, D, P) {
        return s ? ce(22, 1, S, C, D, P) : 52;
      }
      function cI(S, C, D, P) {
        return s ? ce(23, 1, S, C, D, P) : 70;
      }
      var XX = [
        null,
        [],
        []
      ];
      function hI(S, C, D, P) {
        if (s) return ce(24, 1, S, C, D, P);
        C >>>= 0, D >>>= 0, P >>>= 0;
        for (var R = 0, W = 0; W < D; W++) {
          var q = Z()[C >>> 2 >>> 0], J = Z()[C + 4 >>> 2 >>> 0];
          C += 8;
          for (var ie = 0; ie < J; ie++) {
            var de = H()[q + ie >>> 0], Ae = XX[S];
            de === 0 || de === 10 ? ((S === 1 ? m : y)(AA(Ae)), Ae.length = 0) : Ae.push(de);
          }
          R += J;
        }
        return Z()[P >>> 2 >>> 0] = R, 0;
      }
      function jX(S) {
        return S >>> 0;
      }
      s || function() {
        for (var S = n.numThreads - 1; S--; ) wA();
        jt.unshift(() => {
          Se++, function(C) {
            s ? C() : Promise.all(Nn.map(xA)).then(C);
          }(() => Xe());
        });
      }();
      for (var fI = Array(256), lp = 0; 256 > lp; ++lp) fI[lp] = String.fromCharCode(lp);
      VA = fI, Ao = n.BindingError = class extends Error {
        constructor(S) {
          super(S), this.name = "BindingError";
        }
      }, n.InternalError = class extends Error {
        constructor(S) {
          super(S), this.name = "InternalError";
        }
      }, Ga.push(0, 1, void 0, 1, null, 1, true, 1, false, 1), n.count_emval_handles = () => Ga.length / 2 - 5 - Ly.length;
      var fe, KX = [
        Nt,
        ar,
        SA,
        IA,
        MA,
        EA,
        kA,
        PA,
        LA,
        $A,
        RA,
        OA,
        NA,
        BA,
        zA,
        FA,
        eI,
        tI,
        rI,
        oI,
        sI,
        lI,
        uI,
        cI,
        hI
      ];
      (async function() {
        function S(P, R) {
          return fe = P.exports, fe = function() {
            var W = fe, q = {};
            for (let [J, ie] of Object.entries(W)) q[J] = typeof ie == "function" ? (...de) => {
              ip.push(J);
              try {
                return ie(...de);
              } finally {
                O || (ip.pop(), ia && Mo === 1 && ip.length === 0 && (Mo = 0, ne += 1, np(gM), typeof Fibers < "u" && Fibers.le()));
              }
            } : ie;
            return q;
          }(), fe = function() {
            var W = fe, q = (ie) => (de) => ie(de) >>> 0, J = (ie) => () => ie() >>> 0;
            return (W = Object.assign({}, W)).Cb = q(W.Cb), W.fc = J(W.fc), W.ic = q(W.ic), W.vc = q(W.vc), W.wc = J(W.wc), W.Ac = q(W.Ac), W;
          }(), Jd.push(fe.jc), b = R, Xe(), fe;
        }
        Se++;
        var C = ke();
        if (n.instantiateWasm) return new Promise((P) => {
          n.instantiateWasm(C, (R, W) => {
            S(R, W), P(R.exports);
          });
        });
        if (s) return new Promise((P) => {
          Te = (R) => {
            var W = new WebAssembly.Instance(R, ke());
            P(S(W, R));
          };
        });
        ve ?? (ve = n.locateFile ? n.locateFile ? n.locateFile("ort-wasm-simd-threaded.jsep.wasm", p) : p + "ort-wasm-simd-threaded.jsep.wasm" : new URL("/assets/ort-wasm-simd-threaded.jsep-D5Jk56-t.wasm", import.meta.url).href);
        try {
          var D = await async function(P) {
            var R = ve;
            if (!E && typeof WebAssembly.instantiateStreaming == "function" && !N(R)) try {
              var W = fetch(R, {
                credentials: "same-origin"
              });
              return await WebAssembly.instantiateStreaming(W, P);
            } catch (q) {
              y(`wasm streaming compile failed: ${q}`), y("falling back to ArrayBuffer instantiation");
            }
            return async function(q, J) {
              try {
                var ie = await async function(de) {
                  if (!E) try {
                    var Ae = await c(de);
                    return new Uint8Array(Ae);
                  } catch {
                  }
                  if (de == ve && E) de = new Uint8Array(E);
                  else {
                    if (!h) throw "both async and sync fetching of the wasm failed";
                    de = h(de);
                  }
                  return de;
                }(q);
                return await WebAssembly.instantiate(ie, J);
              } catch (de) {
                y(`failed to asynchronously prepare wasm: ${de}`), be(de);
              }
            }(R, P);
          }(C);
          return S(D.instance, D.module);
        } catch (P) {
          return r(P), Promise.reject(P);
        }
      })();
      var dI = (S) => (dI = fe.Cb)(S), pI = () => (pI = fe.Db)();
      n._OrtInit = (S, C) => (n._OrtInit = fe.Eb)(S, C), n._OrtGetLastError = (S, C) => (n._OrtGetLastError = fe.Fb)(S, C), n._OrtCreateSessionOptions = (S, C, D, P, R, W, q, J, ie, de) => (n._OrtCreateSessionOptions = fe.Gb)(S, C, D, P, R, W, q, J, ie, de), n._OrtAppendExecutionProvider = (S, C) => (n._OrtAppendExecutionProvider = fe.Hb)(S, C), n._OrtAddFreeDimensionOverride = (S, C, D) => (n._OrtAddFreeDimensionOverride = fe.Ib)(S, C, D), n._OrtAddSessionConfigEntry = (S, C, D) => (n._OrtAddSessionConfigEntry = fe.Jb)(S, C, D), n._OrtReleaseSessionOptions = (S) => (n._OrtReleaseSessionOptions = fe.Kb)(S), n._OrtCreateSession = (S, C, D) => (n._OrtCreateSession = fe.Lb)(S, C, D), n._OrtReleaseSession = (S) => (n._OrtReleaseSession = fe.Mb)(S), n._OrtGetInputOutputCount = (S, C, D) => (n._OrtGetInputOutputCount = fe.Nb)(S, C, D), n._OrtGetInputName = (S, C) => (n._OrtGetInputName = fe.Ob)(S, C), n._OrtGetOutputName = (S, C) => (n._OrtGetOutputName = fe.Pb)(S, C), n._OrtFree = (S) => (n._OrtFree = fe.Qb)(S), n._OrtCreateTensor = (S, C, D, P, R, W) => (n._OrtCreateTensor = fe.Rb)(S, C, D, P, R, W), n._OrtGetTensorData = (S, C, D, P, R) => (n._OrtGetTensorData = fe.Sb)(S, C, D, P, R), n._OrtReleaseTensor = (S) => (n._OrtReleaseTensor = fe.Tb)(S), n._OrtCreateRunOptions = (S, C, D, P) => (n._OrtCreateRunOptions = fe.Ub)(S, C, D, P), n._OrtAddRunConfigEntry = (S, C, D) => (n._OrtAddRunConfigEntry = fe.Vb)(S, C, D), n._OrtReleaseRunOptions = (S) => (n._OrtReleaseRunOptions = fe.Wb)(S), n._OrtCreateBinding = (S) => (n._OrtCreateBinding = fe.Xb)(S), n._OrtBindInput = (S, C, D) => (n._OrtBindInput = fe.Yb)(S, C, D), n._OrtBindOutput = (S, C, D, P) => (n._OrtBindOutput = fe.Zb)(S, C, D, P), n._OrtClearBoundOutputs = (S) => (n._OrtClearBoundOutputs = fe._b)(S), n._OrtReleaseBinding = (S) => (n._OrtReleaseBinding = fe.$b)(S), n._OrtRunWithBinding = (S, C, D, P, R) => (n._OrtRunWithBinding = fe.ac)(S, C, D, P, R), n._OrtRun = (S, C, D, P, R, W, q, J) => (n._OrtRun = fe.bc)(S, C, D, P, R, W, q, J), n._OrtEndProfiling = (S) => (n._OrtEndProfiling = fe.cc)(S), n._JsepOutput = (S, C, D) => (n._JsepOutput = fe.dc)(S, C, D), n._JsepGetNodeName = (S) => (n._JsepGetNodeName = fe.ec)(S);
      var up = () => (up = fe.fc)(), aa = n._free = (S) => (aa = n._free = fe.gc)(S), cp = n._malloc = (S) => (cp = n._malloc = fe.ic)(S), Wy = (S, C, D, P, R, W) => (Wy = fe.kc)(S, C, D, P, R, W), vI = () => (vI = fe.lc)(), gI = (S, C, D, P, R) => (gI = fe.mc)(S, C, D, P, R), mI = (S) => (mI = fe.nc)(S), Hy = (S) => (Hy = fe.oc)(S), yI = (S, C) => (yI = fe.pc)(S, C), _I = () => (_I = fe.qc)(), lt = (S, C) => (lt = fe.rc)(S, C), nh = (S) => (nh = fe.sc)(S), bI = (S, C) => (bI = fe.tc)(S, C), tt = (S) => (tt = fe.uc)(S), Uy = (S) => (Uy = fe.vc)(S), nt = () => (nt = fe.wc)(), xI = (S) => (xI = fe.xc)(S), wI = (S) => (wI = fe.yc)(S), SI = (S, C, D) => (SI = fe.zc)(S, C, D), TI = (S) => (TI = fe.Ac)(S), CI = n.dynCall_iii = (S, C, D) => (CI = n.dynCall_iii = fe.Bc)(S, C, D), AI = n.dynCall_vi = (S, C) => (AI = n.dynCall_vi = fe.Cc)(S, C), Yy = n.dynCall_ii = (S, C) => (Yy = n.dynCall_ii = fe.Dc)(S, C), II = n.dynCall_vii = (S, C, D) => (II = n.dynCall_vii = fe.Ec)(S, C, D), MI = n.dynCall_iiii = (S, C, D, P) => (MI = n.dynCall_iiii = fe.Fc)(S, C, D, P), DI = n.dynCall_viii = (S, C, D, P) => (DI = n.dynCall_viii = fe.Gc)(S, C, D, P), EI = n.dynCall_iiiii = (S, C, D, P, R) => (EI = n.dynCall_iiiii = fe.Hc)(S, C, D, P, R), kI = n.dynCall_viiii = (S, C, D, P, R) => (kI = n.dynCall_viiii = fe.Ic)(S, C, D, P, R), PI = n.dynCall_viiiiii = (S, C, D, P, R, W, q) => (PI = n.dynCall_viiiiii = fe.Jc)(S, C, D, P, R, W, q), LI = n.dynCall_viiiiiii = (S, C, D, P, R, W, q, J) => (LI = n.dynCall_viiiiiii = fe.Kc)(S, C, D, P, R, W, q, J), $I = n.dynCall_ji = (S, C) => ($I = n.dynCall_ji = fe.Lc)(S, C), RI = n.dynCall_v = (S) => (RI = n.dynCall_v = fe.Mc)(S), OI = n.dynCall_viiiii = (S, C, D, P, R, W) => (OI = n.dynCall_viiiii = fe.Nc)(S, C, D, P, R, W), NI = n.dynCall_i = (S) => (NI = n.dynCall_i = fe.Oc)(S), BI = n.dynCall_fii = (S, C, D) => (BI = n.dynCall_fii = fe.Pc)(S, C, D), zI = n.dynCall_viiiiiiii = (S, C, D, P, R, W, q, J, ie) => (zI = n.dynCall_viiiiiiii = fe.Qc)(S, C, D, P, R, W, q, J, ie), FI = n.dynCall_viiiiiiiiii = (S, C, D, P, R, W, q, J, ie, de, Ae) => (FI = n.dynCall_viiiiiiiiii = fe.Rc)(S, C, D, P, R, W, q, J, ie, de, Ae), VI = n.dynCall_jiii = (S, C, D, P) => (VI = n.dynCall_jiii = fe.Sc)(S, C, D, P), GI = n.dynCall_dii = (S, C, D) => (GI = n.dynCall_dii = fe.Tc)(S, C, D), WI = n.dynCall_viiiiiiiii = (S, C, D, P, R, W, q, J, ie, de) => (WI = n.dynCall_viiiiiiiii = fe.Uc)(S, C, D, P, R, W, q, J, ie, de), HI = n.dynCall_viiiiiiiiiii = (S, C, D, P, R, W, q, J, ie, de, Ae, He) => (HI = n.dynCall_viiiiiiiiiii = fe.Vc)(S, C, D, P, R, W, q, J, ie, de, Ae, He), UI = n.dynCall_iiiiii = (S, C, D, P, R, W) => (UI = n.dynCall_iiiiii = fe.Wc)(S, C, D, P, R, W), YI = n.dynCall_iij = (S, C, D) => (YI = n.dynCall_iij = fe.Xc)(S, C, D), qI = n.dynCall_iiiiiiiiii = (S, C, D, P, R, W, q, J, ie, de) => (qI = n.dynCall_iiiiiiiiii = fe.Yc)(S, C, D, P, R, W, q, J, ie, de), XI = n.dynCall_iiiiiiiiiii = (S, C, D, P, R, W, q, J, ie, de, Ae) => (XI = n.dynCall_iiiiiiiiiii = fe.Zc)(S, C, D, P, R, W, q, J, ie, de, Ae), jI = n.dynCall_vij = (S, C, D) => (jI = n.dynCall_vij = fe._c)(S, C, D), KI = n.dynCall_iiif = (S, C, D, P) => (KI = n.dynCall_iiif = fe.$c)(S, C, D, P), ZI = n.dynCall_iiij = (S, C, D, P) => (ZI = n.dynCall_iiij = fe.ad)(S, C, D, P), QI = n.dynCall_fiii = (S, C, D, P) => (QI = n.dynCall_fiii = fe.bd)(S, C, D, P), JI = n.dynCall_viiiiiiiiiiiii = (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt) => (JI = n.dynCall_viiiiiiiiiiiii = fe.cd)(S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt), eM = n.dynCall_vjiii = (S, C, D, P, R) => (eM = n.dynCall_vjiii = fe.dd)(S, C, D, P, R), tM = n.dynCall_vif = (S, C, D) => (tM = n.dynCall_vif = fe.ed)(S, C, D), rM = n.dynCall_iiiiiii = (S, C, D, P, R, W, q) => (rM = n.dynCall_iiiiiii = fe.fd)(S, C, D, P, R, W, q), nM = n.dynCall_iiiij = (S, C, D, P, R) => (nM = n.dynCall_iiiij = fe.gd)(S, C, D, P, R), iM = n.dynCall_iiiiiiii = (S, C, D, P, R, W, q, J) => (iM = n.dynCall_iiiiiiii = fe.hd)(S, C, D, P, R, W, q, J), aM = n.dynCall_viiiiiiiiiiii = (S, C, D, P, R, W, q, J, ie, de, Ae, He, ut) => (aM = n.dynCall_viiiiiiiiiiii = fe.id)(S, C, D, P, R, W, q, J, ie, de, Ae, He, ut), oM = n.dynCall_diii = (S, C, D, P) => (oM = n.dynCall_diii = fe.jd)(S, C, D, P), sM = n.dynCall_jiiii = (S, C, D, P, R) => (sM = n.dynCall_jiiii = fe.kd)(S, C, D, P, R), lM = n.dynCall_viiij = (S, C, D, P, R) => (lM = n.dynCall_viiij = fe.ld)(S, C, D, P, R), uM = n.dynCall_fiiii = (S, C, D, P, R) => (uM = n.dynCall_fiiii = fe.md)(S, C, D, P, R), cM = n.dynCall_viiif = (S, C, D, P, R) => (cM = n.dynCall_viiif = fe.nd)(S, C, D, P, R), hM = n.dynCall_diiii = (S, C, D, P, R) => (hM = n.dynCall_diiii = fe.od)(S, C, D, P, R), fM = n.dynCall_viiid = (S, C, D, P, R) => (fM = n.dynCall_viiid = fe.pd)(S, C, D, P, R), dM = n.dynCall_iiiijii = (S, C, D, P, R, W, q) => (dM = n.dynCall_iiiijii = fe.qd)(S, C, D, P, R, W, q), pM = n.dynCall_iiiiiij = (S, C, D, P, R, W, q) => (pM = n.dynCall_iiiiiij = fe.rd)(S, C, D, P, R, W, q), vM = (S) => (vM = fe.sd)(S), gM = () => (gM = fe.td)(), mM = (S) => (mM = fe.ud)(S), yM = () => (yM = fe.vd)();
      function ZX(S, C, D) {
        var P = nt();
        try {
          II(S, C, D);
        } catch (R) {
          if (tt(P), R !== R + 0) throw R;
          lt(1, 0);
        }
      }
      function QX(S, C, D) {
        var P = nt();
        try {
          return CI(S, C, D);
        } catch (R) {
          if (tt(P), R !== R + 0) throw R;
          lt(1, 0);
        }
      }
      function JX(S, C) {
        var D = nt();
        try {
          AI(S, C);
        } catch (P) {
          if (tt(D), P !== P + 0) throw P;
          lt(1, 0);
        }
      }
      function ej(S, C) {
        var D = nt();
        try {
          return Yy(S, C);
        } catch (P) {
          if (tt(D), P !== P + 0) throw P;
          lt(1, 0);
        }
      }
      function tj(S, C, D, P) {
        var R = nt();
        try {
          return MI(S, C, D, P);
        } catch (W) {
          if (tt(R), W !== W + 0) throw W;
          lt(1, 0);
        }
      }
      function rj(S, C, D, P, R) {
        var W = nt();
        try {
          kI(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function nj(S, C, D, P, R) {
        var W = nt();
        try {
          return EI(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function ij(S, C, D, P) {
        var R = nt();
        try {
          DI(S, C, D, P);
        } catch (W) {
          if (tt(R), W !== W + 0) throw W;
          lt(1, 0);
        }
      }
      function aj(S, C, D, P, R, W, q) {
        var J = nt();
        try {
          return rM(S, C, D, P, R, W, q);
        } catch (ie) {
          if (tt(J), ie !== ie + 0) throw ie;
          lt(1, 0);
        }
      }
      function oj(S) {
        var C = nt();
        try {
          RI(S);
        } catch (D) {
          if (tt(C), D !== D + 0) throw D;
          lt(1, 0);
        }
      }
      function sj(S, C, D) {
        var P = nt();
        try {
          return YI(S, C, D);
        } catch (R) {
          if (tt(P), R !== R + 0) throw R;
          lt(1, 0);
        }
      }
      function lj(S, C, D, P, R, W) {
        var q = nt();
        try {
          OI(S, C, D, P, R, W);
        } catch (J) {
          if (tt(q), J !== J + 0) throw J;
          lt(1, 0);
        }
      }
      function uj(S, C, D) {
        var P = nt();
        try {
          jI(S, C, D);
        } catch (R) {
          if (tt(P), R !== R + 0) throw R;
          lt(1, 0);
        }
      }
      function cj(S, C, D, P, R, W, q) {
        var J = nt();
        try {
          PI(S, C, D, P, R, W, q);
        } catch (ie) {
          if (tt(J), ie !== ie + 0) throw ie;
          lt(1, 0);
        }
      }
      function hj(S, C, D, P, R, W, q, J) {
        var ie = nt();
        try {
          LI(S, C, D, P, R, W, q, J);
        } catch (de) {
          if (tt(ie), de !== de + 0) throw de;
          lt(1, 0);
        }
      }
      function fj(S, C, D, P, R, W) {
        var q = nt();
        try {
          return UI(S, C, D, P, R, W);
        } catch (J) {
          if (tt(q), J !== J + 0) throw J;
          lt(1, 0);
        }
      }
      function dj(S, C, D, P, R, W, q, J) {
        var ie = nt();
        try {
          return iM(S, C, D, P, R, W, q, J);
        } catch (de) {
          if (tt(ie), de !== de + 0) throw de;
          lt(1, 0);
        }
      }
      function pj(S, C, D, P, R, W, q, J, ie, de) {
        var Ae = nt();
        try {
          WI(S, C, D, P, R, W, q, J, ie, de);
        } catch (He) {
          if (tt(Ae), He !== He + 0) throw He;
          lt(1, 0);
        }
      }
      function vj(S, C, D, P, R, W, q, J, ie) {
        var de = nt();
        try {
          zI(S, C, D, P, R, W, q, J, ie);
        } catch (Ae) {
          if (tt(de), Ae !== Ae + 0) throw Ae;
          lt(1, 0);
        }
      }
      function gj(S) {
        var C = nt();
        try {
          return NI(S);
        } catch (D) {
          if (tt(C), D !== D + 0) throw D;
          lt(1, 0);
        }
      }
      function mj(S, C, D, P, R, W, q, J, ie, de) {
        var Ae = nt();
        try {
          return qI(S, C, D, P, R, W, q, J, ie, de);
        } catch (He) {
          if (tt(Ae), He !== He + 0) throw He;
          lt(1, 0);
        }
      }
      function yj(S, C, D) {
        var P = nt();
        try {
          return BI(S, C, D);
        } catch (R) {
          if (tt(P), R !== R + 0) throw R;
          lt(1, 0);
        }
      }
      function _j(S, C, D, P) {
        var R = nt();
        try {
          return VI(S, C, D, P);
        } catch (W) {
          if (tt(R), W !== W + 0) throw W;
          return lt(1, 0), 0n;
        }
      }
      function bj(S, C, D) {
        var P = nt();
        try {
          return GI(S, C, D);
        } catch (R) {
          if (tt(P), R !== R + 0) throw R;
          lt(1, 0);
        }
      }
      function xj(S, C, D, P, R, W, q, J, ie, de, Ae, He) {
        var ut = nt();
        try {
          HI(S, C, D, P, R, W, q, J, ie, de, Ae, He);
        } catch (Qt) {
          if (tt(ut), Qt !== Qt + 0) throw Qt;
          lt(1, 0);
        }
      }
      function wj(S, C, D, P, R, W, q, J, ie, de, Ae) {
        var He = nt();
        try {
          FI(S, C, D, P, R, W, q, J, ie, de, Ae);
        } catch (ut) {
          if (tt(He), ut !== ut + 0) throw ut;
          lt(1, 0);
        }
      }
      function Sj(S, C, D, P, R, W, q, J, ie, de, Ae) {
        var He = nt();
        try {
          return XI(S, C, D, P, R, W, q, J, ie, de, Ae);
        } catch (ut) {
          if (tt(He), ut !== ut + 0) throw ut;
          lt(1, 0);
        }
      }
      function Tj(S, C, D, P) {
        var R = nt();
        try {
          return KI(S, C, D, P);
        } catch (W) {
          if (tt(R), W !== W + 0) throw W;
          lt(1, 0);
        }
      }
      function Cj(S, C, D, P) {
        var R = nt();
        try {
          return ZI(S, C, D, P);
        } catch (W) {
          if (tt(R), W !== W + 0) throw W;
          lt(1, 0);
        }
      }
      function Aj(S, C, D, P) {
        var R = nt();
        try {
          return QI(S, C, D, P);
        } catch (W) {
          if (tt(R), W !== W + 0) throw W;
          lt(1, 0);
        }
      }
      function Ij(S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt) {
        var ei = nt();
        try {
          JI(S, C, D, P, R, W, q, J, ie, de, Ae, He, ut, Qt);
        } catch (ih) {
          if (tt(ei), ih !== ih + 0) throw ih;
          lt(1, 0);
        }
      }
      function Mj(S, C, D, P, R) {
        var W = nt();
        try {
          eM(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function Dj(S, C, D) {
        var P = nt();
        try {
          tM(S, C, D);
        } catch (R) {
          if (tt(P), R !== R + 0) throw R;
          lt(1, 0);
        }
      }
      function Ej(S, C) {
        var D = nt();
        try {
          return $I(S, C);
        } catch (P) {
          if (tt(D), P !== P + 0) throw P;
          return lt(1, 0), 0n;
        }
      }
      function kj(S, C, D, P, R) {
        var W = nt();
        try {
          return nM(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function Pj(S, C, D, P, R, W, q, J, ie, de, Ae, He, ut) {
        var Qt = nt();
        try {
          aM(S, C, D, P, R, W, q, J, ie, de, Ae, He, ut);
        } catch (ei) {
          if (tt(Qt), ei !== ei + 0) throw ei;
          lt(1, 0);
        }
      }
      function Lj(S, C, D, P) {
        var R = nt();
        try {
          return oM(S, C, D, P);
        } catch (W) {
          if (tt(R), W !== W + 0) throw W;
          lt(1, 0);
        }
      }
      function $j(S, C, D, P, R) {
        var W = nt();
        try {
          return sM(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          return lt(1, 0), 0n;
        }
      }
      function Rj(S, C, D, P, R) {
        var W = nt();
        try {
          lM(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function Oj(S, C, D, P, R) {
        var W = nt();
        try {
          return uM(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function Nj(S, C, D, P, R) {
        var W = nt();
        try {
          cM(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function Bj(S, C, D, P, R) {
        var W = nt();
        try {
          return hM(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function zj(S, C, D, P, R) {
        var W = nt();
        try {
          fM(S, C, D, P, R);
        } catch (q) {
          if (tt(W), q !== q + 0) throw q;
          lt(1, 0);
        }
      }
      function Fj(S, C, D, P, R, W, q) {
        var J = nt();
        try {
          return dM(S, C, D, P, R, W, q);
        } catch (ie) {
          if (tt(J), ie !== ie + 0) throw ie;
          lt(1, 0);
        }
      }
      function Vj(S, C, D, P, R, W, q) {
        var J = nt();
        try {
          return pM(S, C, D, P, R, W, q);
        } catch (ie) {
          if (tt(J), ie !== ie + 0) throw ie;
          lt(1, 0);
        }
      }
      return n.stackSave = () => nt(), n.stackRestore = (S) => tt(S), n.stackAlloc = (S) => Uy(S), n.setValue = function(S, C, D = "i8") {
        switch (D.endsWith("*") && (D = "*"), D) {
          case "i1":
          case "i8":
            V()[S >>> 0] = C;
            break;
          case "i16":
            G()[S >>> 1 >>> 0] = C;
            break;
          case "i32":
            U()[S >>> 2 >>> 0] = C;
            break;
          case "i64":
            L[S >>> 3] = BigInt(C);
            break;
          case "float":
            ee()[S >>> 2 >>> 0] = C;
            break;
          case "double":
            we()[S >>> 3 >>> 0] = C;
            break;
          case "*":
            Z()[S >>> 2 >>> 0] = C;
            break;
          default:
            be(`invalid type for setValue: ${D}`);
        }
      }, n.getValue = function(S, C = "i8") {
        switch (C.endsWith("*") && (C = "*"), C) {
          case "i1":
          case "i8":
            return V()[S >>> 0];
          case "i16":
            return G()[S >>> 1 >>> 0];
          case "i32":
            return U()[S >>> 2 >>> 0];
          case "i64":
            return L[S >>> 3];
          case "float":
            return ee()[S >>> 2 >>> 0];
          case "double":
            return we()[S >>> 3 >>> 0];
          case "*":
            return Z()[S >>> 2 >>> 0];
          default:
            be(`invalid type for getValue: ${C}`);
        }
      }, n.UTF8ToString = pr, n.stringToUTF8 = gu, n.lengthBytesUTF8 = DA, function S() {
        if (0 < Se) Qe = S;
        else if (s) e(n), ye();
        else {
          for (; 0 < jt.length; ) jt.shift()(n);
          0 < Se ? Qe = S : (n.calledRun = true, O || (ye(), e(n)));
        }
      }(), n.PTR_SIZE = 4, i;
    }), IU = wb, SR = (_b2 = (_a2 = globalThis.self) == null ? void 0 : _a2.name) == null ? void 0 : _b2.startsWith("em-pthread"), SR && wb();
  }), Sb, TR, Fn, MU, gv, CR, AR, Tb, IR, Cb, DU, Ab, EU, tC = ge(() => {
    eC(), Sb = typeof location > "u" ? void 0 : location.origin, TR = () => {
      var _a2;
      return ((_a2 = import.meta.url) == null ? void 0 : _a2.startsWith("file:")) ? new URL(new URL("/assets/ort.bundle.min-OfoG_cy9.mjs", import.meta.url).href, Sb).href : import.meta.url;
    }, Fn = TR(), MU = () => {
      if (Fn && !Fn.startsWith("blob:")) return Fn.substring(0, Fn.lastIndexOf("/") + 1);
    }, gv = (t, e) => {
      try {
        let r = e ?? Fn;
        return (r ? new URL(t, r) : new URL(t)).origin === Sb;
      } catch {
        return false;
      }
    }, CR = (t, e) => {
      let r = e ?? Fn;
      try {
        return (r ? new URL(t, r) : new URL(t)).href;
      } catch {
        return;
      }
    }, AR = (t, e) => `${e ?? "./"}${t}`, Tb = async (t) => {
      let e = await (await fetch(t, {
        credentials: "same-origin"
      })).blob();
      return URL.createObjectURL(e);
    }, IR = async (t) => (await import(t).then(async (m) => {
      await m.__tla;
      return m;
    })).default, Cb = (Aye(), vm(TU)).default, DU = async () => {
      if (!Fn) throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
      if (gv(Fn)) return [
        void 0,
        Cb()
      ];
      let t = await Tb(Fn);
      return [
        t,
        Cb(t)
      ];
    }, Ab = (Iye(), vm(AU)).default, EU = async (t, e, r) => {
      if (!t && !e && Ab && Fn && gv(Fn)) return [
        void 0,
        Ab
      ];
      {
        let n = "ort-wasm-simd-threaded.jsep.mjs", i = t ?? CR(n, e), a = r && i && !gv(i, e), o = a ? await Tb(i) : i ?? AR(n, e);
        return [
          a ? o : void 0,
          await IR(o)
        ];
      }
    };
  }), Ib, mv, Rh, Mb, MR, DR, rC, Cr, hu = ge(() => {
    tC(), mv = false, Rh = false, Mb = false, MR = () => {
      if (typeof SharedArrayBuffer > "u") return false;
      try {
        return typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          4,
          1,
          96,
          0,
          0,
          3,
          2,
          1,
          0,
          5,
          4,
          1,
          3,
          1,
          1,
          10,
          11,
          1,
          9,
          0,
          65,
          0,
          254,
          16,
          2,
          0,
          26,
          11
        ]));
      } catch {
        return false;
      }
    }, DR = () => {
      try {
        return WebAssembly.validate(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          4,
          1,
          96,
          0,
          0,
          3,
          2,
          1,
          0,
          10,
          30,
          1,
          28,
          0,
          65,
          0,
          253,
          15,
          253,
          12,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          253,
          186,
          1,
          26,
          11
        ]));
      } catch {
        return false;
      }
    }, rC = async (t) => {
      if (mv) return Promise.resolve();
      if (Rh) throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
      if (Mb) throw new Error("previous call to 'initializeWebAssembly()' failed.");
      Rh = true;
      let e = t.initTimeout, r = t.numThreads;
      if (!DR()) throw new Error("WebAssembly SIMD is not supported in the current environment.");
      let n = MR();
      r > 1 && !n && (typeof self < "u" && !self.crossOriginIsolated && console.warn("env.wasm.numThreads is set to " + r + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."), console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."), t.numThreads = r = 1);
      let i = t.wasmPaths, a = typeof i == "string" ? i : void 0, o = i == null ? void 0 : i.mjs, s = (o == null ? void 0 : o.href) ?? o, l = i == null ? void 0 : i.wasm, u = (l == null ? void 0 : l.href) ?? l, c = t.wasmBinary, [h, f] = await EU(s, a, r > 1), d = false, p = [];
      if (e > 0 && p.push(new Promise((v) => {
        setTimeout(() => {
          d = true, v();
        }, e);
      })), p.push(new Promise((v, g) => {
        let m = {
          numThreads: r
        };
        if (c) m.wasmBinary = c;
        else if (u || a) m.locateFile = (y) => u ?? a + y;
        else if (s && s.indexOf("blob:") !== 0) m.locateFile = (y) => new URL(y, s).href;
        else if (h) {
          let y = MU();
          y && (m.locateFile = (_) => y + _);
        }
        f(m).then((y) => {
          Rh = false, mv = true, Ib = y, v(), h && URL.revokeObjectURL(h);
        }, (y) => {
          Rh = false, Mb = true, g(y);
        });
      })), await Promise.race(p), d) throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`);
    }, Cr = () => {
      if (mv && Ib) return Ib;
      throw new Error("WebAssembly is not initialized yet.");
    };
  }), Wr, mm, Lt, nC = ge(() => {
    hu(), Wr = (t, e) => {
      let r = Cr(), n = r.lengthBytesUTF8(t) + 1, i = r._malloc(n);
      return r.stringToUTF8(t, i, n), e.push(i), i;
    }, mm = (t, e, r, n) => {
      if (typeof t == "object" && t !== null) {
        if (r.has(t)) throw new Error("Circular reference in options");
        r.add(t);
      }
      Object.entries(t).forEach(([i, a]) => {
        let o = e ? e + i : i;
        if (typeof a == "object") mm(a, o + ".", r, n);
        else if (typeof a == "string" || typeof a == "number") n(o, a.toString());
        else if (typeof a == "boolean") n(o, a ? "1" : "0");
        else throw new Error(`Can't handle extra config type: ${typeof a}`);
      });
    }, Lt = (t) => {
      let e = Cr(), r = e.stackSave();
      try {
        let n = e.PTR_SIZE, i = e.stackAlloc(2 * n);
        e._OrtGetLastError(i, i + n);
        let a = Number(e.getValue(i, n === 4 ? "i32" : "i64")), o = e.getValue(i + n, "*"), s = o ? e.UTF8ToString(o) : "";
        throw new Error(`${t} ERROR_CODE: ${a}, ERROR_MESSAGE: ${s}`);
      } finally {
        e.stackRestore(r);
      }
    };
  }), kU, Mye = ge(() => {
    hu(), nC(), kU = (t) => {
      let e = Cr(), r = 0, n = [], i = t || {};
      try {
        if ((t == null ? void 0 : t.logSeverityLevel) === void 0) i.logSeverityLevel = 2;
        else if (typeof t.logSeverityLevel != "number" || !Number.isInteger(t.logSeverityLevel) || t.logSeverityLevel < 0 || t.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);
        if ((t == null ? void 0 : t.logVerbosityLevel) === void 0) i.logVerbosityLevel = 0;
        else if (typeof t.logVerbosityLevel != "number" || !Number.isInteger(t.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);
        (t == null ? void 0 : t.terminate) === void 0 && (i.terminate = false);
        let a = 0;
        return (t == null ? void 0 : t.tag) !== void 0 && (a = Wr(t.tag, n)), r = e._OrtCreateRunOptions(i.logSeverityLevel, i.logVerbosityLevel, !!i.terminate, a), r === 0 && Lt("Can't create run options."), (t == null ? void 0 : t.extra) !== void 0 && mm(t.extra, "", /* @__PURE__ */ new WeakSet(), (o, s) => {
          let l = Wr(o, n), u = Wr(s, n);
          e._OrtAddRunConfigEntry(r, l, u) !== 0 && Lt(`Can't set a run config entry: ${o} - ${s}.`);
        }), [
          r,
          n
        ];
      } catch (a) {
        throw r !== 0 && e._OrtReleaseRunOptions(r), n.forEach((o) => e._free(o)), a;
      }
    };
  }), ER, kR, PR, LR, PU, Dye = ge(() => {
    hu(), nC(), ER = (t) => {
      switch (t) {
        case "disabled":
          return 0;
        case "basic":
          return 1;
        case "extended":
          return 2;
        case "all":
          return 99;
        default:
          throw new Error(`unsupported graph optimization level: ${t}`);
      }
    }, kR = (t) => {
      switch (t) {
        case "sequential":
          return 0;
        case "parallel":
          return 1;
        default:
          throw new Error(`unsupported execution mode: ${t}`);
      }
    }, PR = (t) => {
      t.extra || (t.extra = {}), t.extra.session || (t.extra.session = {});
      let e = t.extra.session;
      e.use_ort_model_bytes_directly || (e.use_ort_model_bytes_directly = "1"), t.executionProviders && t.executionProviders.some((r) => (typeof r == "string" ? r : r.name) === "webgpu") && (t.enableMemPattern = false);
    }, LR = (t, e, r) => {
      for (let n of e) {
        let i = typeof n == "string" ? n : n.name;
        switch (i) {
          case "webnn":
            if (i = "WEBNN", typeof n != "string") {
              let o = n == null ? void 0 : n.deviceType;
              if (o) {
                let s = Wr("deviceType", r), l = Wr(o, r);
                Cr()._OrtAddSessionConfigEntry(t, s, l) !== 0 && Lt(`Can't set a session config entry: 'deviceType' - ${o}.`);
              }
            }
            break;
          case "webgpu":
            if (i = "JS", typeof n != "string") {
              let o = n;
              if (o == null ? void 0 : o.preferredLayout) {
                if (o.preferredLayout !== "NCHW" && o.preferredLayout !== "NHWC") throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${o.preferredLayout}`);
                let s = Wr("preferredLayout", r), l = Wr(o.preferredLayout, r);
                Cr()._OrtAddSessionConfigEntry(t, s, l) !== 0 && Lt(`Can't set a session config entry: 'preferredLayout' - ${o.preferredLayout}.`);
              }
            }
            break;
          case "wasm":
          case "cpu":
            continue;
          default:
            throw new Error(`not supported execution provider: ${i}`);
        }
        let a = Wr(i, r);
        Cr()._OrtAppendExecutionProvider(t, a) !== 0 && Lt(`Can't append execution provider: ${i}.`);
      }
    }, PU = (t) => {
      let e = Cr(), r = 0, n = [], i = t || {};
      PR(i);
      try {
        let a = ER(i.graphOptimizationLevel ?? "all"), o = kR(i.executionMode ?? "sequential"), s = typeof i.logId == "string" ? Wr(i.logId, n) : 0, l = i.logSeverityLevel ?? 2;
        if (!Number.isInteger(l) || l < 0 || l > 4) throw new Error(`log serverity level is not valid: ${l}`);
        let u = i.logVerbosityLevel ?? 0;
        if (!Number.isInteger(u) || u < 0 || u > 4) throw new Error(`log verbosity level is not valid: ${u}`);
        let c = typeof i.optimizedModelFilePath == "string" ? Wr(i.optimizedModelFilePath, n) : 0;
        if (r = e._OrtCreateSessionOptions(a, !!i.enableCpuMemArena, !!i.enableMemPattern, o, !!i.enableProfiling, 0, s, l, u, c), r === 0 && Lt("Can't create session options."), i.executionProviders && LR(r, i.executionProviders, n), i.enableGraphCapture !== void 0) {
          if (typeof i.enableGraphCapture != "boolean") throw new Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);
          let h = Wr("enableGraphCapture", n), f = Wr(i.enableGraphCapture.toString(), n);
          e._OrtAddSessionConfigEntry(r, h, f) !== 0 && Lt(`Can't set a session config entry: 'enableGraphCapture' - ${i.enableGraphCapture}.`);
        }
        if (i.freeDimensionOverrides) for (let [h, f] of Object.entries(i.freeDimensionOverrides)) {
          if (typeof h != "string") throw new Error(`free dimension override name must be a string: ${h}`);
          if (typeof f != "number" || !Number.isInteger(f) || f < 0) throw new Error(`free dimension override value must be a non-negative integer: ${f}`);
          let d = Wr(h, n);
          e._OrtAddFreeDimensionOverride(r, d, f) !== 0 && Lt(`Can't set a free dimension override: ${h} - ${f}.`);
        }
        return i.extra !== void 0 && mm(i.extra, "", /* @__PURE__ */ new WeakSet(), (h, f) => {
          let d = Wr(h, n), p = Wr(f, n);
          e._OrtAddSessionConfigEntry(r, d, p) !== 0 && Lt(`Can't set a session config entry: ${h} - ${f}.`);
        }), [
          r,
          n
        ];
      } catch (a) {
        throw r !== 0 && e._OrtReleaseSessionOptions(r) !== 0 && Lt("Can't release session options."), n.forEach((o) => e._free(o)), a;
      }
    };
  }), Ku, bl, xl, iC, ym, aC, oC, Ww, Je = ge(() => {
    Ku = (t) => {
      switch (t) {
        case "int8":
          return 3;
        case "uint8":
          return 2;
        case "bool":
          return 9;
        case "int16":
          return 5;
        case "uint16":
          return 4;
        case "int32":
          return 6;
        case "uint32":
          return 12;
        case "float16":
          return 10;
        case "float32":
          return 1;
        case "float64":
          return 11;
        case "string":
          return 8;
        case "int64":
          return 7;
        case "uint64":
          return 13;
        case "int4":
          return 22;
        case "uint4":
          return 21;
        default:
          throw new Error(`unsupported data type: ${t}`);
      }
    }, bl = (t) => {
      switch (t) {
        case 3:
          return "int8";
        case 2:
          return "uint8";
        case 9:
          return "bool";
        case 5:
          return "int16";
        case 4:
          return "uint16";
        case 6:
          return "int32";
        case 12:
          return "uint32";
        case 10:
          return "float16";
        case 1:
          return "float32";
        case 11:
          return "float64";
        case 8:
          return "string";
        case 7:
          return "int64";
        case 13:
          return "uint64";
        case 22:
          return "int4";
        case 21:
          return "uint4";
        default:
          throw new Error(`unsupported data type: ${t}`);
      }
    }, xl = (t, e) => {
      let r = [
        -1,
        4,
        1,
        1,
        2,
        2,
        4,
        8,
        -1,
        1,
        2,
        8,
        4,
        8,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0.5,
        0.5
      ][t], n = typeof e == "number" ? e : e.reduce((i, a) => i * a, 1);
      return r > 0 ? Math.ceil(n * r) : void 0;
    }, iC = (t) => {
      switch (t) {
        case "float16":
          return typeof Float16Array < "u" && Float16Array.from ? Float16Array : Uint16Array;
        case "float32":
          return Float32Array;
        case "uint8":
          return Uint8Array;
        case "int8":
          return Int8Array;
        case "uint16":
          return Uint16Array;
        case "int16":
          return Int16Array;
        case "int32":
          return Int32Array;
        case "bool":
          return Uint8Array;
        case "float64":
          return Float64Array;
        case "uint32":
          return Uint32Array;
        case "int64":
          return BigInt64Array;
        case "uint64":
          return BigUint64Array;
        default:
          throw new Error(`unsupported type: ${t}`);
      }
    }, ym = (t) => {
      switch (t) {
        case "verbose":
          return 0;
        case "info":
          return 1;
        case "warning":
          return 2;
        case "error":
          return 3;
        case "fatal":
          return 4;
        default:
          throw new Error(`unsupported logging level: ${t}`);
      }
    }, aC = (t) => t === "float32" || t === "float16" || t === "int32" || t === "int64" || t === "uint32" || t === "uint8" || t === "bool" || t === "uint4" || t === "int4", oC = (t) => t === "float32" || t === "float16" || t === "int32" || t === "int64" || t === "uint32" || t === "uint64" || t === "int8" || t === "uint8" || t === "bool" || t === "uint4" || t === "int4", Ww = (t) => {
      switch (t) {
        case "none":
          return 0;
        case "cpu":
          return 1;
        case "cpu-pinned":
          return 2;
        case "texture":
          return 3;
        case "gpu-buffer":
          return 4;
        case "ml-tensor":
          return 5;
        default:
          throw new Error(`unsupported data location: ${t}`);
      }
    };
  }), sC, LU = ge(() => {
    eC(), sC = async (t) => {
      if (typeof t == "string") {
        let e = await fetch(t);
        if (!e.ok) throw new Error(`failed to load external data file: ${t}`);
        let r = e.headers.get("Content-Length"), n = r ? parseInt(r, 10) : 0;
        if (n < 1073741824) return new Uint8Array(await e.arrayBuffer());
        {
          if (!e.body) throw new Error(`failed to load external data file: ${t}, no response body.`);
          let i = e.body.getReader(), a;
          try {
            a = new ArrayBuffer(n);
          } catch (s) {
            if (s instanceof RangeError) {
              let l = Math.ceil(n / 65536);
              a = new WebAssembly.Memory({
                initial: l,
                maximum: l
              }).buffer;
            } else throw s;
          }
          let o = 0;
          for (; ; ) {
            let { done: s, value: l } = await i.read();
            if (s) break;
            let u = l.byteLength;
            new Uint8Array(a, o, u).set(l), o += u;
          }
          return new Uint8Array(a, 0, n);
        }
      } else return t instanceof Blob ? new Uint8Array(await t.arrayBuffer()) : t instanceof Uint8Array ? t : new Uint8Array(t);
    };
  }), $R, RR, OR, NR, lC, BR, Mt, To = ge(() => {
    Je(), $R = [
      "V",
      "I",
      "W",
      "E",
      "F"
    ], RR = (t, e) => {
      console.log(`[${$R[t]},${(/* @__PURE__ */ new Date()).toISOString()}]${e}`);
    }, lC = (t, e) => {
      OR = t, NR = e;
    }, BR = (t, e) => {
      let r = ym(t), n = ym(OR);
      r >= n && RR(r, typeof e == "function" ? e() : e);
    }, Mt = (...t) => {
      NR && BR(...t);
    };
  }), uC, $U = ge(() => {
    Je(), uC = (t, e) => new (iC(e))(t);
  }), cC = ge(() => {
  }), Db, yv, _v, zR, FR, Eb, Hw, VR, RU, Eye = ge(() => {
    To(), cC(), Db = /* @__PURE__ */ new Map([
      [
        64,
        250
      ],
      [
        128,
        200
      ],
      [
        256,
        200
      ],
      [
        512,
        200
      ],
      [
        2048,
        230
      ],
      [
        4096,
        200
      ],
      [
        8192,
        50
      ],
      [
        16384,
        50
      ],
      [
        32768,
        50
      ],
      [
        65536,
        50
      ],
      [
        131072,
        50
      ],
      [
        262144,
        50
      ],
      [
        524288,
        50
      ],
      [
        1048576,
        50
      ],
      [
        2097152,
        30
      ],
      [
        4194304,
        20
      ],
      [
        8388608,
        10
      ],
      [
        12582912,
        10
      ],
      [
        16777216,
        10
      ],
      [
        26214400,
        15
      ],
      [
        33554432,
        22
      ],
      [
        44236800,
        2
      ],
      [
        58982400,
        6
      ],
      [
        67108864,
        6
      ],
      [
        134217728,
        6
      ],
      [
        167772160,
        6
      ]
    ]), yv = [], _v = (t) => Math.ceil(Number(t) / 16) * 16, zR = (t) => {
      for (let e = 0; e < yv.length; e++) {
        let r = yv[e];
        if (t <= r) return r;
      }
      return Math.ceil(t / 16) * 16;
    }, FR = 1, Eb = () => FR++, Hw = async (t, e, r, n) => {
      let i = _v(r), a = t.device.createBuffer({
        size: i,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      });
      try {
        let o = t.getCommandEncoder();
        t.endComputePass(), o.copyBufferToBuffer(e, 0, a, 0, i), t.flush(), await a.mapAsync(GPUMapMode.READ);
        let s = a.getMappedRange();
        if (n) {
          let l = n();
          return l.set(new Uint8Array(s, 0, r)), l;
        } else return new Uint8Array(s.slice(0, r));
      } finally {
        a.destroy();
      }
    }, VR = class {
      constructor(t) {
        this.backend = t, this.storageCache = /* @__PURE__ */ new Map(), this.freeBuffers = /* @__PURE__ */ new Map(), this.freeUniformBuffers = /* @__PURE__ */ new Map(), this.buffersPending = [], this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        for (let [e] of Db) yv.push(e), this.freeBuffers.set(e, []), this.freeUniformBuffers.set(e, []);
        this.sessionCount = 0;
      }
      upload(t, e) {
        let r = e.buffer, n = e.byteOffset, i = e.byteLength, a = _v(i), o = this.storageCache.get(t);
        if (!o) throw new Error("gpu data for uploading does not exist");
        if (Number(o.originalSize) !== i) throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${i}`);
        let s = this.backend.device.createBuffer({
          mappedAtCreation: true,
          size: a,
          usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
        }), l = s.getMappedRange();
        new Uint8Array(l).set(new Uint8Array(r, n, i)), s.unmap();
        let u = this.backend.device.createCommandEncoder();
        u.copyBufferToBuffer(s, 0, o.gpuData.buffer, 0, a), this.backend.device.queue.submit([
          u.finish()
        ]), s.destroy(), Mt("verbose", () => `[WebGPU] GpuDataManager.upload(id=${t})`);
      }
      memcpy(t, e) {
        let r = this.storageCache.get(t);
        if (!r) throw new Error("source gpu data for memcpy does not exist");
        let n = this.storageCache.get(e);
        if (!n) throw new Error("destination gpu data for memcpy does not exist");
        if (r.originalSize !== n.originalSize) throw new Error("inconsistent source and destination gpu data size");
        let i = _v(r.originalSize), a = this.backend.getCommandEncoder();
        this.backend.endComputePass(), a.copyBufferToBuffer(r.gpuData.buffer, 0, n.gpuData.buffer, 0, i);
      }
      registerExternalBuffer(t, e, r) {
        let n;
        if (r) {
          if (n = r[0], t === r[1]) return Mt("verbose", () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${n}, buffer is the same, skip.`), n;
          if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
        } else n = Eb();
        return this.storageCache.set(n, {
          gpuData: {
            id: n,
            type: 0,
            buffer: t
          },
          originalSize: e
        }), Mt("verbose", () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${n}, registered.`), n;
      }
      unregisterExternalBuffer(t) {
        t !== void 0 && (this.storageCache.delete(t), Mt("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`));
      }
      create(t, e = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
        let r = zR(t), n, i = (e & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE, a = (e & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
        if (i || a) {
          let s = (i ? this.freeBuffers : this.freeUniformBuffers).get(r);
          s ? s.length > 0 ? n = s.pop() : n = this.backend.device.createBuffer({
            size: r,
            usage: e
          }) : n = this.backend.device.createBuffer({
            size: r,
            usage: e
          });
        } else n = this.backend.device.createBuffer({
          size: r,
          usage: e
        });
        let o = {
          id: Eb(),
          type: 0,
          buffer: n
        };
        return this.storageCache.set(o.id, {
          gpuData: o,
          originalSize: Number(t)
        }), Mt("verbose", () => `[WebGPU] GpuDataManager.create(size=${t}) => id=${o.id}`), o;
      }
      get(t) {
        var _a2;
        return (_a2 = this.storageCache.get(t)) == null ? void 0 : _a2.gpuData;
      }
      release(t) {
        let e = typeof t == "bigint" ? Number(t) : t, r = this.storageCache.get(e);
        if (!r) {
          if (this.storageCache.size === 0) return 0;
          throw new Error("releasing data does not exist");
        }
        return Mt("verbose", () => `[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${r.gpuData.id}`), this.storageCache.delete(e), this.buffersPending.push(r.gpuData.buffer), r.originalSize;
      }
      async download(t, e) {
        let r = this.storageCache.get(Number(t));
        if (!r) throw new Error("data does not exist");
        await Hw(this.backend, r.gpuData.buffer, r.originalSize, e);
      }
      refreshPendingBuffers() {
        if (this.buffersPending.length !== 0) if (this.backend.sessionStatus === "default") {
          for (let t of this.buffersPending) {
            let e = Db.get(t.size);
            if ((t.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
              let r = this.freeBuffers.get(t.size) || [];
              e === void 0 || r.length >= e ? t.destroy() : r.push(t);
            } else if ((t.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
              let r = this.freeUniformBuffers.get(t.size) || [];
              e === void 0 || r.length >= e ? t.destroy() : r.push(t);
            } else t.destroy();
          }
          this.buffersPending = [];
        } else {
          let t = this.capturedPendingBuffers.get(this.backend.currentSessionId);
          t || (t = [], this.capturedPendingBuffers.set(this.backend.currentSessionId, t));
          for (let e of this.buffersPending) t.push(e);
          this.buffersPending = [];
        }
      }
      dispose() {
        this.freeBuffers.forEach((t) => {
          t.forEach((e) => {
            e.destroy();
          });
        }), this.freeUniformBuffers.forEach((t) => {
          t.forEach((e) => {
            e.destroy();
          });
        }), this.storageCache.forEach((t) => {
          t.gpuData.buffer.destroy();
        }), this.capturedPendingBuffers.forEach((t) => {
          t.forEach((e) => {
            e.destroy();
          });
        }), this.storageCache = /* @__PURE__ */ new Map(), this.freeBuffers = /* @__PURE__ */ new Map(), this.freeUniformBuffers = /* @__PURE__ */ new Map(), this.capturedPendingBuffers = /* @__PURE__ */ new Map();
      }
      onCreateSession() {
        this.sessionCount += 1;
      }
      onReleaseSession(t) {
        let e = this.capturedPendingBuffers.get(t);
        e && (e.forEach((r) => {
          r.destroy();
        }), this.capturedPendingBuffers.delete(t)), this.sessionCount -= 1, this.sessionCount === 0 && (Mt("warning", () => "[WebGPU] Clearing webgpu buffer cache"), this.storageCache.forEach((r) => {
          r.gpuData.buffer.destroy();
        }), this.storageCache = /* @__PURE__ */ new Map());
      }
    }, RU = (...t) => new VR(...t);
  }), GR, Bt, ur = ge(() => {
    GR = class {
      constructor(t) {
        Object.assign(this, t);
      }
      get cacheKey() {
        return this.key || (this.key = Object.getOwnPropertyNames(this).sort().map((t) => `${this[t]}`).join(";")), this.key;
      }
    }, Bt = (t) => new GR(t);
  }), WR, Ic, re, _m, OU, NU, BU, ft = ge(() => {
    WR = class {
      static calcMatMulShape(t, e) {
        return t[1] !== e[0] ? void 0 : [
          t[0],
          e[1]
        ];
      }
    }, Ic = class {
      static calcShape(t, e, r = false) {
        let n = t.length, i = e.length;
        if (n === 0) return e;
        if (i === 0) return t;
        let a = Math.max(t.length, e.length), o = new Array(a);
        if (r) {
          if (n < 2 || i < 2) return;
          let s = WR.calcMatMulShape([
            t[n - 2],
            t[n - 1]
          ], [
            e[i - 2],
            e[i - 1]
          ]);
          if (s === void 0) return;
          [o[a - 2], o[a - 1]] = s;
        }
        for (let s = r ? 3 : 1; s <= a; s++) {
          let l = n - s < 0 ? 1 : t[n - s], u = i - s < 0 ? 1 : e[i - s];
          if (l !== u && l > 1 && u > 1) return;
          let c = Math.max(l, u);
          if (l && u) o[a - s] = Math.max(l, u);
          else {
            if (c > 1) return;
            o[a - s] = 0;
          }
        }
        return o;
      }
      static isValidBroadcast(t, e) {
        let r = t.length, n = e.length;
        if (r > n) return false;
        for (let i = 1; i <= r; i++) if (t[r - i] !== 1 && t[r - i] !== e[n - i]) return false;
        return true;
      }
    }, re = class gg {
      static size(e) {
        return gg.getSizeFromDimensionRange(e, 0, e.length);
      }
      static convertShape(e, r = 4) {
        let n = e.length;
        if (n === 0) return [];
        let i = new Array(n), a = n - 1;
        for (; a >= 0; ) {
          if (e[a] % r === 0) {
            i[a] = e[a] / r;
            break;
          }
          if (r % e[a] !== 0) throw new Error("cannot convert shape");
          i[a] = 1, r /= e[a], a--;
        }
        for (a--; a >= 0; a--) i[a] = e[a];
        return i;
      }
      static sizeFromDimension(e, r) {
        if (r < 0 || r > e.length) throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${e.length} dimensions.`);
        return gg.getSizeFromDimensionRange(e, r, e.length);
      }
      static sizeToDimension(e, r) {
        if (r < 0 || r > e.length) throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${e.length} dimensions.`);
        return gg.getSizeFromDimensionRange(e, 0, r);
      }
      static getSizeFromDimensionRange(e, r, n) {
        let i = 1;
        for (let a = r; a < n; a++) {
          if (e[a] < 0) throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");
          i *= Number(e[a]);
        }
        return i;
      }
      static computeStrides(e) {
        let r = e.length;
        if (r === 0) return [];
        if (r === 1) return [
          1
        ];
        let n = new Array(r);
        n[r - 1] = 1, n[r - 2] = e[r - 1];
        for (let i = r - 3; i >= 0; --i) n[i] = n[i + 1] * e[i + 1];
        return n;
      }
      static normalizeAxis(e, r) {
        if (e < -r && e >= r) throw new Error("unsupported axis for this operation.");
        return e < 0 ? e + r : e;
      }
      static normalizeAxes(e, r) {
        return e.map((n) => this.normalizeAxis(n, r ?? e.length));
      }
      static sortBasedOnPerm(e, r) {
        return r ? r.map((n) => e[n]) : e.slice().reverse();
      }
      static padShape(e, r) {
        let n = e.length;
        return e.map((i, a) => i + r[a] + r[a + n]);
      }
      static areEqual(e, r) {
        return e.length !== r.length ? false : e.every((n, i) => n === r[i]);
      }
    }, _m = class cf {
      static adjustPoolAttributes(e, r, n, i, a, o) {
        if (!e && n.length !== r.length - 2) throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
        if (e) for (let s = 0; s < r.length - 2; s++) s >= n.length ? n.push(r[s + 2]) : n[s] = r[s + 2];
        for (let s = 0; s < n.length; s++) if (s < i.length) {
          if (i[s] < 0) throw new Error("strides should be greater than or equal to 1");
        } else i.push(1);
        for (let s = 0; s < n.length; s++) if (s < a.length) {
          if (a[s] < 0) throw new Error("dilations should be greater than or equal to 1");
        } else a.push(1);
        for (let s = 0; s < n.length * 2; s++) if (s < o.length) {
          if (o[s] < 0) throw new Error("pad should be greater than or equal to 1");
        } else o.push(0);
        for (let s = 0; s < n.length; s++) {
          if (n[s] <= 0) throw new Error("kernel shapes need to be greater than 0");
          if (o[s] >= n[s] || o[s + n.length] >= n[s]) throw new Error("pads should be smaller than kernel");
        }
      }
      static adjustPadsBasedOnAutoPad(e, r, n, i, a, o, s) {
        if (s) {
          if (a.length !== 2 * (e.length - 2)) throw new Error("length of pads should be twice the length of data dimensions");
          if (r.length !== e.length - 2) throw new Error("length of strides should be the length of data dimensions");
          if (i.length !== e.length - 2) throw new Error("length of kernel shapes should be the length of data dimensions");
          for (let l = 0; l < e.length - 2; l++) cf.adjustPadAndReturnShape(e[l + (o ? 1 : 2)], r[l], n[l], i[l], a, l, l + e.length - 2, s);
        }
      }
      static computePoolOutputShape(e, r, n, i, a, o, s) {
        if (r.length <= 0) throw new Error("input shape must be of size greater than 0");
        let l = [
          r[0],
          r[1]
        ];
        return cf.computeShapeHelper(e, r, l, n, i, a, o, s), l;
      }
      static computeConvOutputShape(e, r, n, i, a, o, s) {
        if (e.length <= 0 || r.length <= 0) throw new Error("invalid input tensor dims or invalid filter tensor dims");
        let l = [
          e[0],
          r[0]
        ];
        return cf.computeShapeHelper(false, e, l, n, i, a, o, s), l;
      }
      static computeShapeHelper(e, r, n, i, a, o, s, l) {
        if (e) for (let u = 0; u < r.length - 2; u++) n.push(1);
        else for (let u = 0; u < r.length - 2; u++) n.push(cf.adjustPadAndReturnShape(r[u + 2], i[u], a[u], o[u], s, u, u + r.length - 2, l));
      }
      static adjustPadAndReturnShape(e, r, n, i, a, o, s, l) {
        let u = n * (i - 1) + 1;
        if (l && l !== "NOTSET") switch (l) {
          case "VALID":
            return a[o] = 0, a[s] = 0, Math.floor((e - u) / r + 1);
          case "SAME_LOWER":
          case "SAME_UPPER":
            if (n !== 1) throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
            {
              let c = ((e + r - 1) / r - 1) * r + i - e;
              return a[o] = Math.floor(l === "SAME_LOWER" ? (c + 1) / 2 : c / 2), a[s] = c - a[o], Math.floor((e + c - i) / r + 1);
            }
          default:
            throw new Error("Unsupported AutoPad type");
        }
        else return Math.floor((e + a[o] + a[s] - u) / r + 1);
      }
    }, OU = class {
      static getShapeOfGemmResult(t, e, r, n, i) {
        if (t.length !== 2 || r.length !== 2) throw new Error("shape need to be of size 2");
        let a, o, s;
        e ? (a = t[1], o = t[0]) : (a = t[0], o = t[1]);
        let l = -1;
        if (n ? (s = r[0], l = 1) : (s = r[1], l = 0), r[l] !== o) throw new Error("dimension mismatch");
        if (a <= 0 || s <= 0 || o <= 0) throw new Error("invalid shape specified");
        if (i && !Ic.isValidBroadcast(i, [
          a,
          s
        ])) throw new Error("gemm: invalid bias shape for broadcast");
        return [
          a,
          s,
          o
        ];
      }
    }, NU = -34028234663852886e22, BU = 34028234663852886e22;
  }), Mc, bv, kr, Jr, Ve, or, Uw, sc, ys, Ne, Oh, se, Re, zU, hC, HR, FU, mt = ge(() => {
    Je(), ft(), Mc = 64, bv = (t, e) => {
      if (e === 3) throw new Error("vec3 has same alignment as vec4, use vec4 instead");
      switch (Number(t)) {
        case 10:
          return e > 1 ? `vec${e}<f16>` : "f16";
        case 1:
          return e > 1 ? `vec${e}<f32>` : "f32";
        case 6:
          return e > 1 ? `vec${e}<i32>` : "i32";
        case 12:
          return e > 1 ? `vec${e}<u32>` : "u32";
        case 7:
          if (e > 1) throw new Error("currently not supported vecX of uint64 yet");
          return [
            "vec2<u32>",
            "i32"
          ];
        case 13:
          if (e > 1) throw new Error("currently not supported vecX of uint64 yet");
          return [
            "vec2<u32>",
            "u32"
          ];
        case 9:
          if (e !== 4) throw new Error("bool must be vec4");
          return [
            "u32",
            "vec4<bool>"
          ];
        case 22:
          return "i32";
        case 21:
          return "u32";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    }, kr = (t, e = 1) => {
      let r = bv(t, e);
      return typeof r == "string" ? r : r[0];
    }, Jr = (t, e = 1) => {
      let r = bv(t, e);
      return typeof r == "string" ? r : r[1];
    }, Ve = (...t) => {
      let e = [];
      return t.forEach((r) => {
        r.length !== 0 && e.push({
          type: 12,
          data: r
        }, {
          type: 12,
          data: re.computeStrides(r)
        });
      }), e;
    }, or = (t) => t % 4 === 0 ? 4 : t % 2 === 0 ? 2 : 1, Uw = (t = "f32", e, r = "0") => !e || e === 1 ? `${t}(${r})` : `vec${e}<${t}>(${r})`, sc = (t, e, r) => t === "f32" ? r : e === 1 ? `f32(${r})` : `vec${e}<f32>(${r})`, ys = (t, e) => e === 4 ? `(${t}.x + ${t}.y + ${t}.z + ${t}.w)` : e === 2 ? `(${t}.x + ${t}.y)` : e === 3 ? `(${t}.x + ${t}.y + ${t}.z)` : t, Ne = (t, e, r, n) => t.startsWith("uniforms.") && r > 4 ? typeof e == "string" ? n === "f16" ? `${t}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]` : `${t}[(${e}) / 4][(${e}) % 4]` : n === "f16" ? `${t}[${Math.floor(e / 8)}][${Math.floor(e % 8 / 4)}][${e % 8 % 4}]` : `${t}[${Math.floor(e / 4)}][${e % 4}]` : r > 1 ? `${t}[${e}]` : t, Oh = (t, e, r, n, i) => {
      let a = typeof r == "number", o = a ? r : r.length, s = [
        ...new Array(o).keys()
      ], l = o < 2 ? "u32" : o <= 4 ? `vec${o}<u32>` : `array<u32, ${o}>`, u = bv(e, i), c = typeof u == "string" ? u : u[1], h = typeof u == "string" ? u : u[0], f = {
        indices: l,
        value: c,
        storage: h,
        tensor: e
      }, d = (G) => typeof G == "string" ? G : `${G}u`, p = {
        offsetToIndices: false,
        indicesToOffset: false,
        broadcastedIndicesToOffset: false,
        set: false,
        setByIndices: false,
        get: false,
        getByIndices: false
      }, v = a ? "uniforms." : "", g = `${v}${t}_shape`, m = `${v}${t}_strides`, y = "";
      for (let G = 0; G < o - 1; G++) y += `
    let dim${G} = current / ${Ne(m, G, o)};
    let rest${G} = current % ${Ne(m, G, o)};
    indices[${G}] = dim${G};
    current = rest${G};
    `;
      y += `indices[${o - 1}] = current;`;
      let _ = o < 2 ? "" : `
  fn o2i_${t}(offset: u32) -> ${f.indices} {
    var indices: ${f.indices};
    var current = offset;
    ${y}
    return indices;
  }`, b = (G) => (p.offsetToIndices = true, o < 2 ? G : `o2i_${t}(${G})`), w = [];
      if (o >= 2) for (let G = o - 1; G >= 0; G--) w.push(`${Ne(m, G, o)} * (indices[${G}])`);
      let x = o < 2 ? "" : `
  fn i2o_${t}(indices: ${f.indices}) -> u32 {
    return ${w.join("+")};
  }`, T = (G) => (p.indicesToOffset = true, o < 2 ? G : `i2o_${t}(${G})`), A = (...G) => o === 0 ? "0u" : `${f.indices}(${G.map(d).join(",")})`, I = (G, Y) => o < 2 ? `${G}` : `${Ne(G, Y, o)}`, M = (G, Y, U) => o < 2 ? `${G}=${U};` : `${Ne(G, Y, o)}=${U};`, k = {}, B = (G, Y) => {
        p.broadcastedIndicesToOffset = true;
        let U = `${Y.name}broadcastedIndicesTo${t}Offset`;
        if (U in k) return `${U}(${G})`;
        let Z = [];
        for (let ee = o - 1; ee >= 0; ee--) {
          let we = Y.indicesGet("outputIndices", ee + Y.rank - o);
          Z.push(`${I(m, ee)} * (${we} % ${I(g, ee)})`);
        }
        return k[U] = `fn ${U}(outputIndices: ${Y.type.indices}) -> u32 {
             return ${Z.length > 0 ? Z.join("+") : "0u"};
           }`, `${U}(${G})`;
      }, L = (G, Y) => (() => {
        if (f.storage === f.value) return `${t}[${G}]=${Y};`;
        if (f.storage === "vec2<u32>" && f.value === "i32") return `${t}[${G}]=vec2<u32>(u32(${Y}), select(0u, 0xFFFFFFFFu, ${Y} < 0));`;
        if (f.storage === "vec2<u32>" && f.value === "u32") return `${t}[${G}]=vec2<u32>(u32(${Y}), 0u);`;
        if (f.storage === "u32" && f.value === "vec4<bool>") return `${t}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Y}));`;
        throw new Error(`not supported combination of storage type ${f.storage} and value type ${f.value} yet`);
      })(), z = (G) => (() => {
        if (f.storage === f.value) return `${t}[${G}]`;
        if (f.storage === "vec2<u32>" && f.value === "i32") return `i32(${t}[${G}].x)`;
        if (f.storage === "vec2<u32>" && f.value === "u32") return `u32(${t}[${G}].x)`;
        if (f.storage === "u32" && f.value === "vec4<bool>") return `vec4<bool>(bool(${t}[${G}] & 0xFFu), bool(${t}[${G}] & 0xFF00u), bool(${t}[${G}] & 0xFF0000u), bool(${t}[${G}] & 0xFF000000u))`;
        throw new Error(`not supported combination of storage type ${f.storage} and value type ${f.value} yet`);
      })(), F = o < 2 ? "" : `
  fn get_${t}ByIndices(indices: ${f.indices}) -> ${c} {
    return ${z(`i2o_${t}(indices)`)};
  }`, E = o < 2 ? "" : (() => {
        let G = s.map((U) => `d${U}: u32`).join(", "), Y = s.map((U) => `d${U}`).join(", ");
        return `
  fn get_${t}(${G}) -> ${c} {
    return get_${t}ByIndices(${A(Y)});
  }`;
      })(), O = (...G) => {
        if (G.length !== o) throw new Error(`indices length must be ${o}`);
        let Y = G.map(d).join(",");
        return o === 0 ? z("0u") : o === 1 ? z(Y[0]) : (p.get = true, p.getByIndices = true, p.indicesToOffset = true, `get_${t}(${Y})`);
      }, N = (G) => o < 2 ? z(G) : (p.getByIndices = true, p.indicesToOffset = true, `get_${t}ByIndices(${G})`), V = o < 2 ? "" : `
  fn set_${t}ByIndices(indices: ${f.indices}, value: ${c}) {
    ${L(`i2o_${t}(indices)`, "value")}
  }`, H = o < 2 ? "" : (() => {
        let G = s.map((U) => `d${U}: u32`).join(", "), Y = s.map((U) => `d${U}`).join(", ");
        return `
  fn set_${t}(${G}, value: ${c}) {
    set_${t}ByIndices(${A(Y)}, value);
  }`;
      })();
      return {
        impl: () => {
          let G = [], Y = false;
          return p.offsetToIndices && (G.push(_), Y = true), p.indicesToOffset && (G.push(x), Y = true), p.broadcastedIndicesToOffset && (Object.values(k).forEach((U) => G.push(U)), Y = true), p.set && (G.push(H), Y = true), p.setByIndices && (G.push(V), Y = true), p.get && (G.push(E), Y = true), p.getByIndices && (G.push(F), Y = true), !a && Y && G.unshift(`const ${g} = ${f.indices}(${r.join(",")});`, `const ${m} = ${f.indices}(${re.computeStrides(r).join(",")});`), G.join(`
`);
        },
        type: f,
        offsetToIndices: b,
        indicesToOffset: T,
        broadcastedIndicesToOffset: B,
        indices: A,
        indicesGet: I,
        indicesSet: M,
        set: (...G) => {
          if (G.length !== o + 1) throw new Error(`indices length must be ${o}`);
          let Y = G[o];
          if (typeof Y != "string") throw new Error("value must be string");
          let U = G.slice(0, o).map(d).join(",");
          return o === 0 ? L("0u", Y) : o === 1 ? L(U[0], Y) : (p.set = true, p.setByIndices = true, p.indicesToOffset = true, `set_${t}(${U}, ${Y})`);
        },
        setByOffset: L,
        setByIndices: (G, Y) => o < 2 ? L(G, Y) : (p.setByIndices = true, p.indicesToOffset = true, `set_${t}ByIndices(${G}, ${Y});`),
        get: O,
        getByOffset: z,
        getByIndices: N,
        usage: n,
        name: t,
        strides: m,
        shape: g,
        rank: o
      };
    }, se = (t, e, r, n = 1) => Oh(t, e, r, "input", n), Re = (t, e, r, n = 1) => Oh(t, e, r, "output", n), zU = (t, e, r) => Oh(t, e, r, "atomicOutput", 1), hC = (t, e, r, n = 1) => Oh(t, e, r, "internal", n), HR = class {
      constructor(t, e) {
        this.normalizedDispatchGroup = t, this.limits = e, this.internalVariables = [], this.variables = [], this.uniforms = [], this.variableIndex = 0;
      }
      guardAgainstOutOfBoundsWorkgroupSizes(t) {
        return `if (global_idx >= ${typeof t == "number" ? `${t}u` : t}) { return; }`;
      }
      mainStart(t = Mc) {
        let e = typeof t == "number" ? t : t[0], r = typeof t == "number" ? 1 : t[1], n = typeof t == "number" ? 1 : t[2];
        if (e > this.limits.maxComputeWorkgroupSizeX || r > this.limits.maxComputeWorkgroupSizeY || n > this.limits.maxComputeWorkgroupSizeZ) throw new Error(`workgroup size [${e}, ${r}, ${n}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);
        if (e * r * n > this.limits.maxComputeInvocationsPerWorkgroup) throw new Error(`workgroup size [${e}, ${r}, ${n}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);
        let i = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1, a = i ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`, o = i ? `let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${e * r * n}u + local_idx;`;
        return `@compute @workgroup_size(${e}, ${r}, ${n})
  fn main(${a}) {
    ${o}
  `;
      }
      appendVariableUniforms(t) {
        t.rank !== 0 && (t.shape.startsWith("uniforms.") && this.uniforms.push({
          name: t.shape.replace("uniforms.", ""),
          type: "u32",
          length: t.rank
        }), t.strides.startsWith("uniforms.") && this.uniforms.push({
          name: t.strides.replace("uniforms.", ""),
          type: "u32",
          length: t.rank
        }));
      }
      declareVariable(t, e) {
        if (t.usage === "internal") throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
        this.variables.push(t), this.appendVariableUniforms(t);
        let r = t.usage === "input" ? "read" : "read_write", n = t.usage === "atomicOutput" ? "atomic<i32>" : t.type.storage;
        return `@group(0) @binding(${e}) var<storage, ${r}> ${t.name}: array<${n}>;`;
      }
      declareVariables(...t) {
        return t.map((e) => this.declareVariable(e, this.variableIndex++)).join(`
`);
      }
      registerInternalVariable(t) {
        if (t.usage !== "internal") throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");
        this.internalVariables.push(t), this.appendVariableUniforms(t);
      }
      registerInternalVariables(...t) {
        return t.forEach((e) => this.registerInternalVariable(e)), this;
      }
      registerUniform(t, e, r = 1) {
        return this.uniforms.push({
          name: t,
          type: e,
          length: r
        }), this;
      }
      registerUniforms(t) {
        return this.uniforms = this.uniforms.concat(t), this;
      }
      uniformDeclaration() {
        if (this.uniforms.length === 0) return "";
        let t = [];
        for (let { name: e, type: r, length: n } of this.uniforms) if (n && n > 4) r === "f16" ? t.push(`@align(16) ${e}:array<mat2x4<${r}>, ${Math.ceil(n / 8)}>`) : t.push(`${e}:array<vec4<${r}>, ${Math.ceil(n / 4)}>`);
        else {
          let i = n == null || n === 1 ? r : `vec${n}<${r}>`;
          t.push(`${e}:${i}`);
        }
        return `
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
      }
      get additionalImplementations() {
        return this.uniformDeclaration() + this.variables.map((t) => t.impl()).join(`
`) + this.internalVariables.map((t) => t.impl()).join(`
`);
      }
      get variablesInfo() {
        if (this.uniforms.length === 0) return;
        let t = (e) => [
          12,
          10,
          1,
          6
        ][[
          "u32",
          "f16",
          "f32",
          "i32"
        ].indexOf(e)];
        return this.uniforms.map((e) => [
          t(e.type),
          e.length ?? 1
        ]);
      }
    }, FU = (t, e) => new HR(t, e);
  }), UR, kb, YR, qR, XR, jR, qn, VU, GU, ws = ge(() => {
    Je(), ft(), ur(), mt(), UR = (t, e) => {
      if (!t || t.length !== 1) throw new Error("Transpose requires 1 input.");
      if (e.length !== 0 && e.length !== t[0].dims.length) throw new Error(`perm size ${e.length} does not match input rank ${t[0].dims.length}`);
    }, kb = (t, e) => e.length !== 0 ? e : [
      ...new Array(t).keys()
    ].reverse(), YR = (t, e) => re.sortBasedOnPerm(t, kb(t.length, e)), qR = (t, e, r, n) => {
      let i = `fn perm(i: ${n.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`;
      for (let a = 0; a < e; ++a) i += `a[${t[a]}]=i[${a}];`;
      return i += "return a;}";
    }, XR = (t, e) => {
      let r = [], n = [];
      for (let i = 0; i < t.length; ++i) t[i] !== 1 && r.push(t[i]), t[e[i]] !== 1 && n.push(e[i]);
      return {
        newShape: r,
        newPerm: n
      };
    }, jR = (t, e) => {
      let r = 0;
      for (let n = 0; n < t.length; ++n) if (e[t[n]] !== 1) {
        if (t[n] < r) return false;
        r = t[n];
      }
      return true;
    }, qn = (t, e) => {
      let r = t.dataType, n = t.dims.length, i = kb(n, e), a = YR(t.dims, i), o = t.dims, s = a, l = n < 2 || jR(i, t.dims), u;
      if (l) return u = (p) => {
        let v = se("input", r, o, 4), g = Re("output", r, s, 4);
        return `
  ${p.registerUniform("output_size", "u32").declareVariables(v, g)}
  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`;
      }, {
        name: "TransposeCopy",
        shaderCache: {
          inputDependencies: [
            "type"
          ]
        },
        getRunData: () => {
          let p = re.size(a);
          return {
            outputs: [
              {
                dims: a,
                dataType: t.dataType
              }
            ],
            dispatchGroup: {
              x: Math.ceil(p / 64 / 4)
            },
            programUniforms: [
              {
                type: 12,
                data: Math.ceil(p / 4)
              }
            ]
          };
        },
        getShaderSource: u
      };
      let { newShape: c, newPerm: h } = XR(t.dims, i), f = re.areEqual(h, [
        2,
        3,
        1
      ]), d = re.areEqual(h, [
        3,
        1,
        2
      ]);
      if (c.length === 2 || f || d) {
        o = f ? [
          c[0],
          c[1] * c[2]
        ] : d ? [
          c[0] * c[1],
          c[2]
        ] : c, s = [
          o[1],
          o[0]
        ];
        let p = 16;
        return u = (v) => {
          let g = se("a", r, o.length), m = Re("output", r, s.length);
          return `
  ${v.registerUniform("output_size", "u32").declareVariables(g, m)}
  var<workgroup> tile : array<array<${m.type.value}, ${p + 1}>, ${p}>;
  ${v.mainStart([
            p,
            p,
            1
          ])}
    let stride = (uniforms.output_shape[1] - 1) / ${p} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${p}u + local_id.x;
    let input_row = workgroup_id_x * ${p}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${g.getByIndices(`${g.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${p}u + local_id.x;
    let output_row = workgroup_id_y * ${p}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${m.setByIndices(`${m.type.indices}(output_row, output_col)`, "tile[local_id.x][local_id.y]")}
    }
  }`;
        }, {
          name: "TransposeShared",
          shaderCache: {
            inputDependencies: [
              "type"
            ]
          },
          getRunData: () => {
            let v = re.size(a);
            return {
              outputs: [
                {
                  dims: a,
                  dataType: t.dataType
                }
              ],
              dispatchGroup: {
                x: Math.ceil(s[1] / p),
                y: Math.ceil(s[0] / p)
              },
              programUniforms: [
                {
                  type: 12,
                  data: v
                },
                ...Ve(o, s)
              ]
            };
          },
          getShaderSource: u
        };
      }
      return u = (p) => {
        let v = se("a", r, o.length), g = Re("output", r, s.length);
        return `
  ${p.registerUniform("output_size", "u32").declareVariables(v, g)}

  ${qR(i, n, v, g)}

  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${g.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${g.setByOffset("global_idx", v.getByIndices("aIndices"))}
  }`;
      }, {
        name: "Transpose",
        shaderCache: {
          hint: `${e}`,
          inputDependencies: [
            "rank"
          ]
        },
        getRunData: () => {
          let p = re.size(a);
          return {
            outputs: [
              {
                dims: a,
                dataType: t.dataType
              }
            ],
            dispatchGroup: {
              x: Math.ceil(p / 64)
            },
            programUniforms: [
              {
                type: 12,
                data: p
              },
              ...Ve(o, s)
            ]
          };
        },
        getShaderSource: u
      };
    }, VU = (t, e) => {
      UR(t.inputs, e.perm), t.compute(qn(t.inputs[0], e.perm));
    }, GU = (t) => Bt({
      perm: t.perm
    });
  }), KR, ZR, QR, JR, e3, t3, r3, n3, i3, a3, Di, WU, HU, UU, YU, qU, XU, jU, KU, ZU, QU, kye = ge(() => {
    Je(), ft(), mt(), fC(), ws(), KR = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate * candidate",
      logSumExp: "bestValue + exp(candidate)",
      l1: "bestValue + abs(candidate)",
      l2: "bestValue + candidate * candidate",
      logSum: "bestValue + candidate"
    }, ZR = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate",
      logSumExp: "bestValue + candidate",
      l1: "bestValue + candidate",
      l2: "bestValue + candidate",
      logSum: "bestValue + candidate"
    }, QR = {
      max: "_A[offset]",
      min: "_A[offset]",
      mean: "0",
      sum: "0",
      prod: "1",
      sumSquare: "0",
      logSumExp: "0",
      l1: "0",
      l2: "0",
      logSum: "0"
    }, JR = {
      max: "bestValue",
      min: "bestValue",
      sum: "bestValue",
      prod: "bestValue",
      sumSquare: "bestValue",
      logSumExp: "log(bestValue)",
      l1: "bestValue",
      l2: "sqrt(bestValue)",
      logSum: "log(bestValue)"
    }, e3 = (t, e) => {
      let r = [];
      for (let n = e - t; n < e; ++n) r.push(n);
      return r;
    }, t3 = (t, e) => {
      let r = [], n = t.length;
      for (let a = 0; a < n; a++) e.indexOf(a) === -1 && r.push(t[a]);
      let i = e.map((a) => t[a]);
      return [
        r,
        i
      ];
    }, r3 = (t, e) => {
      let r = t.length + e.length, n = [], i = 0;
      for (let a = 0; a < r; a++) e.indexOf(a) === -1 ? n.push(t[i++]) : n.push(1);
      return n;
    }, n3 = (t, e) => {
      for (let r = 0; r < t.length; ++r) if (t[t.length - r - 1] !== e - 1 - r) return false;
      return true;
    }, i3 = (t, e) => {
      let r = [];
      if (!n3(t, e)) {
        for (let n = 0; n < e; ++n) t.indexOf(n) === -1 && r.push(n);
        t.forEach((n) => r.push(n));
      }
      return r;
    }, a3 = (t, e, r, n, i, a, o) => {
      let s = r[0].dims, l = re.size(a), u = re.size(o), c = se("_A", r[0].dataType, s), h = Re("output", i, a), f = 64;
      l === 1 && (f = 256);
      let d = `
          var<workgroup> aBestValues : array<f32, ${f}>;
       `, p = (v) => `
        ${v.registerUniform("reduceSize", "u32").declareVariables(c, h)}
        ${d}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${v.mainStart(f)}

          let outputIndex = global_idx / ${f};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${QR[n]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${f}) {
           let candidate = f32(${c.getByOffset("offset + k")});
           bestValue = ${KR[n]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${f}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${ZR[n]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${h.setByOffset("outputIndex", `${n === "mean" ? `${h.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${h.type.storage}(${JR[n]})`}`)};
         }
        }`;
      return {
        name: t,
        shaderCache: {
          hint: `${e};${f}`,
          inputDependencies: [
            "type"
          ]
        },
        getShaderSource: p,
        getRunData: () => ({
          outputs: [
            {
              dims: a,
              dataType: i
            }
          ],
          dispatchGroup: {
            x: l
          },
          programUniforms: [
            {
              type: 12,
              data: u
            }
          ]
        })
      };
    }, Di = (t, e, r, n) => {
      let i = t.inputs.length === 1 ? r : Yw(t.inputs, r), a = i.axes;
      a.length === 0 && !i.noopWithEmptyAxes && (a = t.inputs[0].dims.map((d, p) => p));
      let o = re.normalizeAxes(a, t.inputs[0].dims.length), s = o, l = t.inputs[0], u = i3(s, t.inputs[0].dims.length);
      u.length > 0 && (l = t.compute(qn(t.inputs[0], u), {
        inputs: [
          0
        ],
        outputs: [
          -1
        ]
      })[0], s = e3(s.length, l.dims.length));
      let [c, h] = t3(l.dims, s), f = c;
      i.keepDims && (f = r3(c, o)), t.compute(a3(e, i.cacheKey, [
        l
      ], n, t.inputs[0].dataType, f, h), {
        inputs: [
          l
        ]
      });
    }, WU = (t, e) => {
      Di(t, "ReduceMeanShared", e, "mean");
    }, HU = (t, e) => {
      Di(t, "ReduceL1Shared", e, "l1");
    }, UU = (t, e) => {
      Di(t, "ReduceL2Shared", e, "l2");
    }, YU = (t, e) => {
      Di(t, "ReduceLogSumExpShared", e, "logSumExp");
    }, qU = (t, e) => {
      Di(t, "ReduceMaxShared", e, "max");
    }, XU = (t, e) => {
      Di(t, "ReduceMinShared", e, "min");
    }, jU = (t, e) => {
      Di(t, "ReduceProdShared", e, "prod");
    }, KU = (t, e) => {
      Di(t, "ReduceSumShared", e, "sum");
    }, ZU = (t, e) => {
      Di(t, "ReduceSumSquareShared", e, "sumSquare");
    }, QU = (t, e) => {
      Di(t, "ReduceLogSumShared", e, "logSum");
    };
  }), Ei, o3, bm, Yw, ki, s3, l3, u3, c3, h3, f3, d3, p3, v3, g3, Pi, JU, e6, t6, r6, n6, i6, a6, o6, s6, l6, fC = ge(() => {
    Je(), ft(), ur(), mt(), kye(), Ei = (t) => {
      if (!t || t.length === 0 || t.length > 2) throw new Error("Reduce op requires 1 or 2 inputs.");
      if (t.length === 2 && t[1].dims.length !== 1) throw new Error("Invalid axes input dims.");
    }, o3 = (t) => [
      "",
      "",
      `var value = ${t.getByIndices("input_indices")};`,
      ""
    ], bm = (t, e, r, n, i, a, o = false, s = false) => {
      let l = [], u = r[0].dims, c = u.length, h = re.normalizeAxes(i, c), f = !s && h.length === 0;
      u.forEach((v, g) => {
        f || h.indexOf(g) >= 0 ? o && l.push(1) : l.push(v);
      });
      let d = l.length, p = re.size(l);
      return {
        name: t,
        shaderCache: e,
        getShaderSource: (v) => {
          let g = [], m = se("_A", r[0].dataType, c), y = Re("output", a, d), _ = n(m, y, h), b = _[2];
          for (let w = 0, x = 0; w < c; w++) f || h.indexOf(w) >= 0 ? (o && x++, b = `for(var j${w}: u32 = 0; j${w} < ${u[w]}; j${w}++) {
                  ${_[2].includes("last_index") ? `let last_index = j${w};` : ""}
                  ${m.indicesSet("input_indices", w, `j${w}`)}
                  ${b}
                }`) : (g.push(`${m.indicesSet("input_indices", w, y.indicesGet("output_indices", x))};`), x++);
          return `

        ${v.registerUniform("output_size", "u32").declareVariables(m, y)}

        ${v.mainStart()}
          ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${m.type.indices};
          let output_indices = ${y.offsetToIndices("global_idx")};

          ${g.join(`
`)}
          ${_[0]}       // init ops for reduce max/min
          ${_[1]}
          ${b}
          ${_[3]}
          ${_.length === 4 ? y.setByOffset("global_idx", "value") : _.slice(4).join(`
`)}
        }`;
        },
        getRunData: () => ({
          outputs: [
            {
              dims: l,
              dataType: a
            }
          ],
          dispatchGroup: {
            x: Math.ceil(p / 64)
          },
          programUniforms: [
            {
              type: 12,
              data: p
            },
            ...Ve(u, l)
          ]
        })
      };
    }, Yw = (t, e) => {
      let r = [];
      return t[1].dims[0] > 0 && t[1].getBigInt64Array().forEach((n) => r.push(Number(n))), Bt({
        axes: r,
        keepDims: e.keepDims,
        noopWithEmptyAxes: e.noopWithEmptyAxes
      });
    }, ki = (t, e, r, n) => {
      let i = t.inputs, a = i.length === 1 ? r : Yw(i, r);
      t.compute(bm(e, {
        hint: a.cacheKey,
        inputDependencies: [
          "rank"
        ]
      }, [
        i[0]
      ], a.noopWithEmptyAxes && a.axes.length === 0 ? o3 : n, a.axes, i[0].dataType, a.keepDims, a.noopWithEmptyAxes), {
        inputs: [
          0
        ]
      });
    }, s3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceLogSum", e, (r, n) => [
        `var value = ${n.type.storage}(0);`,
        "",
        `value += ${r.getByIndices("input_indices")};`,
        "value = log(value);"
      ]);
    }, l3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceL1", e, (r, n) => [
        `var value = ${n.type.storage}(0);`,
        "",
        `value += abs(${r.getByIndices("input_indices")});`,
        ""
      ]);
    }, u3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceL2", e, (r, n) => [
        `var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,
        "",
        `t = ${r.getByIndices("input_indices")}; value += (t * t);`,
        "value = sqrt(value);"
      ]);
    }, c3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceLogSumExp", e, (r, n) => [
        `var value = ${n.type.storage}(0);`,
        "",
        `value += exp(${r.getByIndices("input_indices")});`,
        "value = log(value);"
      ]);
    }, h3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceMax", e, (r, n, i) => {
        let a = [];
        for (let o = 0; o < r.rank; o++) (i.indexOf(o) >= 0 || i.length === 0) && a.push(r.indicesSet("input_indices", o, 0));
        return [
          `${a.join(`
`)}`,
          `var value = ${r.getByIndices("input_indices")};`,
          `value = max(value, ${r.getByIndices("input_indices")});`,
          ""
        ];
      });
    }, f3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceMean", e, (r, n, i) => {
        let a = 1;
        for (let o = 0; o < r.rank; o++) (i.indexOf(o) >= 0 || i.length === 0) && (a *= t.inputs[0].dims[o]);
        return [
          "var sum = f32(0);",
          "",
          `sum += f32(${r.getByIndices("input_indices")});`,
          `let value = ${n.type.value}(sum / ${a});`
        ];
      });
    }, d3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceMin", e, (r, n, i) => {
        let a = [];
        for (let o = 0; o < r.rank; o++) (i.indexOf(o) >= 0 || i.length === 0) && a.push(`input_indices[${o}] = 0;`);
        return [
          `${a.join(`
`)}`,
          `var value = ${r.getByIndices("input_indices")};`,
          `value = min(value, ${r.getByIndices("input_indices")});`,
          ""
        ];
      });
    }, p3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceProd", e, (r, n) => [
        `var value = ${n.type.storage}(1);`,
        "",
        `value *= ${r.getByIndices("input_indices")};`,
        ""
      ]);
    }, v3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceSum", e, (r, n) => [
        `var value = ${n.type.storage}(0);`,
        "",
        `value += ${r.getByIndices("input_indices")};`,
        ""
      ]);
    }, g3 = (t, e) => {
      Ei(t.inputs), ki(t, "ReduceSumSquare", e, (r, n) => [
        `var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,
        "",
        `t = ${r.getByIndices("input_indices")}; value += t * t;`,
        ""
      ]);
    }, Pi = (t, e, r) => {
      if (e.length === 0) return r;
      let n = 1, i = 1;
      for (let a = 0; a < e.length; a++) e.indexOf(a) === -1 ? n *= t[a] : i *= t[a];
      return i < 32 && n > 1024;
    }, JU = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? f3(t, e) : WU(t, e);
    }, e6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? l3(t, e) : HU(t, e);
    }, t6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? u3(t, e) : UU(t, e);
    }, r6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? c3(t, e) : YU(t, e);
    }, n6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? h3(t, e) : qU(t, e);
    }, i6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? d3(t, e) : XU(t, e);
    }, a6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? p3(t, e) : jU(t, e);
    }, o6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? v3(t, e) : KU(t, e);
    }, s6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? g3(t, e) : ZU(t, e);
    }, l6 = (t, e) => {
      Pi(t.inputs[0].dims, e.axes, e.noopWithEmptyAxes) ? s3(t, e) : QU(t, e);
    };
  }), Pb, u6, c6, qw, Pye = ge(() => {
    Je(), ur(), fC(), Pb = (t) => {
      if (!t || t.length === 0 || t.length > 2) throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
      if (t[0].dataType !== 1) throw new Error("Invalid input type.");
    }, u6 = (t, e) => {
      Pb(t.inputs);
      let r = (n, i, a) => {
        let o = [];
        for (let s = 0; s < n.rank; s++) (a.indexOf(s) >= 0 || a.length === 0) && o.push(`input_indices[${s}] = 0;`);
        return [
          `${o.join(`
`)}`,
          `var value = ${n.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${n.getByIndices("input_indices")} ${e.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${n.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          i.setByOffset("global_idx", "best_index")
        ];
      };
      t.compute(bm("ArgMin", {
        hint: e.cacheKey,
        inputDependencies: [
          "rank"
        ]
      }, [
        t.inputs[0]
      ], r, [
        e.axis
      ], 7, e.keepDims), {
        inputs: [
          0
        ]
      });
    }, c6 = (t, e) => {
      Pb(t.inputs);
      let r = (n, i, a) => {
        let o = [];
        for (let s = 0; s < n.rank; s++) (a.indexOf(s) >= 0 || a.length === 0) && o.push(`input_indices[${s}] = 0;`);
        return [
          `${o.join(`
`)}`,
          `var value = ${n.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${n.getByIndices("input_indices")} ${e.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${n.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          i.setByOffset("global_idx", "best_index")
        ];
      };
      t.compute(bm("argMax", {
        hint: e.cacheKey,
        inputDependencies: [
          "rank"
        ]
      }, [
        t.inputs[0]
      ], r, [
        e.axis
      ], 7, e.keepDims), {
        inputs: [
          0
        ]
      });
    }, qw = (t) => Bt(t);
  }), m3, xv, y3, _3, b3, vd, x3, h6, dC = ge(() => {
    Je(), ft(), cC(), mt(), m3 = (t, e) => {
      let r = t[0], n = t[1], i = t[2], a = t[3], o = t[4], s = t[5];
      if (o && s) throw new Error("Attention cannot have both past and attention_bias");
      if (r.dims.length !== 3) throw new Error('Input "input" must have 3 dimensions');
      let l = r.dims[0], u = r.dims[1], c = r.dims[2];
      if (i.dims.length !== 1) throw new Error('Input "bias" is expected to have 1 dimensions');
      if (n.dims.length !== 2) throw new Error('Input "weights" is expected to have 2 dimensions');
      if (n.dims[0] !== c) throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
      if (i.dims[0] !== n.dims[1]) throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
      let h = i.dims[0] / 3, f = h, d = f;
      if (e.qkvHiddenSizes.length > 0) {
        if (e.qkvHiddenSizes.length !== 3) throw new Error("qkv_hidden_sizes attribute should have 3 elements");
        for (let _ of e.qkvHiddenSizes) if (_ % e.numHeads !== 0) throw new Error("qkv_hidden_sizes should be divisible by num_heads");
        h = e.qkvHiddenSizes[0], f = e.qkvHiddenSizes[1], d = e.qkvHiddenSizes[2];
      }
      let p = u;
      if (h !== f) throw new Error("qkv_hidden_sizes first element should be same as the second");
      if (i.dims[0] !== h + f + d) throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
      let v = 0;
      if (o) {
        if (f !== d) throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
        if (o.dims.length !== 5) throw new Error('Input "past" must have 5 dimensions');
        if (o.dims[0] !== 2) throw new Error('Input "past" first dimension must be 2');
        if (o.dims[1] !== l) throw new Error('Input "past" second dimension must be batch_size');
        if (o.dims[2] !== e.numHeads) throw new Error('Input "past" third dimension must be num_heads');
        if (o.dims[4] !== f / e.numHeads) throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
        e.pastPresentShareBuffer || (v = o.dims[3]);
      }
      let g = p + v, m = -1, y = 0;
      if (a) throw new Error("Mask not supported");
      if (o) throw new Error("past is not supported");
      if (s) {
        if (s.dims.length !== 4) throw new Error('Input "attention_bias" must have 4 dimensions');
        if (s.dims[0] !== l || s.dims[1] !== e.numHeads || s.dims[2] !== u || s.dims[3] !== g) throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
      }
      return {
        batchSize: l,
        sequenceLength: u,
        pastSequenceLength: v,
        kvSequenceLength: p,
        totalSequenceLength: g,
        maxSequenceLength: m,
        inputHiddenSize: c,
        hiddenSize: h,
        vHiddenSize: d,
        headSize: Math.floor(h / e.numHeads),
        vHeadSize: Math.floor(d / e.numHeads),
        numHeads: e.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: e.maskFilterValue,
        maskType: y,
        scale: e.scale,
        broadcastResPosBias: false,
        passPastInKv: false,
        qkvFormat: 1
      };
    }, xv = (t, e, r) => e && t ? `
      let total_sequence_length_input = u32(${e.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${t == null ? void 0 : t.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       ` : `
    ${r ? "let past_sequence_length = uniforms.past_sequence_length" : ""};
    let present_sequence_length = total_sequence_length;
    `, y3 = (t, e, r, n, i, a, o, s) => {
      let l = or(o ? 1 : a), u = 64, c = a / l;
      c < u && (u = 32);
      let h = Math.ceil(a / l / u), f = [
        {
          type: 12,
          data: e
        },
        {
          type: 12,
          data: r
        },
        {
          type: 12,
          data: n
        },
        {
          type: 12,
          data: i
        },
        {
          type: 12,
          data: c
        },
        {
          type: 12,
          data: h
        }
      ], d = kr(t.dataType, l), p = Jr(1, l), v = [
        "type"
      ];
      o && v.push("type"), s && v.push("type");
      let g = (m) => {
        let y = Re("x", t.dataType, t.dims, l), _ = [
          y
        ], b = o ? se("seq_lens", o.dataType, o.dims) : void 0;
        b && _.push(b);
        let w = s ? se("total_sequence_length_input", s.dataType, s.dims) : void 0;
        w && _.push(w);
        let x = Jr(t.dataType), T = [
          {
            name: "batch_size",
            type: "u32"
          },
          {
            name: "num_heads",
            type: "u32"
          },
          {
            name: "past_sequence_length",
            type: "u32"
          },
          {
            name: "sequence_length",
            type: "u32"
          },
          {
            name: "total_sequence_length",
            type: "u32"
          },
          {
            name: "elements_per_thread",
            type: "u32"
          }
        ];
        return `
  var<workgroup> thread_max: array<f32, ${u}>;
  var<workgroup> thread_sum: array<f32, ${u}>;
  ${m.registerUniforms(T).declareVariables(..._)}
  ${m.mainStart([
          u,
          1,
          1
        ])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${xv(b, w, false)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${o ? "u32(past_sequence_length + workgroup_id.y + 1)" : "total_sequence_length"};
    var thread_max_vector = ${p}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${p}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
          switch (l) {
            case 1:
              return "thread_max_vector";
            case 2:
              return "max(thread_max_vector.x, thread_max_vector.y)";
            case 4:
              return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
            default:
              throw new Error(`Unsupported components: ${l}`);
          }
        })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${u}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${p}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${p}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
          switch (l) {
            case 1:
              return "sum_vector";
            case 2:
              return "sum_vector.x + sum_vector.y";
            case 4:
              return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
            default:
              throw new Error(`Unsupported components: ${l}`);
          }
        })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${u}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${y.type.value}(${x}(1.0) / ${x}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${p}(x[offset + i]);
        x[offset + i] = ${y.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${o ? `
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${y.type.value}(${x}(0));
        }` : ""};
  }`;
      };
      return {
        name: "AttentionProbsSoftmax",
        shaderCache: {
          hint: `${u};${d};${l}`,
          inputDependencies: v
        },
        getShaderSource: g,
        getRunData: () => ({
          outputs: [],
          dispatchGroup: {
            x: Math.ceil(a / u),
            y: i,
            z: e * r
          },
          programUniforms: f
        })
      };
    }, _3 = (t, e, r, n, i, a, o, s, l) => {
      let u = o + a.kvSequenceLength, c = [
        a.batchSize,
        a.numHeads,
        a.sequenceLength,
        u
      ], h = t > 1 && n, f = a.kvNumHeads ? a.kvNumHeads : a.numHeads, d = h ? [
        a.batchSize,
        f,
        u,
        a.headSize
      ] : void 0, p = a.nReps ? a.nReps : 1, v = a.scale === 0 ? 1 / Math.sqrt(a.headSize) : a.scale, g = or(a.headSize), m = a.headSize / g, y = 12, _ = {
        x: Math.ceil(u / y),
        y: Math.ceil(a.sequenceLength / y),
        z: a.batchSize * a.numHeads
      }, b = [
        {
          type: 12,
          data: a.sequenceLength
        },
        {
          type: 12,
          data: m
        },
        {
          type: 12,
          data: u
        },
        {
          type: 12,
          data: a.numHeads
        },
        {
          type: 12,
          data: a.headSize
        },
        {
          type: 1,
          data: v
        },
        {
          type: 12,
          data: o
        },
        {
          type: 12,
          data: a.kvSequenceLength
        },
        {
          type: 12,
          data: p
        }
      ], w = h && n && re.size(n.dims) > 0, x = [
        "type",
        "type"
      ];
      w && x.push("type"), i && x.push("type"), s && x.push("type"), l && x.push("type");
      let T = [
        {
          dims: c,
          dataType: e.dataType,
          gpuDataType: 0
        }
      ];
      h && T.push({
        dims: d,
        dataType: e.dataType,
        gpuDataType: 0
      });
      let A = (I) => {
        let M = se("q", e.dataType, e.dims, g), k = se("key", r.dataType, r.dims, g), B = [
          M,
          k
        ];
        if (w) {
          let V = se("past_key", n.dataType, n.dims, g);
          B.push(V);
        }
        i && B.push(se("attention_bias", i.dataType, i.dims));
        let L = s ? se("seq_lens", s.dataType, s.dims) : void 0;
        L && B.push(L);
        let z = l ? se("total_sequence_length_input", l.dataType, l.dims) : void 0;
        z && B.push(z);
        let F = Re("output", e.dataType, c), E = [
          F
        ];
        h && E.push(Re("present_key", e.dataType, d, g));
        let O = Jr(1, g), N = [
          {
            name: "M",
            type: "u32"
          },
          {
            name: "K",
            type: "u32"
          },
          {
            name: "N",
            type: "u32"
          },
          {
            name: "num_heads",
            type: "u32"
          },
          {
            name: "head_size",
            type: "u32"
          },
          {
            name: "alpha",
            type: "f32"
          },
          {
            name: "past_sequence_length",
            type: "u32"
          },
          {
            name: "kv_sequence_length",
            type: "u32"
          },
          {
            name: "n_reps",
            type: "u32"
          }
        ];
        return `
  const TILE_SIZE = ${y}u;

  var<workgroup> tileQ: array<${M.type.storage}, ${y * y}>;
  var<workgroup> tileK: array<${M.type.storage}, ${y * y}>;
  ${I.registerUniforms(N).declareVariables(...B, ...E)}
  ${I.mainStart([
          y,
          y,
          1
        ])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${p === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
    let kv_num_heads = ${p === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${xv(L, z, true)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${w && h ? "let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;" : ""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${h ? "let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${O}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${w && h ? `
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }` : `
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${h ? `if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }` : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${O}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
          switch (g) {
            case 1:
              return "value";
            case 2:
              return "value.x + value.y";
            case 4:
              return "value.x + value.y + value.z + value.w";
            default:
              throw new Error(`Unsupported components: ${g}`);
          }
        })()};
        output[outputIdx] = ${F.type.value} (sum * uniforms.alpha) + ${i ? "attention_bias[outputIdx]" : "0.0"};
    }
  }`;
      };
      return {
        name: "AttentionProbs",
        shaderCache: {
          hint: `${g};${i !== void 0};${n !== void 0};${t}`,
          inputDependencies: x
        },
        getRunData: () => ({
          outputs: T,
          dispatchGroup: _,
          programUniforms: b
        }),
        getShaderSource: A
      };
    }, b3 = (t, e, r, n, i, a, o = void 0, s = void 0) => {
      let l = a + i.kvSequenceLength, u = i.nReps ? i.nReps : 1, c = i.vHiddenSize * u, h = t > 1 && n, f = i.kvNumHeads ? i.kvNumHeads : i.numHeads, d = h ? [
        i.batchSize,
        f,
        l,
        i.headSize
      ] : void 0, p = [
        i.batchSize,
        i.sequenceLength,
        c
      ], v = 12, g = {
        x: Math.ceil(i.vHeadSize / v),
        y: Math.ceil(i.sequenceLength / v),
        z: i.batchSize * i.numHeads
      }, m = [
        {
          type: 12,
          data: i.sequenceLength
        },
        {
          type: 12,
          data: l
        },
        {
          type: 12,
          data: i.vHeadSize
        },
        {
          type: 12,
          data: i.numHeads
        },
        {
          type: 12,
          data: i.headSize
        },
        {
          type: 12,
          data: c
        },
        {
          type: 12,
          data: a
        },
        {
          type: 12,
          data: i.kvSequenceLength
        },
        {
          type: 12,
          data: u
        }
      ], y = h && n && re.size(n.dims) > 0, _ = [
        "type",
        "type"
      ];
      y && _.push("type"), o && _.push("type"), s && _.push("type");
      let b = [
        {
          dims: p,
          dataType: e.dataType,
          gpuDataType: 0
        }
      ];
      h && b.push({
        dims: d,
        dataType: e.dataType,
        gpuDataType: 0
      });
      let w = (x) => {
        let T = se("probs", e.dataType, e.dims), A = se("v", r.dataType, r.dims), I = [
          T,
          A
        ];
        y && I.push(se("past_value", n.dataType, n.dims));
        let M = o ? se("seq_lens", o.dataType, o.dims) : void 0;
        o && I.push(M);
        let k = s ? se("total_sequence_length_input", s.dataType, s.dims) : void 0;
        s && I.push(k);
        let B = [
          Re("output", e.dataType, p)
        ];
        h && B.push(Re("present_value", e.dataType, d));
        let L = [
          {
            name: "M",
            type: "u32"
          },
          {
            name: "K",
            type: "u32"
          },
          {
            name: "N",
            type: "u32"
          },
          {
            name: "num_heads",
            type: "u32"
          },
          {
            name: "head_size",
            type: "u32"
          },
          {
            name: "v_hidden_size",
            type: "u32"
          },
          {
            name: "past_sequence_length",
            type: "u32"
          },
          {
            name: "kv_sequence_length",
            type: "u32"
          },
          {
            name: "n_reps",
            type: "u32"
          }
        ];
        return `
  const TILE_SIZE = ${v}u;
  var<workgroup> tileQ: array<${T.type.value}, ${v * v}>;
  var<workgroup> tileV: array<${T.type.value}, ${v * v}>;
  ${x.registerUniforms(L).declareVariables(...I, ...B)}
  ${x.mainStart([
          v,
          v,
          1
        ])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${u === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
   let kv_num_heads = ${u === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${xv(M, k, true)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${y && h ? "let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;" : ""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${h ? "let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${T.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${y && h ? `
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      ` : `
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${h ? `
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }` : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
      };
      return {
        name: "AttentionScore",
        shaderCache: {
          hint: `${n !== void 0};${t}`,
          inputDependencies: _
        },
        getRunData: () => ({
          outputs: b,
          dispatchGroup: g,
          programUniforms: m
        }),
        getShaderSource: w
      };
    }, vd = (t, e, r, n, i, a, o, s, l, u, c = void 0, h = void 0) => {
      let f = Math.min(t.outputCount, 1 + (o ? 1 : 0) + (s ? 1 : 0)), d = f > 1 ? u.pastSequenceLength : 0, p = d + u.kvSequenceLength, v = l && re.size(l.dims) > 0 ? l : void 0, g = [
        e,
        r
      ];
      f > 1 && o && re.size(o.dims) > 0 && g.push(o), v && g.push(v), c && g.push(c), h && g.push(h);
      let m = t.compute(_3(f, e, r, o, v, u, d, c, h), {
        inputs: g,
        outputs: f > 1 ? [
          -1,
          1
        ] : [
          -1
        ]
      })[0];
      t.compute(y3(m, u.batchSize, u.numHeads, d, u.sequenceLength, p, c, h), {
        inputs: c && h ? [
          m,
          c,
          h
        ] : [
          m
        ],
        outputs: []
      });
      let y = [
        m,
        n
      ];
      f > 1 && s && re.size(s.dims) > 0 && y.push(s), c && y.push(c), h && y.push(h), t.compute(b3(f, m, n, s, u, d, c, h), {
        inputs: y,
        outputs: f > 1 ? [
          0,
          2
        ] : [
          0
        ]
      });
    }, x3 = (t, e) => {
      let r = [
        e.batchSize,
        e.numHeads,
        e.sequenceLength,
        e.headSize
      ], n = e.sequenceLength, i = e.inputHiddenSize, a = e.headSize, o = 12, s = {
        x: Math.ceil(e.headSize / o),
        y: Math.ceil(e.sequenceLength / o),
        z: e.batchSize * e.numHeads
      }, l = [
        t.inputs[0],
        t.inputs[1],
        t.inputs[2]
      ], u = [
        {
          type: 12,
          data: n
        },
        {
          type: 12,
          data: i
        },
        {
          type: 12,
          data: a
        },
        {
          type: 12,
          data: e.numHeads
        },
        {
          type: 12,
          data: e.headSize
        },
        {
          type: 12,
          data: e.hiddenSize
        },
        {
          type: 12,
          data: e.hiddenSize + e.hiddenSize + e.vHiddenSize
        }
      ], c = (h) => {
        let f = Re("output_q", l[0].dataType, r), d = Re("output_k", l[0].dataType, r), p = Re("output_v", l[0].dataType, r), v = se("input", l[0].dataType, l[0].dims), g = se("weight", l[1].dataType, l[1].dims), m = se("bias", l[2].dataType, l[2].dims), y = v.type.storage, _ = [
          {
            name: "M",
            type: "u32"
          },
          {
            name: "K",
            type: "u32"
          },
          {
            name: "N",
            type: "u32"
          },
          {
            name: "num_heads",
            type: "u32"
          },
          {
            name: "head_size",
            type: "u32"
          },
          {
            name: "hidden_size",
            type: "u32"
          },
          {
            name: "ldb",
            type: "u32"
          }
        ];
        return `
  const TILE_SIZE = ${o}u;
  var<workgroup> tileInput: array<${y}, ${o * o}>;
  var<workgroup> tileWeightQ: array<${y}, ${o * o}>;
  var<workgroup> tileWeightK: array<${y}, ${o * o}>;
  var<workgroup> tileWeightV: array<${y}, ${o * o}>;
  ${h.registerUniforms(_).declareVariables(v, g, m, f, d, p)}
  ${h.mainStart([
          o,
          o,
          1
        ])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${y}(0);
    var valueK = ${y}(0);
    var valueV = ${y}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
      };
      return t.compute({
        name: "AttentionPrepare",
        shaderCache: {
          inputDependencies: [
            "type",
            "type",
            "type"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: r,
              dataType: t.inputs[0].dataType,
              gpuDataType: 0
            },
            {
              dims: r,
              dataType: t.inputs[0].dataType,
              gpuDataType: 0
            },
            {
              dims: r,
              dataType: t.inputs[0].dataType,
              gpuDataType: 0
            }
          ],
          dispatchGroup: s,
          programUniforms: u
        }),
        getShaderSource: c
      }, {
        inputs: l,
        outputs: [
          -1,
          -1,
          -1
        ]
      });
    }, h6 = (t, e) => {
      let r = m3(t.inputs, e), [n, i, a] = x3(t, r);
      return vd(t, n, i, a, t.inputs[4], void 0, void 0, void 0, t.inputs[5], r);
    };
  }), w3, S3, T3, f6, Lye = ge(() => {
    ea(), Je(), ft(), ur(), mt(), w3 = (t, e) => {
      if (!t || t.length !== 5) throw new Error("BatchNormalization requires 5 inputs");
      let r = (n, i, a) => {
        let o = i.length;
        if (o !== n.length) throw new Error(`${a}: num dimensions != ${o}`);
        i.forEach((s, l) => {
          if (s !== n[l]) throw new Error(`${a}: dim[${l}] do not match`);
        });
      };
      if (t[0].dims.length > 1) {
        let n = e.format === "NHWC" ? e.spatial ? t[0].dims.slice(-1) : t[0].dims.slice(-1).concat(t[0].dims.slice(1, t[0].dims.length - 1)) : t[0].dims.slice(1, e.spatial ? 2 : void 0);
        r(t[1].dims, n, "Invalid input scale"), r(t[2].dims, n, "Invalid input B"), r(t[3].dims, n, "Invalid input mean"), r(t[4].dims, n, "Invalid input var");
      } else r(t[1].dims, [
        1
      ], "Invalid input scale"), r(t[2].dims, [
        1
      ], "Invalid input B"), r(t[3].dims, [
        1
      ], "Invalid input mean"), r(t[4].dims, [
        1
      ], "Invalid input var");
    }, S3 = (t, e) => {
      let { epsilon: r, spatial: n, format: i } = e, a = t[0].dims, o = n ? or(a[a.length - 1]) : 1, s = i === "NHWC" && a.length > 1 ? o : 1, l = re.size(a) / o, u = n, c = u ? a.length : a, h = se("x", t[0].dataType, t[0].dims, o), f = se("scale", t[1].dataType, t[1].dims, s), d = se("bias", t[2].dataType, t[2].dims, s), p = se("inputMean", t[3].dataType, t[3].dims, s), v = se("inputVar", t[4].dataType, t[4].dims, s), g = Re("y", t[0].dataType, c, o), m = () => {
        let _ = "";
        if (n) _ = `let cOffset = ${a.length === 1 ? "0u" : i === "NHWC" ? `outputIndices[${a.length - 1}] / ${o}` : "outputIndices[1]"};`;
        else if (i === "NCHW") _ = `
            ${g.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${g.indicesToOffset("outputIndices")};`;
        else {
          _ = `var cIndices = ${f.type.indices}(0);
                       cIndices[0] = outputIndices[${a.length - 1}];`;
          for (let b = 1; b < f.rank; b++) _ += `cIndices[${b}] = outputIndices[${b}];`;
          _ += `let cOffset = ${f.indicesToOffset("cIndices")};`;
        }
        return _;
      }, y = (_) => `
  const epsilon = ${r};
  ${_.registerUniform("outputSize", "u32").declareVariables(h, f, d, p, v, g)}
  ${_.mainStart()}
  ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${g.offsetToIndices(`global_idx * ${o}`)};
    ${m()}
    let scale = ${f.getByOffset("cOffset")};
    let bias = ${d.getByOffset("cOffset")};
    let inputMean = ${p.getByOffset("cOffset")};
    let inputVar = ${v.getByOffset("cOffset")};
    let x = ${h.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${g.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BatchNormalization",
        shaderCache: {
          hint: `${e.epsilon}_${e.format}_${n}_${o}`,
          inputDependencies: u ? [
            "rank",
            "type",
            "type",
            "type",
            "type"
          ] : void 0
        },
        getShaderSource: y,
        getRunData: () => ({
          outputs: [
            {
              dims: t[0].dims,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(l / 64)
          },
          programUniforms: u ? [
            {
              type: 12,
              data: l
            },
            ...Ve(a)
          ] : [
            {
              type: 12,
              data: l
            }
          ]
        })
      };
    }, T3 = (t) => Bt(t), f6 = (t, e) => {
      let { inputs: r, outputCount: n } = t, i = T3({
        ...e,
        outputCount: n
      });
      if (rr.webgpu.validateInputContent && w3(r, i), e.trainingMode) throw new Error("BatchNormalization trainingMode is not supported yet.");
      t.compute(S3(r, i));
    };
  }), C3, A3, d6, $ye = ge(() => {
    ft(), mt(), C3 = (t) => {
      if (t[0].dims.length !== 3) throw new Error("input should have 3 dimensions");
      if (![
        320,
        640,
        1280
      ].includes(t[0].dims[2])) throw new Error("number of channels should be 320, 640 or 1280");
      if (t[1].dims.length !== 1) throw new Error("bias is expected to have 1 dimensions");
      if (t[0].dims[2] !== t[1].dims[0]) throw new Error("last dimension of input and bias are not the same");
    }, A3 = (t) => {
      let e = t[0].dims, r = t[0].dims[2], n = re.size(e) / 4, i = t[0].dataType, a = se("input", i, e, 4), o = se("bias", i, [
        r
      ], 4), s = se("residual", i, e, 4), l = Re("output", i, e, 4);
      return {
        name: "BiasAdd",
        getRunData: () => ({
          outputs: [
            {
              dims: e,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(n / 64)
          }
        }),
        getShaderSource: (u) => `
  const channels = ${r}u / 4;
  ${u.declareVariables(a, o, s, l)}

  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes(n)}
    let value = ${a.getByOffset("global_idx")}
      + ${o.getByOffset("global_idx % channels")} + ${s.getByOffset("global_idx")};
    ${l.setByOffset("global_idx", "value")}
  }`
      };
    }, d6 = (t) => {
      C3(t.inputs), t.compute(A3(t.inputs));
    };
  }), I3, Pt, p6, v6, g6, m6, y6, _6, b6, x6, w6, M3, S6, T6, C6, A6, hf, I6, mg, M6, D6, E6, k6, P6, L6, $6, R6, O6, N6, B6, z6, F6, V6, G6, W6, Lb, H6, Xw, jw, U6, Y6, q6, D3, E3, X6, pC = ge(() => {
    Je(), ft(), ur(), mt(), I3 = (t, e, r, n, i, a, o) => {
      let s = Math.ceil(e / 4), l = "";
      typeof i == "string" ? l = `${i}(a)` : l = i("a");
      let u = se("inputData", r, [
        s
      ], 4), c = Re("outputData", n, [
        s
      ], 4), h = [
        {
          name: "vec_size",
          type: "u32"
        }
      ];
      return o && h.push(...o), `
      ${t.registerUniforms(h).declareVariables(u, c)}

  ${a ?? ""}

  ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${u.getByOffset("global_idx")};
    ${c.setByOffset("global_idx", l)}
  }`;
    }, Pt = (t, e, r, n, i, a = t.dataType, o, s) => {
      let l = [
        {
          type: 12,
          data: Math.ceil(re.size(t.dims) / 4)
        }
      ];
      return o && l.push(...o), {
        name: e,
        shaderCache: {
          hint: i,
          inputDependencies: [
            "type"
          ]
        },
        getShaderSource: (u) => I3(u, re.size(t.dims), t.dataType, a, r, n, s),
        getRunData: (u) => ({
          outputs: [
            {
              dims: t.dims,
              dataType: a
            }
          ],
          dispatchGroup: {
            x: Math.ceil(re.size(u[0].dims) / 64 / 4)
          },
          programUniforms: l
        })
      };
    }, p6 = (t) => {
      t.compute(Pt(t.inputs[0], "Abs", "abs"));
    }, v6 = (t) => {
      t.compute(Pt(t.inputs[0], "Acos", "acos"));
    }, g6 = (t) => {
      t.compute(Pt(t.inputs[0], "Acosh", "acosh"));
    }, m6 = (t) => {
      t.compute(Pt(t.inputs[0], "Asin", "asin"));
    }, y6 = (t) => {
      t.compute(Pt(t.inputs[0], "Asinh", "asinh"));
    }, _6 = (t) => {
      t.compute(Pt(t.inputs[0], "Atan", "atan"));
    }, b6 = (t) => {
      t.compute(Pt(t.inputs[0], "Atanh", "atanh"));
    }, x6 = (t) => Bt(t), w6 = (t, e) => {
      let r;
      switch (e.to) {
        case 10:
          r = "vec4<f16>";
          break;
        case 1:
          r = "vec4<f32>";
          break;
        case 12:
          r = "vec4<u32>";
          break;
        case 6:
          r = "vec4<i32>";
          break;
        case 9:
          r = "vec4<bool>";
          break;
        default:
          throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`);
      }
      t.compute(Pt(t.inputs[0], "Cast", r, void 0, e.cacheKey, e.to));
    }, M3 = (t) => {
      let e, r, n = t.length >= 2 && t[1].data !== 0, i = t.length >= 3 && t[2].data !== 0;
      switch (t[0].dataType) {
        case 1:
          e = n ? t[1].getFloat32Array()[0] : -34028234663852886e22, r = i ? t[2].getFloat32Array()[0] : 34028234663852886e22;
          break;
        case 10:
          e = n ? t[1].getUint16Array()[0] : 64511, r = i ? t[2].getUint16Array()[0] : 31743;
          break;
        default:
          throw new Error("Unsupport data type");
      }
      return Bt({
        min: e,
        max: r
      });
    }, S6 = (t, e) => {
      let r = e || M3(t.inputs), n = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "Clip", (i) => `clamp(${i}, vec4<${n}>(uniforms.min), vec4<${n}>(uniforms.max))`, void 0, r.cacheKey, void 0, [
        {
          type: t.inputs[0].dataType,
          data: r.min
        },
        {
          type: t.inputs[0].dataType,
          data: r.max
        }
      ], [
        {
          name: "min",
          type: n
        },
        {
          name: "max",
          type: n
        }
      ]), {
        inputs: [
          0
        ]
      });
    }, T6 = (t) => {
      t.compute(Pt(t.inputs[0], "Ceil", "ceil"));
    }, C6 = (t) => {
      t.compute(Pt(t.inputs[0], "Cos", "cos"));
    }, A6 = (t) => {
      t.compute(Pt(t.inputs[0], "Cosh", "cosh"));
    }, hf = (t) => Bt(t), I6 = (t, e) => {
      let r = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "Elu", (n) => `elu_vf32(${n})`, `
  const elu_alpha_ = ${r}(${e.alpha});

  fn elu_f32(a: ${r}) -> ${r} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`, e.cacheKey));
    }, mg = (t = "f32") => `
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: vec4<${t}>) -> vec4<${t}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`, M6 = (t) => {
      let e = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "Erf", (r) => `erf_vf32(${r})`, mg(e)));
    }, D6 = (t) => {
      t.compute(Pt(t.inputs[0], "Exp", "exp"));
    }, E6 = (t) => {
      t.compute(Pt(t.inputs[0], "Floor", "floor"));
    }, k6 = (t) => {
      let e = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "Gelu", (r) => `0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`, mg(e)));
    }, P6 = (t, e) => {
      let r = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "LeakyRelu", (n) => `select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<${r}>(0.0))`, `const leaky_relu_alpha_ = ${r}(${e.alpha});`, e.cacheKey));
    }, L6 = (t) => {
      t.compute(Pt(t.inputs[0], "Not", (e) => `!${e}`));
    }, $6 = (t) => {
      t.compute(Pt(t.inputs[0], "Neg", (e) => `-${e}`));
    }, R6 = (t) => {
      t.compute(Pt(t.inputs[0], "Reciprocal", (e) => `1.0/${e}`));
    }, O6 = (t) => {
      let e = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "Relu", (r) => `select(vec4<${e}>(0.0), ${r}, ${r} > vec4<${e}>(0.0))`));
    }, N6 = (t) => {
      t.compute(Pt(t.inputs[0], "Sigmoid", (e) => `(1.0 / (1.0 + exp(-${e})))`));
    }, B6 = (t) => Bt(t), z6 = (t, e) => {
      let r = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "HardSigmoid", (n) => `max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${e.alpha} * ${n} + vec4<${r}>(${e.beta})))`, void 0, e.cacheKey));
    }, F6 = (t) => {
      t.compute(Pt(t.inputs[0], "Sin", "sin"));
    }, V6 = (t) => {
      t.compute(Pt(t.inputs[0], "Sinh", "sinh"));
    }, G6 = (t) => {
      t.compute(Pt(t.inputs[0], "Sqrt", "sqrt"));
    }, W6 = (t) => {
      t.compute(Pt(t.inputs[0], "Tan", "tan"));
    }, Lb = (t) => `sign(${t}) * (1 - exp(-2 * abs(${t}))) / (1 + exp(-2 * abs(${t})))`, H6 = (t) => {
      t.compute(Pt(t.inputs[0], "Tanh", Lb));
    }, Xw = (t = "f32") => `
const fast_gelu_a: ${t} = 0.5;
const fast_gelu_b: ${t} = 0.7978845608028654;
const fast_gelu_c: ${t} = 0.035677408136300125;

fn tanh_v(v: vec4<${t}>) -> vec4<${t}> {
  return ${Lb("v")};
}
`, jw = (t) => `(fast_gelu_a + fast_gelu_a * tanh_v(${t} * (fast_gelu_c * ${t} * ${t} + fast_gelu_b))) * ${t}`, U6 = (t) => {
      let e = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "FastGelu", jw, Xw(e), void 0, t.inputs[0].dataType));
    }, Y6 = (t, e) => {
      let r = Jr(t.inputs[0].dataType);
      return t.compute(Pt(t.inputs[0], "ThresholdedRelu", (n) => `select(vec4<${r}>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`, `const thresholded_relu_alpha_ = vec4<${r}>(${e.alpha});`, e.cacheKey)), 0;
    }, q6 = (t) => {
      t.compute(Pt(t.inputs[0], "Log", "log"));
    }, D3 = (t, e) => `
const alpha = vec4<${t}>(${e});
const one = ${t}(1.0);
const zero = ${t}(0.0);

fn quick_gelu_impl(x: vec4<${t}>) -> vec4<${t}> {
  let v = x *alpha;
  var x1 : vec4<${t}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`, E3 = (t) => `quick_gelu_impl(${t})`, X6 = (t, e) => {
      let r = Jr(t.inputs[0].dataType);
      t.compute(Pt(t.inputs[0], "QuickGelu", E3, D3(r, e.alpha), e.cacheKey, t.inputs[0].dataType));
    };
  }), k3, P3, j6, Rye = ge(() => {
    ft(), mt(), pC(), k3 = (t) => {
      if (t[0].dims.length !== 3) throw new Error("input should have 3 dimensions");
      if (![
        2560,
        5120,
        10240
      ].includes(t[0].dims[2])) throw new Error("hidden state should be 2560, 5120 or 10240");
      if (t[1].dims.length !== 1) throw new Error("bias is expected to have 1 dimensions");
      if (t[0].dims[2] !== t[1].dims[0]) throw new Error("last dimension of input and bias are not the same");
    }, P3 = (t) => {
      let e = t[0].dims.slice();
      e[2] = e[2] / 2;
      let r = se("input", t[0].dataType, t[0].dims, 4), n = se("bias", t[0].dataType, [
        t[0].dims[2]
      ], 4), i = Re("output", t[0].dataType, e, 4), a = re.size(e) / 4, o = kr(t[0].dataType);
      return {
        name: "BiasSplitGelu",
        getRunData: () => ({
          outputs: [
            {
              dims: e,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(a / 64)
          }
        }),
        getShaderSource: (s) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${t[0].dims[2] / 4 / 2}u;

  ${s.declareVariables(r, n, i)}

  ${mg(o)}

  ${s.mainStart()}
    ${s.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${i.setByOffset("global_idx", "valueLeft * geluRight")}
  }`
      };
    }, j6 = (t) => {
      k3(t.inputs), t.compute(P3(t.inputs));
    };
  }), L3, $3, Li, K6, Z6, Q6, J6, e8, t8, r8, n8, i8, a8, Oye = ge(() => {
    Je(), ft(), mt(), L3 = (t, e, r, n, i, a, o, s, l, u, c, h) => {
      let f, d;
      typeof s == "string" ? f = d = (y, _) => `${s}((${y}),(${_}))` : typeof s == "function" ? f = d = s : (f = s.scalar, d = s.vector);
      let p = Re("outputData", c, n.length, 4), v = se("aData", l, e.length, 4), g = se("bData", u, r.length, 4), m;
      if (i) if (a) {
        let y = re.size(e) === 1, _ = re.size(r) === 1, b = e.length > 0 && e[e.length - 1] % 4 === 0, w = r.length > 0 && r[r.length - 1] % 4 === 0;
        y || _ ? m = p.setByOffset("global_idx", d(y ? `${v.type.value}(${v.getByOffset("0")}.x)` : v.getByOffset("global_idx"), _ ? `${g.type.value}(${g.getByOffset("0")}.x)` : g.getByOffset("global_idx"))) : m = `
            let outputIndices = ${p.offsetToIndices("global_idx * 4u")};
            let offsetA = ${v.broadcastedIndicesToOffset("outputIndices", p)};
            let offsetB = ${g.broadcastedIndicesToOffset("outputIndices", p)};
            ${p.setByOffset("global_idx", d(o || b ? v.getByOffset("offsetA / 4u") : `${v.type.value}(${v.getByOffset("offsetA / 4u")}[offsetA % 4u])`, o || w ? g.getByOffset("offsetB / 4u") : `${g.type.value}(${g.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `;
      } else m = p.setByOffset("global_idx", d(v.getByOffset("global_idx"), g.getByOffset("global_idx")));
      else {
        if (!a) throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
        let y = (_, b, w = "") => {
          let x = `aData[indexA${b}][componentA${b}]`, T = `bData[indexB${b}][componentB${b}]`;
          return `
            let outputIndices${b} = ${p.offsetToIndices(`global_idx * 4u + ${b}u`)};
            let offsetA${b} = ${v.broadcastedIndicesToOffset(`outputIndices${b}`, p)};
            let offsetB${b} = ${g.broadcastedIndicesToOffset(`outputIndices${b}`, p)};
            let indexA${b} = offsetA${b} / 4u;
            let indexB${b} = offsetB${b} / 4u;
            let componentA${b} = offsetA${b} % 4u;
            let componentB${b} = offsetB${b} % 4u;
            ${_}[${b}] = ${w}(${f(x, T)});
          `;
        };
        c === 9 ? m = `
            var data = vec4<u32>(0);
            ${y("data", 0, "u32")}
            ${y("data", 1, "u32")}
            ${y("data", 2, "u32")}
            ${y("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));` : m = `
            ${y("outputData[global_idx]", 0)}
            ${y("outputData[global_idx]", 1)}
            ${y("outputData[global_idx]", 2)}
            ${y("outputData[global_idx]", 3)}
          `;
      }
      return `
        ${t.registerUniform("vec_size", "u32").declareVariables(v, g, p)}

        ${h ?? ""}

        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${m}
      }`;
    }, $3 = (t, e, r, n, i, a, o = r.dataType) => {
      let s = r.dims.map((v) => Number(v) ?? 1), l = n.dims.map((v) => Number(v) ?? 1), u = !re.areEqual(s, l), c = s, h = re.size(s), f = false, d = false, p = [
        u
      ];
      if (u) {
        let v = Ic.calcShape(s, l, false);
        if (!v) throw new Error("Can't perform binary op on the given tensors");
        c = v.slice(), h = re.size(c);
        let g = re.size(s) === 1, m = re.size(l) === 1, y = s.length > 0 && s[s.length - 1] % 4 === 0, _ = l.length > 0 && l[l.length - 1] % 4 === 0;
        p.push(g), p.push(m), p.push(y), p.push(_);
        let b = 1;
        for (let w = 1; w < c.length; w++) {
          let x = s[s.length - w], T = l[l.length - w];
          if (x === T) b *= x;
          else break;
        }
        b % 4 === 0 ? (d = true, f = true) : (g || m || y || _) && (f = true);
      } else f = true;
      return p.push(f), {
        name: t,
        shaderCache: {
          hint: e + p.map((v) => v.toString()).join("_"),
          inputDependencies: [
            "rank",
            "rank"
          ]
        },
        getShaderSource: (v) => L3(v, s, l, c, f, u, d, i, r.dataType, n.dataType, o, a),
        getRunData: () => ({
          outputs: [
            {
              dims: c,
              dataType: o
            }
          ],
          dispatchGroup: {
            x: Math.ceil(h / 64 / 4)
          },
          programUniforms: [
            {
              type: 12,
              data: Math.ceil(re.size(c) / 4)
            },
            ...Ve(s, l, c)
          ]
        })
      };
    }, Li = (t, e, r, n, i, a) => {
      t.compute($3(e, i ?? "", t.inputs[0], t.inputs[1], r, n, a));
    }, K6 = (t) => {
      Li(t, "Add", (e, r) => `${e}+${r}`);
    }, Z6 = (t) => {
      Li(t, "Div", (e, r) => `${e}/${r}`);
    }, Q6 = (t) => {
      Li(t, "Equal", {
        scalar: (e, r) => `u32(${e}==${r})`,
        vector: (e, r) => `vec4<u32>(${e}==${r})`
      }, void 0, void 0, 9);
    }, J6 = (t) => {
      Li(t, "Mul", (e, r) => `${e}*${r}`);
    }, e8 = (t) => {
      let e = se("input", t.inputs[0].dataType, t.inputs[0].dims).type.value;
      Li(t, "Pow", {
        scalar: (r, n) => `pow_custom(${r},${n})`,
        vector: (r, n) => `pow_vector_custom(${r},${n})`
      }, `
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e === "i32" ? "round" : ""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `);
    }, t8 = (t) => {
      Li(t, "Sub", (e, r) => `${e}-${r}`);
    }, r8 = (t) => {
      Li(t, "Greater", {
        scalar: (e, r) => `u32(${e}>${r})`,
        vector: (e, r) => `vec4<u32>(${e}>${r})`
      }, void 0, void 0, 9);
    }, n8 = (t) => {
      Li(t, "Less", {
        scalar: (e, r) => `u32(${e}<${r})`,
        vector: (e, r) => `vec4<u32>(${e}<${r})`
      }, void 0, void 0, 9);
    }, i8 = (t) => {
      Li(t, "GreaterOrEqual", {
        scalar: (e, r) => `u32(${e}>=${r})`,
        vector: (e, r) => `vec4<u32>(${e}>=${r})`
      }, void 0, void 0, 9);
    }, a8 = (t) => {
      Li(t, "LessOrEqual", {
        scalar: (e, r) => `u32(${e}<=${r})`,
        vector: (e, r) => `vec4<u32>(${e}<=${r})`
      }, void 0, void 0, 9);
    };
  }), R3, O3, N3, B3, o8, s8, Nye = ge(() => {
    Je(), ft(), ur(), mt(), R3 = (t, e) => {
      if (!t || t.length < 1) throw new Error("too few inputs");
      let r = 0, n = t[r], i = n.dataType, a = n.dims.length;
      t.forEach((o, s) => {
        if (s !== r) {
          if (o.dataType !== i) throw new Error("input tensors should be one type");
          if (o.dims.length !== a) throw new Error("input tensors should have the same shape");
          o.dims.forEach((l, u) => {
            if (u !== e && l !== n.dims[u]) throw new Error("non concat dimensions must match");
          });
        }
      });
    }, O3 = (t, e) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${t}u>(${e});
    for (var i: u32 = 0u; i < ${t}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t}u;
  }`, N3 = (t, e) => {
      let r = t.length, n = [];
      for (let i = 0; i < r; ++i) {
        let a = e.setByOffset("global_idx", t[i].getByIndices("indices"));
        r === 1 ? n.push(a) : i === 0 ? n.push(`if (inputIndex == ${i}u) { ${a} }`) : i === r - 1 ? n.push(`else { ${a} }`) : n.push(`else if (inputIndex == ${i}) { ${a} }`);
      }
      return n.join(`
`);
    }, B3 = (t, e, r, n) => {
      let i = re.size(r), a = new Array(t.length), o = new Array(t.length), s = 0, l = [], u = [], c = [
        {
          type: 12,
          data: i
        }
      ];
      for (let v = 0; v < t.length; ++v) s += t[v].dims[e], a[v] = s, u.push(t[v].dims.length), o[v] = se(`input${v}`, n, u[v]), l.push("rank"), c.push({
        type: 12,
        data: a[v]
      });
      for (let v = 0; v < t.length; ++v) c.push(...Ve(t[v].dims));
      c.push(...Ve(r));
      let h = Re("output", n, r.length), f = h.indicesGet("indices", e), d = Array.from(Array(a.length).keys()).map((v) => `uniforms.sizeInConcatAxis${v}`).join(","), p = (v) => `

  ${(() => {
        v.registerUniform("outputSize", "u32");
        for (let g = 0; g < t.length; g++) v.registerUniform(`sizeInConcatAxis${g}`, "u32");
        return v.declareVariables(...o, h);
      })()}

  ${O3(a.length, d)}

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${h.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${f});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${a.length}u>(${d});
      ${f} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${N3(o, h)}
  }`;
      return {
        name: "Concat",
        shaderCache: {
          hint: `${e}`,
          inputDependencies: l
        },
        getRunData: () => ({
          outputs: [
            {
              dims: r,
              dataType: n
            }
          ],
          dispatchGroup: {
            x: Math.ceil(i / 64)
          },
          programUniforms: c
        }),
        getShaderSource: p
      };
    }, o8 = (t, e) => {
      let r = t.inputs, n = r[0].dims, i = re.normalizeAxis(e.axis, n.length);
      R3(r, i);
      let a = n.slice();
      a[i] = r.reduce((s, l) => s + (l.dims.length > i ? l.dims[i] : 0), 0);
      let o = r.filter((s) => re.size(s.dims) > 0);
      t.compute(B3(o, i, a, r[0].dataType), {
        inputs: o
      });
    }, s8 = (t) => Bt({
      axis: t.axis
    });
  }), Ql, Jl, eu, vC, fu = ge(() => {
    Je(), ft(), Ql = (t, e, r = "f32") => {
      switch (t.activation) {
        case "Relu":
          return `value = max(value, ${e}(0.0));`;
        case "Sigmoid":
          return `value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;
        case "Clip":
          return `value = clamp(value, ${e}(${r}(uniforms.clip_min)), ${e}(${r}(uniforms.clip_max)));`;
        case "HardSigmoid":
          return `value = max(${e}(0.0), min(${e}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;
        case "LeakyRelu":
          return `value = select(${r}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;
        case "Tanh":
          return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
        case "":
          return "";
        default:
          throw new Error(`Unsupported activation ${t.activation}`);
      }
    }, Jl = (t, e) => {
      t.activation === "Clip" ? e.push({
        type: 1,
        data: t.clipMax
      }, {
        type: 1,
        data: t.clipMin
      }) : t.activation === "HardSigmoid" ? e.push({
        type: 1,
        data: t.alpha
      }, {
        type: 1,
        data: t.beta
      }) : t.activation === "LeakyRelu" && e.push({
        type: 1,
        data: t.alpha
      });
    }, eu = (t, e) => {
      t.activation === "Clip" ? e.push({
        name: "clip_max",
        type: "f32"
      }, {
        name: "clip_min",
        type: "f32"
      }) : t.activation === "HardSigmoid" ? e.push({
        name: "alpha",
        type: "f32"
      }, {
        name: "beta",
        type: "f32"
      }) : t.activation === "LeakyRelu" && e.push({
        name: "alpha",
        type: "f32"
      });
    }, vC = (t) => {
      let e = (t == null ? void 0 : t.activation) || "";
      if (e === "HardSigmoid") {
        let [r, n] = (t == null ? void 0 : t.activation_params) || [
          0.2,
          0.5
        ];
        return {
          activation: e,
          alpha: r,
          beta: n
        };
      } else if (e === "Clip") {
        let [r, n] = (t == null ? void 0 : t.activation_params) || [
          NU,
          BU
        ];
        return {
          activation: e,
          clipMax: n,
          clipMin: r
        };
      } else if (e === "LeakyRelu") {
        let [r] = (t == null ? void 0 : t.activation_params) || [
          0.01
        ];
        return {
          activation: e,
          alpha: r
        };
      }
      return {
        activation: e
      };
    };
  }), Nr, l8, gC = ge(() => {
    Nr = (t, e) => {
      switch (t) {
        case 1:
          return e;
        case 2:
          return `vec2<${e}>`;
        case 3:
          return `vec3<${e}>`;
        case 4:
          return `vec4<${e}>`;
        default:
          throw new Error(`${t}-component is not supported.`);
      }
    }, l8 = (t) => `
      ${t ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
  }), u8, Bye = ge(() => {
    u8 = (t) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${t}.x), i32(${t}.y), i32(${t}.z), 1));
}
`;
  }), Lf, mC, yC = ge(() => {
    Je(), ft(), mt(), fu(), Lf = (t, e, r, n, i) => {
      let a = n - r;
      return `
      ${Array.from({
        length: r
      }).map((o, s) => `
      if (${Ne(e.shape, s, e.rank)} != 1) {
        ${e.indicesSet(t, s, Ne(i, s + a, n))}
      } else {
        ${e.indicesSet(t, s, 0)}
      }`).join("")}
`;
    }, mC = (t, e, r, n, i = false, a) => {
      let o = t[0].dims, s = t[1].dims, l = o[o.length - 2], u = s[s.length - 1], c = o[o.length - 1], h = or(u), f = or(c), d = or(l), p = re.size(r) / h / d, v = t.length > 2, g = n ? n.slice(0, -2) : r.slice(0, -2), m = [
        re.size(g),
        l,
        u
      ], y = [
        {
          type: 12,
          data: p
        },
        {
          type: 12,
          data: l
        },
        {
          type: 12,
          data: u
        },
        {
          type: 12,
          data: c
        }
      ];
      Jl(e, y), y.push(...Ve(g, o, s)), v && y.push(...Ve(t[2].dims)), y.push(...Ve(m));
      let _ = (b) => {
        let w = hC("batch_dims", t[0].dataType, g.length), x = se("a", t[0].dataType, o.length, f), T = se("b", t[1].dataType, s.length, h), A = Re("output", t[0].dataType, m.length, h), I = kr(A.type.tensor), M = Ql(e, A.type.value, I), k = [
          x,
          T
        ], B = "";
        if (v) {
          let F = i ? h : 1;
          k.push(se("bias", t[2].dataType, t[2].dims.length, F)), B = `${i ? `value += bias[col / ${F}];` : `value += ${A.type.value}(bias[row + i]);`}`;
        }
        let L = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "M",
            type: "u32"
          },
          {
            name: "N",
            type: "u32"
          },
          {
            name: "K",
            type: "u32"
          }
        ];
        eu(e, L);
        let z = () => {
          let F = `var a_data: ${x.type.value};`;
          for (let E = 0; E < f; E++) F += `
              let b_data${E} = b[(b_offset + (k + ${E}) * uniforms.N + col) / ${h}];`;
          for (let E = 0; E < d; E++) {
            F += `a_data = a[(a_offset + (row + ${E}) * uniforms.K + k) / ${f}];`;
            for (let O = 0; O < f; O++) F += `
            values[${E}] = fma(${T.type.value}(a_data${f === 1 ? "" : `[${O}]`}), b_data${O}, values[${E}]);
`;
          }
          return F;
        };
        return `
  ${b.registerUniforms(L).registerInternalVariables(w).declareVariables(...k, A)}
  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${h})) * ${h};
    var index1 = global_idx / (uniforms.N / ${h});
    let stride1 = uniforms.M / ${d};
    let row = (index1 % stride1) * ${d};
    let batch = index1 / stride1;

    ${r.length === 2 ? "" : `let batch_indices = ${w.offsetToIndices("batch")};`}

    var a_indices: ${x.type.indices};
    ${Lf("a_indices", x, x.rank - 2, w.rank, "batch_indices")}
    ${x.indicesSet("a_indices", x.rank - 2, 0)}
    ${x.indicesSet("a_indices", x.rank - 1, 0)}
    let a_offset = ${x.indicesToOffset("a_indices")};

    var b_indices: ${T.type.indices};
    ${Lf("b_indices", T, T.rank - 2, w.rank, "batch_indices")}
    ${T.indicesSet("b_indices", T.rank - 2, 0)}
    ${T.indicesSet("b_indices", T.rank - 1, 0)}
    let b_offset = ${T.indicesToOffset("b_indices")};
    var values: array<${A.type.value}, ${d}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${f}) {
      ${z()}
    }
    for (var i = 0u; i < ${d}u; i++) {
      var value = values[i];
      ${B}
      ${M}
      let cur_indices = ${A.type.indices}(batch, row + i, col);
      let offset = ${A.indicesToOffset("cur_indices")};
      ${A.setByOffset(`offset / ${h}`, "value")};
    }
  }
  `;
      };
      return {
        name: "MatMulNaive",
        shaderCache: {
          hint: `${e.activation};${h};${f};${d};${i}`,
          inputDependencies: v ? [
            "rank",
            "rank",
            "rank"
          ] : [
            "rank",
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: a ? a(r) : r,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(p / 64)
          },
          programUniforms: y
        }),
        getShaderSource: _
      };
    };
  }), z3, F3, Kw, $b, V3, Zw, G3, xm, _C = ge(() => {
    Je(), ft(), mt(), fu(), yC(), gC(), z3 = (t, e) => t ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e ? ", batchIndices" : ""});
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e ? ", batchIndices" : ""});
        `, F3 = (t, e) => t ? `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }` : `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`, Kw = (t, e, r = "f32", n, i = false, a = 32, o = false, s = 32) => {
      let l = e[1] * t[1], u = e[0] * t[0], c = i ? l : a, h = i ? a : l, f = c / e[0], d = a / e[1];
      if (!((i && f === 4 && t[1] === 4 || !i && (f === 3 || f === 4)) && c % e[0] === 0 && a % e[1] === 0 && t[0] === 4)) throw new Error(`If transposeA ${i} is true, innerElementSize ${f} and workPerThread[1] ${t[1]} must be 4.
      Otherwise, innerElementSize ${f} must be 3 or 4.
  tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`);
      return `
var<workgroup> mm_Asub: array<array<vec${f}<${r}>, ${c / f}>, ${h}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${u / t[0]}>, ${a}>;

const rowPerThread = ${t[1]};
const colPerThread = ${t[0]};
const innerElementSize = ${f};
const tileInner = ${a};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${o ? "0" : "i32(globalId.z)"};
  ${n ? `let batchIndices = ${n.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${l};

  let num_tiles = ${o ? `${Math.ceil(s / a)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${o ? `i32(globalId.z) * ${s}` : "0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${d};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${z3(i, n)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${f === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${F3(i, f)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
    }, $b = (t, e) => t ? `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e ? ", batchIndices" : ""});
            ` : `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e ? ", batchIndices" : ""});
            `, V3 = (t) => t ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];", Zw = (t, e, r = "f32", n, i = false, a = 32, o = false, s = 32, l = false) => {
      let u = t[1] * e[1], c = t[0] * e[0], h = i ? u : a, f = i ? a : u;
      if (!(f % e[1] === 0 && h % e[0] === 0 && a % e[1] === 0)) throw new Error(`tileAHight ${f} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${e[0]}, tileInner ${a} must be divisible by workgroupSize[1]${e[1]}`);
      let d = f / e[1], p = h / e[0], v = a / e[1], g = l ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${u};
    let globalColStart = i32(workgroupId.x) * ${c};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${e[0]}) {
          ${$b(i, n)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${n ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${i ? `mm_Asub[k][localRow + innerRow * ${e[1]}];` : `mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${u};

let tileRowA = i32(localId.y) * ${d};
let tileColA = i32(localId.x) * ${p};
let tileRowB = i32(localId.y) * ${v};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${p}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${$b(i, n)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${v}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${n ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${V3(i)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
      return `
  var<workgroup> mm_Asub : array<array<${r}, ${h}>, ${f}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${c}>, ${a}>;
  const rowPerThread = ${t[1]};
  const colPerThread = ${t[0]};
  const tileInner = ${a};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${o ? "0" : "i32(globalId.z)"};
    ${n ? `let batchIndices = ${n.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${o ? `${Math.ceil(s / a)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${o ? `i32(globalId.z) * ${s}` : "0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;
    ${g}
  }
`;
    }, G3 = (t, e, r, n, i = false) => {
      let [a, o, s, l] = n, u = kr(n[0].type.tensor);
      return `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Nr(t, u)} {
      var value = ${Nr(t, u)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${o.type.indices};
        ${Lf("aIndices", o, o.rank - 2, a.rank, "batchIndices")}
        ${o.indicesSet("aIndices", o.rank - 2, "u32(row)")}
        ${o.indicesSet("aIndices", o.rank - 1, "u32(colIn)")}
        value = ${o.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Nr(t, u)} {
      var value = ${Nr(t, u)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${s.type.indices};
        ${Lf("bIndices", s, s.rank - 2, a.rank, "batchIndices")}
        ${s.indicesSet("bIndices", s.rank - 2, "u32(row)")}
        ${s.indicesSet("bIndices", s.rank - 1, "u32(colIn)")}
        value = ${s.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Nr(t, u)}) {
      let col = colIn * ${t};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e ? `value = value + ${i ? "bias[colIn]" : `${Nr(t, u)}(bias[row])`};` : ""}
        ${r}
        ${l.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
    }, xm = (t, e, r, n, i = false, a) => {
      let o = t[0].dims, s = t[1].dims, l = o.slice(0, -2), u = s.slice(0, -2), c = n ? n.slice(0, -2) : r.slice(0, -2), h = re.size(c), f = o[o.length - 2], d = o[o.length - 1], p = s[s.length - 1], v = d % 4 === 0 && p % 4 === 0, g = f <= 8 ? [
        4,
        1,
        1
      ] : [
        4,
        4,
        1
      ], m = [
        8,
        8,
        1
      ], y = [
        Math.ceil(p / m[0] / g[0]),
        Math.ceil(f / m[1] / g[1]),
        Math.ceil(h / m[2] / g[2])
      ], _ = v ? 4 : 1, b = [
        ...l,
        f,
        d / _
      ], w = b.length, x = [
        ...u,
        d,
        p / _
      ], T = x.length, A = [
        h,
        f,
        p / _
      ], I = [
        {
          type: 6,
          data: f
        },
        {
          type: 6,
          data: p
        },
        {
          type: 6,
          data: d
        }
      ];
      Jl(e, I), I.push(...Ve(c, b, x));
      let M = [
        "rank",
        "rank"
      ], k = t.length > 2;
      k && (I.push(...Ve(t[2].dims)), M.push("rank")), I.push(...Ve(A));
      let B = (L) => {
        let z = c.length, F = hC("batchDims", t[0].dataType, z, 1), E = kr(t[0].dataType), O = se("a", t[0].dataType, w, _), N = se("b", t[1].dataType, T, _), V = Re("result", t[0].dataType, A.length, _), H = [
          O,
          N
        ];
        if (k) {
          let ee = i ? _ : 1;
          H.push(se("bias", t[2].dataType, t[2].dims.length, ee));
        }
        let G = [
          {
            name: "dim_a_outer",
            type: "i32"
          },
          {
            name: "dim_b_outer",
            type: "i32"
          },
          {
            name: "dim_inner",
            type: "i32"
          }
        ];
        eu(e, G);
        let Y = kr(V.type.tensor), U = Ql(e, V.type.value, Y), Z = G3(_, k, U, [
          F,
          O,
          N,
          V
        ], i);
        return `
  ${L.registerUniforms(G).registerInternalVariables(F).declareVariables(...H, V)}
  ${Z}
  ${v ? Kw(g, m, E, F) : Zw(g, m, E, F)}
                   `;
      };
      return {
        name: "MatMul",
        shaderCache: {
          hint: `${g};${e.activation};${v};${i}`,
          inputDependencies: M
        },
        getRunData: () => ({
          outputs: [
            {
              dims: a ? a(r) : r,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: y[0],
            y: y[1],
            z: y[2]
          },
          programUniforms: I
        }),
        getShaderSource: B
      };
    };
  }), W3, c8, zye = ge(() => {
    Je(), To(), mt(), fu(), gC(), Bye(), _C(), W3 = (t, e, r, n, i = false, a, o = 4, s = 4, l = 4, u = "f32") => {
      let c = (I) => {
        switch (I) {
          case 1:
            return "resData = x[xIndex];";
          case 3:
            return `resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
          case 4:
            return "resData = x[xIndex / 4];";
          default:
            throw new Error(`innerElementSize ${I} is not supported.`);
        }
      }, h = (I) => {
        switch (I) {
          case 1:
            return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
          case 4:
            return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
          default:
            throw new Error(`innerElementSize ${I} is not supported.`);
        }
      }, f = t ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `, d = t ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `, p = t ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])", v = t ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])", g = t ? "row" : "col", m = t ? "col" : "row", y = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${t ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${g} / outWidth;
    let outCol = ${g} % outWidth;

    let WRow = ${m} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${m} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${m} % inChannels;
    var resData = ${Nr(o, u)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${v}) {
      ${f}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${c(o)}
    }
    return resData;`, _ = t ? e && n ? `
    let col = colIn * ${o};
    ${y}` : `
    let col = colIn * ${o};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${y}
    }
    return ${Nr(o, u)}(0.0);` : n && r ? `
    let col = colIn * ${o};
    ${y}` : `
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${y}
    }
    return ${Nr(o, u)}(0.0);`, b = t ? n && r ? h(s) : `
    let col = colIn * ${s};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${h(s)}
    }
    return ${Nr(s, u)}(0.0);` : `
    let col = colIn * ${s};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${h(s)}
    }
    return ${Nr(s, u)}(0.0);`, w = Nr(l, u), x = Nr(t ? o : s, u), T = Nr(t ? s : o, u), A = Ql(a, w, u);
      return `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${x} {
      ${t ? _ : b}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${T} {
      ${t ? b : _}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {
      let col = colIn * ${l};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${t ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${d}
      ${l8(i)}
      ${A}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
    }, c8 = (t, e, r, n, i, a, o, s, l) => {
      let u = e.format === "NHWC", c = u ? t[0].dims[3] : t[0].dims[1], h = r[0], f = u ? r[2] : r[3], d = u ? r[1] : r[2], p = u ? r[3] : r[1], v = u && (c % 4 === 0 || c % 3 === 0) && p % 4 === 0, g = u ? p : f * d, m = u ? f * d : p, y = [
        8,
        8,
        1
      ], _ = n <= 8 ? [
        4,
        1,
        1
      ] : [
        4,
        4,
        1
      ], b = [
        Math.ceil(g / y[0] / _[0]),
        Math.ceil(m / y[1] / _[1]),
        Math.ceil(h / y[2] / _[2])
      ];
      Mt("verbose", () => `[conv2d_mm_webgpu] dispatch = ${b}`);
      let w = v ? u && c % 4 !== 0 ? 3 : 4 : 1, x = y[1] * _[1], T = y[0] * _[0], A = Math.max(y[0] * w, y[1]), I = n % x === 0, M = i % T === 0, k = a % A === 0, B = v ? [
        w,
        4,
        4
      ] : [
        1,
        1,
        1
      ], L = [
        {
          type: 6,
          data: n
        },
        {
          type: 6,
          data: i
        },
        {
          type: 6,
          data: a
        },
        {
          type: 6,
          data: [
            e.pads[0],
            e.pads[1]
          ]
        },
        {
          type: 6,
          data: e.strides
        },
        {
          type: 6,
          data: e.dilations
        }
      ];
      Jl(e, L), L.push(...Ve(t[0].dims, t[1].dims));
      let z = [
        "rank",
        "rank"
      ];
      o && (L.push(...Ve(t[2].dims)), z.push("rank")), L.push(...Ve(r));
      let F = (E) => {
        let O = [
          {
            name: "dim_a_outer",
            type: "i32"
          },
          {
            name: "dim_b_outer",
            type: "i32"
          },
          {
            name: "dim_inner",
            type: "i32"
          },
          {
            name: "pad",
            type: "i32",
            length: 2
          },
          {
            name: "stride",
            type: "i32",
            length: 2
          },
          {
            name: "dilation",
            type: "i32",
            length: 2
          }
        ];
        eu(e, O);
        let N = v ? 4 : 1, V = kr(t[0].dataType), H = `
      fn setOutputAtIndex(flatIndex : i32, value : ${v ? `vec4<${V}>` : V}) {
        result[flatIndex] = ${v ? `vec4<${V}>` : V}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v ? `vec4<${V}>` : V}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${v ? "/ 4" : ""}, value);
      }`, G = se("x", t[0].dataType, t[0].dims.length, w === 3 ? 1 : w), Y = se("w", t[1].dataType, t[1].dims.length, N), U = [
          G,
          Y
        ], Z = Re("result", t[0].dataType, r.length, N);
        if (o) {
          let ee = se("bias", t[2].dataType, t[2].dims.length, N);
          U.push(ee), H += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v ? `vec4<${V}>` : V} {
          return bias[coords.${u ? "w" : "y"}${v ? "/ 4" : ""}];
        }`;
        }
        return `
        ${u8("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${E.registerUniforms(O).declareVariables(...U, Z)}
        ${H}
        ${W3(u, I, M, k, o, e, B[0], B[1], B[2], V)}
        ${v ? Kw(_, y, V, void 0, !u, A) : Zw(_, y, V, void 0, !u, A, false, void 0, s)}`;
      };
      return {
        name: "Conv2DMatMul",
        shaderCache: {
          hint: `${e.cacheKey};${w};${v};${I};${M};${k};${x};${T};${A}`,
          inputDependencies: z
        },
        getRunData: () => ({
          outputs: [
            {
              dims: l ? l(r) : r,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: b[0],
            y: b[1],
            z: b[2]
          },
          programUniforms: L
        }),
        getShaderSource: F
      };
    };
  }), H3, Rb, Nh, U3, Ob, Y3, h8, f8, Fye = ge(() => {
    Je(), To(), ft(), mt(), fu(), gC(), H3 = (t) => {
      let e = 1;
      for (let r = 0; r < t.length; r++) e *= t[r];
      return e;
    }, Rb = (t) => typeof t == "number" ? [
      t,
      t,
      t
    ] : t, Nh = (t, e) => e <= 1 ? t : t + (t - 1) * (e - 1), U3 = (t, e, r, n = 1) => {
      let i = Nh(e, n);
      return Math.floor((t[0] * (r - 1) - r + i) / 2);
    }, Ob = (t, e, r, n, i) => {
      i == null && (i = U3(t, e[0], n[0]));
      let a = [
        0,
        0,
        0,
        r
      ];
      for (let o = 0; o < 3; o++) t[o] + 2 * i >= e[o] && (a[o] = Math.trunc((t[o] - e[o] + 2 * i) / n[o] + 1));
      return a;
    }, Y3 = (t, e, r, n, i, a, o, s, l, u) => {
      let c, h, f, d;
      if (t === "VALID" && (t = 0), typeof t == "number") {
        c = {
          top: t,
          bottom: t,
          left: t,
          right: t,
          front: t,
          back: t
        };
        let p = Ob([
          e,
          r,
          n,
          1
        ], [
          s,
          l,
          u
        ], 1, [
          i,
          a,
          o
        ], t);
        h = p[0], f = p[1], d = p[2];
      } else if (Array.isArray(t)) {
        if (!t.every((v, g, m) => v === m[0])) throw Error(`Unsupported padding parameter: ${t}`);
        c = {
          top: t[0],
          bottom: t[1],
          left: t[2],
          right: t[3],
          front: t[4],
          back: t[5]
        };
        let p = Ob([
          e,
          r,
          n,
          1
        ], [
          s,
          l,
          u
        ], 1, [
          i,
          a,
          o
        ], t[0]);
        h = p[0], f = p[1], d = p[2];
      } else if (t === "SAME_UPPER") {
        h = Math.ceil(e / i), f = Math.ceil(r / a), d = Math.ceil(n / o);
        let p = (h - 1) * i + s - e, v = (f - 1) * a + l - r, g = (d - 1) * o + u - n, m = Math.floor(p / 2), y = p - m, _ = Math.floor(v / 2), b = v - _, w = Math.floor(g / 2), x = g - w;
        c = {
          top: _,
          bottom: b,
          left: w,
          right: x,
          front: m,
          back: y
        };
      } else throw Error(`Unknown padding parameter: ${t}`);
      return {
        padInfo: c,
        outDepth: h,
        outHeight: f,
        outWidth: d
      };
    }, h8 = (t, e, r, n, i, a = false, o = "channelsLast") => {
      let s, l, u, c, h;
      if (o === "channelsLast") [s, l, u, c, h] = t;
      else if (o === "channelsFirst") [s, h, l, u, c] = t;
      else throw new Error(`Unknown dataFormat ${o}`);
      let [f, , d, p, v] = e, [g, m, y] = Rb(r), [_, b, w] = Rb(n), x = Nh(d, _), T = Nh(p, b), A = Nh(v, w), { padInfo: I, outDepth: M, outHeight: k, outWidth: B } = Y3(i, l, u, c, g, m, y, x, T, A), L = a ? f * h : f, z = [
        0,
        0,
        0,
        0,
        0
      ];
      return o === "channelsFirst" ? z = [
        s,
        L,
        M,
        k,
        B
      ] : o === "channelsLast" && (z = [
        s,
        M,
        k,
        B,
        L
      ]), {
        batchSize: s,
        dataFormat: o,
        inDepth: l,
        inHeight: u,
        inWidth: c,
        inChannels: h,
        outDepth: M,
        outHeight: k,
        outWidth: B,
        outChannels: L,
        padInfo: I,
        strideDepth: g,
        strideHeight: m,
        strideWidth: y,
        filterDepth: d,
        filterHeight: p,
        filterWidth: v,
        effectiveFilterDepth: x,
        effectiveFilterHeight: T,
        effectiveFilterWidth: A,
        dilationDepth: _,
        dilationHeight: b,
        dilationWidth: w,
        inShape: t,
        outShape: z,
        filterShape: e
      };
    }, f8 = (t, e, r, n, i, a) => {
      let o = a === "channelsLast";
      o ? t[0].dims[3] : t[0].dims[1];
      let s = [
        64,
        1,
        1
      ], l = {
        x: r.map((g, m) => m)
      }, u = [
        Math.ceil(H3(l.x.map((g) => r[g])) / s[0]),
        1,
        1
      ];
      Mt("verbose", () => `[conv3d_naive_webgpu] dispatch = ${u}`);
      let c = 1, h = re.size(r), f = [
        {
          type: 12,
          data: h
        },
        {
          type: 12,
          data: n
        },
        {
          type: 12,
          data: i
        },
        {
          type: 12,
          data: e.strides
        },
        {
          type: 12,
          data: e.dilations
        }
      ];
      Jl(e, f), f.push(...Ve(t[0].dims, t[1].dims));
      let d = [
        "rank",
        "rank"
      ], p = t.length === 3;
      p && (f.push(...Ve(t[2].dims)), d.push("rank")), f.push(...Ve(r));
      let v = (g) => {
        let m = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "filter_dims",
            type: "u32",
            length: n.length
          },
          {
            name: "pads",
            type: "u32",
            length: i.length
          },
          {
            name: "strides",
            type: "u32",
            length: e.strides.length
          },
          {
            name: "dilations",
            type: "u32",
            length: e.dilations.length
          }
        ];
        eu(e, m);
        let y = 1, _ = kr(t[0].dataType), b = se("x", t[0].dataType, t[0].dims.length, c), w = se("W", t[1].dataType, t[1].dims.length, y), x = [
          b,
          w
        ], T = Re("result", t[0].dataType, r.length, y), A = "";
        if (p) {
          let k = se("bias", t[2].dataType, t[2].dims.length, y);
          x.push(k), A += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${_} {
          return bias[${o ? Ne("coords", 4, 5) : Ne("coords", 1, 5)}];
        }`;
        }
        let I = Nr(c, _), M = Ql(e, I, _);
        return `
            ${A}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${b.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${g.registerUniforms(m).declareVariables(...x, T)}
          ${g.mainStart()}
          ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${T.offsetToIndices("global_idx")};
              let batch = ${Ne("coords", 0, b.rank)};
              let d2 = ${o ? Ne("coords", b.rank - 1, b.rank) : Ne("coords", 1, b.rank)};
              let xFRCCorner = vec3<u32>(${o ? Ne("coords", 1, b.rank) : Ne("coords", 2, b.rank)},
              ${o ? Ne("coords", 2, b.rank) : Ne("coords", 3, b.rank)},
              ${o ? Ne("coords", 3, b.rank) : Ne("coords", 4, b.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${o ? Ne("uniforms.x_shape", 1, b.rank) : Ne("uniforms.x_shape", 2, b.rank)};
              let xShapeZ = ${o ? Ne("uniforms.x_shape", 2, b.rank) : Ne("uniforms.x_shape", 3, b.rank)};
              let xShapeW = ${o ? Ne("uniforms.x_shape", 3, b.rank) : Ne("uniforms.x_shape", 4, b.rank)};
              let xShapeU = ${o ? Ne("uniforms.x_shape", 4, b.rank) : Ne("uniforms.x_shape", 1, b.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${o ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${o ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${o ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${o ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${p ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${M}
              result[global_idx] = f32(value);
          }`;
      };
      return {
        name: "Conv3DNaive",
        shaderCache: {
          hint: `${e.cacheKey};${o};${c};${p}`,
          inputDependencies: d
        },
        getRunData: () => ({
          outputs: [
            {
              dims: r,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: u[0],
            y: u[1],
            z: u[2]
          },
          programUniforms: f
        }),
        getShaderSource: v
      };
    };
  }), d8, p8, Vye = ge(() => {
    Je(), ft(), mt(), fu(), d8 = (t, e, r, n) => {
      let i = t.length > 2, a = i ? "value += b[output_channel];" : "", o = t[0].dims, s = t[1].dims, l = e.format === "NHWC", u = l ? r[3] : r[1], c = u / e.group, h = l && c >= 4 ? or(u) : 1, f = re.size(r) / h, d = [
        {
          type: 12,
          data: f
        },
        {
          type: 12,
          data: e.dilations
        },
        {
          type: 12,
          data: [
            e.strides[0],
            e.strides[1]
          ]
        },
        {
          type: 12,
          data: [
            e.pads[0],
            e.pads[1]
          ]
        },
        {
          type: 12,
          data: c
        }
      ];
      Jl(e, d), d.push(...Ve(o, [
        s[0],
        s[1],
        s[2],
        s[3] / h
      ]));
      let p = i ? [
        "rank",
        "rank",
        "rank"
      ] : [
        "rank",
        "rank"
      ];
      d.push(...Ve([
        r[0],
        r[1],
        r[2],
        r[3] / h
      ]));
      let v = (g) => {
        let m = Re("output", t[0].dataType, r.length, h), y = kr(m.type.tensor), _ = Ql(e, m.type.value, y), b = se("x", t[0].dataType, o.length), w = se("w", t[1].dataType, s.length, h), x = [
          b,
          w
        ];
        i && x.push(se("b", t[2].dataType, t[2].dims, h));
        let T = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "dilations",
            type: "u32",
            length: e.dilations.length
          },
          {
            name: "strides",
            type: "u32",
            length: 2
          },
          {
            name: "pads",
            type: "u32",
            length: 2
          },
          {
            name: "output_channels_per_group",
            type: "u32"
          }
        ];
        eu(e, T);
        let A = l ? `
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${b.get("batch", "xHeight", "xWidth", "input_channel")};
            let wVal = ${w.get("wHeight", "wWidth", "wInChannel", "output_channel")};
            value += xVal * wVal;
          }
        }
      }
      ` : `
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${b.get("batch", "input_channel", "xHeight", "xWidth")};
            let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;
        return `
  ${g.registerUniforms(T).declareVariables(...x, m)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${m.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${l ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l ? 1 : 2}], outputIndices[${l ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${h} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${l ? 2 : 1}];

    var value: ${m.type.value} = ${m.type.value}(0);
    ${A}
    ${a}
    ${_}
    ${m.setByOffset("global_idx", "value")}
  }`;
      };
      return {
        name: "GroupedConv",
        shaderCache: {
          hint: `${e.cacheKey}_${h}`,
          inputDependencies: p
        },
        getRunData: () => ({
          outputs: [
            {
              dims: n ? n(r) : r,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(f / 64)
          },
          programUniforms: d
        }),
        getShaderSource: v
      };
    }, p8 = (t, e, r, n) => {
      let i = t.length > 2, a = or(r[3]), o = or(r[2]), s = re.size(r) / a / o, l = [
        t[0].dims[0],
        t[0].dims[1],
        t[0].dims[2],
        t[0].dims[3] / a
      ], u = [
        t[1].dims[0],
        t[1].dims[1],
        t[1].dims[2],
        t[1].dims[3] / a
      ], c = [
        r[0],
        r[1],
        r[2],
        r[3] / a
      ], h = [
        {
          type: 12,
          data: s
        },
        {
          type: 6,
          data: [
            e.strides[0],
            e.strides[1]
          ]
        },
        {
          type: 6,
          data: [
            e.pads[0],
            e.pads[1]
          ]
        }
      ];
      Jl(e, h), h.push(...Ve(l, u, c));
      let f = (o - 1) * e.strides[1] + u[1], d = (p) => {
        let v = Re("output", t[0].dataType, c.length, a), g = kr(v.type.tensor), m = Ql(e, v.type.value, g), y = se("x", t[0].dataType, l.length, a), _ = se("w", t[1].dataType, u.length, a), b = [
          y,
          _
        ];
        i && b.push(se("b", t[2].dataType, t[2].dims, a));
        let w = i ? "value += b[output_channel];" : "", x = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "strides",
            type: "i32",
            length: 2
          },
          {
            name: "pads",
            type: "i32",
            length: 2
          }
        ];
        return eu(e, x), `
  ${p.registerUniforms(x).declareVariables(...b, v)}
  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${o}u;
    let col = (index1 % width1) * ${o}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${y.type.value}, ${f}>;
    var values: array<${v.type.value}, ${o}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${f}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${y.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${y.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {
          let w_val = ${_.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${o}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${o}u; i++) {
      var value = values[i];
      ${w}
      ${m}
      ${v.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
      };
      return {
        name: "GroupedConv-Vectorize",
        shaderCache: {
          hint: `${e.cacheKey};${a};${o};${f};${u[0]};${u[1]}`,
          inputDependencies: i ? [
            "rank",
            "rank",
            "type"
          ] : [
            "rank",
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: n ? n(r) : r,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(s / 64)
          },
          programUniforms: h
        }),
        getShaderSource: d
      };
    };
  }), q3, wv, X3, Sv, Qw, Nb, j3, K3, Jw, Gye = ge(() => {
    ft(), zye(), Fye(), _C(), Vye(), fu(), yC(), ws(), q3 = (t, e, r, n, i, a) => {
      let o = t[0], s = t.slice(a ? 1 : 2, a ? 3 : 4), l = s.length, u = e[0], c = e.slice(2).map((f, d) => f + (f - 1) * (r[d] - 1)), h = s.map((f, d) => f + n[d] + n[d + l]).map((f, d) => Math.floor((f - c[d] + i[d]) / i[d]));
      return h.splice(0, 0, o), h.splice(a ? 3 : 1, 0, u), h;
    }, wv = [
      2,
      3,
      1,
      0
    ], X3 = (t, e) => {
      if (!t || t.length !== 2 && t.length !== 3) throw new Error("Conv requires 2 or 3 inputs");
      if (t[0].dims.length > 5) throw new Error("greater than 5D is not supported");
      if (t[0].dims.length !== t[1].dims.length) throw new Error("filter does not have same dimension as input");
      let r = t[0].dims[e.format === "NHWC" ? t[0].dims.length - 1 : 1], n = t[1].dims[1] * e.group;
      if (r !== n) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      if (t.length === 3 && (t[2].dims.length !== 1 || t[1].dims[0] !== t[2].dims[0])) throw new Error("invalid bias");
      let i = t[0].dims.length - 2;
      if (e.dilations.length !== i) throw new Error(`dilations should be ${i}D`);
      if (e.strides.length !== i) throw new Error(`strides should be ${i}D`);
      if (e.pads.length !== i * 2) throw new Error(`pads should be ${i * 2}D`);
      if (e.kernelShape.length !== 0 && e.kernelShape.length !== t[1].dims.length - 2) throw new Error("invalid kernel shape");
    }, Sv = (t, e) => {
      let r = t.kernelShape.slice();
      r.length < e[1].dims.length - 2 && r.push(...Array(e[1].dims.length - 2 - r.length).fill(0));
      for (let a = 2; a < e[1].dims.length; ++a) r[a - 2] === 0 && (r[a - 2] = e[1].dims[a]);
      let n = t.pads.slice();
      _m.adjustPadsBasedOnAutoPad(e[0].dims, t.strides, t.dilations, r, n, t.format === "NHWC", t.autoPad);
      let i = Object.assign({}, t);
      return Object.assign(i, {
        kernelShape: r,
        pads: n
      }), i;
    }, Qw = (t) => {
      let e = vC(t), r = t.format, n = [
        "NOTSET",
        "VALID",
        "SAME_UPPER",
        "SAME_LOWER"
      ][t.auto_pad], i = t.dilations, a = t.group, o = t.kernel_shape, s = t.pads, l = t.strides, u = t.w_is_const();
      return {
        autoPad: n,
        format: r,
        dilations: i,
        group: a,
        kernelShape: o,
        pads: s,
        strides: l,
        wIsConst: u,
        ...e,
        cacheKey: `${t.format};${e.activation};`
      };
    }, Nb = (t, e, r, n) => {
      let i = r.format === "NHWC", a = q3(e[0].dims, e[1].dims, r.dilations, r.pads, r.strides, i);
      if (r.group !== 1) {
        let x = [
          e[0]
        ];
        if (i) {
          let T = t.kernelCustomData.wT ?? t.compute(qn(e[1], wv), {
            inputs: [
              1
            ],
            outputs: [
              r.wIsConst ? -2 : -1
            ]
          })[0];
          r.wIsConst && !t.kernelCustomData.wT && (t.kernelCustomData.wT = T), x.push(T);
        } else x.push(e[1]);
        e.length === 3 && x.push(e[2]), !t.adapterInfo.isArchitecture("ampere") && i && e[1].dims[0] === r.group && e[1].dims[1] === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 ? t.compute(p8(x, r, a, n), {
          inputs: x
        }) : t.compute(d8(x, r, a, n), {
          inputs: x
        });
        return;
      }
      let o = e.length === 3, s = e[0].dims[i ? 1 : 2], l = e[0].dims[i ? 2 : 3], u = e[0].dims[i ? 3 : 1], c = e[1].dims[2], h = e[1].dims[3], f = a[i ? 1 : 2], d = a[i ? 2 : 3], p = a[i ? 3 : 1], v = i && c === s && h === l && r.pads[0] === 0 && r.pads[1] === 0;
      if (v || c === 1 && h === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 && r.strides[0] === 1 && r.strides[1] === 1 && r.pads[0] === 0 && r.pads[1] === 0) {
        let x = a[0], T, A, I, M = [];
        if (i) {
          let L = t.kernelCustomData.wT ?? t.compute(qn(e[1], wv), {
            inputs: [
              1
            ],
            outputs: [
              r.wIsConst ? -2 : -1
            ]
          })[0];
          if (r.wIsConst && !t.kernelCustomData.wT && (t.kernelCustomData.wT = L), v) {
            let z = s * l * u;
            T = e[0].reshape([
              1,
              x,
              z
            ]), A = L.reshape([
              1,
              z,
              p
            ]), I = [
              1,
              x,
              p
            ];
          } else T = e[0].reshape([
            x,
            s * l,
            u
          ]), A = L.reshape([
            1,
            u,
            p
          ]), I = [
            x,
            f * d,
            p
          ];
          M.push(T), M.push(A);
        } else T = e[0].reshape([
          x,
          u,
          s * l
        ]), A = e[1].reshape([
          1,
          p,
          u
        ]), I = [
          x,
          p,
          f * d
        ], M.push(A), M.push(T);
        o && M.push(e[2]);
        let k = I[2], B = M[0].dims[M[0].dims.length - 1];
        k < 8 && B < 8 ? t.compute(mC(M, r, a, I, i, n), {
          inputs: M
        }) : t.compute(xm(M, r, a, I, i, n), {
          inputs: M
        });
        return;
      }
      let g = true, m = t.kernelCustomData.wT ?? t.compute(qn(e[1], wv), {
        inputs: [
          1
        ],
        outputs: [
          r.wIsConst ? -2 : -1
        ]
      })[0];
      r.wIsConst && !t.kernelCustomData.wT && (t.kernelCustomData.wT = m);
      let y = [
        e[0],
        m
      ];
      o && y.push(e[2]);
      let _ = i ? f * d : p, b = i ? p : f * d, w = c * h * u;
      t.compute(c8(y, r, a, _, b, w, o, g, n), {
        inputs: y
      });
    }, j3 = (t, e) => {
      let r = e.format === "NHWC", n = [
        t.inputs[0].reshape(r ? [
          t.inputs[0].dims[0],
          1,
          t.inputs[0].dims[1],
          t.inputs[0].dims[2]
        ] : [
          t.inputs[0].dims[0],
          t.inputs[0].dims[1],
          1,
          t.inputs[0].dims[2]
        ]),
        t.inputs[1].reshape([
          t.inputs[1].dims[0],
          t.inputs[1].dims[1],
          1,
          t.inputs[1].dims[2]
        ])
      ];
      t.inputs.length === 3 && n.push(t.inputs[2]);
      let i = [
        0,
        e.pads[0],
        0,
        e.pads[1]
      ], a = [
        1
      ].concat(e.strides), o = [
        1
      ].concat(e.dilations), s = [
        1
      ].concat(e.kernelShape), l = Sv({
        ...e,
        pads: i,
        strides: a,
        dilations: o,
        kernelShape: s
      }, n);
      Nb(t, n, l, (u) => r ? [
        u[0],
        u[2],
        u[3]
      ] : [
        u[0],
        u[1],
        u[3]
      ]);
    }, K3 = (t, e, r) => {
      let n = r.format === "NHWC" ? "channelsLast" : "channelsFirst", i = Sv(r, e), a = r.autoPad === "NOTSET" ? r.pads : r.autoPad, o = h8(e[0].dims, e[1].dims, r.strides, r.dilations, a, false, n);
      t.compute(f8(e, i, o.outShape, [
        o.filterDepth,
        o.filterHeight,
        o.filterWidth
      ], [
        o.padInfo.front,
        o.padInfo.top,
        o.padInfo.left
      ], n));
    }, Jw = (t, e) => {
      if (X3(t.inputs, e), t.inputs[0].dims.length === 3) j3(t, e);
      else if (t.inputs[0].dims.length === 5) K3(t, t.inputs, e);
      else {
        let r = Sv(e, t.inputs);
        Nb(t, t.inputs, r);
      }
    };
  }), v8, Wye = ge(() => {
    Je(), To(), ft(), mt(), v8 = (t, e, r) => {
      let n = t.length > 2, i = e.outputShape, a = e.format === "NHWC", o = e.group, s = t[1].dims, l = s[2] / o, u = s[3], c = a ? or(l) : 1, h = a ? or(u) : 1, f = a ? u === 1 ? c : h : 1, d = re.size(i) / h, p = [
        Math.ceil(d / 64),
        1,
        1
      ];
      Mt("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${p}`);
      let v = [
        "rank",
        "rank"
      ], g = [
        e.strides[0],
        e.strides[1]
      ], m = [
        e.kernelShape[a ? 1 : 2],
        e.kernelShape[a ? 2 : 3]
      ], y = [
        e.dilations[0],
        e.dilations[1]
      ], _ = [
        m[0] + (e.dilations[0] <= 1 ? 0 : (e.kernelShape[a ? 1 : 2] - 1) * (e.dilations[0] - 1)),
        m[1] + (e.dilations[1] <= 1 ? 0 : (e.kernelShape[a ? 2 : 3] - 1) * (e.dilations[1] - 1))
      ], b = [
        _[0] - 1 - Math.floor((e.pads[0] + e.pads[2]) / 2),
        _[1] - 1 - Math.floor((e.pads[1] + e.pads[3]) / 2)
      ], w = [
        {
          type: 12,
          data: d
        },
        {
          type: 12,
          data: g
        },
        {
          type: 12,
          data: m
        },
        {
          type: 12,
          data: y
        },
        {
          type: 12,
          data: _
        },
        {
          type: 6,
          data: b
        },
        {
          type: 12,
          data: l
        },
        {
          type: 12,
          data: u
        },
        ...Ve(t[0].dims, t[1].dims)
      ];
      n && (w.push(...Ve(t[2].dims)), v.push("rank")), w.push(...Ve(i));
      let x = (T) => {
        let A = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "strides",
            type: "u32",
            length: g.length
          },
          {
            name: "filter_dims",
            type: "u32",
            length: m.length
          },
          {
            name: "dilations",
            type: "u32",
            length: m.length
          },
          {
            name: "effective_filter_dims",
            type: "u32",
            length: _.length
          },
          {
            name: "pads",
            type: "i32",
            length: b.length
          },
          {
            name: "input_channels_per_group",
            type: "u32"
          },
          {
            name: "output_channels_per_group",
            type: "u32"
          }
        ], I = kr(t[0].dataType), M = a ? 1 : 2, k = a ? 2 : 3, B = a ? 3 : 1, L = se("W", t[1].dataType, t[1].dims.length, f), z = se("Dy", t[0].dataType, t[0].dims.length, c), F = [
          z,
          L
        ];
        n && F.push(se("bias", t[2].dataType, [
          i[B]
        ].length, h));
        let E = Re("result", t[0].dataType, i.length, h), O = () => {
          let V = "";
          if (c === 1) V += `
        let w_offset = ${L.indicesToOffset(`${L.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
        let wValue = ${L.getByOffset(`w_offset / ${f}`)};
        dotProd = dotProd + xValue * wValue;`;
          else if (u === 1) V += `
          let wValue = ${L.getByOffset(`${L.indicesToOffset(`${L.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${f}`)};
          dotProd = dotProd + dot(xValue, wValue);`;
          else for (let H = 0; H < c; H++) V += `
            let wValue${H} = ${L.getByOffset(`${L.indicesToOffset(`${L.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${H}, wOutChannel)`)} / ${f}`)};
            dotProd = dotProd + xValue[${H}] * wValue${H};`;
          return V;
        }, N = `
            let outputIndices = ${E.offsetToIndices(`global_idx * ${h}`)};
            let batch = ${E.indicesGet("outputIndices", 0)};
            let d1 = ${E.indicesGet("outputIndices", B)};
            let r = ${E.indicesGet("outputIndices", M)};
            let c = ${E.indicesGet("outputIndices", k)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${E.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${I}(dyRCorner) + ${I}(wR)) / ${I}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${I}(uniforms.Dy_shape[${M}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }

              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${I}(dyCCorner) + ${I}(wC)) / ${I}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${I}(uniforms.Dy_shape[${k}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${c}) {
                  let xValue = ${a ? z.getByOffset(`${z.indicesToOffset(`${z.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c}`) : z.get("batch", "inputChannel", "idyR", "idyC")};
                  ${O()}
                  inputChannel = inputChannel + ${c};
                }
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${n ? ` + bias[d1 / ${h}]` : ""};
            ${E.setByOffset("global_idx", "value")};
          `;
        return `
    ${T.registerUniforms(A).declareVariables(...F, E)}
      ${T.mainStart()}
      ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${N}}`;
      };
      return {
        name: "ConvTranspose2D",
        shaderCache: {
          hint: `${e.cacheKey};${c}${f}${h}${u === 1}`,
          inputDependencies: v
        },
        getRunData: () => ({
          dispatchGroup: {
            x: p[0],
            y: p[1],
            z: p[2]
          },
          outputs: [
            {
              dims: r ? r(i) : i,
              dataType: t[0].dataType
            }
          ],
          programUniforms: w
        }),
        getShaderSource: x
      };
    };
  }), Z3, Q3, J3, Bb, g8, eO, zb, tO, m8, Hye = ge(() => {
    Wye(), fu(), ws(), Z3 = (t, e, r, n, i, a) => (t - 1) * e + r + (n - 1) * i + 1 - a, Q3 = (t, e, r, n, i) => {
      let a = Math.floor(t / 2);
      e === "SAME_UPPER" ? (r[n] = a, r[i] = t - a) : e === "SAME_LOWER" && (r[n] = t - a, r[i] = a);
    }, J3 = (t, e, r, n, i, a, o, s, l, u) => {
      let c = t.length - 2, h = u.length === 0;
      l.length < c && l.push(...Array(c - l.length).fill(0));
      let f = t[0], d = e[s ? 3 : 1] * i;
      for (let p = 0, v = t.length - c - (s ? 1 : 0); p < c; ++p, ++v) {
        let g = t[v], m = h ? g * o[p] : u[p], y = Z3(g, o[p], a[p], e[v], r[p], m);
        Q3(y, n, a, p, p + c), h && u.push(o[p] * (g - 1) + l[p] + (e[v] - 1) * r[p] + 1 - a[p] - a[p + c]);
      }
      u.splice(0, 0, f), u.splice(s ? 3 : 1, 0, d);
    }, Bb = (t, e) => {
      let r = t.kernelShape.slice();
      if (t.kernelShape.length === 0 || t.kernelShape.reduce((h, f) => h * f, 1) === 0) {
        r.length = 0;
        for (let h = 2; h < e[1].dims.length; ++h) r.push(e[1].dims[h]);
      }
      let n = t.format === "NHWC";
      r.splice(0, 0, e[1].dims[0]), r.splice(n ? 3 : 1, 0, e[1].dims[1]);
      let i = t.pads.slice(), a = t.outputShape.slice(), o = t.outputPadding.slice(), s = e[0].dims, l = t.dilations.slice();
      if (l.reduce((h, f) => h + f, 0) === 0) {
        let h = e[0].dims.length - 2;
        l = new Array(h).fill(1);
      }
      let u = t.strides.slice();
      if (u.reduce((h, f) => h + f, 0) === 0) {
        let h = e[0].dims.length - 2;
        u = new Array(h).fill(1);
      }
      J3(s, r, l, t.autoPad, t.group, i, u, n, o, a);
      let c = Object.assign({}, t);
      return Object.assign(c, {
        kernelShape: r,
        pads: i,
        outputPadding: o,
        outputShape: a,
        dilations: l,
        strides: u
      }), c;
    }, g8 = (t) => {
      let e = vC(t), r = t.format, n = [
        "NOTSET",
        "VALID",
        "SAME_UPPER",
        "SAME_LOWER"
      ][typeof t.autoPad > "u" ? 0 : t.autoPad], i = t.dilations, a = t.group, o = t.kernelShape, s = t.pads, l = t.strides, u = t.wIsConst(), c = t.outputPadding, h = t.outputShape;
      return {
        autoPad: n,
        format: r,
        dilations: i,
        group: a,
        kernelShape: o,
        outputPadding: c,
        outputShape: h,
        pads: s,
        strides: l,
        wIsConst: u,
        ...e,
        cacheKey: `${t.format};${e.activation};`
      };
    }, eO = (t, e) => {
      if (!t || t.length !== 2 && t.length !== 3) throw new Error("Conv requires 2 or 3 inputs");
      if (t[0].dims.length !== 4 && t[0].dims.length !== 3) throw new Error("currently only support 2-dimensional conv");
      if (t[0].dims.length !== t[1].dims.length) throw new Error("filter does not have same dimension as input");
      let r = t[0].dims[e.format === "NHWC" ? t[0].dims.length - 1 : 1], n = t[1].dims[0];
      if (r !== n) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      let i = t[1].dims[1] * e.group;
      if (t.length === 3 && (t[2].dims.length !== 1 || t[2].dims[0] !== i)) throw new Error("invalid bias");
      let a = t[0].dims.length - 2;
      if (e.dilations.reduce((o, s) => o + s, 0) > 0 && e.dilations.length !== a) throw new Error(`dilations should be ${a}D`);
      if (e.strides.reduce((o, s) => o + s, 0) > 0 && e.strides.length !== a) throw new Error(`strides should be ${a}D`);
      if (e.pads.reduce((o, s) => o + s, 0) > 0 && e.pads.length !== a * 2) throw new Error(`pads should be ${a * 2}D`);
      if (e.outputPadding.length !== a && e.outputPadding.length !== 0) throw new Error(`output_padding should be ${a}D`);
      if (e.kernelShape.reduce((o, s) => o + s, 0) > 0 && e.kernelShape.length !== 0 && e.kernelShape.length !== t[1].dims.length - 2) throw new Error("invalid kernel shape");
      if (e.outputShape.length !== 0 && e.outputShape.length !== t[0].dims.length - 2) throw new Error("invalid output shape");
    }, zb = (t, e, r, n) => {
      let i = t.kernelCustomData.wT ?? t.compute(qn(e[1], [
        2,
        3,
        0,
        1
      ]), {
        inputs: [
          1
        ],
        outputs: [
          r.wIsConst ? -2 : -1
        ]
      })[0];
      r.wIsConst && !t.kernelCustomData.wT && (t.kernelCustomData.wT = i);
      let a = [
        e[0],
        i
      ];
      e.length === 3 && a.push(e[2]), t.compute(v8(a, r, n), {
        inputs: a
      });
    }, tO = (t, e) => {
      let r = e.format === "NHWC", n = [
        t.inputs[0].reshape(r ? [
          t.inputs[0].dims[0],
          1,
          t.inputs[0].dims[1],
          t.inputs[0].dims[2]
        ] : [
          t.inputs[0].dims[0],
          t.inputs[0].dims[1],
          1,
          t.inputs[0].dims[2]
        ]),
        t.inputs[1].reshape([
          t.inputs[1].dims[0],
          t.inputs[1].dims[1],
          1,
          t.inputs[1].dims[2]
        ])
      ];
      t.inputs.length === 3 && n.push(t.inputs[2]);
      let i = e.kernelShape;
      (i.length === 0 || i[0] === 0) && (i = [
        t.inputs[1].dims[2]
      ]);
      let a = e.dilations;
      (a.length === 0 || a[0] === 0) && (a = [
        1
      ]);
      let o = e.strides;
      (o.length === 0 || o[0] === 0) && (o = [
        1
      ]);
      let s = e.pads;
      s.length === 0 && (s = [
        0,
        0
      ]), s = [
        0,
        s[0],
        0,
        s[1]
      ], o = [
        1
      ].concat(o), a = [
        1
      ].concat(a), i = [
        1
      ].concat(i);
      let l = e.outputPadding;
      l = [
        0
      ].concat(l);
      let u = Bb({
        ...e,
        pads: s,
        strides: o,
        dilations: a,
        kernelShape: i,
        outputPadding: l
      }, n);
      zb(t, n, u, (c) => r ? [
        c[0],
        c[2],
        c[3]
      ] : [
        c[0],
        c[1],
        c[3]
      ]);
    }, m8 = (t, e) => {
      if (eO(t.inputs, e), t.inputs[0].dims.length === 3) tO(t, e);
      else {
        let r = Bb(e, t.inputs);
        zb(t, t.inputs, r);
      }
    };
  }), rO, y8, _8, Uye = ge(() => {
    Je(), ft(), ur(), mt(), rO = (t, e, r, n) => {
      let i = re.size(e), a = e.length, o = se("input", t, a), s = Re("output", t, a), l = r.dataType === 6 ? r.getInt32Array()[0] : Number(r.getBigInt64Array()[0]), u = re.normalizeAxis(l, a), c = (h) => {
        let f = ` i32(${o.indicesGet("inputIndices", "uniforms.axis")}) `, d = Ne("uniforms.input_shape", "uniforms.axis", a), p = n.reverse ? f + (n.exclusive ? " + 1" : "") : "0", v = n.reverse ? d : f + (n.exclusive ? "" : " + 1");
        return `
                ${h.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(o, s)}
                ${h.mainStart()}
                  ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${s.offsetToIndices("global_idx")};
                  var sum = ${s.type.value}(0);
                  let first : i32 = ${p};
                  let last : i32 = ${v};
                  for (var i : i32 = first; i < last; i++) {
                    ${o.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${o.getByIndices("inputIndices")};
                  }
                  ${s.setByOffset("global_idx", "sum")};
                }`;
      };
      return {
        name: "CumSum",
        shaderCache: {
          hint: n.cacheKey,
          inputDependencies: [
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: e,
              dataType: t
            }
          ],
          dispatchGroup: {
            x: Math.ceil(i / 64)
          },
          programUniforms: [
            {
              type: 12,
              data: i
            },
            {
              type: 12,
              data: u
            },
            ...Ve(e, e)
          ]
        }),
        getShaderSource: c
      };
    }, y8 = (t, e) => {
      let r = t.inputs[0].dims, n = t.inputs[0].dataType, i = t.inputs[1];
      t.compute(rO(n, r, i, e), {
        inputs: [
          0
        ]
      });
    }, _8 = (t) => {
      let e = t.exclusive === 1, r = t.reverse === 1;
      return Bt({
        exclusive: e,
        reverse: r
      });
    };
  }), nO, iO, aO, b8, x8, Yye = ge(() => {
    Je(), ft(), ur(), mt(), nO = (t) => {
      if (!t || t.length !== 1) throw new Error("DepthToSpace requires 1 input.");
      if (t[0].dims.length !== 4) throw new Error("DepthToSpace requires 4D input.");
    }, iO = (t, e, r, n) => {
      let i = [];
      i.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);
      for (let a = 0; a < e; ++a) i.push(r.indicesSet("a", t[a], `i[${a}]`));
      return i.push("return a;}"), i.join(`
`);
    }, aO = (t, e) => {
      let r, n, i, a, o, s, l = e.format === "NHWC", u = e.blocksize, c = e.mode === "DCR";
      l ? ([r, n, i, a] = t.dims, o = c ? [
        r,
        n,
        i,
        u,
        u,
        a / u ** 2
      ] : [
        r,
        n,
        i,
        a / u ** 2,
        u,
        u
      ], s = c ? [
        0,
        1,
        3,
        2,
        4,
        5
      ] : [
        0,
        1,
        4,
        2,
        5,
        3
      ]) : ([r, n, i, a] = [
        t.dims[0],
        t.dims[2],
        t.dims[3],
        t.dims[1]
      ], o = c ? [
        r,
        u,
        u,
        a / u ** 2,
        n,
        i
      ] : [
        r,
        a / u ** 2,
        u,
        u,
        n,
        i
      ], s = c ? [
        0,
        3,
        4,
        1,
        5,
        2
      ] : [
        0,
        1,
        4,
        2,
        5,
        3
      ]);
      let h = t.reshape(o), f = h.dims.length, d = t.dataType, p = se("a", d, f), v = Re("output", d, f), g = (m) => `
  ${m.registerUniform("output_size", "u32").declareVariables(p, v)}

  ${iO(s, f, p, v)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${v.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${v.setByOffset("global_idx", p.getByIndices("aIndices"))}
  }`;
      return {
        name: "DepthToSpace",
        shaderCache: {
          hint: `${t.dims};${e.blocksize};${e.mode}`,
          inputDependencies: [
            "rank"
          ]
        },
        getRunData: (m) => {
          let y = l ? [
            r,
            n * u,
            i * u,
            a / u ** 2
          ] : [
            r,
            a / u ** 2,
            n * u,
            i * u
          ], _ = re.size(y), b = h.dims, w = re.sortBasedOnPerm(b, s);
          return {
            outputs: [
              {
                dims: y,
                dataType: m[0].dataType
              }
            ],
            dispatchGroup: {
              x: Math.ceil(_ / 64)
            },
            programUniforms: [
              {
                type: 12,
                data: _
              },
              ...Ve(b, w)
            ]
          };
        },
        getShaderSource: g
      };
    }, b8 = (t, e) => {
      nO(t.inputs), t.compute(aO(t.inputs[0], e));
    }, x8 = (t) => Bt({
      blocksize: t.blocksize,
      mode: t.mode,
      format: t.format
    });
  }), Tv, Bh, Fb, oO, sO, lO, uO, Vb, cO, w8, S8, qye = ge(() => {
    Je(), ft(), ur(), mt(), Tv = "[a-zA-Z]|\\.\\.\\.", Bh = "(" + Tv + ")+", Fb = "^" + Bh + "$", oO = "(" + Bh + ",)*" + Bh, sO = "^" + oO + "$", lO = class {
      constructor(t = -1) {
        this.symbolToIndices = /* @__PURE__ */ new Map(), this.inputIndex = t;
      }
      addSymbol(t, e) {
        let r = this.symbolToIndices.get(t);
        r === void 0 ? r = [
          e
        ] : r.push(e), this.symbolToIndices.set(t, r);
      }
    }, uO = class {
      constructor(t, e) {
        var _a2;
        this.equation = e, this.hasEllipsis = false, this.symbolToInfo = /* @__PURE__ */ new Map(), this.lhs = new Array(), this.outputDims = [];
        let [r, n] = e.includes("->") ? e.split("->", 2) : [
          e,
          ""
        ];
        if (!r.match(RegExp(sO))) throw new Error("Invalid LHS term");
        if (r.split(",").forEach((i, a) => {
          let o = t[a].dims.slice();
          if (!i.match(RegExp(Fb))) throw new Error("Invalid LHS term");
          let s = this.processTerm(i, true, o, a);
          this.lhs.push(s);
        }), n === "") n += [
          ...this.symbolToInfo.entries()
        ].filter(([i, a]) => a.count === 1 || i === "...").map(([i]) => i).join("");
        else if (!n.match(RegExp(Bh))) throw new Error("Invalid RHS");
        (_a2 = n.match(RegExp(Tv, "g"))) == null ? void 0 : _a2.forEach((i) => {
          if (i === "...") this.outputDims = this.outputDims.concat(this.ellipsisDims);
          else {
            let a = this.symbolToInfo.get(i);
            if (a === void 0) throw new Error("Invalid RHS symbol");
            this.outputDims.push(a.dimValue);
          }
        }), this.rhs = this.processTerm(n, false, this.outputDims);
      }
      addSymbol(t, e, r) {
        let n = this.symbolToInfo.get(t);
        if (n !== void 0) {
          if (n.dimValue !== e && n.count !== 1) throw new Error("Dimension mismatch");
          n.count++, n.inputIndices.push(r);
        } else n = {
          count: 1,
          dimValue: e,
          inputIndices: [
            r
          ]
        };
        this.symbolToInfo.set(t, n);
      }
      processTerm(t, e, r, n = -1) {
        let i = r.length, a = false, o = [], s = 0;
        if (!t.match(RegExp(Fb)) && !e && t !== "") throw new Error("Invalid LHS term");
        let l = t.match(RegExp(Tv, "g")), u = new lO(n);
        return l == null ? void 0 : l.forEach((c, h) => {
          if (c === "...") {
            if (a) throw new Error("Only one ellipsis is allowed per input term");
            a = true;
            let f = i - l.length + 1;
            if (f < 0) throw new Error("Ellipsis out of bounds");
            if (o = r.slice(s, s + f), this.hasEllipsis) {
              if (this.ellipsisDims.length !== o.length || this.ellipsisDims.toString() !== o.toString()) throw new Error("Ellipsis dimensions mismatch");
            } else if (e) this.hasEllipsis = true, this.ellipsisDims = o;
            else throw new Error("Ellipsis must be specified in the LHS");
            for (let d = 0; d < o.length; d++) {
              let p = String.fromCharCode(48 + d);
              u.addSymbol(p, h + d), this.addSymbol(p, r[s++], n);
            }
          } else u.addSymbol(c, h + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0)), this.addSymbol(c, r[s++], n);
        }), u;
      }
    }, Vb = (t) => t + "_max", cO = (t, e, r, n) => {
      let i = t.map((u) => u.length).map((u, c) => se(`input${c}`, e, u)), a = re.size(n), o = Re("output", e, n.length), s = [
        ...r.symbolToInfo.keys()
      ].filter((u) => !r.rhs.symbolToIndices.has(u)), l = (u) => {
        let c = [], h = "var prod = 1.0;", f = "var sum = 0.0;", d = "sum += prod;", p = [], v = [], g = [], m = [], y = r.symbolToInfo.size === r.rhs.symbolToIndices.size;
        r.symbolToInfo.forEach((b, w) => {
          var _a2;
          if (r.rhs.symbolToIndices.has(w)) {
            let x = (_a2 = r.rhs.symbolToIndices.get(w)) == null ? void 0 : _a2[0];
            x !== void 0 && r.lhs.forEach((T, A) => {
              if (b.inputIndices.includes(A)) {
                let I = T.symbolToIndices.get(w);
                if (I === void 0) throw new Error("Invalid symbol error");
                I.forEach((M) => {
                  c.push(`${i[A].indicesSet(`input${A}Indices`, M, o.indicesGet("outputIndices", x))}`);
                });
              }
            });
          } else r.lhs.forEach((x, T) => {
            if (b.inputIndices.includes(T)) {
              let A = x.symbolToIndices.get(w);
              if (A === void 0) throw new Error("Invalid symbol error");
              A.forEach((I) => {
                p.push(`${i[T].indicesSet(`input${T}Indices`, I, `${w}`)}`);
              }), m.push(`prod *= ${i[T].getByIndices(`input${T}Indices`)};`);
            }
          }), v.push(`for(var ${w}: u32 = 0; ${w} < uniforms.${Vb(w)}; ${w}++) {`), g.push("}");
        });
        let _ = y ? [
          ...c,
          `let sum = ${i.map((b, w) => b.getByIndices(`input${w}Indices`)).join(" * ")};`
        ] : [
          ...c,
          f,
          ...v,
          ...p,
          h,
          ...m,
          d,
          ...g
        ];
        return `
            ${u.registerUniforms(s.map((b) => ({
          name: `${Vb(b)}`,
          type: "u32"
        }))).registerUniform("outputSize", "u32").declareVariables(...i, o)}

            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${o.offsetToIndices("global_idx")};
            ${i.map((b, w) => `var input${w}Indices: ${i[w].type.indices};`).join(`
`)}
            ${_.join(`
`)};
            ${o.setByOffset("global_idx", "sum")};
          }`;
      };
      return {
        name: "Einsum",
        shaderCache: {
          hint: r.equation,
          inputDependencies: t.map(() => "rank")
        },
        getRunData: () => {
          let u = s.filter((h) => r.symbolToInfo.has(h)).map((h) => {
            var _a2;
            return {
              type: 12,
              data: ((_a2 = r.symbolToInfo.get(h)) == null ? void 0 : _a2.dimValue) || 0
            };
          });
          u.push({
            type: 12,
            data: a
          });
          let c = t.map((h, f) => [
            ...Ve(h)
          ]).reduce((h, f) => h.concat(f), u);
          return c.push(...Ve(n)), {
            outputs: [
              {
                dims: n,
                dataType: e
              }
            ],
            dispatchGroup: {
              x: Math.ceil(a / 64)
            },
            programUniforms: c
          };
        },
        getShaderSource: l
      };
    }, w8 = (t, e) => {
      let r = new uO(t.inputs, e.equation), n = r.outputDims, i = t.inputs.map((a, o) => a.dims);
      t.compute(cO(i, t.inputs[0].dataType, r, n));
    }, S8 = (t) => {
      let e = t.equation.replace(/\s+/g, "");
      return Bt({
        equation: e
      });
    };
  }), hO, Gb, fO, dO, T8, Xye = ge(() => {
    Je(), ft(), mt(), hO = (t) => {
      if (!t || t.length !== 2) throw new Error("Expand requires 2 input.");
      let e = t[0].dims, r = Array.from(t[1].getBigInt64Array(), Number), n = r.length < e.length ? 0 : r.length - e.length, i = e.length < r.length ? 0 : e.length - r.length;
      for (; n < r.length && i < e.length; ++n, ++i) if (r[n] !== e[i] && r[n] !== 1 && e[i] !== 1) throw new Error("Expand requires shape to be broadcastable to input");
    }, Gb = (t, e) => {
      let r = t.length - e.length, n = [];
      for (let i = 0; i < r; ++i) n.push(t[i]);
      for (let i = 0; i < e.length; ++i) n.push(e[i] === 1 ? t[i + r] : e[i]);
      return n;
    }, fO = (t, e) => t.length > e.length ? Gb(t, e) : Gb(e, t), dO = (t) => {
      let e = t[0].dims, r = Array.from(t[1].getBigInt64Array(), Number), n = fO(e, r), i = t[0].dataType, a = i === 9 || re.size(e) === 1, o = i === 9 || e.length > 0 && e[e.length - 1] % 4 === 0 ? 4 : 1, s = a || n.length > 0 && n[n.length - 1] % 4 === 0 ? 4 : 1, l = Math.ceil(re.size(n) / s), u = (h) => {
        let f = se("input", i, e.length, o), d = Re("output", i, n.length, s), p;
        if (i === 9) {
          let v = (g, m, y = "") => `
          let outputIndices${m} = ${d.offsetToIndices(`outputOffset + ${m}u`)};
          let offset${m} = ${f.broadcastedIndicesToOffset(`outputIndices${m}`, d)};
          let index${m} = offset${m} / 4u;
          let component${m} = offset${m} % 4u;
          ${g}[${m}] = ${y}(${f.getByOffset(`index${m}`)}[component${m}]);
        `;
          p = `
        let outputOffset = global_idx * ${s};
        var data = vec4<u32>(0);
        ${v("data", 0, "u32")}
        ${v("data", 1, "u32")}
        ${v("data", 2, "u32")}
        ${v("data", 3, "u32")}
        ${d.setByOffset("global_idx", "data")}
      }`;
        } else p = `
        let outputIndices = ${d.offsetToIndices(`global_idx * ${s}`)};
        let inputOffset = ${f.broadcastedIndicesToOffset("outputIndices", d)};
        let data = ${d.type.value}(${f.getByOffset(`inputOffset / ${o}`)});
        ${d.setByOffset("global_idx", "data")}
      }`;
        return `
    ${h.registerUniform("vec_size", "u32").declareVariables(f, d)}
    ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${p}`;
      }, c = [
        {
          type: 12,
          data: l
        },
        ...Ve(e, n)
      ];
      return {
        name: "Expand",
        shaderCache: {
          hint: `${n.length};${o}${s}`,
          inputDependencies: [
            "rank"
          ]
        },
        getShaderSource: u,
        getRunData: () => ({
          outputs: [
            {
              dims: n,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(l / 64)
          },
          programUniforms: c
        })
      };
    }, T8 = (t) => {
      hO(t.inputs), t.compute(dO(t.inputs), {
        inputs: [
          0
        ]
      });
    };
  }), pO, C8, jye = ge(() => {
    Je(), ft(), mt(), pC(), pO = (t) => {
      let e = t[0].dataType, r = re.size(t[0].dims), n = re.size(t[1].dims), i = n % 4 === 0, a = (o) => {
        let s = se("x", e, [
          1
        ], 4), l = se("bias", e, [
          1
        ], 4), u = Re("y", e, [
          1
        ], 4), c = [
          {
            name: "output_vec_size",
            type: "u32"
          },
          {
            name: "bias_size",
            type: "u32"
          }
        ], h = (d) => `
      let bias${d}_offset: u32 = (global_idx * 4 + ${d}) % uniforms.bias_size;
      let bias${d} = ${l.getByOffset(`bias${d}_offset / 4`)}[bias${d}_offset % 4];`, f = i ? `
      let bias = ${l.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${h(0)}${h(1)}${h(2)}${h(3)}
      let bias = ${s.type.value}(bias0, bias1, bias2, bias3);`;
        return `${o.registerUniforms(c).declareVariables(s, l, u)}

    ${Xw(Jr(e))}

    ${o.mainStart(Mc)}
      ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${s.getByOffset("global_idx")};
      ${f}
      let x_in = x + bias;
      ${u.setByOffset("global_idx", jw("x_in"))}
    }`;
      };
      return {
        name: "FastGeluWithBias",
        shaderCache: {
          hint: `${i}`,
          inputDependencies: [
            "type",
            "type"
          ]
        },
        getShaderSource: a,
        getRunData: (o) => ({
          outputs: [
            {
              dims: o[0].dims,
              dataType: o[0].dataType
            }
          ],
          programUniforms: [
            {
              type: 12,
              data: Math.ceil(r / 4)
            },
            {
              type: 12,
              data: n
            }
          ],
          dispatchGroup: {
            x: Math.ceil(r / Mc / 4)
          }
        })
      };
    }, C8 = (t) => {
      t.inputs.length < 2 || re.size(t.inputs[1].dims) === 0 ? U6(t) : t.compute(pO(t.inputs));
    };
  }), vO, gO, A8, I8, Kye = ge(() => {
    Je(), ft(), ur(), mt(), vO = (t) => {
      if (!t || t.length !== 2) throw new Error("Gather requires 2 inputs.");
    }, gO = (t, e) => {
      let r = t[0].dims, n = t[1].dims, i = r.length, a = re.normalizeAxis(e.axis, i), o = r.slice(0);
      o.splice(a, 1, ...n);
      let s = r[a], l = t[0].dataType === 9 ? 4 : 1, u = Math.ceil(re.size(o) / l), c = [
        {
          type: 12,
          data: u
        },
        {
          type: 6,
          data: s
        },
        {
          type: 12,
          data: a
        },
        ...Ve(t[0].dims, t[1].dims, o)
      ], h = (f) => {
        let d = se("data", t[0].dataType, t[0].dims.length, l), p = se("inputIndices", t[1].dataType, t[1].dims.length), v = Re("output", t[0].dataType, o.length, l), g = (y) => {
          let _ = n.length, b = `var indicesIndices${y}  = ${p.type.indices}(0);`;
          for (let w = 0; w < _; w++) b += `${_ > 1 ? `indicesIndices${y}[${w}]` : `indicesIndices${y}`} = ${o.length > 1 ? `outputIndices${y}[uniforms.axis + ${w}]` : `outputIndices${y}`};`;
          b += `
          var idx${y} = ${p.getByIndices(`indicesIndices${y}`)};
          if (idx${y} < 0) {
            idx${y} = idx${y} + uniforms.axisDimLimit;
          }
          var dataIndices${y} : ${d.type.indices};
        `;
          for (let w = 0, x = 0; w < i; w++) w === a ? (b += `${i > 1 ? `dataIndices${y}[${w}]` : `dataIndices${y}`} = u32(idx${y});`, x += _) : (b += `${i > 1 ? `dataIndices${y}[${w}]` : `dataIndices${y}`} = ${o.length > 1 ? `outputIndices${y}[${x}]` : `outputIndices${y}`};`, x++);
          return b;
        }, m;
        if (t[0].dataType === 9) {
          let y = (_, b, w = "") => `
          let outputIndices${b} = ${v.offsetToIndices(`outputOffset + ${b}u`)};
          ${g(b)};
          let offset${b} = ${d.indicesToOffset(`dataIndices${b}`)};
          let index${b} = offset${b} / 4u;
          let component${b} = offset${b} % 4u;
          ${_}[${b}] = ${w}(${d.getByOffset(`index${b}`)}[component${b}]);
        `;
          m = `
        let outputOffset = global_idx * ${l};
        var value = vec4<u32>(0);
        ${y("value", 0, "u32")}
        ${y("value", 1, "u32")}
        ${y("value", 2, "u32")}
        ${y("value", 3, "u32")}
        ${v.setByOffset("global_idx", "value")}
      `;
        } else m = `
      let outputIndices = ${v.offsetToIndices("global_idx")};
      ${g("")};
      let value = ${d.getByIndices("dataIndices")};
      ${v.setByOffset("global_idx", "value")};
      `;
        return `
      ${f.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(d, p, v)}
      ${f.mainStart()}
        ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${m}
      }`;
      };
      return {
        name: "Gather",
        shaderCache: {
          hint: e.cacheKey,
          inputDependencies: [
            "rank",
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: o,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(u / 64)
          },
          programUniforms: c
        }),
        getShaderSource: h
      };
    }, A8 = (t) => Bt({
      axis: t.axis
    }), I8 = (t, e) => {
      let r = t.inputs;
      vO(r), t.compute(gO(t.inputs, e));
    };
  }), mO, M8, D8, Zye = ge(() => {
    Je(), ft(), mt(), mO = (t, e, r, n, i, a, o, s, l) => {
      let u = [
        {
          type: 12,
          data: a
        },
        {
          type: 12,
          data: n
        },
        {
          type: 12,
          data: i
        },
        {
          type: 12,
          data: r
        },
        {
          type: 12,
          data: o
        },
        {
          type: 12,
          data: s
        },
        {
          type: 12,
          data: l
        }
      ], c = [
        a
      ];
      u.push(...Ve(e.dims, c));
      let h = (f) => {
        let d = se("indices_data", e.dataType, e.dims.length), p = Re("input_slice_offsets_data", 12, 1, 1), v = [
          d,
          p
        ], g = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "batch_dims",
            type: "u32"
          },
          {
            name: "input_dims",
            type: "u32",
            length: i.length
          },
          {
            name: "sizes_from_slice_dims_data",
            type: "u32",
            length: r.length
          },
          {
            name: "num_slices_per_batch",
            type: "u32"
          },
          {
            name: "input_batch_stride",
            type: "u32"
          },
          {
            name: "num_slice_dims",
            type: "u32"
          }
        ];
        return `
  ${f.registerUniforms(g).declareVariables(...v)}
  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${i.length === 1 ? "index += i32(uniforms.input_dims);" : "index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${r.length === 1 ? "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);" : "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`;
      };
      return t.compute({
        name: "computeSliceOffsets",
        shaderCache: {
          hint: `${i.length}_${r.length}`,
          inputDependencies: [
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: c,
              dataType: t.inputs[1].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(a / 64)
          },
          programUniforms: u
        }),
        getShaderSource: h
      }, {
        inputs: [
          e
        ],
        outputs: [
          -1
        ]
      })[0];
    }, M8 = (t, e) => {
      let r = t.inputs, n = r[0].dims, i = r[0].dataType, a = r[1].dims, o = a[a.length - 1], s = re.sizeToDimension(a, a.length - 1), l = re.sizeFromDimension(n, e.batchDims + o), u = re.sizeToDimension(n, e.batchDims), c = re.sizeFromDimension(n, e.batchDims), h = s / u, f = new Array(o), d = l;
      for (let b = 0; b < o; ++b) f[o - 1 - b] = d, d *= n[e.batchDims + o - 1 - b];
      let p = mO(t, r[1], f, e.batchDims, n, s, h, c, o), v = e.batchDims + o;
      if (v > n.length) throw new Error("last dimension of indices must not be larger than rank of input tensor");
      let g = a.slice(0, -1).concat(n.slice(v)), m = re.size(g), y = [
        {
          type: 12,
          data: m
        },
        {
          type: 12,
          data: l
        },
        ...Ve(r[0].dims, p.dims, g)
      ], _ = (b) => {
        let w = se("data", r[0].dataType, r[0].dims.length), x = se("slice_offsets", 12, p.dims.length), T = Re("output", r[0].dataType, g.length);
        return `
          ${b.registerUniform("output_size", "u32").registerUniform("slice_size", "u32").declareVariables(w, x, T)}
            ${b.mainStart()}
            ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`;
      };
      t.compute({
        name: "GatherND",
        shaderCache: {
          hint: e.cacheKey,
          inputDependencies: [
            "rank",
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: g,
              dataType: i
            }
          ],
          dispatchGroup: {
            x: Math.ceil(m / 64)
          },
          programUniforms: y
        }),
        getShaderSource: _
      }, {
        inputs: [
          r[0],
          p
        ]
      });
    }, D8 = (t) => ({
      batchDims: t.batch_dims,
      cacheKey: ""
    });
  }), yO, _O, E8, k8, Qye = ge(() => {
    Je(), ft(), ur(), mt(), yO = (t, e) => {
      if (t.length < 3 || t.length > 4) throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
      let r = re.normalizeAxis(e.quantizeAxis, t[0].dims.length), n = e.blockSize, i = t[0], a = t[2], o = t.length === 4 ? t[3] : void 0;
      if (a.dims.length !== i.dims.length || !i.dims.map((s, l) => l === r ? Math.ceil(s / n) === a.dims[l] : s === a.dims[l]).reduce((s, l) => s && l, true)) throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");
      if (o) {
        if (o.dataType !== i.dataType) throw new Error("Zero point must have the same data type as the input tensor.");
        if (o.dims.length !== a.dims.length || !o.dims.map((s, l) => s === a.dims[l]).reduce((s, l) => s && l, true)) throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.");
      }
    }, _O = (t, e) => {
      let r = t[0].dims, n = t[1].dims, i = r.length, a = re.normalizeAxis(e.gatherAxis, i), o = re.normalizeAxis(e.quantizeAxis, i), s = r.slice(0);
      s.splice(a, 1, ...n);
      let l = re.size(s), u = t[2].dataType, c = t[0].dataType === 22, h = [
        {
          type: 12,
          data: l
        },
        {
          type: 12,
          data: o
        },
        {
          type: 12,
          data: a
        },
        {
          type: 12,
          data: e.blockSize
        },
        ...Ve(...t.map((d, p) => d.dims), s)
      ], f = (d) => {
        let p = se("data", t[0].dataType, t[0].dims.length), v = se("inputIndices", t[1].dataType, t[1].dims.length), g = se("scales", t[2].dataType, t[2].dims.length), m = t.length > 3 ? se("zeroPoint", t[3].dataType, t[3].dims.length) : void 0, y = Re("output", u, s.length), _ = [
          p,
          v,
          g
        ];
        m && _.push(m);
        let b = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "quantize_axis",
            type: "u32"
          },
          {
            name: "gather_axis",
            type: "u32"
          },
          {
            name: "block_size",
            type: "u32"
          }
        ];
        return `
        ${d.registerUniforms(b).declareVariables(..._, y)}
        ${d.mainStart()}
        let output_indices = ${y.offsetToIndices("global_idx")};
        var indices_indices = ${v.type.indices}(0);
        ${n.length > 1 ? `
          for (var i: u32 = 0; i < ${n.length}; i++) {
            let index = ${y.indicesGet("output_indices", "uniforms.gather_axis + i")};
            ${v.indicesSet("indices_indices", "i", "index")};
          }` : `indices_indices = ${y.indicesGet("output_indices", "uniforms.gather_axis")};`};
        var data_indices = ${p.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${y.indicesGet("output_indices", "i")};
          ${p.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${v.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${r[a]};
        }
        ${p.indicesSet("data_indices", "uniforms.gather_axis", "u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${s.length}; i++) {
          let index = ${y.indicesGet("output_indices", `i + ${n.length} - 1`)};
          ${p.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${p.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${p.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${c ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${g.indicesGet("data_indices", "uniforms.quantize_axis")} / uniforms.block_size;
        ${g.indicesSet("scale_indices", "uniforms.quantize_axis", "quantize_axis_index")};
        var scale = ${g.getByIndices("scale_indices")};
        ${m ? `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${m.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${m.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${c ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];` : "var zero_point = 0"};
        let dequantized_data = ${Jr(u)}(quantized_data - zero_point) * scale;
        ${y.setByOffset("global_idx", "dequantized_data")};
    }`;
      };
      return {
        name: "GatherBlockQuantized",
        shaderCache: {
          hint: `${e.cacheKey};${t.filter((d, p) => p !== 1).map((d) => d.dims.join("_")).join(";")}`,
          inputDependencies: Array.from({
            length: t.length
          }, (d, p) => "rank")
        },
        getRunData: () => ({
          outputs: [
            {
              dims: s,
              dataType: u
            }
          ],
          dispatchGroup: {
            x: Math.ceil(l / 64)
          },
          programUniforms: h
        }),
        getShaderSource: f
      };
    }, E8 = (t, e) => {
      let r = t.inputs;
      yO(r, e), t.compute(_O(t.inputs, e));
    }, k8 = (t) => Bt({
      blockSize: t.blockSize,
      gatherAxis: t.gatherAxis,
      quantizeAxis: t.quantizeAxis
    });
  }), bO, xO, P8, L8, Jye = ge(() => {
    Je(), ft(), ur(), mt(), bO = (t) => {
      if (!t || t.length !== 2) throw new Error("GatherElements requires 2 inputs.");
      if (t[0].dims.length < 1) throw new Error("GatherElements requires that the data input be rank >= 1.");
      if (t[0].dims.length !== t[1].dims.length) throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
    }, xO = (t, e) => {
      let r = t[0].dims, n = t[0].dataType, i = r.length, a = t[1].dims, o = t[1].dataType, s = re.normalizeAxis(e.axis, i), l = r[s], u = a.slice(0), c = re.size(u), h = se("input", n, i), f = se("indicesInput", o, a.length), d = Re("output", n, u.length), p = [
        {
          type: 12,
          data: c
        },
        {
          type: 6,
          data: l
        },
        {
          type: 12,
          data: s
        }
      ];
      return p.push(...Ve(r, a, u)), {
        name: "GatherElements",
        shaderCache: {
          inputDependencies: [
            "rank",
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: u,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(c / 64)
          },
          programUniforms: p
        }),
        getShaderSource: (v) => `
      ${v.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(h, f, d)}
      ${v.mainStart()}
      ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${d.offsetToIndices("global_idx")};

      var idx = ${f.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${h.type.indices}(outputIndices);
      ${h.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${h.getByIndices("inputIndices")};

      ${d.setByOffset("global_idx", "value")};
  }`
      };
    }, P8 = (t) => Bt({
      axis: t.axis
    }), L8 = (t, e) => {
      let r = t.inputs;
      bO(r), t.compute(xO(t.inputs, e));
    };
  }), wO, SO, $8, R8, e0e = ge(() => {
    Je(), ft(), mt(), wO = (t) => {
      if (!t) throw new Error("Input is missing");
      if (t.length < 2 || t.length > 3) throw new Error("Invaid input number.");
      if (t.length === 3 && t[2].dims.length > 2) throw new Error("Invalid input shape of C");
      if (t[0].dataType !== t[1].dataType || t.length === 3 && t[0].dataType !== t[2].dataType) throw new Error("Input types are mismatched");
    }, SO = (t, e) => {
      let r = t[0].dims.slice(), n = t[1].dims.slice(), [i, a, o] = OU.getShapeOfGemmResult(r, e.transA, n, e.transB, t.length === 3 ? t[2].dims : void 0), s = [
        i,
        a
      ];
      if (!s) throw new Error("Can't use gemm on the given tensors");
      let l = 16, u = Math.ceil(a / l), c = Math.ceil(i / l), h = true, f = re.size(s), d = [
        {
          type: 12,
          data: h ? u : f
        },
        {
          type: 12,
          data: i
        },
        {
          type: 12,
          data: a
        },
        {
          type: 12,
          data: o
        },
        {
          type: 1,
          data: e.alpha
        },
        {
          type: 1,
          data: e.beta
        }
      ], p = [
        "type",
        "type"
      ];
      t.length === 3 && (d.push(...Ve(t[2].dims)), p.push("rank")), d.push(...Ve(s));
      let v = (m) => {
        let y = "";
        e.transA && e.transB ? y = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];" : e.transA && !e.transB ? y = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];" : !e.transA && e.transB ? y = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];" : !e.transA && !e.transB && (y = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");
        let _ = e.alpha === 1 ? "" : "value *= uniforms.alpha;", b = se("a", t[0].dataType, t[0].dims), w = se("b", t[1].dataType, t[1].dims), x = b.type.value, T = null, A = [
          b,
          w
        ];
        t.length === 3 && (T = se("c", t[2].dataType, t[2].dims.length), A.push(T));
        let I = Re("output", t[0].dataType, s.length);
        A.push(I);
        let M = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "M",
            type: "u32"
          },
          {
            name: "N",
            type: "u32"
          },
          {
            name: "K",
            type: "u32"
          },
          {
            name: "alpha",
            type: "f32"
          },
          {
            name: "beta",
            type: "f32"
          }
        ];
        return `
  ${m.registerUniforms(M).declareVariables(...A)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${x}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${y}
    }

    ${_}
    ${T != null ? `let cOffset = ${T.broadcastedIndicesToOffset("vec2(m, n)", I)}; value += ${x}(uniforms.beta) * ${T.getByOffset("cOffset")};` : ""}
    output[global_idx] = value;
  }`;
      }, g = (m) => {
        let y = se("a", t[0].dataType, t[0].dims), _ = se("b", t[1].dataType, t[1].dims), b = null, w = [
          y,
          _
        ];
        t.length === 3 && (b = se("c", t[2].dataType, t[2].dims.length), w.push(b));
        let x = Re("output", t[0].dataType, s.length);
        w.push(x);
        let T = [
          {
            name: "num_tile_n",
            type: "u32"
          },
          {
            name: "M",
            type: "u32"
          },
          {
            name: "N",
            type: "u32"
          },
          {
            name: "K",
            type: "u32"
          },
          {
            name: "alpha",
            type: "f32"
          },
          {
            name: "beta",
            type: "f32"
          }
        ], A = "", I = "";
        e.transA && e.transB ? (I = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${y.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${_.type.value}(0);
      }
      `, A = "value += tile_a[k][local_id.y] * tile_b[local_id.x][k];") : e.transA && !e.transB ? (I = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${y.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${_.type.value}(0);
      }
      `, A = "value += tile_a[k][local_id.y] * tile_b[k][local_id.x];") : !e.transA && e.transB ? (I = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${y.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${_.type.value}(0);
      }
      `, A = "value += tile_a[local_id.y][k] * tile_b[local_id.x][k];") : !e.transA && !e.transB && (I = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${y.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${_.type.value}(0);
      }
      `, A = "value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");
        let M = e.alpha === 1 ? "" : "value *= uniforms.alpha;";
        return `
  ${m.registerUniforms(T).declareVariables(...w)}
  var<workgroup> tile_a: array<array<${y.type.storage}, ${l}>, ${l}>;
  var<workgroup> tile_b: array<array<${_.type.storage}, ${l}>, ${l}>;
  ${m.mainStart([
          l,
          l,
          1
        ])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};
    let num_tiles = (uniforms.K - 1) / ${l} + 1;
    var k_start = 0u;
    var value = ${x.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${I}
      k_start = k_start + ${l};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${l}; k++) {
        ${A}
      }
      workgroupBarrier();
    }

    ${M}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${b != null ? `let cOffset = ${b.broadcastedIndicesToOffset("vec2(m, n)", x)}; value += ${x.type.value}(uniforms.beta) * ${b.getByOffset("cOffset")};` : ""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`;
      };
      return h ? {
        name: "GemmShared",
        shaderCache: {
          hint: `${e.cacheKey}`,
          inputDependencies: p
        },
        getRunData: () => ({
          outputs: [
            {
              dims: s,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: u * c
          },
          programUniforms: d
        }),
        getShaderSource: g
      } : {
        name: "Gemm",
        shaderCache: {
          hint: `${e.cacheKey}`,
          inputDependencies: p
        },
        getRunData: () => ({
          outputs: [
            {
              dims: s,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(f / 64)
          },
          programUniforms: d
        }),
        getShaderSource: v
      };
    }, $8 = (t) => {
      let e = t.transA, r = t.transB, n = t.alpha, i = t.beta;
      return {
        transA: e,
        transB: r,
        alpha: n,
        beta: i,
        cacheKey: `${t.transA};${t.transB};${t.alpha === 1}`
      };
    }, R8 = (t, e) => {
      wO(t.inputs), t.compute(SO(t.inputs, e));
    };
  }), ha, Ya, Zs, Qs, TO, CO, AO, IO, MO, DO, EO, kO, O8, N8, t0e = ge(() => {
    Je(), ft(), ur(), mt(), [ha, Ya, Zs, Qs] = [
      0,
      1,
      2,
      3
    ], TO = (t) => {
      if (t[0].dims.length !== 4) throw new Error("only 4-D tensor is supported.");
      if (t[0].dims.length !== t[1].dims.length) throw new Error("input dimensions must be equal to grid dimensions");
      if (t[0].dims.length - 2 !== t[1].dims[t[1].dims.length - 1]) throw new Error(`last dimension of grid must be equal to ${t[0].dims.length - 2}`);
      if (t[0].dims[0] !== t[1].dims[0]) throw new Error("grid batch size must match input batch size");
    }, CO = `
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`, AO = (t) => `
  fn gs_bicubic_interpolate(p: mat4x4<${t}>, x: f32, y: f32) -> ${t} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${t}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`, IO = (t) => `
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${t.alignCorners === 0 ? `
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    ` : `
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`, MO = (t) => `
  ${t.paddingMode === "reflection" ? `
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }` : ""}
`, DO = (t, e, r) => `
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${e} {
     var pixel = ${e}(0);
     var indices = vec4<u32>(0);
     indices[${ha}] = batch;
     indices[${Ya}] = channel;` + (() => {
      switch (r.paddingMode) {
        case "zeros":
          return `
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${Zs}] = u32(r);
            indices[${Qs}] = u32(c);
          }
        `;
        case "border":
          return `
          indices[${Zs}] = u32(clamp(r, 0, H - 1));
          indices[${Qs}] = u32(clamp(c, 0, W - 1));
        `;
        case "reflection":
          return `
          indices[${Zs}] = gs_reflect(r, border[1], border[3]);
          indices[${Qs}] = gs_reflect(c, border[0], border[2]);
        `;
        default:
          throw new Error(`padding mode ${r.paddingMode} is not supported`);
      }
    })() + `
    return ${t.getByIndices("indices")};
  }
`, EO = (t, e, r) => (() => {
      switch (r.mode) {
        case "nearest":
          return `
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${ha}], indices[${Ya}], border);
        `;
        case "bilinear":
          return `
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${ha}], indices[${Ya}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${ha}], indices[${Ya}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${ha}], indices[${Ya}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${ha}], indices[${Ya}], border);

          let dx2 = ${e}(f32(x2) - x);
          let dx1 = ${e}(x - f32(x1));
          let dy2 = ${e}(f32(y2) - y);
          let dy1 = ${e}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;
        case "bicubic":
          return `
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${e}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${ha}], indices[${Ya}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;
        default:
          throw new Error(`mode ${r.mode} is not supported`);
      }
    })() + `${t.setByOffset("global_idx", "result")}`, kO = (t, e) => {
      let r = se("x", t[0].dataType, t[0].dims.length), n = [
        t[1].dims[0],
        t[1].dims[1],
        t[1].dims[2]
      ], i = se("grid", t[1].dataType, n.length, 2), a = [
        t[0].dims[0],
        t[0].dims[1],
        t[1].dims[1],
        t[1].dims[2]
      ];
      e.format === "NHWC" && (a = [
        t[0].dims[0],
        t[1].dims[1],
        t[1].dims[2],
        t[0].dims[3]
      ], [ha, Ya, Zs, Qs] = [
        0,
        3,
        1,
        2
      ]);
      let o = Re("output", t[0].dataType, a.length), s = r.type.value, l = re.size(a), u = [
        {
          type: 12,
          data: l
        },
        ...Ve(t[0].dims, n, a)
      ], c = (h) => `
  ${h.registerUniform("output_size", "u32").declareVariables(r, i, o)}
  ${CO}
  ${AO(s)}
  ${IO(e)}
  ${MO(e)}
  ${DO(r, s, e)}

  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${Zs}]);
      let W_in = i32(uniforms.x_shape[${Qs}]);

      ${e.alignCorners === 0 ? `
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      ` : `
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${o.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${ha}], indices[${Zs}], indices[${Qs}]);
      let nxy = ${i.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${EO(o, s, e)}
  }`;
      return {
        name: "GridSample",
        shaderCache: {
          hint: `${e.cacheKey}`,
          inputDependencies: [
            "type",
            "type"
          ]
        },
        getRunData: (h) => {
          let f = re.size(a);
          return {
            outputs: [
              {
                dims: a,
                dataType: h[0].dataType
              }
            ],
            dispatchGroup: {
              x: Math.ceil(f / 64)
            },
            programUniforms: u
          };
        },
        getShaderSource: c
      };
    }, O8 = (t, e) => {
      TO(t.inputs), t.compute(kO(t.inputs, e));
    }, N8 = (t) => Bt({
      alignCorners: t.align_corners,
      mode: t.mode,
      paddingMode: t.padding_mode,
      format: t.format
    });
  }), cn, PO, B8, Wb, LO, ff, z8, F8 = ge(() => {
    Je(), ft(), ur(), cC(), dC(), mt(), ws(), cn = (t, e) => t.length > e && t[e].dims.length > 0 ? t[e] : void 0, PO = (t, e) => {
      let r = t[0], n = cn(t, 1), i = cn(t, 2), a = cn(t, 3), o = cn(t, 4), s = cn(t, 5), l = cn(t, 6), u = cn(t, 7);
      if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error("Input query is expected to have 3 or 5 dimensions");
      let c = r.dims[0], h = r.dims[1], f = r.dims.length === 3 ? r.dims[2] : e.numHeads * r.dims[4], d = h, p = 0, v = 0, g = Math.floor(f / e.numHeads);
      if (l && u && re.size(l.dims) && re.size(u.dims)) {
        if (l.dims.length !== 4) throw new Error('Input "past_key" is expected to have 4 dimensions');
        if (l.dims[0] !== c || l.dims[1] !== e.numHeads || l.dims[3] !== g) throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
        if (u.dims[0] !== c || u.dims[1] !== e.numHeads || u.dims[3] !== g) throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
        if (l.dims[2] !== u.dims[2]) throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
        if (u.dims.length !== 4) throw new Error('Input "past_value" is expected to have 4 dimensions');
        p = l.dims[2], v = l.dims[2];
      } else if (l && re.size(l.dims) || u && re.size(u.dims)) throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      let m;
      if (n && re.size(n.dims) > 0) {
        if (r.dims.length !== 3) throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        if (n.dims.length < 3 || n.dims.length > 5) throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        if (r.dims[0] !== n.dims[0]) throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        if (n.dims.length === 3) {
          if (n.dims[2] !== r.dims[2]) throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
          m = 2, d = n.dims[1];
        } else if (n.dims.length === 5) {
          if (n.dims[2] !== e.numHeads || n.dims[3] !== 2 || n.dims[4] !== g) throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          if (i) throw new Error('Expect "value" be none when "key" has packed kv format.');
          m = 5, d = n.dims[1];
        } else {
          if (n.dims[1] !== e.numHeads || n.dims[3] !== g) throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          m = 0, d = n.dims[2];
        }
      } else {
        if (r.dims.length !== 5) throw new Error('Input "query" is expected to have 5 dimensions when key is empty');
        if (r.dims[2] !== e.numHeads || r.dims[3] !== 3) throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        m = 3;
      }
      if (a && re.size(a.dims) > 0) {
        if (a.dims.length !== 1) throw new Error('Input "bias" is expected to have 1 dimension');
        if (n && n.dims.length === 5 && n.dims[3] === 2) throw new Error("bias is not allowed for packed kv.");
      }
      let y = p + d, _ = 0;
      if (o && re.size(o.dims) > 0) {
        _ = 8;
        let T = o.dims;
        throw T.length === 1 ? T[0] === c ? _ = 1 : T[0] === 3 * c + 2 && (_ = 3) : T.length === 2 && T[0] === c && T[1] === y && (_ = 5), _ === 8 ? new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)') : new Error("Mask not supported");
      }
      let b = false, w = f;
      if (i && re.size(i.dims) > 0) {
        if (i.dims.length !== 3 && i.dims.length !== 4) throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        if (r.dims[0] !== i.dims[0]) throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        if (i.dims.length === 3) {
          if (d !== i.dims[1]) throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          w = i.dims[2];
        } else {
          if (d !== i.dims[2]) throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');
          w = i.dims[1] * i.dims[3], b = true;
        }
      }
      let x = false;
      if (o && re.size(o.dims) > 0) throw new Error("Key padding mask is not supported");
      if (s && re.size(s.dims) > 0) {
        if (s.dims.length !== 4) throw new Error('Input "attention_bias" is expected to have 4 dimensions');
        if (s.dims[0] !== c || s.dims[1] !== e.numHeads || s.dims[2] !== h || s.dims[3] !== y) throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
      }
      return {
        batchSize: c,
        sequenceLength: h,
        pastSequenceLength: p,
        kvSequenceLength: d,
        totalSequenceLength: y,
        maxSequenceLength: v,
        inputHiddenSize: 0,
        hiddenSize: f,
        vHiddenSize: w,
        headSize: g,
        vHeadSize: Math.floor(w / e.numHeads),
        numHeads: e.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: e.maskFilterValue,
        maskType: _,
        scale: e.scale,
        broadcastResPosBias: x,
        passPastInKv: b,
        qkvFormat: m
      };
    }, B8 = (t) => Bt({
      ...t
    }), Wb = Bt({
      perm: [
        0,
        2,
        1,
        3
      ]
    }), LO = (t, e, r, n, i, a, o) => {
      let s = [
        n,
        i,
        a
      ], l = re.size(s), u = [
        {
          type: 12,
          data: l
        },
        {
          type: 12,
          data: o
        },
        {
          type: 12,
          data: a
        }
      ], c = (h) => {
        let f = Re("qkv_with_bias", e.dataType, s), d = se("qkv", e.dataType, s), p = se("bias", r.dataType, s), v = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "bias_offset",
            type: "u32"
          },
          {
            name: "hidden_size",
            type: "u32"
          }
        ];
        return `
  ${h.registerUniforms(v).declareVariables(d, p, f)}
  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
      };
      return t.compute({
        name: "MultiHeadAttentionAddBias",
        shaderCache: {
          inputDependencies: [
            "type",
            "type"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: s,
              dataType: e.dataType,
              gpuDataType: 0
            }
          ],
          dispatchGroup: {
            x: Math.ceil(l / 64)
          },
          programUniforms: u
        }),
        getShaderSource: c
      }, {
        inputs: [
          e,
          r
        ],
        outputs: [
          -1
        ]
      })[0];
    }, ff = (t, e, r, n, i, a, o, s) => {
      let l = a;
      if (o && re.size(o.dims) > 0) {
        if (n === 1) throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
        return l = LO(t, a, o, e, n, r * i, s), l = l.reshape([
          e,
          n,
          r,
          i
        ]), r === 1 || n === 1 ? l : t.compute(qn(l, Wb.perm), {
          inputs: [
            l
          ],
          outputs: [
            -1
          ]
        })[0];
      } else return a.dims.length === 3 && (l = a.reshape([
        e,
        n,
        r,
        i
      ])), r === 1 || n === 1 ? l : t.compute(qn(l, Wb.perm), {
        inputs: [
          l
        ],
        outputs: [
          -1
        ]
      })[0];
    }, z8 = (t, e) => {
      let r = PO(t.inputs, e), n = t.inputs[0], i = cn(t.inputs, 1), a = cn(t.inputs, 2), o = cn(t.inputs, 3), s = cn(t.inputs, 4), l = cn(t.inputs, 5), u = cn(t.inputs, 6), c = cn(t.inputs, 7);
      if (n.dims.length === 5) throw new Error("Packed QKV is not implemented");
      if ((i == null ? void 0 : i.dims.length) === 5) throw new Error("Packed KV is not implemented");
      let h = i && a && i.dims.length === 4 && a.dims.length === 4, f = ff(t, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, n, o, 0);
      if (h) return vd(t, f, i, a, s, void 0, u, c, l, r);
      if (!i || !a) throw new Error("key and value must be provided");
      let d = ff(t, r.batchSize, r.numHeads, r.kvSequenceLength, r.headSize, i, o, r.hiddenSize), p = ff(t, r.batchSize, r.numHeads, r.kvSequenceLength, r.vHeadSize, a, o, 2 * r.hiddenSize);
      vd(t, f, d, p, s, void 0, u, c, l, r);
    };
  }), $O, RO, OO, NO, eS, V8, G8, W8 = ge(() => {
    Je(), ft(), ur(), mt(), $O = (t) => {
      if (!t || t.length < 1) throw new Error("too few inputs");
    }, RO = (t, e) => {
      let r = [], n = e.numOutputs;
      return t[1].dims[0] > 0 && (t[1].getBigInt64Array().forEach((i) => r.push(Number(i))), n = r.length), Bt({
        numOutputs: n,
        axis: e.axis,
        splitSizes: r
      });
    }, OO = (t) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
    if (index < ${Ne("uniforms.size_in_split_axis", "i", t)}) {
        return i;
    }
    }
    return ${t}u;
}`, NO = (t) => {
      let e = t.length, r = [];
      for (let n = 0; n < e; ++n) {
        let i = t[n].setByIndices("indices", "input[global_idx]");
        e === 1 ? r.push(i) : n === 0 ? r.push(`if (output_number == ${n}u) { ${i} }`) : n === e - 1 ? r.push(`else { ${i} }`) : r.push(`else if (output_number == ${n}) { ${i} }`);
      }
      return `
      fn writeBufferData(output_number: u32, indices: ${t[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`;
    }, eS = (t, e) => {
      let r = t[0].dims, n = re.size(r), i = t[0].dataType, a = re.normalizeAxis(e.axis, r.length), o = new Array(e.numOutputs), s = se("input", i, r.length), l = new Array(e.numOutputs), u = [], c = [], h = 0, f = [
        {
          type: 12,
          data: n
        }
      ];
      for (let p = 0; p < e.numOutputs; p++) {
        h += e.splitSizes[p], l[p] = h;
        let v = r.slice();
        v[a] = e.splitSizes[p], c.push(v), o[p] = Re(`output${p}`, i, v.length), u.push({
          dims: c[p],
          dataType: t[0].dataType
        });
      }
      f.push({
        type: 12,
        data: l
      }, ...Ve(r, ...c));
      let d = (p) => `
  ${p.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", l.length).declareVariables(s, ...o)}
  ${OO(l.length)}
  ${NO(o)}

  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${s.offsetToIndices("global_idx")};
    var index = ${s.indicesGet("indices", a)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Ne("uniforms.size_in_split_axis", "output_number - 1u", l.length)};
      ${s.indicesSet("indices", a, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
      return {
        name: "Split",
        shaderCache: {
          hint: e.cacheKey,
          inputDependencies: [
            "rank"
          ]
        },
        getShaderSource: d,
        getRunData: () => ({
          outputs: u,
          dispatchGroup: {
            x: Math.ceil(n / 64)
          },
          programUniforms: f
        })
      };
    }, V8 = (t, e) => {
      $O(t.inputs);
      let r = t.inputs.length === 1 ? e : RO(t.inputs, e);
      t.compute(eS(t.inputs, r), {
        inputs: [
          0
        ]
      });
    }, G8 = (t) => {
      let e = t.axis, r = t.splitSizes, n = t.numOutputs < 0 ? r.length : t.numOutputs;
      if (n !== r.length) throw new Error("numOutputs and splitSizes lengh must be equal");
      return Bt({
        axis: e,
        numOutputs: n,
        splitSizes: r
      });
    };
  }), BO, zO, Hb, H8, r0e = ge(() => {
    ur(), dC(), F8(), W8(), ws(), BO = (t, e) => {
      if (e.doRotary) throw new Error("GroupQuerryAttention do_rotary attribute is not supported");
      if (e.doRotary && t.length <= 7) throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");
      let r = t[0], n = t[1], i = t[2], a = t[3], o = t[4];
      if (e.localWindowSize !== -1) throw new Error("Local attention is not supported");
      if (e.softcap !== 0) throw new Error("Softcap is not supported");
      if (e.rotaryInterleaved !== 0) throw new Error("Rotary interleaved is not supported");
      if (e.smoothSoftmax) throw new Error("Smooth softmax is not supported");
      if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error("Input query is expected to have 3 or 5 dimensions");
      let s = false, l = r.dims[0], u = r.dims[1], c = r.dims.length === 3 ? s ? r.dims[2] / 3 : r.dims[2] : e.numHeads * r.dims[4], h = u, f = 0, d = !n || n.dims.length === 0, p = Math.floor(d ? c / (e.numHeads + 2 * e.kvNumHeads) : c / e.numHeads);
      d && (c = p * e.numHeads);
      let v = a && a.dims.length !== 0, g = o && o.dims.length !== 0;
      if (v && a.dims.length === 4 && a.dims[0] === l && a.dims[1] !== e.kvNumHeads && a.dims[2] === e.kvNumHeads && a.dims[3] === p) throw new Error("BSNH pastKey/pastValue is not supported");
      if (v && g) {
        if (a.dims.length !== 4) throw new Error('Input "past_key" is expected to have 4 dimensions');
        if (o.dims.length !== 4) throw new Error('Input "past_value" is expected to have 4 dimensions');
        f = a.dims[2];
      } else if (v || g) throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      let m = 1;
      if (n && n.dims.length > 0) {
        if (r.dims.length !== 3) throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        if (n.dims.length < 3 || n.dims.length > 5) throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        if (r.dims[0] !== n.dims[0]) throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        if (n.dims.length === 3) {
          if (r.dims[2] % n.dims[2] !== 0) throw new Error('Dimension 2 of "query" should be a multiple of "key"');
          h = n.dims[1];
        } else if (n.dims.length === 5) {
          if (n.dims[2] !== e.numHeads || n.dims[3] !== 2 || n.dims[4] !== p) throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          if (i) throw new Error('Expect "value" be none when "key" has packed kv format.');
          h = n.dims[1];
        } else {
          if (n.dims[1] !== e.numHeads || n.dims[3] !== p) throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          h = n.dims[2];
        }
      } else {
        if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
        if (r.dims.length === 5 && (r.dims[2] !== e.numHeads || r.dims[3] !== 3)) throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        m = 3;
      }
      let y = 0, _ = false, b = e.kvNumHeads ? p * e.kvNumHeads : c;
      if (i && i.dims.length > 0) {
        if (i.dims.length !== 3 && i.dims.length !== 4) throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        if (r.dims[0] !== i.dims[0]) throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        if (i.dims.length === 3) {
          if (h !== i.dims[1]) throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          b = i.dims[2];
        } else {
          if (h !== i.dims[2]) throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
          b = i.dims[1] * i.dims[3], _ = true;
        }
      }
      let w = t.length > 4 ? t[5] : void 0;
      if (w && w.dims.length !== 1 && w.dims[0] !== l) throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');
      return {
        batchSize: l,
        sequenceLength: u,
        pastSequenceLength: f,
        kvSequenceLength: h,
        totalSequenceLength: -1,
        maxSequenceLength: -1,
        inputHiddenSize: 0,
        hiddenSize: c,
        vHiddenSize: b,
        headSize: p,
        vHeadSize: Math.floor(b / e.kvNumHeads),
        numHeads: e.numHeads,
        kvNumHeads: e.kvNumHeads,
        nReps: e.numHeads / e.kvNumHeads,
        pastPresentShareBuffer: false,
        maskType: y,
        scale: e.scale,
        broadcastResPosBias: false,
        passPastInKv: _,
        qkvFormat: m
      };
    }, zO = Bt({
      perm: [
        0,
        2,
        1,
        3
      ]
    }), Hb = (t, e, r) => {
      let n = e, i = r.kvNumHeads;
      return e.dims.length === 3 && r.kvSequenceLength !== 0 && (n = e.reshape([
        r.batchSize,
        r.kvSequenceLength,
        i,
        r.headSize
      ]), n = t.compute(qn(n, zO.perm), {
        inputs: [
          n
        ],
        outputs: [
          -1
        ]
      })[0]), n;
    }, H8 = (t, e) => {
      var _a2;
      let r = BO(t.inputs, e);
      if (t.inputs[0].dims.length === 5) throw new Error("Packed QKV is not implemented");
      if (((_a2 = t.inputs[1]) == null ? void 0 : _a2.dims.length) === 5) throw new Error("Packed KV is not implemented");
      let n = t.inputs[0], i = t.inputs[1] && t.inputs[1].dims.length > 0 ? t.inputs[1] : void 0, a = t.inputs[2] && t.inputs[2].dims.length > 0 ? t.inputs[2] : void 0, o = t.inputs[3] && t.inputs[3].dims.length !== 0 ? t.inputs[3] : void 0, s = t.inputs[4] && t.inputs[4].dims.length !== 0 ? t.inputs[4] : void 0, l = t.inputs.length > 4 ? t.inputs[5] : void 0, u = t.inputs.length > 5 ? t.inputs[6] : void 0, c = r.kvNumHeads ? r.kvNumHeads : r.numHeads, h = Bt({
        axis: 2,
        numOutputs: 3,
        splitSizes: [
          r.numHeads * r.headSize,
          c * r.headSize,
          c * r.headSize
        ]
      }), [f, d, p] = !i && !a ? t.compute(eS([
        n
      ], h), {
        inputs: [
          n
        ],
        outputs: [
          -1,
          -1,
          -1
        ]
      }) : [
        n,
        i,
        a
      ], v = ff(t, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, f, void 0, 0);
      vd(t, v, Hb(t, d, r), Hb(t, p, r), void 0, void 0, o, s, void 0, r, l, u);
    };
  }), Ub, FO, VO, U8, n0e = ge(() => {
    Je(), ft(), ws(), mt(), Ub = (t, e, r, n, i, a, o, s) => {
      let l = or(a), u = l === 1 ? "f32" : `vec${l}f`, c = l === 1 ? "vec2f" : `mat2x${l}f`, h = i * o, f = 64;
      h === 1 && (f = 256);
      let d = [
        i,
        o,
        a / l
      ], p = [
        i,
        o,
        2
      ], v = [
        "rank",
        "type",
        "type"
      ], g = [];
      g.push(...Ve(d, p));
      let m = (y) => {
        let _ = se("x", e.dataType, 3, l), b = se("scale", r.dataType, r.dims), w = se("bias", n.dataType, n.dims), x = Re("output", 1, 3, 2), T = [
          _,
          b,
          w,
          x
        ];
        return `
  var<workgroup> workgroup_shared : array<${c}, ${f}>;
  const workgroup_size = ${f}u;
  ${y.declareVariables(...T)}
  ${y.mainStart(f)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${u}(0);
    var squared_sum = ${u}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${u}(${_.get("batch", "channel", "h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${c}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${ys("workgroup_shared[0][0]", l)} / f32(hight * ${l});
      let squared_sum_final = ${ys("workgroup_shared[0][1]", l)} / f32(hight * ${l});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${s}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`;
      };
      return t.compute({
        name: "InstanceNormComputeChannelScaleShift",
        shaderCache: {
          hint: `${l};${s};${f}`,
          inputDependencies: v
        },
        getRunData: () => ({
          outputs: [
            {
              dims: p,
              dataType: 1
            }
          ],
          dispatchGroup: {
            x: h
          },
          programUniforms: g
        }),
        getShaderSource: m
      }, {
        inputs: [
          e,
          r,
          n
        ],
        outputs: [
          -1
        ]
      })[0];
    }, FO = (t, e, r) => {
      let n = e[0].dims, i = n, a = 2, o = n[0], s = n[1], l = re.sizeFromDimension(n, a), u = or(l), c = re.size(i) / u, h = Ub(t, e[0], e[1], e[2], o, l, s, r.epsilon), f = [
        o,
        s,
        l / u
      ], d = [
        o,
        s
      ], p = [
        "type",
        "none"
      ], v = (g) => {
        let m = se("x", e[0].dataType, f.length, u), y = se("scale_shift", 1, d.length, 2), _ = Re("output", e[0].dataType, f.length, u), b = [
          m,
          y,
          _
        ];
        return `
  ${g.registerUniform("output_size", "u32").declareVariables(...b)}
  ${g.mainStart()}
  ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${_.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${y.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${m.getByOffset("global_idx")} * ${_.type.value}(scale_shift.x) + ${_.type.value}(scale_shift.y);
      ${_.setByOffset("global_idx", "value")};
  }`;
      };
      t.compute({
        name: "InstanceNormalization",
        shaderCache: {
          hint: `${u}`,
          inputDependencies: p
        },
        getRunData: () => ({
          outputs: [
            {
              dims: i,
              dataType: e[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(c / 64)
          },
          programUniforms: [
            {
              type: 12,
              data: c
            },
            ...Ve(f, d, f)
          ]
        }),
        getShaderSource: v
      }, {
        inputs: [
          e[0],
          h
        ]
      });
    }, VO = (t, e, r) => {
      let n = e[0].dims, i = n, a = n[0], o = n[n.length - 1], s = re.sizeFromDimension(n, 1) / o, l = or(o), u = re.size(i) / l, c = [
        {
          type: 12,
          data: s
        },
        {
          type: 12,
          data: Math.floor(o / l)
        }
      ], h = [
        "type",
        "type"
      ], f = false, d = [
        0,
        n.length - 1
      ];
      for (let m = 0; m < n.length - 2; m++) f = f || n[m + 1] !== 1, d.push(m + 1);
      f = f && n[n.length - 1] !== 1;
      let p = f ? t.compute(qn(t.inputs[0], d), {
        inputs: [
          t.inputs[0]
        ],
        outputs: [
          -1
        ]
      })[0] : t.inputs[0].reshape(Array.from({
        length: n.length
      }, (m, y) => n[d[y]])), v = Ub(t, p, e[1], e[2], a, s, o, r.epsilon), g = (m) => {
        let y = kr(e[0].dataType), _ = l === 1 ? "vec2f" : `mat${l}x2f`, b = (T) => {
          let A = T === 0 ? "x" : "y", I = l === 1 ? "f32" : `vec${l}f`;
          switch (l) {
            case 1:
              return `${y}(${I}(scale.${A}))`;
            case 2:
              return `vec2<${y}>(${I}(scale[0].${A}, scale[1].${A}))`;
            case 4:
              return `vec4<${y}>(${I}(scale[0].${A}, scale[1].${A}, scale[2].${A}, scale[3].${A}))`;
            default:
              throw new Error(`Not supported compoents ${l}`);
          }
        }, w = se("input", e[0].dataType, e[0].dims, l), x = Re("output", e[0].dataType, i, l);
        return `
  @group(0) @binding(0) var<storage, read> input : array<${w.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${_}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${x.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${m.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${b(0)}, ${b(1)});
  }`;
      };
      t.compute({
        name: "InstanceNormalizationNHWC",
        shaderCache: {
          hint: `${l}`,
          inputDependencies: h
        },
        getRunData: () => ({
          outputs: [
            {
              dims: i,
              dataType: e[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(u / 64)
          },
          programUniforms: c
        }),
        getShaderSource: g
      }, {
        inputs: [
          e[0],
          v
        ]
      });
    }, U8 = (t, e) => {
      e.format === "NHWC" ? VO(t, t.inputs, e) : FO(t, t.inputs, e);
    };
  }), GO, WO, Y8, i0e = ge(() => {
    Je(), ft(), mt(), GO = (t) => {
      if (!t || t.length < 2) throw new Error("layerNorm requires at least 2 inputs.");
    }, WO = (t, e, r) => {
      let n = e.simplified, i = t[0].dims, a = t[1], o = !n && t[2], s = i, l = re.normalizeAxis(e.axis, i.length), u = re.sizeToDimension(i, l), c = re.sizeFromDimension(i, l), h = re.size(a.dims), f = o ? re.size(o.dims) : 0;
      if (h !== c || o && f !== c) throw new Error(`Size of X.shape()[axis:] == ${c}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${h} and bias size of ${f}`);
      let d = [];
      for (let w = 0; w < i.length; ++w) w < l ? d.push(i[w]) : d.push(1);
      let p = or(c), v = [
        "type",
        "type"
      ], g = [
        {
          type: 12,
          data: u
        },
        {
          type: 1,
          data: c
        },
        {
          type: 12,
          data: Math.floor(c / p)
        },
        {
          type: 1,
          data: e.epsilon
        }
      ];
      o && v.push("type");
      let m = r > 1, y = r > 2, _ = (w) => {
        let x = kr(t[0].dataType), T = [
          se("x", t[0].dataType, t[0].dims, p),
          se("scale", a.dataType, a.dims, p)
        ];
        o && T.push(se("bias", o.dataType, o.dims, p)), T.push(Re("output", t[0].dataType, s, p)), m && T.push(Re("mean_data_output", 1, d)), y && T.push(Re("inv_std_output", 1, d));
        let A = [
          {
            name: "norm_count",
            type: "u32"
          },
          {
            name: "norm_size",
            type: "f32"
          },
          {
            name: "norm_size_vectorized",
            type: "u32"
          },
          {
            name: "epsilon",
            type: "f32"
          }
        ];
        return `
  ${w.registerUniforms(A).declareVariables(...T)}
  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Uw("f32", p)};
    var mean_square_vector = ${Uw("f32", p)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${sc(x, p, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${ys("mean_vector", p)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${ys("mean_square_vector", p)} / uniforms.norm_size ${n ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${sc(x, p, "x[j + offset]")};
      let f32scale = ${sc(x, p, "scale[j]")};
      output[j + offset] = ${T[0].type.value}((f32input ${n ? "" : "- mean"}) * inv_std_dev * f32scale
        ${o ? `+ ${sc(x, p, "bias[j]")}` : ""}
      );
    }

    ${m ? "mean_data_output[global_idx] = mean" : ""};
    ${y ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
      }, b = [
        {
          dims: s,
          dataType: t[0].dataType
        }
      ];
      return m && b.push({
        dims: d,
        dataType: 1
      }), y && b.push({
        dims: d,
        dataType: 1
      }), {
        name: "LayerNormalization",
        shaderCache: {
          hint: `${p};${r};${n}`,
          inputDependencies: v
        },
        getRunData: () => ({
          outputs: b,
          dispatchGroup: {
            x: Math.ceil(u / 64)
          },
          programUniforms: g
        }),
        getShaderSource: _
      };
    }, Y8 = (t, e) => {
      GO(t.inputs), t.compute(WO(t.inputs, e, t.outputCount));
    };
  }), HO, q8, a0e = ge(() => {
    ft(), yC(), _C(), HO = (t) => {
      if (!t || t.length !== 2) throw new Error("MatMul requires 2 inputs.");
      if (t[0].dims[t[0].dims.length - 1] !== t[1].dims[t[1].dims.length - 2]) throw new Error("shared dimension does not match.");
    }, q8 = (t) => {
      HO(t.inputs);
      let e = Ic.calcShape(t.inputs[0].dims, t.inputs[1].dims, true);
      if (!e) throw new Error("Can't use matmul on the given tensors");
      let r = e[e.length - 1], n = t.inputs[0].dims[t.inputs[0].dims.length - 1];
      if (r < 8 && n < 8) t.compute(mC(t.inputs, {
        activation: ""
      }, e));
      else {
        let i = e[e.length - 2], a = re.size(t.inputs[0].dims.slice(0, -2)), o = re.size(t.inputs[1].dims.slice(0, -2));
        if (a !== 1 && i === 1 && o === 1) {
          let s = t.inputs[0].reshape([
            1,
            a,
            n
          ]), l = t.inputs[1].reshape([
            1,
            n,
            r
          ]), u = [
            1,
            a,
            r
          ], c = [
            s,
            l
          ];
          t.compute(xm(c, {
            activation: ""
          }, e, u), {
            inputs: c
          });
        } else t.compute(xm(t.inputs, {
          activation: ""
        }, e));
      }
    };
  }), UO, YO, qO, X8, j8, o0e = ge(() => {
    Je(), ft(), ur(), mt(), UO = (t, e) => {
      if (t.length < 3 || t.length > 4) throw new Error("MatMulNBits requires 3 or 4 inputs");
      let r = t[0], n = r.dims.length;
      if (r.dims[n - 1] !== e.k) throw new Error("The last dim of input shape does not match the k value");
      let i = Math.floor((e.k + e.blockSize - 1) / e.blockSize), a = e.blockSize / 8 * e.bits, o = t[1];
      if (!re.areEqual(o.dims, [
        e.n,
        i,
        a
      ])) throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
      let s = t[2].dims;
      if (re.size(s) !== e.n * i) throw new Error("scales input size error.");
      if (t.length === 4) {
        let l = t[3].dims, u = e.bits > 4 ? e.n * i : e.n * Math.floor((i + 1) / 2);
        if (re.size(l) !== u) throw new Error("zeroPoints input size error.");
      }
    }, YO = (t, e) => {
      let r = t[0].dims, n = r.length, i = r[n - 2], a = e.k, o = e.n, s = r.slice(0, n - 2), l = re.size(s), u = t[1].dims[2] / 4, c = t[0].dataType, h = or(e.k), f = or(u), d = or(o), p = s.concat([
        i,
        o
      ]), v = i > 1 && o / d % 2 === 0 ? 2 : 1, g = re.size(p) / d / v, m = 64, y = [], _ = [
        l,
        i,
        a / h
      ], b = re.convertShape(t[1].dims).slice();
      b.splice(-1, 1, u / f), y.push(...Ve(_)), y.push(...Ve(b)), y.push(...Ve(t[2].dims)), t.length === 4 && y.push(...Ve(re.convertShape(t[3].dims)));
      let w = [
        l,
        i,
        o / d
      ];
      y.push(...Ve(w));
      let x = (T) => {
        let A = _.length, I = se("a", t[0].dataType, A, h), M = se("b", 12, b.length, f), k = se("scales", t[2].dataType, t[2].dims.length), B = [
          I,
          M,
          k
        ], L = t.length === 4 ? se("zero_points", 12, t[3].dims.length) : void 0;
        L && B.push(L);
        let z = w.length, F = Re("output", t[0].dataType, z, d), E = kr(t[0].dataType), O = (() => {
          switch (h) {
            case 1:
              return `array<${E}, 8>`;
            case 2:
              return `mat4x2<${E}>`;
            case 4:
              return `mat2x4<${E}>`;
            default:
              throw new Error(`${h}-component is not supported.`);
          }
        })(), N = () => {
          let G = `
          // reuse a data
            var input_offset = ${I.indicesToOffset(`${I.type.indices}(batch, row, word_offset)`)};
            var a_data: ${O};
            for (var j: u32 = 0; j < ${8 / h}; j++) {
              a_data[j] = ${I.getByOffset("input_offset")};
              input_offset++;
            }
          `;
          for (let Y = 0; Y < d * v; Y++) G += `
            b_value = ${f === 1 ? `b${Y}_data` : `b${Y}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${O}(${Array.from({
            length: 4
          }, (U, Z) => `${E}(b_value_lower[${Z}]), ${E}(b_value_upper[${Z}])`).join(", ")});
            b_dequantized_values = ${h === 1 ? `${O}(${Array.from({
            length: 8
          }, (U, Z) => `(b_quantized_values[${Z}] - ${L ? `zero_point${Y}` : "zero_point"}) * scale${Y}`).join(", ")});` : `(b_quantized_values - ${O}(${Array(8).fill(`${L ? `zero_point${Y}` : "zero_point"}`).join(",")})) * scale${Y};`};
            workgroup_shared[local_id.x * ${v} + ${Math.floor(Y / d)}]${d > 1 ? `[${Y % d}]` : ""} += ${Array.from({
            length: 8 / h
          }, (U, Z) => `${h === 1 ? `a_data[${Z}] * b_dequantized_values[${Z}]` : `dot(a_data[${Z}], b_dequantized_values[${Z}])`}`).join(" + ")};
          `;
          return G;
        }, V = () => {
          let G = `
            var col_index = col * ${d};
            ${L ? `
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${E}(8);`}
            `;
          for (let Y = 0; Y < d * v; Y++) G += `
            let scale${Y} = ${k.getByOffset("col_index * nBlocksPerCol + block")};
            ${L ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${L.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${Y} = ${E}((zero_point_word) & 0xFu);` : ""}
            col_index += 1;`;
          return G;
        }, H = () => {
          let G = `col_index = col * ${d};`;
          for (let Y = 0; Y < d * v; Y++) G += `
            let b${Y}_data = ${M.getByIndices(`${M.type.indices}(col_index, block, word)`)};
            col_index += 1;`;
          return G += `
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${O};
            var b_dequantized_values: ${O};`, G;
        };
        return `
        var<workgroup> workgroup_shared: array<${F.type.value}, ${v * m}>;
        ${T.declareVariables(...B, F)}
        ${T.mainStart([
          m,
          1,
          1
        ])}
          let output_indices = ${F.offsetToIndices(`(global_idx / ${m}) * ${v}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${m}) {
            //process one block
            var word_offset: u32 = block * ${e.blockSize / h};
            ${V()}
            for (var word: u32 = 0; word < ${u}; word += ${f}) {
              ${H()}
              for (var i: u32 = 0; i < ${f}; i++) {
                ${N()}
                word_offset += ${8 / h};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${v}) {
            var output_value: ${F.type.value} = ${F.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${m}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${v};
            }
            ${F.setByIndices(`${F.type.indices}(batch, row, col + local_id.x)`, "output_value")};
          }
        }`;
      };
      return {
        name: "MatMulNBits",
        shaderCache: {
          hint: `${e.blockSize};${e.bits};${h};${f};${d};${v};${m}`,
          inputDependencies: Array(t.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [
            {
              dims: p,
              dataType: c
            }
          ],
          dispatchGroup: {
            x: g
          },
          programUniforms: y
        }),
        getShaderSource: x
      };
    }, qO = (t, e) => {
      let r = t[0].dims, n = r.length, i = r[n - 2], a = e.k, o = e.n, s = r.slice(0, n - 2), l = re.size(s), u = t[1].dims[2] / 4, c = t[0].dataType, h = or(e.k), f = or(u), d = s.concat([
        i,
        o
      ]), p = 128, v = o % 8 === 0 ? 8 : o % 4 === 0 ? 4 : 1, g = p / v, m = g * f * 8, y = m / h, _ = m / e.blockSize, b = re.size(d) / v, w = [], x = [
        l,
        i,
        a / h
      ], T = re.convertShape(t[1].dims).slice();
      T.splice(-1, 1, u / f), w.push(...Ve(x)), w.push(...Ve(T)), w.push(...Ve(t[2].dims)), t.length === 4 && w.push(...Ve(re.convertShape(t[3].dims)));
      let A = [
        l,
        i,
        o
      ];
      w.push(...Ve(A));
      let I = (M) => {
        let k = x.length, B = se("a", t[0].dataType, k, h), L = se("b", 12, T.length, f), z = se("scales", t[2].dataType, t[2].dims.length), F = [
          B,
          L,
          z
        ], E = t.length === 4 ? se("zero_points", 12, t[3].dims.length) : void 0;
        E && F.push(E);
        let O = A.length, N = Re("output", t[0].dataType, O), V = kr(t[0].dataType), H = () => {
          switch (h) {
            case 1:
              return `
          let a_data0 = vec4<${V}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${V}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;
            case 2:
              return `
          let a_data0 = vec4<${V}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${V}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;
            case 4:
              return `
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;
            default:
              throw new Error(`${h}-component is not supported.`);
          }
        };
        return `
        var<workgroup> sub_a: array<${B.type.value}, ${y}>;
        var<workgroup> inter_results: array<array<${N.type.value}, ${g}>, ${v}>;
        ${M.declareVariables(...F, N)}
        ${M.mainStart([
          g,
          v,
          1
        ])}
          let output_indices = ${N.offsetToIndices(`workgroup_index * ${v}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${_} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${y};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${y}; a_offset += ${p})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${B.getByIndices(`${B.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${B.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${_} + local_id.x;
            ${E ? `
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${E.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${V}((zero_point_word) & 0xFu);` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${V}(8);`}
            let scale = ${z.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${L.getByIndices(`${L.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${e.blockSize / h};
            for (var i: u32 = 0; i < ${f}; i++) {
              ${H()}
              let b_value = ${f === 1 ? "b_data" : "b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${V}>(${Array.from({
          length: 4
        }, (G, Y) => `${V}(b_value_lower[${Y}]), ${V}(b_value_upper[${Y}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${V}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({
          length: 2
        }, (G, Y) => `${`dot(a_data${Y}, b_dequantized_values[${Y}])`}`).join(" + ")};
              word_offset += ${8 / h};
            }
            workgroupBarrier();
          }

          if (local_idx < ${v}) {
            var output_value: ${N.type.value} = ${N.type.value}(0);
            for (var b = 0u; b < ${g}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${N.setByIndices(`${N.type.indices}(batch, row, col + local_idx)`, "output_value")}
            }
          }
        }`;
      };
      return {
        name: "BlockwiseMatMulNBits32",
        shaderCache: {
          hint: `${e.blockSize};${h};${f};${g};${v}`,
          inputDependencies: Array(t.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [
            {
              dims: d,
              dataType: c
            }
          ],
          dispatchGroup: {
            x: b
          },
          programUniforms: w
        }),
        getShaderSource: I
      };
    }, X8 = (t, e) => {
      UO(t.inputs, e), e.blockSize === 32 && t.adapterInfo.isVendor("intel") && t.adapterInfo.isArchitecture("gen-12lp") ? t.compute(qO(t.inputs, e)) : t.compute(YO(t.inputs, e));
    }, j8 = (t) => Bt(t);
  }), XO, jO, KO, ZO, QO, JO, eN, tN, K8, s0e = ge(() => {
    Je(), ft(), mt(), XO = (t) => {
      if (!t || t.length < 1) throw new Error("Too few inputs");
      if (t[0].dataType !== 1 && t[0].dataType !== 10) throw new Error("Input type must be float or float16.");
      if (t.length >= 2) {
        let e = t[0].dims.length * 2 === t[1].dims[0];
        if (t.length === 4 && (e = t[3].dims[0] * 2 === t[1].dims[0]), !e) throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
      }
    }, jO = (t, e, r) => {
      let n = "";
      for (let i = e - 1; i >= 0; --i) n += `
            k = i32(${t.indicesGet("indices", i)}) - ${Ne("uniforms.pads", i, r)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Ne("uniforms.x_shape", i, e)})) {
              break;
            }
            offset += k * i32(${Ne("uniforms.x_strides", i, e)});
        `;
      return `
          value = ${t.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${n}
            value = x[offset];
          }
      `;
    }, KO = (t, e, r) => {
      let n = "";
      for (let i = e - 1; i >= 0; --i) n += `
                k = i32(${t.indicesGet("indices", i)}) - ${Ne("uniforms.pads", i, r)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Ne("uniforms.x_shape", i, e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Ne("uniforms.x_shape", i, e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Ne("uniforms.x_strides", i, e)});
            `;
      return `
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `;
    }, ZO = (t, e, r) => {
      let n = "";
      for (let i = e - 1; i >= 0; --i) n += `
                k = i32(${t.indicesGet("indices", i)}) - ${Ne("uniforms.pads", i, r)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Ne("uniforms.x_shape", i, e)})) {
                  k = i32(${Ne("uniforms.x_shape", i, e)}) - 1;
                }
                offset += k * i32(${Ne("uniforms.x_strides", i, e)});
            `;
      return `
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `;
    }, QO = (t, e, r) => {
      let n = "";
      for (let i = e - 1; i >= 0; --i) n += `
                k = i32(${t.indicesGet("indices", i)}) - ${Ne("uniforms.pads", i, r)};
                if (k < 0)  {
                  k += i32(${Ne("uniforms.x_shape", i, e)}]);
                }
                if (k >= i32(${Ne("uniforms.x_shape", i, e)})) {
                  k -= i32(${Ne("uniforms.x_shape", i, e)});
                }
                offset += k * i32(${Ne("uniforms.x_strides", i, e)});
            `;
      return `
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `;
    }, JO = (t, e, r) => {
      switch (r.mode) {
        case 0:
          return jO(t, e, r.pads.length);
        case 1:
          return KO(t, e, r.pads.length);
        case 2:
          return ZO(t, e, r.pads.length);
        case 3:
          return QO(t, e, r.pads.length);
        default:
          throw new Error("Invalid mode");
      }
    }, eN = (t, e) => {
      let r = re.padShape(t[0].dims.slice(), e.pads), n = t[0].dims, i = re.size(r), a = [
        {
          type: 12,
          data: i
        },
        {
          type: 6,
          data: e.pads
        }
      ], o = t.length >= 3 && t[2].data;
      e.mode === 0 && a.push({
        type: o ? t[2].dataType : 1,
        data: e.value
      }), a.push(...Ve(t[0].dims, r));
      let s = [
        "rank"
      ], l = (u) => {
        let c = Re("output", t[0].dataType, r.length), h = se("x", t[0].dataType, n.length), f = h.type.value, d = JO(c, n.length, e), p = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "pads",
            type: "i32",
            length: e.pads.length
          }
        ];
        return e.mode === 0 && p.push({
          name: "constant_value",
          type: o ? f : "f32"
        }), `
            ${u.registerUniforms(p).declareVariables(h, c)}
            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${c.offsetToIndices("global_idx")};

            var value = ${f}(0);
            ${d}
            output[global_idx] = value;
        }`;
      };
      return {
        name: "Pad",
        shaderCache: {
          hint: `${e.mode}${o}`,
          inputDependencies: s
        },
        getRunData: () => ({
          outputs: [
            {
              dims: r,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(re.size(r) / 64)
          },
          programUniforms: a
        }),
        getShaderSource: l
      };
    }, tN = (t, e) => {
      if (t.length > 1) {
        let r = t[1].getBigInt64Array(), n = t.length >= 3 && t[2].data ? t[2].dataType === 10 ? t[2].getUint16Array()[0] : t[2].getFloat32Array()[0] : 0, i = t[0].dims.length, a = new Int32Array(2 * i).fill(0);
        if (t.length >= 4) {
          let s = t[3].getBigInt64Array();
          for (let l = 0; l < s.length; l++) a[Number(s[l])] = Number(r[l]), a[Number(s[l]) + i] = Number(r[l + s.length]);
        } else r.forEach((s, l) => a[Number(l)] = Number(s));
        let o = [];
        return a.forEach((s) => o.push(s)), {
          mode: e.mode,
          value: n,
          pads: o
        };
      } else return e;
    }, K8 = (t, e) => {
      XO(t.inputs);
      let r = tN(t.inputs, e);
      t.compute(eN(t.inputs, r), {
        inputs: [
          0
        ]
      });
    };
  }), zh, Yb, qb, Xb, jb, rN, nN, Kb, Zb, Z8, Q8, Qb, J8, eY, Jb, tY, rY, nY, iY, l0e = ge(() => {
    ea(), Je(), ft(), mt(), zh = (t) => {
      if (rr.webgpu.validateInputContent && (!t || t.length !== 1)) throw new Error("Pool ops requires 1 input.");
    }, Yb = (t, e, r) => {
      let n = e.format === "NHWC", i = t.dims.slice();
      n && i.splice(1, 0, i.pop());
      let a = Object.hasOwnProperty.call(e, "dilations"), o = e.kernelShape.slice(), s = e.strides.slice(), l = a ? e.dilations.slice() : [], u = e.pads.slice();
      _m.adjustPoolAttributes(r, i, o, s, l, u);
      let c = _m.computePoolOutputShape(r, i, s, l, o, u, e.autoPad), h = Object.assign({}, e);
      a ? Object.assign(h, {
        kernelShape: o,
        strides: s,
        pads: u,
        dilations: l,
        cacheKey: e.cacheKey
      }) : Object.assign(h, {
        kernelShape: o,
        strides: s,
        pads: u,
        cacheKey: e.cacheKey
      });
      let f = c.slice();
      return f.push(f.splice(1, 1)[0]), [
        h,
        n ? f : c
      ];
    }, qb = (t, e) => {
      let r = e.format === "NHWC", n = re.size(t), i = re.size(e.kernelShape), a = [
        {
          type: 12,
          data: n
        },
        {
          type: 12,
          data: i
        }
      ], o = [
        {
          name: "outputSize",
          type: "u32"
        },
        {
          name: "kernelSize",
          type: "u32"
        }
      ];
      if (e.kernelShape.length <= 2) {
        let s = e.kernelShape[e.kernelShape.length - 1], l = e.strides[e.strides.length - 1], u = e.pads[e.pads.length / 2 - 1], c = e.pads[e.pads.length - 1], h = !!(u + c);
        a.push({
          type: 12,
          data: s
        }, {
          type: 12,
          data: l
        }, {
          type: 12,
          data: u
        }, {
          type: 12,
          data: c
        }), o.push({
          name: "kw",
          type: "u32"
        }, {
          name: "sw",
          type: "u32"
        }, {
          name: "pwStart",
          type: "u32"
        }, {
          name: "pwEnd",
          type: "u32"
        });
        let f = false;
        if (e.kernelShape.length === 2) {
          let d = e.kernelShape[e.kernelShape.length - 2], p = e.strides[e.strides.length - 2], v = e.pads[e.pads.length / 2 - 2], g = e.pads[e.pads.length - 2];
          f = !!(v + g), a.push({
            type: 12,
            data: d
          }, {
            type: 12,
            data: p
          }, {
            type: 12,
            data: v
          }, {
            type: 12,
            data: g
          }), o.push({
            name: "kh",
            type: "u32"
          }, {
            name: "sh",
            type: "u32"
          }, {
            name: "phStart",
            type: "u32"
          }, {
            name: "phEnd",
            type: "u32"
          });
        }
        return [
          a,
          o,
          true,
          h,
          f
        ];
      } else {
        if (r) throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        let s = re.computeStrides(e.kernelShape);
        a.push({
          type: 12,
          data: s
        }, {
          type: 12,
          data: e.pads
        }, {
          type: 12,
          data: e.strides
        }), o.push({
          name: "kernelStrides",
          type: "u32",
          length: s.length
        }, {
          name: "pads",
          type: "u32",
          length: e.pads.length
        }, {
          name: "strides",
          type: "u32",
          length: e.strides.length
        });
        let l = e.pads.reduce((u, c) => u + c);
        return [
          a,
          o,
          !!l,
          false,
          false
        ];
      }
    }, Xb = (t, e, r, n, i, a, o, s, l, u, c, h) => {
      let f = i.format === "NHWC", d = e.type.value, p = Re("output", e.type.tensor, n);
      if (i.kernelShape.length <= 2) {
        let v = "", g = "", m = "", y = r - (f ? 2 : 1);
        if (c ? v = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${y}] = indices[${y}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${y}] < 0 || xIndices[${y}]
                      >= uniforms.x_shape[${y}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${a}
                }` : v = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${y}] = indices[${y}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${a}
                }`, i.kernelShape.length === 2) {
          let _ = r - (f ? 3 : 2);
          h ? g = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${_}] < 0 || xIndices[${_}] >= uniforms.x_shape[${_}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              ` : g = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${_}] = indices[${_}] * uniforms.sh - uniforms.phStart + j;
                `, m = `
              }
            `;
        }
        return `
            ${t.registerUniforms(l).declareVariables(e, p)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${p.offsetToIndices("global_idx")};
              var xIndices = ${p.offsetToIndices("global_idx")};

              var value = ${d}(${s});
              var pad = 0;
              ${g}
              ${v}
              ${m}
              ${o}

              output[global_idx] = value;
            }`;
      } else {
        if (f) throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        let v = i.kernelShape.length, g = i.pads.length, m = "";
        return u ? m = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${a}
              }` : m = `
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${a}
            `, `
            ${t.registerUniforms(l).declareVariables(e, p)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${p.offsetToIndices("global_idx")};
              var xIndices = ${p.offsetToIndices("global_idx")};

              var offsets: array<u32, ${v}>;

              var value = ${d}(${s});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${v - 1}u; j++) {
                  offsets[j] = offset / ${Ne("uniforms.kernelStrides", "j", v)};
                  offset -= offsets[j] * ${Ne("uniforms.kernelStrides", "j", v)};
                }
                offsets[${v - 1}] = offset;

                isPad = false;
                for (var j = ${r - v}u; j < ${r}u; j++) {
                  xIndices[j] = indices[j] * ${Ne("uniforms.strides", `j - ${r - v}u`, v)}
                    + offsets[j - ${r - v}u] - ${Ne("uniforms.pads", "j - 2u", g)};
                  ${m}
              }
              ${o}

              output[global_idx] = value;
            }`;
      }
    }, jb = (t) => `${t.format};${t.ceilMode};${t.autoPad};${t.kernelShape.length}`, rN = (t) => `${jb(t)};${t.countIncludePad}`, nN = (t) => `${jb(t)};${t.storageOrder};${t.dilations}`, Kb = (t) => ({
      format: t.format,
      autoPad: [
        "NOTSET",
        "VALID",
        "SAME_UPPER",
        "SAME_LOWER"
      ][t.auto_pad],
      ceilMode: t.ceil_mode,
      kernelShape: t.kernel_shape,
      strides: t.strides,
      pads: t.pads
    }), Zb = (t, e, r, n) => {
      let [i, a] = Yb(e, n, r), o = se("x", e.dataType, e.dims.length), s = o.type.value, l = "value += x_val;", u = "";
      i.countIncludePad ? u += `value /= ${s}(uniforms.kernelSize);` : u += `value /= ${s}(i32(uniforms.kernelSize) - pad);`;
      let [c, h, f, d, p] = qb(a, i);
      c.push(...Ve(e.dims, a));
      let v = [
        "rank"
      ];
      return {
        name: t,
        shaderCache: {
          hint: `${n.cacheKey};${f};${d};${p}`,
          inputDependencies: v
        },
        getRunData: () => ({
          outputs: [
            {
              dims: a,
              dataType: e.dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(re.size(a) / 64)
          },
          programUniforms: c
        }),
        getShaderSource: (g) => Xb(g, o, e.dims.length, a.length, i, l, u, 0, h, f, d, p)
      };
    }, Z8 = (t) => {
      let e = t.count_include_pad !== 0, r = Kb(t);
      if (r.ceilMode !== 0) throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
      let n = {
        countIncludePad: e,
        ...r,
        cacheKey: ""
      };
      return {
        ...n,
        cacheKey: rN(n)
      };
    }, Q8 = (t, e) => {
      zh(t.inputs), t.compute(Zb("AveragePool", t.inputs[0], false, e));
    }, Qb = {
      autoPad: "",
      ceilMode: 0,
      countIncludePad: false,
      kernelShape: [],
      strides: [],
      pads: [],
      storageOrder: 0,
      dilations: []
    }, J8 = (t) => {
      let e = t.format;
      return {
        format: e,
        ...Qb,
        cacheKey: e
      };
    }, eY = (t, e) => {
      zh(t.inputs), t.compute(Zb("GlobalAveragePool", t.inputs[0], true, e));
    }, Jb = (t, e, r, n) => {
      let [i, a] = Yb(e, n, r), o = `
      value = max(x_val, value);
    `, s = "", l = se("x", e.dataType, e.dims.length), u = [
        "rank"
      ], [c, h, f, d, p] = qb(a, i);
      return c.push(...Ve(e.dims, a)), {
        name: t,
        shaderCache: {
          hint: `${n.cacheKey};${f};${d};${p}`,
          inputDependencies: u
        },
        getRunData: () => ({
          outputs: [
            {
              dims: a,
              dataType: e.dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(re.size(a) / 64)
          },
          programUniforms: c
        }),
        getShaderSource: (v) => Xb(v, l, e.dims.length, a.length, i, o, s, e.dataType === 10 ? -65504 : -1e5, h, f, d, p)
      };
    }, tY = (t, e) => {
      zh(t.inputs), t.compute(Jb("MaxPool", t.inputs[0], false, e));
    }, rY = (t) => {
      let e = t.storage_order, r = t.dilations, n = Kb(t);
      if (e !== 0) throw new Error("column major storage order is not yet supported for MaxPool");
      if (n.ceilMode !== 0) throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
      let i = {
        storageOrder: e,
        dilations: r,
        ...n,
        cacheKey: ""
      };
      return {
        ...i,
        cacheKey: nN(i)
      };
    }, nY = (t) => {
      let e = t.format;
      return {
        format: e,
        ...Qb,
        cacheKey: e
      };
    }, iY = (t, e) => {
      zh(t.inputs), t.compute(Jb("GlobalMaxPool", t.inputs[0], true, e));
    };
  }), iN, aN, aY, oY, u0e = ge(() => {
    Je(), ft(), ur(), mt(), iN = (t, e) => {
      if (t.length < 2 || t.length > 3) throw new Error("DequantizeLinear requires 2 or 3 inputs.");
      if (t.length === 3 && t[1].dims === t[2].dims) throw new Error("x-scale and x-zero-point must have the same shape.");
      if (t.length === 3 && t[0].dataType !== t[2].dataType) throw new Error("x and x-zero-point must have the same data type.");
      if (t[0].dataType === 6 && t.length > 2) throw new Error("In the case of dequantizing int32 there is no zero point.");
      if (t[1].dims.length !== 0 && t[1].dims.length !== 1 && t[1].dims.length !== t[0].dims.length) throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");
      if (t.length > 2) {
        if (t[0].dataType !== t[2].dataType) throw new Error("x and x-zero-point must have the same data type.");
        if (t[1].dims.length !== t[2].dims.length) throw new Error("scale and zero-point inputs must have the same rank.");
        if (!t[1].dims.map((r, n) => r === t[2].dims[n]).reduce((r, n) => r && n, true)) throw new Error("scale and zero-point inputs must have the same shape.");
      }
      if (e.blockSize > 0) {
        if (t[1].dims.length === 0 || t[1].dims.length === 1 && t[1].dims[0] === 1) throw new Error("blockSize must be set only for block quantization.");
        if (!t[1].dims.map((i, a) => a === e.axis || i === t[0].dims[a]).reduce((i, a) => i && a, true)) throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");
        if (t[1].dims.length !== t[0].dims.length) throw new Error("For block qunatization the scale input rank must be the same as the x rank.");
        let r = t[0].dims[e.axis], n = t[1].dims[e.axis];
        if (e.blockSize < Math.ceil(r / n) || e.blockSize > Math.ceil(r / (n - 1) - 1)) throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].");
      }
    }, aN = (t, e) => {
      let r = re.normalizeAxis(e.axis, t[0].dims.length), n = t[0].dataType, i = n === 3, a = t[0].dims, o = t[1].dataType, s = re.size(a), l = n === 3 || n === 2, u = l ? [
        Math.ceil(re.size(t[0].dims) / 4)
      ] : t[0].dims, c = t[1].dims, h = t.length > 2 ? t[2] : void 0, f = h ? l ? [
        Math.ceil(re.size(h.dims) / 4)
      ] : h.dims : void 0, d = c.length === 0 || c.length === 1 && c[0] === 1, p = d === false && c.length === 1, v = or(s), g = d && (!l || v === 4), m = g ? v : 1, y = g && !l ? v : 1, _ = se("input", l ? 12 : n, u.length, y), b = se("scale", o, c.length), w = h ? se("zero_point", l ? 12 : n, f.length) : void 0, x = Re("output", o, a.length, m), T = [
        _,
        b
      ];
      w && T.push(w);
      let A = [
        u,
        c
      ];
      h && A.push(f);
      let I = [
        {
          type: 12,
          data: s / m
        },
        {
          type: 12,
          data: r
        },
        {
          type: 12,
          data: e.blockSize
        },
        ...Ve(...A, a)
      ], M = (k) => {
        let B = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "axis",
            type: "u32"
          },
          {
            name: "block_size",
            type: "u32"
          }
        ];
        return `
      ${k.registerUniforms(B).declareVariables(...T, x)}
      ${k.mainStart()}
          ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${x.offsetToIndices("global_idx")};

          // Set input x
          ${l ? `
            let input = ${_.getByOffset("global_idx / 4")};
            let x_vec = ${i ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${m === 1 ? "x_vec[global_idx % 4]" : "x_vec"};` : `let x_value = ${_.getByOffset("global_idx")};`};

          // Set scale input
          ${d ? `let scale_value= ${b.getByOffset("0")}` : p ? `
            let scale_index = ${x.indicesGet("output_indices", "uniforms.axis")};
            let scale_value= ${b.getByOffset("scale_index")};` : `
            var scale_indices: ${b.type.indices} = output_indices;
            let index = ${b.indicesGet("scale_indices", "uniforms.axis")} / uniforms.block_size;
            ${b.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${b.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${w ? d ? l ? `
                let zero_point_input = ${w.getByOffset("0")};
                let zero_point_vec =  ${i ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]` : `let zero_point_value = ${w.getByOffset("0")}` : p ? l ? `
                let zero_point_index = ${x.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_input = ${w.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${i ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]` : `
                let zero_point_index = ${x.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_value = ${w.getByOffset("zero_point_index")};` : l ? `
                let zero_point_offset = ${b.indicesToOffset("scale_indices")};
                let zero_point_input = ${w.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${i ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];` : `let zero_point_value = ${w.getByIndices("scale_indices")};` : `let zero_point_value = ${l ? i ? "i32" : "u32" : _.type.value}(0);`};
      // Compute and write output
      ${x.setByOffset("global_idx", `${x.type.value}(x_value - zero_point_value) * scale_value`)};
      }`;
      };
      return {
        name: "DequantizeLinear",
        shaderCache: {
          hint: e.cacheKey,
          inputDependencies: w ? [
            "rank",
            "rank",
            "rank"
          ] : [
            "rank",
            "rank"
          ]
        },
        getShaderSource: M,
        getRunData: () => ({
          outputs: [
            {
              dims: a,
              dataType: o
            }
          ],
          dispatchGroup: {
            x: Math.ceil(s / m / 64),
            y: 1,
            z: 1
          },
          programUniforms: I
        })
      };
    }, aY = (t, e) => {
      iN(t.inputs, e), t.compute(aN(t.inputs, e));
    }, oY = (t) => Bt({
      axis: t.axis,
      blockSize: t.blockSize
    });
  }), oN, sN, sY, c0e = ge(() => {
    ea(), Je(), mt(), oN = (t, e, r) => {
      let n = t === e, i = t < e && r < 0, a = t > e && r > 0;
      if (n || i || a) throw new Error("Range these inputs' contents are invalid.");
    }, sN = (t, e, r, n) => {
      let i = Math.abs(Math.ceil((e - t) / r)), a = [
        i
      ], o = i, s = [
        {
          type: 12,
          data: o
        },
        {
          type: n,
          data: t
        },
        {
          type: n,
          data: r
        },
        ...Ve(a)
      ], l = (u) => {
        let c = Re("output", n, a.length), h = c.type.value, f = [
          {
            name: "outputSize",
            type: "u32"
          },
          {
            name: "start",
            type: h
          },
          {
            name: "delta",
            type: h
          }
        ];
        return `
        ${u.registerUniforms(f).declareVariables(c)}
        ${u.mainStart()}
        ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${h}(global_idx) * uniforms.delta;
      }`;
      };
      return {
        name: "Range",
        shaderCache: {
          hint: `${n}`
        },
        getShaderSource: l,
        getRunData: () => ({
          outputs: [
            {
              dims: a,
              dataType: n
            }
          ],
          dispatchGroup: {
            x: Math.ceil(o / 64)
          },
          programUniforms: s
        })
      };
    }, sY = (t) => {
      let e = 0, r = 0, n = 0;
      t.inputs[0].dataType === 6 ? (e = t.inputs[0].getInt32Array()[0], r = t.inputs[1].getInt32Array()[0], n = t.inputs[2].getInt32Array()[0]) : t.inputs[0].dataType === 1 && (e = t.inputs[0].getFloat32Array()[0], r = t.inputs[1].getFloat32Array()[0], n = t.inputs[2].getFloat32Array()[0]), rr.webgpu.validateInputContent && oN(e, r, n), t.compute(sN(e, r, n, t.inputs[0].dataType), {
        inputs: []
      });
    };
  }), lN, uN, lY, uY, h0e = ge(() => {
    Je(), ft(), ur(), mt(), lN = (t, e, r, n) => {
      if (t !== "none" && n !== "i32" && n !== "u32" && n !== "f32") throw new Error(`Input ${n} is not supported with reduction ${t}.`);
      let i = `{
                var oldValue = 0;
                loop {
                  let newValueF32 =`, a = `;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${e}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;
      switch (t) {
        case "none":
          return `${e}=${r};`;
        case "add":
          return n === "i32" || n === "u32" ? `atomicAdd(&${e}, bitcast<${n}>(${r}));` : `
              ${i}bitcast<${n}>(oldValue) + (${r})${a}`;
        case "max":
          return n === "i32" || n === "u32" ? `atomicMax(&${e}, bitcast<${n}>(${r}));` : `
                ${i}max(bitcast<f32>(oldValue), (${r}))${a}`;
        case "min":
          return n === "i32" || n === "u32" ? `atomicMin(&${e}, bitcast<${n}>(${r}));` : `${i}min(bitcast<${n}>(oldValue), (${r}))${a}`;
        case "mul":
          return `${i}(bitcast<${n}>(oldValue) * (${r}))${a}`;
        default:
          throw new Error(`Reduction ${t} is not supported.`);
      }
    }, uN = (t, e) => {
      let r = t[0].dims, n = t[1].dims, i = r, a = 1, o = Math.ceil(re.size(n) / a), s = n[n.length - 1], l = re.sizeFromDimension(r, s), u = [
        {
          type: 12,
          data: o
        },
        {
          type: 12,
          data: s
        },
        {
          type: 12,
          data: l
        },
        ...Ve(t[1].dims, t[2].dims, i)
      ], c = (h) => {
        let f = se("indices", t[1].dataType, t[1].dims.length), d = se("updates", t[2].dataType, t[2].dims.length, a), p = e.reduction !== "none" && e.reduction !== "" ? zU("output", t[0].dataType, i.length) : Re("output", t[0].dataType, i.length, a);
        return `
      ${h.registerUniform("output_size", "u32").registerUniform("last_index_dimension", "u32").registerUniform("num_updates_elements", "u32").declareVariables(f, d, p)}
      ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${e.reduction === "none"}) {
    let n = ${re.size(n)};
    for (var i = 0; i < n; i = i + 1) {
      for (var j = i + 1; j < n; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  if (${e.reduction === "none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    indices_start = 0u;
  }
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${t[0].dims.length === 1 ? `
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;` : `
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${lN(e.reduction, "output[data_offset + i]", "value", p.type.value)}
  }

      }`;
      };
      return {
        name: "ScatterND",
        shaderCache: {
          hint: `${e.cacheKey}_${e.reduction}`,
          inputDependencies: [
            "rank",
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: i,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(o / 64)
          },
          programUniforms: u
        }),
        getShaderSource: c
      };
    }, lY = (t) => Bt({
      reduction: t.reduction
    }), uY = (t, e) => {
      t.compute(uN(t.inputs, e), {
        inputs: [
          t.inputs[1],
          t.inputs[2]
        ],
        outputs: []
      });
    };
  }), cN, hN, fN, e1, dN, pN, vN, gN, mN, yN, _N, bN, t1, xN, wN, SN, TN, CN, cY, hY, f0e = ge(() => {
    Je(), ft(), ur(), mt(), cN = (t, e) => {
      if (t.every((r) => r > 0 || (() => {
        throw new Error("Resize requires scales input values to be positive");
      })), t.length > 0) {
        if (e.mode === "linear") {
          if (!(t.length === 2 || t.length === 3 || t.length === 4 && t[0] === 1 && t[1] === 1 || t.length === 4 && t[0] === 1 && t[3] === 1 || t.length === 5 && t[0] === 1 && t[1] === 1)) throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`);
        } else if (e.mode === "cubic" && !(t.length === 2 || t.length === 4 && t[0] === 1 && t[1] === 1 || t.length === 4 && t[0] === 1 && t[3] === 1)) throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
      }
    }, hN = (t, e, r) => {
      e.every((i) => i >= 0 && i < r || (() => {
        throw new Error("Resize requires axes input values to be positive and less than rank");
      }));
      let n = new Array(r).fill(1);
      return e.forEach((i, a) => n[i] = t[a]), n;
    }, fN = (t, e, r, n, i, a) => {
      let [o, s, l] = r > 10 ? [
        1,
        2,
        3
      ] : [
        -1,
        t.length > 1 ? 1 : -1,
        -1
      ], u = t[0].dims.length;
      if (o > 0 && t.length > o && t[o].dims.length > 0) t[o].getFloat32Array().forEach((c) => a.push(c));
      else if (e.coordinateTransformMode === "tf_crop_and_resize") throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
      if (s > 0 && t.length > s && t[s].dims.length === 1 && t[s].dims[0] > 0) {
        if (t[s].getFloat32Array().forEach((c) => n.push(c)), n.length !== 0 && n.length !== u && r >= 18 && n.length !== e.axes.length) throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
        cN(n, e), e.axes.length > 0 && hN(n, e.axes, u).forEach((c, h) => n[h] = c);
      }
      if (l > 0 && t.length > l && t[l].dims.length === 1 && t[l].dims[0] > 0 && (t[l].getBigInt64Array().forEach((c) => i.push(Number(c))), i.length !== 0 && i.length !== u && r >= 18 && i.length !== e.axes.length)) throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
      if (e.axes.length > 0) {
        if (n.length !== 0 && n.length !== e.axes.length) throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
        if (i.length !== 0 && i.length !== e.axes.length) throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
      }
      if (typeof n < "u" && typeof i < "u" && n.length > 0 && i.length > u) throw new Error("Resize requires only of scales or sizes to be specified");
    }, e1 = (t, e, r, n) => `
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${t}) * (${e});
  let whole = ${n}(big / (${r}));
  let fract = ${n}(big % (${r})) / ${n}(${r});
  return whole + fract;
`, dN = (t, e) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { ` + (() => {
      switch (t) {
        case "asymmetric":
          return `
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${e}(xResized) / ${e}(xScale);
          } else {
            ${e1("xResized", "lengthOriginal", "lengthResized", e)}
          }
        `;
        case "pytorch_half_pixel":
          return `if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
        case "tf_half_pixel_for_nn":
          return `return (${e}(xResized) + 0.5) / ${e}(xScale);`;
        case "align_corners":
          return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${e1("xResized", "lengthOriginal - 1", "lengthResized - 1", e)}
                  }`;
        case "tf_crop_and_resize":
          return `if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;
        case "half_pixel_symmetric":
          return `const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;
        case "half_pixel":
          return `return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;
        default:
          throw new Error(`Coordinate transform mode ${t} is not supported`);
      }
    })() + "}", pN = (t, e, r) => `fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {` + (() => {
      switch (t) {
        case "round_prefer_ceil":
          return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
        case "floor":
          return "return floor(xOriginal);";
        case "ceil":
          return "return ceil(xOriginal);";
        case "round_prefer_floor":
          return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
        case "simple":
        default:
          if (e < 11) return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
          throw new Error(`Nearest mode ${t} is not supported`);
      }
    })() + "}", vN = (t, e, r) => {
      let n = new Array(r).fill(0).concat(new Array(r).fill(1)), i = t.length === 0 ? n : t.slice();
      return e.length > 0 ? (e.forEach((a, o) => {
        n[a] = i[o], n[o + r] = i[e.length + o];
      }), n) : i;
    }, gN = (t, e, r, n) => {
      let i = [];
      if (r.length > 0) if (n.length > 0) {
        if (t.forEach((a) => i.push(a)), Math.max(...n) > t.length) throw new Error("axes is out of bound");
        n.forEach((a, o) => i[a] = r[o]);
      } else r.forEach((a) => i.push(a));
      else {
        if (e.length === 0) throw new Error("Resize requires either scales or sizes.");
        i = t.map((a, o) => Math.round(a * e[o]));
      }
      return i;
    }, mN = (t, e, r) => {
      let n = (() => {
        switch (r.keepAspectRatioPolicy) {
          case "not_larger":
            return r.axes.length > 0 ? Math.min(...r.axes.map((a) => e[a]), Number.MAX_VALUE) : Math.min(...e, Number.MAX_VALUE);
          case "not_smaller":
            return r.axes.length > 0 ? Math.max(...r.axes.map((a) => e[a]), Number.MIN_VALUE) : Math.max(...e, Number.MIN_VALUE);
          default:
            throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`);
        }
      })();
      e.fill(1, 0, e.length);
      let i = t.slice();
      return r.axes.length > 0 ? (r.axes.forEach((a) => e[a] = n), r.axes.forEach((a) => i[a] = Math.round(t[a] * e[a]))) : (e.fill(n, 0, e.length), i.forEach((a, o) => i[o] = Math.round(a * e[o]))), i;
    }, yN = (t, e, r, n, i) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> array<${t.type.value}, ${r.length}> {
      var original_indices: array<${t.type.value}, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${t.indicesGet("output_indices", "i")};
        var scale = ${Ne("uniforms.scales", "i", n)};
        var roi_low = ${Ne("uniforms.roi", "i", i)};
        var roi_hi = ${Ne("uniforms.roi", `i + ${e.length}`, i)};
        if (scale == 1.0) {
          original_indices[i] = ${t.type.value}(output_index);
        } else {
          var input_shape_i = ${Ne("uniforms.input_shape", "i", e.length)};
          var output_shape_i = ${Ne("uniforms.output_shape", "i", r.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`, _N = (t, e, r, n, i, a, o) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
      var input_indices: ${t.type.indices};
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${e.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${Ne("uniforms.scales", "i", i)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Ne("uniforms.roi", "i", a)};
          var roi_hi = ${Ne("uniforms.roi", `i + ${r.length}`, a)};
          var input_shape_i = ${Ne("uniforms.input_shape", "i", r.length)};
          var output_shape_i = ${Ne("uniforms.output_shape", "i", n.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${o} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${t.indicesSet("input_indices", "i", "input_index")}
      }
      return input_indices;
    }`, bN = (t, e) => `
    fn checkInputIndices(input_indices: ${t.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${t.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${Ne("uniforms.input_shape", "i", e.length)}) {
          return false;
        }
      }
      return true;
    }`, t1 = (t, e, r, n) => t.rank > n ? `
    ${t.indicesSet("input_indices", e, "channel")};
    ${t.indicesSet("input_indices", r, "batch")};
` : "", xN = (t, e, r, n, i) => {
      let [a, o, s, l] = r.length === 2 ? [
        -1,
        0,
        1,
        -1
      ] : [
        0,
        2,
        3,
        1
      ], u = t.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices", o, `max(0, min(row, ${r[o]} - 1))`)};
      ${t.indicesSet("input_indices", s, `max(0, min(col, ${r[s]} - 1))`)};
      ${t1(t, l, a, 2)}
      return ${t.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${u} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${u} = originalIndices[${o}];
      var col:${u} = originalIndices[${s}];
      ${n ? `if (row < 0 || row > (${r[o]} - 1) || col < 0 || col > (${r[s]} - 1)) {
        return ${i};
      }` : ""};
      row = max(0, min(row, ${r[o]} - 1));
      col = max(0, min(col, ${r[s]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${r.length > 2 ? `u32(originalIndices[${l}])` : "0"};
      var batch: u32 =  ${r.length > 2 ? `u32(originalIndices[${a}])` : "0"};
      var x11: ${u} = getInputValue(batch, channel, row1, col1);
      var x12: ${u} = getInputValue(batch, channel, row1, col2);
      var x21: ${u} = getInputValue(batch, channel, row2, col1);
      var x22: ${u} = getInputValue(batch, channel, row2, col2);
      var dx1: ${u} = abs(row - ${u}(row1));
      var dx2: ${u} = abs(${u}(row2) - row);
      var dy1: ${u} = abs(col - ${u}(col1));
      var dy2: ${u} = abs(${u}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
    }, wN = (t, e, r, n, i, a, o, s, l, u) => {
      let c = r.length === 2, [h, f] = c ? [
        0,
        1
      ] : [
        2,
        3
      ], d = t.type.value, p = (v) => {
        let g = v === h ? "row" : "col";
        return `
      fn ${g}CubicInterpolation(input_indices: ${t.type.indices}, output_indices: ${e.type.indices}) -> ${d} {
        var output_index = ${e.indicesGet("output_indices", v)};
        var originalIdx: ${d} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[v]},
        ${n[v]}, ${r[v]}, ${a[v]}, ${a[v]} + ${r.length});
        var fractOriginalIdx: ${d} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${s} && (originalIdx < 0 || originalIdx > (${r[v]} - 1))) {
          return ${l};
        }
        var data: array<${d}, 4> = array<${d}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${g}: ${d} = originalIdx + ${d}(i);
          if (${g} < 0 || ${g} >= ${r[v]}) {
            ${u ? `coefs[i + 1] = 0.0;
                        continue;` : s ? `return ${l};` : `${g} = max(0, min(${g}, ${r[v]} - 1));`};
          }
        var input_indices_copy: ${t.type.indices} = input_indices;
          ${t.indicesSet("input_indices_copy", v, `u32(${g})`)};
          data[i + 1] = ${v === h ? t.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
      };
      return `
    ${p(h)};
    ${p(f)};
  fn getCubicInterpolationCoefs(s: ${d}) -> array<${d}, 4> {
    var absS = abs(s);
    var coeffs: array<${d}, 4> = array<${d}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${d} = 1.0 - absS;
    var twoMinusAbsS: ${d} = 2.0 - absS;
    var onePlusAbsS: ${d} = 1.0 + absS;
    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};
    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;
    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${d}, 4>, coefs: array<${d}, 4>) -> ${d} {
    var coefsSum: ${d} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${d} {
    var input_indices: ${t.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
    }, SN = (t, e, r, n, i) => {
      let [a, o, s, l, u] = r.length === 3 ? [
        -1,
        0,
        1,
        2,
        -1
      ] : [
        0,
        2,
        3,
        4,
        1
      ], c = t.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${c} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices", o, `max(0, min(depth, ${r[o]} - 1))`)};
      ${t.indicesSet("input_indices", s, `max(0, min(height, ${r[s]} - 1))`)};
      ${t.indicesSet("input_indices", l, `max(0, min(width, ${r[l]} - 1))`)};
      ${t1(t, u, a, 3)}
      return ${t.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${c} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${c} = originalIndices[${o}];
      var height:${c} = originalIndices[${s}];
      var width:${c} = originalIndices[${l}];
      ${n ? `if (depth < 0 || depth > (${r[o]} - 1) || height < 0 || height > (${r[s]} - 1) || width < 0 || (width > ${r[l]} - 1)) {
      return ${i};
        }` : ""};

    depth = max(0, min(depth, ${r[o]} - 1));
      height = max(0, min(height, ${r[s]} - 1));
      width = max(0, min(width, ${r[l]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${r.length > 3 ? `u32(originalIndices[${u}])` : "0"};
      var batch: u32 =  ${r.length > 3 ? `u32(originalIndices[${a}])` : "0"};

      var x111: ${c} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${c} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${c} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${c} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${c} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${c} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${c} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${c} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${c} = abs(depth - ${c}(depth1));
      var dx2: ${c} = abs(${c}(depth2) - depth);
      var dy1: ${c} = abs(height - ${c}(height1));
      var dy2: ${c} = abs(${c}(height2) - height);
      var dz1: ${c} = abs(width - ${c}(width1));
      var dz2: ${c} = abs(${c}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
    }, TN = (t, e, r, n, i, a) => {
      let o = t.dims, s = vN(a, e.axes, o.length), l = gN(o, n, i, e.axes), u = n.slice();
      n.length === 0 && (u = o.map((y, _) => y === 0 ? 1 : l[_] / y), e.keepAspectRatioPolicy !== "stretch" && (l = mN(o, u, e)));
      let c = Re("output", t.dataType, l.length), h = se("input", t.dataType, o.length), f = re.size(l), d = o.length === l.length && o.every((y, _) => y === l[_]), p = e.coordinateTransformMode === "tf_crop_and_resize", v = e.extrapolationValue, g = h.type.value, m = (y) => `
      ${d ? "" : `
      ${dN(e.coordinateTransformMode, g)};
      ${(() => {
        switch (e.mode) {
          case "nearest":
            return `
              ${bN(h, o)};
              ${pN(e.nearestMode, r, g)};
              ${_N(h, c, o, l, u.length, s.length, p)};
              `;
          case "linear":
            return `
              ${yN(c, o, l, u.length, s.length)};
              ${(() => {
              if (o.length === 2 || o.length === 4) return `${xN(h, c, o, p, v)}`;
              if (o.length === 3 || o.length === 5) return `${SN(h, c, o, p, v)}`;
              throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
            })()};
            `;
          case "cubic":
            return `
            ${(() => {
              if (o.length === 2 || o.length === 4) return `${wN(h, c, o, l, u, s, e.cubicCoeffA, p, e.extrapolationValue, e.excludeOutside)}`;
              throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
            })()};
            `;
          default:
            throw Error("Invalid resize mode");
        }
      })()};
      `}
      ${y.registerUniform("output_size", "u32").registerUniform("scales", "f32", u.length).registerUniform("roi", "f32", s.length).declareVariables(h, c)}
      ${y.mainStart()}
        ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${d ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${c.offsetToIndices("global_idx")};
        var input_indices: ${h.type.indices};
        ${(() => {
        switch (e.mode) {
          case "nearest":
            return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${h.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;
          case "linear":
            return `output[global_idx] = ${o.length === 2 || o.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
          case "cubic":
            return "output[global_idx] = bicubicInterpolation(output_indices);";
          default:
            throw Error(`Unsupported resize mode: ${e.mode}`);
        }
      })()};
`}
      }`;
      return {
        name: "Resize",
        shaderCache: {
          hint: `${e.cacheKey}|${r}|${u.length > 0 ? e.mode === "cubic" ? u : u.length : ""}|${i.length > 0 ? i : ""}|${s.length > 0 ? s : ""}|${d}|${e.mode === "nearest" ? o.length : o}`,
          inputDependencies: [
            "rank"
          ]
        },
        getShaderSource: m,
        getRunData: () => ({
          outputs: [
            {
              dims: l,
              dataType: t.dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(f / 64)
          },
          programUniforms: [
            {
              type: 12,
              data: f
            },
            {
              type: 1,
              data: u
            },
            {
              type: 1,
              data: s
            },
            ...Ve(o, l)
          ]
        })
      };
    }, CN = (t) => {
      let e = t.customDataBuffer;
      return new Uint32Array(e, e.byteOffset, 1)[0];
    }, cY = (t, e) => {
      let r = [], n = [], i = [], a = CN(t);
      if (e.antialias !== 0) throw Error("Only default value (0) for Antialias attribute is supported");
      fN(t.inputs, e, a, r, n, i), t.compute(TN(t.inputs[0], e, a, r, n, i), {
        inputs: [
          0
        ]
      });
    }, hY = (t) => {
      let e = t.antialias, r = t.axes, n = t.coordinateTransformMode, i = t.cubicCoeffA, a = t.excludeOutside !== 0, o = t.extrapolationValue, s = t.keepAspectRatioPolicy, l = t.mode, u = t.nearestMode === "" ? "simple" : t.nearestMode;
      return Bt({
        antialias: e,
        axes: r,
        coordinateTransformMode: n,
        cubicCoeffA: i,
        excludeOutside: a,
        extrapolationValue: o,
        keepAspectRatioPolicy: s,
        mode: l,
        nearestMode: u
      });
    };
  }), AN, IN, fY, d0e = ge(() => {
    Je(), ft(), ur(), mt(), AN = (t, e) => {
      let [r, n, i, a] = t, { numHeads: o, rotaryEmbeddingDim: s } = e;
      if (r.dims.length !== 3 && r.dims.length !== 4) throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);
      if (!re.areEqual(n.dims, []) && !re.areEqual(n.dims, [
        1
      ]) && n.dims.length !== 2) throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);
      if (i.dims.length !== 2) throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${i.dims.length}`);
      if (a.dims.length !== 2) throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);
      if (!re.areEqual(i.dims, a.dims)) throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
      if (s > 0 && o === 0) throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
      let l = r.dims[0], u = r.dims[r.dims.length - 2], c = i.dims[0], h = re.sizeFromDimension(r.dims, 1) / u, f = s === 0 ? i.dims[1] * 2 : h / o;
      if (s > f) throw new Error("rotary_embedding_dim must be less than or equal to head_size");
      if (n.dims.length === 2) {
        if (l !== n.dims[0]) throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);
        if (u !== n.dims[1]) throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`);
      }
      if (f / 2 !== i.dims[1] && s / 2 !== i.dims[1]) throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${i.dims[1]}`);
      if (u > c) throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
    }, IN = (t, e) => {
      let { interleaved: r, numHeads: n, rotaryEmbeddingDim: i, scale: a } = e, o = t[0].dims[0], s = re.sizeFromDimension(t[0].dims, 1), l = t[0].dims[t[0].dims.length - 2], u = s / l, c = t[2].dims[1], h = i === 0 ? c * 2 : u / n, f = new Array(o, l, u / h, h - c), d = re.computeStrides(f), p = [
        {
          type: 1,
          data: a
        },
        {
          type: 12,
          data: f
        },
        {
          type: 12,
          data: d
        },
        ...t[0].dims.length === 3 ? new Array({
          type: 12,
          data: [
            s,
            u,
            h,
            1
          ]
        }) : [],
        ...t[0].dims.length === 4 ? new Array({
          type: 12,
          data: [
            s,
            h,
            l * h,
            1
          ]
        }) : [],
        ...Ve(t[0].dims, t[1].dims, t[2].dims, t[3].dims, t[0].dims)
      ], v = (g) => {
        let m = se("input", t[0].dataType, t[0].dims.length), y = se("position_ids", t[1].dataType, t[1].dims.length), _ = se("cos_cache", t[2].dataType, t[2].dims.length), b = se("sin_cache", t[3].dataType, t[3].dims.length), w = Re("output", t[0].dataType, t[0].dims.length);
        return g.registerUniforms([
          {
            name: "scale",
            type: "f32"
          },
          {
            name: "global_shape",
            type: "u32",
            length: f.length
          },
          {
            name: "global_strides",
            type: "u32",
            length: d.length
          },
          {
            name: "input_output_strides",
            type: "u32",
            length: d.length
          }
        ]), `
        ${g.declareVariables(m, y, _, b, w)}

        ${g.mainStart(Mc)}
          let half_rotary_emb_dim = uniforms.${_.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${g.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${y.broadcastedIndicesToOffset("bsnh.xy", Re("", y.type.tensor, 2))};
            let position_id =
                u32(${y.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});
            let j = i + select(half_rotary_emb_dim, 1, ${r});
            let re = ${m.getByOffset("i")} * ${_.get("position_id", "bsnh[3]")} -
                ${m.getByOffset("j")} * ${b.get("position_id", "bsnh[3]")};
            ${w.setByOffset("i", "re")}
            let im = ${m.getByOffset("i")} * ${b.get("position_id", "bsnh[3]")} +
                ${m.getByOffset("j")} * ${_.get("position_id", "bsnh[3]")};
            ${w.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${w.setByOffset("k", m.getByOffset("k"))}
          }
        }`;
      };
      return {
        name: "RotaryEmbedding",
        shaderCache: {
          hint: Bt({
            interleaved: r
          }).cacheKey,
          inputDependencies: [
            "rank",
            "rank",
            "rank",
            "rank"
          ]
        },
        getShaderSource: v,
        getRunData: () => ({
          outputs: [
            {
              dims: t[0].dims,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(re.size(f) / Mc)
          },
          programUniforms: p
        })
      };
    }, fY = (t, e) => {
      AN(t.inputs, e), t.compute(IN(t.inputs, e));
    };
  }), MN, DN, dY, p0e = ge(() => {
    Je(), ft(), mt(), MN = (t) => {
      if (!t || t.length < 3) throw new Error("layerNorm requires at least 3 inputs.");
      let e = t[0], r = t[1], n = t[2];
      if (e.dataType !== r.dataType || e.dataType !== n.dataType) throw new Error("All inputs must have the same data type");
      if (e.dims.length !== 3 && e.dims.length !== 2) throw new Error("Input must be 2D or 3D");
      if (r.dims.length !== 3 && r.dims.length !== 2) throw new Error("Skip must be 2D or 3D");
      let i = e.dims[e.dims.length - 1], a = e.dims[e.dims.length - 2];
      if (r.dims[r.dims.length - 1] !== i) throw new Error("Skip must have the same hidden size as input");
      if (r.dims[r.dims.length - 2] !== a) throw new Error("Skip must have the same sequence length as input");
      if (n.dims.length !== 1) throw new Error("Gamma must be 1D");
      if (n.dims[n.dims.length - 1] !== i) throw new Error("Gamma must have the same hidden size as input");
      if (t.length > 3) {
        let o = t[3];
        if (o.dims.length !== 1) throw new Error("Beta must be 1D");
        if (o.dims[o.dims.length - 1] !== i) throw new Error("Beta must have the same hidden size as input");
      }
      if (t.length > 4) {
        let o = t[4];
        if (o.dims.length !== 1) throw new Error("Bias must be 1D");
        if (o.dims[o.dims.length - 1] !== i) throw new Error("Bias must have the same hidden size as input");
      }
    }, DN = (t, e, r, n) => {
      let i = e.simplified, a = t[0].dims, o = re.size(a), s = a, l = o, u = a.slice(-1)[0], c = n ? a.slice(0, -1).concat(1) : [], h = !i && t.length > 3, f = t.length > 4, d = n && r > 1, p = n && r > 2, v = r > 3, g = 64, m = or(u), y = [
        {
          type: 12,
          data: l
        },
        {
          type: 12,
          data: m
        },
        {
          type: 12,
          data: u
        },
        {
          type: 1,
          data: e.epsilon
        }
      ], _ = (w) => {
        let x = [
          {
            name: "output_size",
            type: "u32"
          },
          {
            name: "components",
            type: "u32"
          },
          {
            name: "hidden_size",
            type: "u32"
          },
          {
            name: "epsilon",
            type: "f32"
          }
        ], T = [
          se("x", t[0].dataType, t[0].dims, m),
          se("skip", t[1].dataType, t[1].dims, m),
          se("gamma", t[2].dataType, t[2].dims, m)
        ];
        h && T.push(se("beta", t[3].dataType, t[3].dims, m)), f && T.push(se("bias", t[4].dataType, t[4].dims, m)), T.push(Re("output", t[0].dataType, s, m)), d && T.push(Re("mean_output", 1, c)), p && T.push(Re("inv_std_output", 1, c)), v && T.push(Re("input_skip_bias_sum", t[0].dataType, s, m));
        let A = kr(t[0].dataType), I = kr(1, m);
        return `

      ${w.registerUniforms(x).declareVariables(...T)}
      var<workgroup> sum_shared : array<${I}, ${g}>;
      var<workgroup> sum_squared_shared : array<${I}, ${g}>;

      ${w.mainStart([
          g,
          1,
          1
        ])}
        let ix = local_id.x;
        let iy = global_id.x / ${g};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${g};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${g - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${f ? "bias[offset1d + i]" : A + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${v ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${sc(A, m, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${g};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${ys("sum", m)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${ys("square_sum", m)} / f32(uniforms.hidden_size) ${i ? "" : "- mean * mean"} + uniforms.epsilon);
        ${d ? "mean_output[global_idx] = mean;" : ""}
        ${p ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${i ? "" : `- ${A}(mean)`}) *
            ${A}(inv_std_dev) * gamma[offset1d + i]
            ${h ? "+ beta[offset1d + i]" : ""};
        }
      }`;
      }, b = [
        {
          dims: s,
          dataType: t[0].dataType
        }
      ];
      return r > 1 && b.push({
        dims: c,
        dataType: 1
      }), r > 2 && b.push({
        dims: c,
        dataType: 1
      }), r > 3 && b.push({
        dims: a,
        dataType: t[0].dataType
      }), {
        name: "SkipLayerNormalization",
        shaderCache: {
          hint: `${m};${d};${p};${v}`,
          inputDependencies: t.map((w, x) => "type")
        },
        getShaderSource: _,
        getRunData: () => ({
          outputs: b,
          dispatchGroup: {
            x: Math.ceil(l / u)
          },
          programUniforms: y
        })
      };
    }, dY = (t, e) => {
      MN(t.inputs);
      let r = [
        0
      ];
      t.outputCount > 1 && r.push(-3), t.outputCount > 2 && r.push(-3), t.outputCount > 3 && r.push(3), t.compute(DN(t.inputs, e, t.outputCount, false), {
        outputs: r
      });
    };
  }), EN, Fh, kN, r1, PN, LN, pY, vY, v0e = ge(() => {
    Je(), ft(), ur(), mt(), EN = (t, e) => {
      if (!t || t.length < 1) throw new Error("too few inputs");
      if (e.axes.length !== 0) {
        if (e.axes.length !== e.starts.length || e.axes.length !== e.ends.length) throw new Error("axes, starts and ends must have the same length");
      } else if (e.starts.length !== e.ends.length) throw new Error("starts and ends must have the same length");
      t.slice(1).forEach((r, n) => {
        if (t[n + 1].dataType !== 6 && t[n + 1].dataType !== 7) throw new Error(`Input ${n} must be an array of int32 or int64`);
      });
    }, Fh = (t, e) => {
      let r = [];
      if (t.length > e) if (t[e].dataType === 7) t[e].getBigInt64Array().forEach((n) => r.push(Number(n)));
      else if (t[e].dataType === 6) t[e].getInt32Array().forEach((n) => r.push(Number(n)));
      else throw new Error(`Input ${e} must be an array of int32 or int64`);
      return r;
    }, kN = (t, e) => {
      if (t.length > 1) {
        let r = Fh(t, 1), n = Fh(t, 2), i = Fh(t, 3);
        return i.length === 0 && (i = [
          ...Array(t[0].dims.length).keys()
        ]), Bt({
          starts: r,
          ends: n,
          axes: i
        });
      } else return e;
    }, r1 = (t, e, r, n, i) => {
      let a = t;
      return t < 0 && (a += r[n[e]]), i[e] < 0 ? Math.max(0, Math.min(a, r[n[e]] - 1)) : Math.max(0, Math.min(a, r[n[e]]));
    }, PN = (t, e, r) => `fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${t.type.indices} {
          var input_indices: ${t.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            let input_shape_i = ${Ne("uniforms.input_shape", "i", r.length)};
            let steps_i = ${Ne("uniforms.steps", "i", r.length)};
            let signs_i = ${Ne("uniforms.signs", "i", r.length)};
            let starts_i = ${Ne("uniforms.starts", "i", r.length)};
            var output_index = ${e.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${t.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`, LN = (t, e) => {
      let r = t[0].dims, n = re.size(r), i = e.axes.length > 0 ? re.normalizeAxes(e.axes, r.length) : [
        ...Array(r.length).keys()
      ], a = Fh(t, 4);
      a.forEach((m) => m !== 0 || (() => {
        throw new Error("step cannot be 0");
      })), a.length === 0 && (a = Array(i.length).fill(1));
      let o = e.starts.map((m, y) => r1(m, y, r, i, a)), s = e.ends.map((m, y) => r1(m, y, r, i, a));
      if (i.length !== o.length || i.length !== s.length) throw new Error("start, ends and axes should have the same number of elements");
      if (i.length !== r.length) for (let m = 0; m < r.length; ++m) i.includes(m) || (o.splice(m, 0, 0), s.splice(m, 0, r[m]), a.splice(m, 0, 1));
      let l = a.map((m) => Math.sign(m));
      a.forEach((m, y, _) => {
        if (m < 0) {
          let b = (s[y] - o[y]) / m, w = o[y], x = w + b * a[y];
          o[y] = x, s[y] = w, _[y] = -m;
        }
      });
      let u = r.slice(0);
      i.forEach((m, y) => {
        u[m] = Math.ceil((s[m] - o[m]) / a[m]);
      });
      let c = {
        dims: u,
        dataType: t[0].dataType
      }, h = Re("output", t[0].dataType, u.length), f = se("input", t[0].dataType, t[0].dims.length), d = re.size(u), p = [
        {
          name: "outputSize",
          type: "u32"
        },
        {
          name: "starts",
          type: "u32",
          length: o.length
        },
        {
          name: "signs",
          type: "i32",
          length: l.length
        },
        {
          name: "steps",
          type: "u32",
          length: a.length
        }
      ], v = [
        {
          type: 12,
          data: d
        },
        {
          type: 12,
          data: o
        },
        {
          type: 6,
          data: l
        },
        {
          type: 12,
          data: a
        },
        ...Ve(t[0].dims, u)
      ], g = (m) => `
      ${m.registerUniforms(p).declareVariables(f, h)}
        ${PN(f, h, r)}
        ${m.mainStart()}
          ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${h.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${h.setByOffset("global_idx", f.getByIndices("input_indices"))}
      }`;
      return {
        name: "Slice",
        shaderCache: {
          hint: `${l.length}_${o.length}_${a.length}`,
          inputDependencies: [
            "rank"
          ]
        },
        getShaderSource: g,
        getRunData: () => ({
          outputs: [
            c
          ],
          dispatchGroup: {
            x: Math.ceil(n / 64)
          },
          programUniforms: v
        })
      };
    }, pY = (t, e) => {
      EN(t.inputs, e);
      let r = kN(t.inputs, e);
      t.compute(LN(t.inputs, r), {
        inputs: [
          0
        ]
      });
    }, vY = (t) => {
      let e = t.starts, r = t.ends, n = t.axes;
      return Bt({
        starts: e,
        ends: r,
        axes: n
      });
    };
  }), $N, RN, gY, mY, g0e = ge(() => {
    Je(), ft(), ur(), ws(), mt(), $N = (t) => {
      if (!t || t.length !== 1) throw new Error("Softmax op requires 1 input.");
    }, RN = (t, e) => {
      let r = t.inputs[0], n = r.dims, i = re.size(n), a = n.length, o = re.normalizeAxis(e.axis, a), s = o < n.length - 1, l, u = [];
      s ? (u = Array.from({
        length: a
      }, (T, A) => A), u[o] = a - 1, u[a - 1] = o, l = t.compute(qn(r, u), {
        inputs: [
          r
        ],
        outputs: [
          -1
        ]
      })[0]) : l = r;
      let c = l.dims, h = c[a - 1], f = i / h, d = or(h), p = h / d, v = 64;
      f === 1 && (v = 256);
      let g = (T, A) => A === 4 ? `max(max(${T}.x, ${T}.y), max(${T}.z, ${T}.w))` : A === 2 ? `max(${T}.x, ${T}.y)` : A === 3 ? `max(max(${T}.x, ${T}.y), ${T}.z)` : T, m = se("x", l.dataType, l.dims, d), y = Re("result", l.dataType, l.dims, d), _ = m.type.value, b = kr(l.dataType) === "f32" ? `var threadMax = ${_}(-3.402823e+38f);` : `var threadMax = ${_}(-65504.0h);`, w = (T) => `
      var<workgroup> rowMaxShared : ${_};
      var<workgroup> rowSumShared : ${_};
      var<workgroup> threadShared : array<${_}, ${v}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${T.registerUniform("packedCols", "i32").declareVariables(m, y)}
      ${T.mainStart(v)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${v};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${b}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${_}(${g("threadShared[0]", d)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${_}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${_}(${ys("threadShared[0]", d)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`, x = t.compute({
        name: "Softmax",
        shaderCache: {
          hint: `${d};${v}`,
          inputDependencies: [
            "type"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: c,
              dataType: l.dataType
            }
          ],
          dispatchGroup: {
            x: f
          },
          programUniforms: [
            {
              type: 6,
              data: p
            }
          ]
        }),
        getShaderSource: w
      }, {
        inputs: [
          l
        ],
        outputs: [
          s ? -1 : 0
        ]
      })[0];
      s && t.compute(qn(x, u), {
        inputs: [
          x
        ]
      });
    }, gY = (t, e) => {
      $N(t.inputs), RN(t, e);
    }, mY = (t) => Bt({
      axis: t.axis
    });
  }), n1, ON, NN, BN, yY, m0e = ge(() => {
    Je(), ft(), mt(), n1 = (t) => Array.from(t.getBigInt64Array(), Number), ON = (t) => {
      if (!t || t.length !== 2) throw new Error("Tile requires 2 inputs.");
      if (t[0].dataType !== 1 && t[0].dataType !== 10 && t[0].dataType !== 6 && t[0].dataType !== 12) throw new Error("Tile only support float, float16, int32, and uint32 data types");
      if (t[1].dataType !== 7) throw new Error("Tile `repeats` input should be of int64 data type");
      if (t[1].dims.length !== 1) throw new Error("Tile `repeats` input should be 1-D");
      if (n1(t[1]).length !== t[0].dims.length) throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
    }, NN = (t, e) => {
      let r = [];
      for (let n = 0; n < t.length; ++n) r.push(t[n] * e[n]);
      return r;
    }, BN = (t, e) => {
      let r = t[0].dims, n = e ?? n1(t[1]), i = NN(r, n), a = re.size(i), o = t[0].dataType, s = se("input", o, r.length), l = Re("output", o, i.length), u = (c) => `
      const inputShape = ${s.indices(...r)};
      ${c.registerUniform("output_size", "u32").declareVariables(s, l)}
      ${c.mainStart()}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${l.offsetToIndices("global_idx")};
      var input_indices: ${s.type.indices};
      for (var i = 0; i < ${r.length}; i++) {
        let input_dim_i = ${s.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${l.indicesGet("output_indices", "i")}  % input_dim_i;

        ${s.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${l.setByOffset("global_idx", s.getByIndices("input_indices"))}
    }`;
      return {
        name: "Tile",
        shaderCache: {
          hint: `${n}`,
          inputDependencies: [
            "rank"
          ]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: i,
              dataType: t[0].dataType
            }
          ],
          dispatchGroup: {
            x: Math.ceil(a / 64)
          },
          programUniforms: [
            {
              type: 12,
              data: a
            },
            ...Ve(t[0].dims, i)
          ]
        }),
        getShaderSource: u
      };
    }, yY = (t) => {
      ON(t.inputs), t.compute(BN(t.inputs), {
        inputs: [
          0
        ]
      });
    };
  }), zN, FN, _Y, y0e = ge(() => {
    Je(), ft(), mt(), zN = (t, e, r, n, i) => {
      let a = Re("output_data", i, r.length, 4), o = se("a_data", e[1].dataType, e[1].dims.length, 4), s = se("b_data", e[2].dataType, e[2].dims.length, 4), l = se("c_data", e[0].dataType, e[0].dims.length, 4), u, c = (h, f, d) => `select(${f}, ${h}, ${d})`;
      if (!n) u = a.setByOffset("global_idx", c(o.getByOffset("global_idx"), s.getByOffset("global_idx"), l.getByOffset("global_idx")));
      else {
        let h = (f, d, p = "") => {
          let v = `a_data[index_a${d}][component_a${d}]`, g = `b_data[index_b${d}][component_b${d}]`, m = `bool(c_data[index_c${d}] & (0xffu << (component_c${d} * 8)))`;
          return `
            let output_indices${d} = ${a.offsetToIndices(`global_idx * 4u + ${d}u`)};
            let offset_a${d} = ${o.broadcastedIndicesToOffset(`output_indices${d}`, a)};
            let offset_b${d} = ${s.broadcastedIndicesToOffset(`output_indices${d}`, a)};
            let offset_c${d} = ${l.broadcastedIndicesToOffset(`output_indices${d}`, a)};
            let index_a${d} = offset_a${d} / 4u;
            let index_b${d} = offset_b${d} / 4u;
            let index_c${d} = offset_c${d} / 4u;
            let component_a${d} = offset_a${d} % 4u;
            let component_b${d} = offset_b${d} % 4u;
            let component_c${d} = offset_c${d} % 4u;
            ${f}[${d}] = ${p}(${c(v, g, m)});
          `;
        };
        i === 9 ? u = `
            var data = vec4<u32>(0);
            ${h("data", 0, "u32")}
            ${h("data", 1, "u32")}
            ${h("data", 2, "u32")}
            ${h("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));` : u = `
            ${h("output_data[global_idx]", 0)}
            ${h("output_data[global_idx]", 1)}
            ${h("output_data[global_idx]", 2)}
            ${h("output_data[global_idx]", 3)}
          `;
      }
      return `
        ${t.registerUniform("vec_size", "u32").declareVariables(l, o, s, a)}
        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${u}
      }`;
    }, FN = (t) => {
      let e = t[1].dims, r = t[2].dims, n = t[0].dims, i = t[1].dataType, a = !(re.areEqual(e, r) && re.areEqual(r, n)), o = e, s = re.size(e);
      if (a) {
        let u = Ic.calcShape(Ic.calcShape(e, r, false), n, false);
        if (!u) throw new Error("Can't perform where op on the given tensors");
        o = u, s = re.size(o);
      }
      let l = Math.ceil(s / 4);
      return {
        name: "Where",
        shaderCache: {
          inputDependencies: [
            "rank",
            "rank",
            "rank"
          ]
        },
        getShaderSource: (u) => zN(u, t, o, a, i),
        getRunData: () => ({
          outputs: [
            {
              dims: o,
              dataType: i
            }
          ],
          dispatchGroup: {
            x: Math.ceil(s / 64 / 4)
          },
          programUniforms: [
            {
              type: 12,
              data: l
            },
            ...Ve(n, e, r, o)
          ]
        })
      };
    }, _Y = (t) => {
      t.compute(FN(t.inputs));
    };
  }), bY, _0e = ge(() => {
    Pye(), dC(), Lye(), $ye(), Rye(), Oye(), Nye(), Gye(), Hye(), Uye(), Yye(), qye(), Xye(), jye(), Kye(), Zye(), Qye(), Jye(), e0e(), t0e(), r0e(), n0e(), i0e(), a0e(), o0e(), F8(), s0e(), l0e(), u0e(), c0e(), h0e(), fC(), f0e(), d0e(), p0e(), v0e(), g0e(), W8(), m0e(), ws(), pC(), y0e(), bY = /* @__PURE__ */ new Map([
      [
        "Abs",
        [
          p6
        ]
      ],
      [
        "Acos",
        [
          v6
        ]
      ],
      [
        "Acosh",
        [
          g6
        ]
      ],
      [
        "Add",
        [
          K6
        ]
      ],
      [
        "ArgMax",
        [
          c6,
          qw
        ]
      ],
      [
        "ArgMin",
        [
          u6,
          qw
        ]
      ],
      [
        "Asin",
        [
          m6
        ]
      ],
      [
        "Asinh",
        [
          y6
        ]
      ],
      [
        "Atan",
        [
          _6
        ]
      ],
      [
        "Atanh",
        [
          b6
        ]
      ],
      [
        "Attention",
        [
          h6
        ]
      ],
      [
        "AveragePool",
        [
          Q8,
          Z8
        ]
      ],
      [
        "BatchNormalization",
        [
          f6
        ]
      ],
      [
        "BiasAdd",
        [
          d6
        ]
      ],
      [
        "BiasSplitGelu",
        [
          j6
        ]
      ],
      [
        "Cast",
        [
          w6,
          x6
        ]
      ],
      [
        "Ceil",
        [
          T6
        ]
      ],
      [
        "Clip",
        [
          S6
        ]
      ],
      [
        "Concat",
        [
          o8,
          s8
        ]
      ],
      [
        "Conv",
        [
          Jw,
          Qw
        ]
      ],
      [
        "ConvTranspose",
        [
          m8,
          g8
        ]
      ],
      [
        "Cos",
        [
          C6
        ]
      ],
      [
        "Cosh",
        [
          A6
        ]
      ],
      [
        "CumSum",
        [
          y8,
          _8
        ]
      ],
      [
        "DepthToSpace",
        [
          b8,
          x8
        ]
      ],
      [
        "DequantizeLinear",
        [
          aY,
          oY
        ]
      ],
      [
        "Div",
        [
          Z6
        ]
      ],
      [
        "Einsum",
        [
          w8,
          S8
        ]
      ],
      [
        "Elu",
        [
          I6,
          hf
        ]
      ],
      [
        "Equal",
        [
          Q6
        ]
      ],
      [
        "Erf",
        [
          M6
        ]
      ],
      [
        "Exp",
        [
          D6
        ]
      ],
      [
        "Expand",
        [
          T8
        ]
      ],
      [
        "FastGelu",
        [
          C8
        ]
      ],
      [
        "Floor",
        [
          E6
        ]
      ],
      [
        "FusedConv",
        [
          Jw,
          Qw
        ]
      ],
      [
        "Gather",
        [
          I8,
          A8
        ]
      ],
      [
        "GatherElements",
        [
          L8,
          P8
        ]
      ],
      [
        "GatherBlockQuantized",
        [
          E8,
          k8
        ]
      ],
      [
        "GatherND",
        [
          M8,
          D8
        ]
      ],
      [
        "Gelu",
        [
          k6
        ]
      ],
      [
        "Gemm",
        [
          R8,
          $8
        ]
      ],
      [
        "GlobalAveragePool",
        [
          eY,
          J8
        ]
      ],
      [
        "GlobalMaxPool",
        [
          iY,
          nY
        ]
      ],
      [
        "Greater",
        [
          r8
        ]
      ],
      [
        "GreaterOrEqual",
        [
          i8
        ]
      ],
      [
        "GridSample",
        [
          O8,
          N8
        ]
      ],
      [
        "GroupQueryAttention",
        [
          H8
        ]
      ],
      [
        "HardSigmoid",
        [
          z6,
          B6
        ]
      ],
      [
        "InstanceNormalization",
        [
          U8
        ]
      ],
      [
        "LayerNormalization",
        [
          Y8
        ]
      ],
      [
        "LeakyRelu",
        [
          P6,
          hf
        ]
      ],
      [
        "Less",
        [
          n8
        ]
      ],
      [
        "LessOrEqual",
        [
          a8
        ]
      ],
      [
        "Log",
        [
          q6
        ]
      ],
      [
        "MatMul",
        [
          q8
        ]
      ],
      [
        "MatMulNBits",
        [
          X8,
          j8
        ]
      ],
      [
        "MaxPool",
        [
          tY,
          rY
        ]
      ],
      [
        "Mul",
        [
          J6
        ]
      ],
      [
        "MultiHeadAttention",
        [
          z8,
          B8
        ]
      ],
      [
        "Neg",
        [
          $6
        ]
      ],
      [
        "Not",
        [
          L6
        ]
      ],
      [
        "Pad",
        [
          K8
        ]
      ],
      [
        "Pow",
        [
          e8
        ]
      ],
      [
        "QuickGelu",
        [
          X6,
          hf
        ]
      ],
      [
        "Range",
        [
          sY
        ]
      ],
      [
        "Reciprocal",
        [
          R6
        ]
      ],
      [
        "ReduceMin",
        [
          i6
        ]
      ],
      [
        "ReduceMean",
        [
          JU
        ]
      ],
      [
        "ReduceMax",
        [
          n6
        ]
      ],
      [
        "ReduceSum",
        [
          o6
        ]
      ],
      [
        "ReduceProd",
        [
          a6
        ]
      ],
      [
        "ReduceL1",
        [
          e6
        ]
      ],
      [
        "ReduceL2",
        [
          t6
        ]
      ],
      [
        "ReduceLogSum",
        [
          l6
        ]
      ],
      [
        "ReduceLogSumExp",
        [
          r6
        ]
      ],
      [
        "ReduceSumSquare",
        [
          s6
        ]
      ],
      [
        "Relu",
        [
          O6
        ]
      ],
      [
        "Resize",
        [
          cY,
          hY
        ]
      ],
      [
        "RotaryEmbedding",
        [
          fY
        ]
      ],
      [
        "ScatterND",
        [
          uY,
          lY
        ]
      ],
      [
        "Sigmoid",
        [
          N6
        ]
      ],
      [
        "Sin",
        [
          F6
        ]
      ],
      [
        "Sinh",
        [
          V6
        ]
      ],
      [
        "Slice",
        [
          pY,
          vY
        ]
      ],
      [
        "SkipLayerNormalization",
        [
          dY
        ]
      ],
      [
        "Split",
        [
          V8,
          G8
        ]
      ],
      [
        "Sqrt",
        [
          G6
        ]
      ],
      [
        "Softmax",
        [
          gY,
          mY
        ]
      ],
      [
        "Sub",
        [
          t8
        ]
      ],
      [
        "Tan",
        [
          W6
        ]
      ],
      [
        "Tanh",
        [
          H6
        ]
      ],
      [
        "ThresholdedRelu",
        [
          Y6,
          hf
        ]
      ],
      [
        "Tile",
        [
          yY
        ]
      ],
      [
        "Transpose",
        [
          VU,
          GU
        ]
      ],
      [
        "Where",
        [
          _Y
        ]
      ]
    ]);
  }), xY, b0e = ge(() => {
    ea(), To(), mt(), xY = class {
      constructor(t) {
        this.backend = t, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
      }
      getArtifact(t) {
        return this.repo.get(t);
      }
      setArtifact(t, e) {
        this.repo.set(t, e);
      }
      run(t, e, r, n, i) {
        Oa(t.programInfo.name);
        let a = this.backend.device, o = this.backend.getComputePassEncoder();
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
        let s = [];
        for (let u of e) s.push({
          binding: s.length,
          resource: {
            buffer: u.buffer
          }
        });
        for (let u of r) s.push({
          binding: s.length,
          resource: {
            buffer: u.buffer
          }
        });
        i && s.push({
          binding: s.length,
          resource: i
        });
        let l = a.createBindGroup({
          layout: t.computePipeline.getBindGroupLayout(0),
          entries: s,
          label: t.programInfo.name
        });
        if (this.backend.sessionStatus === "capturing") {
          let u = {
            kernelId: this.backend.currentKernelId,
            computePipeline: t.computePipeline,
            bindGroup: l,
            dispatchGroup: n
          };
          this.backend.capturedCommandList.get(this.backend.currentSessionId).push(u);
        }
        o.setPipeline(t.computePipeline), o.setBindGroup(0, l), o.dispatchWorkgroups(...n), this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1), this.backend.pendingDispatchNumber++, (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") && this.backend.endComputePass(), this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber && this.backend.flush(), qi(t.programInfo.name);
      }
      dispose() {
      }
      build(t, e) {
        Oa(t.name);
        let r = this.backend.device, n = [];
        [
          {
            feature: "shader-f16",
            extension: "f16"
          },
          {
            feature: "subgroups",
            extension: "subgroups"
          },
          {
            feature: "subgroups-f16",
            extension: "subgroups_f16"
          }
        ].forEach((u) => {
          r.features.has(u.feature) && n.push(`enable ${u.extension};`);
        });
        let i = FU(e, this.backend.device.limits), a = t.getShaderSource(i), o = `${n.join(`
`)}
${i.additionalImplementations}
${a}`, s = r.createShaderModule({
          code: o,
          label: t.name
        });
        Mt("verbose", () => `[WebGPU] ${t.name} shader code: ${o}`);
        let l = r.createComputePipeline({
          compute: {
            module: s,
            entryPoint: "main"
          },
          layout: "auto",
          label: t.name
        });
        return qi(t.name), {
          programInfo: t,
          computePipeline: l,
          uniformVariablesInfo: i.variablesInfo
        };
      }
      normalizeDispatchGroupSize(t) {
        let e = typeof t == "number" ? t : t.x, r = typeof t == "number" ? 1 : t.y || 1, n = typeof t == "number" ? 1 : t.z || 1, i = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
        if (e <= i && r <= i && n <= i) return [
          e,
          r,
          n
        ];
        let a = e * r * n, o = Math.ceil(Math.sqrt(a));
        if (o > i) {
          if (o = Math.ceil(Math.cbrt(a)), o > i) throw new Error("Total dispatch size exceeds WebGPU maximum.");
          return [
            o,
            o,
            o
          ];
        } else return [
          o,
          o,
          1
        ];
      }
    };
  }), VN, GN, WN, HN, wY, x0e = ge(() => {
    ea(), Je(), To(), $U(), Eye(), _0e(), b0e(), VN = (t, e) => {
      if (e.length !== t.length) throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${t.length}.`);
      let r = [];
      for (let n = 0; n < t.length; ++n) {
        let i = t[n].dataType;
        switch (e[n]) {
          case "none": {
            r.push("");
            break;
          }
          case "type": {
            r.push(`${i}`);
            break;
          }
          case "rank": {
            let a = t[n].dims.length;
            r.push(`${i};${a}`);
            break;
          }
          case "dims": {
            let a = t[n].dims.join(",");
            r.push(`${i};${a}`);
            break;
          }
          default:
            throw new Error(`unsupported input dependency: ${e[n]}`);
        }
      }
      return r.join("|");
    }, GN = (t, e, r) => {
      var _a2, _b2;
      let n = t.name;
      return ((_a2 = t.shaderCache) == null ? void 0 : _a2.hint) && (n += "[" + t.shaderCache.hint + "]"), n += ":" + r + `:${VN(e, ((_b2 = t.shaderCache) == null ? void 0 : _b2.inputDependencies) ?? new Array(e.length).fill("dims"))}`, n;
    }, WN = class {
      constructor(t) {
        t && (this.architecture = t.architecture, this.vendor = t.vendor);
      }
      isArchitecture(t) {
        return this.architecture === t;
      }
      isVendor(t) {
        return this.vendor === t;
      }
    }, HN = class {
      constructor(t) {
        this.subgroupsSupported = t.features.has("subgroups"), this.subgroupsF16Supported = t.features.has("subgroups");
        let e = t.limits;
        !this.subgroupsSupported || !e.minSubgroupSize || !e.maxSubgroupSize ? this.subgroupSizeRange = void 0 : this.subgroupSizeRange = [
          e.minSubgroupSize,
          e.maxSubgroupSize
        ];
      }
    }, wY = class {
      constructor() {
        this.currentSessionId = null, this.currentKernelId = null, this.commandEncoder = null, this.computePassEncoder = null, this.maxDispatchNumber = 16, this.pendingDispatchNumber = 0, this.pendingKernels = [], this.pendingQueries = /* @__PURE__ */ new Map(), this.sessionStatus = "default", this.capturedCommandList = /* @__PURE__ */ new Map(), this.capturedPendingKernels = /* @__PURE__ */ new Map(), this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
      }
      get currentKernelCustomData() {
        if (this.currentKernelId === null) throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
        let t = this.kernelCustomData.get(this.currentKernelId);
        return t || (t = {}, this.kernelCustomData.set(this.currentKernelId, t)), t;
      }
      async initialize(t, e) {
        this.env = t;
        let r = [], n = {
          requiredLimits: {
            maxComputeWorkgroupStorageSize: e.limits.maxComputeWorkgroupStorageSize,
            maxComputeWorkgroupsPerDimension: e.limits.maxComputeWorkgroupsPerDimension,
            maxStorageBufferBindingSize: e.limits.maxStorageBufferBindingSize,
            maxBufferSize: e.limits.maxBufferSize,
            maxComputeInvocationsPerWorkgroup: e.limits.maxComputeInvocationsPerWorkgroup,
            maxComputeWorkgroupSizeX: e.limits.maxComputeWorkgroupSizeX,
            maxComputeWorkgroupSizeY: e.limits.maxComputeWorkgroupSizeY,
            maxComputeWorkgroupSizeZ: e.limits.maxComputeWorkgroupSizeZ
          },
          requiredFeatures: r
        }, i = (a) => e.features.has(a) && r.push(a) && true;
        i("chromium-experimental-timestamp-query-inside-passes") || i("timestamp-query"), i("shader-f16"), i("subgroups") && i("subgroups-f16"), this.device = await e.requestDevice(n), this.deviceInfo = new HN(this.device), this.adapterInfo = new WN(e.info || await e.requestAdapterInfo()), this.gpuDataManager = RU(this), this.programManager = new xY(this), this.kernels = /* @__PURE__ */ new Map(), this.kernelPersistentData = /* @__PURE__ */ new Map(), this.kernelCustomData = /* @__PURE__ */ new Map(), lC(t.logLevel, !!t.debug), this.device.onuncapturederror = (a) => {
          a.error instanceof GPUValidationError && console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`);
        }, Object.defineProperty(this.env.webgpu, "device", {
          value: this.device,
          writable: false,
          enumerable: true,
          configurable: false
        }), Object.defineProperty(this.env.webgpu, "adapter", {
          value: e,
          writable: false,
          enumerable: true,
          configurable: false
        }), this.setQueryType();
      }
      dispose() {
        typeof this.querySet < "u" && this.querySet.destroy(), this.gpuDataManager.dispose();
      }
      getCommandEncoder() {
        return this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder()), this.commandEncoder;
      }
      getComputePassEncoder() {
        if (!this.computePassEncoder) {
          let t = this.getCommandEncoder(), e = {};
          this.queryType === "at-passes" && (e.timestampWrites = {
            querySet: this.querySet,
            beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
            endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
          }), this.computePassEncoder = t.beginComputePass(e);
        }
        return this.computePassEncoder;
      }
      endComputePass() {
        this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);
      }
      flush() {
        if (!this.commandEncoder) return;
        Oa(), this.endComputePass();
        let t;
        this.queryType !== "none" && (this.commandEncoder.resolveQuerySet(this.querySet, 0, this.pendingDispatchNumber * 2, this.queryResolveBuffer, 0), t = this.device.createBuffer({
          size: this.pendingDispatchNumber * 2 * 8,
          usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
        }), this.pendingQueries.set(t, this.pendingKernels), this.pendingKernels = [], this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, t, 0, this.pendingDispatchNumber * 2 * 8)), this.device.queue.submit([
          this.commandEncoder.finish()
        ]), this.gpuDataManager.refreshPendingBuffers(), this.commandEncoder = null, this.pendingDispatchNumber = 0, this.queryType !== "none" && t.mapAsync(GPUMapMode.READ).then(() => {
          var _a2;
          let e = new BigUint64Array(t.getMappedRange()), r = this.pendingQueries.get(t);
          for (let n = 0; n < e.length / 2; n++) {
            let i = r[n], a = i.kernelId, o = this.kernels.get(a), s = o.kernelType, l = o.kernelName, u = i.programName, c = i.inputTensorViews, h = i.outputTensorViews, f = e[n * 2], d = e[n * 2 + 1];
            typeof this.queryTimeBase > "u" && (this.queryTimeBase = f);
            let p = Number(f - this.queryTimeBase), v = Number(d - this.queryTimeBase);
            if (!Number.isSafeInteger(p) || !Number.isSafeInteger(v)) throw new RangeError("incorrect timestamp range");
            if ((_a2 = this.env.webgpu.profiling) == null ? void 0 : _a2.ondata) this.env.webgpu.profiling.ondata({
              version: 1,
              inputsMetadata: c.map((g) => ({
                dims: g.dims,
                dataType: bl(g.dataType)
              })),
              outputsMetadata: h.map((g) => ({
                dims: g.dims,
                dataType: bl(g.dataType)
              })),
              kernelId: a,
              kernelType: s,
              kernelName: l,
              programName: u,
              startTime: p,
              endTime: v
            });
            else {
              let g = "";
              c.forEach((y, _) => {
                g += `input[${_}]: [${y.dims}] | ${bl(y.dataType)}, `;
              });
              let m = "";
              h.forEach((y, _) => {
                m += `output[${_}]: [${y.dims}] | ${bl(y.dataType)}, `;
              }), console.log(`[profiling] kernel "${a}|${s}|${l}|${u}" ${g}${m}execution time: ${v - p} ns`);
            }
            gm("GPU", `${u}::${f}::${d}`);
          }
          t.unmap(), this.pendingQueries.delete(t);
        }), qi();
      }
      run(t, e, r, n, i, a) {
        Oa(t.name);
        let o = [];
        for (let y = 0; y < e.length; ++y) {
          let _ = e[y].data;
          if (_ === 0) continue;
          let b = this.gpuDataManager.get(_);
          if (!b) throw new Error(`no GPU data for input: ${_}`);
          o.push(b);
        }
        let { outputs: s, dispatchGroup: l, programUniforms: u } = t.getRunData(e), c = r.length === 0 ? s.map((y, _) => _) : r;
        if (c.length !== s.length) throw new Error(`Output size ${c.length} must be equal to ${s.length}.`);
        let h = [], f = [];
        for (let y = 0; y < s.length; ++y) {
          if (!Number.isInteger(c[y]) || c[y] < -3 || c[y] >= a) throw new Error(`Invalid output index: ${c[y]}`);
          if (c[y] === -3) continue;
          let _ = c[y] === -1, b = c[y] === -2, w = _ || b ? i(s[y].dataType, s[y].dims) : n(c[y], s[y].dataType, s[y].dims);
          if (h.push(w), w.data === 0) continue;
          let x = this.gpuDataManager.get(w.data);
          if (!x) throw new Error(`no GPU data for output: ${w.data}`);
          if (_ && this.temporaryData.push(x), b) {
            let T = this.kernelPersistentData.get(this.currentKernelId);
            T || (T = [], this.kernelPersistentData.set(this.currentKernelId, T)), T.push(x);
          }
          f.push(x);
        }
        if (o.length !== e.length || f.length !== h.length) {
          if (f.length === 0) return qi(t.name), h;
          throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`);
        }
        let d;
        if (u) {
          let y = 0, _ = [];
          u.forEach((T) => {
            let A = typeof T.data == "number" ? [
              T.data
            ] : T.data;
            if (A.length === 0) return;
            let I = T.type === 10 ? 2 : 4, M, k;
            T.type === 10 ? (k = A.length > 4 ? 16 : A.length > 2 ? 8 : A.length * I, M = A.length > 4 ? 16 : I * A.length) : (k = A.length <= 2 ? A.length * I : 16, M = 16), y = Math.ceil(y / k) * k, _.push(y);
            let B = T.type === 10 ? 8 : 4;
            y += A.length > 4 ? Math.ceil(A.length / B) * M : A.length * I;
          });
          let b = 16;
          y = Math.ceil(y / b) * b;
          let w = new ArrayBuffer(y);
          u.forEach((T, A) => {
            let I = _[A], M = typeof T.data == "number" ? [
              T.data
            ] : T.data;
            if (T.type === 6) new Int32Array(w, I, M.length).set(M);
            else if (T.type === 12) new Uint32Array(w, I, M.length).set(M);
            else if (T.type === 10) new Uint16Array(w, I, M.length).set(M);
            else if (T.type === 1) new Float32Array(w, I, M.length).set(M);
            else throw new Error(`Unsupported uniform type: ${bl(T.type)}`);
          });
          let x = this.gpuDataManager.create(y, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
          this.device.queue.writeBuffer(x.buffer, 0, w, 0, y), this.gpuDataManager.release(x.id), d = {
            offset: 0,
            size: y,
            buffer: x.buffer
          };
        }
        let p = this.programManager.normalizeDispatchGroupSize(l), v = p[1] === 1 && p[2] === 1, g = GN(t, e, v), m = this.programManager.getArtifact(g);
        if (m || (m = this.programManager.build(t, p), this.programManager.setArtifact(g, m), Mt("info", () => `[artifact] key: ${g}, programName: ${t.name}`)), u && m.uniformVariablesInfo) {
          if (u.length !== m.uniformVariablesInfo.length) throw new Error(`Uniform variables count mismatch: expect ${m.uniformVariablesInfo.length}, got ${u.length} in program "${m.programInfo.name}".`);
          for (let y = 0; y < u.length; y++) {
            let _ = u[y], b = _.type, w = typeof _.data == "number" ? 1 : _.data.length, [x, T] = m.uniformVariablesInfo[y];
            if (b !== x || w !== T) throw new Error(`Uniform variable ${y} mismatch: expect type ${x} with size ${T}, got type ${b} with size ${w} in program "${m.programInfo.name}".`);
          }
        }
        if (Mt("info", () => `[ProgramManager] run "${t.name}" (key=${g}) with ${p[0]}x${p[1]}x${p[2]}`), this.queryType !== "none" || this.sessionStatus === "capturing") {
          let y = {
            kernelId: this.currentKernelId,
            programName: m.programInfo.name,
            inputTensorViews: e,
            outputTensorViews: h
          };
          this.pendingKernels.push(y), this.sessionStatus === "capturing" && this.capturedPendingKernels.get(this.currentSessionId).push(y);
        }
        return this.programManager.run(m, o, f, p, d), qi(t.name), h;
      }
      upload(t, e) {
        this.gpuDataManager.upload(t, e);
      }
      memcpy(t, e) {
        this.gpuDataManager.memcpy(t, e);
      }
      async download(t, e) {
        await this.gpuDataManager.download(t, e);
      }
      alloc(t) {
        return this.gpuDataManager.create(t).id;
      }
      free(t) {
        return this.gpuDataManager.release(t);
      }
      createKernel(t, e, r, n) {
        let i = bY.get(t);
        if (!i) throw new Error(`kernel not implemented: ${t}`);
        let a = {
          kernelType: t,
          kernelName: n,
          kernelEntry: i[0],
          attributes: [
            i[1],
            r
          ]
        };
        this.kernels.set(e, a);
      }
      releaseKernel(t) {
        let e = this.kernelPersistentData.get(t);
        if (e) {
          for (let r of e) this.gpuDataManager.release(r.id);
          this.kernelPersistentData.delete(t);
        }
        this.kernelCustomData.delete(t), this.kernels.delete(t);
      }
      computeKernel(t, e, r) {
        let n = this.kernels.get(t);
        if (!n) throw new Error(`kernel not created: ${t}`);
        let i = n.kernelType, a = n.kernelName, o = n.kernelEntry, s = n.attributes;
        if (this.currentKernelId !== null) throw new Error(`kernel "[${i}] ${a}" is not allowed to be called recursively`);
        this.currentKernelId = t, s[0] && (s[1] = s[0](s[1]), s[0] = void 0), Mt("info", () => `[WebGPU] Start to run kernel "[${i}] ${a}"...`);
        let l = this.env.debug;
        this.temporaryData = [];
        try {
          return l && this.device.pushErrorScope("validation"), o(e, s[1]), 0;
        } catch (u) {
          return r.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${a}" failed. ${u}`)), 1;
        } finally {
          l && r.push(this.device.popErrorScope().then((u) => u ? `GPU validation error for kernel "[${i}] ${a}": ${u.message}` : null));
          for (let u of this.temporaryData) this.gpuDataManager.release(u.id);
          this.temporaryData = [], this.currentKernelId = null;
        }
      }
      registerBuffer(t, e, r, n) {
        let i = this.sessionExternalDataMapping.get(t);
        i || (i = /* @__PURE__ */ new Map(), this.sessionExternalDataMapping.set(t, i));
        let a = i.get(e), o = this.gpuDataManager.registerExternalBuffer(r, n, a);
        return i.set(e, [
          o,
          r
        ]), o;
      }
      unregisterBuffers(t) {
        let e = this.sessionExternalDataMapping.get(t);
        e && (e.forEach((r) => this.gpuDataManager.unregisterExternalBuffer(r[0])), this.sessionExternalDataMapping.delete(t));
      }
      getBuffer(t) {
        let e = this.gpuDataManager.get(t);
        if (!e) throw new Error(`no GPU data for buffer: ${t}`);
        return e.buffer;
      }
      createDownloader(t, e, r) {
        return async () => {
          let n = await Hw(this, t, e);
          return uC(n.buffer, r);
        };
      }
      writeTimestamp(t) {
        this.queryType === "inside-passes" && this.computePassEncoder.writeTimestamp(this.querySet, t);
      }
      setQueryType() {
        var _a2;
        this.queryType = "none", (((_a2 = this.env.webgpu.profiling) == null ? void 0 : _a2.mode) === "default" || (typeof this.env.trace > "u" ? this.env.wasm.trace : this.env.trace)) && (this.device.features.has("chromium-experimental-timestamp-query-inside-passes") ? this.queryType = "inside-passes" : this.device.features.has("timestamp-query") && (this.queryType = "at-passes"), this.queryType !== "none" && typeof this.querySet > "u" && (this.querySet = this.device.createQuerySet({
          type: "timestamp",
          count: this.maxDispatchNumber * 2
        }), this.queryResolveBuffer = this.device.createBuffer({
          size: this.maxDispatchNumber * 2 * 8,
          usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE
        })));
      }
      captureBegin() {
        Mt("info", "captureBegin"), this.capturedCommandList.get(this.currentSessionId) || this.capturedCommandList.set(this.currentSessionId, []), this.capturedPendingKernels.get(this.currentSessionId) || this.capturedPendingKernels.set(this.currentSessionId, []), this.flush(), this.sessionStatus = "capturing";
      }
      captureEnd() {
        Mt("info", "captureEnd"), this.flush(), this.sessionStatus = "default";
      }
      replay() {
        Mt("info", "replay"), this.sessionStatus = "replaying";
        let t = this.capturedCommandList.get(this.currentSessionId), e = this.capturedPendingKernels.get(this.currentSessionId), r = t.length;
        this.pendingKernels = [];
        for (let n = 0; n < r; n++) {
          let i = this.getComputePassEncoder(), a = t[n];
          this.writeTimestamp(this.pendingDispatchNumber * 2), i.setPipeline(a.computePipeline), i.setBindGroup(0, a.bindGroup), i.dispatchWorkgroups(...a.dispatchGroup), this.writeTimestamp(this.pendingDispatchNumber * 2 + 1), this.pendingDispatchNumber++, this.queryType !== "none" && this.pendingKernels.push(e[n]), (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") && this.endComputePass(), this.pendingDispatchNumber >= this.maxDispatchNumber && this.flush();
        }
        this.flush(), this.sessionStatus = "default";
      }
      onCreateSession() {
        this.gpuDataManager.onCreateSession();
      }
      onReleaseSession(t) {
        this.unregisterBuffers(t), this.capturedCommandList.has(t) && this.capturedCommandList.delete(t), this.capturedPendingKernels.has(t) && this.capturedPendingKernels.delete(t), this.gpuDataManager.onReleaseSession(t);
      }
      onRunStart(t) {
        this.currentSessionId = t, this.setQueryType();
      }
    };
  }), UN, i1, YN, a1, o1, s1, qN, SY, w0e = ge(() => {
    To(), UN = 1, i1 = () => UN++, YN = /* @__PURE__ */ new Map([
      [
        "float32",
        32
      ],
      [
        "float16",
        16
      ],
      [
        "int32",
        32
      ],
      [
        "uint32",
        32
      ],
      [
        "int64",
        64
      ],
      [
        "uint64",
        64
      ],
      [
        "int8",
        8
      ],
      [
        "uint8",
        8
      ],
      [
        "int4",
        4
      ],
      [
        "uint4",
        4
      ]
    ]), a1 = (t, e) => {
      let r = YN.get(t);
      if (!r) throw new Error("Unsupported data type.");
      return e.length > 0 ? Math.ceil(e.reduce((n, i) => n * i) * r / 8) : 0;
    }, o1 = class {
      constructor(t) {
        this.sessionId = t.sessionId, this.mlContext = t.context, this.mlTensor = t.tensor, this.dataType = t.dataType, this.tensorShape = t.shape;
      }
      get tensor() {
        return this.mlTensor;
      }
      get type() {
        return this.dataType;
      }
      get shape() {
        return this.tensorShape;
      }
      get byteLength() {
        return a1(this.dataType, this.tensorShape);
      }
      destroy() {
        Mt("verbose", () => "[WebNN] TensorWrapper.destroy"), this.mlTensor.destroy();
      }
      write(t) {
        this.mlContext.writeTensor(this.mlTensor, t);
      }
      async read(t) {
        return t ? this.mlContext.readTensor(this.mlTensor, t) : this.mlContext.readTensor(this.mlTensor);
      }
      canReuseTensor(t, e, r) {
        return this.mlContext === t && this.dataType === e && this.tensorShape.length === r.length && this.tensorShape.every((n, i) => n === r[i]);
      }
    }, s1 = class {
      constructor(t, e) {
        this.tensorManager = t, this.wrapper = e;
      }
      get tensorWrapper() {
        return this.wrapper;
      }
      releaseTensor() {
        this.tensorWrapper && (this.tensorManager.releaseTensor(this.tensorWrapper), this.wrapper = void 0);
      }
      async ensureTensor(t, e, r, n) {
        let i = this.tensorManager.getMLContext(t);
        if (this.wrapper) {
          if (this.wrapper.canReuseTensor(i, e, r)) return this.wrapper.tensor;
          if (n) {
            if (this.wrapper.byteLength !== a1(e, r)) throw new Error("Unable to copy data to tensor with different size.");
            this.activeUpload = new Uint8Array(await this.wrapper.read());
          }
          this.tensorManager.releaseTensor(this.wrapper);
        }
        let a = typeof MLTensorUsage > "u" ? void 0 : MLTensorUsage.READ | MLTensorUsage.WRITE;
        return this.wrapper = await this.tensorManager.getCachedTensor(t, e, r, a, true, true), n && this.activeUpload && (this.wrapper.write(this.activeUpload), this.activeUpload = void 0), this.wrapper.tensor;
      }
      upload(t) {
        if (this.wrapper) if (t.byteLength === this.wrapper.byteLength) {
          this.wrapper.write(t);
          return;
        } else Mt("verbose", () => "Data size does not match tensor size. Releasing tensor."), this.releaseTensor();
        this.activeUpload ? this.activeUpload.set(t) : this.activeUpload = new Uint8Array(t);
      }
      async download(t) {
        if (this.activeUpload) if (t) {
          t instanceof ArrayBuffer ? new Uint8Array(t).set(this.activeUpload) : new Uint8Array(t.buffer, t.byteOffset, t.byteLength).set(this.activeUpload);
          return;
        } else return this.activeUpload.buffer;
        if (!this.wrapper) throw new Error("Tensor has not been created.");
        return t ? this.wrapper.read(t) : this.wrapper.read();
      }
    }, qN = class {
      constructor(t) {
        this.backend = t, this.tensorTrackersById = /* @__PURE__ */ new Map(), this.freeTensors = [], this.externalTensors = /* @__PURE__ */ new Set();
      }
      getMLContext(t) {
        let e = this.backend.getMLContext(t);
        if (!e) throw new Error("MLContext not found for session.");
        return e;
      }
      reserveTensorId() {
        let t = i1();
        return this.tensorTrackersById.set(t, new s1(this)), t;
      }
      releaseTensorId(t) {
        let e = this.tensorTrackersById.get(t);
        e && (this.tensorTrackersById.delete(t), e.tensorWrapper && this.releaseTensor(e.tensorWrapper));
      }
      async ensureTensor(t, e, r, n, i) {
        Mt("verbose", () => `[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${r}, shape: ${n}, copyOld: ${i}}`);
        let a = this.tensorTrackersById.get(e);
        if (!a) throw new Error("Tensor not found.");
        return a.ensureTensor(t, r, n, i);
      }
      upload(t, e) {
        let r = this.tensorTrackersById.get(t);
        if (!r) throw new Error("Tensor not found.");
        r.upload(e);
      }
      async download(t, e) {
        Mt("verbose", () => `[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${e == null ? void 0 : e.byteLength}}`);
        let r = this.tensorTrackersById.get(t);
        if (!r) throw new Error("Tensor not found.");
        return r.download(e);
      }
      releaseTensorsForSession(t) {
        for (let e of this.freeTensors) e.sessionId === t && e.destroy();
        this.freeTensors = this.freeTensors.filter((e) => e.sessionId !== t);
      }
      registerTensor(t, e, r, n) {
        let i = this.getMLContext(t), a = i1(), o = new o1({
          sessionId: t,
          context: i,
          tensor: e,
          dataType: r,
          shape: n
        });
        return this.tensorTrackersById.set(a, new s1(this, o)), this.externalTensors.add(o), a;
      }
      async getCachedTensor(t, e, r, n, i, a) {
        let o = this.getMLContext(t);
        for (let [l, u] of this.freeTensors.entries()) if (u.canReuseTensor(o, e, r)) {
          Mt("verbose", () => `[WebNN] Reusing tensor {dataType: ${e}, shape: ${r}}`);
          let c = this.freeTensors.splice(l, 1)[0];
          return c.sessionId = t, c;
        }
        Mt("verbose", () => `[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${r}}`);
        let s = await o.createTensor({
          dataType: e,
          shape: r,
          dimensions: r,
          usage: n,
          writable: i,
          readable: a
        });
        return new o1({
          sessionId: t,
          context: o,
          tensor: s,
          dataType: e,
          shape: r
        });
      }
      releaseTensor(t) {
        this.externalTensors.has(t) && this.externalTensors.delete(t), this.freeTensors.push(t);
      }
    }, SY = (...t) => new qN(...t);
  }), Cv, XN, TY, S0e = ge(() => {
    Je(), hu(), $U(), w0e(), To(), Cv = /* @__PURE__ */ new Map([
      [
        1,
        "float32"
      ],
      [
        10,
        "float16"
      ],
      [
        6,
        "int32"
      ],
      [
        12,
        "uint32"
      ],
      [
        7,
        "int64"
      ],
      [
        13,
        "uint64"
      ],
      [
        22,
        "int4"
      ],
      [
        21,
        "uint4"
      ],
      [
        3,
        "int8"
      ],
      [
        2,
        "uint8"
      ],
      [
        9,
        "uint8"
      ]
    ]), XN = (t, e) => {
      if (t === e) return true;
      if (t === void 0 || e === void 0) return false;
      let r = Object.keys(t).sort(), n = Object.keys(e).sort();
      return r.length === n.length && r.every((i, a) => i === n[a] && t[i] === e[i]);
    }, TY = class {
      constructor(t) {
        this.tensorManager = SY(this), this.mlContextBySessionId = /* @__PURE__ */ new Map(), this.sessionIdsByMLContext = /* @__PURE__ */ new Map(), this.mlContextCache = [], this.sessionGraphInputs = /* @__PURE__ */ new Map(), this.temporaryGraphInputs = [], this.temporarySessionTensorIds = /* @__PURE__ */ new Map(), lC(t.logLevel, !!t.debug);
      }
      get currentSessionId() {
        if (this.activeSessionId === void 0) throw new Error("No active session");
        return this.activeSessionId;
      }
      onRunStart(t) {
        Mt("verbose", () => `[WebNN] onRunStart {sessionId: ${t}}`), this.activeSessionId = t;
      }
      onRunEnd(t) {
        Mt("verbose", () => `[WebNN] onRunEnd {sessionId: ${t}}`);
        let e = this.temporarySessionTensorIds.get(t);
        if (e) {
          for (let r of e) Mt("verbose", () => `[WebNN] releasing temporary tensor {tensorId: ${r}}`), this.tensorManager.releaseTensorId(r);
          this.temporarySessionTensorIds.delete(t), this.activeSessionId = void 0;
        }
      }
      async createMLContext(t) {
        if (t instanceof GPUDevice) {
          let r = this.mlContextCache.findIndex((n) => n.gpuDevice === t);
          if (r !== -1) return this.mlContextCache[r].mlContext;
          {
            let n = await navigator.ml.createContext(t);
            return this.mlContextCache.push({
              gpuDevice: t,
              mlContext: n
            }), n;
          }
        } else if (t === void 0) {
          let r = this.mlContextCache.findIndex((n) => n.options === void 0 && n.gpuDevice === void 0);
          if (r !== -1) return this.mlContextCache[r].mlContext;
          {
            let n = await navigator.ml.createContext();
            return this.mlContextCache.push({
              mlContext: n
            }), n;
          }
        }
        let e = this.mlContextCache.findIndex((r) => XN(r.options, t));
        if (e !== -1) return this.mlContextCache[e].mlContext;
        {
          let r = await navigator.ml.createContext(t);
          return this.mlContextCache.push({
            options: t,
            mlContext: r
          }), r;
        }
      }
      registerMLContext(t, e) {
        this.mlContextBySessionId.set(t, e);
        let r = this.sessionIdsByMLContext.get(e);
        r || (r = /* @__PURE__ */ new Set(), this.sessionIdsByMLContext.set(e, r)), r.add(t), this.temporaryGraphInputs.length > 0 && (this.sessionGraphInputs.set(t, this.temporaryGraphInputs), this.temporaryGraphInputs = []);
      }
      onReleaseSession(t) {
        this.sessionGraphInputs.delete(t);
        let e = this.mlContextBySessionId.get(t);
        if (!e) return;
        this.tensorManager.releaseTensorsForSession(t), this.mlContextBySessionId.delete(t);
        let r = this.sessionIdsByMLContext.get(e);
        if (r.delete(t), r.size === 0) {
          this.sessionIdsByMLContext.delete(e);
          let n = this.mlContextCache.findIndex((i) => i.mlContext === e);
          n !== -1 && this.mlContextCache.splice(n, 1);
        }
      }
      getMLContext(t) {
        return this.mlContextBySessionId.get(t);
      }
      reserveTensorId() {
        return this.tensorManager.reserveTensorId();
      }
      releaseTensorId(t) {
        Mt("verbose", () => `[WebNN] releaseTensorId {tensorId: ${t}}`), this.tensorManager.releaseTensorId(t);
      }
      async ensureTensor(t, e, r, n, i) {
        let a = Cv.get(r);
        if (!a) throw new Error(`Unsupported ONNX data type: ${r}`);
        return this.tensorManager.ensureTensor(t ?? this.currentSessionId, e, a, n, i);
      }
      async createTemporaryTensor(t, e, r) {
        Mt("verbose", () => `[WebNN] createTemporaryTensor {onnxDataType: ${e}, shape: ${r}}`);
        let n = Cv.get(e);
        if (!n) throw new Error(`Unsupported ONNX data type: ${e}`);
        let i = this.tensorManager.reserveTensorId();
        await this.tensorManager.ensureTensor(t, i, n, r, false);
        let a = this.temporarySessionTensorIds.get(t);
        return a ? a.push(i) : this.temporarySessionTensorIds.set(t, [
          i
        ]), i;
      }
      uploadTensor(t, e) {
        if (!Cr().shouldTransferToMLTensor) throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");
        Mt("verbose", () => `[WebNN] uploadTensor {tensorId: ${t}, data: ${e.byteLength}}`), this.tensorManager.upload(t, e);
      }
      async downloadTensor(t, e) {
        return this.tensorManager.download(t, e);
      }
      createMLTensorDownloader(t, e) {
        return async () => {
          let r = await this.tensorManager.download(t);
          return uC(r, e);
        };
      }
      registerMLTensor(t, e, r, n) {
        let i = Cv.get(r);
        if (!i) throw new Error(`Unsupported ONNX data type: ${r}`);
        let a = this.tensorManager.registerTensor(t, e, i, n);
        return Mt("verbose", () => `[WebNN] registerMLTensor {tensor: ${e}, dataType: ${i}, dimensions: ${n}} -> {tensorId: ${a}}`), a;
      }
      registerMLConstant(t, e, r, n, i, a) {
        if (!a) throw new Error("External mounted files are not available.");
        let o = t;
        t.startsWith("./") && (o = t.substring(2));
        let s = a.get(o);
        if (!s) throw new Error(`File with name ${o} not found in preloaded files.`);
        if (e + r > s.byteLength) throw new Error("Out of bounds: data offset and length exceed the external file data size.");
        let l = s.slice(e, e + r).buffer, u;
        switch (i.dataType) {
          case "float32":
            u = new Float32Array(l);
            break;
          case "float16":
            u = new Uint16Array(l);
            break;
          case "int32":
            u = new Int32Array(l);
            break;
          case "uint32":
            u = new Uint32Array(l);
            break;
          case "int64":
            u = new BigInt64Array(l);
            break;
          case "uint64":
            u = new BigUint64Array(l);
            break;
          case "int8":
            u = new Int8Array(l);
            break;
          case "int4":
          case "uint4":
          case "uint8":
            u = new Uint8Array(l);
            break;
          default:
            throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`);
        }
        return Mt("verbose", () => `[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}}`), n.constant(i, u);
      }
      registerGraphInput(t) {
        this.temporaryGraphInputs.push(t);
      }
      isGraphInput(t, e) {
        let r = this.sessionGraphInputs.get(t);
        return r ? r.includes(e) : false;
      }
      flush() {
      }
    };
  }), CY = {};
  Kd(CY, {
    init: () => AY
  });
  var Av, jN, AY, T0e = ge(() => {
    Je(), x0e(), To(), ft(), S0e(), Av = class IY {
      constructor(e, r, n, i) {
        this.module = e, this.dataType = r, this.data = n, this.dims = i;
      }
      getFloat32Array() {
        if (this.dataType !== 1) throw new Error("Invalid data type");
        let e = re.size(this.dims);
        return e === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, e);
      }
      getBigInt64Array() {
        if (this.dataType !== 7) throw new Error("Invalid data type");
        let e = re.size(this.dims);
        return e === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, e);
      }
      getInt32Array() {
        if (this.dataType !== 6) throw new Error("Invalid data type");
        let e = re.size(this.dims);
        return e === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, e);
      }
      getUint16Array() {
        if (this.dataType !== 10 && this.dataType !== 4) throw new Error("Invalid data type");
        let e = re.size(this.dims);
        return e === 0 ? new Uint16Array() : new Uint16Array(this.module.HEAP8.buffer, this.data, e);
      }
      reshape(e) {
        if (re.size(e) !== re.size(this.dims)) throw new Error("Invalid new shape");
        return new IY(this.module, this.dataType, this.data, e);
      }
    }, jN = class {
      constructor(t, e, r) {
        this.module = t, this.backend = e, this.customDataOffset = 0, this.customDataSize = 0, this.adapterInfo = e.adapterInfo, this.deviceInfo = e.deviceInfo;
        let n = t.PTR_SIZE, i = r / t.PTR_SIZE, a = n === 4 ? "i32" : "i64";
        this.opKernelContext = Number(t.getValue(n * i++, a));
        let o = Number(t.getValue(n * i++, a));
        this.outputCount = Number(t.getValue(n * i++, a)), this.customDataOffset = Number(t.getValue(n * i++, "*")), this.customDataSize = Number(t.getValue(n * i++, a));
        let s = [];
        for (let l = 0; l < o; l++) {
          let u = Number(t.getValue(n * i++, a)), c = Number(t.getValue(n * i++, "*")), h = Number(t.getValue(n * i++, a)), f = [];
          for (let d = 0; d < h; d++) f.push(Number(t.getValue(n * i++, a)));
          s.push(new Av(t, u, c, f));
        }
        this.inputs = s;
      }
      get kernelCustomData() {
        return this.backend.currentKernelCustomData;
      }
      get customDataBuffer() {
        return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
      }
      compute(t, e) {
        var _a2;
        let r = ((_a2 = e == null ? void 0 : e.inputs) == null ? void 0 : _a2.map((o) => typeof o == "number" ? this.inputs[o] : o)) ?? this.inputs, n = (e == null ? void 0 : e.outputs) ?? [], i = (o, s, l) => new Av(this.module, s, this.output(o, l), l), a = (o, s) => {
          let l = xl(o, s);
          if (!l) throw new Error(`Unsupported data type: ${o}`);
          let u = l > 0 ? this.backend.gpuDataManager.create(l).id : 0;
          return new Av(this.module, o, u, s);
        };
        return this.backend.run(t, r, n, i, a, this.outputCount);
      }
      output(t, e) {
        let r = this.module.stackSave();
        try {
          let n = this.module.PTR_SIZE, i = n === 4 ? "i32" : "i64", a = this.module.stackAlloc((1 + e.length) * n);
          this.module.setValue(a, e.length, i);
          for (let o = 0; o < e.length; o++) this.module.setValue(a + n * (o + 1), e[o], i);
          return this.module._JsepOutput(this.opKernelContext, t, a);
        } catch (n) {
          throw new Error(`Failed to generate kernel's output[${t}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`);
        } finally {
          this.module.stackRestore(r);
        }
      }
    }, AY = async (t, e, r, n) => {
      let i = e.jsepInit;
      if (!i) throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
      if (t === "webgpu") {
        let a = new wY();
        await a.initialize(r, n), i("webgpu", [
          a,
          (o) => a.alloc(Number(o)),
          (o) => a.free(o),
          (o, s, l, u = false) => {
            if (u) Mt("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${Number(o)}, dst=${Number(s)}, size=${Number(l)}`), a.memcpy(Number(o), Number(s));
            else {
              Mt("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(o)}, gpuDataId=${Number(s)}, size=${Number(l)}`);
              let c = e.HEAPU8.subarray(Number(o >>> 0), Number(o >>> 0) + Number(l));
              a.upload(Number(s), c);
            }
          },
          async (o, s, l) => {
            Mt("verbose", () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${s}, size=${l}`), await a.download(Number(o), () => e.HEAPU8.subarray(Number(s) >>> 0, Number(s + l) >>> 0));
          },
          (o, s, l) => a.createKernel(o, Number(s), l, e.UTF8ToString(e._JsepGetNodeName(Number(s)))),
          (o) => a.releaseKernel(o),
          (o, s, l, u) => {
            Mt("verbose", () => `[WebGPU] jsepRun: sessionHandle=${l}, kernel=${o}, contextDataOffset=${s}`);
            let c = new jN(e, a, Number(s));
            return a.computeKernel(Number(o), c, u);
          },
          () => a.captureBegin(),
          () => a.captureEnd(),
          () => a.replay()
        ]);
      } else {
        let a = new TY(r);
        i("webnn", [
          a,
          () => a.reserveTensorId(),
          (o) => a.releaseTensorId(o),
          async (o, s, l, u, c) => a.ensureTensor(o, s, l, u, c),
          (o, s) => {
            a.uploadTensor(o, s);
          },
          async (o, s) => a.downloadTensor(o, s)
        ]);
      }
    };
  }), KN, bC, xC, zo, ZN, wm, wC, SC, l1, TC, CC, AC, MY = ge(() => {
    Mye(), Dye(), Je(), hu(), nC(), LU(), KN = (t, e) => {
      Cr()._OrtInit(t, e) !== 0 && Lt("Can't initialize onnxruntime.");
    }, bC = async (t) => {
      KN(t.wasm.numThreads, ym(t.logLevel));
    }, xC = async (t, e) => {
      {
        let r = (T0e(), vm(CY)).init;
        if (e === "webgpu") {
          if (typeof navigator > "u" || !navigator.gpu) throw new Error("WebGPU is not supported in current environment");
          let n = t.webgpu.adapter;
          if (n) {
            if (typeof n.limits != "object" || typeof n.features != "object" || typeof n.requestDevice != "function") throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
          } else {
            let i = t.webgpu.powerPreference;
            if (i !== void 0 && i !== "low-power" && i !== "high-performance") throw new Error(`Invalid powerPreference setting: "${i}"`);
            let a = t.webgpu.forceFallbackAdapter;
            if (a !== void 0 && typeof a != "boolean") throw new Error(`Invalid forceFallbackAdapter setting: "${a}"`);
            if (n = await navigator.gpu.requestAdapter({
              powerPreference: i,
              forceFallbackAdapter: a
            }), !n) throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.');
          }
          await r("webgpu", Cr(), t, n);
        }
        if (e === "webnn") {
          if (typeof navigator > "u" || !navigator.ml) throw new Error("WebNN is not supported in current environment");
          await r("webnn", Cr(), t);
        }
      }
    }, zo = /* @__PURE__ */ new Map(), ZN = (t) => {
      let e = Cr(), r = e.stackSave();
      try {
        let n = e.PTR_SIZE, i = e.stackAlloc(2 * n);
        e._OrtGetInputOutputCount(t, i, i + n) !== 0 && Lt("Can't get session input/output count.");
        let a = n === 4 ? "i32" : "i64";
        return [
          Number(e.getValue(i, a)),
          Number(e.getValue(i + n, a))
        ];
      } finally {
        e.stackRestore(r);
      }
    }, wm = (t) => {
      let e = Cr(), r = e._malloc(t.byteLength);
      if (r === 0) throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);
      return e.HEAPU8.set(t, r), [
        r,
        t.byteLength
      ];
    }, wC = async (t, e) => {
      var _a2, _b2, _c2;
      let r, n, i = Cr();
      Array.isArray(t) ? [r, n] = t : t.buffer === i.HEAPU8.buffer ? [r, n] = [
        t.byteOffset,
        t.byteLength
      ] : [r, n] = wm(t);
      let a = 0, o = 0, s = 0, l = [], u = [], c = [];
      try {
        if ([o, l] = PU(e), (e == null ? void 0 : e.externalData) && i.mountExternalData) {
          let y = [];
          for (let _ of e.externalData) {
            let b = typeof _ == "string" ? _ : _.path;
            y.push(sC(typeof _ == "string" ? _ : _.data).then((w) => {
              i.mountExternalData(b, w);
            }));
          }
          await Promise.all(y);
        }
        for (let y of (e == null ? void 0 : e.executionProviders) ?? []) if ((typeof y == "string" ? y : y.name) === "webnn") {
          if (i.shouldTransferToMLTensor = false, typeof y != "string") {
            let _ = y, b = _ == null ? void 0 : _.context, w = _ == null ? void 0 : _.gpuDevice, x = _ == null ? void 0 : _.deviceType, T = _ == null ? void 0 : _.powerPreference;
            b ? i.currentContext = b : w ? i.currentContext = await i.jsepCreateMLContext(w) : i.currentContext = await i.jsepCreateMLContext({
              deviceType: x,
              powerPreference: T
            });
          } else i.currentContext = await i.jsepCreateMLContext();
          break;
        }
        a = await i._OrtCreateSession(r, n, o), a === 0 && Lt("Can't create a session."), (_a2 = i.jsepOnCreateSession) == null ? void 0 : _a2.call(i), i.currentContext && (i.jsepRegisterMLContext(a, i.currentContext), i.currentContext = void 0, i.shouldTransferToMLTensor = true);
        let [h, f] = ZN(a), d = !!(e == null ? void 0 : e.enableGraphCapture), p = [], v = [], g = [];
        for (let y = 0; y < h; y++) {
          let _ = i._OrtGetInputName(a, y);
          _ === 0 && Lt("Can't get an input name."), u.push(_), p.push(i.UTF8ToString(_));
        }
        for (let y = 0; y < f; y++) {
          let _ = i._OrtGetOutputName(a, y);
          _ === 0 && Lt("Can't get an output name."), c.push(_);
          let b = i.UTF8ToString(_);
          v.push(b);
          {
            if (d && (e == null ? void 0 : e.preferredOutputLocation) === void 0) {
              g.push("gpu-buffer");
              continue;
            }
            let w = typeof (e == null ? void 0 : e.preferredOutputLocation) == "string" ? e.preferredOutputLocation : ((_b2 = e == null ? void 0 : e.preferredOutputLocation) == null ? void 0 : _b2[b]) ?? "cpu";
            if (w !== "cpu" && w !== "cpu-pinned" && w !== "gpu-buffer" && w !== "ml-tensor") throw new Error(`Not supported preferred output location: ${w}.`);
            if (d && w !== "gpu-buffer") throw new Error(`Not supported preferred output location: ${w}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);
            g.push(w);
          }
        }
        let m = null;
        return g.some((y) => y === "gpu-buffer" || y === "ml-tensor") && (s = i._OrtCreateBinding(a), s === 0 && Lt("Can't create IO binding."), m = {
          handle: s,
          outputPreferredLocations: g,
          outputPreferredLocationsEncoded: g.map((y) => Ww(y))
        }), zo.set(a, [
          a,
          u,
          c,
          m,
          d,
          false
        ]), [
          a,
          p,
          v
        ];
      } catch (h) {
        throw u.forEach((f) => i._OrtFree(f)), c.forEach((f) => i._OrtFree(f)), s !== 0 && i._OrtReleaseBinding(s) !== 0 && Lt("Can't release IO binding."), a !== 0 && i._OrtReleaseSession(a) !== 0 && Lt("Can't release session."), h;
      } finally {
        i._free(r), o !== 0 && i._OrtReleaseSessionOptions(o) !== 0 && Lt("Can't release session options."), l.forEach((h) => i._free(h)), (_c2 = i.unmountExternalData) == null ? void 0 : _c2.call(i);
      }
    }, SC = (t) => {
      var _a2;
      let e = Cr(), r = zo.get(t);
      if (!r) throw new Error(`cannot release session. invalid session id: ${t}`);
      let [n, i, a, o, s] = r;
      o && (s && e._OrtClearBoundOutputs(o.handle) !== 0 && Lt("Can't clear bound outputs."), e._OrtReleaseBinding(o.handle) !== 0 && Lt("Can't release IO binding.")), (_a2 = e.jsepOnReleaseSession) == null ? void 0 : _a2.call(e, t), i.forEach((l) => e._OrtFree(l)), a.forEach((l) => e._OrtFree(l)), e._OrtReleaseSession(n) !== 0 && Lt("Can't release session."), zo.delete(t);
    }, l1 = async (t, e, r, n, i, a = false) => {
      if (!t) {
        e.push(0);
        return;
      }
      let o = Cr(), s = o.PTR_SIZE, l = t[0], u = t[1], c = t[3], h = c, f, d;
      if (l === "string" && (c === "gpu-buffer" || c === "ml-tensor")) throw new Error("String tensor is not supported on GPU.");
      if (a && c !== "gpu-buffer") throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);
      if (c === "gpu-buffer") {
        let g = t[2].gpuBuffer;
        d = xl(Ku(l), u);
        let m = o.jsepRegisterBuffer;
        if (!m) throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
        f = m(n, i, g, d);
      } else if (c === "ml-tensor") {
        let g = t[2].mlTensor;
        d = xl(Ku(l), u);
        let m = o.jsepRegisterMLTensor;
        if (!m) throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
        f = m(n, g, Ku(l), u);
      } else {
        let g = t[2];
        if (Array.isArray(g)) {
          d = s * g.length, f = o._malloc(d), r.push(f);
          for (let m = 0; m < g.length; m++) {
            if (typeof g[m] != "string") throw new TypeError(`tensor data at index ${m} is not a string`);
            o.setValue(f + m * s, Wr(g[m], r), "*");
          }
        } else {
          let m = o.jsepIsGraphInput;
          if (l !== "string" && m) {
            let y = o._OrtGetInputName(n, i), _ = o.UTF8ToString(y);
            if (m(n, _)) {
              let b = Ku(l);
              d = xl(b, u), h = "ml-tensor";
              let w = o.jsepCreateTemporaryTensor, x = o.jsepUploadTensor;
              if (!w || !x) throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
              let T = await w(n, b, u);
              x(T, new Uint8Array(g.buffer, g.byteOffset, g.byteLength)), f = T;
            } else d = g.byteLength, f = o._malloc(d), r.push(f), o.HEAPU8.set(new Uint8Array(g.buffer, g.byteOffset, d), f);
          } else d = g.byteLength, f = o._malloc(d), r.push(f), o.HEAPU8.set(new Uint8Array(g.buffer, g.byteOffset, d), f);
        }
      }
      let p = o.stackSave(), v = o.stackAlloc(4 * u.length);
      try {
        u.forEach((m, y) => o.setValue(v + y * s, m, s === 4 ? "i32" : "i64"));
        let g = o._OrtCreateTensor(Ku(l), f, d, v, u.length, Ww(h));
        g === 0 && Lt(`Can't create tensor for input/output. session=${n}, index=${i}.`), e.push(g);
      } finally {
        o.stackRestore(p);
      }
    }, TC = async (t, e, r, n, i, a) => {
      var _a2, _b2, _c2;
      let o = Cr(), s = o.PTR_SIZE, l = zo.get(t);
      if (!l) throw new Error(`cannot run inference. invalid session id: ${t}`);
      let u = l[0], c = l[1], h = l[2], f = l[3], d = l[4], p = l[5], v = e.length, g = n.length, m = 0, y = [], _ = [], b = [], w = [], x = o.stackSave(), T = o.stackAlloc(v * s), A = o.stackAlloc(v * s), I = o.stackAlloc(g * s), M = o.stackAlloc(g * s);
      try {
        [m, y] = kU(a);
        for (let L = 0; L < v; L++) await l1(r[L], _, w, t, e[L], d);
        for (let L = 0; L < g; L++) await l1(i[L], b, w, t, v + n[L], d);
        for (let L = 0; L < v; L++) o.setValue(T + L * s, _[L], "*"), o.setValue(A + L * s, c[e[L]], "*");
        for (let L = 0; L < g; L++) o.setValue(I + L * s, b[L], "*"), o.setValue(M + L * s, h[n[L]], "*");
        if (f && !p) {
          let { handle: L, outputPreferredLocations: z, outputPreferredLocationsEncoded: F } = f;
          if (c.length !== v) throw new Error(`input count from feeds (${v}) is expected to be always equal to model's input count (${c.length}).`);
          for (let E = 0; E < v; E++) {
            let O = e[E];
            await o._OrtBindInput(L, c[O], _[E]) !== 0 && Lt(`Can't bind input[${E}] for session=${t}.`);
          }
          for (let E = 0; E < g; E++) {
            let O = n[E];
            ((_a2 = i[E]) == null ? void 0 : _a2[3]) ? o._OrtBindOutput(L, h[O], b[E], 0) !== 0 && Lt(`Can't bind pre-allocated output[${E}] for session=${t}.`) : o._OrtBindOutput(L, h[O], 0, F[O]) !== 0 && Lt(`Can't bind output[${E}] to ${z[E]} for session=${t}.`);
          }
          zo.set(t, [
            u,
            c,
            h,
            f,
            d,
            true
          ]);
        }
        (_b2 = o.jsepOnRunStart) == null ? void 0 : _b2.call(o, u);
        let k;
        f ? k = await o._OrtRunWithBinding(u, f.handle, g, I, m) : k = await o._OrtRun(u, A, T, v, M, g, I, m), k !== 0 && Lt("failed to call OrtRun().");
        let B = [];
        for (let L = 0; L < g; L++) {
          let z = Number(o.getValue(I + L * s, "*"));
          if (z === b[L]) {
            B.push(i[L]);
            continue;
          }
          let F = o.stackSave(), E = o.stackAlloc(4 * s), O = false, N, V = 0;
          try {
            o._OrtGetTensorData(z, E, E + s, E + 2 * s, E + 3 * s) !== 0 && Lt(`Can't access output tensor data on index ${L}.`);
            let H = s === 4 ? "i32" : "i64", G = Number(o.getValue(E, H));
            V = o.getValue(E + s, "*");
            let Y = o.getValue(E + s * 2, "*"), U = Number(o.getValue(E + s * 3, H)), Z = [];
            for (let Te = 0; Te < U; Te++) Z.push(Number(o.getValue(Y + Te * s, H)));
            o._OrtFree(Y) !== 0 && Lt("Can't free memory for tensor dims.");
            let ee = Z.reduce((Te, le) => Te * le, 1);
            N = bl(G);
            let we = f == null ? void 0 : f.outputPreferredLocations[n[L]];
            if (N === "string") {
              if (we === "gpu-buffer" || we === "ml-tensor") throw new Error("String tensor is not supported on GPU.");
              let Te = [];
              for (let le = 0; le < ee; le++) {
                let ue = o.getValue(V + le * s, "*"), ye = o.getValue(V + (le + 1) * s, "*"), ve = le === ee - 1 ? void 0 : ye - ue;
                Te.push(o.UTF8ToString(ue, ve));
              }
              B.push([
                N,
                Z,
                Te,
                "cpu"
              ]);
            } else if (we === "gpu-buffer" && ee > 0) {
              let Te = o.jsepGetBuffer;
              if (!Te) throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
              let le = Te(V), ue = xl(G, ee);
              if (ue === void 0 || !aC(N)) throw new Error(`Unsupported data type: ${N}`);
              O = true, B.push([
                N,
                Z,
                {
                  gpuBuffer: le,
                  download: o.jsepCreateDownloader(le, ue, N),
                  dispose: () => {
                    o._OrtReleaseTensor(z) !== 0 && Lt("Can't release tensor.");
                  }
                },
                "gpu-buffer"
              ]);
            } else if (we === "ml-tensor" && ee > 0) {
              let Te = o.jsepEnsureTensor;
              if (!Te) throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
              if (xl(G, ee) === void 0 || !oC(N)) throw new Error(`Unsupported data type: ${N}`);
              let le = await Te(t, V, G, Z, false);
              O = true, B.push([
                N,
                Z,
                {
                  mlTensor: le,
                  download: o.jsepCreateMLTensorDownloader(V, N),
                  dispose: () => {
                    o.jsepReleaseTensorId(V), o._OrtReleaseTensor(z);
                  }
                },
                "ml-tensor"
              ]);
            } else {
              let Te = iC(N), le = new Te(ee);
              new Uint8Array(le.buffer, le.byteOffset, le.byteLength).set(o.HEAPU8.subarray(V, V + le.byteLength)), B.push([
                N,
                Z,
                le,
                "cpu"
              ]);
            }
          } finally {
            o.stackRestore(F), N === "string" && V && o._free(V), O || o._OrtReleaseTensor(z), (_c2 = o.jsepOnRunEnd) == null ? void 0 : _c2.call(o, u);
          }
        }
        return f && !d && (o._OrtClearBoundOutputs(f.handle) !== 0 && Lt("Can't clear bound outputs."), zo.set(t, [
          u,
          c,
          h,
          f,
          d,
          false
        ])), B;
      } finally {
        o.stackRestore(x), _.forEach((k) => o._OrtReleaseTensor(k)), b.forEach((k) => o._OrtReleaseTensor(k)), w.forEach((k) => o._free(k)), m !== 0 && o._OrtReleaseRunOptions(m), y.forEach((k) => o._free(k));
      }
    }, CC = (t) => {
      let e = Cr(), r = zo.get(t);
      if (!r) throw new Error("invalid session id");
      let n = r[0], i = e._OrtEndProfiling(n);
      i === 0 && Lt("Can't get an profile file name."), e._OrtFree(i);
    }, AC = (t) => {
      let e = [];
      for (let r of t) {
        let n = r[2];
        !Array.isArray(n) && "buffer" in n && e.push(n.buffer);
      }
      return e;
    };
  }), Fo, ai, zu, Vh, Gh, Iv, u1, Mv, Js, el, QN, DY, EY, kY, PY, LY, $Y, RY, OY = ge(() => {
    ea(), MY(), hu(), tC(), Fo = () => !!rr.wasm.proxy && typeof document < "u", zu = false, Vh = false, Gh = false, Mv = /* @__PURE__ */ new Map(), Js = (t, e) => {
      let r = Mv.get(t);
      r ? r.push(e) : Mv.set(t, [
        e
      ]);
    }, el = () => {
      if (zu || !Vh || Gh || !ai) throw new Error("worker not ready");
    }, QN = (t) => {
      switch (t.data.type) {
        case "init-wasm":
          zu = false, t.data.err ? (Gh = true, u1[1](t.data.err)) : (Vh = true, u1[0]()), Iv && (URL.revokeObjectURL(Iv), Iv = void 0);
          break;
        case "init-ep":
        case "copy-from":
        case "create":
        case "release":
        case "run":
        case "end-profiling": {
          let e = Mv.get(t.data.type);
          t.data.err ? e.shift()[1](t.data.err) : e.shift()[0](t.data.out);
          break;
        }
      }
    }, DY = async () => {
      if (!Vh) {
        if (zu) throw new Error("multiple calls to 'initWasm()' detected.");
        if (Gh) throw new Error("previous call to 'initWasm()' failed.");
        if (zu = true, Fo()) return new Promise((t, e) => {
          ai == null ? void 0 : ai.terminate(), DU().then(([r, n]) => {
            var _a2;
            try {
              ai = n, ai.onerror = (a) => e(a), ai.onmessage = QN, u1 = [
                t,
                e
              ];
              let i = {
                type: "init-wasm",
                in: rr
              };
              !i.in.wasm.wasmPaths && (r || ((_a2 = import.meta.url) == null ? void 0 : _a2.startsWith("file:"))) && (i.in.wasm.wasmPaths = {
                wasm: new URL("/assets/ort-wasm-simd-threaded.jsep-D5Jk56-t.wasm", import.meta.url).href
              }), ai.postMessage(i), Iv = r;
            } catch (i) {
              e(i);
            }
          }, e);
        });
        try {
          await rC(rr.wasm), await bC(rr), Vh = true;
        } catch (t) {
          throw Gh = true, t;
        } finally {
          zu = false;
        }
      }
    }, EY = async (t) => {
      if (Fo()) return el(), new Promise((e, r) => {
        Js("init-ep", [
          e,
          r
        ]);
        let n = {
          type: "init-ep",
          in: {
            epName: t,
            env: rr
          }
        };
        ai.postMessage(n);
      });
      await xC(rr, t);
    }, kY = async (t) => Fo() ? (el(), new Promise((e, r) => {
      Js("copy-from", [
        e,
        r
      ]);
      let n = {
        type: "copy-from",
        in: {
          buffer: t
        }
      };
      ai.postMessage(n, [
        t.buffer
      ]);
    })) : wm(t), PY = async (t, e) => {
      if (Fo()) {
        if (e == null ? void 0 : e.preferredOutputLocation) throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
        return el(), new Promise((r, n) => {
          Js("create", [
            r,
            n
          ]);
          let i = {
            type: "create",
            in: {
              model: t,
              options: {
                ...e
              }
            }
          }, a = [];
          t instanceof Uint8Array && a.push(t.buffer), ai.postMessage(i, a);
        });
      } else return wC(t, e);
    }, LY = async (t) => {
      if (Fo()) return el(), new Promise((e, r) => {
        Js("release", [
          e,
          r
        ]);
        let n = {
          type: "release",
          in: t
        };
        ai.postMessage(n);
      });
      SC(t);
    }, $Y = async (t, e, r, n, i, a) => {
      if (Fo()) {
        if (r.some((o) => o[3] !== "cpu")) throw new Error("input tensor on GPU is not supported for proxy.");
        if (i.some((o) => o)) throw new Error("pre-allocated output tensor is not supported for proxy.");
        return el(), new Promise((o, s) => {
          Js("run", [
            o,
            s
          ]);
          let l = r, u = {
            type: "run",
            in: {
              sessionId: t,
              inputIndices: e,
              inputs: l,
              outputIndices: n,
              options: a
            }
          };
          ai.postMessage(u, AC(l));
        });
      } else return TC(t, e, r, n, i, a);
    }, RY = async (t) => {
      if (Fo()) return el(), new Promise((e, r) => {
        Js("end-profiling", [
          e,
          r
        ]);
        let n = {
          type: "end-profiling",
          in: t
        };
        ai.postMessage(n);
      });
      CC(t);
    };
  }), c1, JN, NY, C0e = ge(() => {
    ea(), OY(), Je(), eC(), LU(), c1 = (t, e) => {
      switch (t.location) {
        case "cpu":
          return [
            t.type,
            t.dims,
            t.data,
            "cpu"
          ];
        case "gpu-buffer":
          return [
            t.type,
            t.dims,
            {
              gpuBuffer: t.gpuBuffer
            },
            "gpu-buffer"
          ];
        case "ml-tensor":
          return [
            t.type,
            t.dims,
            {
              mlTensor: t.mlTensor
            },
            "ml-tensor"
          ];
        default:
          throw new Error(`invalid data location: ${t.location} for ${e()}`);
      }
    }, JN = (t) => {
      switch (t[3]) {
        case "cpu":
          return new ba(t[0], t[2], t[1]);
        case "gpu-buffer": {
          let e = t[0];
          if (!aC(e)) throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);
          let { gpuBuffer: r, download: n, dispose: i } = t[2];
          return ba.fromGpuBuffer(r, {
            dataType: e,
            dims: t[1],
            download: n,
            dispose: i
          });
        }
        case "ml-tensor": {
          let e = t[0];
          if (!oC(e)) throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);
          let { mlTensor: r, download: n, dispose: i } = t[2];
          return ba.fromMLTensor(r, {
            dataType: e,
            dims: t[1],
            download: n,
            dispose: i
          });
        }
        default:
          throw new Error(`invalid data location: ${t[3]}`);
      }
    }, NY = class {
      async fetchModelAndCopyToWasmMemory(t) {
        return kY(await sC(t));
      }
      async loadModel(t, e) {
        Oa();
        let r;
        typeof t == "string" ? r = await this.fetchModelAndCopyToWasmMemory(t) : r = t, [this.sessionId, this.inputNames, this.outputNames] = await PY(r, e), qi();
      }
      async dispose() {
        return LY(this.sessionId);
      }
      async run(t, e, r) {
        Oa();
        let n = [], i = [];
        Object.entries(t).forEach((h) => {
          let f = h[0], d = h[1], p = this.inputNames.indexOf(f);
          if (p === -1) throw new Error(`invalid input '${f}'`);
          n.push(d), i.push(p);
        });
        let a = [], o = [];
        Object.entries(e).forEach((h) => {
          let f = h[0], d = h[1], p = this.outputNames.indexOf(f);
          if (p === -1) throw new Error(`invalid output '${f}'`);
          a.push(d), o.push(p);
        });
        let s = n.map((h, f) => c1(h, () => `input "${this.inputNames[i[f]]}"`)), l = a.map((h, f) => h ? c1(h, () => `output "${this.outputNames[o[f]]}"`) : null), u = await $Y(this.sessionId, i, s, o, l, r), c = {};
        for (let h = 0; h < u.length; h++) c[this.outputNames[o[h]]] = a[h] ?? JN(u[h]);
        return qi(), c;
      }
      startProfiling() {
      }
      endProfiling() {
        RY(this.sessionId);
      }
    };
  }), BY = {};
  Kd(BY, {
    OnnxruntimeWebAssemblyBackend: () => rS,
    initializeFlags: () => tS,
    wasmBackend: () => zY
  });
  var tS, rS, zY, A0e = ge(() => {
    ea(), OY(), C0e(), tS = () => {
      if ((typeof rr.wasm.initTimeout != "number" || rr.wasm.initTimeout < 0) && (rr.wasm.initTimeout = 0), rr.wasm.simd === false && console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof rr.wasm.proxy != "boolean" && (rr.wasm.proxy = false), typeof rr.wasm.trace != "boolean" && (rr.wasm.trace = false), typeof rr.wasm.numThreads != "number" || !Number.isInteger(rr.wasm.numThreads) || rr.wasm.numThreads <= 0) if (typeof self < "u" && !self.crossOriginIsolated) rr.wasm.numThreads = 1;
      else {
        let t = typeof navigator > "u" ? cye("node:os").cpus().length : navigator.hardwareConcurrency;
        rr.wasm.numThreads = Math.min(4, Math.ceil((t || 1) / 2));
      }
    }, rS = class {
      async init(t) {
        tS(), await DY(), await EY(t);
      }
      async createInferenceSessionHandler(t, e) {
        let r = new NY();
        return await r.loadModel(t, e), Promise.resolve(r);
      }
    }, zY = new rS();
  });
  ea();
  ea();
  ea();
  var I0e = "1.21.0";
  {
    let t = (A0e(), vm(BY)).wasmBackend;
    oc("webgpu", t, 5), oc("webnn", t, 5), oc("cpu", t, 10), oc("wasm", t, 10);
  }
  Object.defineProperty(rr.versions, "web", {
    value: I0e,
    enumerable: true
  });
  function M0e(t) {
    return new Worker("/assets/detect.worker-zO3dnsj2.js", {
      name: t == null ? void 0 : t.name
    });
  }
  const tl = new M0e();
  var xa = ((t) => (t.detect = "detect", t.stop = "stop", t.loadModel = "loadModel", t.disposeModel = "disposeModel", t.testRun = "testRun", t))(xa || {});
  class IC {
    constructor(e) {
      __publicField(this, "src");
      __publicField(this, "net");
      __publicField(this, "labels");
      __publicField(this, "inputShape");
      __publicField(this, "frameRate");
      __publicField(this, "loaded", false);
      __publicField(this, "detectState", false);
    }
    dispose() {
      tl.postMessage({
        cmd: xa.disposeModel
      });
    }
    get numClass() {
      throw new Error("Method not implemented.");
    }
    async detect(e, r) {
      return new Promise((n, i) => {
        tl.postMessage({
          cmd: xa.detect,
          data: {
            source: e,
            options: r
          }
        }), tl.onmessage = (a) => {
          n(a.data);
        };
      });
    }
    detectVideo(e, r = {
      once: false,
      scoreThreshold: 0.6
    }) {
      const n = async () => {
        var _a2, _b2, _c2, _d2;
        if (!this.detectState || this.loaded == null) {
          (_a2 = r.onOutput) == null ? void 0 : _a2.call(r, null);
          return;
        }
        if (e instanceof HTMLVideoElement && e.videoWidth === 0 && e.srcObject === null) {
          (_b2 = r.onOutput) == null ? void 0 : _b2.call(r, null);
          return;
        }
        if (e instanceof HTMLCanvasElement && e.width === 0) {
          (_c2 = r.onOutput) == null ? void 0 : _c2.call(r, null);
          return;
        }
        const [i, a] = this.getSourceSize(e), o = this.inputShape[2], s = Math.min(a, o) / a, l = parseInt((a * s).toString(), 10), u = parseInt((i * s).toString(), 10), c = await createImageBitmap(e, {
          resizeWidth: l,
          resizeHeight: u
        }), h = await this.detect(c, {
          scoreThreshold: r.scoreThreshold
        }), [f, d] = h.ratios;
        h.ratios = [
          f / s,
          d / s
        ], (_d2 = r.onOutput) == null ? void 0 : _d2.call(r, h), !(r.once && h.boxes.length) && (this.frameRate !== void 0 && this.frameRate !== 0 ? setTimeout(n, 1e3 / this.frameRate) : requestAnimationFrame(n));
      };
      this.detectState = true, n();
    }
    testRun() {
      return new Promise((e, r) => {
        this.inputShape && (tl.postMessage({
          cmd: xa.testRun
        }), tl.onmessage = (n) => {
          n.data ? e(n.data) : r(new Error("Test run failed"));
        });
      });
    }
    async loadModel(e) {
      return new Promise((r, n) => {
        tl.postMessage({
          cmd: xa.loadModel,
          data: {
            model: this.src,
            labels: this.labels
          }
        }), tl.onmessage = (i) => {
          var _a2;
          i.data.cmd === xa.loadModel && ((_a2 = e == null ? void 0 : e.onProgress) == null ? void 0 : _a2.call(e, i.data.percent), i.data.percent === 100 && i.data.inputShape && (this.inputShape = i.data.inputShape, this.loaded = true, r(true)));
        };
      });
    }
    static async fromUrl(e, r) {
      return new IC({});
    }
    getSourceSize(e) {
      return e instanceof HTMLVideoElement ? [
        e.videoHeight,
        e.videoWidth
      ] : [
        e.height,
        e.width
      ];
    }
  }
  async function D0e() {
    return (await Wl(() => import("./tfjs-DSq-hcCs.js").then((e) => e.i), [])).setWasmPaths("/"), hp().set("WEBGL_CPU_FORWARD", false), hp().set("WEBGL_DELETE_TEXTURE_THRESHOLD", -1), hp().set("WASM_HAS_SIMD_SUPPORT", true), hp().set("WASM_HAS_MULTITHREAD_SUPPORT", true), await xF("wasm"), await wF(), iK;
  }
  function FY(t) {
    return typeof t > "u" || t === null;
  }
  function E0e(t) {
    return typeof t == "object" && t !== null;
  }
  function k0e(t) {
    return Array.isArray(t) ? t : FY(t) ? [] : [
      t
    ];
  }
  function P0e(t, e) {
    var r, n, i, a;
    if (e) for (a = Object.keys(e), r = 0, n = a.length; r < n; r += 1) i = a[r], t[i] = e[i];
    return t;
  }
  function L0e(t, e) {
    var r = "", n;
    for (n = 0; n < e; n += 1) r += t;
    return r;
  }
  function $0e(t) {
    return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
  }
  var R0e = FY, O0e = E0e, N0e = k0e, B0e = L0e, z0e = $0e, F0e = P0e, Ir = {
    isNothing: R0e,
    isObject: O0e,
    toArray: N0e,
    repeat: B0e,
    isNegativeZero: z0e,
    extend: F0e
  };
  function VY(t, e) {
    var r = "", n = t.reason || "(unknown reason)";
    return t.mark ? (t.mark.name && (r += 'in "' + t.mark.name + '" '), r += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")", !e && t.mark.snippet && (r += `

` + t.mark.snippet), n + " " + r) : n;
  }
  function gd(t, e) {
    Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = VY(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  gd.prototype = Object.create(Error.prototype);
  gd.prototype.constructor = gd;
  gd.prototype.toString = function(e) {
    return this.name + ": " + VY(this, e);
  };
  var gn = gd;
  function h1(t, e, r, n, i) {
    var a = "", o = "", s = Math.floor(i / 2) - 1;
    return n - e > s && (a = " ... ", e = n - s + a.length), r - n > s && (o = " ...", r = n + s - o.length), {
      str: a + t.slice(e, r).replace(/\t/g, "\u2192") + o,
      pos: n - e + a.length
    };
  }
  function f1(t, e) {
    return Ir.repeat(" ", e - t.length) + t;
  }
  function V0e(t, e) {
    if (e = Object.create(e || null), !t.buffer) return null;
    e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
    for (var r = /\r?\n|\r|\0/g, n = [
      0
    ], i = [], a, o = -1; a = r.exec(t.buffer); ) i.push(a.index), n.push(a.index + a[0].length), t.position <= a.index && o < 0 && (o = n.length - 2);
    o < 0 && (o = n.length - 1);
    var s = "", l, u, c = Math.min(t.line + e.linesAfter, i.length).toString().length, h = e.maxLength - (e.indent + c + 3);
    for (l = 1; l <= e.linesBefore && !(o - l < 0); l++) u = h1(t.buffer, n[o - l], i[o - l], t.position - (n[o] - n[o - l]), h), s = Ir.repeat(" ", e.indent) + f1((t.line - l + 1).toString(), c) + " | " + u.str + `
` + s;
    for (u = h1(t.buffer, n[o], i[o], t.position, h), s += Ir.repeat(" ", e.indent) + f1((t.line + 1).toString(), c) + " | " + u.str + `
`, s += Ir.repeat("-", e.indent + c + 3 + u.pos) + `^
`, l = 1; l <= e.linesAfter && !(o + l >= i.length); l++) u = h1(t.buffer, n[o + l], i[o + l], t.position - (n[o] - n[o + l]), h), s += Ir.repeat(" ", e.indent) + f1((t.line + l + 1).toString(), c) + " | " + u.str + `
`;
    return s.replace(/\n$/, "");
  }
  var G0e = V0e, W0e = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], H0e = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function U0e(t) {
    var e = {};
    return t !== null && Object.keys(t).forEach(function(r) {
      t[r].forEach(function(n) {
        e[String(n)] = r;
      });
    }), e;
  }
  function Y0e(t, e) {
    if (e = e || {}, Object.keys(e).forEach(function(r) {
      if (W0e.indexOf(r) === -1) throw new gn('Unknown option "' + r + '" is met in definition of "' + t + '" YAML type.');
    }), this.options = e, this.tag = t, this.kind = e.kind || null, this.resolve = e.resolve || function() {
      return true;
    }, this.construct = e.construct || function(r) {
      return r;
    }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || false, this.styleAliases = U0e(e.styleAliases || null), H0e.indexOf(this.kind) === -1) throw new gn('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
  }
  var Yr = Y0e;
  function eB(t, e) {
    var r = [];
    return t[e].forEach(function(n) {
      var i = r.length;
      r.forEach(function(a, o) {
        a.tag === n.tag && a.kind === n.kind && a.multi === n.multi && (i = o);
      }), r[i] = n;
    }), r;
  }
  function q0e() {
    var t = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, e, r;
    function n(i) {
      i.multi ? (t.multi[i.kind].push(i), t.multi.fallback.push(i)) : t[i.kind][i.tag] = t.fallback[i.tag] = i;
    }
    for (e = 0, r = arguments.length; e < r; e += 1) arguments[e].forEach(n);
    return t;
  }
  function nS(t) {
    return this.extend(t);
  }
  nS.prototype.extend = function(e) {
    var r = [], n = [];
    if (e instanceof Yr) n.push(e);
    else if (Array.isArray(e)) n = n.concat(e);
    else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit))) e.implicit && (r = r.concat(e.implicit)), e.explicit && (n = n.concat(e.explicit));
    else throw new gn("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    r.forEach(function(a) {
      if (!(a instanceof Yr)) throw new gn("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (a.loadKind && a.loadKind !== "scalar") throw new gn("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (a.multi) throw new gn("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), n.forEach(function(a) {
      if (!(a instanceof Yr)) throw new gn("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var i = Object.create(nS.prototype);
    return i.implicit = (this.implicit || []).concat(r), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = eB(i, "implicit"), i.compiledExplicit = eB(i, "explicit"), i.compiledTypeMap = q0e(i.compiledImplicit, i.compiledExplicit), i;
  };
  var GY = nS, WY = new Yr("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(t) {
      return t !== null ? t : "";
    }
  }), HY = new Yr("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(t) {
      return t !== null ? t : [];
    }
  }), UY = new Yr("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(t) {
      return t !== null ? t : {};
    }
  }), YY = new GY({
    explicit: [
      WY,
      HY,
      UY
    ]
  });
  function X0e(t) {
    if (t === null) return true;
    var e = t.length;
    return e === 1 && t === "~" || e === 4 && (t === "null" || t === "Null" || t === "NULL");
  }
  function j0e() {
    return null;
  }
  function K0e(t) {
    return t === null;
  }
  var qY = new Yr("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: X0e,
    construct: j0e,
    predicate: K0e,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function Z0e(t) {
    if (t === null) return false;
    var e = t.length;
    return e === 4 && (t === "true" || t === "True" || t === "TRUE") || e === 5 && (t === "false" || t === "False" || t === "FALSE");
  }
  function Q0e(t) {
    return t === "true" || t === "True" || t === "TRUE";
  }
  function J0e(t) {
    return Object.prototype.toString.call(t) === "[object Boolean]";
  }
  var XY = new Yr("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: Z0e,
    construct: Q0e,
    predicate: J0e,
    represent: {
      lowercase: function(t) {
        return t ? "true" : "false";
      },
      uppercase: function(t) {
        return t ? "TRUE" : "FALSE";
      },
      camelcase: function(t) {
        return t ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function e_e(t) {
    return 48 <= t && t <= 57 || 65 <= t && t <= 70 || 97 <= t && t <= 102;
  }
  function t_e(t) {
    return 48 <= t && t <= 55;
  }
  function r_e(t) {
    return 48 <= t && t <= 57;
  }
  function n_e(t) {
    if (t === null) return false;
    var e = t.length, r = 0, n = false, i;
    if (!e) return false;
    if (i = t[r], (i === "-" || i === "+") && (i = t[++r]), i === "0") {
      if (r + 1 === e) return true;
      if (i = t[++r], i === "b") {
        for (r++; r < e; r++) if (i = t[r], i !== "_") {
          if (i !== "0" && i !== "1") return false;
          n = true;
        }
        return n && i !== "_";
      }
      if (i === "x") {
        for (r++; r < e; r++) if (i = t[r], i !== "_") {
          if (!e_e(t.charCodeAt(r))) return false;
          n = true;
        }
        return n && i !== "_";
      }
      if (i === "o") {
        for (r++; r < e; r++) if (i = t[r], i !== "_") {
          if (!t_e(t.charCodeAt(r))) return false;
          n = true;
        }
        return n && i !== "_";
      }
    }
    if (i === "_") return false;
    for (; r < e; r++) if (i = t[r], i !== "_") {
      if (!r_e(t.charCodeAt(r))) return false;
      n = true;
    }
    return !(!n || i === "_");
  }
  function i_e(t) {
    var e = t, r = 1, n;
    if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (r = -1), e = e.slice(1), n = e[0]), e === "0") return 0;
    if (n === "0") {
      if (e[1] === "b") return r * parseInt(e.slice(2), 2);
      if (e[1] === "x") return r * parseInt(e.slice(2), 16);
      if (e[1] === "o") return r * parseInt(e.slice(2), 8);
    }
    return r * parseInt(e, 10);
  }
  function a_e(t) {
    return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !Ir.isNegativeZero(t);
  }
  var jY = new Yr("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: n_e,
    construct: i_e,
    predicate: a_e,
    represent: {
      binary: function(t) {
        return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
      },
      octal: function(t) {
        return t >= 0 ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1);
      },
      decimal: function(t) {
        return t.toString(10);
      },
      hexadecimal: function(t) {
        return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [
        2,
        "bin"
      ],
      octal: [
        8,
        "oct"
      ],
      decimal: [
        10,
        "dec"
      ],
      hexadecimal: [
        16,
        "hex"
      ]
    }
  }), o_e = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
  function s_e(t) {
    return !(t === null || !o_e.test(t) || t[t.length - 1] === "_");
  }
  function l_e(t) {
    var e, r;
    return e = t.replace(/_/g, "").toLowerCase(), r = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : r * parseFloat(e, 10);
  }
  var u_e = /^[-+]?[0-9]+e/;
  function c_e(t, e) {
    var r;
    if (isNaN(t)) switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
    else if (Number.POSITIVE_INFINITY === t) switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
    else if (Number.NEGATIVE_INFINITY === t) switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
    else if (Ir.isNegativeZero(t)) return "-0.0";
    return r = t.toString(10), u_e.test(r) ? r.replace("e", ".e") : r;
  }
  function h_e(t) {
    return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || Ir.isNegativeZero(t));
  }
  var KY = new Yr("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: s_e,
    construct: l_e,
    predicate: h_e,
    represent: c_e,
    defaultStyle: "lowercase"
  }), ZY = YY.extend({
    implicit: [
      qY,
      XY,
      jY,
      KY
    ]
  }), QY = ZY, JY = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), e9 = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
  function f_e(t) {
    return t === null ? false : JY.exec(t) !== null || e9.exec(t) !== null;
  }
  function d_e(t) {
    var e, r, n, i, a, o, s, l = 0, u = null, c, h, f;
    if (e = JY.exec(t), e === null && (e = e9.exec(t)), e === null) throw new Error("Date resolve error");
    if (r = +e[1], n = +e[2] - 1, i = +e[3], !e[4]) return new Date(Date.UTC(r, n, i));
    if (a = +e[4], o = +e[5], s = +e[6], e[7]) {
      for (l = e[7].slice(0, 3); l.length < 3; ) l += "0";
      l = +l;
    }
    return e[9] && (c = +e[10], h = +(e[11] || 0), u = (c * 60 + h) * 6e4, e[9] === "-" && (u = -u)), f = new Date(Date.UTC(r, n, i, a, o, s, l)), u && f.setTime(f.getTime() - u), f;
  }
  function p_e(t) {
    return t.toISOString();
  }
  var t9 = new Yr("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: f_e,
    construct: d_e,
    instanceOf: Date,
    represent: p_e
  });
  function v_e(t) {
    return t === "<<" || t === null;
  }
  var r9 = new Yr("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: v_e
  }), MC = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function g_e(t) {
    if (t === null) return false;
    var e, r, n = 0, i = t.length, a = MC;
    for (r = 0; r < i; r++) if (e = a.indexOf(t.charAt(r)), !(e > 64)) {
      if (e < 0) return false;
      n += 6;
    }
    return n % 8 === 0;
  }
  function m_e(t) {
    var e, r, n = t.replace(/[\r\n=]/g, ""), i = n.length, a = MC, o = 0, s = [];
    for (e = 0; e < i; e++) e % 4 === 0 && e && (s.push(o >> 16 & 255), s.push(o >> 8 & 255), s.push(o & 255)), o = o << 6 | a.indexOf(n.charAt(e));
    return r = i % 4 * 6, r === 0 ? (s.push(o >> 16 & 255), s.push(o >> 8 & 255), s.push(o & 255)) : r === 18 ? (s.push(o >> 10 & 255), s.push(o >> 2 & 255)) : r === 12 && s.push(o >> 4 & 255), new Uint8Array(s);
  }
  function y_e(t) {
    var e = "", r = 0, n, i, a = t.length, o = MC;
    for (n = 0; n < a; n++) n % 3 === 0 && n && (e += o[r >> 18 & 63], e += o[r >> 12 & 63], e += o[r >> 6 & 63], e += o[r & 63]), r = (r << 8) + t[n];
    return i = a % 3, i === 0 ? (e += o[r >> 18 & 63], e += o[r >> 12 & 63], e += o[r >> 6 & 63], e += o[r & 63]) : i === 2 ? (e += o[r >> 10 & 63], e += o[r >> 4 & 63], e += o[r << 2 & 63], e += o[64]) : i === 1 && (e += o[r >> 2 & 63], e += o[r << 4 & 63], e += o[64], e += o[64]), e;
  }
  function __e(t) {
    return Object.prototype.toString.call(t) === "[object Uint8Array]";
  }
  var n9 = new Yr("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: g_e,
    construct: m_e,
    predicate: __e,
    represent: y_e
  }), b_e = Object.prototype.hasOwnProperty, x_e = Object.prototype.toString;
  function w_e(t) {
    if (t === null) return true;
    var e = [], r, n, i, a, o, s = t;
    for (r = 0, n = s.length; r < n; r += 1) {
      if (i = s[r], o = false, x_e.call(i) !== "[object Object]") return false;
      for (a in i) if (b_e.call(i, a)) if (!o) o = true;
      else return false;
      if (!o) return false;
      if (e.indexOf(a) === -1) e.push(a);
      else return false;
    }
    return true;
  }
  function S_e(t) {
    return t !== null ? t : [];
  }
  var i9 = new Yr("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: w_e,
    construct: S_e
  }), T_e = Object.prototype.toString;
  function C_e(t) {
    if (t === null) return true;
    var e, r, n, i, a, o = t;
    for (a = new Array(o.length), e = 0, r = o.length; e < r; e += 1) {
      if (n = o[e], T_e.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1)) return false;
      a[e] = [
        i[0],
        n[i[0]]
      ];
    }
    return true;
  }
  function A_e(t) {
    if (t === null) return [];
    var e, r, n, i, a, o = t;
    for (a = new Array(o.length), e = 0, r = o.length; e < r; e += 1) n = o[e], i = Object.keys(n), a[e] = [
      i[0],
      n[i[0]]
    ];
    return a;
  }
  var a9 = new Yr("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: C_e,
    construct: A_e
  }), I_e = Object.prototype.hasOwnProperty;
  function M_e(t) {
    if (t === null) return true;
    var e, r = t;
    for (e in r) if (I_e.call(r, e) && r[e] !== null) return false;
    return true;
  }
  function D_e(t) {
    return t !== null ? t : {};
  }
  var o9 = new Yr("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: M_e,
    construct: D_e
  }), DC = QY.extend({
    implicit: [
      t9,
      r9
    ],
    explicit: [
      n9,
      i9,
      a9,
      o9
    ]
  }), _s = Object.prototype.hasOwnProperty, Sm = 1, s9 = 2, l9 = 3, Tm = 4, d1 = 1, E_e = 2, tB = 3, k_e = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, P_e = /[\x85\u2028\u2029]/, L_e = /[,\[\]\{\}]/, u9 = /^(?:!|!!|![a-z\-]+!)$/i, c9 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function rB(t) {
    return Object.prototype.toString.call(t);
  }
  function Da(t) {
    return t === 10 || t === 13;
  }
  function Gl(t) {
    return t === 9 || t === 32;
  }
  function Pn(t) {
    return t === 9 || t === 32 || t === 10 || t === 13;
  }
  function lc(t) {
    return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
  }
  function $_e(t) {
    var e;
    return 48 <= t && t <= 57 ? t - 48 : (e = t | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
  }
  function R_e(t) {
    return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
  }
  function O_e(t) {
    return 48 <= t && t <= 57 ? t - 48 : -1;
  }
  function nB(t) {
    return t === 48 ? "\0" : t === 97 ? "\x07" : t === 98 ? "\b" : t === 116 || t === 9 ? "	" : t === 110 ? `
` : t === 118 ? "\v" : t === 102 ? "\f" : t === 114 ? "\r" : t === 101 ? "\x1B" : t === 32 ? " " : t === 34 ? '"' : t === 47 ? "/" : t === 92 ? "\\" : t === 78 ? "\x85" : t === 95 ? "\xA0" : t === 76 ? "\u2028" : t === 80 ? "\u2029" : "";
  }
  function N_e(t) {
    return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode((t - 65536 >> 10) + 55296, (t - 65536 & 1023) + 56320);
  }
  var h9 = new Array(256), f9 = new Array(256);
  for (var Fu = 0; Fu < 256; Fu++) h9[Fu] = nB(Fu) ? 1 : 0, f9[Fu] = nB(Fu);
  function B_e(t, e) {
    this.input = t, this.filename = e.filename || null, this.schema = e.schema || DC, this.onWarning = e.onWarning || null, this.legacy = e.legacy || false, this.json = e.json || false, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function d9(t, e) {
    var r = {
      name: t.filename,
      buffer: t.input.slice(0, -1),
      position: t.position,
      line: t.line,
      column: t.position - t.lineStart
    };
    return r.snippet = G0e(r), new gn(e, r);
  }
  function qe(t, e) {
    throw d9(t, e);
  }
  function Cm(t, e) {
    t.onWarning && t.onWarning.call(null, d9(t, e));
  }
  var iB = {
    YAML: function(e, r, n) {
      var i, a, o;
      e.version !== null && qe(e, "duplication of %YAML directive"), n.length !== 1 && qe(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && qe(e, "ill-formed argument of the YAML directive"), a = parseInt(i[1], 10), o = parseInt(i[2], 10), a !== 1 && qe(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = o < 2, o !== 1 && o !== 2 && Cm(e, "unsupported YAML version of the document");
    },
    TAG: function(e, r, n) {
      var i, a;
      n.length !== 2 && qe(e, "TAG directive accepts exactly two arguments"), i = n[0], a = n[1], u9.test(i) || qe(e, "ill-formed tag handle (first argument) of the TAG directive"), _s.call(e.tagMap, i) && qe(e, 'there is a previously declared suffix for "' + i + '" tag handle'), c9.test(a) || qe(e, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        a = decodeURIComponent(a);
      } catch {
        qe(e, "tag prefix is malformed: " + a);
      }
      e.tagMap[i] = a;
    }
  };
  function us(t, e, r, n) {
    var i, a, o, s;
    if (e < r) {
      if (s = t.input.slice(e, r), n) for (i = 0, a = s.length; i < a; i += 1) o = s.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || qe(t, "expected valid JSON character");
      else k_e.test(s) && qe(t, "the stream contains non-printable characters");
      t.result += s;
    }
  }
  function aB(t, e, r, n) {
    var i, a, o, s;
    for (Ir.isObject(r) || qe(t, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), o = 0, s = i.length; o < s; o += 1) a = i[o], _s.call(e, a) || (e[a] = r[a], n[a] = true);
  }
  function uc(t, e, r, n, i, a, o, s, l) {
    var u, c;
    if (Array.isArray(i)) for (i = Array.prototype.slice.call(i), u = 0, c = i.length; u < c; u += 1) Array.isArray(i[u]) && qe(t, "nested arrays are not supported inside keys"), typeof i == "object" && rB(i[u]) === "[object Object]" && (i[u] = "[object Object]");
    if (typeof i == "object" && rB(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), n === "tag:yaml.org,2002:merge") if (Array.isArray(a)) for (u = 0, c = a.length; u < c; u += 1) aB(t, e, a[u], r);
    else aB(t, e, a, r);
    else !t.json && !_s.call(r, i) && _s.call(e, i) && (t.line = o || t.line, t.lineStart = s || t.lineStart, t.position = l || t.position, qe(t, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: a
    }) : e[i] = a, delete r[i];
    return e;
  }
  function EC(t) {
    var e;
    e = t.input.charCodeAt(t.position), e === 10 ? t.position++ : e === 13 ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++) : qe(t, "a line break is expected"), t.line += 1, t.lineStart = t.position, t.firstTabInLine = -1;
  }
  function _r(t, e, r) {
    for (var n = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
      for (; Gl(i); ) i === 9 && t.firstTabInLine === -1 && (t.firstTabInLine = t.position), i = t.input.charCodeAt(++t.position);
      if (e && i === 35) do
        i = t.input.charCodeAt(++t.position);
      while (i !== 10 && i !== 13 && i !== 0);
      if (Da(i)) for (EC(t), i = t.input.charCodeAt(t.position), n++, t.lineIndent = 0; i === 32; ) t.lineIndent++, i = t.input.charCodeAt(++t.position);
      else break;
    }
    return r !== -1 && n !== 0 && t.lineIndent < r && Cm(t, "deficient indentation"), n;
  }
  function xy(t) {
    var e = t.position, r;
    return r = t.input.charCodeAt(e), !!((r === 45 || r === 46) && r === t.input.charCodeAt(e + 1) && r === t.input.charCodeAt(e + 2) && (e += 3, r = t.input.charCodeAt(e), r === 0 || Pn(r)));
  }
  function kC(t, e) {
    e === 1 ? t.result += " " : e > 1 && (t.result += Ir.repeat(`
`, e - 1));
  }
  function z_e(t, e, r) {
    var n, i, a, o, s, l, u, c, h = t.kind, f = t.result, d;
    if (d = t.input.charCodeAt(t.position), Pn(d) || lc(d) || d === 35 || d === 38 || d === 42 || d === 33 || d === 124 || d === 62 || d === 39 || d === 34 || d === 37 || d === 64 || d === 96 || (d === 63 || d === 45) && (i = t.input.charCodeAt(t.position + 1), Pn(i) || r && lc(i))) return false;
    for (t.kind = "scalar", t.result = "", a = o = t.position, s = false; d !== 0; ) {
      if (d === 58) {
        if (i = t.input.charCodeAt(t.position + 1), Pn(i) || r && lc(i)) break;
      } else if (d === 35) {
        if (n = t.input.charCodeAt(t.position - 1), Pn(n)) break;
      } else {
        if (t.position === t.lineStart && xy(t) || r && lc(d)) break;
        if (Da(d)) if (l = t.line, u = t.lineStart, c = t.lineIndent, _r(t, false, -1), t.lineIndent >= e) {
          s = true, d = t.input.charCodeAt(t.position);
          continue;
        } else {
          t.position = o, t.line = l, t.lineStart = u, t.lineIndent = c;
          break;
        }
      }
      s && (us(t, a, o, false), kC(t, t.line - l), a = o = t.position, s = false), Gl(d) || (o = t.position + 1), d = t.input.charCodeAt(++t.position);
    }
    return us(t, a, o, false), t.result ? true : (t.kind = h, t.result = f, false);
  }
  function F_e(t, e) {
    var r, n, i;
    if (r = t.input.charCodeAt(t.position), r !== 39) return false;
    for (t.kind = "scalar", t.result = "", t.position++, n = i = t.position; (r = t.input.charCodeAt(t.position)) !== 0; ) if (r === 39) if (us(t, n, t.position, true), r = t.input.charCodeAt(++t.position), r === 39) n = t.position, t.position++, i = t.position;
    else return true;
    else Da(r) ? (us(t, n, i, true), kC(t, _r(t, false, e)), n = i = t.position) : t.position === t.lineStart && xy(t) ? qe(t, "unexpected end of the document within a single quoted scalar") : (t.position++, i = t.position);
    qe(t, "unexpected end of the stream within a single quoted scalar");
  }
  function V_e(t, e) {
    var r, n, i, a, o, s;
    if (s = t.input.charCodeAt(t.position), s !== 34) return false;
    for (t.kind = "scalar", t.result = "", t.position++, r = n = t.position; (s = t.input.charCodeAt(t.position)) !== 0; ) {
      if (s === 34) return us(t, r, t.position, true), t.position++, true;
      if (s === 92) {
        if (us(t, r, t.position, true), s = t.input.charCodeAt(++t.position), Da(s)) _r(t, false, e);
        else if (s < 256 && h9[s]) t.result += f9[s], t.position++;
        else if ((o = R_e(s)) > 0) {
          for (i = o, a = 0; i > 0; i--) s = t.input.charCodeAt(++t.position), (o = $_e(s)) >= 0 ? a = (a << 4) + o : qe(t, "expected hexadecimal character");
          t.result += N_e(a), t.position++;
        } else qe(t, "unknown escape sequence");
        r = n = t.position;
      } else Da(s) ? (us(t, r, n, true), kC(t, _r(t, false, e)), r = n = t.position) : t.position === t.lineStart && xy(t) ? qe(t, "unexpected end of the document within a double quoted scalar") : (t.position++, n = t.position);
    }
    qe(t, "unexpected end of the stream within a double quoted scalar");
  }
  function G_e(t, e) {
    var r = true, n, i, a, o = t.tag, s, l = t.anchor, u, c, h, f, d, p = /* @__PURE__ */ Object.create(null), v, g, m, y;
    if (y = t.input.charCodeAt(t.position), y === 91) c = 93, d = false, s = [];
    else if (y === 123) c = 125, d = true, s = {};
    else return false;
    for (t.anchor !== null && (t.anchorMap[t.anchor] = s), y = t.input.charCodeAt(++t.position); y !== 0; ) {
      if (_r(t, true, e), y = t.input.charCodeAt(t.position), y === c) return t.position++, t.tag = o, t.anchor = l, t.kind = d ? "mapping" : "sequence", t.result = s, true;
      r ? y === 44 && qe(t, "expected the node content, but found ','") : qe(t, "missed comma between flow collection entries"), g = v = m = null, h = f = false, y === 63 && (u = t.input.charCodeAt(t.position + 1), Pn(u) && (h = f = true, t.position++, _r(t, true, e))), n = t.line, i = t.lineStart, a = t.position, Dc(t, e, Sm, false, true), g = t.tag, v = t.result, _r(t, true, e), y = t.input.charCodeAt(t.position), (f || t.line === n) && y === 58 && (h = true, y = t.input.charCodeAt(++t.position), _r(t, true, e), Dc(t, e, Sm, false, true), m = t.result), d ? uc(t, s, p, g, v, m, n, i, a) : h ? s.push(uc(t, null, p, g, v, m, n, i, a)) : s.push(v), _r(t, true, e), y = t.input.charCodeAt(t.position), y === 44 ? (r = true, y = t.input.charCodeAt(++t.position)) : r = false;
    }
    qe(t, "unexpected end of the stream within a flow collection");
  }
  function W_e(t, e) {
    var r, n, i = d1, a = false, o = false, s = e, l = 0, u = false, c, h;
    if (h = t.input.charCodeAt(t.position), h === 124) n = false;
    else if (h === 62) n = true;
    else return false;
    for (t.kind = "scalar", t.result = ""; h !== 0; ) if (h = t.input.charCodeAt(++t.position), h === 43 || h === 45) d1 === i ? i = h === 43 ? tB : E_e : qe(t, "repeat of a chomping mode identifier");
    else if ((c = O_e(h)) >= 0) c === 0 ? qe(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? qe(t, "repeat of an indentation width identifier") : (s = e + c - 1, o = true);
    else break;
    if (Gl(h)) {
      do
        h = t.input.charCodeAt(++t.position);
      while (Gl(h));
      if (h === 35) do
        h = t.input.charCodeAt(++t.position);
      while (!Da(h) && h !== 0);
    }
    for (; h !== 0; ) {
      for (EC(t), t.lineIndent = 0, h = t.input.charCodeAt(t.position); (!o || t.lineIndent < s) && h === 32; ) t.lineIndent++, h = t.input.charCodeAt(++t.position);
      if (!o && t.lineIndent > s && (s = t.lineIndent), Da(h)) {
        l++;
        continue;
      }
      if (t.lineIndent < s) {
        i === tB ? t.result += Ir.repeat(`
`, a ? 1 + l : l) : i === d1 && a && (t.result += `
`);
        break;
      }
      for (n ? Gl(h) ? (u = true, t.result += Ir.repeat(`
`, a ? 1 + l : l)) : u ? (u = false, t.result += Ir.repeat(`
`, l + 1)) : l === 0 ? a && (t.result += " ") : t.result += Ir.repeat(`
`, l) : t.result += Ir.repeat(`
`, a ? 1 + l : l), a = true, o = true, l = 0, r = t.position; !Da(h) && h !== 0; ) h = t.input.charCodeAt(++t.position);
      us(t, r, t.position, false);
    }
    return true;
  }
  function oB(t, e) {
    var r, n = t.tag, i = t.anchor, a = [], o, s = false, l;
    if (t.firstTabInLine !== -1) return false;
    for (t.anchor !== null && (t.anchorMap[t.anchor] = a), l = t.input.charCodeAt(t.position); l !== 0 && (t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, qe(t, "tab characters must not be used in indentation")), !(l !== 45 || (o = t.input.charCodeAt(t.position + 1), !Pn(o)))); ) {
      if (s = true, t.position++, _r(t, true, -1) && t.lineIndent <= e) {
        a.push(null), l = t.input.charCodeAt(t.position);
        continue;
      }
      if (r = t.line, Dc(t, e, l9, false, true), a.push(t.result), _r(t, true, -1), l = t.input.charCodeAt(t.position), (t.line === r || t.lineIndent > e) && l !== 0) qe(t, "bad indentation of a sequence entry");
      else if (t.lineIndent < e) break;
    }
    return s ? (t.tag = n, t.anchor = i, t.kind = "sequence", t.result = a, true) : false;
  }
  function H_e(t, e, r) {
    var n, i, a, o, s, l, u = t.tag, c = t.anchor, h = {}, f = /* @__PURE__ */ Object.create(null), d = null, p = null, v = null, g = false, m = false, y;
    if (t.firstTabInLine !== -1) return false;
    for (t.anchor !== null && (t.anchorMap[t.anchor] = h), y = t.input.charCodeAt(t.position); y !== 0; ) {
      if (!g && t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, qe(t, "tab characters must not be used in indentation")), n = t.input.charCodeAt(t.position + 1), a = t.line, (y === 63 || y === 58) && Pn(n)) y === 63 ? (g && (uc(t, h, f, d, p, null, o, s, l), d = p = v = null), m = true, g = true, i = true) : g ? (g = false, i = true) : qe(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, y = n;
      else {
        if (o = t.line, s = t.lineStart, l = t.position, !Dc(t, r, s9, false, true)) break;
        if (t.line === a) {
          for (y = t.input.charCodeAt(t.position); Gl(y); ) y = t.input.charCodeAt(++t.position);
          if (y === 58) y = t.input.charCodeAt(++t.position), Pn(y) || qe(t, "a whitespace character is expected after the key-value separator within a block mapping"), g && (uc(t, h, f, d, p, null, o, s, l), d = p = v = null), m = true, g = false, i = false, d = t.tag, p = t.result;
          else if (m) qe(t, "can not read an implicit mapping pair; a colon is missed");
          else return t.tag = u, t.anchor = c, true;
        } else if (m) qe(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else return t.tag = u, t.anchor = c, true;
      }
      if ((t.line === a || t.lineIndent > e) && (g && (o = t.line, s = t.lineStart, l = t.position), Dc(t, e, Tm, true, i) && (g ? p = t.result : v = t.result), g || (uc(t, h, f, d, p, v, o, s, l), d = p = v = null), _r(t, true, -1), y = t.input.charCodeAt(t.position)), (t.line === a || t.lineIndent > e) && y !== 0) qe(t, "bad indentation of a mapping entry");
      else if (t.lineIndent < e) break;
    }
    return g && uc(t, h, f, d, p, null, o, s, l), m && (t.tag = u, t.anchor = c, t.kind = "mapping", t.result = h), m;
  }
  function U_e(t) {
    var e, r = false, n = false, i, a, o;
    if (o = t.input.charCodeAt(t.position), o !== 33) return false;
    if (t.tag !== null && qe(t, "duplication of a tag property"), o = t.input.charCodeAt(++t.position), o === 60 ? (r = true, o = t.input.charCodeAt(++t.position)) : o === 33 ? (n = true, i = "!!", o = t.input.charCodeAt(++t.position)) : i = "!", e = t.position, r) {
      do
        o = t.input.charCodeAt(++t.position);
      while (o !== 0 && o !== 62);
      t.position < t.length ? (a = t.input.slice(e, t.position), o = t.input.charCodeAt(++t.position)) : qe(t, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; o !== 0 && !Pn(o); ) o === 33 && (n ? qe(t, "tag suffix cannot contain exclamation marks") : (i = t.input.slice(e - 1, t.position + 1), u9.test(i) || qe(t, "named tag handle cannot contain such characters"), n = true, e = t.position + 1)), o = t.input.charCodeAt(++t.position);
      a = t.input.slice(e, t.position), L_e.test(a) && qe(t, "tag suffix cannot contain flow indicator characters");
    }
    a && !c9.test(a) && qe(t, "tag name cannot contain such characters: " + a);
    try {
      a = decodeURIComponent(a);
    } catch {
      qe(t, "tag name is malformed: " + a);
    }
    return r ? t.tag = a : _s.call(t.tagMap, i) ? t.tag = t.tagMap[i] + a : i === "!" ? t.tag = "!" + a : i === "!!" ? t.tag = "tag:yaml.org,2002:" + a : qe(t, 'undeclared tag handle "' + i + '"'), true;
  }
  function Y_e(t) {
    var e, r;
    if (r = t.input.charCodeAt(t.position), r !== 38) return false;
    for (t.anchor !== null && qe(t, "duplication of an anchor property"), r = t.input.charCodeAt(++t.position), e = t.position; r !== 0 && !Pn(r) && !lc(r); ) r = t.input.charCodeAt(++t.position);
    return t.position === e && qe(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), true;
  }
  function q_e(t) {
    var e, r, n;
    if (n = t.input.charCodeAt(t.position), n !== 42) return false;
    for (n = t.input.charCodeAt(++t.position), e = t.position; n !== 0 && !Pn(n) && !lc(n); ) n = t.input.charCodeAt(++t.position);
    return t.position === e && qe(t, "name of an alias node must contain at least one character"), r = t.input.slice(e, t.position), _s.call(t.anchorMap, r) || qe(t, 'unidentified alias "' + r + '"'), t.result = t.anchorMap[r], _r(t, true, -1), true;
  }
  function Dc(t, e, r, n, i) {
    var a, o, s, l = 1, u = false, c = false, h, f, d, p, v, g;
    if (t.listener !== null && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, a = o = s = Tm === r || l9 === r, n && _r(t, true, -1) && (u = true, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)), l === 1) for (; U_e(t) || Y_e(t); ) _r(t, true, -1) ? (u = true, s = a, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)) : s = false;
    if (s && (s = u || i), (l === 1 || Tm === r) && (Sm === r || s9 === r ? v = e : v = e + 1, g = t.position - t.lineStart, l === 1 ? s && (oB(t, g) || H_e(t, g, v)) || G_e(t, v) ? c = true : (o && W_e(t, v) || F_e(t, v) || V_e(t, v) ? c = true : q_e(t) ? (c = true, (t.tag !== null || t.anchor !== null) && qe(t, "alias node should not have any properties")) : z_e(t, v, Sm === r) && (c = true, t.tag === null && (t.tag = "?")), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : l === 0 && (c = s && oB(t, g))), t.tag === null) t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
    else if (t.tag === "?") {
      for (t.result !== null && t.kind !== "scalar" && qe(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), h = 0, f = t.implicitTypes.length; h < f; h += 1) if (p = t.implicitTypes[h], p.resolve(t.result)) {
        t.result = p.construct(t.result), t.tag = p.tag, t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
        break;
      }
    } else if (t.tag !== "!") {
      if (_s.call(t.typeMap[t.kind || "fallback"], t.tag)) p = t.typeMap[t.kind || "fallback"][t.tag];
      else for (p = null, d = t.typeMap.multi[t.kind || "fallback"], h = 0, f = d.length; h < f; h += 1) if (t.tag.slice(0, d[h].tag.length) === d[h].tag) {
        p = d[h];
        break;
      }
      p || qe(t, "unknown tag !<" + t.tag + ">"), t.result !== null && p.kind !== t.kind && qe(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + p.kind + '", not "' + t.kind + '"'), p.resolve(t.result, t.tag) ? (t.result = p.construct(t.result, t.tag), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : qe(t, "cannot resolve a node with !<" + t.tag + "> explicit tag");
    }
    return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || c;
  }
  function X_e(t) {
    var e = t.position, r, n, i, a = false, o;
    for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = /* @__PURE__ */ Object.create(null), t.anchorMap = /* @__PURE__ */ Object.create(null); (o = t.input.charCodeAt(t.position)) !== 0 && (_r(t, true, -1), o = t.input.charCodeAt(t.position), !(t.lineIndent > 0 || o !== 37)); ) {
      for (a = true, o = t.input.charCodeAt(++t.position), r = t.position; o !== 0 && !Pn(o); ) o = t.input.charCodeAt(++t.position);
      for (n = t.input.slice(r, t.position), i = [], n.length < 1 && qe(t, "directive name must not be less than one character in length"); o !== 0; ) {
        for (; Gl(o); ) o = t.input.charCodeAt(++t.position);
        if (o === 35) {
          do
            o = t.input.charCodeAt(++t.position);
          while (o !== 0 && !Da(o));
          break;
        }
        if (Da(o)) break;
        for (r = t.position; o !== 0 && !Pn(o); ) o = t.input.charCodeAt(++t.position);
        i.push(t.input.slice(r, t.position));
      }
      o !== 0 && EC(t), _s.call(iB, n) ? iB[n](t, n, i) : Cm(t, 'unknown document directive "' + n + '"');
    }
    if (_r(t, true, -1), t.lineIndent === 0 && t.input.charCodeAt(t.position) === 45 && t.input.charCodeAt(t.position + 1) === 45 && t.input.charCodeAt(t.position + 2) === 45 ? (t.position += 3, _r(t, true, -1)) : a && qe(t, "directives end mark is expected"), Dc(t, t.lineIndent - 1, Tm, false, true), _r(t, true, -1), t.checkLineBreaks && P_e.test(t.input.slice(e, t.position)) && Cm(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && xy(t)) {
      t.input.charCodeAt(t.position) === 46 && (t.position += 3, _r(t, true, -1));
      return;
    }
    if (t.position < t.length - 1) qe(t, "end of the stream or a document separator is expected");
    else return;
  }
  function p9(t, e) {
    t = String(t), e = e || {}, t.length !== 0 && (t.charCodeAt(t.length - 1) !== 10 && t.charCodeAt(t.length - 1) !== 13 && (t += `
`), t.charCodeAt(0) === 65279 && (t = t.slice(1)));
    var r = new B_e(t, e), n = t.indexOf("\0");
    for (n !== -1 && (r.position = n, qe(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; ) r.lineIndent += 1, r.position += 1;
    for (; r.position < r.length - 1; ) X_e(r);
    return r.documents;
  }
  function j_e(t, e, r) {
    e !== null && typeof e == "object" && typeof r > "u" && (r = e, e = null);
    var n = p9(t, r);
    if (typeof e != "function") return n;
    for (var i = 0, a = n.length; i < a; i += 1) e(n[i]);
  }
  function K_e(t, e) {
    var r = p9(t, e);
    if (r.length !== 0) {
      if (r.length === 1) return r[0];
      throw new gn("expected a single document in the stream, but found more");
    }
  }
  var Z_e = j_e, Q_e = K_e, v9 = {
    loadAll: Z_e,
    load: Q_e
  }, g9 = Object.prototype.toString, m9 = Object.prototype.hasOwnProperty, PC = 65279, J_e = 9, md = 10, ebe = 13, tbe = 32, rbe = 33, nbe = 34, iS = 35, ibe = 37, abe = 38, obe = 39, sbe = 42, y9 = 44, lbe = 45, Am = 58, ube = 61, cbe = 62, hbe = 63, fbe = 64, _9 = 91, b9 = 93, dbe = 96, x9 = 123, pbe = 124, w9 = 125, ln = {};
  ln[0] = "\\0";
  ln[7] = "\\a";
  ln[8] = "\\b";
  ln[9] = "\\t";
  ln[10] = "\\n";
  ln[11] = "\\v";
  ln[12] = "\\f";
  ln[13] = "\\r";
  ln[27] = "\\e";
  ln[34] = '\\"';
  ln[92] = "\\\\";
  ln[133] = "\\N";
  ln[160] = "\\_";
  ln[8232] = "\\L";
  ln[8233] = "\\P";
  var vbe = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], gbe = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function mbe(t, e) {
    var r, n, i, a, o, s, l;
    if (e === null) return {};
    for (r = {}, n = Object.keys(e), i = 0, a = n.length; i < a; i += 1) o = n[i], s = String(e[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), l = t.compiledTypeMap.fallback[o], l && m9.call(l.styleAliases, s) && (s = l.styleAliases[s]), r[o] = s;
    return r;
  }
  function ybe(t) {
    var e, r, n;
    if (e = t.toString(16).toUpperCase(), t <= 255) r = "x", n = 2;
    else if (t <= 65535) r = "u", n = 4;
    else if (t <= 4294967295) r = "U", n = 8;
    else throw new gn("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + r + Ir.repeat("0", n - e.length) + e;
  }
  var _be = 1, yd = 2;
  function bbe(t) {
    this.schema = t.schema || DC, this.indent = Math.max(1, t.indent || 2), this.noArrayIndent = t.noArrayIndent || false, this.skipInvalid = t.skipInvalid || false, this.flowLevel = Ir.isNothing(t.flowLevel) ? -1 : t.flowLevel, this.styleMap = mbe(this.schema, t.styles || null), this.sortKeys = t.sortKeys || false, this.lineWidth = t.lineWidth || 80, this.noRefs = t.noRefs || false, this.noCompatMode = t.noCompatMode || false, this.condenseFlow = t.condenseFlow || false, this.quotingType = t.quotingType === '"' ? yd : _be, this.forceQuotes = t.forceQuotes || false, this.replacer = typeof t.replacer == "function" ? t.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function sB(t, e) {
    for (var r = Ir.repeat(" ", e), n = 0, i = -1, a = "", o, s = t.length; n < s; ) i = t.indexOf(`
`, n), i === -1 ? (o = t.slice(n), n = s) : (o = t.slice(n, i + 1), n = i + 1), o.length && o !== `
` && (a += r), a += o;
    return a;
  }
  function aS(t, e) {
    return `
` + Ir.repeat(" ", t.indent * e);
  }
  function xbe(t, e) {
    var r, n, i;
    for (r = 0, n = t.implicitTypes.length; r < n; r += 1) if (i = t.implicitTypes[r], i.resolve(e)) return true;
    return false;
  }
  function Im(t) {
    return t === tbe || t === J_e;
  }
  function _d(t) {
    return 32 <= t && t <= 126 || 161 <= t && t <= 55295 && t !== 8232 && t !== 8233 || 57344 <= t && t <= 65533 && t !== PC || 65536 <= t && t <= 1114111;
  }
  function lB(t) {
    return _d(t) && t !== PC && t !== ebe && t !== md;
  }
  function uB(t, e, r) {
    var n = lB(t), i = n && !Im(t);
    return (r ? n : n && t !== y9 && t !== _9 && t !== b9 && t !== x9 && t !== w9) && t !== iS && !(e === Am && !i) || lB(e) && !Im(e) && t === iS || e === Am && i;
  }
  function wbe(t) {
    return _d(t) && t !== PC && !Im(t) && t !== lbe && t !== hbe && t !== Am && t !== y9 && t !== _9 && t !== b9 && t !== x9 && t !== w9 && t !== iS && t !== abe && t !== sbe && t !== rbe && t !== pbe && t !== ube && t !== cbe && t !== obe && t !== nbe && t !== ibe && t !== fbe && t !== dbe;
  }
  function Sbe(t) {
    return !Im(t) && t !== Am;
  }
  function df(t, e) {
    var r = t.charCodeAt(e), n;
    return r >= 55296 && r <= 56319 && e + 1 < t.length && (n = t.charCodeAt(e + 1), n >= 56320 && n <= 57343) ? (r - 55296) * 1024 + n - 56320 + 65536 : r;
  }
  function S9(t) {
    var e = /^\n* /;
    return e.test(t);
  }
  var T9 = 1, oS = 2, C9 = 3, A9 = 4, Zu = 5;
  function Tbe(t, e, r, n, i, a, o, s) {
    var l, u = 0, c = null, h = false, f = false, d = n !== -1, p = -1, v = wbe(df(t, 0)) && Sbe(df(t, t.length - 1));
    if (e || o) for (l = 0; l < t.length; u >= 65536 ? l += 2 : l++) {
      if (u = df(t, l), !_d(u)) return Zu;
      v = v && uB(u, c, s), c = u;
    }
    else {
      for (l = 0; l < t.length; u >= 65536 ? l += 2 : l++) {
        if (u = df(t, l), u === md) h = true, d && (f = f || l - p - 1 > n && t[p + 1] !== " ", p = l);
        else if (!_d(u)) return Zu;
        v = v && uB(u, c, s), c = u;
      }
      f = f || d && l - p - 1 > n && t[p + 1] !== " ";
    }
    return !h && !f ? v && !o && !i(t) ? T9 : a === yd ? Zu : oS : r > 9 && S9(t) ? Zu : o ? a === yd ? Zu : oS : f ? A9 : C9;
  }
  function Cbe(t, e, r, n, i) {
    t.dump = function() {
      if (e.length === 0) return t.quotingType === yd ? '""' : "''";
      if (!t.noCompatMode && (vbe.indexOf(e) !== -1 || gbe.test(e))) return t.quotingType === yd ? '"' + e + '"' : "'" + e + "'";
      var a = t.indent * Math.max(1, r), o = t.lineWidth === -1 ? -1 : Math.max(Math.min(t.lineWidth, 40), t.lineWidth - a), s = n || t.flowLevel > -1 && r >= t.flowLevel;
      function l(u) {
        return xbe(t, u);
      }
      switch (Tbe(e, s, t.indent, o, l, t.quotingType, t.forceQuotes && !n, i)) {
        case T9:
          return e;
        case oS:
          return "'" + e.replace(/'/g, "''") + "'";
        case C9:
          return "|" + cB(e, t.indent) + hB(sB(e, a));
        case A9:
          return ">" + cB(e, t.indent) + hB(sB(Abe(e, o), a));
        case Zu:
          return '"' + Ibe(e) + '"';
        default:
          throw new gn("impossible error: invalid scalar style");
      }
    }();
  }
  function cB(t, e) {
    var r = S9(t) ? String(e) : "", n = t[t.length - 1] === `
`, i = n && (t[t.length - 2] === `
` || t === `
`), a = i ? "+" : n ? "" : "-";
    return r + a + `
`;
  }
  function hB(t) {
    return t[t.length - 1] === `
` ? t.slice(0, -1) : t;
  }
  function Abe(t, e) {
    for (var r = /(\n+)([^\n]*)/g, n = function() {
      var u = t.indexOf(`
`);
      return u = u !== -1 ? u : t.length, r.lastIndex = u, fB(t.slice(0, u), e);
    }(), i = t[0] === `
` || t[0] === " ", a, o; o = r.exec(t); ) {
      var s = o[1], l = o[2];
      a = l[0] === " ", n += s + (!i && !a && l !== "" ? `
` : "") + fB(l, e), i = a;
    }
    return n;
  }
  function fB(t, e) {
    if (t === "" || t[0] === " ") return t;
    for (var r = / [^ ]/g, n, i = 0, a, o = 0, s = 0, l = ""; n = r.exec(t); ) s = n.index, s - i > e && (a = o > i ? o : s, l += `
` + t.slice(i, a), i = a + 1), o = s;
    return l += `
`, t.length - i > e && o > i ? l += t.slice(i, o) + `
` + t.slice(o + 1) : l += t.slice(i), l.slice(1);
  }
  function Ibe(t) {
    for (var e = "", r = 0, n, i = 0; i < t.length; r >= 65536 ? i += 2 : i++) r = df(t, i), n = ln[r], !n && _d(r) ? (e += t[i], r >= 65536 && (e += t[i + 1])) : e += n || ybe(r);
    return e;
  }
  function Mbe(t, e, r) {
    var n = "", i = t.tag, a, o, s;
    for (a = 0, o = r.length; a < o; a += 1) s = r[a], t.replacer && (s = t.replacer.call(r, String(a), s)), (_o(t, e, s, false, false) || typeof s > "u" && _o(t, e, null, false, false)) && (n !== "" && (n += "," + (t.condenseFlow ? "" : " ")), n += t.dump);
    t.tag = i, t.dump = "[" + n + "]";
  }
  function dB(t, e, r, n) {
    var i = "", a = t.tag, o, s, l;
    for (o = 0, s = r.length; o < s; o += 1) l = r[o], t.replacer && (l = t.replacer.call(r, String(o), l)), (_o(t, e + 1, l, true, true, false, true) || typeof l > "u" && _o(t, e + 1, null, true, true, false, true)) && ((!n || i !== "") && (i += aS(t, e)), t.dump && md === t.dump.charCodeAt(0) ? i += "-" : i += "- ", i += t.dump);
    t.tag = a, t.dump = i || "[]";
  }
  function Dbe(t, e, r) {
    var n = "", i = t.tag, a = Object.keys(r), o, s, l, u, c;
    for (o = 0, s = a.length; o < s; o += 1) c = "", n !== "" && (c += ", "), t.condenseFlow && (c += '"'), l = a[o], u = r[l], t.replacer && (u = t.replacer.call(r, l, u)), _o(t, e, l, false, false) && (t.dump.length > 1024 && (c += "? "), c += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " "), _o(t, e, u, false, false) && (c += t.dump, n += c));
    t.tag = i, t.dump = "{" + n + "}";
  }
  function Ebe(t, e, r, n) {
    var i = "", a = t.tag, o = Object.keys(r), s, l, u, c, h, f;
    if (t.sortKeys === true) o.sort();
    else if (typeof t.sortKeys == "function") o.sort(t.sortKeys);
    else if (t.sortKeys) throw new gn("sortKeys must be a boolean or a function");
    for (s = 0, l = o.length; s < l; s += 1) f = "", (!n || i !== "") && (f += aS(t, e)), u = o[s], c = r[u], t.replacer && (c = t.replacer.call(r, u, c)), _o(t, e + 1, u, true, true, true) && (h = t.tag !== null && t.tag !== "?" || t.dump && t.dump.length > 1024, h && (t.dump && md === t.dump.charCodeAt(0) ? f += "?" : f += "? "), f += t.dump, h && (f += aS(t, e)), _o(t, e + 1, c, true, h) && (t.dump && md === t.dump.charCodeAt(0) ? f += ":" : f += ": ", f += t.dump, i += f));
    t.tag = a, t.dump = i || "{}";
  }
  function pB(t, e, r) {
    var n, i, a, o, s, l;
    for (i = r ? t.explicitTypes : t.implicitTypes, a = 0, o = i.length; a < o; a += 1) if (s = i[a], (s.instanceOf || s.predicate) && (!s.instanceOf || typeof e == "object" && e instanceof s.instanceOf) && (!s.predicate || s.predicate(e))) {
      if (r ? s.multi && s.representName ? t.tag = s.representName(e) : t.tag = s.tag : t.tag = "?", s.represent) {
        if (l = t.styleMap[s.tag] || s.defaultStyle, g9.call(s.represent) === "[object Function]") n = s.represent(e, l);
        else if (m9.call(s.represent, l)) n = s.represent[l](e, l);
        else throw new gn("!<" + s.tag + '> tag resolver accepts not "' + l + '" style');
        t.dump = n;
      }
      return true;
    }
    return false;
  }
  function _o(t, e, r, n, i, a, o) {
    t.tag = null, t.dump = r, pB(t, r, false) || pB(t, r, true);
    var s = g9.call(t.dump), l = n, u;
    n && (n = t.flowLevel < 0 || t.flowLevel > e);
    var c = s === "[object Object]" || s === "[object Array]", h, f;
    if (c && (h = t.duplicates.indexOf(r), f = h !== -1), (t.tag !== null && t.tag !== "?" || f || t.indent !== 2 && e > 0) && (i = false), f && t.usedDuplicates[h]) t.dump = "*ref_" + h;
    else {
      if (c && f && !t.usedDuplicates[h] && (t.usedDuplicates[h] = true), s === "[object Object]") n && Object.keys(t.dump).length !== 0 ? (Ebe(t, e, t.dump, i), f && (t.dump = "&ref_" + h + t.dump)) : (Dbe(t, e, t.dump), f && (t.dump = "&ref_" + h + " " + t.dump));
      else if (s === "[object Array]") n && t.dump.length !== 0 ? (t.noArrayIndent && !o && e > 0 ? dB(t, e - 1, t.dump, i) : dB(t, e, t.dump, i), f && (t.dump = "&ref_" + h + t.dump)) : (Mbe(t, e, t.dump), f && (t.dump = "&ref_" + h + " " + t.dump));
      else if (s === "[object String]") t.tag !== "?" && Cbe(t, t.dump, e, a, l);
      else {
        if (s === "[object Undefined]") return false;
        if (t.skipInvalid) return false;
        throw new gn("unacceptable kind of an object to dump " + s);
      }
      t.tag !== null && t.tag !== "?" && (u = encodeURI(t.tag[0] === "!" ? t.tag.slice(1) : t.tag).replace(/!/g, "%21"), t.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", t.dump = u + " " + t.dump);
    }
    return true;
  }
  function kbe(t, e) {
    var r = [], n = [], i, a;
    for (sS(t, r, n), i = 0, a = n.length; i < a; i += 1) e.duplicates.push(r[n[i]]);
    e.usedDuplicates = new Array(a);
  }
  function sS(t, e, r) {
    var n, i, a;
    if (t !== null && typeof t == "object") if (i = e.indexOf(t), i !== -1) r.indexOf(i) === -1 && r.push(i);
    else if (e.push(t), Array.isArray(t)) for (i = 0, a = t.length; i < a; i += 1) sS(t[i], e, r);
    else for (n = Object.keys(t), i = 0, a = n.length; i < a; i += 1) sS(t[n[i]], e, r);
  }
  function Pbe(t, e) {
    e = e || {};
    var r = new bbe(e);
    r.noRefs || kbe(t, r);
    var n = t;
    return r.replacer && (n = r.replacer.call({
      "": n
    }, "", n)), _o(r, 0, n, true, true) ? r.dump + `
` : "";
  }
  var Lbe = Pbe, $be = {
    dump: Lbe
  };
  function LC(t, e) {
    return function() {
      throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
    };
  }
  var Rbe = Yr, Obe = GY, Nbe = YY, Bbe = ZY, zbe = QY, Fbe = DC, Vbe = v9.load, Gbe = v9.loadAll, Wbe = $be.dump, Hbe = gn, Ube = {
    binary: n9,
    float: KY,
    map: UY,
    null: qY,
    pairs: a9,
    set: o9,
    timestamp: t9,
    bool: XY,
    int: jY,
    merge: r9,
    omap: i9,
    seq: HY,
    str: WY
  }, Ybe = LC("safeLoad", "load"), qbe = LC("safeLoadAll", "loadAll"), Xbe = LC("safeDump", "dump"), jbe = {
    Type: Rbe,
    Schema: Obe,
    FAILSAFE_SCHEMA: Nbe,
    JSON_SCHEMA: Bbe,
    CORE_SCHEMA: zbe,
    DEFAULT_SCHEMA: Fbe,
    load: Vbe,
    loadAll: Gbe,
    dump: Wbe,
    YAMLException: Hbe,
    types: Ube,
    safeLoad: Ybe,
    safeLoadAll: qbe,
    safeDump: Xbe
  };
  function Kbe(t) {
    return new Worker("/assets/detect.worker-C_HcPRwm.js", {
      name: t == null ? void 0 : t.name
    });
  }
  const rl = new Kbe();
  let vB = false;
  async function Zbe(t = "webgl") {
    if (xM() !== t && (vB = false), vB) return true;
    try {
      return t === "wasm" ? await D0e() : await xF(t), console.log(t, xM()), await wF(), true;
    } catch (r) {
      return console.error("Failed to initialize backend:", r), false;
    }
  }
  class $C {
    constructor(e) {
      __publicField(this, "labels");
      __publicField(this, "src");
      __publicField(this, "loaded", false);
      __publicField(this, "inputShape");
      __publicField(this, "frameRate");
      __publicField(this, "detectState", false);
      this.labels = e.labels, this.src = e.modelJson;
    }
    get numClass() {
      return this.labels.length;
    }
    static async fromUrl(e, r) {
      await Zbe();
      const n = "https://office-website-1251680498.cos.ap-shanghai.myqcloud.com/xinzhou/web_model", i = `${n}/${e}/model.json`, a = `${n}/${e}/metadata.yaml`, o = await (await fetch(a)).text(), s = jbe.load(o), l = Object.values(s.names);
      if (!l) {
        console.error("No Labels Fetched");
        return;
      }
      const u = new $C({
        modelJson: i,
        labels: l
      });
      let c = 0;
      return await u.loadModel({
        onProgress: (h) => {
          c = Math.round(h), r(c);
        }
      }), r(100), u;
    }
    async loadModel(e) {
      return new Promise((r, n) => {
        rl.postMessage({
          cmd: xa.loadModel,
          data: {
            model: this.src,
            labels: this.labels
          }
        }), rl.onmessage = (i) => {
          var _a2;
          i.data.cmd === "loadModel" && ((_a2 = e == null ? void 0 : e.onProgress) == null ? void 0 : _a2.call(e, i.data.percent), i.data.percent === 100 && i.data.inputShape && (this.inputShape = i.data.inputShape, this.loaded = true, r(true)));
        };
      });
    }
    async detect(e, r) {
      return new Promise((n, i) => {
        rl.postMessage({
          cmd: xa.detect,
          data: {
            source: e,
            options: r
          }
        }), rl.onmessage = (a) => {
          n(a.data);
        };
      });
    }
    testRun() {
      return new Promise((e, r) => {
        this.inputShape && (rl.postMessage({
          cmd: xa.testRun
        }), rl.onmessage = (n) => {
          n.data ? e(n.data) : r(new Error("Test run failed"));
        });
      });
    }
    detectVideo(e, r = {
      once: false,
      scoreThreshold: 0.6
    }) {
      const n = async () => {
        var _a2, _b2, _c2, _d2;
        if (!this.detectState || this.loaded == null) {
          (_a2 = r.onOutput) == null ? void 0 : _a2.call(r, null);
          return;
        }
        if (e instanceof HTMLVideoElement && e.videoWidth === 0 && e.srcObject === null) {
          (_b2 = r.onOutput) == null ? void 0 : _b2.call(r, null);
          return;
        }
        if (e instanceof HTMLCanvasElement && e.width === 0) {
          (_c2 = r.onOutput) == null ? void 0 : _c2.call(r, null);
          return;
        }
        const [i, a] = this.getSourceSize(e), o = this.inputShape[2], s = Math.min(a, o) / a, l = parseInt((a * s).toString(), 10), u = parseInt((i * s).toString(), 10), c = await createImageBitmap(e, {
          resizeWidth: l,
          resizeHeight: u
        }), h = await this.detect(c, {
          scoreThreshold: r.scoreThreshold
        }), [f, d] = h.ratios;
        h.ratios = [
          f / s,
          d / s
        ], (_d2 = r.onOutput) == null ? void 0 : _d2.call(r, h), !(r.once && h.boxes.length) && (this.frameRate !== void 0 && this.frameRate !== 0 ? setTimeout(n, 1e3 / this.frameRate) : requestAnimationFrame(n));
      };
      this.detectState = true, n();
    }
    stop() {
      this.detectState = false;
    }
    dispose() {
      rl.postMessage({
        cmd: xa.disposeModel
      });
    }
    getSourceSize(e) {
      return e instanceof HTMLVideoElement ? [
        e.videoHeight,
        e.videoWidth
      ] : [
        e.height,
        e.width
      ];
    }
  }
  var I9 = ((t) => (t.tfjs = "tfjs", t.onnx = "onnx", t))(I9 || {});
  function Qbe(t) {
    switch (t.type) {
      case "tfjs":
        return $C.fromUrl(t.url, t.onProgress);
      case "onnx":
        return IC.fromUrl(t.url, t.onProgress);
      default:
        throw new Error("Model type not supported");
    }
  }
  class M9 {
    constructor(e) {
      __publicField(this, "_canvas");
      __publicField(this, "onSelect");
      this._canvas = e;
    }
  }
  class gB {
    constructor() {
      __publicField(this, "palette");
      __publicField(this, "n");
      __publicField(this, "get", (e) => this.palette[Math.floor(e) % this.n]);
      this.palette = [
        "#FF3838",
        "#FF9D97",
        "#FF701F",
        "#FFB21D",
        "#CFD231",
        "#48F90A",
        "#92CC17",
        "#3DDB86",
        "#1A9334",
        "#00D4BB",
        "#2C99A8",
        "#00C2FF",
        "#344593",
        "#6473FF",
        "#0018EC",
        "#8438FF",
        "#520085",
        "#CB38FF",
        "#FF95C8",
        "#FF37C7"
      ], this.n = this.palette.length;
    }
  }
  __publicField(gB, "hexToRgba", (e, r) => {
    const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return n ? `rgba(${[
      parseInt(n[1], 16),
      parseInt(n[2], 16),
      parseInt(n[3], 16)
    ].join(", ")}, ${r})` : null;
  });
  class Jbe extends M9 {
    init() {
      throw new Error("Method not implemented.");
    }
    render(e, r, n, i, a) {
      throw new Error("Method not implemented.");
    }
    clear() {
      throw new Error("Method not implemented.");
    }
    dispose() {
      throw new Error("Method not implemented.");
    }
    capture(e) {
      throw new Error("Method not implemented.");
    }
  }
  qt = ((t) => (t.Application = "application", t.WebGLPipes = "webgl-pipes", t.WebGLPipesAdaptor = "webgl-pipes-adaptor", t.WebGLSystem = "webgl-system", t.WebGPUPipes = "webgpu-pipes", t.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", t.WebGPUSystem = "webgpu-system", t.CanvasSystem = "canvas-system", t.CanvasPipesAdaptor = "canvas-pipes-adaptor", t.CanvasPipes = "canvas-pipes", t.Asset = "asset", t.LoadParser = "load-parser", t.ResolveParser = "resolve-parser", t.CacheParser = "cache-parser", t.DetectionParser = "detection-parser", t.MaskEffect = "mask-effect", t.BlendMode = "blend-mode", t.TextureSource = "texture-source", t.Environment = "environment", t.ShapeBuilder = "shape-builder", t.Batcher = "batcher", t))(qt || {});
  let lS, Dv, e1e, t1e;
  lS = (t) => {
    if (typeof t == "function" || typeof t == "object" && t.extension) {
      if (!t.extension) throw new Error("Extension class must have an extension object");
      t = {
        ...typeof t.extension != "object" ? {
          type: t.extension
        } : t.extension,
        ref: t
      };
    }
    if (typeof t == "object") t = {
      ...t
    };
    else throw new Error("Invalid extension type");
    return typeof t.type == "string" && (t.type = [
      t.type
    ]), t;
  };
  Dv = (t, e) => lS(t).priority ?? e;
  Ti = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...t) {
      return t.map(lS).forEach((e) => {
        e.type.forEach((r) => {
          var _a2, _b2;
          return (_b2 = (_a2 = this._removeHandlers)[r]) == null ? void 0 : _b2.call(_a2, e);
        });
      }), this;
    },
    add(...t) {
      return t.map(lS).forEach((e) => {
        e.type.forEach((r) => {
          var _a2, _b2;
          const n = this._addHandlers, i = this._queue;
          n[r] ? (_a2 = n[r]) == null ? void 0 : _a2.call(n, e) : (i[r] = i[r] || [], (_b2 = i[r]) == null ? void 0 : _b2.push(e));
        });
      }), this;
    },
    handle(t, e, r) {
      var _a2;
      const n = this._addHandlers, i = this._removeHandlers;
      if (n[t] || i[t]) throw new Error(`Extension type ${t} already has a handler`);
      n[t] = e, i[t] = r;
      const a = this._queue;
      return a[t] && ((_a2 = a[t]) == null ? void 0 : _a2.forEach((o) => e(o)), delete a[t]), this;
    },
    handleByMap(t, e) {
      return this.handle(t, (r) => {
        r.name && (e[r.name] = r.ref);
      }, (r) => {
        r.name && delete e[r.name];
      });
    },
    handleByNamedList(t, e, r = -1) {
      return this.handle(t, (n) => {
        e.findIndex((a) => a.name === n.name) >= 0 || (e.push({
          name: n.name,
          value: n.ref
        }), e.sort((a, o) => Dv(o.value, r) - Dv(a.value, r)));
      }, (n) => {
        const i = e.findIndex((a) => a.name === n.name);
        i !== -1 && e.splice(i, 1);
      });
    },
    handleByList(t, e, r = -1) {
      return this.handle(t, (n) => {
        e.includes(n.ref) || (e.push(n.ref), e.sort((i, a) => Dv(a, r) - Dv(i, r)));
      }, (n) => {
        const i = e.indexOf(n.ref);
        i !== -1 && e.splice(i, 1);
      });
    },
    mixin(t, ...e) {
      for (const r of e) Object.defineProperties(t.prototype, Object.getOwnPropertyDescriptors(r));
    }
  };
  e1e = {
    extension: {
      type: qt.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await Wl(() => import("./browserAll-aB6VSaJW.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([0,1,2,3,4,5,6]));
    }
  };
  t1e = {
    extension: {
      type: qt.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await Wl(() => import("./webworkerAll-Bznaa_Tn.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([1,2,3,4,5,6]));
    }
  };
  class In {
    constructor(e, r, n) {
      this._x = r || 0, this._y = n || 0, this._observer = e;
    }
    clone(e) {
      return new In(e ?? this._observer, this._x, this._y);
    }
    set(e = 0, r = e) {
      return (this._x !== e || this._y !== r) && (this._x = e, this._y = r, this._observer._onUpdate(this)), this;
    }
    copyFrom(e) {
      return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this;
    }
    copyTo(e) {
      return e.set(this._x, this._y), e;
    }
    equals(e) {
      return e.x === this._x && e.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x !== e && (this._x = e, this._observer._onUpdate(this));
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y !== e && (this._y = e, this._observer._onUpdate(this));
    }
  }
  var p1 = {
    exports: {}
  }, mB;
  function r1e() {
    return mB || (mB = 1, function(t) {
      var e = Object.prototype.hasOwnProperty, r = "~";
      function n() {
      }
      Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = false));
      function i(l, u, c) {
        this.fn = l, this.context = u, this.once = c || false;
      }
      function a(l, u, c, h, f) {
        if (typeof c != "function") throw new TypeError("The listener must be a function");
        var d = new i(c, h || l, f), p = r ? r + u : u;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [
          l._events[p],
          d
        ] : l._events[p].push(d) : (l._events[p] = d, l._eventsCount++), l;
      }
      function o(l, u) {
        --l._eventsCount === 0 ? l._events = new n() : delete l._events[u];
      }
      function s() {
        this._events = new n(), this._eventsCount = 0;
      }
      s.prototype.eventNames = function() {
        var u = [], c, h;
        if (this._eventsCount === 0) return u;
        for (h in c = this._events) e.call(c, h) && u.push(r ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u;
      }, s.prototype.listeners = function(u) {
        var c = r ? r + u : u, h = this._events[c];
        if (!h) return [];
        if (h.fn) return [
          h.fn
        ];
        for (var f = 0, d = h.length, p = new Array(d); f < d; f++) p[f] = h[f].fn;
        return p;
      }, s.prototype.listenerCount = function(u) {
        var c = r ? r + u : u, h = this._events[c];
        return h ? h.fn ? 1 : h.length : 0;
      }, s.prototype.emit = function(u, c, h, f, d, p) {
        var v = r ? r + u : u;
        if (!this._events[v]) return false;
        var g = this._events[v], m = arguments.length, y, _;
        if (g.fn) {
          switch (g.once && this.removeListener(u, g.fn, void 0, true), m) {
            case 1:
              return g.fn.call(g.context), true;
            case 2:
              return g.fn.call(g.context, c), true;
            case 3:
              return g.fn.call(g.context, c, h), true;
            case 4:
              return g.fn.call(g.context, c, h, f), true;
            case 5:
              return g.fn.call(g.context, c, h, f, d), true;
            case 6:
              return g.fn.call(g.context, c, h, f, d, p), true;
          }
          for (_ = 1, y = new Array(m - 1); _ < m; _++) y[_ - 1] = arguments[_];
          g.fn.apply(g.context, y);
        } else {
          var b = g.length, w;
          for (_ = 0; _ < b; _++) switch (g[_].once && this.removeListener(u, g[_].fn, void 0, true), m) {
            case 1:
              g[_].fn.call(g[_].context);
              break;
            case 2:
              g[_].fn.call(g[_].context, c);
              break;
            case 3:
              g[_].fn.call(g[_].context, c, h);
              break;
            case 4:
              g[_].fn.call(g[_].context, c, h, f);
              break;
            default:
              if (!y) for (w = 1, y = new Array(m - 1); w < m; w++) y[w - 1] = arguments[w];
              g[_].fn.apply(g[_].context, y);
          }
        }
        return true;
      }, s.prototype.on = function(u, c, h) {
        return a(this, u, c, h, false);
      }, s.prototype.once = function(u, c, h) {
        return a(this, u, c, h, true);
      }, s.prototype.removeListener = function(u, c, h, f) {
        var d = r ? r + u : u;
        if (!this._events[d]) return this;
        if (!c) return o(this, d), this;
        var p = this._events[d];
        if (p.fn) p.fn === c && (!f || p.once) && (!h || p.context === h) && o(this, d);
        else {
          for (var v = 0, g = [], m = p.length; v < m; v++) (p[v].fn !== c || f && !p[v].once || h && p[v].context !== h) && g.push(p[v]);
          g.length ? this._events[d] = g.length === 1 ? g[0] : g : o(this, d);
        }
        return this;
      }, s.prototype.removeAllListeners = function(u) {
        var c;
        return u ? (c = r ? r + u : u, this._events[c] && o(this, c)) : (this._events = new n(), this._eventsCount = 0), this;
      }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = r, s.EventEmitter = s, t.exports = s;
    }(p1)), p1.exports;
  }
  var n1e = r1e();
  let i1e, a1e, o1e;
  Fa = GS(n1e);
  i1e = Math.PI * 2;
  a1e = 180 / Math.PI;
  o1e = Math.PI / 180;
  rn = class {
    constructor(e = 0, r = 0) {
      this.x = 0, this.y = 0, this.x = e, this.y = r;
    }
    clone() {
      return new rn(this.x, this.y);
    }
    copyFrom(e) {
      return this.set(e.x, e.y), this;
    }
    copyTo(e) {
      return e.set(this.x, this.y), e;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    set(e = 0, r = e) {
      return this.x = e, this.y = r, this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
      return v1.x = 0, v1.y = 0, v1;
    }
  };
  const v1 = new rn();
  $t = class {
    constructor(e = 1, r = 0, n = 0, i = 1, a = 0, o = 0) {
      this.array = null, this.a = e, this.b = r, this.c = n, this.d = i, this.tx = a, this.ty = o;
    }
    fromArray(e) {
      this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
    }
    set(e, r, n, i, a, o) {
      return this.a = e, this.b = r, this.c = n, this.d = i, this.tx = a, this.ty = o, this;
    }
    toArray(e, r) {
      this.array || (this.array = new Float32Array(9));
      const n = r || this.array;
      return e ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n;
    }
    apply(e, r) {
      r = r || new rn();
      const n = e.x, i = e.y;
      return r.x = this.a * n + this.c * i + this.tx, r.y = this.b * n + this.d * i + this.ty, r;
    }
    applyInverse(e, r) {
      r = r || new rn();
      const n = this.a, i = this.b, a = this.c, o = this.d, s = this.tx, l = this.ty, u = 1 / (n * o + a * -i), c = e.x, h = e.y;
      return r.x = o * u * c + -a * u * h + (l * a - s * o) * u, r.y = n * u * h + -i * u * c + (-l * n + s * i) * u, r;
    }
    translate(e, r) {
      return this.tx += e, this.ty += r, this;
    }
    scale(e, r) {
      return this.a *= e, this.d *= r, this.c *= e, this.b *= r, this.tx *= e, this.ty *= r, this;
    }
    rotate(e) {
      const r = Math.cos(e), n = Math.sin(e), i = this.a, a = this.c, o = this.tx;
      return this.a = i * r - this.b * n, this.b = i * n + this.b * r, this.c = a * r - this.d * n, this.d = a * n + this.d * r, this.tx = o * r - this.ty * n, this.ty = o * n + this.ty * r, this;
    }
    append(e) {
      const r = this.a, n = this.b, i = this.c, a = this.d;
      return this.a = e.a * r + e.b * i, this.b = e.a * n + e.b * a, this.c = e.c * r + e.d * i, this.d = e.c * n + e.d * a, this.tx = e.tx * r + e.ty * i + this.tx, this.ty = e.tx * n + e.ty * a + this.ty, this;
    }
    appendFrom(e, r) {
      const n = e.a, i = e.b, a = e.c, o = e.d, s = e.tx, l = e.ty, u = r.a, c = r.b, h = r.c, f = r.d;
      return this.a = n * u + i * h, this.b = n * c + i * f, this.c = a * u + o * h, this.d = a * c + o * f, this.tx = s * u + l * h + r.tx, this.ty = s * c + l * f + r.ty, this;
    }
    setTransform(e, r, n, i, a, o, s, l, u) {
      return this.a = Math.cos(s + u) * a, this.b = Math.sin(s + u) * a, this.c = -Math.sin(s - l) * o, this.d = Math.cos(s - l) * o, this.tx = e - (n * this.a + i * this.c), this.ty = r - (n * this.b + i * this.d), this;
    }
    prepend(e) {
      const r = this.tx;
      if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
        const n = this.a, i = this.c;
        this.a = n * e.a + this.b * e.c, this.b = n * e.b + this.b * e.d, this.c = i * e.a + this.d * e.c, this.d = i * e.b + this.d * e.d;
      }
      return this.tx = r * e.a + this.ty * e.c + e.tx, this.ty = r * e.b + this.ty * e.d + e.ty, this;
    }
    decompose(e) {
      const r = this.a, n = this.b, i = this.c, a = this.d, o = e.pivot, s = -Math.atan2(-i, a), l = Math.atan2(n, r), u = Math.abs(s + l);
      return u < 1e-5 || Math.abs(i1e - u) < 1e-5 ? (e.rotation = l, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = s, e.skew.y = l), e.scale.x = Math.sqrt(r * r + n * n), e.scale.y = Math.sqrt(i * i + a * a), e.position.x = this.tx + (o.x * r + o.y * i), e.position.y = this.ty + (o.x * n + o.y * a), e;
    }
    invert() {
      const e = this.a, r = this.b, n = this.c, i = this.d, a = this.tx, o = e * i - r * n;
      return this.a = i / o, this.b = -r / o, this.c = -n / o, this.d = e / o, this.tx = (n * this.ty - i * a) / o, this.ty = -(e * this.ty - r * a) / o, this;
    }
    isIdentity() {
      return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    identity() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }
    clone() {
      const e = new $t();
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }
    copyTo(e) {
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }
    copyFrom(e) {
      return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
    }
    equals(e) {
      return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return l1e.identity();
    }
    static get shared() {
      return s1e.identity();
    }
  };
  const s1e = new $t(), l1e = new $t(), hl = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1
  ], fl = [
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], dl = [
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], pl = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1
  ], uS = [], D9 = [], Ev = Math.sign;
  function u1e() {
    for (let t = 0; t < 16; t++) {
      const e = [];
      uS.push(e);
      for (let r = 0; r < 16; r++) {
        const n = Ev(hl[t] * hl[r] + dl[t] * fl[r]), i = Ev(fl[t] * hl[r] + pl[t] * fl[r]), a = Ev(hl[t] * dl[r] + dl[t] * pl[r]), o = Ev(fl[t] * dl[r] + pl[t] * pl[r]);
        for (let s = 0; s < 16; s++) if (hl[s] === n && fl[s] === i && dl[s] === a && pl[s] === o) {
          e.push(s);
          break;
        }
      }
    }
    for (let t = 0; t < 16; t++) {
      const e = new $t();
      e.set(hl[t], fl[t], dl[t], pl[t], 0, 0), D9.push(e);
    }
  }
  u1e();
  const sr = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (t) => hl[t],
    uY: (t) => fl[t],
    vX: (t) => dl[t],
    vY: (t) => pl[t],
    inv: (t) => t & 8 ? t & 15 : -t & 7,
    add: (t, e) => uS[t][e],
    sub: (t, e) => uS[t][sr.inv(e)],
    rotate180: (t) => t ^ 4,
    isVertical: (t) => (t & 3) === 2,
    byDirection: (t, e) => Math.abs(t) * 2 <= Math.abs(e) ? e >= 0 ? sr.S : sr.N : Math.abs(e) * 2 <= Math.abs(t) ? t > 0 ? sr.E : sr.W : e > 0 ? t > 0 ? sr.SE : sr.SW : t > 0 ? sr.NE : sr.NW,
    matrixAppendRotationInv: (t, e, r = 0, n = 0) => {
      const i = D9[sr.inv(e)];
      i.tx = r, i.ty = n, t.append(i);
    }
  }, kv = [
    new rn(),
    new rn(),
    new rn(),
    new rn()
  ];
  Vr = class {
    constructor(e = 0, r = 0, n = 0, i = 0) {
      this.type = "rectangle", this.x = Number(e), this.y = Number(r), this.width = Number(n), this.height = Number(i);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new Vr(0, 0, 0, 0);
    }
    clone() {
      return new Vr(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(e) {
      return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    contains(e, r) {
      return this.width <= 0 || this.height <= 0 ? false : e >= this.x && e < this.x + this.width && r >= this.y && r < this.y + this.height;
    }
    strokeContains(e, r, n, i = 0.5) {
      const { width: a, height: o } = this;
      if (a <= 0 || o <= 0) return false;
      const s = this.x, l = this.y, u = n * (1 - i), c = n - u, h = s - u, f = s + a + u, d = l - u, p = l + o + u, v = s + c, g = s + a - c, m = l + c, y = l + o - c;
      return e >= h && e <= f && r >= d && r <= p && !(e > v && e < g && r > m && r < y);
    }
    intersects(e, r) {
      if (!r) {
        const A = this.x < e.x ? e.x : this.x;
        if ((this.right > e.right ? e.right : this.right) <= A) return false;
        const M = this.y < e.y ? e.y : this.y;
        return (this.bottom > e.bottom ? e.bottom : this.bottom) > M;
      }
      const n = this.left, i = this.right, a = this.top, o = this.bottom;
      if (i <= n || o <= a) return false;
      const s = kv[0].set(e.left, e.top), l = kv[1].set(e.left, e.bottom), u = kv[2].set(e.right, e.top), c = kv[3].set(e.right, e.bottom);
      if (u.x <= s.x || l.y <= s.y) return false;
      const h = Math.sign(r.a * r.d - r.b * r.c);
      if (h === 0 || (r.apply(s, s), r.apply(l, l), r.apply(u, u), r.apply(c, c), Math.max(s.x, l.x, u.x, c.x) <= n || Math.min(s.x, l.x, u.x, c.x) >= i || Math.max(s.y, l.y, u.y, c.y) <= a || Math.min(s.y, l.y, u.y, c.y) >= o)) return false;
      const f = h * (l.y - s.y), d = h * (s.x - l.x), p = f * n + d * a, v = f * i + d * a, g = f * n + d * o, m = f * i + d * o;
      if (Math.max(p, v, g, m) <= f * s.x + d * s.y || Math.min(p, v, g, m) >= f * c.x + d * c.y) return false;
      const y = h * (s.y - u.y), _ = h * (u.x - s.x), b = y * n + _ * a, w = y * i + _ * a, x = y * n + _ * o, T = y * i + _ * o;
      return !(Math.max(b, w, x, T) <= y * s.x + _ * s.y || Math.min(b, w, x, T) >= y * c.x + _ * c.y);
    }
    pad(e = 0, r = e) {
      return this.x -= e, this.y -= r, this.width += e * 2, this.height += r * 2, this;
    }
    fit(e) {
      const r = Math.max(this.x, e.x), n = Math.min(this.x + this.width, e.x + e.width), i = Math.max(this.y, e.y), a = Math.min(this.y + this.height, e.y + e.height);
      return this.x = r, this.width = Math.max(n - r, 0), this.y = i, this.height = Math.max(a - i, 0), this;
    }
    ceil(e = 1, r = 1e-3) {
      const n = Math.ceil((this.x + this.width - r) * e) / e, i = Math.ceil((this.y + this.height - r) * e) / e;
      return this.x = Math.floor((this.x + r) * e) / e, this.y = Math.floor((this.y + r) * e) / e, this.width = n - this.x, this.height = i - this.y, this;
    }
    enlarge(e) {
      const r = Math.min(this.x, e.x), n = Math.max(this.x + this.width, e.x + e.width), i = Math.min(this.y, e.y), a = Math.max(this.y + this.height, e.y + e.height);
      return this.x = r, this.width = n - r, this.y = i, this.height = a - i, this;
    }
    getBounds(e) {
      return e || (e = new Vr()), e.copyFrom(this), e;
    }
    containsRect(e) {
      if (this.width <= 0 || this.height <= 0) return false;
      const r = e.x, n = e.y, i = e.x + e.width, a = e.y + e.height;
      return r >= this.x && r < this.x + this.width && n >= this.y && n < this.y + this.height && i >= this.x && i < this.x + this.width && a >= this.y && a < this.y + this.height;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };
  const g1 = {
    default: -1
  };
  wr = function(t = "default") {
    return g1[t] === void 0 && (g1[t] = -1), ++g1[t];
  };
  let yB, c1e;
  yB = {};
  fr = "8.0.0";
  c1e = "8.3.4";
  Jt = function(t, e, r = 3) {
    if (yB[e]) return;
    let n = new Error().stack;
    typeof n > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${t}`) : (n = n.split(`
`).splice(r).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${t}`), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${t}`), console.warn(n))), yB[e] = true;
  };
  const E9 = () => {
  };
  _B = function(t) {
    return t += t === 0 ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t + 1;
  };
  function bB(t) {
    return !(t & t - 1) && !!t;
  }
  function k9(t) {
    const e = {};
    for (const r in t) t[r] !== void 0 && (e[r] = t[r]);
    return e;
  }
  const xB = /* @__PURE__ */ Object.create(null);
  function h1e(t) {
    const e = xB[t];
    return e === void 0 && (xB[t] = wr("resource")), e;
  }
  const P9 = class L9 extends Fa {
    constructor(e = {}) {
      super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = false, e = {
        ...L9.defaultOptions,
        ...e
      }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ?? this.addressModeU, this.addressModeV = e.addressModeV ?? this.addressModeV, this.addressModeW = e.addressModeW ?? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ?? this.magFilter, this.minFilter = e.minFilter ?? this.minFilter, this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ?? 1;
    }
    set addressMode(e) {
      this.addressModeU = e, this.addressModeV = e, this.addressModeW = e;
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(e) {
      Jt(fr, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e;
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(e) {
      this.magFilter = e, this.minFilter = e, this.mipmapFilter = e;
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(e) {
      this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this), this._sharedResourceId = null;
    }
    _generateResourceId() {
      const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      return this._sharedResourceId = h1e(e), this._resourceId;
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
    }
  };
  P9.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  f1e = P9;
  const $9 = class R9 extends Fa {
    constructor(e = {}) {
      super(), this.options = e, this.uid = wr("textureSource"), this._resourceType = "textureSource", this._resourceId = wr("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = false, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = false, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = {
        ...R9.defaultOptions,
        ...e
      }, this.label = e.label ?? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new f1e(k9(e)), this.destroyed = false, this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(e) {
      var _a2, _b2;
      this.style !== e && ((_a2 = this._style) == null ? void 0 : _a2.off("change", this._onStyleChange, this), this._style = e, (_b2 = this._style) == null ? void 0 : _b2.on("change", this._onStyleChange, this), this._onStyleChange());
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(e) {
      this._style.addressMode = e;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(e) {
      this._style.addressMode = e;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(e) {
      this._style.magFilter = e;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(e) {
      this._style.minFilter = e;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(e) {
      this._style.mipmapFilter = e;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(e) {
      this._style.lodMinClamp = e;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(e) {
      this._style.lodMaxClamp = e;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const e = this._resolution;
        if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return;
      }
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
    }
    unload() {
      this._resourceId = wr("resource"), this.emit("change", this), this.emit("unload", this);
    }
    get resourceWidth() {
      const { resource: e } = this;
      return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
    }
    get resourceHeight() {
      const { resource: e } = this;
      return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e);
    }
    resize(e, r, n) {
      n || (n = this._resolution), e || (e = this.width), r || (r = this.height);
      const i = Math.round(e * n), a = Math.round(r * n);
      return this.width = i / n, this.height = a / n, this._resolution = n, this.pixelWidth === i && this.pixelHeight === a ? false : (this._refreshPOT(), this.pixelWidth = i, this.pixelHeight = a, this.emit("resize", this), this._resourceId = wr("resource"), this.emit("change", this), true);
    }
    updateMipmaps() {
      this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
    }
    set wrapMode(e) {
      this._style.wrapMode = e;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(e) {
      this._style.scaleMode = e;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = bB(this.pixelWidth) && bB(this.pixelHeight);
    }
    static test(e) {
      throw new Error("Unimplemented");
    }
  };
  $9.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
    autoGarbageCollect: false
  };
  ta = $9;
  class RC extends ta {
    constructor(e) {
      const r = e.resource || new Float32Array(e.width * e.height * 4);
      let n = e.format;
      n || (r instanceof Float32Array ? n = "rgba32float" : r instanceof Int32Array || r instanceof Uint32Array ? n = "rgba32uint" : r instanceof Int16Array || r instanceof Uint16Array ? n = "rgba16uint" : (r instanceof Int8Array, n = "bgra8unorm")), super({
        ...e,
        resource: r,
        format: n
      }), this.uploadMethodId = "buffer";
    }
    static test(e) {
      return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array;
    }
  }
  RC.extension = qt.TextureSource;
  const wB = new $t();
  d1e = class {
    constructor(e, r) {
      this.mapCoord = new $t(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof r > "u" ? this.clampMargin = e.width < 10 ? 0 : 0.5 : this.clampMargin = r, this.isSimple = false, this.texture = e;
    }
    get texture() {
      return this._texture;
    }
    set texture(e) {
      var _a2;
      this.texture !== e && ((_a2 = this._texture) == null ? void 0 : _a2.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update());
    }
    multiplyUvs(e, r) {
      r === void 0 && (r = e);
      const n = this.mapCoord;
      for (let i = 0; i < e.length; i += 2) {
        const a = e[i], o = e[i + 1];
        r[i] = a * n.a + o * n.c + n.tx, r[i + 1] = a * n.b + o * n.d + n.ty;
      }
      return r;
    }
    update() {
      const e = this._texture;
      this._updateID++;
      const r = e.uvs;
      this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
      const n = e.orig, i = e.trim;
      i && (wB.set(n.width / i.width, 0, 0, n.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(wB));
      const a = e.source, o = this.uClampFrame, s = this.clampMargin / a._resolution, l = this.clampOffset / a._resolution;
      return o[0] = (e.frame.x + s + l) / a.width, o[1] = (e.frame.y + s + l) / a.height, o[2] = (e.frame.x + e.frame.width - s + l) / a.width, o[3] = (e.frame.y + e.frame.height - s + l) / a.height, this.uClampOffset[0] = this.clampOffset / a.pixelWidth, this.uClampOffset[1] = this.clampOffset / a.pixelHeight, this.isSimple = e.frame.width === a.width && e.frame.height === a.height && e.rotate === 0, true;
    }
  };
  Kt = class extends Fa {
    constructor({ source: e, label: r, frame: n, orig: i, trim: a, defaultAnchor: o, defaultBorders: s, rotate: l, dynamic: u } = {}) {
      if (super(), this.uid = wr("texture"), this.uvs = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        x3: 0,
        y3: 0
      }, this.frame = new Vr(), this.noFrame = false, this.dynamic = false, this.isTexture = true, this.label = r, this.source = (e == null ? void 0 : e.source) ?? new ta(), this.noFrame = !n, n) this.frame.copyFrom(n);
      else {
        const { width: c, height: h } = this._source;
        this.frame.width = c, this.frame.height = h;
      }
      this.orig = i || this.frame, this.trim = a, this.rotate = l ?? 0, this.defaultAnchor = o, this.defaultBorders = s, this.destroyed = false, this.dynamic = u || false, this.updateUvs();
    }
    set source(e) {
      this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      return this._textureMatrix || (this._textureMatrix = new d1e(this)), this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const { uvs: e, frame: r } = this, { width: n, height: i } = this._source, a = r.x / n, o = r.y / i, s = r.width / n, l = r.height / i;
      let u = this.rotate;
      if (u) {
        const c = s / 2, h = l / 2, f = a + c, d = o + h;
        u = sr.add(u, sr.NW), e.x0 = f + c * sr.uX(u), e.y0 = d + h * sr.uY(u), u = sr.add(u, 2), e.x1 = f + c * sr.uX(u), e.y1 = d + h * sr.uY(u), u = sr.add(u, 2), e.x2 = f + c * sr.uX(u), e.y2 = d + h * sr.uY(u), u = sr.add(u, 2), e.x3 = f + c * sr.uX(u), e.y3 = d + h * sr.uY(u);
      } else e.x0 = a, e.y0 = o, e.x1 = a + s, e.y1 = o, e.x2 = a + s, e.y2 = o + l, e.x3 = a, e.y3 = o + l;
    }
    destroy(e = false) {
      this._source && e && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = true, this.emit("destroy", this), this.removeAllListeners();
    }
    update() {
      this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
    }
    get baseTexture() {
      return Jt(fr, "Texture.baseTexture is now Texture.source"), this._source;
    }
  };
  Kt.EMPTY = new Kt({
    label: "EMPTY",
    source: new ta({
      label: "EMPTY"
    })
  });
  Kt.EMPTY.destroy = E9;
  Kt.WHITE = new Kt({
    source: new RC({
      resource: new Uint8Array([
        255,
        255,
        255,
        255
      ]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  Kt.WHITE.destroy = E9;
  p1e = function(t, e, r) {
    const { width: n, height: i } = r.orig, a = r.trim;
    if (a) {
      const o = a.width, s = a.height;
      t.minX = a.x - e._x * n, t.maxX = t.minX + o, t.minY = a.y - e._y * i, t.maxY = t.minY + s;
    } else t.minX = -e._x * n, t.maxX = t.minX + n, t.minY = -e._y * i, t.maxY = t.minY + i;
  };
  const SB = new $t();
  Zi = class {
    constructor(e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0) {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = SB, this.minX = e, this.minY = r, this.maxX = n, this.maxY = i;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      this._rectangle || (this._rectangle = new Vr());
      const e = this._rectangle;
      return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e;
    }
    clear() {
      return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = SB, this;
    }
    set(e, r, n, i) {
      this.minX = e, this.minY = r, this.maxX = n, this.maxY = i;
    }
    addFrame(e, r, n, i, a) {
      a || (a = this.matrix);
      const o = a.a, s = a.b, l = a.c, u = a.d, c = a.tx, h = a.ty;
      let f = this.minX, d = this.minY, p = this.maxX, v = this.maxY, g = o * e + l * r + c, m = s * e + u * r + h;
      g < f && (f = g), m < d && (d = m), g > p && (p = g), m > v && (v = m), g = o * n + l * r + c, m = s * n + u * r + h, g < f && (f = g), m < d && (d = m), g > p && (p = g), m > v && (v = m), g = o * e + l * i + c, m = s * e + u * i + h, g < f && (f = g), m < d && (d = m), g > p && (p = g), m > v && (v = m), g = o * n + l * i + c, m = s * n + u * i + h, g < f && (f = g), m < d && (d = m), g > p && (p = g), m > v && (v = m), this.minX = f, this.minY = d, this.maxX = p, this.maxY = v;
    }
    addRect(e, r) {
      this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, r);
    }
    addBounds(e, r) {
      this.addFrame(e.minX, e.minY, e.maxX, e.maxY, r);
    }
    addBoundsMask(e) {
      this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY;
    }
    applyMatrix(e) {
      const r = this.minX, n = this.minY, i = this.maxX, a = this.maxY, { a: o, b: s, c: l, d: u, tx: c, ty: h } = e;
      let f = o * r + l * n + c, d = s * r + u * n + h;
      this.minX = f, this.minY = d, this.maxX = f, this.maxY = d, f = o * i + l * n + c, d = s * i + u * n + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, f = o * r + l * a + c, d = s * r + u * a + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY, f = o * i + l * a + c, d = s * i + u * a + h, this.minX = f < this.minX ? f : this.minX, this.minY = d < this.minY ? d : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = d > this.maxY ? d : this.maxY;
    }
    fit(e) {
      return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this;
    }
    fitBounds(e, r, n, i) {
      return this.minX < e && (this.minX = e), this.maxX > r && (this.maxX = r), this.minY < n && (this.minY = n), this.maxY > i && (this.maxY = i), this;
    }
    pad(e, r = e) {
      return this.minX -= e, this.maxX += e, this.minY -= r, this.maxY += r, this;
    }
    ceil() {
      return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
    }
    clone() {
      return new Zi(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(e, r = e) {
      return this.minX *= e, this.minY *= r, this.maxX *= e, this.maxY *= r, this;
    }
    get x() {
      return this.minX;
    }
    set x(e) {
      const r = this.maxX - this.minX;
      this.minX = e, this.maxX = e + r;
    }
    get y() {
      return this.minY;
    }
    set y(e) {
      const r = this.maxY - this.minY;
      this.minY = e, this.maxY = e + r;
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(e) {
      this.maxX = this.minX + e;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(e) {
      this.maxY = this.minY + e;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== 1 / 0;
    }
    addVertexData(e, r, n, i) {
      let a = this.minX, o = this.minY, s = this.maxX, l = this.maxY;
      i || (i = this.matrix);
      const u = i.a, c = i.b, h = i.c, f = i.d, d = i.tx, p = i.ty;
      for (let v = r; v < n; v += 2) {
        const g = e[v], m = e[v + 1], y = u * g + h * m + d, _ = c * g + f * m + p;
        a = y < a ? y : a, o = _ < o ? _ : o, s = y > s ? y : s, l = _ > l ? _ : l;
      }
      this.minX = a, this.minY = o, this.maxX = s, this.maxY = l;
    }
    containsPoint(e, r) {
      return this.minX <= e && this.minY <= r && this.maxX >= e && this.maxY >= r;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    copyFrom(e) {
      return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this;
    }
  };
  var v1e = {
    grad: 0.9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  }, qa = function(t) {
    return typeof t == "string" ? t.length > 0 : typeof t == "number";
  }, zr = function(t, e, r) {
    return e === void 0 && (e = 0), r === void 0 && (r = Math.pow(10, e)), Math.round(r * t) / r + 0;
  }, yi = function(t, e, r) {
    return e === void 0 && (e = 0), r === void 0 && (r = 1), t > r ? r : t > e ? t : e;
  }, O9 = function(t) {
    return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360;
  }, TB = function(t) {
    return {
      r: yi(t.r, 0, 255),
      g: yi(t.g, 0, 255),
      b: yi(t.b, 0, 255),
      a: yi(t.a)
    };
  }, m1 = function(t) {
    return {
      r: zr(t.r),
      g: zr(t.g),
      b: zr(t.b),
      a: zr(t.a, 3)
    };
  }, g1e = /^#([0-9a-f]{3,8})$/i, Pv = function(t) {
    var e = t.toString(16);
    return e.length < 2 ? "0" + e : e;
  }, N9 = function(t) {
    var e = t.r, r = t.g, n = t.b, i = t.a, a = Math.max(e, r, n), o = a - Math.min(e, r, n), s = o ? a === e ? (r - n) / o : a === r ? 2 + (n - e) / o : 4 + (e - r) / o : 0;
    return {
      h: 60 * (s < 0 ? s + 6 : s),
      s: a ? o / a * 100 : 0,
      v: a / 255 * 100,
      a: i
    };
  }, B9 = function(t) {
    var e = t.h, r = t.s, n = t.v, i = t.a;
    e = e / 360 * 6, r /= 100, n /= 100;
    var a = Math.floor(e), o = n * (1 - r), s = n * (1 - (e - a) * r), l = n * (1 - (1 - e + a) * r), u = a % 6;
    return {
      r: 255 * [
        n,
        s,
        o,
        o,
        l,
        n
      ][u],
      g: 255 * [
        l,
        n,
        n,
        s,
        o,
        o
      ][u],
      b: 255 * [
        o,
        o,
        l,
        n,
        n,
        s
      ][u],
      a: i
    };
  }, CB = function(t) {
    return {
      h: O9(t.h),
      s: yi(t.s, 0, 100),
      l: yi(t.l, 0, 100),
      a: yi(t.a)
    };
  }, AB = function(t) {
    return {
      h: zr(t.h),
      s: zr(t.s),
      l: zr(t.l),
      a: zr(t.a, 3)
    };
  }, IB = function(t) {
    return B9((r = (e = t).s, {
      h: e.h,
      s: (r *= ((n = e.l) < 50 ? n : 100 - n) / 100) > 0 ? 2 * r / (n + r) * 100 : 0,
      v: n + r,
      a: e.a
    }));
    var e, r, n;
  }, $f = function(t) {
    return {
      h: (e = N9(t)).h,
      s: (i = (200 - (r = e.s)) * (n = e.v) / 100) > 0 && i < 200 ? r * n / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
      l: i / 2,
      a: e.a
    };
    var e, r, n, i;
  }, m1e = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, y1e = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, _1e = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, b1e = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, cS = {
    string: [
      [
        function(t) {
          var e = g1e.exec(t);
          return e ? (t = e[1]).length <= 4 ? {
            r: parseInt(t[0] + t[0], 16),
            g: parseInt(t[1] + t[1], 16),
            b: parseInt(t[2] + t[2], 16),
            a: t.length === 4 ? zr(parseInt(t[3] + t[3], 16) / 255, 2) : 1
          } : t.length === 6 || t.length === 8 ? {
            r: parseInt(t.substr(0, 2), 16),
            g: parseInt(t.substr(2, 2), 16),
            b: parseInt(t.substr(4, 2), 16),
            a: t.length === 8 ? zr(parseInt(t.substr(6, 2), 16) / 255, 2) : 1
          } : null : null;
        },
        "hex"
      ],
      [
        function(t) {
          var e = _1e.exec(t) || b1e.exec(t);
          return e ? e[2] !== e[4] || e[4] !== e[6] ? null : TB({
            r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
            g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
            b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
            a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
          }) : null;
        },
        "rgb"
      ],
      [
        function(t) {
          var e = m1e.exec(t) || y1e.exec(t);
          if (!e) return null;
          var r, n, i = CB({
            h: (r = e[1], n = e[2], n === void 0 && (n = "deg"), Number(r) * (v1e[n] || 1)),
            s: Number(e[3]),
            l: Number(e[4]),
            a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
          });
          return IB(i);
        },
        "hsl"
      ]
    ],
    object: [
      [
        function(t) {
          var e = t.r, r = t.g, n = t.b, i = t.a, a = i === void 0 ? 1 : i;
          return qa(e) && qa(r) && qa(n) ? TB({
            r: Number(e),
            g: Number(r),
            b: Number(n),
            a: Number(a)
          }) : null;
        },
        "rgb"
      ],
      [
        function(t) {
          var e = t.h, r = t.s, n = t.l, i = t.a, a = i === void 0 ? 1 : i;
          if (!qa(e) || !qa(r) || !qa(n)) return null;
          var o = CB({
            h: Number(e),
            s: Number(r),
            l: Number(n),
            a: Number(a)
          });
          return IB(o);
        },
        "hsl"
      ],
      [
        function(t) {
          var e = t.h, r = t.s, n = t.v, i = t.a, a = i === void 0 ? 1 : i;
          if (!qa(e) || !qa(r) || !qa(n)) return null;
          var o = function(s) {
            return {
              h: O9(s.h),
              s: yi(s.s, 0, 100),
              v: yi(s.v, 0, 100),
              a: yi(s.a)
            };
          }({
            h: Number(e),
            s: Number(r),
            v: Number(n),
            a: Number(a)
          });
          return B9(o);
        },
        "hsv"
      ]
    ]
  }, MB = function(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r][0](t);
      if (n) return [
        n,
        e[r][1]
      ];
    }
    return [
      null,
      void 0
    ];
  }, x1e = function(t) {
    return typeof t == "string" ? MB(t.trim(), cS.string) : typeof t == "object" && t !== null ? MB(t, cS.object) : [
      null,
      void 0
    ];
  }, y1 = function(t, e) {
    var r = $f(t);
    return {
      h: r.h,
      s: yi(r.s + 100 * e, 0, 100),
      l: r.l,
      a: r.a
    };
  }, _1 = function(t) {
    return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255;
  }, DB = function(t, e) {
    var r = $f(t);
    return {
      h: r.h,
      s: r.s,
      l: yi(r.l + 100 * e, 0, 100),
      a: r.a
    };
  }, hS = function() {
    function t(e) {
      this.parsed = x1e(e)[0], this.rgba = this.parsed || {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      };
    }
    return t.prototype.isValid = function() {
      return this.parsed !== null;
    }, t.prototype.brightness = function() {
      return zr(_1(this.rgba), 2);
    }, t.prototype.isDark = function() {
      return _1(this.rgba) < 0.5;
    }, t.prototype.isLight = function() {
      return _1(this.rgba) >= 0.5;
    }, t.prototype.toHex = function() {
      return e = m1(this.rgba), r = e.r, n = e.g, i = e.b, o = (a = e.a) < 1 ? Pv(zr(255 * a)) : "", "#" + Pv(r) + Pv(n) + Pv(i) + o;
      var e, r, n, i, a, o;
    }, t.prototype.toRgb = function() {
      return m1(this.rgba);
    }, t.prototype.toRgbString = function() {
      return e = m1(this.rgba), r = e.r, n = e.g, i = e.b, (a = e.a) < 1 ? "rgba(" + r + ", " + n + ", " + i + ", " + a + ")" : "rgb(" + r + ", " + n + ", " + i + ")";
      var e, r, n, i, a;
    }, t.prototype.toHsl = function() {
      return AB($f(this.rgba));
    }, t.prototype.toHslString = function() {
      return e = AB($f(this.rgba)), r = e.h, n = e.s, i = e.l, (a = e.a) < 1 ? "hsla(" + r + ", " + n + "%, " + i + "%, " + a + ")" : "hsl(" + r + ", " + n + "%, " + i + "%)";
      var e, r, n, i, a;
    }, t.prototype.toHsv = function() {
      return e = N9(this.rgba), {
        h: zr(e.h),
        s: zr(e.s),
        v: zr(e.v),
        a: zr(e.a, 3)
      };
      var e;
    }, t.prototype.invert = function() {
      return va({
        r: 255 - (e = this.rgba).r,
        g: 255 - e.g,
        b: 255 - e.b,
        a: e.a
      });
      var e;
    }, t.prototype.saturate = function(e) {
      return e === void 0 && (e = 0.1), va(y1(this.rgba, e));
    }, t.prototype.desaturate = function(e) {
      return e === void 0 && (e = 0.1), va(y1(this.rgba, -e));
    }, t.prototype.grayscale = function() {
      return va(y1(this.rgba, -1));
    }, t.prototype.lighten = function(e) {
      return e === void 0 && (e = 0.1), va(DB(this.rgba, e));
    }, t.prototype.darken = function(e) {
      return e === void 0 && (e = 0.1), va(DB(this.rgba, -e));
    }, t.prototype.rotate = function(e) {
      return e === void 0 && (e = 15), this.hue(this.hue() + e);
    }, t.prototype.alpha = function(e) {
      return typeof e == "number" ? va({
        r: (r = this.rgba).r,
        g: r.g,
        b: r.b,
        a: e
      }) : zr(this.rgba.a, 3);
      var r;
    }, t.prototype.hue = function(e) {
      var r = $f(this.rgba);
      return typeof e == "number" ? va({
        h: e,
        s: r.s,
        l: r.l,
        a: r.a
      }) : zr(r.h);
    }, t.prototype.isEqual = function(e) {
      return this.toHex() === va(e).toHex();
    }, t;
  }(), va = function(t) {
    return t instanceof hS ? t : new hS(t);
  }, EB = [], w1e = function(t) {
    t.forEach(function(e) {
      EB.indexOf(e) < 0 && (e(hS, cS), EB.push(e));
    });
  };
  function S1e(t, e) {
    var r = {
      white: "#ffffff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000"
    }, n = {};
    for (var i in r) n[r[i]] = i;
    var a = {};
    t.prototype.toName = function(o) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var s, l, u = n[this.toHex()];
      if (u) return u;
      if (o == null ? void 0 : o.closest) {
        var c = this.toRgb(), h = 1 / 0, f = "black";
        if (!a.length) for (var d in r) a[d] = new t(r[d]).toRgb();
        for (var p in r) {
          var v = (s = c, l = a[p], Math.pow(s.r - l.r, 2) + Math.pow(s.g - l.g, 2) + Math.pow(s.b - l.b, 2));
          v < h && (h = v, f = p);
        }
        return f;
      }
    }, e.string.push([
      function(o) {
        var s = o.toLowerCase(), l = s === "transparent" ? "#0000" : r[s];
        return l ? new t(l).toRgb() : null;
      },
      "name"
    ]);
  }
  w1e([
    S1e
  ]);
  const Ec = class pf {
    constructor(e = 16777215) {
      this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e;
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(e) {
      return this.value = e, this;
    }
    set value(e) {
      if (e instanceof pf) this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components);
      else {
        if (e === null) throw new Error("Cannot set Color#value to null");
        (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value));
      }
    }
    get value() {
      return this._value;
    }
    _cloneSource(e) {
      return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? {
        ...e
      } : e;
    }
    _isSourceEqual(e, r) {
      const n = typeof e;
      if (n !== typeof r) return false;
      if (n === "number" || n === "string" || e instanceof Number) return e === r;
      if (Array.isArray(e) && Array.isArray(r) || ArrayBuffer.isView(e) && ArrayBuffer.isView(r)) return e.length !== r.length ? false : e.every((a, o) => a === r[o]);
      if (e !== null && r !== null) {
        const a = Object.keys(e), o = Object.keys(r);
        return a.length !== o.length ? false : a.every((s) => e[s] === r[s]);
      }
      return e === r;
    }
    toRgba() {
      const [e, r, n, i] = this._components;
      return {
        r: e,
        g: r,
        b: n,
        a: i
      };
    }
    toRgb() {
      const [e, r, n] = this._components;
      return {
        r: e,
        g: r,
        b: n
      };
    }
    toRgbaString() {
      const [e, r, n] = this.toUint8RgbArray();
      return `rgba(${e},${r},${n},${this.alpha})`;
    }
    toUint8RgbArray(e) {
      const [r, n, i] = this._components;
      return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(r * 255), e[1] = Math.round(n * 255), e[2] = Math.round(i * 255), e;
    }
    toArray(e) {
      this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
      const [r, n, i, a] = this._components;
      return e[0] = r, e[1] = n, e[2] = i, e[3] = a, e;
    }
    toRgbArray(e) {
      this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
      const [r, n, i] = this._components;
      return e[0] = r, e[1] = n, e[2] = i, e;
    }
    toNumber() {
      return this._int;
    }
    toBgrNumber() {
      const [e, r, n] = this.toUint8RgbArray();
      return (n << 16) + (r << 8) + e;
    }
    toLittleEndianNumber() {
      const e = this._int;
      return (e >> 16) + (e & 65280) + ((e & 255) << 16);
    }
    multiply(e) {
      const [r, n, i, a] = pf._temp.setValue(e)._components;
      return this._components[0] *= r, this._components[1] *= n, this._components[2] *= i, this._components[3] *= a, this._refreshInt(), this._value = null, this;
    }
    premultiply(e, r = true) {
      return r && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this;
    }
    toPremultiplied(e, r = true) {
      if (e === 1) return (255 << 24) + this._int;
      if (e === 0) return r ? 0 : this._int;
      let n = this._int >> 16 & 255, i = this._int >> 8 & 255, a = this._int & 255;
      return r && (n = n * e + 0.5 | 0, i = i * e + 0.5 | 0, a = a * e + 0.5 | 0), (e * 255 << 24) + (n << 16) + (i << 8) + a;
    }
    toHex() {
      const e = this._int.toString(16);
      return `#${"000000".substring(0, 6 - e.length) + e}`;
    }
    toHexa() {
      const r = Math.round(this._components[3] * 255).toString(16);
      return this.toHex() + "00".substring(0, 2 - r.length) + r;
    }
    setAlpha(e) {
      return this._components[3] = this._clamp(e), this;
    }
    _normalize(e) {
      let r, n, i, a;
      if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
        const o = e;
        r = (o >> 16 & 255) / 255, n = (o >> 8 & 255) / 255, i = (o & 255) / 255, a = 1;
      } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [r, n, i, a = 1] = e;
      else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [r, n, i, a = 255] = e, r /= 255, n /= 255, i /= 255, a /= 255;
      else if (typeof e == "string" || typeof e == "object") {
        if (typeof e == "string") {
          const s = pf.HEX_PATTERN.exec(e);
          s && (e = `#${s[2]}`);
        }
        const o = va(e);
        o.isValid() && ({ r, g: n, b: i, a } = o.rgba, r /= 255, n /= 255, i /= 255);
      }
      if (r !== void 0) this._components[0] = r, this._components[1] = n, this._components[2] = i, this._components[3] = a, this._refreshInt();
      else throw new Error(`Unable to convert color ${e}`);
    }
    _refreshInt() {
      this._clamp(this._components);
      const [e, r, n] = this._components;
      this._int = (e * 255 << 16) + (r * 255 << 8) + (n * 255 | 0);
    }
    _clamp(e, r = 0, n = 1) {
      return typeof e == "number" ? Math.min(Math.max(e, r), n) : (e.forEach((i, a) => {
        e[a] = Math.min(Math.max(i, r), n);
      }), e);
    }
    static isColorLike(e) {
      return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof pf || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0;
    }
  };
  Ec.shared = new Ec();
  Ec._temp = new Ec();
  Ec.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  an = Ec;
  const T1e = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
  };
  class OC {
    constructor(e, r) {
      this._pool = [], this._count = 0, this._index = 0, this._classType = e, r && this.prepopulate(r);
    }
    prepopulate(e) {
      for (let r = 0; r < e; r++) this._pool[this._index++] = new this._classType();
      this._count += e;
    }
    get(e) {
      var _a2;
      let r;
      return this._index > 0 ? r = this._pool[--this._index] : r = new this._classType(), (_a2 = r.init) == null ? void 0 : _a2.call(r, e), r;
    }
    return(e) {
      var _a2;
      (_a2 = e.reset) == null ? void 0 : _a2.call(e), this._pool[this._index++] = e;
    }
    get totalSize() {
      return this._count;
    }
    get totalFree() {
      return this._index;
    }
    get totalUsed() {
      return this._count - this._index;
    }
    clear() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class C1e {
    constructor() {
      this._poolsByClass = /* @__PURE__ */ new Map();
    }
    prepopulate(e, r) {
      this.getPool(e).prepopulate(r);
    }
    get(e, r) {
      return this.getPool(e).get(r);
    }
    return(e) {
      this.getPool(e.constructor).return(e);
    }
    getPool(e) {
      return this._poolsByClass.has(e) || this._poolsByClass.set(e, new OC(e)), this._poolsByClass.get(e);
    }
    stats() {
      const e = {};
      return this._poolsByClass.forEach((r) => {
        const n = e[r._classType.name] ? r._classType.name + r._classType.ID : r._classType.name;
        e[n] = {
          free: r.totalFree,
          used: r.totalUsed,
          size: r.totalSize
        };
      }), e;
    }
  }
  let A1e;
  lo = new C1e();
  A1e = {
    get isCachedAsTexture() {
      var _a2;
      return !!((_a2 = this.renderGroup) == null ? void 0 : _a2.isCachedAsTexture);
    },
    cacheAsTexture(t) {
      typeof t == "boolean" && t === false ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(t === true ? {} : t));
    },
    updateCacheTexture() {
      var _a2;
      (_a2 = this.renderGroup) == null ? void 0 : _a2.updateCacheTexture();
    },
    get cacheAsBitmap() {
      return this.isCachedAsTexture;
    },
    set cacheAsBitmap(t) {
      Jt("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(t);
    }
  };
  I1e = function(t, e, r) {
    const n = t.length;
    let i;
    if (e >= n || r === 0) return;
    r = e + r > n ? n - e : r;
    const a = n - r;
    for (i = e; i < a; ++i) t[i] = t[i + r];
    t.length = a;
  };
  const M1e = {
    allowChildren: true,
    removeChildren(t = 0, e) {
      const r = e ?? this.children.length, n = r - t, i = [];
      if (n > 0 && n <= r) {
        for (let o = r - 1; o >= t; o--) {
          const s = this.children[o];
          s && (i.push(s), s.parent = null);
        }
        I1e(this.children, t, r);
        const a = this.renderGroup || this.parentRenderGroup;
        a && a.removeChildren(i);
        for (let o = 0; o < i.length; ++o) this.emit("childRemoved", i[o], this, o), i[o].emit("removed", this);
        return i.length > 0 && this._didViewChangeTick++, i;
      } else if (n === 0 && this.children.length === 0) return i;
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt(t) {
      const e = this.getChildAt(t);
      return this.removeChild(e);
    },
    getChildAt(t) {
      if (t < 0 || t >= this.children.length) throw new Error(`getChildAt: Index (${t}) does not exist.`);
      return this.children[t];
    },
    setChildIndex(t, e) {
      if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
      this.getChildIndex(t), this.addChildAt(t, e);
    },
    getChildIndex(t) {
      const e = this.children.indexOf(t);
      if (e === -1) throw new Error("The supplied Container must be a child of the caller");
      return e;
    },
    addChildAt(t, e) {
      this.allowChildren || Jt(fr, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      const { children: r } = this;
      if (e < 0 || e > r.length) throw new Error(`${t}addChildAt: The index ${e} supplied is out of bounds ${r.length}`);
      if (t.parent) {
        const i = t.parent.children.indexOf(t);
        if (t.parent === this && i === e) return t;
        i !== -1 && t.parent.children.splice(i, 1);
      }
      e === r.length ? r.push(t) : r.splice(e, 0, t), t.parent = this, t.didChange = true, t._updateFlags = 15;
      const n = this.renderGroup || this.parentRenderGroup;
      return n && n.addChild(t), this.sortableChildren && (this.sortDirty = true), this.emit("childAdded", t, this, e), t.emit("added", this), t;
    },
    swapChildren(t, e) {
      if (t === e) return;
      const r = this.getChildIndex(t), n = this.getChildIndex(e);
      this.children[r] = e, this.children[n] = t;
      const i = this.renderGroup || this.parentRenderGroup;
      i && (i.structureDidChange = true), this._didContainerChangeTick++;
    },
    removeFromParent() {
      var _a2;
      (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
    },
    reparentChild(...t) {
      return t.length === 1 ? this.reparentChildAt(t[0], this.children.length) : (t.forEach((e) => this.reparentChildAt(e, this.children.length)), t[0]);
    },
    reparentChildAt(t, e) {
      if (t.parent === this) return this.setChildIndex(t, e), t;
      const r = t.worldTransform.clone();
      t.removeFromParent(), this.addChildAt(t, e);
      const n = this.worldTransform.clone();
      return n.invert(), r.prepend(n), t.setFromMatrix(r), t;
    }
  }, D1e = {
    collectRenderables(t, e, r) {
      this.parentRenderLayer && this.parentRenderLayer !== r || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(t, e, r) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, t) : this.collectRenderablesWithEffects(t, e, r));
    },
    collectRenderablesSimple(t, e, r) {
      const n = this.children, i = n.length;
      for (let a = 0; a < i; a++) n[a].collectRenderables(t, e, r);
    },
    collectRenderablesWithEffects(t, e, r) {
      const { renderPipes: n } = e;
      for (let i = 0; i < this.effects.length; i++) {
        const a = this.effects[i];
        n[a.pipe].push(a, this, t);
      }
      this.collectRenderablesSimple(t, e, r);
      for (let i = this.effects.length - 1; i >= 0; i--) {
        const a = this.effects[i];
        n[a.pipe].pop(a, this, t);
      }
    }
  };
  kB = class {
    constructor() {
      this.pipe = "filter", this.priority = 1;
    }
    destroy() {
      for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy();
      this.filters = null, this.filterArea = null;
    }
  };
  class E1e {
    constructor() {
      this._effectClasses = [], this._tests = [], this._initialized = false;
    }
    init() {
      this._initialized || (this._initialized = true, this._effectClasses.forEach((e) => {
        this.add({
          test: e.test,
          maskClass: e
        });
      }));
    }
    add(e) {
      this._tests.push(e);
    }
    getMaskEffect(e) {
      this._initialized || this.init();
      for (let r = 0; r < this._tests.length; r++) {
        const n = this._tests[r];
        if (n.test(e)) return lo.get(n.maskClass, e);
      }
      return e;
    }
    returnMaskEffect(e) {
      lo.return(e);
    }
  }
  const fS = new E1e();
  Ti.handleByList(qt.MaskEffect, fS._effectClasses);
  const k1e = {
    _maskEffect: null,
    _maskOptions: {
      inverse: false
    },
    _filterEffect: null,
    effects: [],
    _markStructureAsChanged() {
      const t = this.renderGroup || this.parentRenderGroup;
      t && (t.structureDidChange = true);
    },
    addEffect(t) {
      this.effects.indexOf(t) === -1 && (this.effects.push(t), this.effects.sort((r, n) => r.priority - n.priority), this._markStructureAsChanged(), this._updateIsSimple());
    },
    removeEffect(t) {
      const e = this.effects.indexOf(t);
      e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple());
    },
    set mask(t) {
      const e = this._maskEffect;
      (e == null ? void 0 : e.mask) !== t && (e && (this.removeEffect(e), fS.returnMaskEffect(e), this._maskEffect = null), t != null && (this._maskEffect = fS.getMaskEffect(t), this.addEffect(this._maskEffect)));
    },
    setMask(t) {
      this._maskOptions = {
        ...this._maskOptions,
        ...t
      }, t.mask && (this.mask = t.mask), this._markStructureAsChanged();
    },
    get mask() {
      var _a2;
      return (_a2 = this._maskEffect) == null ? void 0 : _a2.mask;
    },
    set filters(t) {
      var _a2;
      !Array.isArray(t) && t && (t = [
        t
      ]);
      const e = this._filterEffect || (this._filterEffect = new kB());
      t = t;
      const r = (t == null ? void 0 : t.length) > 0, n = ((_a2 = e.filters) == null ? void 0 : _a2.length) > 0, i = r !== n;
      t = Array.isArray(t) ? t.slice(0) : t, e.filters = Object.freeze(t), i && (r ? this.addEffect(e) : (this.removeEffect(e), e.filters = t ?? null));
    },
    get filters() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filters;
    },
    set filterArea(t) {
      this._filterEffect || (this._filterEffect = new kB()), this._filterEffect.filterArea = t;
    },
    get filterArea() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filterArea;
    }
  }, P1e = {
    label: null,
    get name() {
      return Jt(fr, "Container.name property has been removed, use Container.label instead"), this.label;
    },
    set name(t) {
      Jt(fr, "Container.name property has been removed, use Container.label instead"), this.label = t;
    },
    getChildByName(t, e = false) {
      return this.getChildByLabel(t, e);
    },
    getChildByLabel(t, e = false) {
      const r = this.children;
      for (let n = 0; n < r.length; n++) {
        const i = r[n];
        if (i.label === t || t instanceof RegExp && t.test(i.label)) return i;
      }
      if (e) for (let n = 0; n < r.length; n++) {
        const a = r[n].getChildByLabel(t, true);
        if (a) return a;
      }
      return null;
    },
    getChildrenByLabel(t, e = false, r = []) {
      const n = this.children;
      for (let i = 0; i < n.length; i++) {
        const a = n[i];
        (a.label === t || t instanceof RegExp && t.test(a.label)) && r.push(a);
      }
      if (e) for (let i = 0; i < n.length; i++) n[i].getChildrenByLabel(t, true, r);
      return r;
    }
  }, mn = new OC($t), uo = new OC(Zi), L1e = new $t(), $1e = {
    getFastGlobalBounds(t, e) {
      e || (e = new Zi()), e.clear(), this._getGlobalBoundsRecursive(!!t, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0);
      const r = this.renderGroup || this.parentRenderGroup;
      return e.applyMatrix(r.worldTransform), e;
    },
    _getGlobalBoundsRecursive(t, e, r) {
      let n = e;
      if (t && this.parentRenderLayer && this.parentRenderLayer !== r || this.localDisplayStatus !== 7 || !this.measurable) return;
      const i = !!this.effects.length;
      if ((this.renderGroup || i) && (n = uo.get().clear()), this.boundsArea) e.addRect(this.boundsArea, this.worldTransform);
      else {
        if (this.renderPipeId) {
          const o = this.bounds;
          n.addFrame(o.minX, o.minY, o.maxX, o.maxY, this.groupTransform);
        }
        const a = this.children;
        for (let o = 0; o < a.length; o++) a[o]._getGlobalBoundsRecursive(t, n, r);
      }
      if (i) {
        let a = false;
        const o = this.renderGroup || this.parentRenderGroup;
        for (let s = 0; s < this.effects.length; s++) this.effects[s].addBounds && (a || (a = true, n.applyMatrix(o.worldTransform)), this.effects[s].addBounds(n, true));
        a && (n.applyMatrix(o.worldTransform.copyTo(L1e).invert()), e.addBounds(n, this.relativeGroupTransform)), e.addBounds(n), uo.return(n);
      } else this.renderGroup && (e.addBounds(n, this.relativeGroupTransform), uo.return(n));
    }
  };
  z9 = function(t, e, r) {
    r.clear();
    let n, i;
    return t.parent ? e ? n = t.parent.worldTransform : (i = mn.get().identity(), n = NC(t, i)) : n = $t.IDENTITY, F9(t, r, n, e), i && mn.return(i), r.isValid || r.set(0, 0, 0, 0), r;
  };
  function F9(t, e, r, n) {
    var _a2, _b2;
    if (!t.visible || !t.measurable) return;
    let i;
    n ? i = t.worldTransform : (t.updateLocalTransform(), i = mn.get(), i.appendFrom(t.localTransform, r));
    const a = e, o = !!t.effects.length;
    if (o && (e = uo.get().clear()), t.boundsArea) e.addRect(t.boundsArea, i);
    else {
      t.bounds && (e.matrix = i, e.addBounds(t.bounds));
      for (let s = 0; s < t.children.length; s++) F9(t.children[s], e, i, n);
    }
    if (o) {
      for (let s = 0; s < t.effects.length; s++) (_b2 = (_a2 = t.effects[s]).addBounds) == null ? void 0 : _b2.call(_a2, e);
      a.addBounds(e, $t.IDENTITY), uo.return(e);
    }
    n || mn.return(i);
  }
  function NC(t, e) {
    const r = t.parent;
    return r && (NC(r, e), r.updateLocalTransform(), e.append(r.localTransform)), e;
  }
  function V9(t, e) {
    if (t === 16777215 || !e) return e;
    if (e === 16777215 || !t) return t;
    const r = t >> 16 & 255, n = t >> 8 & 255, i = t & 255, a = e >> 16 & 255, o = e >> 8 & 255, s = e & 255, l = r * a / 255 | 0, u = n * o / 255 | 0, c = i * s / 255 | 0;
    return (l << 16) + (u << 8) + c;
  }
  const PB = 16777215;
  LB = function(t, e) {
    return t === PB ? e : e === PB ? t : V9(t, e);
  };
  function yg(t) {
    return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255);
  }
  const R1e = {
    getGlobalAlpha(t) {
      if (t) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
      let e = this.alpha, r = this.parent;
      for (; r; ) e *= r.alpha, r = r.parent;
      return e;
    },
    getGlobalTransform(t, e) {
      if (e) return t.copyFrom(this.worldTransform);
      this.updateLocalTransform();
      const r = NC(this, mn.get().identity());
      return t.appendFrom(this.localTransform, r), mn.return(r), t;
    },
    getGlobalTint(t) {
      if (t) return this.renderGroup ? yg(this.renderGroup.worldColor) : this.parentRenderGroup ? yg(LB(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
      let e = this.localColor, r = this.parent;
      for (; r; ) e = LB(e, r.localColor), r = r.parent;
      return yg(e);
    }
  };
  let b1 = 0;
  const $B = 500;
  Xn = function(...t) {
    b1 !== $B && (b1++, b1 === $B ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...t));
  };
  G9 = function(t, e, r) {
    return e.clear(), r || (r = $t.IDENTITY), W9(t, e, r, t, true), e.isValid || e.set(0, 0, 0, 0), e;
  };
  function W9(t, e, r, n, i) {
    var _a2, _b2;
    let a;
    if (i) a = mn.get(), a = r.copyTo(a);
    else {
      if (!t.visible || !t.measurable) return;
      t.updateLocalTransform();
      const l = t.localTransform;
      a = mn.get(), a.appendFrom(l, r);
    }
    const o = e, s = !!t.effects.length;
    if (s && (e = uo.get().clear()), t.boundsArea) e.addRect(t.boundsArea, a);
    else {
      t.renderPipeId && (e.matrix = a, e.addBounds(t.bounds));
      const l = t.children;
      for (let u = 0; u < l.length; u++) W9(l[u], e, a, n, false);
    }
    if (s) {
      for (let l = 0; l < t.effects.length; l++) (_b2 = (_a2 = t.effects[l]).addLocalBounds) == null ? void 0 : _b2.call(_a2, e, n);
      o.addBounds(e, $t.IDENTITY), uo.return(e);
    }
    mn.return(a);
  }
  function H9(t, e) {
    const r = t.children;
    for (let n = 0; n < r.length; n++) {
      const i = r[n], a = i.uid, o = (i._didViewChangeTick & 65535) << 16 | i._didContainerChangeTick & 65535, s = e.index;
      (e.data[s] !== a || e.data[s + 1] !== o) && (e.data[e.index] = a, e.data[e.index + 1] = o, e.didChange = true), e.index = s + 2, i.children.length && H9(i, e);
    }
    return e.didChange;
  }
  const O1e = new $t(), N1e = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(t, e) {
      const r = Math.sign(this.scale.x) || 1;
      e !== 0 ? this.scale.x = t / e * r : this.scale.x = r;
    },
    _setHeight(t, e) {
      const r = Math.sign(this.scale.y) || 1;
      e !== 0 ? this.scale.y = t / e * r : this.scale.y = r;
    },
    getLocalBounds() {
      this._localBoundsCacheData || (this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new Zi()
      });
      const t = this._localBoundsCacheData;
      return t.index = 1, t.didChange = false, t.data[0] !== this._didViewChangeTick && (t.didChange = true, t.data[0] = this._didViewChangeTick), H9(this, t), t.didChange && G9(this, t.localBounds, O1e), t.localBounds;
    },
    getBounds(t, e) {
      return z9(this, t, e || new Zi());
    }
  }, B1e = {
    _onRender: null,
    set onRender(t) {
      const e = this.renderGroup || this.parentRenderGroup;
      if (!t) {
        this._onRender && (e == null ? void 0 : e.removeOnRender(this)), this._onRender = null;
        return;
      }
      this._onRender || (e == null ? void 0 : e.addOnRender(this)), this._onRender = t;
    },
    get onRender() {
      return this._onRender;
    }
  }, z1e = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex() {
      return this._zIndex;
    },
    set zIndex(t) {
      this._zIndex !== t && (this._zIndex = t, this.depthOfChildModified());
    },
    depthOfChildModified() {
      this.parent && (this.parent.sortableChildren = true, this.parent.sortDirty = true), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true);
    },
    sortChildren() {
      this.sortDirty && (this.sortDirty = false, this.children.sort(F1e));
    }
  };
  function F1e(t, e) {
    return t._zIndex - e._zIndex;
  }
  const V1e = {
    getGlobalPosition(t = new rn(), e = false) {
      return this.parent ? this.parent.toGlobal(this._position, t, e) : (t.x = this._position.x, t.y = this._position.y), t;
    },
    toGlobal(t, e, r = false) {
      const n = this.getGlobalTransform(mn.get(), r);
      return e = n.apply(t, e), mn.return(n), e;
    },
    toLocal(t, e, r, n) {
      e && (t = e.toGlobal(t, r, n));
      const i = this.getGlobalTransform(mn.get(), n);
      return r = i.applyInverse(t, r), mn.return(i), r;
    }
  };
  class U9 {
    constructor() {
      this.uid = wr("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
    }
    reset() {
      this.instructionSize = 0;
    }
    add(e) {
      this.instructions[this.instructionSize++] = e;
    }
    log() {
      this.instructions.length = this.instructionSize, console.table(this.instructions, [
        "type",
        "action"
      ]);
    }
  }
  let G1e = 0;
  class W1e {
    constructor(e) {
      this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = false;
    }
    createTexture(e, r, n) {
      const i = new ta({
        ...this.textureOptions,
        width: e,
        height: r,
        resolution: 1,
        antialias: n,
        autoGarbageCollect: false
      });
      return new Kt({
        source: i,
        label: `texturePool_${G1e++}`
      });
    }
    getOptimalTexture(e, r, n = 1, i) {
      let a = Math.ceil(e * n - 1e-6), o = Math.ceil(r * n - 1e-6);
      a = _B(a), o = _B(o);
      const s = (a << 17) + (o << 1) + (i ? 1 : 0);
      this._texturePool[s] || (this._texturePool[s] = []);
      let l = this._texturePool[s].pop();
      return l || (l = this.createTexture(a, o, i)), l.source._resolution = n, l.source.width = a / n, l.source.height = o / n, l.source.pixelWidth = a, l.source.pixelHeight = o, l.frame.x = 0, l.frame.y = 0, l.frame.width = e, l.frame.height = r, l.updateUvs(), this._poolKeyHash[l.uid] = s, l;
    }
    getSameSizeTexture(e, r = false) {
      const n = e.source;
      return this.getOptimalTexture(e.width, e.height, n._resolution, r);
    }
    returnTexture(e) {
      const r = this._poolKeyHash[e.uid];
      this._texturePool[r].push(e);
    }
    clear(e) {
      if (e = e !== false, e) for (const r in this._texturePool) {
        const n = this._texturePool[r];
        if (n) for (let i = 0; i < n.length; i++) n[i].destroy(true);
      }
      this._texturePool = {};
    }
  }
  H1e = new W1e();
  class U1e {
    constructor() {
      this.renderPipeId = "renderGroup", this.root = null, this.canBundle = false, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new $t(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
        list: [],
        index: 0
      }, this.structureDidChange = true, this.instructionSet = new U9(), this._onRenderContainers = [], this.textureNeedsUpdate = true, this.isCachedAsTexture = false, this._matrixDirty = 7;
    }
    init(e) {
      this.root = e, e._onRender && this.addOnRender(e), e.didChange = true;
      const r = e.children;
      for (let n = 0; n < r.length; n++) {
        const i = r[n];
        i._updateFlags = 15, this.addChild(i);
      }
    }
    enableCacheAsTexture(e = {}) {
      this.textureOptions = e, this.isCachedAsTexture = true, this.textureNeedsUpdate = true;
    }
    disableCacheAsTexture() {
      this.isCachedAsTexture = false, this.texture && (H1e.returnTexture(this.texture), this.texture = null);
    }
    updateCacheTexture() {
      this.textureNeedsUpdate = true;
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const e in this.childrenToUpdate) {
        const r = this.childrenToUpdate[e];
        r.list.fill(null), r.index = 0;
      }
      this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = true, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(e) {
      e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e);
    }
    _removeRenderGroupChild(e) {
      const r = this.renderGroupChildren.indexOf(e);
      r > -1 && this.renderGroupChildren.splice(r, 1), e.renderGroupParent = null;
    }
    addChild(e) {
      if (this.structureDidChange = true, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = true, this.onChildUpdate(e), e.renderGroup) {
        this.addRenderGroupChild(e.renderGroup);
        return;
      }
      e._onRender && this.addOnRender(e);
      const r = e.children;
      for (let n = 0; n < r.length; n++) this.addChild(r[n]);
    }
    removeChild(e) {
      if (this.structureDidChange = true, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) {
        this._removeRenderGroupChild(e.renderGroup);
        return;
      }
      const r = e.children;
      for (let n = 0; n < r.length; n++) this.removeChild(r[n]);
    }
    removeChildren(e) {
      for (let r = 0; r < e.length; r++) this.removeChild(e[r]);
    }
    onChildUpdate(e) {
      let r = this.childrenToUpdate[e.relativeRenderGroupDepth];
      r || (r = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      }), r.list[r.index++] = e;
    }
    updateRenderable(e) {
      e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = false);
    }
    onChildViewUpdate(e) {
      this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e;
    }
    get isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(e) {
      this._onRenderContainers.push(e);
    }
    removeOnRender(e) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
    }
    runOnRender(e) {
      for (let r = 0; r < this._onRenderContainers.length; r++) this._onRenderContainers[r]._onRender(e);
    }
    destroy() {
      this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
    }
    getChildren(e = []) {
      const r = this.root.children;
      for (let n = 0; n < r.length; n++) this._getChildren(r[n], e);
      return e;
    }
    _getChildren(e, r = []) {
      if (r.push(e), e.renderGroup) return r;
      const n = e.children;
      for (let i = 0; i < n.length; i++) this._getChildren(n[i], r);
      return r;
    }
    invalidateMatrices() {
      this._matrixDirty = 7;
    }
    get inverseWorldTransform() {
      return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new $t()), this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
    }
    get textureOffsetInverseTransform() {
      return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new $t()), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y));
    }
    get inverseParentTextureTransform() {
      if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
      this._matrixDirty &= -5;
      const e = this._parentCacheAsTextureRenderGroup;
      return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new $t()), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform;
    }
    get cacheToLocalTransform() {
      return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
    }
  }
  function Y1e(t, e, r = {}) {
    for (const n in e) !r[n] && e[n] !== void 0 && (t[n] = e[n]);
  }
  let x1, w1, S1;
  x1 = new In(null);
  w1 = new In(null);
  S1 = new In(null, 1, 1);
  RB = 1;
  q1e = 2;
  T1 = 4;
  du = class extends Fa {
    constructor(e = {}) {
      var _a2, _b2;
      super(), this.uid = wr("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = false, this.didViewUpdate = false, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = true, this.measurable = true, this.isSimple = true, this.updateTick = -1, this.localTransform = new $t(), this.relativeGroupTransform = new $t(), this.groupTransform = this.relativeGroupTransform, this.destroyed = false, this._position = new In(this, 0, 0), this._scale = S1, this._pivot = w1, this._skew = x1, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], Y1e(this, e, {
        children: true,
        parent: true,
        effects: true
      }), (_a2 = e.children) == null ? void 0 : _a2.forEach((r) => this.addChild(r)), (_b2 = e.parent) == null ? void 0 : _b2.addChild(this);
    }
    static mixin(e) {
      Jt("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), Ti.mixin(du, e);
    }
    set _didChangeId(e) {
      this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095;
    }
    get _didChangeId() {
      return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
    }
    addChild(...e) {
      if (this.allowChildren || Jt(fr, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) {
        for (let i = 0; i < e.length; i++) this.addChild(e[i]);
        return e[0];
      }
      const r = e[0], n = this.renderGroup || this.parentRenderGroup;
      return r.parent === this ? (this.children.splice(this.children.indexOf(r), 1), this.children.push(r), n && (n.structureDidChange = true), r) : (r.parent && r.parent.removeChild(r), this.children.push(r), this.sortableChildren && (this.sortDirty = true), r.parent = this, r.didChange = true, r._updateFlags = 15, n && n.addChild(r), this.emit("childAdded", r, this, this.children.length - 1), r.emit("added", this), this._didViewChangeTick++, r._zIndex !== 0 && r.depthOfChildModified(), r);
    }
    removeChild(...e) {
      if (e.length > 1) {
        for (let i = 0; i < e.length; i++) this.removeChild(e[i]);
        return e[0];
      }
      const r = e[0], n = this.children.indexOf(r);
      return n > -1 && (this._didViewChangeTick++, this.children.splice(n, 1), this.renderGroup ? this.renderGroup.removeChild(r) : this.parentRenderGroup && this.parentRenderGroup.removeChild(r), r.parentRenderLayer && r.parentRenderLayer.detach(r), r.parent = null, this.emit("childRemoved", r, this, n), r.emit("removed", this)), r;
    }
    _onUpdate(e) {
      e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = true, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
    }
    set isRenderGroup(e) {
      !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup());
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup) return;
      const e = this.parentRenderGroup;
      e == null ? void 0 : e.removeChild(this), this.renderGroup = lo.get(U1e, this), this.groupTransform = $t.IDENTITY, e == null ? void 0 : e.addChild(this), this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup) return;
      const e = this.parentRenderGroup;
      e == null ? void 0 : e.removeChild(this), lo.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e == null ? void 0 : e.addChild(this), this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      return this._worldTransform || (this._worldTransform = new $t()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
    }
    get x() {
      return this._position.x;
    }
    set x(e) {
      this._position.x = e;
    }
    get y() {
      return this._position.y;
    }
    set y(e) {
      this._position.y = e;
    }
    get position() {
      return this._position;
    }
    set position(e) {
      this._position.copyFrom(e);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(e) {
      this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew));
    }
    get angle() {
      return this.rotation * a1e;
    }
    set angle(e) {
      this.rotation = e * o1e;
    }
    get pivot() {
      return this._pivot === w1 && (this._pivot = new In(this, 0, 0)), this._pivot;
    }
    set pivot(e) {
      this._pivot === w1 && (this._pivot = new In(this, 0, 0)), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e);
    }
    get skew() {
      return this._skew === x1 && (this._skew = new In(this, 0, 0)), this._skew;
    }
    set skew(e) {
      this._skew === x1 && (this._skew = new In(this, 0, 0)), this._skew.copyFrom(e);
    }
    get scale() {
      return this._scale === S1 && (this._scale = new In(this, 1, 1)), this._scale;
    }
    set scale(e) {
      this._scale === S1 && (this._scale = new In(this, 0, 0)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(e) {
      const r = this.getLocalBounds().width;
      this._setWidth(e, r);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(e) {
      const r = this.getLocalBounds().height;
      this._setHeight(e, r);
    }
    getSize(e) {
      e || (e = {});
      const r = this.getLocalBounds();
      return e.width = Math.abs(this.scale.x * r.width), e.height = Math.abs(this.scale.y * r.height), e;
    }
    setSize(e, r) {
      const n = this.getLocalBounds();
      typeof e == "object" ? (r = e.height ?? e.width, e = e.width) : r ?? (r = e), e !== void 0 && this._setWidth(e, n.width), r !== void 0 && this._setHeight(r, n.height);
    }
    _updateSkew() {
      const e = this._rotation, r = this._skew;
      this._cx = Math.cos(e + r._y), this._sx = Math.sin(e + r._y), this._cy = -Math.sin(e - r._x), this._sy = Math.cos(e - r._x);
    }
    updateTransform(e) {
      return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y), this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y), this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y), this;
    }
    setFromMatrix(e) {
      e.decompose(this);
    }
    updateLocalTransform() {
      const e = this._didContainerChangeTick;
      if (this._didLocalTransformChangeId === e) return;
      this._didLocalTransformChangeId = e;
      const r = this.localTransform, n = this._scale, i = this._pivot, a = this._position, o = n._x, s = n._y, l = i._x, u = i._y;
      r.a = this._cx * o, r.b = this._sx * o, r.c = this._cy * s, r.d = this._sy * s, r.tx = a._x - (l * r.a + u * r.c), r.ty = a._y - (l * r.b + u * r.d);
    }
    set alpha(e) {
      e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= RB, this._onUpdate());
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(e) {
      const n = an.shared.setValue(e ?? 16777215).toBgrNumber();
      n !== this.localColor && (this.localColor = n, this._updateFlags |= RB, this._onUpdate());
    }
    get tint() {
      return yg(this.localColor);
    }
    set blendMode(e) {
      this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= q1e, this.localBlendMode = e, this._onUpdate());
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(e) {
      const r = e ? 2 : 0;
      (this.localDisplayStatus & 2) !== r && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= T1, this.localDisplayStatus ^= 2, this._onUpdate());
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(e) {
      const r = e ? 0 : 4;
      (this.localDisplayStatus & 4) !== r && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= T1, this.localDisplayStatus ^= 4, this._onUpdate());
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(e) {
      const r = e ? 1 : 0;
      (this.localDisplayStatus & 1) !== r && (this._updateFlags |= T1, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._onUpdate());
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(e = false) {
      var _a2;
      if (this.destroyed) return;
      this.destroyed = true;
      let r;
      if (this.children.length && (r = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e == null ? void 0 : e.children) && r) for (let i = 0; i < r.length; ++i) r[i].destroy(e);
      (_a2 = this.renderGroup) == null ? void 0 : _a2.destroy(), this.renderGroup = null;
    }
  };
  Ti.mixin(du, M1e, $1e, V1e, B1e, N1e, k1e, P1e, z1e, T1e, A1e, R1e, D1e);
  class BC extends du {
    constructor(e) {
      super(e), this.canBundle = true, this.allowChildren = false, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new Zi(0, 1, 0, 0), this._boundsDirty = true;
    }
    get bounds() {
      return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = false, this._bounds) : this._bounds;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(e) {
      this._roundPixels = e ? 1 : 0;
    }
    containsPoint(e) {
      const r = this.bounds, { x: n, y: i } = e;
      return n >= r.minX && n <= r.maxX && i >= r.minY && i <= r.maxY;
    }
    onViewUpdate() {
      if (this._didViewChangeTick++, this._boundsDirty = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const e = this.renderGroup || this.parentRenderGroup;
      e && e.onChildViewUpdate(this);
    }
    destroy(e) {
      super.destroy(e), this._bounds = null;
    }
    collectRenderablesSimple(e, r, n) {
      const { renderPipes: i, renderableGC: a } = r;
      i.blendMode.setBlendMode(this, this.groupBlendMode, e), i[this.renderPipeId].addRenderable(this, e), a.addRenderable(this), this.didViewUpdate = false;
      const s = this.children, l = s.length;
      for (let u = 0; u < l; u++) s[u].collectRenderables(e, r, n);
    }
  }
  kc = class extends BC {
    constructor(e = Kt.EMPTY) {
      e instanceof Kt && (e = {
        texture: e
      });
      const { texture: r = Kt.EMPTY, anchor: n, roundPixels: i, width: a, height: o, ...s } = e;
      super({
        label: "Sprite",
        ...s
      }), this.renderPipeId = "sprite", this.batched = true, this._visualBounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._anchor = new In({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), n ? this.anchor = n : r.defaultAnchor && (this.anchor = r.defaultAnchor), this.texture = r, this.allowChildren = false, this.roundPixels = i ?? false, a !== void 0 && (this.width = a), o !== void 0 && (this.height = o);
    }
    static from(e, r = false) {
      return e instanceof Kt ? new kc(e) : new kc(Kt.from(e, r));
    }
    set texture(e) {
      e || (e = Kt.EMPTY);
      const r = this._texture;
      r !== e && (r && r.dynamic && r.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get visualBounds() {
      return p1e(this._visualBounds, this._anchor, this._texture), this._visualBounds;
    }
    get sourceBounds() {
      return Jt("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
    }
    updateBounds() {
      const e = this._anchor, r = this._texture, n = this._bounds, { width: i, height: a } = r.orig;
      n.minX = -e._x * i, n.maxX = n.minX + i, n.minY = -e._y * a, n.maxY = n.minY + a;
    }
    destroy(e = false) {
      if (super.destroy(e), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const n = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        this._texture.destroy(n);
      }
      this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(e) {
      this._setWidth(e, this._texture.orig.width), this._width = e;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(e) {
      this._setHeight(e, this._texture.orig.height), this._height = e;
    }
    getSize(e) {
      return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e;
    }
    setSize(e, r) {
      typeof e == "object" ? (r = e.height ?? e.width, e = e.width) : r ?? (r = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), r !== void 0 && this._setHeight(r, this._texture.orig.height);
    }
  };
  const X1e = new Zi();
  function Y9(t, e, r) {
    const n = X1e;
    t.measurable = true, z9(t, r, n), e.addBoundsMask(n), t.measurable = false;
  }
  function q9(t, e, r) {
    const n = uo.get();
    t.measurable = true;
    const i = mn.get().identity(), a = X9(t, r, i);
    G9(t, n, a), t.measurable = false, e.addBoundsMask(n), mn.return(i), uo.return(n);
  }
  function X9(t, e, r) {
    return t ? (t !== e && (X9(t.parent, e, r), t.updateLocalTransform(), r.append(t.localTransform)), r) : (Xn("Mask bounds, renderable is not inside the root container"), r);
  }
  class j9 {
    constructor(e) {
      this.priority = 0, this.inverse = false, this.pipe = "alphaMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e, this.renderMaskToTexture = !(e instanceof kc), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask = null;
    }
    addBounds(e, r) {
      this.inverse || Y9(this.mask, e, r);
    }
    addLocalBounds(e, r) {
      q9(this.mask, e, r);
    }
    containsPoint(e, r) {
      const n = this.mask;
      return r(n, e);
    }
    destroy() {
      this.reset();
    }
    static test(e) {
      return e instanceof kc;
    }
  }
  j9.extension = qt.MaskEffect;
  class K9 {
    constructor(e) {
      this.priority = 0, this.pipe = "colorMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e;
    }
    destroy() {
    }
    static test(e) {
      return typeof e == "number";
    }
  }
  K9.extension = qt.MaskEffect;
  class Z9 {
    constructor(e) {
      this.priority = 0, this.pipe = "stencilMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e, this.mask.includeInBuild = false, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask.includeInBuild = true, this.mask = null;
    }
    addBounds(e, r) {
      Y9(this.mask, e, r);
    }
    addLocalBounds(e, r) {
      q9(this.mask, e, r);
    }
    containsPoint(e, r) {
      const n = this.mask;
      return r(n, e);
    }
    destroy() {
      this.reset();
    }
    static test(e) {
      return e instanceof du;
    }
  }
  Z9.extension = qt.MaskEffect;
  const j1e = {
    createCanvas: (t, e) => {
      const r = document.createElement("canvas");
      return r.width = t, r.height = e, r;
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (t, e) => fetch(t, e),
    parseXML: (t) => new DOMParser().parseFromString(t, "text/xml")
  };
  let OB = j1e;
  Xi = {
    get() {
      return OB;
    },
    set(t) {
      OB = t;
    }
  };
  Q9 = class extends ta {
    constructor(e) {
      e.resource || (e.resource = Xi.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent;
    }
    resizeCanvas() {
      this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
    }
    resize(e = this.width, r = this.height, n = this._resolution) {
      const i = super.resize(e, r, n);
      return i && this.resizeCanvas(), i;
    }
    static test(e) {
      return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas;
    }
    get context2D() {
      return this._context2D || (this._context2D = this.resource.getContext("2d"));
    }
  };
  Q9.extension = qt.TextureSource;
  Mm = class extends ta {
    constructor(e) {
      if (e.resource && globalThis.HTMLImageElement && e.resource instanceof HTMLImageElement) {
        const r = Xi.get().createCanvas(e.resource.width, e.resource.height);
        r.getContext("2d").drawImage(e.resource, 0, 0, e.resource.width, e.resource.height), e.resource = r, Xn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
      }
      super(e), this.uploadMethodId = "image", this.autoGarbageCollect = true;
    }
    static test(e) {
      return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame;
    }
  };
  Mm.extension = qt.TextureSource;
  dS = ((t) => (t[t.INTERACTION = 50] = "INTERACTION", t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY", t))(dS || {});
  class C1 {
    constructor(e, r = null, n = 0, i = false) {
      this.next = null, this.previous = null, this._destroyed = false, this._fn = e, this._context = r, this.priority = n, this._once = i;
    }
    match(e, r = null) {
      return this._fn === e && this._context === r;
    }
    emit(e) {
      this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
      const r = this.next;
      return this._once && this.destroy(true), this._destroyed && (this.next = null), r;
    }
    connect(e) {
      this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
    }
    destroy(e = false) {
      this._destroyed = true, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      const r = this.next;
      return this.next = e ? null : r, this.previous = null, r;
    }
  }
  const J9 = class Vn {
    constructor() {
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new C1(null, null, 1 / 0), this.deltaMS = 1 / Vn.targetFPMS, this.elapsedMS = 1 / Vn.targetFPMS, this._tick = (e) => {
        this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
      };
    }
    _requestIfNeeded() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }
    _cancelIfNeeded() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(e, r, n = dS.NORMAL) {
      return this._addListener(new C1(e, r, n));
    }
    addOnce(e, r, n = dS.NORMAL) {
      return this._addListener(new C1(e, r, n, true));
    }
    _addListener(e) {
      let r = this._head.next, n = this._head;
      if (!r) e.connect(n);
      else {
        for (; r; ) {
          if (e.priority > r.priority) {
            e.connect(n);
            break;
          }
          n = r, r = r.next;
        }
        e.previous || e.connect(n);
      }
      return this._startIfPossible(), this;
    }
    remove(e, r) {
      let n = this._head.next;
      for (; n; ) n.match(e, r) ? n = n.destroy() : n = n.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) return 0;
      let e = 0, r = this._head;
      for (; r = r.next; ) e++;
      return e;
    }
    start() {
      this.started || (this.started = true, this._requestIfNeeded());
    }
    stop() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let e = this._head.next;
        for (; e; ) e = e.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }
    update(e = performance.now()) {
      let r;
      if (e > this.lastTime) {
        if (r = this.elapsedMS = e - this.lastTime, r > this._maxElapsedMS && (r = this._maxElapsedMS), r *= this.speed, this._minElapsedMS) {
          const a = e - this._lastFrame | 0;
          if (a < this._minElapsedMS) return;
          this._lastFrame = e - a % this._minElapsedMS;
        }
        this.deltaMS = r, this.deltaTime = this.deltaMS * Vn.targetFPMS;
        const n = this._head;
        let i = n.next;
        for (; i; ) i = i.emit(this);
        n.next || this._cancelIfNeeded();
      } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = e;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(e) {
      const r = Math.min(this.maxFPS, e), n = Math.min(Math.max(0, r) / 1e3, Vn.targetFPMS);
      this._maxElapsedMS = 1 / n;
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(e) {
      if (e === 0) this._minElapsedMS = 0;
      else {
        const r = Math.max(this.minFPS, e);
        this._minElapsedMS = 1 / (r / 1e3);
      }
    }
    static get shared() {
      if (!Vn._shared) {
        const e = Vn._shared = new Vn();
        e.autoStart = true, e._protected = true;
      }
      return Vn._shared;
    }
    static get system() {
      if (!Vn._system) {
        const e = Vn._system = new Vn();
        e.autoStart = true, e._protected = true;
      }
      return Vn._system;
    }
  };
  J9.targetFPMS = 0.06;
  let A1;
  Lv = J9;
  async function K1e() {
    return A1 ?? (A1 = (async () => {
      var _a2;
      const e = document.createElement("canvas").getContext("webgl");
      if (!e) return "premultiply-alpha-on-upload";
      const r = await new Promise((o) => {
        const s = document.createElement("video");
        s.onloadeddata = () => o(s), s.onerror = () => o(null), s.autoplay = false, s.crossOrigin = "anonymous", s.preload = "auto", s.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", s.load();
      });
      if (!r) return "premultiply-alpha-on-upload";
      const n = e.createTexture();
      e.bindTexture(e.TEXTURE_2D, n);
      const i = e.createFramebuffer();
      e.bindFramebuffer(e.FRAMEBUFFER, i), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, r);
      const a = new Uint8Array(4);
      return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, a), e.deleteFramebuffer(i), e.deleteTexture(n), (_a2 = e.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), a[0] <= a[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })()), A1;
  }
  const wy = class eq extends ta {
    constructor(e) {
      super(e), this.isReady = false, this.uploadMethodId = "video", e = {
        ...eq.defaultOptions,
        ...e
      }, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== false, this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== false && this.load();
    }
    updateFrame() {
      if (!this.destroyed) {
        if (this._updateFPS) {
          const e = Lv.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
        }
        (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) return this._load;
      const e = this.resource, r = this.options;
      return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = true), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (r.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, true)), this.alphaMode = await K1e(), this._load = new Promise((n, i) => {
        this.isValid ? n(this) : (this._resolve = n, this._reject = i, r.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
          this._onError(new ErrorEvent(`Preload exceeded timeout of ${r.preloadTimeoutMs}ms`));
        })), e.load());
      }), this._load;
    }
    _onError(e) {
      this.resource.removeEventListener("error", this._onError, true), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null);
    }
    _isSourcePlaying() {
      const e = this.resource;
      return !e.paused && !e.ended;
    }
    _isSourceReady() {
      return this.resource.readyState > 2;
    }
    _onPlayStart() {
      this.isValid || this._mediaReady(), this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
    }
    _onCanPlay() {
      this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
    }
    _onCanPlayThrough() {
      this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
    }
    _mediaReady() {
      const e = this.resource;
      this.isValid && (this.isReady = true, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
    }
    destroy() {
      this._configureAutoUpdate();
      const e = this.resource;
      e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, true), e.pause(), e.src = "", e.load()), super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(e) {
      e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Lv.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Lv.shared.add(this.updateFrame, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Lv.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
    }
    static test(e) {
      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
    }
  };
  wy.extension = qt.TextureSource;
  wy.defaultOptions = {
    ...ta.defaultOptions,
    autoLoad: true,
    autoPlay: true,
    updateFPS: 0,
    crossorigin: true,
    loop: false,
    muted: true,
    playsinline: true,
    preload: false
  };
  wy.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  let Z1e = wy;
  const Qu = (t, e, r = false) => (Array.isArray(t) || (t = [
    t
  ]), e ? t.map((n) => typeof n == "string" || r ? e(n) : n) : t);
  class Q1e {
    constructor() {
      this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear(), this._cache.clear();
    }
    has(e) {
      return this._cache.has(e);
    }
    get(e) {
      const r = this._cache.get(e);
      return r || Xn(`[Assets] Asset id ${e} was not found in the Cache`), r;
    }
    set(e, r) {
      const n = Qu(e);
      let i;
      for (let l = 0; l < this.parsers.length; l++) {
        const u = this.parsers[l];
        if (u.test(r)) {
          i = u.getCacheableAssets(n, r);
          break;
        }
      }
      const a = new Map(Object.entries(i || {}));
      i || n.forEach((l) => {
        a.set(l, r);
      });
      const o = [
        ...a.keys()
      ], s = {
        cacheKeys: o,
        keys: n
      };
      n.forEach((l) => {
        this._cacheMap.set(l, s);
      }), o.forEach((l) => {
        const u = i ? i[l] : r;
        this._cache.has(l) && this._cache.get(l) !== u && Xn("[Cache] already has key:", l), this._cache.set(l, a.get(l));
      });
    }
    remove(e) {
      if (!this._cacheMap.has(e)) {
        Xn(`[Assets] Asset id ${e} was not found in the Cache`);
        return;
      }
      const r = this._cacheMap.get(e);
      r.cacheKeys.forEach((i) => {
        this._cache.delete(i);
      }), r.keys.forEach((i) => {
        this._cacheMap.delete(i);
      });
    }
    get parsers() {
      return this._parsers;
    }
  }
  let pS;
  Ju = new Q1e();
  pS = [];
  Ti.handleByList(qt.TextureSource, pS);
  function tq(t = {}) {
    const e = t && t.resource, r = e ? t.resource : t, n = e ? t : {
      resource: t
    };
    for (let i = 0; i < pS.length; i++) {
      const a = pS[i];
      if (a.test(r)) return new a(n);
    }
    throw new Error(`Could not find a source type for resource: ${n.resource}`);
  }
  function J1e(t = {}, e = false) {
    const r = t && t.resource, n = r ? t.resource : t, i = r ? t : {
      resource: t
    };
    if (!e && Ju.has(n)) return Ju.get(n);
    const a = new Kt({
      source: tq(i)
    });
    return a.on("destroy", () => {
      Ju.has(n) && Ju.remove(n);
    }), e || Ju.set(n, a), a;
  }
  function exe(t, e = false) {
    return typeof t == "string" ? Ju.get(t) : t instanceof ta ? new Kt({
      source: t
    }) : J1e(t, e);
  }
  Kt.from = exe;
  ta.from = tq;
  Ti.add(j9, K9, Z9, Z1e, Mm, Q9, RC);
  var rq = ((t) => (t[t.Low = 0] = "Low", t[t.Normal = 1] = "Normal", t[t.High = 2] = "High", t))(rq || {});
  function $i(t) {
    if (typeof t != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`);
  }
  function Wh(t) {
    return t.split("?")[0].split("#")[0];
  }
  function txe(t) {
    return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function rxe(t, e, r) {
    return t.replace(new RegExp(txe(e), "g"), r);
  }
  function nxe(t, e) {
    let r = "", n = 0, i = -1, a = 0, o = -1;
    for (let s = 0; s <= t.length; ++s) {
      if (s < t.length) o = t.charCodeAt(s);
      else {
        if (o === 47) break;
        o = 47;
      }
      if (o === 47) {
        if (!(i === s - 1 || a === 1)) if (i !== s - 1 && a === 2) {
          if (r.length < 2 || n !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
            if (r.length > 2) {
              const l = r.lastIndexOf("/");
              if (l !== r.length - 1) {
                l === -1 ? (r = "", n = 0) : (r = r.slice(0, l), n = r.length - 1 - r.lastIndexOf("/")), i = s, a = 0;
                continue;
              }
            } else if (r.length === 2 || r.length === 1) {
              r = "", n = 0, i = s, a = 0;
              continue;
            }
          }
        } else r.length > 0 ? r += `/${t.slice(i + 1, s)}` : r = t.slice(i + 1, s), n = s - i - 1;
        i = s, a = 0;
      } else o === 46 && a !== -1 ? ++a : a = -1;
    }
    return r;
  }
  const bd = {
    toPosix(t) {
      return rxe(t, "\\", "/");
    },
    isUrl(t) {
      return /^https?:/.test(this.toPosix(t));
    },
    isDataUrl(t) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t);
    },
    isBlobUrl(t) {
      return t.startsWith("blob:");
    },
    hasProtocol(t) {
      return /^[^/:]+:/.test(this.toPosix(t));
    },
    getProtocol(t) {
      $i(t), t = this.toPosix(t);
      const e = /^file:\/\/\//.exec(t);
      if (e) return e[0];
      const r = /^[^/:]+:\/{0,2}/.exec(t);
      return r ? r[0] : "";
    },
    toAbsolute(t, e, r) {
      if ($i(t), this.isDataUrl(t) || this.isBlobUrl(t)) return t;
      const n = Wh(this.toPosix(e ?? Xi.get().getBaseUrl())), i = Wh(this.toPosix(r ?? this.rootname(n)));
      return t = this.toPosix(t), t.startsWith("/") ? bd.join(i, t.slice(1)) : this.isAbsolute(t) ? t : this.join(n, t);
    },
    normalize(t) {
      if ($i(t), t.length === 0) return ".";
      if (this.isDataUrl(t) || this.isBlobUrl(t)) return t;
      t = this.toPosix(t);
      let e = "";
      const r = t.startsWith("/");
      this.hasProtocol(t) && (e = this.rootname(t), t = t.slice(e.length));
      const n = t.endsWith("/");
      return t = nxe(t), t.length > 0 && n && (t += "/"), r ? `/${t}` : e + t;
    },
    isAbsolute(t) {
      return $i(t), t = this.toPosix(t), this.hasProtocol(t) ? true : t.startsWith("/");
    },
    join(...t) {
      if (t.length === 0) return ".";
      let e;
      for (let r = 0; r < t.length; ++r) {
        const n = t[r];
        if ($i(n), n.length > 0) if (e === void 0) e = n;
        else {
          const i = t[r - 1] ?? "";
          this.joinExtensions.includes(this.extname(i).toLowerCase()) ? e += `/../${n}` : e += `/${n}`;
        }
      }
      return e === void 0 ? "." : this.normalize(e);
    },
    dirname(t) {
      if ($i(t), t.length === 0) return ".";
      t = this.toPosix(t);
      let e = t.charCodeAt(0);
      const r = e === 47;
      let n = -1, i = true;
      const a = this.getProtocol(t), o = t;
      t = t.slice(a.length);
      for (let s = t.length - 1; s >= 1; --s) if (e = t.charCodeAt(s), e === 47) {
        if (!i) {
          n = s;
          break;
        }
      } else i = false;
      return n === -1 ? r ? "/" : this.isUrl(o) ? a + t : a : r && n === 1 ? "//" : a + t.slice(0, n);
    },
    rootname(t) {
      $i(t), t = this.toPosix(t);
      let e = "";
      if (t.startsWith("/") ? e = "/" : e = this.getProtocol(t), this.isUrl(t)) {
        const r = t.indexOf("/", e.length);
        r !== -1 ? e = t.slice(0, r) : e = t, e.endsWith("/") || (e += "/");
      }
      return e;
    },
    basename(t, e) {
      $i(t), e && $i(e), t = Wh(this.toPosix(t));
      let r = 0, n = -1, i = true, a;
      if (e !== void 0 && e.length > 0 && e.length <= t.length) {
        if (e.length === t.length && e === t) return "";
        let o = e.length - 1, s = -1;
        for (a = t.length - 1; a >= 0; --a) {
          const l = t.charCodeAt(a);
          if (l === 47) {
            if (!i) {
              r = a + 1;
              break;
            }
          } else s === -1 && (i = false, s = a + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (n = a) : (o = -1, n = s));
        }
        return r === n ? n = s : n === -1 && (n = t.length), t.slice(r, n);
      }
      for (a = t.length - 1; a >= 0; --a) if (t.charCodeAt(a) === 47) {
        if (!i) {
          r = a + 1;
          break;
        }
      } else n === -1 && (i = false, n = a + 1);
      return n === -1 ? "" : t.slice(r, n);
    },
    extname(t) {
      $i(t), t = Wh(this.toPosix(t));
      let e = -1, r = 0, n = -1, i = true, a = 0;
      for (let o = t.length - 1; o >= 0; --o) {
        const s = t.charCodeAt(o);
        if (s === 47) {
          if (!i) {
            r = o + 1;
            break;
          }
          continue;
        }
        n === -1 && (i = false, n = o + 1), s === 46 ? e === -1 ? e = o : a !== 1 && (a = 1) : e !== -1 && (a = -1);
      }
      return e === -1 || n === -1 || a === 0 || a === 1 && e === n - 1 && e === r + 1 ? "" : t.slice(e, n);
    },
    parse(t) {
      $i(t);
      const e = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (t.length === 0) return e;
      t = Wh(this.toPosix(t));
      let r = t.charCodeAt(0);
      const n = this.isAbsolute(t);
      let i;
      e.root = this.rootname(t), n || this.hasProtocol(t) ? i = 1 : i = 0;
      let a = -1, o = 0, s = -1, l = true, u = t.length - 1, c = 0;
      for (; u >= i; --u) {
        if (r = t.charCodeAt(u), r === 47) {
          if (!l) {
            o = u + 1;
            break;
          }
          continue;
        }
        s === -1 && (l = false, s = u + 1), r === 46 ? a === -1 ? a = u : c !== 1 && (c = 1) : a !== -1 && (c = -1);
      }
      return a === -1 || s === -1 || c === 0 || c === 1 && a === s - 1 && a === o + 1 ? s !== -1 && (o === 0 && n ? e.base = e.name = t.slice(1, s) : e.base = e.name = t.slice(o, s)) : (o === 0 && n ? (e.name = t.slice(1, a), e.base = t.slice(1, s)) : (e.name = t.slice(o, a), e.base = t.slice(o, s)), e.ext = t.slice(a, s)), e.dir = this.dirname(t), e;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [
      ".html"
    ]
  };
  function nq(t, e, r, n, i) {
    const a = e[r];
    for (let o = 0; o < a.length; o++) {
      const s = a[o];
      r < e.length - 1 ? nq(t.replace(n[r], s), e, r + 1, n, i) : i.push(t.replace(n[r], s));
    }
  }
  function ixe(t) {
    const e = /\{(.*?)\}/g, r = t.match(e), n = [];
    if (r) {
      const i = [];
      r.forEach((a) => {
        const o = a.substring(1, a.length - 1).split(",");
        i.push(o);
      }), nq(t, i, 0, r, n);
    } else n.push(t);
    return n;
  }
  const NB = (t) => !Array.isArray(t);
  class iq {
    constructor() {
      this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (e, r) => `${e}${this._bundleIdConnector}${r}`,
        extractAssetIdFromBundle: (e, r) => r.replace(`${e}${this._bundleIdConnector}`, "")
      }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
    }
    setBundleIdentifier(e) {
      if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
    prefer(...e) {
      e.forEach((r) => {
        this._preferredOrder.push(r), r.priority || (r.priority = Object.keys(r.params));
      }), this._resolverHash = {};
    }
    set basePath(e) {
      this._basePath = e;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(e) {
      this._rootPath = e;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
    }
    setDefaultSearchParams(e) {
      if (typeof e == "string") this._defaultSearchParams = e;
      else {
        const r = e;
        this._defaultSearchParams = Object.keys(r).map((n) => `${encodeURIComponent(n)}=${encodeURIComponent(r[n])}`).join("&");
      }
    }
    getAlias(e) {
      const { alias: r, src: n } = e;
      return Qu(r || n, (a) => typeof a == "string" ? a : Array.isArray(a) ? a.map((o) => (o == null ? void 0 : o.src) ?? o) : (a == null ? void 0 : a.src) ? a.src : a, true);
    }
    addManifest(e) {
      this._manifest && Xn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach((r) => {
        this.addBundle(r.name, r.assets);
      });
    }
    addBundle(e, r) {
      const n = [];
      let i = r;
      Array.isArray(r) || (i = Object.entries(r).map(([a, o]) => typeof o == "string" || Array.isArray(o) ? {
        alias: a,
        src: o
      } : {
        alias: a,
        ...o
      })), i.forEach((a) => {
        const o = a.src, s = a.alias;
        let l;
        if (typeof s == "string") {
          const u = this._createBundleAssetId(e, s);
          n.push(u), l = [
            s,
            u
          ];
        } else {
          const u = s.map((c) => this._createBundleAssetId(e, c));
          n.push(...u), l = [
            ...s,
            ...u
          ];
        }
        this.add({
          ...a,
          alias: l,
          src: o
        });
      }), this._bundles[e] = n;
    }
    add(e) {
      const r = [];
      Array.isArray(e) ? r.push(...e) : r.push(e);
      let n;
      n = (a) => {
        this.hasKey(a) && Xn(`[Resolver] already has key: ${a} overwriting`);
      }, Qu(r).forEach((a) => {
        const { src: o } = a;
        let { data: s, format: l, loadParser: u } = a;
        const c = Qu(o).map((d) => typeof d == "string" ? ixe(d) : Array.isArray(d) ? d : [
          d
        ]), h = this.getAlias(a);
        Array.isArray(h) ? h.forEach(n) : n(h);
        const f = [];
        c.forEach((d) => {
          d.forEach((p) => {
            let v = {};
            if (typeof p != "object") {
              v.src = p;
              for (let g = 0; g < this._parsers.length; g++) {
                const m = this._parsers[g];
                if (m.test(p)) {
                  v = m.parse(p);
                  break;
                }
              }
            } else s = p.data ?? s, l = p.format ?? l, u = p.loadParser ?? u, v = {
              ...v,
              ...p
            };
            if (!h) throw new Error(`[Resolver] alias is undefined for this asset: ${v.src}`);
            v = this._buildResolvedAsset(v, {
              aliases: h,
              data: s,
              format: l,
              loadParser: u
            }), f.push(v);
          });
        }), h.forEach((d) => {
          this._assetMap[d] = f;
        });
      });
    }
    resolveBundle(e) {
      const r = NB(e);
      e = Qu(e);
      const n = {};
      return e.forEach((i) => {
        const a = this._bundles[i];
        if (a) {
          const o = this.resolve(a), s = {};
          for (const l in o) {
            const u = o[l];
            s[this._extractAssetIdFromBundle(i, l)] = u;
          }
          n[i] = s;
        }
      }), r ? n[e[0]] : n;
    }
    resolveUrl(e) {
      const r = this.resolve(e);
      if (typeof e != "string") {
        const n = {};
        for (const i in r) n[i] = r[i].src;
        return n;
      }
      return r.src;
    }
    resolve(e) {
      const r = NB(e);
      e = Qu(e);
      const n = {};
      return e.forEach((i) => {
        if (!this._resolverHash[i]) if (this._assetMap[i]) {
          let a = this._assetMap[i];
          const o = this._getPreferredOrder(a);
          o == null ? void 0 : o.priority.forEach((s) => {
            o.params[s].forEach((l) => {
              const u = a.filter((c) => c[s] ? c[s] === l : false);
              u.length && (a = u);
            });
          }), this._resolverHash[i] = a[0];
        } else this._resolverHash[i] = this._buildResolvedAsset({
          alias: [
            i
          ],
          src: i
        }, {});
        n[i] = this._resolverHash[i];
      }), r ? n[e[0]] : n;
    }
    hasKey(e) {
      return !!this._assetMap[e];
    }
    hasBundle(e) {
      return !!this._bundles[e];
    }
    _getPreferredOrder(e) {
      for (let r = 0; r < e.length; r++) {
        const n = e[r], i = this._preferredOrder.find((a) => a.params.format.includes(n.format));
        if (i) return i;
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(e) {
      if (!this._defaultSearchParams) return e;
      const r = /\?/.test(e) ? "&" : "?";
      return `${e}${r}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(e, r) {
      const { aliases: n, data: i, loadParser: a, format: o } = r;
      return (this._basePath || this._rootPath) && (e.src = bd.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = n ?? e.alias ?? [
        e.src
      ], e.src = this._appendDefaultSearchParams(e.src), e.data = {
        ...i || {},
        ...e.data
      }, e.loadParser = a ?? e.loadParser, e.format = o ?? e.format ?? axe(e.src), e;
    }
  }
  iq.RETINA_PREFIX = /@([0-9\.]+)x/;
  function axe(t) {
    return t.split(".").pop().split("?").shift().split("#").shift();
  }
  const BB = (t, e) => {
    const r = e.split("?")[1];
    return r && (t += `?${r}`), t;
  }, aq = class vf {
    constructor(e, r) {
      this.linkedSheets = [], this._texture = e instanceof Kt ? e : null, this.textureSource = e.source, this.textures = {}, this.animations = {}, this.data = r;
      const n = parseFloat(r.meta.scale);
      n ? (this.resolution = n, e.source.resolution = this.resolution) : this.resolution = e.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    parse() {
      return new Promise((e) => {
        this._callback = e, this._batchIndex = 0, this._frameKeys.length <= vf.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
      });
    }
    _processFrames(e) {
      let r = e;
      const n = vf.BATCH_SIZE;
      for (; r - e < n && r < this._frameKeys.length; ) {
        const i = this._frameKeys[r], a = this._frames[i], o = a.frame;
        if (o) {
          let s = null, l = null;
          const u = a.trimmed !== false && a.sourceSize ? a.sourceSize : a.frame, c = new Vr(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution);
          a.rotated ? s = new Vr(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : s = new Vr(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), a.trimmed !== false && a.spriteSourceSize && (l = new Vr(Math.floor(a.spriteSourceSize.x) / this.resolution, Math.floor(a.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[i] = new Kt({
            source: this.textureSource,
            frame: s,
            orig: c,
            trim: l,
            rotate: a.rotated ? 2 : 0,
            defaultAnchor: a.anchor,
            defaultBorders: a.borders,
            label: i.toString()
          });
        }
        r++;
      }
    }
    _processAnimations() {
      const e = this.data.animations || {};
      for (const r in e) {
        this.animations[r] = [];
        for (let n = 0; n < e[r].length; n++) {
          const i = e[r][n];
          this.animations[r].push(this.textures[i]);
        }
      }
    }
    _parseComplete() {
      const e = this._callback;
      this._callback = null, this._batchIndex = 0, e.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * vf.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
        this._batchIndex * vf.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(e = false) {
      var _a2;
      for (const r in this.textures) this.textures[r].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((_a2 = this._texture) == null ? void 0 : _a2.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
    }
  };
  aq.BATCH_SIZE = 1e3;
  let zB = aq;
  const oxe = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
  ];
  function oq(t, e, r) {
    const n = {};
    if (t.forEach((i) => {
      n[i] = e;
    }), Object.keys(e.textures).forEach((i) => {
      n[i] = e.textures[i];
    }), !r) {
      const i = bd.dirname(t[0]);
      e.linkedSheets.forEach((a, o) => {
        const s = oq([
          `${i}/${e.data.meta.related_multi_packs[o]}`
        ], a, true);
        Object.assign(n, s);
      });
    }
    return n;
  }
  const sxe = {
    extension: qt.Asset,
    cache: {
      test: (t) => t instanceof zB,
      getCacheableAssets: (t, e) => oq(t, e, false)
    },
    resolver: {
      extension: {
        type: qt.ResolveParser,
        name: "resolveSpritesheet"
      },
      test: (t) => {
        const r = t.split("?")[0].split("."), n = r.pop(), i = r.pop();
        return n === "json" && oxe.includes(i);
      },
      parse: (t) => {
        var _a2;
        const e = t.split(".");
        return {
          resolution: parseFloat(((_a2 = iq.RETINA_PREFIX.exec(t)) == null ? void 0 : _a2[1]) ?? "1"),
          format: e[e.length - 2],
          src: t
        };
      }
    },
    loader: {
      name: "spritesheetLoader",
      extension: {
        type: qt.LoadParser,
        priority: rq.Normal,
        name: "spritesheetLoader"
      },
      async testParse(t, e) {
        return bd.extname(e.src).toLowerCase() === ".json" && !!t.frames;
      },
      async parse(t, e, r) {
        var _a2, _b2;
        const { texture: n, imageFilename: i, textureOptions: a } = (e == null ? void 0 : e.data) ?? {};
        let o = bd.dirname(e.src);
        o && o.lastIndexOf("/") !== o.length - 1 && (o += "/");
        let s;
        if (n instanceof Kt) s = n;
        else {
          const c = BB(o + (i ?? t.meta.image), e.src);
          s = (await r.load([
            {
              src: c,
              data: a
            }
          ]))[c];
        }
        const l = new zB(s.source, t);
        await l.parse();
        const u = (_a2 = t == null ? void 0 : t.meta) == null ? void 0 : _a2.related_multi_packs;
        if (Array.isArray(u)) {
          const c = [];
          for (const f of u) {
            if (typeof f != "string") continue;
            let d = o + f;
            ((_b2 = e.data) == null ? void 0 : _b2.ignoreMultiPack) || (d = BB(d, e.src), c.push(r.load({
              src: d,
              data: {
                textureOptions: a,
                ignoreMultiPack: true
              }
            })));
          }
          const h = await Promise.all(c);
          l.linkedSheets = h, h.forEach((f) => {
            f.linkedSheets = [
              l
            ].concat(l.linkedSheets.filter((d) => d !== f));
          });
        }
        return l;
      },
      async unload(t, e, r) {
        await r.unload(t.textureSource._sourceOrigin), t.destroy(false);
      }
    }
  };
  Ti.add(sxe);
  const I1 = /* @__PURE__ */ Object.create(null), FB = /* @__PURE__ */ Object.create(null);
  zC = function(t, e) {
    let r = FB[t];
    return r === void 0 && (I1[e] === void 0 && (I1[e] = 1), FB[t] = r = I1[e]++), r;
  };
  let $v;
  function sq() {
    return (!$v || ($v == null ? void 0 : $v.isContextLost())) && ($v = Xi.get().createCanvas().getContext("webgl", {})), $v;
  }
  let Rv;
  function lxe() {
    if (!Rv) {
      Rv = "mediump";
      const t = sq();
      t && t.getShaderPrecisionFormat && (Rv = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision ? "highp" : "mediump");
    }
    return Rv;
  }
  function uxe(t, e, r) {
    return e ? t : r ? (t = t.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${t}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${t}
        `;
  }
  function cxe(t, e, r) {
    const n = r ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
    if (t.substring(0, 9) !== "precision") {
      let i = r ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
      return i === "highp" && n !== "highp" && (i = "mediump"), `precision ${i} float;
${t}`;
    } else if (n !== "highp" && t.substring(0, 15) === "precision highp") return t.replace("precision highp", "precision mediump");
    return t;
  }
  function hxe(t, e) {
    return e ? `#version 300 es
${t}` : t;
  }
  const fxe = {}, dxe = {};
  function pxe(t, { name: e = "pixi-program" }, r = true) {
    e = e.replace(/\s+/g, "-"), e += r ? "-fragment" : "-vertex";
    const n = r ? fxe : dxe;
    return n[e] ? (n[e]++, e += `-${n[e]}`) : n[e] = 1, t.indexOf("#define SHADER_NAME") !== -1 ? t : `${`#define SHADER_NAME ${e}`}
${t}`;
  }
  function vxe(t, e) {
    return e ? t.replace("#version 300 es", "") : t;
  }
  const M1 = {
    stripVersion: vxe,
    ensurePrecision: cxe,
    addProgramDefines: uxe,
    setProgramName: pxe,
    insertVersion: hxe
  }, D1 = /* @__PURE__ */ Object.create(null), lq = class vS {
    constructor(e) {
      e = {
        ...vS.defaultOptions,
        ...e
      };
      const r = e.fragment.indexOf("#version 300 es") !== -1, n = {
        stripVersion: r,
        ensurePrecision: {
          requestedFragmentPrecision: e.preferredFragmentPrecision,
          requestedVertexPrecision: e.preferredVertexPrecision,
          maxSupportedVertexPrecision: "highp",
          maxSupportedFragmentPrecision: lxe()
        },
        setProgramName: {
          name: e.name
        },
        addProgramDefines: r,
        insertVersion: r
      };
      let i = e.fragment, a = e.vertex;
      Object.keys(M1).forEach((o) => {
        const s = n[o];
        i = M1[o](i, s, true), a = M1[o](a, s, false);
      }), this.fragment = i, this.vertex = a, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = zC(`${this.vertex}:${this.fragment}`, "gl-program");
    }
    destroy() {
      this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
    }
    static from(e) {
      const r = `${e.vertex}:${e.fragment}`;
      return D1[r] || (D1[r] = new vS(e)), D1[r];
    }
  };
  lq.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
  };
  uq = lq;
  const VB = {
    uint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    uint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    sint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    sint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    unorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    unorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    snorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    snorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    uint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    uint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    sint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    sint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    unorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    unorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    snorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    snorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    float16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    float16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    float32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    float32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    float32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    float32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    uint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    uint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    uint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    uint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    sint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    sint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    sint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    sint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    }
  };
  gxe = function(t) {
    return VB[t] ?? VB.float32;
  };
  const mxe = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };
  function yxe({ source: t, entryPoint: e }) {
    const r = {}, n = t.indexOf(`fn ${e}`);
    if (n !== -1) {
      const i = t.indexOf("->", n);
      if (i !== -1) {
        const a = t.substring(n, i), o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let s;
        for (; (s = o.exec(a)) !== null; ) {
          const l = mxe[s[3]] ?? "float32";
          r[s[2]] = {
            location: parseInt(s[1], 10),
            format: l,
            stride: gxe(l).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return r;
  }
  function E1(t) {
    var _a2, _b2;
    const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, r = /@group\((\d+)\)/, n = /@binding\((\d+)\)/, i = /var(<[^>]+>)? (\w+)/, a = /:\s*(\w+)/, o = /struct\s+(\w+)\s*{([^}]+)}/g, s = /(\w+)\s*:\s*([\w\<\>]+)/g, l = /struct\s+(\w+)/, u = (_a2 = t.match(e)) == null ? void 0 : _a2.map((h) => ({
      group: parseInt(h.match(r)[1], 10),
      binding: parseInt(h.match(n)[1], 10),
      name: h.match(i)[2],
      isUniform: h.match(i)[1] === "<uniform>",
      type: h.match(a)[1]
    }));
    if (!u) return {
      groups: [],
      structs: []
    };
    const c = ((_b2 = t.match(o)) == null ? void 0 : _b2.map((h) => {
      const f = h.match(l)[1], d = h.match(s).reduce((p, v) => {
        const [g, m] = v.split(":");
        return p[g.trim()] = m.trim(), p;
      }, {});
      return d ? {
        name: f,
        members: d
      } : null;
    }).filter(({ name: h }) => u.some((f) => f.type === h))) ?? [];
    return {
      groups: u,
      structs: c
    };
  }
  var gf = ((t) => (t[t.VERTEX = 1] = "VERTEX", t[t.FRAGMENT = 2] = "FRAGMENT", t[t.COMPUTE = 4] = "COMPUTE", t))(gf || {});
  function _xe({ groups: t }) {
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      e[n.group] || (e[n.group] = []), n.isUniform ? e[n.group].push({
        binding: n.binding,
        visibility: gf.VERTEX | gf.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      }) : n.type === "sampler" ? e[n.group].push({
        binding: n.binding,
        visibility: gf.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      }) : n.type === "texture_2d" && e[n.group].push({
        binding: n.binding,
        visibility: gf.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
    return e;
  }
  function bxe({ groups: t }) {
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      e[n.group] || (e[n.group] = {}), e[n.group][n.name] = n.binding;
    }
    return e;
  }
  function xxe(t, e) {
    const r = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), i = [
      ...t.structs,
      ...e.structs
    ].filter((o) => r.has(o.name) ? false : (r.add(o.name), true)), a = [
      ...t.groups,
      ...e.groups
    ].filter((o) => {
      const s = `${o.name}-${o.binding}`;
      return n.has(s) ? false : (n.add(s), true);
    });
    return {
      structs: i,
      groups: a
    };
  }
  const k1 = /* @__PURE__ */ Object.create(null);
  Sy = class {
    constructor(e) {
      var _a2, _b2;
      this._layoutKey = 0, this._attributeLocationsKey = 0;
      const { fragment: r, vertex: n, layout: i, gpuLayout: a, name: o } = e;
      if (this.name = o, this.fragment = r, this.vertex = n, r.source === n.source) {
        const s = E1(r.source);
        this.structsAndGroups = s;
      } else {
        const s = E1(n.source), l = E1(r.source);
        this.structsAndGroups = xxe(s, l);
      }
      this.layout = i ?? bxe(this.structsAndGroups), this.gpuLayout = a ?? _xe(this.structsAndGroups), this.autoAssignGlobalUniforms = ((_a2 = this.layout[0]) == null ? void 0 : _a2.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((_b2 = this.layout[1]) == null ? void 0 : _b2.localUniforms) !== void 0, this._generateProgramKey();
    }
    _generateProgramKey() {
      const { vertex: e, fragment: r } = this, n = e.source + r.source + e.entryPoint + r.entryPoint;
      this._layoutKey = zC(n, "program");
    }
    get attributeData() {
      return this._attributeData ?? (this._attributeData = yxe(this.vertex)), this._attributeData;
    }
    destroy() {
      this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
    }
    static from(e) {
      const r = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
      return k1[r] || (k1[r] = new Sy(e)), k1[r];
    }
  };
  const cq = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>",
    "vec2<i32>",
    "vec3<i32>",
    "vec4<i32>"
  ], wxe = cq.reduce((t, e) => (t[e] = true, t), {});
  function Sxe(t, e) {
    switch (t) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * e);
      case "vec3<f32>":
        return new Float32Array(3 * e);
      case "vec4<f32>":
        return new Float32Array(4 * e);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  const hq = class fq {
    constructor(e, r) {
      this._touched = 0, this.uid = wr("uniform"), this._resourceType = "uniformGroup", this._resourceId = wr("resource"), this.isUniformGroup = true, this._dirtyId = 0, this.destroyed = false, r = {
        ...fq.defaultOptions,
        ...r
      }, this.uniformStructures = e;
      const n = {};
      for (const i in e) {
        const a = e[i];
        if (a.name = i, a.size = a.size ?? 1, !wxe[a.type]) throw new Error(`Uniform type ${a.type} is not supported. Supported uniform types are: ${cq.join(", ")}`);
        a.value ?? (a.value = Sxe(a.type, a.size)), n[i] = a.value;
      }
      this.uniforms = n, this._dirtyId = 1, this.ubo = r.ubo, this.isStatic = r.isStatic, this._signature = zC(Object.keys(n).map((i) => `${i}-${e[i].type}`).join("-"), "uniform-group");
    }
    update() {
      this._dirtyId++;
    }
  };
  hq.defaultOptions = {
    ubo: false,
    isStatic: false
  };
  dq = hq;
  _g = class {
    constructor(e) {
      this.resources = /* @__PURE__ */ Object.create(null), this._dirty = true;
      let r = 0;
      for (const n in e) {
        const i = e[n];
        this.setResource(i, r++);
      }
      this._updateKey();
    }
    _updateKey() {
      if (!this._dirty) return;
      this._dirty = false;
      const e = [];
      let r = 0;
      for (const n in this.resources) e[r++] = this.resources[n]._resourceId;
      this._key = e.join("|");
    }
    setResource(e, r) {
      var _a2, _b2;
      const n = this.resources[r];
      e !== n && (n && ((_a2 = e.off) == null ? void 0 : _a2.call(e, "change", this.onResourceChange, this)), (_b2 = e.on) == null ? void 0 : _b2.call(e, "change", this.onResourceChange, this), this.resources[r] = e, this._dirty = true);
    }
    getResource(e) {
      return this.resources[e];
    }
    _touch(e) {
      const r = this.resources;
      for (const n in r) r[n]._touched = e;
    }
    destroy() {
      var _a2, _b2;
      const e = this.resources;
      for (const r in e) (_b2 = (_a2 = e[r]).off) == null ? void 0 : _b2.call(_a2, "change", this.onResourceChange, this);
      this.resources = null;
    }
    onResourceChange(e) {
      if (this._dirty = true, e.destroyed) {
        const r = this.resources;
        for (const n in r) r[n] === e && (r[n] = null);
      } else this._updateKey();
    }
  };
  gS = ((t) => (t[t.WEBGL = 1] = "WEBGL", t[t.WEBGPU = 2] = "WEBGPU", t[t.BOTH = 3] = "BOTH", t))(gS || {});
  FC = class extends Fa {
    constructor(e) {
      super(), this.uid = wr("shader"), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
      let { gpuProgram: r, glProgram: n, groups: i, resources: a, compatibleRenderers: o, groupMap: s } = e;
      this.gpuProgram = r, this.glProgram = n, o === void 0 && (o = 0, r && (o |= gS.WEBGPU), n && (o |= gS.WEBGL)), this.compatibleRenderers = o;
      const l = {};
      if (!a && !i && (a = {}), a && i) throw new Error("[Shader] Cannot have both resources and groups");
      if (!r && i && !s) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      if (!r && i && s) for (const u in s) for (const c in s[u]) {
        const h = s[u][c];
        l[h] = {
          group: u,
          binding: c,
          name: h
        };
      }
      else if (r && i && !s) {
        const u = r.structsAndGroups.groups;
        s = {}, u.forEach((c) => {
          s[c.group] = s[c.group] || {}, s[c.group][c.binding] = c.name, l[c.name] = c;
        });
      } else if (a) {
        i = {}, s = {}, r && r.structsAndGroups.groups.forEach((h) => {
          s[h.group] = s[h.group] || {}, s[h.group][h.binding] = h.name, l[h.name] = h;
        });
        let u = 0;
        for (const c in a) l[c] || (i[99] || (i[99] = new _g(), this._ownedBindGroups.push(i[99])), l[c] = {
          group: 99,
          binding: u,
          name: c
        }, s[99] = s[99] || {}, s[99][u] = c, u++);
        for (const c in a) {
          const h = c;
          let f = a[c];
          !f.source && !f._resourceType && (f = new dq(f));
          const d = l[h];
          d && (i[d.group] || (i[d.group] = new _g(), this._ownedBindGroups.push(i[d.group])), i[d.group].setResource(f, d.binding));
        }
      }
      this.groups = i, this._uniformBindMap = s, this.resources = this._buildResourceAccessor(i, l);
    }
    addResource(e, r, n) {
      var i, a;
      (i = this._uniformBindMap)[r] || (i[r] = {}), (a = this._uniformBindMap[r])[n] || (a[n] = e), this.groups[r] || (this.groups[r] = new _g(), this._ownedBindGroups.push(this.groups[r]));
    }
    _buildResourceAccessor(e, r) {
      const n = {};
      for (const i in r) {
        const a = r[i];
        Object.defineProperty(n, a.name, {
          get() {
            return e[a.group].getResource(a.binding);
          },
          set(o) {
            e[a.group].setResource(o, a.binding);
          }
        });
      }
      return n;
    }
    destroy(e = false) {
      var _a2, _b2;
      this.emit("destroy", this), e && ((_a2 = this.gpuProgram) == null ? void 0 : _a2.destroy(), (_b2 = this.glProgram) == null ? void 0 : _b2.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((r) => {
        r.destroy();
      }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
    }
    static from(e) {
      const { gpu: r, gl: n, ...i } = e;
      let a, o;
      return r && (a = Sy.from(r)), n && (o = uq.from(n)), new FC({
        gpuProgram: a,
        glProgram: o,
        ...i
      });
    }
  };
  const mS = [];
  Ti.handleByNamedList(qt.Environment, mS);
  async function Txe(t) {
    if (!t) for (let e = 0; e < mS.length; e++) {
      const r = mS[e];
      if (r.value.test()) {
        await r.value.load();
        return;
      }
    }
  }
  let Hh;
  Cxe = function() {
    if (typeof Hh == "boolean") return Hh;
    try {
      Hh = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
        a: "b"
      }, "a", "b") === true;
    } catch {
      Hh = false;
    }
    return Hh;
  };
  var Ov = {
    exports: {}
  }, GB;
  function Axe() {
    if (GB) return Ov.exports;
    GB = 1, Ov.exports = t, Ov.exports.default = t;
    function t(E, O, N) {
      N = N || 2;
      var V = O && O.length, H = V ? O[0] * N : E.length, G = e(E, 0, H, N, true), Y = [];
      if (!G || G.next === G.prev) return Y;
      var U, Z, ee, we, Te, le, ue;
      if (V && (G = l(E, O, G, N)), E.length > 80 * N) {
        U = ee = E[0], Z = we = E[1];
        for (var ye = N; ye < H; ye += N) Te = E[ye], le = E[ye + 1], Te < U && (U = Te), le < Z && (Z = le), Te > ee && (ee = Te), le > we && (we = le);
        ue = Math.max(ee - U, we - Z), ue = ue !== 0 ? 32767 / ue : 0;
      }
      return n(G, Y, N, U, Z, ue, 0), Y;
    }
    function e(E, O, N, V, H) {
      var G, Y;
      if (H === F(E, O, N, V) > 0) for (G = O; G < N; G += V) Y = B(G, E[G], E[G + 1], Y);
      else for (G = N - V; G >= O; G -= V) Y = B(G, E[G], E[G + 1], Y);
      return Y && b(Y, Y.next) && (L(Y), Y = Y.next), Y;
    }
    function r(E, O) {
      if (!E) return E;
      O || (O = E);
      var N = E, V;
      do
        if (V = false, !N.steiner && (b(N, N.next) || _(N.prev, N, N.next) === 0)) {
          if (L(N), N = O = N.prev, N === N.next) break;
          V = true;
        } else N = N.next;
      while (V || N !== O);
      return O;
    }
    function n(E, O, N, V, H, G, Y) {
      if (E) {
        !Y && G && d(E, V, H, G);
        for (var U = E, Z, ee; E.prev !== E.next; ) {
          if (Z = E.prev, ee = E.next, G ? a(E, V, H, G) : i(E)) {
            O.push(Z.i / N | 0), O.push(E.i / N | 0), O.push(ee.i / N | 0), L(E), E = ee.next, U = ee.next;
            continue;
          }
          if (E = ee, E === U) {
            Y ? Y === 1 ? (E = o(r(E), O, N), n(E, O, N, V, H, G, 2)) : Y === 2 && s(E, O, N, V, H, G) : n(r(E), O, N, V, H, G, 1);
            break;
          }
        }
      }
    }
    function i(E) {
      var O = E.prev, N = E, V = E.next;
      if (_(O, N, V) >= 0) return false;
      for (var H = O.x, G = N.x, Y = V.x, U = O.y, Z = N.y, ee = V.y, we = H < G ? H < Y ? H : Y : G < Y ? G : Y, Te = U < Z ? U < ee ? U : ee : Z < ee ? Z : ee, le = H > G ? H > Y ? H : Y : G > Y ? G : Y, ue = U > Z ? U > ee ? U : ee : Z > ee ? Z : ee, ye = V.next; ye !== O; ) {
        if (ye.x >= we && ye.x <= le && ye.y >= Te && ye.y <= ue && m(H, U, G, Z, Y, ee, ye.x, ye.y) && _(ye.prev, ye, ye.next) >= 0) return false;
        ye = ye.next;
      }
      return true;
    }
    function a(E, O, N, V) {
      var H = E.prev, G = E, Y = E.next;
      if (_(H, G, Y) >= 0) return false;
      for (var U = H.x, Z = G.x, ee = Y.x, we = H.y, Te = G.y, le = Y.y, ue = U < Z ? U < ee ? U : ee : Z < ee ? Z : ee, ye = we < Te ? we < le ? we : le : Te < le ? Te : le, ve = U > Z ? U > ee ? U : ee : Z > ee ? Z : ee, Se = we > Te ? we > le ? we : le : Te > le ? Te : le, Qe = v(ue, ye, O, N, V), Xe = v(ve, Se, O, N, V), be = E.prevZ, ke = E.nextZ; be && be.z >= Qe && ke && ke.z <= Xe; ) {
        if (be.x >= ue && be.x <= ve && be.y >= ye && be.y <= Se && be !== H && be !== Y && m(U, we, Z, Te, ee, le, be.x, be.y) && _(be.prev, be, be.next) >= 0 || (be = be.prevZ, ke.x >= ue && ke.x <= ve && ke.y >= ye && ke.y <= Se && ke !== H && ke !== Y && m(U, we, Z, Te, ee, le, ke.x, ke.y) && _(ke.prev, ke, ke.next) >= 0)) return false;
        ke = ke.nextZ;
      }
      for (; be && be.z >= Qe; ) {
        if (be.x >= ue && be.x <= ve && be.y >= ye && be.y <= Se && be !== H && be !== Y && m(U, we, Z, Te, ee, le, be.x, be.y) && _(be.prev, be, be.next) >= 0) return false;
        be = be.prevZ;
      }
      for (; ke && ke.z <= Xe; ) {
        if (ke.x >= ue && ke.x <= ve && ke.y >= ye && ke.y <= Se && ke !== H && ke !== Y && m(U, we, Z, Te, ee, le, ke.x, ke.y) && _(ke.prev, ke, ke.next) >= 0) return false;
        ke = ke.nextZ;
      }
      return true;
    }
    function o(E, O, N) {
      var V = E;
      do {
        var H = V.prev, G = V.next.next;
        !b(H, G) && w(H, V, V.next, G) && I(H, G) && I(G, H) && (O.push(H.i / N | 0), O.push(V.i / N | 0), O.push(G.i / N | 0), L(V), L(V.next), V = E = G), V = V.next;
      } while (V !== E);
      return r(V);
    }
    function s(E, O, N, V, H, G) {
      var Y = E;
      do {
        for (var U = Y.next.next; U !== Y.prev; ) {
          if (Y.i !== U.i && y(Y, U)) {
            var Z = k(Y, U);
            Y = r(Y, Y.next), Z = r(Z, Z.next), n(Y, O, N, V, H, G, 0), n(Z, O, N, V, H, G, 0);
            return;
          }
          U = U.next;
        }
        Y = Y.next;
      } while (Y !== E);
    }
    function l(E, O, N, V) {
      var H = [], G, Y, U, Z, ee;
      for (G = 0, Y = O.length; G < Y; G++) U = O[G] * V, Z = G < Y - 1 ? O[G + 1] * V : E.length, ee = e(E, U, Z, V, false), ee === ee.next && (ee.steiner = true), H.push(g(ee));
      for (H.sort(u), G = 0; G < H.length; G++) N = c(H[G], N);
      return N;
    }
    function u(E, O) {
      return E.x - O.x;
    }
    function c(E, O) {
      var N = h(E, O);
      if (!N) return O;
      var V = k(N, E);
      return r(V, V.next), r(N, N.next);
    }
    function h(E, O) {
      var N = O, V = E.x, H = E.y, G = -1 / 0, Y;
      do {
        if (H <= N.y && H >= N.next.y && N.next.y !== N.y) {
          var U = N.x + (H - N.y) * (N.next.x - N.x) / (N.next.y - N.y);
          if (U <= V && U > G && (G = U, Y = N.x < N.next.x ? N : N.next, U === V)) return Y;
        }
        N = N.next;
      } while (N !== O);
      if (!Y) return null;
      var Z = Y, ee = Y.x, we = Y.y, Te = 1 / 0, le;
      N = Y;
      do
        V >= N.x && N.x >= ee && V !== N.x && m(H < we ? V : G, H, ee, we, H < we ? G : V, H, N.x, N.y) && (le = Math.abs(H - N.y) / (V - N.x), I(N, E) && (le < Te || le === Te && (N.x > Y.x || N.x === Y.x && f(Y, N))) && (Y = N, Te = le)), N = N.next;
      while (N !== Z);
      return Y;
    }
    function f(E, O) {
      return _(E.prev, E, O.prev) < 0 && _(O.next, E, E.next) < 0;
    }
    function d(E, O, N, V) {
      var H = E;
      do
        H.z === 0 && (H.z = v(H.x, H.y, O, N, V)), H.prevZ = H.prev, H.nextZ = H.next, H = H.next;
      while (H !== E);
      H.prevZ.nextZ = null, H.prevZ = null, p(H);
    }
    function p(E) {
      var O, N, V, H, G, Y, U, Z, ee = 1;
      do {
        for (N = E, E = null, G = null, Y = 0; N; ) {
          for (Y++, V = N, U = 0, O = 0; O < ee && (U++, V = V.nextZ, !!V); O++) ;
          for (Z = ee; U > 0 || Z > 0 && V; ) U !== 0 && (Z === 0 || !V || N.z <= V.z) ? (H = N, N = N.nextZ, U--) : (H = V, V = V.nextZ, Z--), G ? G.nextZ = H : E = H, H.prevZ = G, G = H;
          N = V;
        }
        G.nextZ = null, ee *= 2;
      } while (Y > 1);
      return E;
    }
    function v(E, O, N, V, H) {
      return E = (E - N) * H | 0, O = (O - V) * H | 0, E = (E | E << 8) & 16711935, E = (E | E << 4) & 252645135, E = (E | E << 2) & 858993459, E = (E | E << 1) & 1431655765, O = (O | O << 8) & 16711935, O = (O | O << 4) & 252645135, O = (O | O << 2) & 858993459, O = (O | O << 1) & 1431655765, E | O << 1;
    }
    function g(E) {
      var O = E, N = E;
      do
        (O.x < N.x || O.x === N.x && O.y < N.y) && (N = O), O = O.next;
      while (O !== E);
      return N;
    }
    function m(E, O, N, V, H, G, Y, U) {
      return (H - Y) * (O - U) >= (E - Y) * (G - U) && (E - Y) * (V - U) >= (N - Y) * (O - U) && (N - Y) * (G - U) >= (H - Y) * (V - U);
    }
    function y(E, O) {
      return E.next.i !== O.i && E.prev.i !== O.i && !A(E, O) && (I(E, O) && I(O, E) && M(E, O) && (_(E.prev, E, O.prev) || _(E, O.prev, O)) || b(E, O) && _(E.prev, E, E.next) > 0 && _(O.prev, O, O.next) > 0);
    }
    function _(E, O, N) {
      return (O.y - E.y) * (N.x - O.x) - (O.x - E.x) * (N.y - O.y);
    }
    function b(E, O) {
      return E.x === O.x && E.y === O.y;
    }
    function w(E, O, N, V) {
      var H = T(_(E, O, N)), G = T(_(E, O, V)), Y = T(_(N, V, E)), U = T(_(N, V, O));
      return !!(H !== G && Y !== U || H === 0 && x(E, N, O) || G === 0 && x(E, V, O) || Y === 0 && x(N, E, V) || U === 0 && x(N, O, V));
    }
    function x(E, O, N) {
      return O.x <= Math.max(E.x, N.x) && O.x >= Math.min(E.x, N.x) && O.y <= Math.max(E.y, N.y) && O.y >= Math.min(E.y, N.y);
    }
    function T(E) {
      return E > 0 ? 1 : E < 0 ? -1 : 0;
    }
    function A(E, O) {
      var N = E;
      do {
        if (N.i !== E.i && N.next.i !== E.i && N.i !== O.i && N.next.i !== O.i && w(N, N.next, E, O)) return true;
        N = N.next;
      } while (N !== E);
      return false;
    }
    function I(E, O) {
      return _(E.prev, E, E.next) < 0 ? _(E, O, E.next) >= 0 && _(E, E.prev, O) >= 0 : _(E, O, E.prev) < 0 || _(E, E.next, O) < 0;
    }
    function M(E, O) {
      var N = E, V = false, H = (E.x + O.x) / 2, G = (E.y + O.y) / 2;
      do
        N.y > G != N.next.y > G && N.next.y !== N.y && H < (N.next.x - N.x) * (G - N.y) / (N.next.y - N.y) + N.x && (V = !V), N = N.next;
      while (N !== E);
      return V;
    }
    function k(E, O) {
      var N = new z(E.i, E.x, E.y), V = new z(O.i, O.x, O.y), H = E.next, G = O.prev;
      return E.next = O, O.prev = E, N.next = H, H.prev = N, V.next = N, N.prev = V, G.next = V, V.prev = G, V;
    }
    function B(E, O, N, V) {
      var H = new z(E, O, N);
      return V ? (H.next = V.next, H.prev = V, V.next.prev = H, V.next = H) : (H.prev = H, H.next = H), H;
    }
    function L(E) {
      E.next.prev = E.prev, E.prev.next = E.next, E.prevZ && (E.prevZ.nextZ = E.nextZ), E.nextZ && (E.nextZ.prevZ = E.prevZ);
    }
    function z(E, O, N) {
      this.i = E, this.x = O, this.y = N, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    t.deviation = function(E, O, N, V) {
      var H = O && O.length, G = H ? O[0] * N : E.length, Y = Math.abs(F(E, 0, G, N));
      if (H) for (var U = 0, Z = O.length; U < Z; U++) {
        var ee = O[U] * N, we = U < Z - 1 ? O[U + 1] * N : E.length;
        Y -= Math.abs(F(E, ee, we, N));
      }
      var Te = 0;
      for (U = 0; U < V.length; U += 3) {
        var le = V[U] * N, ue = V[U + 1] * N, ye = V[U + 2] * N;
        Te += Math.abs((E[le] - E[ye]) * (E[ue + 1] - E[le + 1]) - (E[le] - E[ue]) * (E[ye + 1] - E[le + 1]));
      }
      return Y === 0 && Te === 0 ? 0 : Math.abs((Te - Y) / Y);
    };
    function F(E, O, N, V) {
      for (var H = 0, G = O, Y = N - V; G < N; G += V) H += (E[Y] - E[G]) * (E[G + 1] + E[Y + 1]), Y = G;
      return H;
    }
    return t.flatten = function(E) {
      for (var O = E[0][0].length, N = {
        vertices: [],
        holes: [],
        dimensions: O
      }, V = 0, H = 0; H < E.length; H++) {
        for (var G = 0; G < E[H].length; G++) for (var Y = 0; Y < O; Y++) N.vertices.push(E[H][G][Y]);
        H > 0 && (V += E[H - 1].length, N.holes.push(V));
      }
      return N;
    }, Ov.exports;
  }
  var Ixe = Axe();
  const Mxe = GS(Ixe);
  pq = ((t) => (t[t.NONE = 0] = "NONE", t[t.COLOR = 16384] = "COLOR", t[t.STENCIL = 1024] = "STENCIL", t[t.DEPTH = 256] = "DEPTH", t[t.COLOR_DEPTH = 16640] = "COLOR_DEPTH", t[t.COLOR_STENCIL = 17408] = "COLOR_STENCIL", t[t.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", t[t.ALL = 17664] = "ALL", t))(pq || {});
  Dxe = class {
    constructor(e) {
      this.items = [], this._name = e;
    }
    emit(e, r, n, i, a, o, s, l) {
      const { name: u, items: c } = this;
      for (let h = 0, f = c.length; h < f; h++) c[h][u](e, r, n, i, a, o, s, l);
      return this;
    }
    add(e) {
      return e[this._name] && (this.remove(e), this.items.push(e)), this;
    }
    remove(e) {
      const r = this.items.indexOf(e);
      return r !== -1 && this.items.splice(r, 1), this;
    }
    contains(e) {
      return this.items.indexOf(e) !== -1;
    }
    removeAll() {
      return this.items.length = 0, this;
    }
    destroy() {
      this.removeAll(), this.items = null, this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  };
  const Exe = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "resetState",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender"
  ], vq = class gq extends Fa {
    constructor(e) {
      super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = e.type, this.name = e.name, this.config = e;
      const r = [
        ...Exe,
        ...this.config.runners ?? []
      ];
      this._addRunners(...r), this._unsafeEvalCheck();
    }
    async init(e = {}) {
      const r = e.skipExtensionImports === true ? true : e.manageImports === false;
      await Txe(r), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (const n in this._systemsHash) e = {
        ...this._systemsHash[n].constructor.defaultOptions,
        ...e
      };
      e = {
        ...gq.defaultOptions,
        ...e
      }, this._roundPixels = e.roundPixels ? 1 : 0;
      for (let n = 0; n < this.runners.init.items.length; n++) await this.runners.init.items[n].init(e);
      this._initOptions = e;
    }
    render(e, r) {
      let n = e;
      if (n instanceof du && (n = {
        container: n
      }, r && (Jt(fr, "passing a second argument is deprecated, please use render options instead"), n.target = r.renderTexture)), n.target || (n.target = this.view.renderTarget), n.target === this.view.renderTarget && (this._lastObjectRendered = n.container, n.clearColor ?? (n.clearColor = this.background.colorRgba), n.clear ?? (n.clear = this.background.clearBeforeRender)), n.clearColor) {
        const i = Array.isArray(n.clearColor) && n.clearColor.length === 4;
        n.clearColor = i ? n.clearColor : an.shared.setValue(n.clearColor).toArray();
      }
      n.transform || (n.container.updateLocalTransform(), n.transform = n.container.localTransform), n.container.enableRenderGroup(), this.runners.prerender.emit(n), this.runners.renderStart.emit(n), this.runners.render.emit(n), this.runners.renderEnd.emit(n), this.runners.postrender.emit(n);
    }
    resize(e, r, n) {
      const i = this.view.resolution;
      this.view.resize(e, r, n), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), n !== void 0 && n !== i && this.runners.resolutionChange.emit(n);
    }
    clear(e = {}) {
      const r = this;
      e.target || (e.target = r.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ?? (e.clear = pq.ALL);
      const { clear: n, clearColor: i, target: a } = e;
      an.shared.setValue(i ?? this.background.colorRgba), r.renderTarget.clear(a, n, an.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(e) {
      this.view.resolution = e, this.runners.resolutionChange.emit(e);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      return this.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...e) {
      e.forEach((r) => {
        this.runners[r] = new Dxe(r);
      });
    }
    _addSystems(e) {
      let r;
      for (r in e) {
        const n = e[r];
        this._addSystem(n.value, n.name);
      }
    }
    _addSystem(e, r) {
      const n = new e(this);
      if (this[r]) throw new Error(`Whoops! The name "${r}" is already in use`);
      this[r] = n, this._systemsHash[r] = n;
      for (const i in this.runners) this.runners[i].add(n);
      return this;
    }
    _addPipes(e, r) {
      const n = r.reduce((i, a) => (i[a.name] = a.value, i), {});
      e.forEach((i) => {
        const a = i.value, o = i.name, s = n[o];
        this.renderPipes[o] = new a(this, s ? new s() : null);
      });
    }
    destroy(e = false) {
      this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), Object.values(this.runners).forEach((r) => {
        r.destroy();
      }), this._systemsHash = null, this.renderPipes = null;
    }
    generateTexture(e) {
      return this.textureGenerator.generateTexture(e);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!Cxe()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
    resetState() {
      this.runners.resetState.emit();
    }
  };
  vq.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: false,
    roundPixels: false
  };
  let Nv;
  mq = vq;
  function kxe(t) {
    return Nv !== void 0 || (Nv = (() => {
      var _a2;
      const e = {
        stencil: true,
        failIfMajorPerformanceCaveat: t ?? mq.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!Xi.get().getWebGLRenderingContext()) return false;
        let n = Xi.get().createCanvas().getContext("webgl", e);
        const i = !!((_a2 = n == null ? void 0 : n.getContextAttributes()) == null ? void 0 : _a2.stencil);
        if (n) {
          const a = n.getExtension("WEBGL_lose_context");
          a && a.loseContext();
        }
        return n = null, i;
      } catch {
        return false;
      }
    })()), Nv;
  }
  let Bv;
  async function Pxe(t = {}) {
    return Bv !== void 0 || (Bv = await (async () => {
      const e = Xi.get().getNavigator().gpu;
      if (!e) return false;
      try {
        return await (await e.requestAdapter(t)).requestDevice(), true;
      } catch {
        return false;
      }
    })()), Bv;
  }
  const WB = [
    "webgl",
    "webgpu",
    "canvas"
  ];
  async function Lxe(t) {
    let e = [];
    t.preference ? (e.push(t.preference), WB.forEach((a) => {
      a !== t.preference && e.push(a);
    })) : e = WB.slice();
    let r, n = {};
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      if (o === "webgpu" && await Pxe()) {
        const { WebGPURenderer: s } = await Wl(async () => {
          const { WebGPURenderer: l } = await import("./WebGPURenderer-l4WKkicU.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            WebGPURenderer: l
          };
        }, __vite__mapDeps([7,2,8,3,4,5,6]));
        r = s, n = {
          ...t,
          ...t.webgpu
        };
        break;
      } else if (o === "webgl" && kxe(t.failIfMajorPerformanceCaveat ?? mq.defaultOptions.failIfMajorPerformanceCaveat)) {
        const { WebGLRenderer: s } = await Wl(async () => {
          const { WebGLRenderer: l } = await import("./WebGLRenderer-9JhWnSmC.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            WebGLRenderer: l
          };
        }, __vite__mapDeps([9,2,8,4,5,6]));
        r = s, n = {
          ...t,
          ...t.webgl
        };
        break;
      } else if (o === "canvas") throw n = {
        ...t
      }, new Error("CanvasRenderer is not yet implemented");
    }
    if (delete n.webgpu, delete n.webgl, !r) throw new Error("No available renderer for the current environment");
    const i = new r();
    return await i.init(n), i;
  }
  yq = "8.9.1";
  class _q {
    static init() {
      var _a2;
      (_a2 = globalThis.__PIXI_APP_INIT__) == null ? void 0 : _a2.call(globalThis, this, yq);
    }
    static destroy() {
    }
  }
  _q.extension = qt.Application;
  $xe = class {
    constructor(e) {
      this._renderer = e;
    }
    init() {
      var _a2;
      (_a2 = globalThis.__PIXI_RENDERER_INIT__) == null ? void 0 : _a2.call(globalThis, this._renderer, yq);
    }
    destroy() {
      this._renderer = null;
    }
  };
  $xe.extension = {
    type: [
      qt.WebGLSystem,
      qt.WebGPUSystem
    ],
    name: "initHook",
    priority: -10
  };
  const bq = class yS {
    constructor(...e) {
      this.stage = new du(), e[0] !== void 0 && Jt(fr, "Application constructor options are deprecated, please use Application.init() instead.");
    }
    async init(e) {
      e = {
        ...e
      }, this.renderer = await Lxe(e), yS._plugins.forEach((r) => {
        r.init.call(this, e);
      });
    }
    render() {
      this.renderer.render({
        container: this.stage
      });
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      return Jt(fr, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(e = false, r = false) {
      const n = yS._plugins.slice(0);
      n.reverse(), n.forEach((i) => {
        i.destroy.call(this);
      }), this.stage.destroy(r), this.stage = null, this.renderer.destroy(e), this.renderer = null;
    }
  };
  bq._plugins = [];
  let xq = bq;
  Ti.handleByList(qt.Application, xq._plugins);
  Ti.add(_q);
  const HB = [
    {
      offset: 0,
      color: "white"
    },
    {
      offset: 1,
      color: "black"
    }
  ], VC = class _S {
    constructor(...e) {
      this.uid = wr("fillGradient"), this.type = "linear", this.colorStops = [];
      let r = Rxe(e);
      r = {
        ...r.type === "radial" ? _S.defaultRadialOptions : _S.defaultLinearOptions,
        ...k9(r)
      }, this._textureSize = r.textureSize, r.type === "radial" ? (this.center = r.center, this.outerCenter = r.outerCenter ?? this.center, this.innerRadius = r.innerRadius, this.outerRadius = r.outerRadius, this.scale = r.scale, this.rotation = r.rotation) : (this.start = r.start, this.end = r.end), this.textureSpace = r.textureSpace, this.type = r.type, r.colorStops.forEach((i) => {
        this.addColorStop(i.offset, i.color);
      });
    }
    addColorStop(e, r) {
      return this.colorStops.push({
        offset: e,
        color: an.shared.setValue(r).toHexa()
      }), this;
    }
    buildLinearGradient() {
      if (this.texture) return;
      const e = this.colorStops.length ? this.colorStops : HB, r = this._textureSize, { canvas: n, context: i } = YB(r, 1), a = i.createLinearGradient(0, 0, this._textureSize, 0);
      UB(a, e), i.fillStyle = a, i.fillRect(0, 0, r, 1), this.texture = new Kt({
        source: new Mm({
          resource: n
        })
      });
      const { x: o, y: s } = this.start, { x: l, y: u } = this.end, c = new $t(), h = l - o, f = u - s, d = Math.sqrt(h * h + f * f), p = Math.atan2(f, h);
      c.scale(d / r, 1), c.rotate(p), c.translate(o, s), this.textureSpace === "local" && c.scale(r, r), this.transform = c;
    }
    buildGradient() {
      this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
    }
    buildRadialGradient() {
      if (this.texture) return;
      const e = this.colorStops.length ? this.colorStops : HB, r = this._textureSize, { canvas: n, context: i } = YB(r, r), { x: a, y: o } = this.center, { x: s, y: l } = this.outerCenter, u = this.innerRadius, c = this.outerRadius, h = s - c, f = l - c, d = r / (c * 2), p = (a - h) * d, v = (o - f) * d, g = i.createRadialGradient(p, v, u * d, (s - h) * d, (l - f) * d, c * d);
      UB(g, e), i.fillStyle = e[e.length - 1].color, i.fillRect(0, 0, r, r), i.fillStyle = g, i.translate(p, v), i.rotate(this.rotation), i.scale(1, this.scale), i.translate(-p, -v), i.fillRect(0, 0, r, r), this.texture = new Kt({
        source: new Mm({
          resource: n,
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        })
      });
      const m = new $t();
      m.scale(1 / d, 1 / d), m.translate(h, f), this.textureSpace === "local" && m.scale(r, r), this.transform = m;
    }
    get styleKey() {
      return this.uid;
    }
    destroy() {
      var _a2;
      (_a2 = this.texture) == null ? void 0 : _a2.destroy(true), this.texture = null;
    }
  };
  VC.defaultLinearOptions = {
    start: {
      x: 0,
      y: 0
    },
    end: {
      x: 0,
      y: 1
    },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256
  };
  VC.defaultRadialOptions = {
    center: {
      x: 0.5,
      y: 0.5
    },
    innerRadius: 0,
    outerRadius: 0.5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256
  };
  tu = VC;
  function UB(t, e) {
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      t.addColorStop(n.offset, n.color);
    }
  }
  function YB(t, e) {
    const r = Xi.get().createCanvas(t, e), n = r.getContext("2d");
    return {
      canvas: r,
      context: n
    };
  }
  function Rxe(t) {
    let e = t[0] ?? {};
    return (typeof e == "number" || t[1]) && (Jt("8.5.2", "use options object instead"), e = {
      type: "linear",
      start: {
        x: t[0],
        y: t[1]
      },
      end: {
        x: t[2],
        y: t[3]
      },
      textureSpace: t[4],
      textureSize: t[5] ?? tu.defaultLinearOptions.textureSize
    }), e;
  }
  const qB = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  GC = class {
    constructor(e, r) {
      this.uid = wr("fillPattern"), this.transform = new $t(), this._styleKey = null, this.texture = e, this.transform.scale(1 / e.frame.width, 1 / e.frame.height), r && (e.source.style.addressModeU = qB[r].addressModeU, e.source.style.addressModeV = qB[r].addressModeV);
    }
    setTransform(e) {
      const r = this.texture;
      this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(1 / r.frame.width, 1 / r.frame.height), this._styleKey = null;
    }
    get styleKey() {
      return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
    }
  };
  var P1, XB;
  function Oxe() {
    if (XB) return P1;
    XB = 1, P1 = r;
    var t = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    }, e = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function r(a) {
      var o = [];
      return a.replace(e, function(s, l, u) {
        var c = l.toLowerCase();
        for (u = i(u), c == "m" && u.length > 2 && (o.push([
          l
        ].concat(u.splice(0, 2))), c = "l", l = l == "m" ? "l" : "L"); ; ) {
          if (u.length == t[c]) return u.unshift(l), o.push(u);
          if (u.length < t[c]) throw new Error("malformed path data");
          o.push([
            l
          ].concat(u.splice(0, t[c])));
        }
      }), o;
    }
    var n = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function i(a) {
      var o = a.match(n);
      return o ? o.map(Number) : [];
    }
    return P1;
  }
  var Nxe = Oxe();
  const Bxe = GS(Nxe);
  function zxe(t, e) {
    const r = Bxe(t), n = [];
    let i = null, a = 0, o = 0;
    for (let s = 0; s < r.length; s++) {
      const l = r[s], u = l[0], c = l;
      switch (u) {
        case "M":
          a = c[1], o = c[2], e.moveTo(a, o);
          break;
        case "m":
          a += c[1], o += c[2], e.moveTo(a, o);
          break;
        case "H":
          a = c[1], e.lineTo(a, o);
          break;
        case "h":
          a += c[1], e.lineTo(a, o);
          break;
        case "V":
          o = c[1], e.lineTo(a, o);
          break;
        case "v":
          o += c[1], e.lineTo(a, o);
          break;
        case "L":
          a = c[1], o = c[2], e.lineTo(a, o);
          break;
        case "l":
          a += c[1], o += c[2], e.lineTo(a, o);
          break;
        case "C":
          a = c[5], o = c[6], e.bezierCurveTo(c[1], c[2], c[3], c[4], a, o);
          break;
        case "c":
          e.bezierCurveTo(a + c[1], o + c[2], a + c[3], o + c[4], a + c[5], o + c[6]), a += c[5], o += c[6];
          break;
        case "S":
          a = c[3], o = c[4], e.bezierCurveToShort(c[1], c[2], a, o);
          break;
        case "s":
          e.bezierCurveToShort(a + c[1], o + c[2], a + c[3], o + c[4]), a += c[3], o += c[4];
          break;
        case "Q":
          a = c[3], o = c[4], e.quadraticCurveTo(c[1], c[2], a, o);
          break;
        case "q":
          e.quadraticCurveTo(a + c[1], o + c[2], a + c[3], o + c[4]), a += c[3], o += c[4];
          break;
        case "T":
          a = c[1], o = c[2], e.quadraticCurveToShort(a, o);
          break;
        case "t":
          a += c[1], o += c[2], e.quadraticCurveToShort(a, o);
          break;
        case "A":
          a = c[6], o = c[7], e.arcToSvg(c[1], c[2], c[3], c[4], c[5], a, o);
          break;
        case "a":
          a += c[6], o += c[7], e.arcToSvg(c[1], c[2], c[3], c[4], c[5], a, o);
          break;
        case "Z":
        case "z":
          e.closePath(), n.length > 0 && (i = n.pop(), i ? (a = i.startX, o = i.startY) : (a = 0, o = 0)), i = null;
          break;
        default:
          Xn(`Unknown SVG path command: ${u}`);
      }
      u !== "Z" && u !== "z" && i === null && (i = {
        startX: a,
        startY: o
      }, n.push(i));
    }
    return e;
  }
  class WC {
    constructor(e = 0, r = 0, n = 0) {
      this.type = "circle", this.x = e, this.y = r, this.radius = n;
    }
    clone() {
      return new WC(this.x, this.y, this.radius);
    }
    contains(e, r) {
      if (this.radius <= 0) return false;
      const n = this.radius * this.radius;
      let i = this.x - e, a = this.y - r;
      return i *= i, a *= a, i + a <= n;
    }
    strokeContains(e, r, n, i = 0.5) {
      if (this.radius === 0) return false;
      const a = this.x - e, o = this.y - r, s = this.radius, l = (1 - i) * n, u = Math.sqrt(a * a + o * o);
      return u <= s + l && u > s - (n - l);
    }
    getBounds(e) {
      return e || (e = new Vr()), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.radius = e.radius, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  }
  class HC {
    constructor(e = 0, r = 0, n = 0, i = 0) {
      this.type = "ellipse", this.x = e, this.y = r, this.halfWidth = n, this.halfHeight = i;
    }
    clone() {
      return new HC(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(e, r) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;
      let n = (e - this.x) / this.halfWidth, i = (r - this.y) / this.halfHeight;
      return n *= n, i *= i, n + i <= 1;
    }
    strokeContains(e, r, n, i = 0.5) {
      const { halfWidth: a, halfHeight: o } = this;
      if (a <= 0 || o <= 0) return false;
      const s = n * (1 - i), l = n - s, u = a - l, c = o - l, h = a + s, f = o + s, d = e - this.x, p = r - this.y, v = d * d / (u * u) + p * p / (c * c), g = d * d / (h * h) + p * p / (f * f);
      return v > 1 && g <= 1;
    }
    getBounds(e) {
      return e || (e = new Vr()), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  }
  function Fxe(t, e, r, n, i, a) {
    const o = t - r, s = e - n, l = i - r, u = a - n, c = o * l + s * u, h = l * l + u * u;
    let f = -1;
    h !== 0 && (f = c / h);
    let d, p;
    f < 0 ? (d = r, p = n) : f > 1 ? (d = i, p = a) : (d = r + f * l, p = n + f * u);
    const v = t - d, g = e - p;
    return v * v + g * g;
  }
  let Vxe, Gxe;
  class Rf {
    constructor(...e) {
      this.type = "polygon";
      let r = Array.isArray(e[0]) ? e[0] : e;
      if (typeof r[0] != "number") {
        const n = [];
        for (let i = 0, a = r.length; i < a; i++) n.push(r[i].x, r[i].y);
        r = n;
      }
      this.points = r, this.closePath = true;
    }
    isClockwise() {
      let e = 0;
      const r = this.points, n = r.length;
      for (let i = 0; i < n; i += 2) {
        const a = r[i], o = r[i + 1], s = r[(i + 2) % n], l = r[(i + 3) % n];
        e += (s - a) * (l + o);
      }
      return e < 0;
    }
    containsPolygon(e) {
      const r = this.getBounds(Vxe), n = e.getBounds(Gxe);
      if (!r.containsRect(n)) return false;
      const i = e.points;
      for (let a = 0; a < i.length; a += 2) {
        const o = i[a], s = i[a + 1];
        if (!this.contains(o, s)) return false;
      }
      return true;
    }
    clone() {
      const e = this.points.slice(), r = new Rf(e);
      return r.closePath = this.closePath, r;
    }
    contains(e, r) {
      let n = false;
      const i = this.points.length / 2;
      for (let a = 0, o = i - 1; a < i; o = a++) {
        const s = this.points[a * 2], l = this.points[a * 2 + 1], u = this.points[o * 2], c = this.points[o * 2 + 1];
        l > r != c > r && e < (u - s) * ((r - l) / (c - l)) + s && (n = !n);
      }
      return n;
    }
    strokeContains(e, r, n, i = 0.5) {
      const a = n * n, o = a * (1 - i), s = a - o, { points: l } = this, u = l.length - (this.closePath ? 0 : 2);
      for (let c = 0; c < u; c += 2) {
        const h = l[c], f = l[c + 1], d = l[(c + 2) % l.length], p = l[(c + 3) % l.length], v = Fxe(e, r, h, f, d, p), g = Math.sign((d - h) * (r - f) - (p - f) * (e - h));
        if (v <= (g < 0 ? s : o)) return true;
      }
      return false;
    }
    getBounds(e) {
      e || (e = new Vr());
      const r = this.points;
      let n = 1 / 0, i = -1 / 0, a = 1 / 0, o = -1 / 0;
      for (let s = 0, l = r.length; s < l; s += 2) {
        const u = r[s], c = r[s + 1];
        n = u < n ? u : n, i = u > i ? u : i, a = c < a ? c : a, o = c > o ? c : o;
      }
      return e.x = n, e.width = i - n, e.y = a, e.height = o - a, e;
    }
    copyFrom(e) {
      return this.points = e.points.slice(), this.closePath = e.closePath, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, r) => `${e}, ${r}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      return this.points[this.points.length - 2];
    }
    get y() {
      return this.points[this.points.length - 1];
    }
  }
  const zv = (t, e, r, n, i, a, o) => {
    const s = t - r, l = e - n, u = Math.sqrt(s * s + l * l);
    return u >= i - a && u <= i + o;
  };
  class UC {
    constructor(e = 0, r = 0, n = 0, i = 0, a = 20) {
      this.type = "roundedRectangle", this.x = e, this.y = r, this.width = n, this.height = i, this.radius = a;
    }
    getBounds(e) {
      return e || (e = new Vr()), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
    }
    clone() {
      return new UC(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    contains(e, r) {
      if (this.width <= 0 || this.height <= 0) return false;
      if (e >= this.x && e <= this.x + this.width && r >= this.y && r <= this.y + this.height) {
        const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (r >= this.y + n && r <= this.y + this.height - n || e >= this.x + n && e <= this.x + this.width - n) return true;
        let i = e - (this.x + n), a = r - (this.y + n);
        const o = n * n;
        if (i * i + a * a <= o || (i = e - (this.x + this.width - n), i * i + a * a <= o) || (a = r - (this.y + this.height - n), i * i + a * a <= o) || (i = e - (this.x + n), i * i + a * a <= o)) return true;
      }
      return false;
    }
    strokeContains(e, r, n, i = 0.5) {
      const { x: a, y: o, width: s, height: l, radius: u } = this, c = n * (1 - i), h = n - c, f = a + u, d = o + u, p = s - u * 2, v = l - u * 2, g = a + s, m = o + l;
      return (e >= a - c && e <= a + h || e >= g - h && e <= g + c) && r >= d && r <= d + v || (r >= o - c && r <= o + h || r >= m - h && r <= m + c) && e >= f && e <= f + p ? true : e < f && r < d && zv(e, r, f, d, u, h, c) || e > g - u && r < d && zv(e, r, g - u, d, u, h, c) || e > g - u && r > m - u && zv(e, r, g - u, m - u, u, h, c) || e < f && r > m - u && zv(e, r, f, m - u, u, h, c);
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }
  const Wxe = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join(`
`);
  function Hxe(t) {
    let e = "";
    for (let r = 0; r < t; ++r) r > 0 && (e += `
else `), r < t - 1 && (e += `if(test == ${r}.0){}`);
    return e;
  }
  function Uxe(t, e) {
    if (t === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const r = e.createShader(e.FRAGMENT_SHADER);
    try {
      for (; ; ) {
        const n = Wxe.replace(/%forloop%/gi, Hxe(t));
        if (e.shaderSource(r, n), e.compileShader(r), !e.getShaderParameter(r, e.COMPILE_STATUS)) t = t / 2 | 0;
        else break;
      }
    } finally {
      e.deleteShader(r);
    }
    return t;
  }
  let Vu = null;
  wq = function() {
    var _a2;
    if (Vu) return Vu;
    const t = sq();
    return Vu = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), Vu = Uxe(Vu, t), (_a2 = t.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), Vu;
  };
  const Sq = {};
  Yxe = function(t, e) {
    let r = 2166136261;
    for (let n = 0; n < e; n++) r ^= t[n].uid, r = Math.imul(r, 16777619), r >>>= 0;
    return Sq[r] || qxe(t, e, r);
  };
  let L1 = 0;
  function qxe(t, e, r) {
    const n = {};
    let i = 0;
    L1 || (L1 = wq());
    for (let o = 0; o < L1; o++) {
      const s = o < e ? t[o] : Kt.EMPTY.source;
      n[i++] = s.source, n[i++] = s.style;
    }
    const a = new _g(n);
    return Sq[r] = a, a;
  }
  jB = class {
    constructor(e) {
      typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
    }
    get int8View() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    }
    get uint8View() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    }
    get int16View() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    }
    get int32View() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    }
    get float64View() {
      return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
    }
    get bigUint64View() {
      return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
    }
    view(e) {
      return this[`${e}View`];
    }
    destroy() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }
    static sizeOf(e) {
      switch (e) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${e} isn't a valid view type`);
      }
    }
  };
  KB = function(t, e) {
    const r = t.byteLength / 8 | 0, n = new Float64Array(t, 0, r);
    new Float64Array(e, 0, r).set(n);
    const a = t.byteLength - r * 8;
    if (a > 0) {
      const o = new Uint8Array(t, r * 8, a);
      new Uint8Array(e, r * 8, a).set(o);
    }
  };
  const Xxe = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  jxe = ((t) => (t[t.DISABLED = 0] = "DISABLED", t[t.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", t[t.MASK_ACTIVE = 2] = "MASK_ACTIVE", t[t.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", t[t.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", t[t.NONE = 5] = "NONE", t))(jxe || {});
  ZB = function(t, e) {
    return e.alphaMode === "no-premultiply-alpha" && Xxe[t] || t;
  };
  class Kxe {
    constructor() {
      this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
    }
    clear() {
      for (let e = 0; e < this.count; e++) {
        const r = this.textures[e];
        this.textures[e] = null, this.ids[r.uid] = null;
      }
      this.count = 0;
    }
  }
  class Zxe {
    constructor() {
      this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new Kxe(), this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = true;
    }
    destroy() {
      this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
    }
  }
  const Tq = [];
  let bS = 0;
  function QB() {
    return bS > 0 ? Tq[--bS] : new Zxe();
  }
  function JB(t) {
    Tq[bS++] = t;
  }
  let Uh = 0;
  const Cq = class bg {
    constructor(e = {}) {
      this.uid = wr("batcher"), this.dirty = true, this.batchIndex = 0, this.batches = [], this._elements = [], bg.defaultOptions.maxTextures = bg.defaultOptions.maxTextures ?? wq(), e = {
        ...bg.defaultOptions,
        ...e
      };
      const { maxTextures: r, attributesInitialSize: n, indicesInitialSize: i } = e;
      this.attributeBuffer = new jB(n * 4), this.indexBuffer = new Uint16Array(i), this.maxTextures = r;
    }
    begin() {
      this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
      for (let e = 0; e < this.batchIndex; e++) JB(this.batches[e]);
      this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = true;
    }
    add(e) {
      this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize;
    }
    checkAndUpdateTexture(e, r) {
      const n = e._batch.textures.ids[r._source.uid];
      return !n && n !== 0 ? false : (e._textureId = n, e.texture = r, true);
    }
    updateElement(e) {
      this.dirty = true;
      const r = this.attributeBuffer;
      e.packAsQuad ? this.packQuadAttributes(e, r.float32View, r.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, r.float32View, r.uint32View, e._attributeStart, e._textureId);
    }
    break(e) {
      const r = this._elements;
      if (!r[this.elementStart]) return;
      let n = QB(), i = n.textures;
      i.clear();
      const a = r[this.elementStart];
      let o = ZB(a.blendMode, a.texture._source), s = a.topology;
      this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
      const l = this.attributeBuffer.float32View, u = this.attributeBuffer.uint32View, c = this.indexBuffer;
      let h = this._batchIndexSize, f = this._batchIndexStart, d = "startBatch";
      const p = this.maxTextures;
      for (let v = this.elementStart; v < this.elementSize; ++v) {
        const g = r[v];
        r[v] = null;
        const y = g.texture._source, _ = ZB(g.blendMode, y), b = o !== _ || s !== g.topology;
        if (y._batchTick === Uh && !b) {
          g._textureId = y._textureBindLocation, h += g.indexSize, g.packAsQuad ? (this.packQuadAttributes(g, l, u, g._attributeStart, g._textureId), this.packQuadIndex(c, g._indexStart, g._attributeStart / this.vertexSize)) : (this.packAttributes(g, l, u, g._attributeStart, g._textureId), this.packIndex(g, c, g._indexStart, g._attributeStart / this.vertexSize)), g._batch = n;
          continue;
        }
        y._batchTick = Uh, (i.count >= p || b) && (this._finishBatch(n, f, h - f, i, o, s, e, d), d = "renderBatch", f = h, o = _, s = g.topology, n = QB(), i = n.textures, i.clear(), ++Uh), g._textureId = y._textureBindLocation = i.count, i.ids[y.uid] = i.count, i.textures[i.count++] = y, g._batch = n, h += g.indexSize, g.packAsQuad ? (this.packQuadAttributes(g, l, u, g._attributeStart, g._textureId), this.packQuadIndex(c, g._indexStart, g._attributeStart / this.vertexSize)) : (this.packAttributes(g, l, u, g._attributeStart, g._textureId), this.packIndex(g, c, g._indexStart, g._attributeStart / this.vertexSize));
      }
      i.count > 0 && (this._finishBatch(n, f, h - f, i, o, s, e, d), f = h, ++Uh), this.elementStart = this.elementSize, this._batchIndexStart = f, this._batchIndexSize = h;
    }
    _finishBatch(e, r, n, i, a, o, s, l) {
      e.gpuBindGroup = null, e.bindGroup = null, e.action = l, e.batcher = this, e.textures = i, e.blendMode = a, e.topology = o, e.start = r, e.size = n, ++Uh, this.batches[this.batchIndex++] = e, s.add(e);
    }
    finish(e) {
      this.break(e);
    }
    ensureAttributeBuffer(e) {
      e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4);
    }
    ensureIndexBuffer(e) {
      e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
    }
    _resizeAttributeBuffer(e) {
      const r = Math.max(e, this.attributeBuffer.size * 2), n = new jB(r);
      KB(this.attributeBuffer.rawBinaryData, n.rawBinaryData), this.attributeBuffer = n;
    }
    _resizeIndexBuffer(e) {
      const r = this.indexBuffer;
      let n = Math.max(e, r.length * 1.5);
      n += n % 2;
      const i = n > 65535 ? new Uint32Array(n) : new Uint16Array(n);
      if (i.BYTES_PER_ELEMENT !== r.BYTES_PER_ELEMENT) for (let a = 0; a < r.length; a++) i[a] = r[a];
      else KB(r.buffer, i.buffer);
      this.indexBuffer = i;
    }
    packQuadIndex(e, r, n) {
      e[r] = n + 0, e[r + 1] = n + 1, e[r + 2] = n + 2, e[r + 3] = n + 0, e[r + 4] = n + 2, e[r + 5] = n + 3;
    }
    packIndex(e, r, n, i) {
      const a = e.indices, o = e.indexSize, s = e.indexOffset, l = e.attributeOffset;
      for (let u = 0; u < o; u++) r[n++] = i + a[u + s] - l;
    }
    destroy() {
      for (let e = 0; e < this.batches.length; e++) JB(this.batches[e]);
      this.batches = null;
      for (let e = 0; e < this._elements.length; e++) this._elements[e]._batch = null;
      this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
    }
  };
  Cq.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6
  };
  let Qxe = Cq;
  En = ((t) => (t[t.MAP_READ = 1] = "MAP_READ", t[t.MAP_WRITE = 2] = "MAP_WRITE", t[t.COPY_SRC = 4] = "COPY_SRC", t[t.COPY_DST = 8] = "COPY_DST", t[t.INDEX = 16] = "INDEX", t[t.VERTEX = 32] = "VERTEX", t[t.UNIFORM = 64] = "UNIFORM", t[t.STORAGE = 128] = "STORAGE", t[t.INDIRECT = 256] = "INDIRECT", t[t.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", t[t.STATIC = 1024] = "STATIC", t))(En || {});
  xd = class extends Fa {
    constructor(e) {
      let { data: r, size: n } = e;
      const { usage: i, label: a, shrinkToFit: o } = e;
      super(), this.uid = wr("buffer"), this._resourceType = "buffer", this._resourceId = wr("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = true, this.destroyed = false, r instanceof Array && (r = new Float32Array(r)), this._data = r, n ?? (n = r == null ? void 0 : r.byteLength);
      const s = !!r;
      this.descriptor = {
        size: n,
        usage: i,
        mappedAtCreation: s,
        label: a
      }, this.shrinkToFit = o ?? true;
    }
    get data() {
      return this._data;
    }
    set data(e) {
      this.setDataWithSize(e, e.length, true);
    }
    get dataInt32() {
      return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
    }
    get static() {
      return !!(this.descriptor.usage & En.STATIC);
    }
    set static(e) {
      e ? this.descriptor.usage |= En.STATIC : this.descriptor.usage &= ~En.STATIC;
    }
    setDataWithSize(e, r, n) {
      if (this._updateID++, this._updateSize = r * e.BYTES_PER_ELEMENT, this._data === e) {
        n && this.emit("update", this);
        return;
      }
      const i = this._data;
      if (this._data = e, this._dataInt32 = null, !i || i.length !== e.length) {
        !this.shrinkToFit && i && e.byteLength < i.byteLength ? n && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = wr("resource"), this.emit("change", this));
        return;
      }
      n && this.emit("update", this);
    }
    update(e) {
      this._updateSize = e ?? this._updateSize, this._updateID++, this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
    }
  };
  function Aq(t, e) {
    if (!(t instanceof xd)) {
      let r = e ? En.INDEX : En.VERTEX;
      t instanceof Array && (e ? (t = new Uint32Array(t), r = En.INDEX | En.COPY_DST) : (t = new Float32Array(t), r = En.VERTEX | En.COPY_DST)), t = new xd({
        data: t,
        label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage: r
      });
    }
    return t;
  }
  function Jxe(t, e, r) {
    const n = t.getAttribute(e);
    if (!n) return r.minX = 0, r.minY = 0, r.maxX = 0, r.maxY = 0, r;
    const i = n.buffer.data;
    let a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0;
    const u = i.BYTES_PER_ELEMENT, c = (n.offset || 0) / u, h = (n.stride || 2 * 4) / u;
    for (let f = c; f < i.length; f += h) {
      const d = i[f], p = i[f + 1];
      d > s && (s = d), p > l && (l = p), d < a && (a = d), p < o && (o = p);
    }
    return r.minX = a, r.minY = o, r.maxX = s, r.maxY = l, r;
  }
  function ewe(t) {
    return (t instanceof xd || Array.isArray(t) || t.BYTES_PER_ELEMENT) && (t = {
      buffer: t
    }), t.buffer = Aq(t.buffer, false), t;
  }
  twe = class extends Fa {
    constructor(e = {}) {
      super(), this.uid = wr("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new Zi(), this._boundsDirty = true;
      const { attributes: r, indexBuffer: n, topology: i } = e;
      if (this.buffers = [], this.attributes = {}, r) for (const a in r) this.addAttribute(a, r[a]);
      this.instanceCount = e.instanceCount ?? 1, n && this.addIndex(n), this.topology = i || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true, this.emit("update", this);
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(e) {
      return this.getAttribute(e).buffer;
    }
    getSize() {
      for (const e in this.attributes) {
        const r = this.attributes[e];
        return r.buffer.data.length / (r.stride / 4 || r.size);
      }
      return 0;
    }
    addAttribute(e, r) {
      const n = ewe(r);
      this.buffers.indexOf(n.buffer) === -1 && (this.buffers.push(n.buffer), n.buffer.on("update", this.onBufferUpdate, this), n.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = n;
    }
    addIndex(e) {
      this.indexBuffer = Aq(e, true), this.buffers.push(this.indexBuffer);
    }
    get bounds() {
      return this._boundsDirty ? (this._boundsDirty = false, Jxe(this, "aPosition", this._bounds)) : this._bounds;
    }
    destroy(e = false) {
      this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach((r) => r.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
    }
  };
  const rwe = new Float32Array(1), nwe = new Uint32Array(1);
  class iwe extends twe {
    constructor() {
      const r = new xd({
        data: rwe,
        label: "attribute-batch-buffer",
        usage: En.VERTEX | En.COPY_DST,
        shrinkToFit: false
      }), n = new xd({
        data: nwe,
        label: "index-batch-buffer",
        usage: En.INDEX | En.COPY_DST,
        shrinkToFit: false
      }), i = 6 * 4;
      super({
        attributes: {
          aPosition: {
            buffer: r,
            format: "float32x2",
            stride: i,
            offset: 0
          },
          aUV: {
            buffer: r,
            format: "float32x2",
            stride: i,
            offset: 2 * 4
          },
          aColor: {
            buffer: r,
            format: "unorm8x4",
            stride: i,
            offset: 4 * 4
          },
          aTextureIdAndRound: {
            buffer: r,
            format: "uint16x2",
            stride: i,
            offset: 5 * 4
          }
        },
        indexBuffer: n
      });
    }
  }
  function ez(t, e, r) {
    if (t) for (const n in t) {
      const i = n.toLocaleLowerCase(), a = e[i];
      if (a) {
        let o = t[n];
        n === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), r && a.push(`//----${r}----//`), a.push(o);
      } else Xn(`${n} placement hook does not exist in shader`);
    }
  }
  const awe = /\{\{(.*?)\}\}/g;
  function tz(t) {
    var _a2;
    const e = {};
    return (((_a2 = t.match(awe)) == null ? void 0 : _a2.map((n) => n.replace(/[{()}]/g, ""))) ?? []).forEach((n) => {
      e[n] = [];
    }), e;
  }
  function rz(t, e) {
    let r;
    const n = /@in\s+([^;]+);/g;
    for (; (r = n.exec(t)) !== null; ) e.push(r[1]);
  }
  function nz(t, e, r = false) {
    const n = [];
    rz(e, n), t.forEach((s) => {
      s.header && rz(s.header, n);
    });
    const i = n;
    r && i.sort();
    const a = i.map((s, l) => `       @location(${l}) ${s},`).join(`
`);
    let o = e.replace(/@in\s+[^;]+;\s*/g, "");
    return o = o.replace("{{in}}", `
${a}
`), o;
  }
  function iz(t, e) {
    let r;
    const n = /@out\s+([^;]+);/g;
    for (; (r = n.exec(t)) !== null; ) e.push(r[1]);
  }
  function owe(t) {
    const r = /\b(\w+)\s*:/g.exec(t);
    return r ? r[1] : "";
  }
  function swe(t) {
    const e = /@.*?\s+/g;
    return t.replace(e, "");
  }
  function lwe(t, e) {
    const r = [];
    iz(e, r), t.forEach((l) => {
      l.header && iz(l.header, r);
    });
    let n = 0;
    const i = r.sort().map((l) => l.indexOf("builtin") > -1 ? l : `@location(${n++}) ${l}`).join(`,
`), a = r.sort().map((l) => `       var ${swe(l)};`).join(`
`), o = `return VSOutput(
            ${r.sort().map((l) => ` ${owe(l)}`).join(`,
`)});`;
    let s = e.replace(/@out\s+[^;]+;\s*/g, "");
    return s = s.replace("{{struct}}", `
${i}
`), s = s.replace("{{start}}", `
${a}
`), s = s.replace("{{return}}", `
${o}
`), s;
  }
  function az(t, e) {
    let r = t;
    for (const n in e) {
      const i = e[n];
      i.join(`
`).length ? r = r.replace(`{{${n}}}`, `//-----${n} START-----//
${i.join(`
`)}
//----${n} FINISH----//`) : r = r.replace(`{{${n}}}`, "");
    }
    return r;
  }
  const is = /* @__PURE__ */ Object.create(null), $1 = /* @__PURE__ */ new Map();
  let uwe = 0;
  function cwe({ template: t, bits: e }) {
    const r = Iq(t, e);
    if (is[r]) return is[r];
    const { vertex: n, fragment: i } = fwe(t, e);
    return is[r] = Mq(n, i, e), is[r];
  }
  function hwe({ template: t, bits: e }) {
    const r = Iq(t, e);
    return is[r] || (is[r] = Mq(t.vertex, t.fragment, e)), is[r];
  }
  function fwe(t, e) {
    const r = e.map((o) => o.vertex).filter((o) => !!o), n = e.map((o) => o.fragment).filter((o) => !!o);
    let i = nz(r, t.vertex, true);
    i = lwe(r, i);
    const a = nz(n, t.fragment, true);
    return {
      vertex: i,
      fragment: a
    };
  }
  function Iq(t, e) {
    return e.map((r) => ($1.has(r) || $1.set(r, uwe++), $1.get(r))).sort((r, n) => r - n).join("-") + t.vertex + t.fragment;
  }
  function Mq(t, e, r) {
    const n = tz(t), i = tz(e);
    return r.forEach((a) => {
      ez(a.vertex, n, a.name), ez(a.fragment, i, a.name);
    }), {
      vertex: az(t, n),
      fragment: az(e, i)
    };
  }
  const dwe = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, pwe = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, vwe = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, gwe = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`, mwe = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    }
  }, ywe = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    }
  };
  _we = function({ bits: t, name: e }) {
    const r = cwe({
      template: {
        fragment: pwe,
        vertex: dwe
      },
      bits: [
        mwe,
        ...t
      ]
    });
    return Sy.from({
      name: e,
      vertex: {
        source: r.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: r.fragment,
        entryPoint: "main"
      }
    });
  };
  bwe = function({ bits: t, name: e }) {
    return new uq({
      name: e,
      ...hwe({
        template: {
          vertex: vwe,
          fragment: gwe
        },
        bits: [
          ywe,
          ...t
        ]
      })
    });
  };
  let R1;
  xwe = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  wwe = {
    name: "color-bit",
    vertex: {
      header: `
            in vec4 aColor;
        `,
      main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  R1 = {};
  function Swe(t) {
    const e = [];
    if (t === 1) e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
      let r = 0;
      for (let n = 0; n < t; n++) e.push(`@group(1) @binding(${r++}) var textureSource${n + 1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${r++}) var textureSampler${n + 1}: sampler;`);
    }
    return e.join(`
`);
  }
  function Twe(t) {
    const e = [];
    if (t === 1) e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
      e.push("switch vTextureId {");
      for (let r = 0; r < t; r++) r === t - 1 ? e.push("  default:{") : e.push(`  case ${r}:{`), e.push(`      outColor = textureSampleGrad(textureSource${r + 1}, textureSampler${r + 1}, vUV, uvDx, uvDy);`), e.push("      break;}");
      e.push("}");
    }
    return e.join(`
`);
  }
  Cwe = function(t) {
    return R1[t] || (R1[t] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${Swe(t)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${Twe(t)}
            `
      }
    }), R1[t];
  };
  const O1 = {};
  function Awe(t) {
    const e = [];
    for (let r = 0; r < t; r++) r > 0 && e.push("else"), r < t - 1 && e.push(`if(vTextureId < ${r}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${r}], vUV);`), e.push("}");
    return e.join(`
`);
  }
  Iwe = function(t) {
    return O1[t] || (O1[t] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${t}];

            `,
        main: `

                ${Awe(t)}
            `
      }
    }), O1[t];
  };
  let oz;
  Mwe = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  Dwe = {
    name: "round-pixels-bit",
    vertex: {
      header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  oz = {};
  Ewe = function(t) {
    let e = oz[t];
    if (e) return e;
    const r = new Int32Array(t);
    for (let n = 0; n < t; n++) r[n] = n;
    return e = oz[t] = new dq({
      uTextures: {
        value: r,
        type: "i32",
        size: t
      }
    }, {
      isStatic: true
    }), e;
  };
  class kwe extends FC {
    constructor(e) {
      const r = bwe({
        name: "batch",
        bits: [
          wwe,
          Iwe(e),
          Dwe
        ]
      }), n = _we({
        name: "batch",
        bits: [
          xwe,
          Cwe(e),
          Mwe
        ]
      });
      super({
        glProgram: r,
        gpuProgram: n,
        resources: {
          batchSamplers: Ewe(e)
        }
      });
    }
  }
  let sz = null;
  const Dq = class Eq extends Qxe {
    constructor() {
      super(...arguments), this.geometry = new iwe(), this.shader = sz || (sz = new kwe(this.maxTextures)), this.name = Eq.extension.name, this.vertexSize = 6;
    }
    packAttributes(e, r, n, i, a) {
      const o = a << 16 | e.roundPixels & 65535, s = e.transform, l = s.a, u = s.b, c = s.c, h = s.d, f = s.tx, d = s.ty, { positions: p, uvs: v } = e, g = e.color, m = e.attributeOffset, y = m + e.attributeSize;
      for (let _ = m; _ < y; _++) {
        const b = _ * 2, w = p[b], x = p[b + 1];
        r[i++] = l * w + c * x + f, r[i++] = h * x + u * w + d, r[i++] = v[b], r[i++] = v[b + 1], n[i++] = g, n[i++] = o;
      }
    }
    packQuadAttributes(e, r, n, i, a) {
      const o = e.texture, s = e.transform, l = s.a, u = s.b, c = s.c, h = s.d, f = s.tx, d = s.ty, p = e.bounds, v = p.maxX, g = p.minX, m = p.maxY, y = p.minY, _ = o.uvs, b = e.color, w = a << 16 | e.roundPixels & 65535;
      r[i + 0] = l * g + c * y + f, r[i + 1] = h * y + u * g + d, r[i + 2] = _.x0, r[i + 3] = _.y0, n[i + 4] = b, n[i + 5] = w, r[i + 6] = l * v + c * y + f, r[i + 7] = h * y + u * v + d, r[i + 8] = _.x1, r[i + 9] = _.y1, n[i + 10] = b, n[i + 11] = w, r[i + 12] = l * v + c * m + f, r[i + 13] = h * m + u * v + d, r[i + 14] = _.x2, r[i + 15] = _.y2, n[i + 16] = b, n[i + 17] = w, r[i + 18] = l * g + c * m + f, r[i + 19] = h * m + u * g + d, r[i + 20] = _.x3, r[i + 21] = _.y3, n[i + 22] = b, n[i + 23] = w;
    }
  };
  Dq.extension = {
    type: [
      qt.Batcher
    ],
    name: "default"
  };
  Pwe = Dq;
  function Lwe(t, e, r, n, i, a, o, s = null) {
    let l = 0;
    r *= e, i *= a;
    const u = s.a, c = s.b, h = s.c, f = s.d, d = s.tx, p = s.ty;
    for (; l < o; ) {
      const v = t[r], g = t[r + 1];
      n[i] = u * v + h * g + d, n[i + 1] = c * v + f * g + p, i += a, r += e, l++;
    }
  }
  function $we(t, e, r, n) {
    let i = 0;
    for (e *= r; i < n; ) t[e] = 0, t[e + 1] = 0, e += r, i++;
  }
  function kq(t, e, r, n, i) {
    const a = e.a, o = e.b, s = e.c, l = e.d, u = e.tx, c = e.ty;
    r || (r = 0), n || (n = 2), i || (i = t.length / n - r);
    let h = r * n;
    for (let f = 0; f < i; f++) {
      const d = t[h], p = t[h + 1];
      t[h] = a * d + s * p + u, t[h + 1] = o * d + l * p + c, h += n;
    }
  }
  const Rwe = new $t();
  Pq = class {
    constructor() {
      this.packAsQuad = false, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = true, this.roundPixels = 0, this._batcher = null, this._batch = null;
    }
    get uvs() {
      return this.geometryData.uvs;
    }
    get positions() {
      return this.geometryData.vertices;
    }
    get indices() {
      return this.geometryData.indices;
    }
    get blendMode() {
      return this.applyTransform ? this.renderable.groupBlendMode : "normal";
    }
    get color() {
      const e = this.baseColor, r = e >> 16 | e & 65280 | (e & 255) << 16, n = this.renderable;
      return n ? V9(r, n.groupColor) + (this.alpha * n.groupAlpha * 255 << 24) : r + (this.alpha * 255 << 24);
    }
    get transform() {
      var _a2;
      return ((_a2 = this.renderable) == null ? void 0 : _a2.groupTransform) || Rwe;
    }
    copyTo(e) {
      e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology;
    }
    reset() {
      this.applyTransform = true, this.renderable = null, this.topology = "triangle-list";
    }
  };
  const wd = {
    extension: {
      type: qt.ShapeBuilder,
      name: "circle"
    },
    build(t, e) {
      let r, n, i, a, o, s;
      if (t.type === "circle") {
        const b = t;
        r = b.x, n = b.y, o = s = b.radius, i = a = 0;
      } else if (t.type === "ellipse") {
        const b = t;
        r = b.x, n = b.y, o = b.halfWidth, s = b.halfHeight, i = a = 0;
      } else {
        const b = t, w = b.width / 2, x = b.height / 2;
        r = b.x + w, n = b.y + x, o = s = Math.max(0, Math.min(b.radius, Math.min(w, x))), i = w - o, a = x - s;
      }
      if (!(o >= 0 && s >= 0 && i >= 0 && a >= 0)) return e;
      const l = Math.ceil(2.3 * Math.sqrt(o + s)), u = l * 8 + (i ? 4 : 0) + (a ? 4 : 0);
      if (u === 0) return e;
      if (l === 0) return e[0] = e[6] = r + i, e[1] = e[3] = n + a, e[2] = e[4] = r - i, e[5] = e[7] = n - a, e;
      let c = 0, h = l * 4 + (i ? 2 : 0) + 2, f = h, d = u, p = i + o, v = a, g = r + p, m = r - p, y = n + v;
      if (e[c++] = g, e[c++] = y, e[--h] = y, e[--h] = m, a) {
        const b = n - v;
        e[f++] = m, e[f++] = b, e[--d] = b, e[--d] = g;
      }
      for (let b = 1; b < l; b++) {
        const w = Math.PI / 2 * (b / l), x = i + Math.cos(w) * o, T = a + Math.sin(w) * s, A = r + x, I = r - x, M = n + T, k = n - T;
        e[c++] = A, e[c++] = M, e[--h] = M, e[--h] = I, e[f++] = I, e[f++] = k, e[--d] = k, e[--d] = A;
      }
      p = i, v = a + s, g = r + p, m = r - p, y = n + v;
      const _ = n - v;
      return e[c++] = g, e[c++] = y, e[--d] = _, e[--d] = g, i && (e[c++] = m, e[c++] = y, e[--d] = _, e[--d] = m), e;
    },
    triangulate(t, e, r, n, i, a) {
      if (t.length === 0) return;
      let o = 0, s = 0;
      for (let c = 0; c < t.length; c += 2) o += t[c], s += t[c + 1];
      o /= t.length / 2, s /= t.length / 2;
      let l = n;
      e[l * r] = o, e[l * r + 1] = s;
      const u = l++;
      for (let c = 0; c < t.length; c += 2) e[l * r] = t[c], e[l * r + 1] = t[c + 1], c > 0 && (i[a++] = l, i[a++] = u, i[a++] = l - 1), l++;
      i[a++] = u + 1, i[a++] = u, i[a++] = l - 1;
    }
  }, Owe = {
    ...wd,
    extension: {
      ...wd.extension,
      name: "ellipse"
    }
  }, Nwe = {
    ...wd,
    extension: {
      ...wd.extension,
      name: "roundedRectangle"
    }
  }, Lq = 1e-4, lz = 1e-4;
  function Bwe(t) {
    const e = t.length;
    if (e < 6) return 1;
    let r = 0;
    for (let n = 0, i = t[e - 2], a = t[e - 1]; n < e; n += 2) {
      const o = t[n], s = t[n + 1];
      r += (o - i) * (s + a), i = o, a = s;
    }
    return r < 0 ? -1 : 1;
  }
  function uz(t, e, r, n, i, a, o, s) {
    const l = t - r * i, u = e - n * i, c = t + r * a, h = e + n * a;
    let f, d;
    o ? (f = n, d = -r) : (f = -n, d = r);
    const p = l + f, v = u + d, g = c + f, m = h + d;
    return s.push(p, v), s.push(g, m), 2;
  }
  function nl(t, e, r, n, i, a, o, s) {
    const l = r - t, u = n - e;
    let c = Math.atan2(l, u), h = Math.atan2(i - t, a - e);
    s && c < h ? c += Math.PI * 2 : !s && c > h && (h += Math.PI * 2);
    let f = c;
    const d = h - c, p = Math.abs(d), v = Math.sqrt(l * l + u * u), g = (15 * p * Math.sqrt(v) / Math.PI >> 0) + 1, m = d / g;
    if (f += m, s) {
      o.push(t, e), o.push(r, n);
      for (let y = 1, _ = f; y < g; y++, _ += m) o.push(t, e), o.push(t + Math.sin(_) * v, e + Math.cos(_) * v);
      o.push(t, e), o.push(i, a);
    } else {
      o.push(r, n), o.push(t, e);
      for (let y = 1, _ = f; y < g; y++, _ += m) o.push(t + Math.sin(_) * v, e + Math.cos(_) * v), o.push(t, e);
      o.push(i, a), o.push(t, e);
    }
    return g * 2;
  }
  function zwe(t, e, r, n, i, a) {
    const o = Lq;
    if (t.length === 0) return;
    const s = e;
    let l = s.alignment;
    if (e.alignment !== 0.5) {
      let V = Bwe(t);
      l = (l - 0.5) * V + 0.5;
    }
    const u = new rn(t[0], t[1]), c = new rn(t[t.length - 2], t[t.length - 1]), h = n, f = Math.abs(u.x - c.x) < o && Math.abs(u.y - c.y) < o;
    if (h) {
      t = t.slice(), f && (t.pop(), t.pop(), c.set(t[t.length - 2], t[t.length - 1]));
      const V = (u.x + c.x) * 0.5, H = (c.y + u.y) * 0.5;
      t.unshift(V, H), t.push(V, H);
    }
    const d = i, p = t.length / 2;
    let v = t.length;
    const g = d.length / 2, m = s.width / 2, y = m * m, _ = s.miterLimit * s.miterLimit;
    let b = t[0], w = t[1], x = t[2], T = t[3], A = 0, I = 0, M = -(w - T), k = b - x, B = 0, L = 0, z = Math.sqrt(M * M + k * k);
    M /= z, k /= z, M *= m, k *= m;
    const F = l, E = (1 - F) * 2, O = F * 2;
    h || (s.cap === "round" ? v += nl(b - M * (E - O) * 0.5, w - k * (E - O) * 0.5, b - M * E, w - k * E, b + M * O, w + k * O, d, true) + 2 : s.cap === "square" && (v += uz(b, w, M, k, E, O, true, d))), d.push(b - M * E, w - k * E), d.push(b + M * O, w + k * O);
    for (let V = 1; V < p - 1; ++V) {
      b = t[(V - 1) * 2], w = t[(V - 1) * 2 + 1], x = t[V * 2], T = t[V * 2 + 1], A = t[(V + 1) * 2], I = t[(V + 1) * 2 + 1], M = -(w - T), k = b - x, z = Math.sqrt(M * M + k * k), M /= z, k /= z, M *= m, k *= m, B = -(T - I), L = x - A, z = Math.sqrt(B * B + L * L), B /= z, L /= z, B *= m, L *= m;
      const H = x - b, G = w - T, Y = x - A, U = I - T, Z = H * Y + G * U, ee = G * Y - U * H, we = ee < 0;
      if (Math.abs(ee) < 1e-3 * Math.abs(Z)) {
        d.push(x - M * E, T - k * E), d.push(x + M * O, T + k * O), Z >= 0 && (s.join === "round" ? v += nl(x, T, x - M * E, T - k * E, x - B * E, T - L * E, d, false) + 4 : v += 2, d.push(x - B * O, T - L * O), d.push(x + B * E, T + L * E));
        continue;
      }
      const Te = (-M + b) * (-k + T) - (-M + x) * (-k + w), le = (-B + A) * (-L + T) - (-B + x) * (-L + I), ue = (H * le - Y * Te) / ee, ye = (U * Te - G * le) / ee, ve = (ue - x) * (ue - x) + (ye - T) * (ye - T), Se = x + (ue - x) * E, Qe = T + (ye - T) * E, Xe = x - (ue - x) * O, be = T - (ye - T) * O, ke = Math.min(H * H + G * G, Y * Y + U * U), Vt = we ? E : O, X = ke + Vt * Vt * y;
      ve <= X ? s.join === "bevel" || ve / y > _ ? (we ? (d.push(Se, Qe), d.push(x + M * O, T + k * O), d.push(Se, Qe), d.push(x + B * O, T + L * O)) : (d.push(x - M * E, T - k * E), d.push(Xe, be), d.push(x - B * E, T - L * E), d.push(Xe, be)), v += 2) : s.join === "round" ? we ? (d.push(Se, Qe), d.push(x + M * O, T + k * O), v += nl(x, T, x + M * O, T + k * O, x + B * O, T + L * O, d, true) + 4, d.push(Se, Qe), d.push(x + B * O, T + L * O)) : (d.push(x - M * E, T - k * E), d.push(Xe, be), v += nl(x, T, x - M * E, T - k * E, x - B * E, T - L * E, d, false) + 4, d.push(x - B * E, T - L * E), d.push(Xe, be)) : (d.push(Se, Qe), d.push(Xe, be)) : (d.push(x - M * E, T - k * E), d.push(x + M * O, T + k * O), s.join === "round" ? we ? v += nl(x, T, x + M * O, T + k * O, x + B * O, T + L * O, d, true) + 2 : v += nl(x, T, x - M * E, T - k * E, x - B * E, T - L * E, d, false) + 2 : s.join === "miter" && ve / y <= _ && (we ? (d.push(Xe, be), d.push(Xe, be)) : (d.push(Se, Qe), d.push(Se, Qe)), v += 2), d.push(x - B * E, T - L * E), d.push(x + B * O, T + L * O), v += 2);
    }
    b = t[(p - 2) * 2], w = t[(p - 2) * 2 + 1], x = t[(p - 1) * 2], T = t[(p - 1) * 2 + 1], M = -(w - T), k = b - x, z = Math.sqrt(M * M + k * k), M /= z, k /= z, M *= m, k *= m, d.push(x - M * E, T - k * E), d.push(x + M * O, T + k * O), h || (s.cap === "round" ? v += nl(x - M * (E - O) * 0.5, T - k * (E - O) * 0.5, x - M * E, T - k * E, x + M * O, T + k * O, d, false) + 2 : s.cap === "square" && (v += uz(x, T, M, k, E, O, false, d)));
    const N = lz * lz;
    for (let V = g; V < v + g - 2; ++V) b = d[V * 2], w = d[V * 2 + 1], x = d[(V + 1) * 2], T = d[(V + 1) * 2 + 1], A = d[(V + 2) * 2], I = d[(V + 2) * 2 + 1], !(Math.abs(b * (T - I) + x * (I - w) + A * (w - T)) < N) && a.push(V, V + 1, V + 2);
  }
  function Fwe(t, e, r, n) {
    const i = Lq;
    if (t.length === 0) return;
    const a = t[0], o = t[1], s = t[t.length - 2], l = t[t.length - 1], u = e || Math.abs(a - s) < i && Math.abs(o - l) < i, c = r, h = t.length / 2, f = c.length / 2;
    for (let d = 0; d < h; d++) c.push(t[d * 2]), c.push(t[d * 2 + 1]);
    for (let d = 0; d < h - 1; d++) n.push(f + d, f + d + 1);
    u && n.push(f + h - 1, f);
  }
  function $q(t, e, r, n, i, a, o) {
    const s = Mxe(t, e, 2);
    if (!s) return;
    for (let u = 0; u < s.length; u += 3) a[o++] = s[u] + i, a[o++] = s[u + 1] + i, a[o++] = s[u + 2] + i;
    let l = i * n;
    for (let u = 0; u < t.length; u += 2) r[l] = t[u], r[l + 1] = t[u + 1], l += n;
  }
  const Vwe = [], Gwe = {
    extension: {
      type: qt.ShapeBuilder,
      name: "polygon"
    },
    build(t, e) {
      for (let r = 0; r < t.points.length; r++) e[r] = t.points[r];
      return e;
    },
    triangulate(t, e, r, n, i, a) {
      $q(t, Vwe, e, r, n, i, a);
    }
  }, Wwe = {
    extension: {
      type: qt.ShapeBuilder,
      name: "rectangle"
    },
    build(t, e) {
      const r = t, n = r.x, i = r.y, a = r.width, o = r.height;
      return a >= 0 && o >= 0 && (e[0] = n, e[1] = i, e[2] = n + a, e[3] = i, e[4] = n + a, e[5] = i + o, e[6] = n, e[7] = i + o), e;
    },
    triangulate(t, e, r, n, i, a) {
      let o = 0;
      n *= r, e[n + o] = t[0], e[n + o + 1] = t[1], o += r, e[n + o] = t[2], e[n + o + 1] = t[3], o += r, e[n + o] = t[6], e[n + o + 1] = t[7], o += r, e[n + o] = t[4], e[n + o + 1] = t[5], o += r;
      const s = n / r;
      i[a++] = s, i[a++] = s + 1, i[a++] = s + 2, i[a++] = s + 1, i[a++] = s + 3, i[a++] = s + 2;
    }
  }, Hwe = {
    extension: {
      type: qt.ShapeBuilder,
      name: "triangle"
    },
    build(t, e) {
      return e[0] = t.x, e[1] = t.y, e[2] = t.x2, e[3] = t.y2, e[4] = t.x3, e[5] = t.y3, e;
    },
    triangulate(t, e, r, n, i, a) {
      let o = 0;
      n *= r, e[n + o] = t[0], e[n + o + 1] = t[1], o += r, e[n + o] = t[2], e[n + o + 1] = t[3], o += r, e[n + o] = t[4], e[n + o + 1] = t[5];
      const s = n / r;
      i[a++] = s, i[a++] = s + 1, i[a++] = s + 2;
    }
  }, Uwe = new $t(), Ywe = new Vr();
  function qwe(t, e, r, n) {
    const i = e.matrix ? t.copyFrom(e.matrix).invert() : t.identity();
    if (e.textureSpace === "local") {
      const a = r.getBounds(Ywe);
      i.translate(-a.x, -a.y), i.scale(1 / a.width, 1 / a.height);
    } else {
      i.translate(e.texture.frame.x, e.texture.frame.y), i.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
      const a = e.texture.source.style;
      a.addressMode === "clamp-to-edge" && (a.addressMode = "repeat", a.update());
    }
    return n && i.append(Uwe.copyFrom(n).invert()), i;
  }
  const Ty = {};
  Ti.handleByMap(qt.ShapeBuilder, Ty);
  Ti.add(Wwe, Gwe, Hwe, wd, Owe, Nwe);
  const Xwe = new Vr(), jwe = new $t();
  function Kwe(t, e) {
    const { geometryData: r, batches: n } = e;
    n.length = 0, r.indices.length = 0, r.vertices.length = 0, r.uvs.length = 0;
    for (let i = 0; i < t.instructions.length; i++) {
      const a = t.instructions[i];
      if (a.action === "texture") Zwe(a.data, n, r);
      else if (a.action === "fill" || a.action === "stroke") {
        const o = a.action === "stroke", s = a.data.path.shapePath, l = a.data.style, u = a.data.hole;
        o && u && cz(u.shapePath, l, true, n, r), u && (s.shapePrimitives[s.shapePrimitives.length - 1].holes = u.shapePath.shapePrimitives), cz(s, l, o, n, r);
      }
    }
  }
  function Zwe(t, e, r) {
    const { vertices: n, uvs: i, indices: a } = r, o = a.length, s = n.length / 2, l = [], u = Ty.rectangle, c = Xwe, h = t.image;
    c.x = t.dx, c.y = t.dy, c.width = t.dw, c.height = t.dh;
    const f = t.transform;
    u.build(c, l), f && kq(l, f), u.triangulate(l, n, 2, s, a, o);
    const d = h.uvs;
    i.push(d.x0, d.y0, d.x1, d.y1, d.x3, d.y3, d.x2, d.y2);
    const p = lo.get(Pq);
    p.indexOffset = o, p.indexSize = a.length - o, p.attributeOffset = s, p.attributeSize = n.length / 2 - s, p.baseColor = t.style, p.alpha = t.alpha, p.texture = h, p.geometryData = r, e.push(p);
  }
  function cz(t, e, r, n, i) {
    const { vertices: a, uvs: o, indices: s } = i;
    t.shapePrimitives.forEach(({ shape: l, transform: u, holes: c }) => {
      const h = s.length, f = a.length / 2, d = [], p = Ty[l.type];
      let v = "triangle-list";
      if (p.build(l, d), u && kq(d, u), r) {
        const _ = l.closePath ?? true, b = e;
        b.pixelLine ? (Fwe(d, _, a, s), v = "line-list") : zwe(d, b, false, _, a, s);
      } else if (c) {
        const _ = [], b = d.slice();
        Qwe(c).forEach((x) => {
          _.push(b.length / 2), b.push(...x);
        }), $q(b, _, a, 2, f, s, h);
      } else p.triangulate(d, a, 2, f, s, h);
      const g = o.length / 2, m = e.texture;
      if (m !== Kt.WHITE) {
        const _ = qwe(jwe, e, l, u);
        Lwe(a, 2, f, o, g, 2, a.length / 2 - f, _);
      } else $we(o, g, 2, a.length / 2 - f);
      const y = lo.get(Pq);
      y.indexOffset = h, y.indexSize = s.length - h, y.attributeOffset = f, y.attributeSize = a.length / 2 - f, y.baseColor = e.color, y.alpha = e.alpha, y.texture = m, y.geometryData = i, y.topology = v, n.push(y);
    });
  }
  function Qwe(t) {
    const e = [];
    for (let r = 0; r < t.length; r++) {
      const n = t[r].shape, i = [];
      Ty[n.type].build(n, i), e.push(i);
    }
    return e;
  }
  class Jwe {
    constructor() {
      this.batches = [], this.geometryData = {
        vertices: [],
        uvs: [],
        indices: []
      };
    }
  }
  class eSe {
    constructor() {
      this.batcher = new Pwe(), this.instructions = new U9();
    }
    init() {
      this.instructions.reset();
    }
    get geometry() {
      return Jt(c1e, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
    }
  }
  const YC = class xS {
    constructor(e) {
      this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
    }
    init(e) {
      xS.defaultOptions.bezierSmoothness = (e == null ? void 0 : e.bezierSmoothness) ?? xS.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(e) {
      return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e);
    }
    updateGpuContext(e) {
      let r = this._gpuContextHash[e.uid] || this._initContext(e);
      if (e.dirty) {
        r ? this._cleanGraphicsContextData(e) : r = this._initContext(e), Kwe(e, r);
        const n = e.batchMode;
        e.customShader || n === "no-batch" ? r.isBatchable = false : n === "auto" && (r.isBatchable = r.geometryData.vertices.length < 400), e.dirty = false;
      }
      return r;
    }
    getGpuContext(e) {
      return this._gpuContextHash[e.uid] || this._initContext(e);
    }
    _initContextRenderData(e) {
      const r = lo.get(eSe), { batches: n, geometryData: i } = this._gpuContextHash[e.uid], a = i.vertices.length, o = i.indices.length;
      for (let c = 0; c < n.length; c++) n[c].applyTransform = false;
      const s = r.batcher;
      s.ensureAttributeBuffer(a), s.ensureIndexBuffer(o), s.begin();
      for (let c = 0; c < n.length; c++) {
        const h = n[c];
        s.add(h);
      }
      s.finish(r.instructions);
      const l = s.geometry;
      l.indexBuffer.setDataWithSize(s.indexBuffer, s.indexSize, true), l.buffers[0].setDataWithSize(s.attributeBuffer.float32View, s.attributeSize, true);
      const u = s.batches;
      for (let c = 0; c < u.length; c++) {
        const h = u[c];
        h.bindGroup = Yxe(h.textures.textures, h.textures.count);
      }
      return this._graphicsDataContextHash[e.uid] = r, r;
    }
    _initContext(e) {
      const r = new Jwe();
      return r.context = e, this._gpuContextHash[e.uid] = r, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid];
    }
    onGraphicsContextDestroy(e) {
      this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null;
    }
    _cleanGraphicsContextData(e) {
      const r = this._gpuContextHash[e.uid];
      r.isBatchable || this._graphicsDataContextHash[e.uid] && (lo.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), r.batches && r.batches.forEach((n) => {
        lo.return(n);
      });
    }
    destroy() {
      for (const e in this._gpuContextHash) this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
    }
  };
  YC.extension = {
    type: [
      qt.WebGLSystem,
      qt.WebGPUSystem,
      qt.CanvasSystem
    ],
    name: "graphicsContext"
  };
  YC.defaultOptions = {
    bezierSmoothness: 0.5
  };
  Rq = YC;
  const tSe = 8, Fv = 11920929e-14, rSe = 1;
  function Oq(t, e, r, n, i, a, o, s, l, u) {
    const h = Math.min(0.99, Math.max(0, u ?? Rq.defaultOptions.bezierSmoothness));
    let f = (rSe - h) / 1;
    return f *= f, nSe(e, r, n, i, a, o, s, l, t, f), t;
  }
  function nSe(t, e, r, n, i, a, o, s, l, u) {
    wS(t, e, r, n, i, a, o, s, l, u, 0), l.push(o, s);
  }
  function wS(t, e, r, n, i, a, o, s, l, u, c) {
    if (c > tSe) return;
    const h = (t + r) / 2, f = (e + n) / 2, d = (r + i) / 2, p = (n + a) / 2, v = (i + o) / 2, g = (a + s) / 2, m = (h + d) / 2, y = (f + p) / 2, _ = (d + v) / 2, b = (p + g) / 2, w = (m + _) / 2, x = (y + b) / 2;
    if (c > 0) {
      let T = o - t, A = s - e;
      const I = Math.abs((r - o) * A - (n - s) * T), M = Math.abs((i - o) * A - (a - s) * T);
      if (I > Fv && M > Fv) {
        if ((I + M) * (I + M) <= u * (T * T + A * A)) {
          l.push(w, x);
          return;
        }
      } else if (I > Fv) {
        if (I * I <= u * (T * T + A * A)) {
          l.push(w, x);
          return;
        }
      } else if (M > Fv) {
        if (M * M <= u * (T * T + A * A)) {
          l.push(w, x);
          return;
        }
      } else if (T = w - (t + o) / 2, A = x - (e + s) / 2, T * T + A * A <= u) {
        l.push(w, x);
        return;
      }
    }
    wS(t, e, h, f, m, y, w, x, l, u, c + 1), wS(w, x, _, b, v, g, o, s, l, u, c + 1);
  }
  const iSe = 8, aSe = 11920929e-14, oSe = 1;
  function sSe(t, e, r, n, i, a, o, s) {
    const u = Math.min(0.99, Math.max(0, s ?? Rq.defaultOptions.bezierSmoothness));
    let c = (oSe - u) / 1;
    return c *= c, lSe(e, r, n, i, a, o, t, c), t;
  }
  function lSe(t, e, r, n, i, a, o, s) {
    SS(o, t, e, r, n, i, a, s, 0), o.push(i, a);
  }
  function SS(t, e, r, n, i, a, o, s, l) {
    if (l > iSe) return;
    const u = (e + n) / 2, c = (r + i) / 2, h = (n + a) / 2, f = (i + o) / 2, d = (u + h) / 2, p = (c + f) / 2;
    let v = a - e, g = o - r;
    const m = Math.abs((n - a) * g - (i - o) * v);
    if (m > aSe) {
      if (m * m <= s * (v * v + g * g)) {
        t.push(d, p);
        return;
      }
    } else if (v = d - (e + a) / 2, g = p - (r + o) / 2, v * v + g * g <= s) {
      t.push(d, p);
      return;
    }
    SS(t, e, r, u, c, d, p, s, l + 1), SS(t, d, p, h, f, a, o, s, l + 1);
  }
  function Nq(t, e, r, n, i, a, o, s) {
    let l = Math.abs(i - a);
    (!o && i > a || o && a > i) && (l = 2 * Math.PI - l), s || (s = Math.max(6, Math.floor(6 * Math.pow(n, 1 / 3) * (l / Math.PI)))), s = Math.max(s, 3);
    let u = l / s, c = i;
    u *= o ? -1 : 1;
    for (let h = 0; h < s + 1; h++) {
      const f = Math.cos(c), d = Math.sin(c), p = e + f * n, v = r + d * n;
      t.push(p, v), c += u;
    }
  }
  function uSe(t, e, r, n, i, a) {
    const o = t[t.length - 2], l = t[t.length - 1] - r, u = o - e, c = i - r, h = n - e, f = Math.abs(l * h - u * c);
    if (f < 1e-8 || a === 0) {
      (t[t.length - 2] !== e || t[t.length - 1] !== r) && t.push(e, r);
      return;
    }
    const d = l * l + u * u, p = c * c + h * h, v = l * c + u * h, g = a * Math.sqrt(d) / f, m = a * Math.sqrt(p) / f, y = g * v / d, _ = m * v / p, b = g * h + m * u, w = g * c + m * l, x = u * (m + y), T = l * (m + y), A = h * (g + _), I = c * (g + _), M = Math.atan2(T - w, x - b), k = Math.atan2(I - w, A - b);
    Nq(t, b + e, w + r, a, M, k, u * c > h * l);
  }
  const Of = Math.PI * 2, N1 = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  }, B1 = ({ x: t, y: e }, r, n, i, a, o, s, l) => {
    t *= r, e *= n;
    const u = i * t - a * e, c = a * t + i * e;
    return l.x = u + o, l.y = c + s, l;
  };
  function cSe(t, e) {
    const r = e === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(e / 4), n = e === 1.5707963267948966 ? 0.551915024494 : r, i = Math.cos(t), a = Math.sin(t), o = Math.cos(t + e), s = Math.sin(t + e);
    return [
      {
        x: i - a * n,
        y: a + i * n
      },
      {
        x: o + s * n,
        y: s - o * n
      },
      {
        x: o,
        y: s
      }
    ];
  }
  const hz = (t, e, r, n) => {
    const i = t * n - e * r < 0 ? -1 : 1;
    let a = t * r + e * n;
    return a > 1 && (a = 1), a < -1 && (a = -1), i * Math.acos(a);
  }, hSe = (t, e, r, n, i, a, o, s, l, u, c, h, f) => {
    const d = Math.pow(i, 2), p = Math.pow(a, 2), v = Math.pow(c, 2), g = Math.pow(h, 2);
    let m = d * p - d * g - p * v;
    m < 0 && (m = 0), m /= d * g + p * v, m = Math.sqrt(m) * (o === s ? -1 : 1);
    const y = m * i / a * h, _ = m * -a / i * c, b = u * y - l * _ + (t + r) / 2, w = l * y + u * _ + (e + n) / 2, x = (c - y) / i, T = (h - _) / a, A = (-c - y) / i, I = (-h - _) / a, M = hz(1, 0, x, T);
    let k = hz(x, T, A, I);
    s === 0 && k > 0 && (k -= Of), s === 1 && k < 0 && (k += Of), f.centerX = b, f.centerY = w, f.ang1 = M, f.ang2 = k;
  };
  function fSe(t, e, r, n, i, a, o, s = 0, l = 0, u = 0) {
    if (a === 0 || o === 0) return;
    const c = Math.sin(s * Of / 360), h = Math.cos(s * Of / 360), f = h * (e - n) / 2 + c * (r - i) / 2, d = -c * (e - n) / 2 + h * (r - i) / 2;
    if (f === 0 && d === 0) return;
    a = Math.abs(a), o = Math.abs(o);
    const p = Math.pow(f, 2) / Math.pow(a, 2) + Math.pow(d, 2) / Math.pow(o, 2);
    p > 1 && (a *= Math.sqrt(p), o *= Math.sqrt(p)), hSe(e, r, n, i, a, o, l, u, c, h, f, d, N1);
    let { ang1: v, ang2: g } = N1;
    const { centerX: m, centerY: y } = N1;
    let _ = Math.abs(g) / (Of / 4);
    Math.abs(1 - _) < 1e-7 && (_ = 1);
    const b = Math.max(Math.ceil(_), 1);
    g /= b;
    let w = t[t.length - 2], x = t[t.length - 1];
    const T = {
      x: 0,
      y: 0
    };
    for (let A = 0; A < b; A++) {
      const I = cSe(v, g), { x: M, y: k } = B1(I[0], a, o, h, c, m, y, T), { x: B, y: L } = B1(I[1], a, o, h, c, m, y, T), { x: z, y: F } = B1(I[2], a, o, h, c, m, y, T);
      Oq(t, w, x, M, k, B, L, z, F), w = z, x = F, v += g;
    }
  }
  function dSe(t, e, r) {
    const n = (o, s) => {
      const l = s.x - o.x, u = s.y - o.y, c = Math.sqrt(l * l + u * u), h = l / c, f = u / c;
      return {
        len: c,
        nx: h,
        ny: f
      };
    }, i = (o, s) => {
      o === 0 ? t.moveTo(s.x, s.y) : t.lineTo(s.x, s.y);
    };
    let a = e[e.length - 1];
    for (let o = 0; o < e.length; o++) {
      const s = e[o % e.length], l = s.radius ?? r;
      if (l <= 0) {
        i(o, s), a = s;
        continue;
      }
      const u = e[(o + 1) % e.length], c = n(s, a), h = n(s, u);
      if (c.len < 1e-4 || h.len < 1e-4) {
        i(o, s), a = s;
        continue;
      }
      let f = Math.asin(c.nx * h.ny - c.ny * h.nx), d = 1, p = false;
      c.nx * h.nx - c.ny * -h.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, d = -1, p = true) : f > 0 && (d = -1, p = true);
      const v = f / 2;
      let g, m = Math.abs(Math.cos(v) * l / Math.sin(v));
      m > Math.min(c.len / 2, h.len / 2) ? (m = Math.min(c.len / 2, h.len / 2), g = Math.abs(m * Math.sin(v) / Math.cos(v))) : g = l;
      const y = s.x + h.nx * m + -h.ny * g * d, _ = s.y + h.ny * m + h.nx * g * d, b = Math.atan2(c.ny, c.nx) + Math.PI / 2 * d, w = Math.atan2(h.ny, h.nx) - Math.PI / 2 * d;
      o === 0 && t.moveTo(y + Math.cos(b) * g, _ + Math.sin(b) * g), t.arc(y, _, g, b, w, p), a = s;
    }
  }
  function pSe(t, e, r, n) {
    const i = (s, l) => Math.sqrt((s.x - l.x) ** 2 + (s.y - l.y) ** 2), a = (s, l, u) => ({
      x: s.x + (l.x - s.x) * u,
      y: s.y + (l.y - s.y) * u
    }), o = e.length;
    for (let s = 0; s < o; s++) {
      const l = e[(s + 1) % o], u = l.radius ?? r;
      if (u <= 0) {
        s === 0 ? t.moveTo(l.x, l.y) : t.lineTo(l.x, l.y);
        continue;
      }
      const c = e[s], h = e[(s + 2) % o], f = i(c, l);
      let d;
      if (f < 1e-4) d = l;
      else {
        const g = Math.min(f / 2, u);
        d = a(l, c, g / f);
      }
      const p = i(h, l);
      let v;
      if (p < 1e-4) v = l;
      else {
        const g = Math.min(p / 2, u);
        v = a(l, h, g / p);
      }
      s === 0 ? t.moveTo(d.x, d.y) : t.lineTo(d.x, d.y), t.quadraticCurveTo(l.x, l.y, v.x, v.y, n);
    }
  }
  const vSe = new Vr();
  class gSe {
    constructor(e) {
      this.shapePrimitives = [], this._currentPoly = null, this._bounds = new Zi(), this._graphicsPath2D = e, this.signed = e.checkForHoles;
    }
    moveTo(e, r) {
      return this.startPoly(e, r), this;
    }
    lineTo(e, r) {
      this._ensurePoly();
      const n = this._currentPoly.points, i = n[n.length - 2], a = n[n.length - 1];
      return (i !== e || a !== r) && n.push(e, r), this;
    }
    arc(e, r, n, i, a, o) {
      this._ensurePoly(false);
      const s = this._currentPoly.points;
      return Nq(s, e, r, n, i, a, o), this;
    }
    arcTo(e, r, n, i, a) {
      this._ensurePoly();
      const o = this._currentPoly.points;
      return uSe(o, e, r, n, i, a), this;
    }
    arcToSvg(e, r, n, i, a, o, s) {
      const l = this._currentPoly.points;
      return fSe(l, this._currentPoly.lastX, this._currentPoly.lastY, o, s, e, r, n, i, a), this;
    }
    bezierCurveTo(e, r, n, i, a, o, s) {
      this._ensurePoly();
      const l = this._currentPoly;
      return Oq(this._currentPoly.points, l.lastX, l.lastY, e, r, n, i, a, o, s), this;
    }
    quadraticCurveTo(e, r, n, i, a) {
      this._ensurePoly();
      const o = this._currentPoly;
      return sSe(this._currentPoly.points, o.lastX, o.lastY, e, r, n, i, a), this;
    }
    closePath() {
      return this.endPoly(true), this;
    }
    addPath(e, r) {
      this.endPoly(), r && !r.isIdentity() && (e = e.clone(true), e.transform(r));
      const n = this.shapePrimitives, i = n.length;
      for (let a = 0; a < e.instructions.length; a++) {
        const o = e.instructions[a];
        this[o.action](...o.data);
      }
      if (e.checkForHoles && n.length - i > 1) {
        let a = null;
        for (let o = i; o < n.length; o++) {
          const s = n[o];
          if (s.shape.type === "polygon") {
            const l = s.shape, u = a == null ? void 0 : a.shape;
            u && u.containsPolygon(l) ? (a.holes || (a.holes = []), a.holes.push(s), n.copyWithin(o, o + 1), n.length--, o--) : a = s;
          }
        }
      }
      return this;
    }
    finish(e = false) {
      this.endPoly(e);
    }
    rect(e, r, n, i, a) {
      return this.drawShape(new Vr(e, r, n, i), a), this;
    }
    circle(e, r, n, i) {
      return this.drawShape(new WC(e, r, n), i), this;
    }
    poly(e, r, n) {
      const i = new Rf(e);
      return i.closePath = r, this.drawShape(i, n), this;
    }
    regularPoly(e, r, n, i, a = 0, o) {
      i = Math.max(i | 0, 3);
      const s = -1 * Math.PI / 2 + a, l = Math.PI * 2 / i, u = [];
      for (let c = 0; c < i; c++) {
        const h = s - c * l;
        u.push(e + n * Math.cos(h), r + n * Math.sin(h));
      }
      return this.poly(u, true, o), this;
    }
    roundPoly(e, r, n, i, a, o = 0, s) {
      if (i = Math.max(i | 0, 3), a <= 0) return this.regularPoly(e, r, n, i, o);
      const l = n * Math.sin(Math.PI / i) - 1e-3;
      a = Math.min(a, l);
      const u = -1 * Math.PI / 2 + o, c = Math.PI * 2 / i, h = (i - 2) * Math.PI / i / 2;
      for (let f = 0; f < i; f++) {
        const d = f * c + u, p = e + n * Math.cos(d), v = r + n * Math.sin(d), g = d + Math.PI + h, m = d - Math.PI - h, y = p + a * Math.cos(g), _ = v + a * Math.sin(g), b = p + a * Math.cos(m), w = v + a * Math.sin(m);
        f === 0 ? this.moveTo(y, _) : this.lineTo(y, _), this.quadraticCurveTo(p, v, b, w, s);
      }
      return this.closePath();
    }
    roundShape(e, r, n = false, i) {
      return e.length < 3 ? this : (n ? pSe(this, e, r, i) : dSe(this, e, r), this.closePath());
    }
    filletRect(e, r, n, i, a) {
      if (a === 0) return this.rect(e, r, n, i);
      const o = Math.min(n, i) / 2, s = Math.min(o, Math.max(-o, a)), l = e + n, u = r + i, c = s < 0 ? -s : 0, h = Math.abs(s);
      return this.moveTo(e, r + h).arcTo(e + c, r + c, e + h, r, h).lineTo(l - h, r).arcTo(l - c, r + c, l, r + h, h).lineTo(l, u - h).arcTo(l - c, u - c, e + n - h, u, h).lineTo(e + h, u).arcTo(e + c, u - c, e, u - h, h).closePath();
    }
    chamferRect(e, r, n, i, a, o) {
      if (a <= 0) return this.rect(e, r, n, i);
      const s = Math.min(a, Math.min(n, i) / 2), l = e + n, u = r + i, c = [
        e + s,
        r,
        l - s,
        r,
        l,
        r + s,
        l,
        u - s,
        l - s,
        u,
        e + s,
        u,
        e,
        u - s,
        e,
        r + s
      ];
      for (let h = c.length - 1; h >= 2; h -= 2) c[h] === c[h - 2] && c[h - 1] === c[h - 3] && c.splice(h - 1, 2);
      return this.poly(c, true, o);
    }
    ellipse(e, r, n, i, a) {
      return this.drawShape(new HC(e, r, n, i), a), this;
    }
    roundRect(e, r, n, i, a, o) {
      return this.drawShape(new UC(e, r, n, i, a), o), this;
    }
    drawShape(e, r) {
      return this.endPoly(), this.shapePrimitives.push({
        shape: e,
        transform: r
      }), this;
    }
    startPoly(e, r) {
      let n = this._currentPoly;
      return n && this.endPoly(), n = new Rf(), n.points.push(e, r), this._currentPoly = n, this;
    }
    endPoly(e = false) {
      const r = this._currentPoly;
      return r && r.points.length > 2 && (r.closePath = e, this.shapePrimitives.push({
        shape: r
      })), this._currentPoly = null, this;
    }
    _ensurePoly(e = true) {
      if (!this._currentPoly && (this._currentPoly = new Rf(), e)) {
        const r = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (r) {
          let n = r.shape.x, i = r.shape.y;
          if (r.transform && !r.transform.isIdentity()) {
            const a = r.transform, o = n;
            n = a.a * n + a.c * i + a.tx, i = a.b * o + a.d * i + a.ty;
          }
          this._currentPoly.points.push(n, i);
        } else this._currentPoly.points.push(0, 0);
      }
    }
    buildPath() {
      const e = this._graphicsPath2D;
      this.shapePrimitives.length = 0, this._currentPoly = null;
      for (let r = 0; r < e.instructions.length; r++) {
        const n = e.instructions[r];
        this[n.action](...n.data);
      }
      this.finish();
    }
    get bounds() {
      const e = this._bounds;
      e.clear();
      const r = this.shapePrimitives;
      for (let n = 0; n < r.length; n++) {
        const i = r[n], a = i.shape.getBounds(vSe);
        i.transform ? e.addRect(a, i.transform) : e.addRect(a);
      }
      return e;
    }
  }
  class Pc {
    constructor(e, r = false) {
      this.instructions = [], this.uid = wr("graphicsPath"), this._dirty = true, this.checkForHoles = r, typeof e == "string" ? zxe(e, this) : this.instructions = (e == null ? void 0 : e.slice()) ?? [];
    }
    get shapePath() {
      return this._shapePath || (this._shapePath = new gSe(this)), this._dirty && (this._dirty = false, this._shapePath.buildPath()), this._shapePath;
    }
    addPath(e, r) {
      return e = e.clone(), this.instructions.push({
        action: "addPath",
        data: [
          e,
          r
        ]
      }), this._dirty = true, this;
    }
    arc(...e) {
      return this.instructions.push({
        action: "arc",
        data: e
      }), this._dirty = true, this;
    }
    arcTo(...e) {
      return this.instructions.push({
        action: "arcTo",
        data: e
      }), this._dirty = true, this;
    }
    arcToSvg(...e) {
      return this.instructions.push({
        action: "arcToSvg",
        data: e
      }), this._dirty = true, this;
    }
    bezierCurveTo(...e) {
      return this.instructions.push({
        action: "bezierCurveTo",
        data: e
      }), this._dirty = true, this;
    }
    bezierCurveToShort(e, r, n, i, a) {
      const o = this.instructions[this.instructions.length - 1], s = this.getLastPoint(rn.shared);
      let l = 0, u = 0;
      if (!o || o.action !== "bezierCurveTo") l = s.x, u = s.y;
      else {
        l = o.data[2], u = o.data[3];
        const c = s.x, h = s.y;
        l = c + (c - l), u = h + (h - u);
      }
      return this.instructions.push({
        action: "bezierCurveTo",
        data: [
          l,
          u,
          e,
          r,
          n,
          i,
          a
        ]
      }), this._dirty = true, this;
    }
    closePath() {
      return this.instructions.push({
        action: "closePath",
        data: []
      }), this._dirty = true, this;
    }
    ellipse(...e) {
      return this.instructions.push({
        action: "ellipse",
        data: e
      }), this._dirty = true, this;
    }
    lineTo(...e) {
      return this.instructions.push({
        action: "lineTo",
        data: e
      }), this._dirty = true, this;
    }
    moveTo(...e) {
      return this.instructions.push({
        action: "moveTo",
        data: e
      }), this;
    }
    quadraticCurveTo(...e) {
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: e
      }), this._dirty = true, this;
    }
    quadraticCurveToShort(e, r, n) {
      const i = this.instructions[this.instructions.length - 1], a = this.getLastPoint(rn.shared);
      let o = 0, s = 0;
      if (!i || i.action !== "quadraticCurveTo") o = a.x, s = a.y;
      else {
        o = i.data[0], s = i.data[1];
        const l = a.x, u = a.y;
        o = l + (l - o), s = u + (u - s);
      }
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: [
          o,
          s,
          e,
          r,
          n
        ]
      }), this._dirty = true, this;
    }
    rect(e, r, n, i, a) {
      return this.instructions.push({
        action: "rect",
        data: [
          e,
          r,
          n,
          i,
          a
        ]
      }), this._dirty = true, this;
    }
    circle(e, r, n, i) {
      return this.instructions.push({
        action: "circle",
        data: [
          e,
          r,
          n,
          i
        ]
      }), this._dirty = true, this;
    }
    roundRect(...e) {
      return this.instructions.push({
        action: "roundRect",
        data: e
      }), this._dirty = true, this;
    }
    poly(...e) {
      return this.instructions.push({
        action: "poly",
        data: e
      }), this._dirty = true, this;
    }
    regularPoly(...e) {
      return this.instructions.push({
        action: "regularPoly",
        data: e
      }), this._dirty = true, this;
    }
    roundPoly(...e) {
      return this.instructions.push({
        action: "roundPoly",
        data: e
      }), this._dirty = true, this;
    }
    roundShape(...e) {
      return this.instructions.push({
        action: "roundShape",
        data: e
      }), this._dirty = true, this;
    }
    filletRect(...e) {
      return this.instructions.push({
        action: "filletRect",
        data: e
      }), this._dirty = true, this;
    }
    chamferRect(...e) {
      return this.instructions.push({
        action: "chamferRect",
        data: e
      }), this._dirty = true, this;
    }
    star(e, r, n, i, a, o, s) {
      a || (a = i / 2);
      const l = -1 * Math.PI / 2 + o, u = n * 2, c = Math.PI * 2 / u, h = [];
      for (let f = 0; f < u; f++) {
        const d = f % 2 ? a : i, p = f * c + l;
        h.push(e + d * Math.cos(p), r + d * Math.sin(p));
      }
      return this.poly(h, true, s), this;
    }
    clone(e = false) {
      const r = new Pc();
      if (r.checkForHoles = this.checkForHoles, !e) r.instructions = this.instructions.slice();
      else for (let n = 0; n < this.instructions.length; n++) {
        const i = this.instructions[n];
        r.instructions.push({
          action: i.action,
          data: i.data.slice()
        });
      }
      return r;
    }
    clear() {
      return this.instructions.length = 0, this._dirty = true, this;
    }
    transform(e) {
      if (e.isIdentity()) return this;
      const r = e.a, n = e.b, i = e.c, a = e.d, o = e.tx, s = e.ty;
      let l = 0, u = 0, c = 0, h = 0, f = 0, d = 0, p = 0, v = 0;
      for (let g = 0; g < this.instructions.length; g++) {
        const m = this.instructions[g], y = m.data;
        switch (m.action) {
          case "moveTo":
          case "lineTo":
            l = y[0], u = y[1], y[0] = r * l + i * u + o, y[1] = n * l + a * u + s;
            break;
          case "bezierCurveTo":
            c = y[0], h = y[1], f = y[2], d = y[3], l = y[4], u = y[5], y[0] = r * c + i * h + o, y[1] = n * c + a * h + s, y[2] = r * f + i * d + o, y[3] = n * f + a * d + s, y[4] = r * l + i * u + o, y[5] = n * l + a * u + s;
            break;
          case "quadraticCurveTo":
            c = y[0], h = y[1], l = y[2], u = y[3], y[0] = r * c + i * h + o, y[1] = n * c + a * h + s, y[2] = r * l + i * u + o, y[3] = n * l + a * u + s;
            break;
          case "arcToSvg":
            l = y[5], u = y[6], p = y[0], v = y[1], y[0] = r * p + i * v, y[1] = n * p + a * v, y[5] = r * l + i * u + o, y[6] = n * l + a * u + s;
            break;
          case "circle":
            y[4] = Yh(y[3], e);
            break;
          case "rect":
            y[4] = Yh(y[4], e);
            break;
          case "ellipse":
            y[8] = Yh(y[8], e);
            break;
          case "roundRect":
            y[5] = Yh(y[5], e);
            break;
          case "addPath":
            y[0].transform(e);
            break;
          case "poly":
            y[2] = Yh(y[2], e);
            break;
          default:
            Xn("unknown transform action", m.action);
            break;
        }
      }
      return this._dirty = true, this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(e) {
      let r = this.instructions.length - 1, n = this.instructions[r];
      if (!n) return e.x = 0, e.y = 0, e;
      for (; n.action === "closePath"; ) {
        if (r--, r < 0) return e.x = 0, e.y = 0, e;
        n = this.instructions[r];
      }
      switch (n.action) {
        case "moveTo":
        case "lineTo":
          e.x = n.data[0], e.y = n.data[1];
          break;
        case "quadraticCurveTo":
          e.x = n.data[2], e.y = n.data[3];
          break;
        case "bezierCurveTo":
          e.x = n.data[4], e.y = n.data[5];
          break;
        case "arc":
        case "arcToSvg":
          e.x = n.data[5], e.y = n.data[6];
          break;
        case "addPath":
          n.data[0].getLastPoint(e);
          break;
      }
      return e;
    }
  }
  function Yh(t, e) {
    return t ? t.prepend(e) : e.clone();
  }
  function cr(t, e, r) {
    const n = t.getAttribute(e);
    return n ? Number(n) : r;
  }
  function mSe(t, e) {
    const r = t.querySelectorAll("defs");
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      for (let a = 0; a < i.children.length; a++) {
        const o = i.children[a];
        switch (o.nodeName.toLowerCase()) {
          case "lineargradient":
            e.defs[o.id] = ySe(o);
            break;
          case "radialgradient":
            e.defs[o.id] = _Se();
            break;
        }
      }
    }
  }
  function ySe(t) {
    const e = cr(t, "x1", 0), r = cr(t, "y1", 0), n = cr(t, "x2", 1), i = cr(t, "y2", 0), a = t.getAttribute("gradientUnits") || "objectBoundingBox", o = new tu(e, r, n, i, a === "objectBoundingBox" ? "local" : "global");
    for (let s = 0; s < t.children.length; s++) {
      const l = t.children[s], u = cr(l, "offset", 0), c = an.shared.setValue(l.getAttribute("stop-color")).toNumber();
      o.addColorStop(u, c);
    }
    return o;
  }
  function _Se(t) {
    return Xn("[SVG Parser] Radial gradients are not yet supported"), new tu(0, 0, 1, 0);
  }
  function fz(t) {
    const e = t.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return e ? e[1] : "";
  }
  const dz = {
    fill: {
      type: "paint",
      default: 0
    },
    "fill-opacity": {
      type: "number",
      default: 1
    },
    stroke: {
      type: "paint",
      default: 0
    },
    "stroke-width": {
      type: "number",
      default: 1
    },
    "stroke-opacity": {
      type: "number",
      default: 1
    },
    "stroke-linecap": {
      type: "string",
      default: "butt"
    },
    "stroke-linejoin": {
      type: "string",
      default: "miter"
    },
    "stroke-miterlimit": {
      type: "number",
      default: 10
    },
    "stroke-dasharray": {
      type: "string",
      default: "none"
    },
    "stroke-dashoffset": {
      type: "number",
      default: 0
    },
    opacity: {
      type: "number",
      default: 1
    }
  };
  function Bq(t, e) {
    const r = t.getAttribute("style"), n = {}, i = {}, a = {
      strokeStyle: n,
      fillStyle: i,
      useFill: false,
      useStroke: false
    };
    for (const o in dz) {
      const s = t.getAttribute(o);
      s && pz(e, a, o, s.trim());
    }
    if (r) {
      const o = r.split(";");
      for (let s = 0; s < o.length; s++) {
        const l = o[s].trim(), [u, c] = l.split(":");
        dz[u] && pz(e, a, u, c.trim());
      }
    }
    return {
      strokeStyle: a.useStroke ? n : null,
      fillStyle: a.useFill ? i : null,
      useFill: a.useFill,
      useStroke: a.useStroke
    };
  }
  function pz(t, e, r, n) {
    switch (r) {
      case "stroke":
        if (n !== "none") {
          if (n.startsWith("url(")) {
            const i = fz(n);
            e.strokeStyle.fill = t.defs[i];
          } else e.strokeStyle.color = an.shared.setValue(n).toNumber();
          e.useStroke = true;
        }
        break;
      case "stroke-width":
        e.strokeStyle.width = Number(n);
        break;
      case "fill":
        if (n !== "none") {
          if (n.startsWith("url(")) {
            const i = fz(n);
            e.fillStyle.fill = t.defs[i];
          } else e.fillStyle.color = an.shared.setValue(n).toNumber();
          e.useFill = true;
        }
        break;
      case "fill-opacity":
        e.fillStyle.alpha = Number(n);
        break;
      case "stroke-opacity":
        e.strokeStyle.alpha = Number(n);
        break;
      case "opacity":
        e.fillStyle.alpha = Number(n), e.strokeStyle.alpha = Number(n);
        break;
    }
  }
  function bSe(t, e) {
    if (typeof t == "string") {
      const o = document.createElement("div");
      o.innerHTML = t.trim(), t = o.querySelector("svg");
    }
    const r = {
      context: e,
      defs: {},
      path: new Pc()
    };
    mSe(t, r);
    const n = t.children, { fillStyle: i, strokeStyle: a } = Bq(t, r);
    for (let o = 0; o < n.length; o++) {
      const s = n[o];
      s.nodeName.toLowerCase() !== "defs" && zq(s, r, i, a);
    }
    return e;
  }
  function zq(t, e, r, n) {
    const i = t.children, { fillStyle: a, strokeStyle: o } = Bq(t, e);
    a && r ? r = {
      ...r,
      ...a
    } : a && (r = a), o && n ? n = {
      ...n,
      ...o
    } : o && (n = o);
    const s = !r && !n;
    s && (r = {
      color: 0
    });
    let l, u, c, h, f, d, p, v, g, m, y, _, b, w, x, T, A;
    switch (t.nodeName.toLowerCase()) {
      case "path":
        w = t.getAttribute("d"), t.getAttribute("fill-rule") === "evenodd" && Xn("SVG Evenodd fill rule not supported, your svg may render incorrectly"), x = new Pc(w, true), e.context.path(x), r && e.context.fill(r), n && e.context.stroke(n);
        break;
      case "circle":
        p = cr(t, "cx", 0), v = cr(t, "cy", 0), g = cr(t, "r", 0), e.context.ellipse(p, v, g, g), r && e.context.fill(r), n && e.context.stroke(n);
        break;
      case "rect":
        l = cr(t, "x", 0), u = cr(t, "y", 0), T = cr(t, "width", 0), A = cr(t, "height", 0), m = cr(t, "rx", 0), y = cr(t, "ry", 0), m || y ? e.context.roundRect(l, u, T, A, m || y) : e.context.rect(l, u, T, A), r && e.context.fill(r), n && e.context.stroke(n);
        break;
      case "ellipse":
        p = cr(t, "cx", 0), v = cr(t, "cy", 0), m = cr(t, "rx", 0), y = cr(t, "ry", 0), e.context.beginPath(), e.context.ellipse(p, v, m, y), r && e.context.fill(r), n && e.context.stroke(n);
        break;
      case "line":
        c = cr(t, "x1", 0), h = cr(t, "y1", 0), f = cr(t, "x2", 0), d = cr(t, "y2", 0), e.context.beginPath(), e.context.moveTo(c, h), e.context.lineTo(f, d), n && e.context.stroke(n);
        break;
      case "polygon":
        b = t.getAttribute("points"), _ = b.match(/\d+/g).map((I) => parseInt(I, 10)), e.context.poly(_, true), r && e.context.fill(r), n && e.context.stroke(n);
        break;
      case "polyline":
        b = t.getAttribute("points"), _ = b.match(/\d+/g).map((I) => parseInt(I, 10)), e.context.poly(_, false), n && e.context.stroke(n);
        break;
      case "g":
      case "svg":
        break;
      default: {
        Xn(`[SVG parser] <${t.nodeName}> elements unsupported`);
        break;
      }
    }
    s && (r = null);
    for (let I = 0; I < i.length; I++) zq(i[I], e, r, n);
  }
  function xSe(t) {
    return an.isColorLike(t);
  }
  function vz(t) {
    return t instanceof GC;
  }
  function gz(t) {
    return t instanceof tu;
  }
  function wSe(t) {
    return t instanceof Kt;
  }
  function SSe(t, e, r) {
    const n = an.shared.setValue(e ?? 0);
    return t.color = n.toNumber(), t.alpha = n.alpha === 1 ? r.alpha : n.alpha, t.texture = Kt.WHITE, {
      ...r,
      ...t
    };
  }
  function TSe(t, e, r) {
    return t.texture = e, {
      ...r,
      ...t
    };
  }
  function mz(t, e, r) {
    return t.fill = e, t.color = 16777215, t.texture = e.texture, t.matrix = e.transform, {
      ...r,
      ...t
    };
  }
  function yz(t, e, r) {
    return e.buildGradient(), t.fill = e, t.color = 16777215, t.texture = e.texture, t.matrix = e.transform, t.textureSpace = e.textureSpace, {
      ...r,
      ...t
    };
  }
  function CSe(t, e) {
    const r = {
      ...e,
      ...t
    }, n = an.shared.setValue(r.color);
    return r.alpha *= n.alpha, r.color = n.toNumber(), r;
  }
  function El(t, e) {
    if (t == null) return null;
    const r = {}, n = t;
    return xSe(t) ? SSe(r, t, e) : wSe(t) ? TSe(r, t, e) : vz(t) ? mz(r, t, e) : gz(t) ? yz(r, t, e) : n.fill && vz(n.fill) ? mz(n, n.fill, e) : n.fill && gz(n.fill) ? yz(n, n.fill, e) : CSe(n, e);
  }
  function Dm(t, e) {
    const { width: r, alignment: n, miterLimit: i, cap: a, join: o, pixelLine: s, ...l } = e, u = El(t, l);
    return u ? {
      width: r,
      alignment: n,
      miterLimit: i,
      cap: a,
      join: o,
      pixelLine: s,
      ...u
    } : null;
  }
  const ASe = new rn(), _z = new $t(), qC = class ga extends Fa {
    constructor() {
      super(...arguments), this.uid = wr("graphicsContext"), this.dirty = true, this.batchMode = "auto", this.instructions = [], this._activePath = new Pc(), this._transform = new $t(), this._fillStyle = {
        ...ga.defaultFillStyle
      }, this._strokeStyle = {
        ...ga.defaultStrokeStyle
      }, this._stateStack = [], this._tick = 0, this._bounds = new Zi(), this._boundsDirty = true;
    }
    clone() {
      const e = new ga();
      return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = {
        ...this._fillStyle
      }, e._strokeStyle = {
        ...this._strokeStyle
      }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = true, e;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(e) {
      this._fillStyle = El(e, ga.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(e) {
      this._strokeStyle = Dm(e, ga.defaultStrokeStyle);
    }
    setFillStyle(e) {
      return this._fillStyle = El(e, ga.defaultFillStyle), this;
    }
    setStrokeStyle(e) {
      return this._strokeStyle = El(e, ga.defaultStrokeStyle), this;
    }
    texture(e, r, n, i, a, o) {
      return this.instructions.push({
        action: "texture",
        data: {
          image: e,
          dx: n || 0,
          dy: i || 0,
          dw: a || e.frame.width,
          dh: o || e.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: r ? an.shared.setValue(r).toNumber() : 16777215
        }
      }), this.onUpdate(), this;
    }
    beginPath() {
      return this._activePath = new Pc(), this;
    }
    fill(e, r) {
      let n;
      const i = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && i && i.action === "stroke" ? n = i.data.path : n = this._activePath.clone(), n ? (e != null && (r !== void 0 && typeof e == "number" && (Jt(fr, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = {
        color: e,
        alpha: r
      }), this._fillStyle = El(e, ga.defaultFillStyle)), this.instructions.push({
        action: "fill",
        data: {
          style: this.fillStyle,
          path: n
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    _initNextPathLocation() {
      const { x: e, y: r } = this._activePath.getLastPoint(rn.shared);
      this._activePath.clear(), this._activePath.moveTo(e, r);
    }
    stroke(e) {
      let r;
      const n = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && n && n.action === "fill" ? r = n.data.path : r = this._activePath.clone(), r ? (e != null && (this._strokeStyle = Dm(e, ga.defaultStrokeStyle)), this.instructions.push({
        action: "stroke",
        data: {
          style: this.strokeStyle,
          path: r
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    cut() {
      for (let e = 0; e < 2; e++) {
        const r = this.instructions[this.instructions.length - 1 - e], n = this._activePath.clone();
        if (r && (r.action === "stroke" || r.action === "fill")) if (r.data.hole) r.data.hole.addPath(n);
        else {
          r.data.hole = n;
          break;
        }
      }
      return this._initNextPathLocation(), this;
    }
    arc(e, r, n, i, a, o) {
      this._tick++;
      const s = this._transform;
      return this._activePath.arc(s.a * e + s.c * r + s.tx, s.b * e + s.d * r + s.ty, n, i, a, o), this;
    }
    arcTo(e, r, n, i, a) {
      this._tick++;
      const o = this._transform;
      return this._activePath.arcTo(o.a * e + o.c * r + o.tx, o.b * e + o.d * r + o.ty, o.a * n + o.c * i + o.tx, o.b * n + o.d * i + o.ty, a), this;
    }
    arcToSvg(e, r, n, i, a, o, s) {
      this._tick++;
      const l = this._transform;
      return this._activePath.arcToSvg(e, r, n, i, a, l.a * o + l.c * s + l.tx, l.b * o + l.d * s + l.ty), this;
    }
    bezierCurveTo(e, r, n, i, a, o, s) {
      this._tick++;
      const l = this._transform;
      return this._activePath.bezierCurveTo(l.a * e + l.c * r + l.tx, l.b * e + l.d * r + l.ty, l.a * n + l.c * i + l.tx, l.b * n + l.d * i + l.ty, l.a * a + l.c * o + l.tx, l.b * a + l.d * o + l.ty, s), this;
    }
    closePath() {
      var _a2;
      return this._tick++, (_a2 = this._activePath) == null ? void 0 : _a2.closePath(), this;
    }
    ellipse(e, r, n, i) {
      return this._tick++, this._activePath.ellipse(e, r, n, i, this._transform.clone()), this;
    }
    circle(e, r, n) {
      return this._tick++, this._activePath.circle(e, r, n, this._transform.clone()), this;
    }
    path(e) {
      return this._tick++, this._activePath.addPath(e, this._transform.clone()), this;
    }
    lineTo(e, r) {
      this._tick++;
      const n = this._transform;
      return this._activePath.lineTo(n.a * e + n.c * r + n.tx, n.b * e + n.d * r + n.ty), this;
    }
    moveTo(e, r) {
      this._tick++;
      const n = this._transform, i = this._activePath.instructions, a = n.a * e + n.c * r + n.tx, o = n.b * e + n.d * r + n.ty;
      return i.length === 1 && i[0].action === "moveTo" ? (i[0].data[0] = a, i[0].data[1] = o, this) : (this._activePath.moveTo(a, o), this);
    }
    quadraticCurveTo(e, r, n, i, a) {
      this._tick++;
      const o = this._transform;
      return this._activePath.quadraticCurveTo(o.a * e + o.c * r + o.tx, o.b * e + o.d * r + o.ty, o.a * n + o.c * i + o.tx, o.b * n + o.d * i + o.ty, a), this;
    }
    rect(e, r, n, i) {
      return this._tick++, this._activePath.rect(e, r, n, i, this._transform.clone()), this;
    }
    roundRect(e, r, n, i, a) {
      return this._tick++, this._activePath.roundRect(e, r, n, i, a, this._transform.clone()), this;
    }
    poly(e, r) {
      return this._tick++, this._activePath.poly(e, r, this._transform.clone()), this;
    }
    regularPoly(e, r, n, i, a = 0, o) {
      return this._tick++, this._activePath.regularPoly(e, r, n, i, a, o), this;
    }
    roundPoly(e, r, n, i, a, o) {
      return this._tick++, this._activePath.roundPoly(e, r, n, i, a, o), this;
    }
    roundShape(e, r, n, i) {
      return this._tick++, this._activePath.roundShape(e, r, n, i), this;
    }
    filletRect(e, r, n, i, a) {
      return this._tick++, this._activePath.filletRect(e, r, n, i, a), this;
    }
    chamferRect(e, r, n, i, a, o) {
      return this._tick++, this._activePath.chamferRect(e, r, n, i, a, o), this;
    }
    star(e, r, n, i, a = 0, o = 0) {
      return this._tick++, this._activePath.star(e, r, n, i, a, o, this._transform.clone()), this;
    }
    svg(e) {
      return this._tick++, bSe(e, this), this;
    }
    restore() {
      const e = this._stateStack.pop();
      return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this;
    }
    save() {
      return this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: {
          ...this._fillStyle
        },
        strokeStyle: {
          ...this._strokeStyle
        }
      }), this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      return this._transform.identity(), this;
    }
    rotate(e) {
      return this._transform.rotate(e), this;
    }
    scale(e, r = e) {
      return this._transform.scale(e, r), this;
    }
    setTransform(e, r, n, i, a, o) {
      return e instanceof $t ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, r, n, i, a, o), this);
    }
    transform(e, r, n, i, a, o) {
      return e instanceof $t ? (this._transform.append(e), this) : (_z.set(e, r, n, i, a, o), this._transform.append(_z), this);
    }
    translate(e, r = e) {
      return this._transform.translate(e, r), this;
    }
    clear() {
      return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
    }
    onUpdate() {
      this.dirty || (this.emit("update", this, 16), this.dirty = true, this._boundsDirty = true);
    }
    get bounds() {
      if (!this._boundsDirty) return this._bounds;
      const e = this._bounds;
      e.clear();
      for (let r = 0; r < this.instructions.length; r++) {
        const n = this.instructions[r], i = n.action;
        if (i === "fill") {
          const a = n.data;
          e.addBounds(a.path.bounds);
        } else if (i === "texture") {
          const a = n.data;
          e.addFrame(a.dx, a.dy, a.dx + a.dw, a.dy + a.dh, a.transform);
        }
        if (i === "stroke") {
          const a = n.data, o = a.style.alignment, s = a.style.width * (1 - o), l = a.path.bounds;
          e.addFrame(l.minX - s, l.minY - s, l.maxX + s, l.maxY + s);
        }
      }
      return e;
    }
    containsPoint(e) {
      var _a2;
      if (!this.bounds.containsPoint(e.x, e.y)) return false;
      const r = this.instructions;
      let n = false;
      for (let i = 0; i < r.length; i++) {
        const a = r[i], o = a.data, s = o.path;
        if (!a.action || !s) continue;
        const l = o.style, u = s.shapePath.shapePrimitives;
        for (let c = 0; c < u.length; c++) {
          const h = u[c].shape;
          if (!l || !h) continue;
          const f = u[c].transform, d = f ? f.applyInverse(e, ASe) : e;
          if (a.action === "fill") n = h.contains(d.x, d.y);
          else {
            const v = l;
            n = h.strokeContains(d.x, d.y, v.width, v.alignment);
          }
          const p = o.hole;
          if (p) {
            const v = (_a2 = p.shapePath) == null ? void 0 : _a2.shapePrimitives;
            if (v) for (let g = 0; g < v.length; g++) v[g].shape.contains(d.x, d.y) && (n = false);
          }
          if (n) return true;
        }
      }
      return n;
    }
    destroy(e = false) {
      if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const n = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        this._fillStyle.texture && this._fillStyle.texture.destroy(n), this._strokeStyle.texture && this._strokeStyle.texture.destroy(n);
      }
      this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
    }
  };
  qC.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: Kt.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local"
  };
  qC.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: Kt.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: false
  };
  let Fi = qC;
  const bz = [
    "align",
    "breakWords",
    "cssOverrides",
    "fontVariant",
    "fontWeight",
    "leading",
    "letterSpacing",
    "lineHeight",
    "padding",
    "textBaseline",
    "trim",
    "whiteSpace",
    "wordWrap",
    "wordWrapWidth",
    "fontFamily",
    "fontStyle",
    "fontSize"
  ];
  ISe = function(t) {
    const e = [];
    let r = 0;
    for (let n = 0; n < bz.length; n++) {
      const i = `_${bz[n]}`;
      e[r++] = t[i];
    }
    return r = Fq(t._fill, e, r), r = MSe(t._stroke, e, r), r = DSe(t.dropShadow, e, r), e.join("-");
  };
  function Fq(t, e, r) {
    var _a2;
    return t && (e[r++] = t.color, e[r++] = t.alpha, e[r++] = (_a2 = t.fill) == null ? void 0 : _a2.styleKey), r;
  }
  function MSe(t, e, r) {
    return t && (r = Fq(t, e, r), e[r++] = t.width, e[r++] = t.alignment, e[r++] = t.cap, e[r++] = t.join, e[r++] = t.miterLimit), r;
  }
  function DSe(t, e, r) {
    return t && (e[r++] = t.alpha, e[r++] = t.angle, e[r++] = t.blur, e[r++] = t.distance, e[r++] = an.shared.setValue(t.color).toNumber()), r;
  }
  const XC = class ec extends Fa {
    constructor(e = {}) {
      super(), ESe(e);
      const r = {
        ...ec.defaultTextStyle,
        ...e
      };
      for (const n in r) {
        const i = n;
        this[i] = r[n];
      }
      this.update();
    }
    get align() {
      return this._align;
    }
    set align(e) {
      this._align = e, this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(e) {
      this._breakWords = e, this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(e) {
      e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({
        ...ec.defaultDropShadow,
        ...e
      }) : this._dropShadow = e ? this._createProxy({
        ...ec.defaultDropShadow
      }) : null, this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(e) {
      this._fontFamily = e, this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(e) {
      typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(e) {
      this._fontStyle = e.toLowerCase(), this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(e) {
      this._fontVariant = e, this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(e) {
      this._fontWeight = e, this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(e) {
      this._leading = e, this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(e) {
      this._letterSpacing = e, this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(e) {
      this._lineHeight = e, this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(e) {
      this._padding = e, this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(e) {
      this._trim = e, this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(e) {
      this._textBaseline = e, this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(e) {
      this._whiteSpace = e, this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(e) {
      this._wordWrap = e, this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(e) {
      this._wordWrapWidth = e, this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(e) {
      e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({
        ...Fi.defaultFillStyle,
        ...e
      }, () => {
        this._fill = El({
          ...this._originalFill
        }, Fi.defaultFillStyle);
      })), this._fill = El(e === 0 ? "black" : e, Fi.defaultFillStyle), this.update());
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(e) {
      e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({
        ...Fi.defaultStrokeStyle,
        ...e
      }, () => {
        this._stroke = Dm({
          ...this._originalStroke
        }, Fi.defaultStrokeStyle);
      })), this._stroke = Dm(e, Fi.defaultStrokeStyle), this.update());
    }
    _generateKey() {
      return this._styleKey = ISe(this), this._styleKey;
    }
    update() {
      this._styleKey = null, this.emit("update", this);
    }
    reset() {
      const e = ec.defaultTextStyle;
      for (const r in e) this[r] = e[r];
    }
    get styleKey() {
      return this._styleKey || this._generateKey();
    }
    clone() {
      return new ec({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? {
          ...this._dropShadow
        } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth
      });
    }
    destroy(e = false) {
      var _a2, _b2, _c2, _d2;
      if (this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const n = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        ((_a2 = this._fill) == null ? void 0 : _a2.texture) && this._fill.texture.destroy(n), ((_b2 = this._originalFill) == null ? void 0 : _b2.texture) && this._originalFill.texture.destroy(n), ((_c2 = this._stroke) == null ? void 0 : _c2.texture) && this._stroke.texture.destroy(n), ((_d2 = this._originalStroke) == null ? void 0 : _d2.texture) && this._originalStroke.texture.destroy(n);
      }
      this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
    }
    _createProxy(e, r) {
      return new Proxy(e, {
        set: (n, i, a) => (n[i] = a, r == null ? void 0 : r(i, a), this.update(), true)
      });
    }
    _isFillStyle(e) {
      return (e ?? null) !== null && !(an.isColorLike(e) || e instanceof tu || e instanceof GC);
    }
  };
  XC.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
  };
  XC.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  TS = XC;
  function ESe(t) {
    const e = t;
    if (typeof e.dropShadow == "boolean" && e.dropShadow) {
      const r = TS.defaultDropShadow;
      t.dropShadow = {
        alpha: e.dropShadowAlpha ?? r.alpha,
        angle: e.dropShadowAngle ?? r.angle,
        blur: e.dropShadowBlur ?? r.blur,
        color: e.dropShadowColor ?? r.color,
        distance: e.dropShadowDistance ?? r.distance
      };
    }
    if (e.strokeThickness !== void 0) {
      Jt(fr, "strokeThickness is now a part of stroke");
      const r = e.stroke;
      let n = {};
      if (an.isColorLike(r)) n.color = r;
      else if (r instanceof tu || r instanceof GC) n.fill = r;
      else if (Object.hasOwnProperty.call(r, "color") || Object.hasOwnProperty.call(r, "fill")) n = r;
      else throw new Error("Invalid stroke value.");
      t.stroke = {
        ...n,
        width: e.strokeThickness
      };
    }
    if (Array.isArray(e.fillGradientStops)) {
      Jt(fr, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let r;
      t.fontSize == null ? t.fontSize = TS.defaultTextStyle.fontSize : typeof t.fontSize == "string" ? r = parseInt(t.fontSize, 10) : r = t.fontSize;
      const n = new tu({
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: (r || 0) * 1.7
        }
      }), i = e.fillGradientStops.map((a) => an.shared.setValue(a).toNumber());
      i.forEach((a, o) => {
        const s = o / (i.length - 1);
        n.addColorStop(s, a);
      }), t.fill = {
        fill: n
      };
    }
  }
  const kSe = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  PSe = function(t) {
    const e = typeof t.fontSize == "number" ? `${t.fontSize}px` : t.fontSize;
    let r = t.fontFamily;
    Array.isArray(t.fontFamily) || (r = t.fontFamily.split(","));
    for (let n = r.length - 1; n >= 0; n--) {
      let i = r[n].trim();
      !/([\"\'])[^\'\"]+\1/.test(i) && !kSe.includes(i) && (i = `"${i}"`), r[n] = i;
    }
    return `${t.fontStyle} ${t.fontVariant} ${t.fontWeight} ${e} ${r.join(",")}`;
  };
  const z1 = {
    willReadFrequently: true
  }, ra = class Ue {
    static get experimentalLetterSpacingSupported() {
      let e = Ue._experimentalLetterSpacingSupported;
      if (e !== void 0) {
        const r = Xi.get().getCanvasRenderingContext2D().prototype;
        e = Ue._experimentalLetterSpacingSupported = "letterSpacing" in r || "textLetterSpacing" in r;
      }
      return e;
    }
    constructor(e, r, n, i, a, o, s, l, u) {
      this.text = e, this.style = r, this.width = n, this.height = i, this.lines = a, this.lineWidths = o, this.lineHeight = s, this.maxLineWidth = l, this.fontProperties = u;
    }
    static measureText(e = " ", r, n = Ue._canvas, i = r.wordWrap) {
      var _a2;
      const a = `${e}:${r.styleKey}`;
      if (Ue._measurementCache[a]) return Ue._measurementCache[a];
      const o = PSe(r), s = Ue.measureFont(o);
      s.fontSize === 0 && (s.fontSize = r.fontSize, s.ascent = r.fontSize);
      const l = Ue.__context;
      l.font = o;
      const c = (i ? Ue._wordWrap(e, r, n) : e).split(/(?:\r\n|\r|\n)/), h = new Array(c.length);
      let f = 0;
      for (let y = 0; y < c.length; y++) {
        const _ = Ue._measureText(c[y], r.letterSpacing, l);
        h[y] = _, f = Math.max(f, _);
      }
      const d = ((_a2 = r._stroke) == null ? void 0 : _a2.width) || 0;
      let p = f + d;
      r.dropShadow && (p += r.dropShadow.distance);
      const v = r.lineHeight || s.fontSize;
      let g = Math.max(v, s.fontSize + d) + (c.length - 1) * (v + r.leading);
      return r.dropShadow && (g += r.dropShadow.distance), new Ue(e, r, p, g, c, h, v + r.leading, f, s);
    }
    static _measureText(e, r, n) {
      let i = false;
      Ue.experimentalLetterSpacingSupported && (Ue.experimentalLetterSpacing ? (n.letterSpacing = `${r}px`, n.textLetterSpacing = `${r}px`, i = true) : (n.letterSpacing = "0px", n.textLetterSpacing = "0px"));
      const a = n.measureText(e);
      let o = a.width;
      const s = -a.actualBoundingBoxLeft;
      let u = a.actualBoundingBoxRight - s;
      if (o > 0) if (i) o -= r, u -= r;
      else {
        const c = (Ue.graphemeSegmenter(e).length - 1) * r;
        o += c, u += c;
      }
      return Math.max(o, u);
    }
    static _wordWrap(e, r, n = Ue._canvas) {
      const i = n.getContext("2d", z1);
      let a = 0, o = "", s = "";
      const l = /* @__PURE__ */ Object.create(null), { letterSpacing: u, whiteSpace: c } = r, h = Ue._collapseSpaces(c), f = Ue._collapseNewlines(c);
      let d = !h;
      const p = r.wordWrapWidth + u, v = Ue._tokenize(e);
      for (let g = 0; g < v.length; g++) {
        let m = v[g];
        if (Ue._isNewline(m)) {
          if (!f) {
            s += Ue._addLine(o), d = !h, o = "", a = 0;
            continue;
          }
          m = " ";
        }
        if (h) {
          const _ = Ue.isBreakingSpace(m), b = Ue.isBreakingSpace(o[o.length - 1]);
          if (_ && b) continue;
        }
        const y = Ue._getFromCache(m, u, l, i);
        if (y > p) if (o !== "" && (s += Ue._addLine(o), o = "", a = 0), Ue.canBreakWords(m, r.breakWords)) {
          const _ = Ue.wordWrapSplit(m);
          for (let b = 0; b < _.length; b++) {
            let w = _[b], x = w, T = 1;
            for (; _[b + T]; ) {
              const I = _[b + T];
              if (!Ue.canBreakChars(x, I, m, b, r.breakWords)) w += I;
              else break;
              x = I, T++;
            }
            b += T - 1;
            const A = Ue._getFromCache(w, u, l, i);
            A + a > p && (s += Ue._addLine(o), d = false, o = "", a = 0), o += w, a += A;
          }
        } else {
          o.length > 0 && (s += Ue._addLine(o), o = "", a = 0);
          const _ = g === v.length - 1;
          s += Ue._addLine(m, !_), d = false, o = "", a = 0;
        }
        else y + a > p && (d = false, s += Ue._addLine(o), o = "", a = 0), (o.length > 0 || !Ue.isBreakingSpace(m) || d) && (o += m, a += y);
      }
      return s += Ue._addLine(o, false), s;
    }
    static _addLine(e, r = true) {
      return e = Ue._trimRight(e), e = r ? `${e}
` : e, e;
    }
    static _getFromCache(e, r, n, i) {
      let a = n[e];
      return typeof a != "number" && (a = Ue._measureText(e, r, i) + r, n[e] = a), a;
    }
    static _collapseSpaces(e) {
      return e === "normal" || e === "pre-line";
    }
    static _collapseNewlines(e) {
      return e === "normal";
    }
    static _trimRight(e) {
      if (typeof e != "string") return "";
      for (let r = e.length - 1; r >= 0; r--) {
        const n = e[r];
        if (!Ue.isBreakingSpace(n)) break;
        e = e.slice(0, -1);
      }
      return e;
    }
    static _isNewline(e) {
      return typeof e != "string" ? false : Ue._newlines.includes(e.charCodeAt(0));
    }
    static isBreakingSpace(e, r) {
      return typeof e != "string" ? false : Ue._breakingSpaces.includes(e.charCodeAt(0));
    }
    static _tokenize(e) {
      const r = [];
      let n = "";
      if (typeof e != "string") return r;
      for (let i = 0; i < e.length; i++) {
        const a = e[i], o = e[i + 1];
        if (Ue.isBreakingSpace(a, o) || Ue._isNewline(a)) {
          n !== "" && (r.push(n), n = ""), r.push(a);
          continue;
        }
        n += a;
      }
      return n !== "" && r.push(n), r;
    }
    static canBreakWords(e, r) {
      return r;
    }
    static canBreakChars(e, r, n, i, a) {
      return true;
    }
    static wordWrapSplit(e) {
      return Ue.graphemeSegmenter(e);
    }
    static measureFont(e) {
      if (Ue._fonts[e]) return Ue._fonts[e];
      const r = Ue._context;
      r.font = e;
      const n = r.measureText(Ue.METRICS_STRING + Ue.BASELINE_SYMBOL), i = {
        ascent: n.actualBoundingBoxAscent,
        descent: n.actualBoundingBoxDescent,
        fontSize: n.actualBoundingBoxAscent + n.actualBoundingBoxDescent
      };
      return Ue._fonts[e] = i, i;
    }
    static clearMetrics(e = "") {
      e ? delete Ue._fonts[e] : Ue._fonts = {};
    }
    static get _canvas() {
      var _a2;
      if (!Ue.__canvas) {
        let e;
        try {
          const r = new OffscreenCanvas(0, 0);
          if ((_a2 = r.getContext("2d", z1)) == null ? void 0 : _a2.measureText) return Ue.__canvas = r, r;
          e = Xi.get().createCanvas();
        } catch {
          e = Xi.get().createCanvas();
        }
        e.width = e.height = 10, Ue.__canvas = e;
      }
      return Ue.__canvas;
    }
    static get _context() {
      return Ue.__context || (Ue.__context = Ue._canvas.getContext("2d", z1)), Ue.__context;
    }
  };
  ra.METRICS_STRING = "|\xC9q\xC5";
  ra.BASELINE_SYMBOL = "M";
  ra.BASELINE_MULTIPLIER = 1.4;
  ra.HEIGHT_MULTIPLIER = 2;
  ra.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
      const t = new Intl.Segmenter();
      return (e) => [
        ...t.segment(e)
      ].map((r) => r.segment);
    }
    return (t) => [
      ...t
    ];
  })();
  ra.experimentalLetterSpacing = false;
  ra._fonts = {};
  ra._newlines = [
    10,
    13
  ];
  ra._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  ra._measurementCache = {};
  LSe = ra;
  Em = class extends BC {
    constructor(e) {
      e instanceof Fi && (e = {
        context: e
      });
      const { context: r, roundPixels: n, ...i } = e || {};
      super({
        label: "Graphics",
        ...i
      }), this.renderPipeId = "graphics", r ? this._context = r : this._context = this._ownedContext = new Fi(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = false, this.roundPixels = n ?? false;
    }
    set context(e) {
      e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    updateBounds() {
    }
    containsPoint(e) {
      return this._context.containsPoint(e);
    }
    destroy(e) {
      this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === true || (e == null ? void 0 : e.context) === true) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e);
    }
    _callContextMethod(e, r) {
      return this.context[e](...r), this;
    }
    setFillStyle(...e) {
      return this._callContextMethod("setFillStyle", e);
    }
    setStrokeStyle(...e) {
      return this._callContextMethod("setStrokeStyle", e);
    }
    fill(...e) {
      return this._callContextMethod("fill", e);
    }
    stroke(...e) {
      return this._callContextMethod("stroke", e);
    }
    texture(...e) {
      return this._callContextMethod("texture", e);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...e) {
      return this._callContextMethod("arc", e);
    }
    arcTo(...e) {
      return this._callContextMethod("arcTo", e);
    }
    arcToSvg(...e) {
      return this._callContextMethod("arcToSvg", e);
    }
    bezierCurveTo(...e) {
      return this._callContextMethod("bezierCurveTo", e);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...e) {
      return this._callContextMethod("ellipse", e);
    }
    circle(...e) {
      return this._callContextMethod("circle", e);
    }
    path(...e) {
      return this._callContextMethod("path", e);
    }
    lineTo(...e) {
      return this._callContextMethod("lineTo", e);
    }
    moveTo(...e) {
      return this._callContextMethod("moveTo", e);
    }
    quadraticCurveTo(...e) {
      return this._callContextMethod("quadraticCurveTo", e);
    }
    rect(...e) {
      return this._callContextMethod("rect", e);
    }
    roundRect(...e) {
      return this._callContextMethod("roundRect", e);
    }
    poly(...e) {
      return this._callContextMethod("poly", e);
    }
    regularPoly(...e) {
      return this._callContextMethod("regularPoly", e);
    }
    roundPoly(...e) {
      return this._callContextMethod("roundPoly", e);
    }
    roundShape(...e) {
      return this._callContextMethod("roundShape", e);
    }
    filletRect(...e) {
      return this._callContextMethod("filletRect", e);
    }
    chamferRect(...e) {
      return this._callContextMethod("chamferRect", e);
    }
    star(...e) {
      return this._callContextMethod("star", e);
    }
    svg(...e) {
      return this._callContextMethod("svg", e);
    }
    restore(...e) {
      return this._callContextMethod("restore", e);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...e) {
      return this._callContextMethod("rotate", e);
    }
    scaleTransform(...e) {
      return this._callContextMethod("scale", e);
    }
    setTransform(...e) {
      return this._callContextMethod("setTransform", e);
    }
    transform(...e) {
      return this._callContextMethod("transform", e);
    }
    translateTransform(...e) {
      return this._callContextMethod("translate", e);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(e) {
      this._context.fillStyle = e;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(e) {
      this._context.strokeStyle = e;
    }
    clone(e = false) {
      return e ? new Em(this._context.clone()) : (this._ownedContext = null, new Em(this._context));
    }
    lineStyle(e, r, n) {
      Jt(fr, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const i = {};
      return e && (i.width = e), r && (i.color = r), n && (i.alpha = n), this.context.strokeStyle = i, this;
    }
    beginFill(e, r) {
      Jt(fr, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const n = {};
      return e !== void 0 && (n.color = e), r !== void 0 && (n.alpha = r), this.context.fillStyle = n, this;
    }
    endFill() {
      Jt(fr, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
      const e = this.context.strokeStyle;
      return (e.width !== Fi.defaultStrokeStyle.width || e.color !== Fi.defaultStrokeStyle.color || e.alpha !== Fi.defaultStrokeStyle.alpha) && this.context.stroke(), this;
    }
    drawCircle(...e) {
      return Jt(fr, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e);
    }
    drawEllipse(...e) {
      return Jt(fr, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e);
    }
    drawPolygon(...e) {
      return Jt(fr, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e);
    }
    drawRect(...e) {
      return Jt(fr, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e);
    }
    drawRoundedRect(...e) {
      return Jt(fr, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e);
    }
    drawStar(...e) {
      return Jt(fr, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e);
    }
  };
  class $Se extends BC {
    constructor(e, r) {
      const { text: n, resolution: i, style: a, anchor: o, width: s, height: l, roundPixels: u, ...c } = e;
      super({
        ...c
      }), this.batched = true, this._resolution = null, this._autoResolution = true, this._didTextUpdate = true, this._styleClass = r, this.text = n ?? "", this.style = a, this.resolution = i ?? null, this.allowChildren = false, this._anchor = new In({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), o && (this.anchor = o), this.roundPixels = u ?? false, s !== void 0 && (this.width = s), l !== void 0 && (this.height = l);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    set text(e) {
      e = e.toString(), this._text !== e && (this._text = e, this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(e) {
      this._autoResolution = e === null, this._resolution = e, this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(e) {
      var _a2;
      e || (e = {}), (_a2 = this._style) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(e) {
      this._setWidth(e, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(e) {
      this._setHeight(e, this.bounds.height);
    }
    getSize(e) {
      return e || (e = {}), e.width = Math.abs(this.scale.x) * this.bounds.width, e.height = Math.abs(this.scale.y) * this.bounds.height, e;
    }
    setSize(e, r) {
      typeof e == "object" ? (r = e.height ?? e.width, e = e.width) : r ?? (r = e), e !== void 0 && this._setWidth(e, this.bounds.width), r !== void 0 && this._setHeight(r, this.bounds.height);
    }
    containsPoint(e) {
      const r = this.bounds.width, n = this.bounds.height, i = -r * this.anchor.x;
      let a = 0;
      return e.x >= i && e.x <= i + r && (a = -n * this.anchor.y, e.y >= a && e.y <= a + n);
    }
    onViewUpdate() {
      this.didViewUpdate || (this._didTextUpdate = true), super.onViewUpdate();
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    destroy(e = false) {
      super.destroy(e), this.owner = null, this._bounds = null, this._anchor = null, (typeof e == "boolean" ? e : e == null ? void 0 : e.style) && this._style.destroy(e), this._style = null, this._text = null;
    }
  }
  function RSe(t, e) {
    let r = t[0] ?? {};
    return (typeof r == "string" || t[1]) && (Jt(fr, `use new ${e}({ text: "hi!", style }) instead`), r = {
      text: r,
      style: t[1]
    }), r;
  }
  class OSe extends $Se {
    constructor(...e) {
      const r = RSe(e, "Text");
      super(r, TS), this.renderPipeId = "text";
    }
    updateBounds() {
      const e = this._bounds, r = this._anchor, n = LSe.measureText(this._text, this._style), { width: i, height: a } = n;
      e.minX = -r._x * i, e.maxX = e.minX + i, e.minY = -r._y * a, e.maxY = e.minY + a;
    }
  }
  jC = class extends Kt {
    static create(e) {
      return new jC({
        source: new ta(e)
      });
    }
    resize(e, r, n) {
      return this.source.resize(e, r, n), this;
    }
  };
  Ti.add(e1e, t1e);
  class NSe extends M9 {
    constructor(e) {
      super(e);
      __publicField(this, "app");
      __publicField(this, "graphicsList", []);
      this.app = new xq();
    }
    async init() {
      await this.app.init({
        canvas: this._canvas,
        width: this._canvas.width,
        height: this._canvas.height,
        backgroundAlpha: 0
      });
    }
    render(e, r, n, i, a, o = 0.6) {
      this.clear();
      const s = this.app.renderer.width, l = this.app.renderer.height, u = new gB(), c = Math.max(Math.round(Math.max(s, l) / 40), 14);
      for (let h = 0; h < n.length; ++h) {
        if (n[h] < o) continue;
        const f = r[i[h]], d = u.get(i[h]), p = (n[h] * 100).toFixed(1);
        let [v, g, m, y] = e.slice(h * 4, (h + 1) * 4);
        [g, y] = [
          g * a[0],
          y * a[0]
        ], [v, m] = [
          v * a[1],
          m * a[1]
        ];
        const _ = y - g, b = m - v, w = new Em();
        w.rect(g, v, _, b).stroke({
          color: d,
          width: 2
        }).fill({
          color: gB.hexToRgba(d, 0.2)
        });
        const x = new OSe({
          text: `${f} - ${p}%`,
          style: {
            fontFamily: "Arial",
            fontSize: c,
            fill: "#ffffff"
          }
        }), T = x.width, A = x.height, I = v - (A + 2);
        w.fill({
          color: parseInt(d.slice(1), 16)
        }).rect(g - 1, I < 0 ? 0 : I, T + 2, A + 2).fill(), x.x = g - 1, x.y = I < 0 ? 0 : I, w.addChild(x), w.eventMode = "static", w.cursor = "pointer", w.on("mousedown", (M) => {
          var _a2;
          (_a2 = this.onSelect) == null ? void 0 : _a2.call(this, M, {
            boxes: e,
            labels: r,
            scores: n,
            classes: i,
            ratios: a,
            canvas: this.app.canvas
          });
        }), this.app.stage.addChild(w), this.graphicsList.push(w);
      }
    }
    capture(e) {
      const r = e.getContext("2d");
      return new Promise((n) => {
        const i = jC.create({
          width: this.app.canvas.width,
          height: this.app.canvas.height
        });
        this.app.ticker.addOnce(() => {
          this.app.renderer.render(this.app.stage, {
            renderTexture: i
          });
          const a = new kc(i);
          r.drawImage(this.app.renderer.extract.canvas(a), 0, 0, e.width, e.height), n();
        });
      });
    }
    clear() {
      this.app.stage.removeChildren(), this.graphicsList.length = 0;
    }
    dispose() {
      this.clear(), this.app.destroy(true, {
        children: true,
        texture: true
      });
    }
  }
  function BSe(t, e) {
    switch (t) {
      case "fabric":
        return new Jbe(e);
      case "pixi":
        return new NSe(e);
      default:
        throw new Error(`Unsupported renderer type: ${t}`);
    }
  }
  const _kl = class _kl {
    constructor() {
      __publicField(this, "ready", false);
      __publicField(this, "model");
      __publicField(this, "modelName", "");
      __publicField(this, "loadingModel", false);
      __publicField(this, "loadingModelProgress", 0);
      __publicField(this, "renderer");
    }
    static getInstance() {
      return _kl._instance || (_kl._instance = new _kl()), _kl._instance;
    }
    async loadModel(e) {
      return this.loadingModel = true, this.loadingModelProgress = 0, await Qbe({
        ...e,
        onProgress: (n) => {
          var _a2;
          n >= 100 ? (this.loadingModel = false, this.loadingModelProgress = 100) : (this.loadingModel = true, this.loadingModelProgress = n), (_a2 = e.onProgress) == null ? void 0 : _a2.call(e, n);
        }
      });
    }
    testRun() {
      var _a2;
      return (_a2 = this.model) == null ? void 0 : _a2.testRun();
    }
    async setRenderer(e, r, n) {
      if (this.renderer) return;
      const i = BSe("pixi", r);
      await i.init(), this.renderer = i, this.renderer.onSelect = async (a, o) => {
        const [s, l, u] = this.model.inputShape, { canvas: c, ...h } = o, f = await this.capture(e, c);
        n({
          image: f,
          ...h,
          modelSize: [
            l,
            u
          ]
        });
      };
    }
    detectVideo(e, { once: r, onOutput: n, scoreThreshold: i }) {
      var _a2;
      return (_a2 = this.model) == null ? void 0 : _a2.detectVideo(e, {
        once: r,
        onOutput: async (a) => {
          var _a3, _b2, _c2;
          if (!a || !a.boxes.length) {
            (_a3 = this.renderer) == null ? void 0 : _a3.clear();
            return;
          }
          (_b2 = this.renderer) == null ? void 0 : _b2.render(a.boxes, a.labels, a.scores, a.classes, a.ratios, i), n(a), r && a.boxes.length && ((_c2 = this.renderer) == null ? void 0 : _c2.clear());
        }
      });
    }
    async capture(e, r) {
      var _a2;
      const n = document.createElement("canvas"), i = n.getContext("2d");
      return n.width = r.width, n.height = r.height, i.drawImage(e, 0, 0, n.width, n.height), await ((_a2 = this.renderer) == null ? void 0 : _a2.capture(n)), n.toDataURL();
    }
    dispose() {
      var _a2, _b2;
      (_a2 = this.model) == null ? void 0 : _a2.dispose(), (_b2 = this.renderer) == null ? void 0 : _b2.dispose(), this.renderer = null, this.model = null;
    }
  };
  __publicField(_kl, "_instance");
  let kl = _kl;
  const xz = kl.getInstance(), zSe = vF("video-detect", {
    state: () => ({
      backend: "webgl",
      loadedModel: "",
      loadState: {
        loading: false,
        progress: 0
      }
    }),
    actions: {
      async setBackend(t = "webgl") {
        this.backend = t;
      },
      async loadModel(t, e) {
        this.loadState.loading = true, this.loadedModel = "";
        try {
          await xz.loadModel({
            type: t,
            url: e,
            backend: this.backend,
            onProgress: (r) => {
              r === 100 ? this.loadState.progress = r : (this.loadState.loading = true, this.loadState.progress = r);
            }
          }), await xz.testRun(), this.loadedModel = e;
        } finally {
          this.loadState.loading = false;
        }
      }
    }
  }), FSe = (t, e, r) => {
    const n = t[e];
    return n ? typeof n == "function" ? n() : Promise.resolve(n) : new Promise((i, a) => {
      (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(a.bind(null, new Error("Unknown variable dynamic import: " + e + (e.split("/").length !== r ? ". Note that variables only represent file names one level deep." : ""))));
    });
  };
  const km = typeof window < "u", Ss = (t, e = false) => e ? Symbol.for(t) : Symbol(t), VSe = (t, e, r) => GSe({
    l: t,
    k: e,
    s: r
  }), GSe = (t) => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), br = (t) => typeof t == "number" && isFinite(t), WSe = (t) => KC(t) === "[object Date]", Lc = (t) => KC(t) === "[object RegExp]", Cy = (t) => Ct(t) && Object.keys(t).length === 0, Pr = Object.assign, HSe = Object.create, Zt = (t = null) => HSe(t);
  let wz;
  const Pl = () => wz || (wz = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : Zt());
  function Sz(t) {
    return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const USe = Object.prototype.hasOwnProperty;
  function Wi(t, e) {
    return USe.call(t, e);
  }
  const Sr = Array.isArray, nr = (t) => typeof t == "function", Pe = (t) => typeof t == "string", Rt = (t) => typeof t == "boolean", zt = (t) => t !== null && typeof t == "object", YSe = (t) => zt(t) && nr(t.then) && nr(t.catch), Vq = Object.prototype.toString, KC = (t) => Vq.call(t), Ct = (t) => KC(t) === "[object Object]", qSe = (t) => t == null ? "" : Sr(t) || Ct(t) && t.toString === Vq ? JSON.stringify(t, null, 2) : String(t);
  function ZC(t, e = "") {
    return t.reduce((r, n, i) => i === 0 ? r + n : r + e + n, "");
  }
  function XSe(t, e) {
    typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack));
  }
  const Vv = (t) => !zt(t) || Sr(t);
  function xg(t, e) {
    if (Vv(t) || Vv(e)) throw new Error("Invalid value");
    const r = [
      {
        src: t,
        des: e
      }
    ];
    for (; r.length; ) {
      const { src: n, des: i } = r.pop();
      Object.keys(n).forEach((a) => {
        a !== "__proto__" && (zt(n[a]) && !zt(i[a]) && (i[a] = Array.isArray(n[a]) ? [] : Zt()), Vv(i[a]) || Vv(n[a]) ? i[a] = n[a] : r.push({
          src: n[a],
          des: i[a]
        }));
      });
    }
  }
  function jSe(t, e, r) {
    return {
      line: t,
      column: e,
      offset: r
    };
  }
  function CS(t, e, r) {
    return {
      start: t,
      end: e
    };
  }
  const Ht = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14
  }, KSe = 17;
  function Ay(t, e, r = {}) {
    const { domain: n, messages: i, args: a } = r, o = t, s = new SyntaxError(String(o));
    return s.code = t, e && (s.location = e), s.domain = n, s;
  }
  function ZSe(t) {
    throw t;
  }
  const Xa = " ", QSe = "\r", hn = `
`, JSe = "\u2028", eTe = "\u2029";
  function tTe(t) {
    const e = t;
    let r = 0, n = 1, i = 1, a = 0;
    const o = (T) => e[T] === QSe && e[T + 1] === hn, s = (T) => e[T] === hn, l = (T) => e[T] === eTe, u = (T) => e[T] === JSe, c = (T) => o(T) || s(T) || l(T) || u(T), h = () => r, f = () => n, d = () => i, p = () => a, v = (T) => o(T) || l(T) || u(T) ? hn : e[T], g = () => v(r), m = () => v(r + a);
    function y() {
      return a = 0, c(r) && (n++, i = 0), o(r) && r++, r++, i++, e[r];
    }
    function _() {
      return o(r + a) && a++, a++, e[r + a];
    }
    function b() {
      r = 0, n = 1, i = 1, a = 0;
    }
    function w(T = 0) {
      a = T;
    }
    function x() {
      const T = r + a;
      for (; T !== r; ) y();
      a = 0;
    }
    return {
      index: h,
      line: f,
      column: d,
      peekOffset: p,
      charAt: v,
      currentChar: g,
      currentPeek: m,
      next: y,
      peek: _,
      reset: b,
      resetPeek: w,
      skipToPeek: x
    };
  }
  const Vo = void 0, rTe = ".", Tz = "'", nTe = "tokenizer";
  function iTe(t, e = {}) {
    const r = e.location !== false, n = tTe(t), i = () => n.index(), a = () => jSe(n.line(), n.column(), n.index()), o = a(), s = i(), l = {
      currentType: 13,
      offset: s,
      startLoc: o,
      endLoc: o,
      lastType: 13,
      lastOffset: s,
      lastStartLoc: o,
      lastEndLoc: o,
      braceNest: 0,
      inLinked: false,
      text: ""
    }, u = () => l, { onError: c } = e;
    function h(X, j, he, ...$e) {
      const jt = u();
      if (j.column += he, j.offset += he, c) {
        const pt = r ? CS(jt.startLoc, j) : null, ne = Ay(X, pt, {
          domain: nTe,
          args: $e
        });
        c(ne);
      }
    }
    function f(X, j, he) {
      X.endLoc = a(), X.currentType = j;
      const $e = {
        type: j
      };
      return r && ($e.loc = CS(X.startLoc, X.endLoc)), he != null && ($e.value = he), $e;
    }
    const d = (X) => f(X, 13);
    function p(X, j) {
      return X.currentChar() === j ? (X.next(), j) : (h(Ht.EXPECTED_TOKEN, a(), 0, j), "");
    }
    function v(X) {
      let j = "";
      for (; X.currentPeek() === Xa || X.currentPeek() === hn; ) j += X.currentPeek(), X.peek();
      return j;
    }
    function g(X) {
      const j = v(X);
      return X.skipToPeek(), j;
    }
    function m(X) {
      if (X === Vo) return false;
      const j = X.charCodeAt(0);
      return j >= 97 && j <= 122 || j >= 65 && j <= 90 || j === 95;
    }
    function y(X) {
      if (X === Vo) return false;
      const j = X.charCodeAt(0);
      return j >= 48 && j <= 57;
    }
    function _(X, j) {
      const { currentType: he } = j;
      if (he !== 2) return false;
      v(X);
      const $e = m(X.currentPeek());
      return X.resetPeek(), $e;
    }
    function b(X, j) {
      const { currentType: he } = j;
      if (he !== 2) return false;
      v(X);
      const $e = X.currentPeek() === "-" ? X.peek() : X.currentPeek(), jt = y($e);
      return X.resetPeek(), jt;
    }
    function w(X, j) {
      const { currentType: he } = j;
      if (he !== 2) return false;
      v(X);
      const $e = X.currentPeek() === Tz;
      return X.resetPeek(), $e;
    }
    function x(X, j) {
      const { currentType: he } = j;
      if (he !== 7) return false;
      v(X);
      const $e = X.currentPeek() === ".";
      return X.resetPeek(), $e;
    }
    function T(X, j) {
      const { currentType: he } = j;
      if (he !== 8) return false;
      v(X);
      const $e = m(X.currentPeek());
      return X.resetPeek(), $e;
    }
    function A(X, j) {
      const { currentType: he } = j;
      if (!(he === 7 || he === 11)) return false;
      v(X);
      const $e = X.currentPeek() === ":";
      return X.resetPeek(), $e;
    }
    function I(X, j) {
      const { currentType: he } = j;
      if (he !== 9) return false;
      const $e = () => {
        const pt = X.currentPeek();
        return pt === "{" ? m(X.peek()) : pt === "@" || pt === "|" || pt === ":" || pt === "." || pt === Xa || !pt ? false : pt === hn ? (X.peek(), $e()) : k(X, false);
      }, jt = $e();
      return X.resetPeek(), jt;
    }
    function M(X) {
      v(X);
      const j = X.currentPeek() === "|";
      return X.resetPeek(), j;
    }
    function k(X, j = true) {
      const he = (jt = false, pt = "") => {
        const ne = X.currentPeek();
        return ne === "{" || ne === "@" || !ne ? jt : ne === "|" ? !(pt === Xa || pt === hn) : ne === Xa ? (X.peek(), he(true, Xa)) : ne === hn ? (X.peek(), he(true, hn)) : true;
      }, $e = he();
      return j && X.resetPeek(), $e;
    }
    function B(X, j) {
      const he = X.currentChar();
      return he === Vo ? Vo : j(he) ? (X.next(), he) : null;
    }
    function L(X) {
      const j = X.charCodeAt(0);
      return j >= 97 && j <= 122 || j >= 65 && j <= 90 || j >= 48 && j <= 57 || j === 95 || j === 36;
    }
    function z(X) {
      return B(X, L);
    }
    function F(X) {
      const j = X.charCodeAt(0);
      return j >= 97 && j <= 122 || j >= 65 && j <= 90 || j >= 48 && j <= 57 || j === 95 || j === 36 || j === 45;
    }
    function E(X) {
      return B(X, F);
    }
    function O(X) {
      const j = X.charCodeAt(0);
      return j >= 48 && j <= 57;
    }
    function N(X) {
      return B(X, O);
    }
    function V(X) {
      const j = X.charCodeAt(0);
      return j >= 48 && j <= 57 || j >= 65 && j <= 70 || j >= 97 && j <= 102;
    }
    function H(X) {
      return B(X, V);
    }
    function G(X) {
      let j = "", he = "";
      for (; j = N(X); ) he += j;
      return he;
    }
    function Y(X) {
      let j = "";
      for (; ; ) {
        const he = X.currentChar();
        if (he === "{" || he === "}" || he === "@" || he === "|" || !he) break;
        if (he === Xa || he === hn) if (k(X)) j += he, X.next();
        else {
          if (M(X)) break;
          j += he, X.next();
        }
        else j += he, X.next();
      }
      return j;
    }
    function U(X) {
      g(X);
      let j = "", he = "";
      for (; j = E(X); ) he += j;
      return X.currentChar() === Vo && h(Ht.UNTERMINATED_CLOSING_BRACE, a(), 0), he;
    }
    function Z(X) {
      g(X);
      let j = "";
      return X.currentChar() === "-" ? (X.next(), j += `-${G(X)}`) : j += G(X), X.currentChar() === Vo && h(Ht.UNTERMINATED_CLOSING_BRACE, a(), 0), j;
    }
    function ee(X) {
      return X !== Tz && X !== hn;
    }
    function we(X) {
      g(X), p(X, "'");
      let j = "", he = "";
      for (; j = B(X, ee); ) j === "\\" ? he += Te(X) : he += j;
      const $e = X.currentChar();
      return $e === hn || $e === Vo ? (h(Ht.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, a(), 0), $e === hn && (X.next(), p(X, "'")), he) : (p(X, "'"), he);
    }
    function Te(X) {
      const j = X.currentChar();
      switch (j) {
        case "\\":
        case "'":
          return X.next(), `\\${j}`;
        case "u":
          return le(X, j, 4);
        case "U":
          return le(X, j, 6);
        default:
          return h(Ht.UNKNOWN_ESCAPE_SEQUENCE, a(), 0, j), "";
      }
    }
    function le(X, j, he) {
      p(X, j);
      let $e = "";
      for (let jt = 0; jt < he; jt++) {
        const pt = H(X);
        if (!pt) {
          h(Ht.INVALID_UNICODE_ESCAPE_SEQUENCE, a(), 0, `\\${j}${$e}${X.currentChar()}`);
          break;
        }
        $e += pt;
      }
      return `\\${j}${$e}`;
    }
    function ue(X) {
      return X !== "{" && X !== "}" && X !== Xa && X !== hn;
    }
    function ye(X) {
      g(X);
      let j = "", he = "";
      for (; j = B(X, ue); ) he += j;
      return he;
    }
    function ve(X) {
      let j = "", he = "";
      for (; j = z(X); ) he += j;
      return he;
    }
    function Se(X) {
      const j = (he) => {
        const $e = X.currentChar();
        return $e === "{" || $e === "@" || $e === "|" || $e === "(" || $e === ")" || !$e || $e === Xa ? he : (he += $e, X.next(), j(he));
      };
      return j("");
    }
    function Qe(X) {
      g(X);
      const j = p(X, "|");
      return g(X), j;
    }
    function Xe(X, j) {
      let he = null;
      switch (X.currentChar()) {
        case "{":
          return j.braceNest >= 1 && h(Ht.NOT_ALLOW_NEST_PLACEHOLDER, a(), 0), X.next(), he = f(j, 2, "{"), g(X), j.braceNest++, he;
        case "}":
          return j.braceNest > 0 && j.currentType === 2 && h(Ht.EMPTY_PLACEHOLDER, a(), 0), X.next(), he = f(j, 3, "}"), j.braceNest--, j.braceNest > 0 && g(X), j.inLinked && j.braceNest === 0 && (j.inLinked = false), he;
        case "@":
          return j.braceNest > 0 && h(Ht.UNTERMINATED_CLOSING_BRACE, a(), 0), he = be(X, j) || d(j), j.braceNest = 0, he;
        default: {
          let jt = true, pt = true, ne = true;
          if (M(X)) return j.braceNest > 0 && h(Ht.UNTERMINATED_CLOSING_BRACE, a(), 0), he = f(j, 1, Qe(X)), j.braceNest = 0, j.inLinked = false, he;
          if (j.braceNest > 0 && (j.currentType === 4 || j.currentType === 5 || j.currentType === 6)) return h(Ht.UNTERMINATED_CLOSING_BRACE, a(), 0), j.braceNest = 0, ke(X, j);
          if (jt = _(X, j)) return he = f(j, 4, U(X)), g(X), he;
          if (pt = b(X, j)) return he = f(j, 5, Z(X)), g(X), he;
          if (ne = w(X, j)) return he = f(j, 6, we(X)), g(X), he;
          if (!jt && !pt && !ne) return he = f(j, 12, ye(X)), h(Ht.INVALID_TOKEN_IN_PLACEHOLDER, a(), 0, he.value), g(X), he;
          break;
        }
      }
      return he;
    }
    function be(X, j) {
      const { currentType: he } = j;
      let $e = null;
      const jt = X.currentChar();
      switch ((he === 7 || he === 8 || he === 11 || he === 9) && (jt === hn || jt === Xa) && h(Ht.INVALID_LINKED_FORMAT, a(), 0), jt) {
        case "@":
          return X.next(), $e = f(j, 7, "@"), j.inLinked = true, $e;
        case ".":
          return g(X), X.next(), f(j, 8, ".");
        case ":":
          return g(X), X.next(), f(j, 9, ":");
        default:
          return M(X) ? ($e = f(j, 1, Qe(X)), j.braceNest = 0, j.inLinked = false, $e) : x(X, j) || A(X, j) ? (g(X), be(X, j)) : T(X, j) ? (g(X), f(j, 11, ve(X))) : I(X, j) ? (g(X), jt === "{" ? Xe(X, j) || $e : f(j, 10, Se(X))) : (he === 7 && h(Ht.INVALID_LINKED_FORMAT, a(), 0), j.braceNest = 0, j.inLinked = false, ke(X, j));
      }
    }
    function ke(X, j) {
      let he = {
        type: 13
      };
      if (j.braceNest > 0) return Xe(X, j) || d(j);
      if (j.inLinked) return be(X, j) || d(j);
      switch (X.currentChar()) {
        case "{":
          return Xe(X, j) || d(j);
        case "}":
          return h(Ht.UNBALANCED_CLOSING_BRACE, a(), 0), X.next(), f(j, 3, "}");
        case "@":
          return be(X, j) || d(j);
        default: {
          if (M(X)) return he = f(j, 1, Qe(X)), j.braceNest = 0, j.inLinked = false, he;
          if (k(X)) return f(j, 0, Y(X));
          break;
        }
      }
      return he;
    }
    function Vt() {
      const { currentType: X, offset: j, startLoc: he, endLoc: $e } = l;
      return l.lastType = X, l.lastOffset = j, l.lastStartLoc = he, l.lastEndLoc = $e, l.offset = i(), l.startLoc = a(), n.currentChar() === Vo ? f(l, 13) : ke(n, l);
    }
    return {
      nextToken: Vt,
      currentOffset: i,
      currentPosition: a,
      context: u
    };
  }
  const aTe = "parser", oTe = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function sTe(t, e, r) {
    switch (t) {
      case "\\\\":
        return "\\";
      case "\\'":
        return "'";
      default: {
        const n = parseInt(e || r, 16);
        return n <= 55295 || n >= 57344 ? String.fromCodePoint(n) : "\uFFFD";
      }
    }
  }
  function lTe(t = {}) {
    const e = t.location !== false, { onError: r } = t;
    function n(m, y, _, b, ...w) {
      const x = m.currentPosition();
      if (x.offset += b, x.column += b, r) {
        const T = e ? CS(_, x) : null, A = Ay(y, T, {
          domain: aTe,
          args: w
        });
        r(A);
      }
    }
    function i(m, y, _) {
      const b = {
        type: m
      };
      return e && (b.start = y, b.end = y, b.loc = {
        start: _,
        end: _
      }), b;
    }
    function a(m, y, _, b) {
      e && (m.end = y, m.loc && (m.loc.end = _));
    }
    function o(m, y) {
      const _ = m.context(), b = i(3, _.offset, _.startLoc);
      return b.value = y, a(b, m.currentOffset(), m.currentPosition()), b;
    }
    function s(m, y) {
      const _ = m.context(), { lastOffset: b, lastStartLoc: w } = _, x = i(5, b, w);
      return x.index = parseInt(y, 10), m.nextToken(), a(x, m.currentOffset(), m.currentPosition()), x;
    }
    function l(m, y) {
      const _ = m.context(), { lastOffset: b, lastStartLoc: w } = _, x = i(4, b, w);
      return x.key = y, m.nextToken(), a(x, m.currentOffset(), m.currentPosition()), x;
    }
    function u(m, y) {
      const _ = m.context(), { lastOffset: b, lastStartLoc: w } = _, x = i(9, b, w);
      return x.value = y.replace(oTe, sTe), m.nextToken(), a(x, m.currentOffset(), m.currentPosition()), x;
    }
    function c(m) {
      const y = m.nextToken(), _ = m.context(), { lastOffset: b, lastStartLoc: w } = _, x = i(8, b, w);
      return y.type !== 11 ? (n(m, Ht.UNEXPECTED_EMPTY_LINKED_MODIFIER, _.lastStartLoc, 0), x.value = "", a(x, b, w), {
        nextConsumeToken: y,
        node: x
      }) : (y.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, fa(y)), x.value = y.value || "", a(x, m.currentOffset(), m.currentPosition()), {
        node: x
      });
    }
    function h(m, y) {
      const _ = m.context(), b = i(7, _.offset, _.startLoc);
      return b.value = y, a(b, m.currentOffset(), m.currentPosition()), b;
    }
    function f(m) {
      const y = m.context(), _ = i(6, y.offset, y.startLoc);
      let b = m.nextToken();
      if (b.type === 8) {
        const w = c(m);
        _.modifier = w.node, b = w.nextConsumeToken || m.nextToken();
      }
      switch (b.type !== 9 && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(b)), b = m.nextToken(), b.type === 2 && (b = m.nextToken()), b.type) {
        case 10:
          b.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(b)), _.key = h(m, b.value || "");
          break;
        case 4:
          b.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(b)), _.key = l(m, b.value || "");
          break;
        case 5:
          b.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(b)), _.key = s(m, b.value || "");
          break;
        case 6:
          b.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(b)), _.key = u(m, b.value || "");
          break;
        default: {
          n(m, Ht.UNEXPECTED_EMPTY_LINKED_KEY, y.lastStartLoc, 0);
          const w = m.context(), x = i(7, w.offset, w.startLoc);
          return x.value = "", a(x, w.offset, w.startLoc), _.key = x, a(_, w.offset, w.startLoc), {
            nextConsumeToken: b,
            node: _
          };
        }
      }
      return a(_, m.currentOffset(), m.currentPosition()), {
        node: _
      };
    }
    function d(m) {
      const y = m.context(), _ = y.currentType === 1 ? m.currentOffset() : y.offset, b = y.currentType === 1 ? y.endLoc : y.startLoc, w = i(2, _, b);
      w.items = [];
      let x = null;
      do {
        const I = x || m.nextToken();
        switch (x = null, I.type) {
          case 0:
            I.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(I)), w.items.push(o(m, I.value || ""));
            break;
          case 5:
            I.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(I)), w.items.push(s(m, I.value || ""));
            break;
          case 4:
            I.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(I)), w.items.push(l(m, I.value || ""));
            break;
          case 6:
            I.value == null && n(m, Ht.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, fa(I)), w.items.push(u(m, I.value || ""));
            break;
          case 7: {
            const M = f(m);
            w.items.push(M.node), x = M.nextConsumeToken || null;
            break;
          }
        }
      } while (y.currentType !== 13 && y.currentType !== 1);
      const T = y.currentType === 1 ? y.lastOffset : m.currentOffset(), A = y.currentType === 1 ? y.lastEndLoc : m.currentPosition();
      return a(w, T, A), w;
    }
    function p(m, y, _, b) {
      const w = m.context();
      let x = b.items.length === 0;
      const T = i(1, y, _);
      T.cases = [], T.cases.push(b);
      do {
        const A = d(m);
        x || (x = A.items.length === 0), T.cases.push(A);
      } while (w.currentType !== 13);
      return x && n(m, Ht.MUST_HAVE_MESSAGES_IN_PLURAL, _, 0), a(T, m.currentOffset(), m.currentPosition()), T;
    }
    function v(m) {
      const y = m.context(), { offset: _, startLoc: b } = y, w = d(m);
      return y.currentType === 13 ? w : p(m, _, b, w);
    }
    function g(m) {
      const y = iTe(m, Pr({}, t)), _ = y.context(), b = i(0, _.offset, _.startLoc);
      return e && b.loc && (b.loc.source = m), b.body = v(y), t.onCacheKey && (b.cacheKey = t.onCacheKey(m)), _.currentType !== 13 && n(y, Ht.UNEXPECTED_LEXICAL_ANALYSIS, _.lastStartLoc, 0, m[_.offset] || ""), a(b, y.currentOffset(), y.currentPosition()), b;
    }
    return {
      parse: g
    };
  }
  function fa(t) {
    if (t.type === 13) return "EOF";
    const e = (t.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "\u2026" : e;
  }
  function uTe(t, e = {}) {
    const r = {
      ast: t,
      helpers: /* @__PURE__ */ new Set()
    };
    return {
      context: () => r,
      helper: (a) => (r.helpers.add(a), a)
    };
  }
  function Cz(t, e) {
    for (let r = 0; r < t.length; r++) QC(t[r], e);
  }
  function QC(t, e) {
    switch (t.type) {
      case 1:
        Cz(t.cases, e), e.helper("plural");
        break;
      case 2:
        Cz(t.items, e);
        break;
      case 6: {
        QC(t.key, e), e.helper("linked"), e.helper("type");
        break;
      }
      case 5:
        e.helper("interpolate"), e.helper("list");
        break;
      case 4:
        e.helper("interpolate"), e.helper("named");
        break;
    }
  }
  function cTe(t, e = {}) {
    const r = uTe(t);
    r.helper("normalize"), t.body && QC(t.body, r);
    const n = r.context();
    t.helpers = Array.from(n.helpers);
  }
  function hTe(t) {
    const e = t.body;
    return e.type === 2 ? Az(e) : e.cases.forEach((r) => Az(r)), t;
  }
  function Az(t) {
    if (t.items.length === 1) {
      const e = t.items[0];
      (e.type === 3 || e.type === 9) && (t.static = e.value, delete e.value);
    } else {
      const e = [];
      for (let r = 0; r < t.items.length; r++) {
        const n = t.items[r];
        if (!(n.type === 3 || n.type === 9) || n.value == null) break;
        e.push(n.value);
      }
      if (e.length === t.items.length) {
        t.static = ZC(e);
        for (let r = 0; r < t.items.length; r++) {
          const n = t.items[r];
          (n.type === 3 || n.type === 9) && delete n.value;
        }
      }
    }
  }
  function tc(t) {
    switch (t.t = t.type, t.type) {
      case 0: {
        const e = t;
        tc(e.body), e.b = e.body, delete e.body;
        break;
      }
      case 1: {
        const e = t, r = e.cases;
        for (let n = 0; n < r.length; n++) tc(r[n]);
        e.c = r, delete e.cases;
        break;
      }
      case 2: {
        const e = t, r = e.items;
        for (let n = 0; n < r.length; n++) tc(r[n]);
        e.i = r, delete e.items, e.static && (e.s = e.static, delete e.static);
        break;
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const e = t;
        e.value && (e.v = e.value, delete e.value);
        break;
      }
      case 6: {
        const e = t;
        tc(e.key), e.k = e.key, delete e.key, e.modifier && (tc(e.modifier), e.m = e.modifier, delete e.modifier);
        break;
      }
      case 5: {
        const e = t;
        e.i = e.index, delete e.index;
        break;
      }
      case 4: {
        const e = t;
        e.k = e.key, delete e.key;
        break;
      }
    }
    delete t.type;
  }
  function fTe(t, e) {
    const { filename: r, breakLineCode: n, needIndent: i } = e, a = e.location !== false, o = {
      filename: r,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: n,
      needIndent: i,
      indentLevel: 0
    };
    a && t.loc && (o.source = t.loc.source);
    const s = () => o;
    function l(v, g) {
      o.code += v;
    }
    function u(v, g = true) {
      const m = g ? n : "";
      l(i ? m + "  ".repeat(v) : m);
    }
    function c(v = true) {
      const g = ++o.indentLevel;
      v && u(g);
    }
    function h(v = true) {
      const g = --o.indentLevel;
      v && u(g);
    }
    function f() {
      u(o.indentLevel);
    }
    return {
      context: s,
      push: l,
      indent: c,
      deindent: h,
      newline: f,
      helper: (v) => `_${v}`,
      needIndent: () => o.needIndent
    };
  }
  function dTe(t, e) {
    const { helper: r } = t;
    t.push(`${r("linked")}(`), $c(t, e.key), e.modifier ? (t.push(", "), $c(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")");
  }
  function pTe(t, e) {
    const { helper: r, needIndent: n } = t;
    t.push(`${r("normalize")}([`), t.indent(n());
    const i = e.items.length;
    for (let a = 0; a < i && ($c(t, e.items[a]), a !== i - 1); a++) t.push(", ");
    t.deindent(n()), t.push("])");
  }
  function vTe(t, e) {
    const { helper: r, needIndent: n } = t;
    if (e.cases.length > 1) {
      t.push(`${r("plural")}([`), t.indent(n());
      const i = e.cases.length;
      for (let a = 0; a < i && ($c(t, e.cases[a]), a !== i - 1); a++) t.push(", ");
      t.deindent(n()), t.push("])");
    }
  }
  function gTe(t, e) {
    e.body ? $c(t, e.body) : t.push("null");
  }
  function $c(t, e) {
    const { helper: r } = t;
    switch (e.type) {
      case 0:
        gTe(t, e);
        break;
      case 1:
        vTe(t, e);
        break;
      case 2:
        pTe(t, e);
        break;
      case 6:
        dTe(t, e);
        break;
      case 8:
        t.push(JSON.stringify(e.value), e);
        break;
      case 7:
        t.push(JSON.stringify(e.value), e);
        break;
      case 5:
        t.push(`${r("interpolate")}(${r("list")}(${e.index}))`, e);
        break;
      case 4:
        t.push(`${r("interpolate")}(${r("named")}(${JSON.stringify(e.key)}))`, e);
        break;
      case 9:
        t.push(JSON.stringify(e.value), e);
        break;
      case 3:
        t.push(JSON.stringify(e.value), e);
        break;
    }
  }
  const mTe = (t, e = {}) => {
    const r = Pe(e.mode) ? e.mode : "normal", n = Pe(e.filename) ? e.filename : "message.intl";
    e.sourceMap;
    const i = e.breakLineCode != null ? e.breakLineCode : r === "arrow" ? ";" : `
`, a = e.needIndent ? e.needIndent : r !== "arrow", o = t.helpers || [], s = fTe(t, {
      filename: n,
      breakLineCode: i,
      needIndent: a
    });
    s.push(r === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), s.indent(a), o.length > 0 && (s.push(`const { ${ZC(o.map((c) => `${c}: _${c}`), ", ")} } = ctx`), s.newline()), s.push("return "), $c(s, t), s.deindent(a), s.push("}"), delete t.helpers;
    const { code: l, map: u } = s.context();
    return {
      ast: t,
      code: l,
      map: u ? u.toJSON() : void 0
    };
  };
  function yTe(t, e = {}) {
    const r = Pr({}, e), n = !!r.jit, i = !!r.minify, a = r.optimize == null ? true : r.optimize, s = lTe(r).parse(t);
    return n ? (a && hTe(s), i && tc(s), {
      ast: s,
      code: ""
    }) : (cTe(s, r), mTe(s, r));
  }
  function _Te() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Pl().__INTLIFY_PROD_DEVTOOLS__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Pl().__INTLIFY_DROP_MESSAGE_COMPILER__ = false);
  }
  function F1(t) {
    return (r) => bTe(r, t);
  }
  function bTe(t, e) {
    const r = wTe(e);
    if (r == null) throw Sd(0);
    if (JC(r) === 1) {
      const a = TTe(r);
      return t.plural(a.reduce((o, s) => [
        ...o,
        Iz(t, s)
      ], []));
    } else return Iz(t, r);
  }
  const xTe = [
    "b",
    "body"
  ];
  function wTe(t) {
    return Ts(t, xTe);
  }
  const STe = [
    "c",
    "cases"
  ];
  function TTe(t) {
    return Ts(t, STe, []);
  }
  function Iz(t, e) {
    const r = ATe(e);
    if (r != null) return t.type === "text" ? r : t.normalize([
      r
    ]);
    {
      const n = MTe(e).reduce((i, a) => [
        ...i,
        AS(t, a)
      ], []);
      return t.normalize(n);
    }
  }
  const CTe = [
    "s",
    "static"
  ];
  function ATe(t) {
    return Ts(t, CTe);
  }
  const ITe = [
    "i",
    "items"
  ];
  function MTe(t) {
    return Ts(t, ITe, []);
  }
  function AS(t, e) {
    const r = JC(e);
    switch (r) {
      case 3:
        return Gv(e, r);
      case 9:
        return Gv(e, r);
      case 4: {
        const n = e;
        if (Wi(n, "k") && n.k) return t.interpolate(t.named(n.k));
        if (Wi(n, "key") && n.key) return t.interpolate(t.named(n.key));
        throw Sd(r);
      }
      case 5: {
        const n = e;
        if (Wi(n, "i") && br(n.i)) return t.interpolate(t.list(n.i));
        if (Wi(n, "index") && br(n.index)) return t.interpolate(t.list(n.index));
        throw Sd(r);
      }
      case 6: {
        const n = e, i = PTe(n), a = $Te(n);
        return t.linked(AS(t, a), i ? AS(t, i) : void 0, t.type);
      }
      case 7:
        return Gv(e, r);
      case 8:
        return Gv(e, r);
      default:
        throw new Error(`unhandled node on format message part: ${r}`);
    }
  }
  const DTe = [
    "t",
    "type"
  ];
  function JC(t) {
    return Ts(t, DTe);
  }
  const ETe = [
    "v",
    "value"
  ];
  function Gv(t, e) {
    const r = Ts(t, ETe);
    if (r) return r;
    throw Sd(e);
  }
  const kTe = [
    "m",
    "modifier"
  ];
  function PTe(t) {
    return Ts(t, kTe);
  }
  const LTe = [
    "k",
    "key"
  ];
  function $Te(t) {
    const e = Ts(t, LTe);
    if (e) return e;
    throw Sd(6);
  }
  function Ts(t, e, r) {
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (Wi(t, i) && t[i] != null) return t[i];
    }
    return r;
  }
  function Sd(t) {
    return new Error(`unhandled node type: ${t}`);
  }
  const RTe = (t) => t;
  let Wv = Zt();
  function Rc(t) {
    return zt(t) && JC(t) === 0 && (Wi(t, "b") || Wi(t, "body"));
  }
  function OTe(t, e = {}) {
    let r = false;
    const n = e.onError || ZSe;
    return e.onError = (i) => {
      r = true, n(i);
    }, {
      ...yTe(t, e),
      detectError: r
    };
  }
  function NTe(t, e) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && Pe(t)) {
      Rt(e.warnHtmlMessage) && e.warnHtmlMessage;
      const n = (e.onCacheKey || RTe)(t), i = Wv[n];
      if (i) return i;
      const { ast: a, detectError: o } = OTe(t, {
        ...e,
        location: false,
        jit: true
      }), s = F1(a);
      return o ? s : Wv[n] = s;
    } else {
      const r = t.cacheKey;
      if (r) {
        const n = Wv[r];
        return n || (Wv[r] = F1(t));
      } else return F1(t);
    }
  }
  let Td = null;
  function BTe(t) {
    Td = t;
  }
  function zTe(t, e, r) {
    Td && Td.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: t,
      version: e,
      meta: r
    });
  }
  const FTe = VTe("function:translate");
  function VTe(t) {
    return (e) => Td && Td.emit(t, e);
  }
  const eo = {
    INVALID_ARGUMENT: KSe,
    INVALID_DATE_ARGUMENT: 18,
    INVALID_ISO_DATE_ARGUMENT: 19,
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
    NOT_SUPPORT_LOCALE_TYPE: 23
  }, GTe = 24;
  function to(t) {
    return Ay(t, null, void 0);
  }
  function eA(t, e) {
    return e.locale != null ? Mz(e.locale) : Mz(t.locale);
  }
  let V1;
  function Mz(t) {
    if (Pe(t)) return t;
    if (nr(t)) {
      if (t.resolvedOnce && V1 != null) return V1;
      if (t.constructor.name === "Function") {
        const e = t();
        if (YSe(e)) throw to(eo.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        return V1 = e;
      } else throw to(eo.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
    } else throw to(eo.NOT_SUPPORT_LOCALE_TYPE);
  }
  function WTe(t, e, r) {
    return [
      .../* @__PURE__ */ new Set([
        r,
        ...Sr(e) ? e : zt(e) ? Object.keys(e) : Pe(e) ? [
          e
        ] : [
          r
        ]
      ])
    ];
  }
  function Gq(t, e, r) {
    const n = Pe(r) ? r : Cd, i = t;
    i.__localeChainCache || (i.__localeChainCache = /* @__PURE__ */ new Map());
    let a = i.__localeChainCache.get(n);
    if (!a) {
      a = [];
      let o = [
        r
      ];
      for (; Sr(o); ) o = Dz(a, o, e);
      const s = Sr(e) || !Ct(e) ? e : e.default ? e.default : null;
      o = Pe(s) ? [
        s
      ] : s, Sr(o) && Dz(a, o, false), i.__localeChainCache.set(n, a);
    }
    return a;
  }
  function Dz(t, e, r) {
    let n = true;
    for (let i = 0; i < e.length && Rt(n); i++) {
      const a = e[i];
      Pe(a) && (n = HTe(t, e[i], r));
    }
    return n;
  }
  function HTe(t, e, r) {
    let n;
    const i = e.split("-");
    do {
      const a = i.join("-");
      n = UTe(t, a, r), i.splice(-1, 1);
    } while (i.length && n === true);
    return n;
  }
  function UTe(t, e, r) {
    let n = false;
    if (!t.includes(e) && (n = true, e)) {
      n = e[e.length - 1] !== "!";
      const i = e.replace(/!/g, "");
      t.push(i), (Sr(r) || Ct(r)) && r[i] && (n = r[i]);
    }
    return n;
  }
  const Cs = [];
  Cs[0] = {
    w: [
      0
    ],
    i: [
      3,
      0
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  Cs[1] = {
    w: [
      1
    ],
    ".": [
      2
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  Cs[2] = {
    w: [
      2
    ],
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ]
  };
  Cs[3] = {
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ],
    w: [
      1,
      1
    ],
    ".": [
      2,
      1
    ],
    "[": [
      4,
      1
    ],
    o: [
      7,
      1
    ]
  };
  Cs[4] = {
    "'": [
      5,
      0
    ],
    '"': [
      6,
      0
    ],
    "[": [
      4,
      2
    ],
    "]": [
      1,
      3
    ],
    o: 8,
    l: [
      4,
      0
    ]
  };
  Cs[5] = {
    "'": [
      4,
      0
    ],
    o: 8,
    l: [
      5,
      0
    ]
  };
  Cs[6] = {
    '"': [
      4,
      0
    ],
    o: 8,
    l: [
      6,
      0
    ]
  };
  const YTe = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function qTe(t) {
    return YTe.test(t);
  }
  function XTe(t) {
    const e = t.charCodeAt(0), r = t.charCodeAt(t.length - 1);
    return e === r && (e === 34 || e === 39) ? t.slice(1, -1) : t;
  }
  function jTe(t) {
    if (t == null) return "o";
    switch (t.charCodeAt(0)) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return t;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function KTe(t) {
    const e = t.trim();
    return t.charAt(0) === "0" && isNaN(parseInt(t)) ? false : qTe(e) ? XTe(e) : "*" + e;
  }
  function ZTe(t) {
    const e = [];
    let r = -1, n = 0, i = 0, a, o, s, l, u, c, h;
    const f = [];
    f[0] = () => {
      o === void 0 ? o = s : o += s;
    }, f[1] = () => {
      o !== void 0 && (e.push(o), o = void 0);
    }, f[2] = () => {
      f[0](), i++;
    }, f[3] = () => {
      if (i > 0) i--, n = 4, f[0]();
      else {
        if (i = 0, o === void 0 || (o = KTe(o), o === false)) return false;
        f[1]();
      }
    };
    function d() {
      const p = t[r + 1];
      if (n === 5 && p === "'" || n === 6 && p === '"') return r++, s = "\\" + p, f[0](), true;
    }
    for (; n !== null; ) if (r++, a = t[r], !(a === "\\" && d())) {
      if (l = jTe(a), h = Cs[n], u = h[l] || h.l || 8, u === 8 || (n = u[0], u[1] !== void 0 && (c = f[u[1]], c && (s = a, c() === false)))) return;
      if (n === 7) return e;
    }
  }
  const Ez = /* @__PURE__ */ new Map();
  function QTe(t, e) {
    return zt(t) ? t[e] : null;
  }
  function JTe(t, e) {
    if (!zt(t)) return null;
    let r = Ez.get(e);
    if (r || (r = ZTe(e), r && Ez.set(e, r)), !r) return null;
    const n = r.length;
    let i = t, a = 0;
    for (; a < n; ) {
      const o = i[r[a]];
      if (o === void 0 || nr(i)) return null;
      i = o, a++;
    }
    return i;
  }
  const e2e = "11.1.2", Iy = -1, Cd = "en-US", kz = "", Pz = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
  function t2e() {
    return {
      upper: (t, e) => e === "text" && Pe(t) ? t.toUpperCase() : e === "vnode" && zt(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
      lower: (t, e) => e === "text" && Pe(t) ? t.toLowerCase() : e === "vnode" && zt(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
      capitalize: (t, e) => e === "text" && Pe(t) ? Pz(t) : e === "vnode" && zt(t) && "__v_isVNode" in t ? Pz(t.children) : t
    };
  }
  let Wq;
  function r2e(t) {
    Wq = t;
  }
  let Hq;
  function n2e(t) {
    Hq = t;
  }
  let Uq;
  function i2e(t) {
    Uq = t;
  }
  let Yq = null;
  const a2e = (t) => {
    Yq = t;
  }, o2e = () => Yq;
  let qq = null;
  const Lz = (t) => {
    qq = t;
  }, s2e = () => qq;
  let $z = 0;
  function l2e(t = {}) {
    const e = nr(t.onWarn) ? t.onWarn : XSe, r = Pe(t.version) ? t.version : e2e, n = Pe(t.locale) || nr(t.locale) ? t.locale : Cd, i = nr(n) ? Cd : n, a = Sr(t.fallbackLocale) || Ct(t.fallbackLocale) || Pe(t.fallbackLocale) || t.fallbackLocale === false ? t.fallbackLocale : i, o = Ct(t.messages) ? t.messages : G1(i), s = Ct(t.datetimeFormats) ? t.datetimeFormats : G1(i), l = Ct(t.numberFormats) ? t.numberFormats : G1(i), u = Pr(Zt(), t.modifiers, t2e()), c = t.pluralRules || Zt(), h = nr(t.missing) ? t.missing : null, f = Rt(t.missingWarn) || Lc(t.missingWarn) ? t.missingWarn : true, d = Rt(t.fallbackWarn) || Lc(t.fallbackWarn) ? t.fallbackWarn : true, p = !!t.fallbackFormat, v = !!t.unresolving, g = nr(t.postTranslation) ? t.postTranslation : null, m = Ct(t.processor) ? t.processor : null, y = Rt(t.warnHtmlMessage) ? t.warnHtmlMessage : true, _ = !!t.escapeParameter, b = nr(t.messageCompiler) ? t.messageCompiler : Wq, w = nr(t.messageResolver) ? t.messageResolver : Hq || QTe, x = nr(t.localeFallbacker) ? t.localeFallbacker : Uq || WTe, T = zt(t.fallbackContext) ? t.fallbackContext : void 0, A = t, I = zt(A.__datetimeFormatters) ? A.__datetimeFormatters : /* @__PURE__ */ new Map(), M = zt(A.__numberFormatters) ? A.__numberFormatters : /* @__PURE__ */ new Map(), k = zt(A.__meta) ? A.__meta : {};
    $z++;
    const B = {
      version: r,
      cid: $z,
      locale: n,
      fallbackLocale: a,
      messages: o,
      modifiers: u,
      pluralRules: c,
      missing: h,
      missingWarn: f,
      fallbackWarn: d,
      fallbackFormat: p,
      unresolving: v,
      postTranslation: g,
      processor: m,
      warnHtmlMessage: y,
      escapeParameter: _,
      messageCompiler: b,
      messageResolver: w,
      localeFallbacker: x,
      fallbackContext: T,
      onWarn: e,
      __meta: k
    };
    return B.datetimeFormats = s, B.numberFormats = l, B.__datetimeFormatters = I, B.__numberFormatters = M, __INTLIFY_PROD_DEVTOOLS__ && zTe(B, r, k), B;
  }
  const G1 = (t) => ({
    [t]: Zt()
  });
  function tA(t, e, r, n, i) {
    const { missing: a, onWarn: o } = t;
    if (a !== null) {
      const s = a(t, r, e, i);
      return Pe(s) ? s : e;
    } else return e;
  }
  function qh(t, e, r) {
    const n = t;
    n.__localeChainCache = /* @__PURE__ */ new Map(), t.localeFallbacker(t, r, e);
  }
  function u2e(t, e) {
    return t === e ? false : t.split("-")[0] === e.split("-")[0];
  }
  function c2e(t, e) {
    const r = e.indexOf(t);
    if (r === -1) return false;
    for (let n = r + 1; n < e.length; n++) if (u2e(t, e[n])) return true;
    return false;
  }
  function Rz(t, ...e) {
    const { datetimeFormats: r, unresolving: n, fallbackLocale: i, onWarn: a, localeFallbacker: o } = t, { __datetimeFormatters: s } = t, [l, u, c, h] = IS(...e), f = Rt(c.missingWarn) ? c.missingWarn : t.missingWarn;
    Rt(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn;
    const d = !!c.part, p = eA(t, c), v = o(t, i, p);
    if (!Pe(l) || l === "") return new Intl.DateTimeFormat(p, h).format(u);
    let g = {}, m, y = null;
    const _ = "datetime format";
    for (let x = 0; x < v.length && (m = v[x], g = r[m] || {}, y = g[l], !Ct(y)); x++) tA(t, l, m, f, _);
    if (!Ct(y) || !Pe(m)) return n ? Iy : l;
    let b = `${m}__${l}`;
    Cy(h) || (b = `${b}__${JSON.stringify(h)}`);
    let w = s.get(b);
    return w || (w = new Intl.DateTimeFormat(m, Pr({}, y, h)), s.set(b, w)), d ? w.formatToParts(u) : w.format(u);
  }
  const Xq = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function IS(...t) {
    const [e, r, n, i] = t, a = Zt();
    let o = Zt(), s;
    if (Pe(e)) {
      const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!l) throw to(eo.INVALID_ISO_DATE_ARGUMENT);
      const u = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
      s = new Date(u);
      try {
        s.toISOString();
      } catch {
        throw to(eo.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (WSe(e)) {
      if (isNaN(e.getTime())) throw to(eo.INVALID_DATE_ARGUMENT);
      s = e;
    } else if (br(e)) s = e;
    else throw to(eo.INVALID_ARGUMENT);
    return Pe(r) ? a.key = r : Ct(r) && Object.keys(r).forEach((l) => {
      Xq.includes(l) ? o[l] = r[l] : a[l] = r[l];
    }), Pe(n) ? a.locale = n : Ct(n) && (o = n), Ct(i) && (o = i), [
      a.key || "",
      s,
      a,
      o
    ];
  }
  function Oz(t, e, r) {
    const n = t;
    for (const i in r) {
      const a = `${e}__${i}`;
      n.__datetimeFormatters.has(a) && n.__datetimeFormatters.delete(a);
    }
  }
  function Nz(t, ...e) {
    const { numberFormats: r, unresolving: n, fallbackLocale: i, onWarn: a, localeFallbacker: o } = t, { __numberFormatters: s } = t, [l, u, c, h] = MS(...e), f = Rt(c.missingWarn) ? c.missingWarn : t.missingWarn;
    Rt(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn;
    const d = !!c.part, p = eA(t, c), v = o(t, i, p);
    if (!Pe(l) || l === "") return new Intl.NumberFormat(p, h).format(u);
    let g = {}, m, y = null;
    const _ = "number format";
    for (let x = 0; x < v.length && (m = v[x], g = r[m] || {}, y = g[l], !Ct(y)); x++) tA(t, l, m, f, _);
    if (!Ct(y) || !Pe(m)) return n ? Iy : l;
    let b = `${m}__${l}`;
    Cy(h) || (b = `${b}__${JSON.stringify(h)}`);
    let w = s.get(b);
    return w || (w = new Intl.NumberFormat(m, Pr({}, y, h)), s.set(b, w)), d ? w.formatToParts(u) : w.format(u);
  }
  const jq = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function MS(...t) {
    const [e, r, n, i] = t, a = Zt();
    let o = Zt();
    if (!br(e)) throw to(eo.INVALID_ARGUMENT);
    const s = e;
    return Pe(r) ? a.key = r : Ct(r) && Object.keys(r).forEach((l) => {
      jq.includes(l) ? o[l] = r[l] : a[l] = r[l];
    }), Pe(n) ? a.locale = n : Ct(n) && (o = n), Ct(i) && (o = i), [
      a.key || "",
      s,
      a,
      o
    ];
  }
  function Bz(t, e, r) {
    const n = t;
    for (const i in r) {
      const a = `${e}__${i}`;
      n.__numberFormatters.has(a) && n.__numberFormatters.delete(a);
    }
  }
  const h2e = (t) => t, f2e = (t) => "", d2e = "text", p2e = (t) => t.length === 0 ? "" : ZC(t), v2e = qSe;
  function zz(t, e) {
    return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0;
  }
  function g2e(t) {
    const e = br(t.pluralIndex) ? t.pluralIndex : -1;
    return t.named && (br(t.named.count) || br(t.named.n)) ? br(t.named.count) ? t.named.count : br(t.named.n) ? t.named.n : e : e;
  }
  function m2e(t, e) {
    e.count || (e.count = t), e.n || (e.n = t);
  }
  function y2e(t = {}) {
    const e = t.locale, r = g2e(t), n = zt(t.pluralRules) && Pe(e) && nr(t.pluralRules[e]) ? t.pluralRules[e] : zz, i = zt(t.pluralRules) && Pe(e) && nr(t.pluralRules[e]) ? zz : void 0, a = (m) => m[n(r, m.length, i)], o = t.list || [], s = (m) => o[m], l = t.named || Zt();
    br(t.pluralIndex) && m2e(r, l);
    const u = (m) => l[m];
    function c(m, y) {
      const _ = nr(t.messages) ? t.messages(m, !!y) : zt(t.messages) ? t.messages[m] : false;
      return _ || (t.parent ? t.parent.message(m) : f2e);
    }
    const h = (m) => t.modifiers ? t.modifiers[m] : h2e, f = Ct(t.processor) && nr(t.processor.normalize) ? t.processor.normalize : p2e, d = Ct(t.processor) && nr(t.processor.interpolate) ? t.processor.interpolate : v2e, p = Ct(t.processor) && Pe(t.processor.type) ? t.processor.type : d2e, g = {
      list: s,
      named: u,
      plural: a,
      linked: (m, ...y) => {
        const [_, b] = y;
        let w = "text", x = "";
        y.length === 1 ? zt(_) ? (x = _.modifier || x, w = _.type || w) : Pe(_) && (x = _ || x) : y.length === 2 && (Pe(_) && (x = _ || x), Pe(b) && (w = b || w));
        const T = c(m, true)(g), A = w === "vnode" && Sr(T) && x ? T[0] : T;
        return x ? h(x)(A, w) : A;
      },
      message: c,
      type: p,
      interpolate: d,
      normalize: f,
      values: Pr(Zt(), o, l)
    };
    return g;
  }
  const Fz = () => "", pi = (t) => nr(t);
  function Vz(t, ...e) {
    const { fallbackFormat: r, postTranslation: n, unresolving: i, messageCompiler: a, fallbackLocale: o, messages: s } = t, [l, u] = DS(...e), c = Rt(u.missingWarn) ? u.missingWarn : t.missingWarn, h = Rt(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, f = Rt(u.escapeParameter) ? u.escapeParameter : t.escapeParameter, d = !!u.resolvedMessage, p = Pe(u.default) || Rt(u.default) ? Rt(u.default) ? a ? l : () => l : u.default : r ? a ? l : () => l : null, v = r || p != null && (Pe(p) || nr(p)), g = eA(t, u);
    f && _2e(u);
    let [m, y, _] = d ? [
      l,
      g,
      s[g] || Zt()
    ] : Kq(t, l, g, o, h, c), b = m, w = l;
    if (!d && !(Pe(b) || Rc(b) || pi(b)) && v && (b = p, w = b), !d && (!(Pe(b) || Rc(b) || pi(b)) || !Pe(y))) return i ? Iy : l;
    let x = false;
    const T = () => {
      x = true;
    }, A = pi(b) ? b : Zq(t, l, y, b, w, T);
    if (x) return b;
    const I = w2e(t, y, _, u), M = y2e(I), k = b2e(t, A, M), B = n ? n(k, l) : k;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const L = {
        timestamp: Date.now(),
        key: Pe(l) ? l : pi(b) ? b.key : "",
        locale: y || (pi(b) ? b.locale : ""),
        format: Pe(b) ? b : pi(b) ? b.source : "",
        message: B
      };
      L.meta = Pr({}, t.__meta, o2e() || {}), FTe(L);
    }
    return B;
  }
  function _2e(t) {
    Sr(t.list) ? t.list = t.list.map((e) => Pe(e) ? Sz(e) : e) : zt(t.named) && Object.keys(t.named).forEach((e) => {
      Pe(t.named[e]) && (t.named[e] = Sz(t.named[e]));
    });
  }
  function Kq(t, e, r, n, i, a) {
    const { messages: o, onWarn: s, messageResolver: l, localeFallbacker: u } = t, c = u(t, n, r);
    let h = Zt(), f, d = null;
    const p = "translate";
    for (let v = 0; v < c.length && (f = c[v], h = o[f] || Zt(), (d = l(h, e)) === null && (d = h[e]), !(Pe(d) || Rc(d) || pi(d))); v++) if (!c2e(f, c)) {
      const g = tA(t, e, f, a, p);
      g !== e && (d = g);
    }
    return [
      d,
      f,
      h
    ];
  }
  function Zq(t, e, r, n, i, a) {
    const { messageCompiler: o, warnHtmlMessage: s } = t;
    if (pi(n)) {
      const u = n;
      return u.locale = u.locale || r, u.key = u.key || e, u;
    }
    if (o == null) {
      const u = () => n;
      return u.locale = r, u.key = e, u;
    }
    const l = o(n, x2e(t, r, i, n, s, a));
    return l.locale = r, l.key = e, l.source = n, l;
  }
  function b2e(t, e, r) {
    return e(r);
  }
  function DS(...t) {
    const [e, r, n] = t, i = Zt();
    if (!Pe(e) && !br(e) && !pi(e) && !Rc(e)) throw to(eo.INVALID_ARGUMENT);
    const a = br(e) ? String(e) : (pi(e), e);
    return br(r) ? i.plural = r : Pe(r) ? i.default = r : Ct(r) && !Cy(r) ? i.named = r : Sr(r) && (i.list = r), br(n) ? i.plural = n : Pe(n) ? i.default = n : Ct(n) && Pr(i, n), [
      a,
      i
    ];
  }
  function x2e(t, e, r, n, i, a) {
    return {
      locale: e,
      key: r,
      warnHtmlMessage: i,
      onError: (o) => {
        throw a && a(o), o;
      },
      onCacheKey: (o) => VSe(e, r, o)
    };
  }
  function w2e(t, e, r, n) {
    const { modifiers: i, pluralRules: a, messageResolver: o, fallbackLocale: s, fallbackWarn: l, missingWarn: u, fallbackContext: c } = t, f = {
      locale: e,
      modifiers: i,
      pluralRules: a,
      messages: (d, p) => {
        let v = o(r, d);
        if (v == null && (c || p)) {
          const [, , g] = Kq(c || t, d, e, s, l, u);
          v = o(g, d);
        }
        if (Pe(v) || Rc(v)) {
          let g = false;
          const y = Zq(t, d, e, v, d, () => {
            g = true;
          });
          return g ? Fz : y;
        } else return pi(v) ? v : Fz;
      }
    };
    return t.processor && (f.processor = t.processor), n.list && (f.list = n.list), n.named && (f.named = n.named), br(n.plural) && (f.pluralIndex = n.plural), f;
  }
  _Te();
  const S2e = "11.1.2";
  function T2e() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Pl().__VUE_I18N_FULL_INSTALL__ = true), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Pl().__VUE_I18N_LEGACY_API__ = true), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Pl().__INTLIFY_DROP_MESSAGE_COMPILER__ = false), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Pl().__INTLIFY_PROD_DEVTOOLS__ = false);
  }
  const Rn = {
    UNEXPECTED_RETURN_TYPE: GTe,
    INVALID_ARGUMENT: 25,
    MUST_BE_CALL_SETUP_TOP: 26,
    NOT_INSTALLED: 27,
    REQUIRED_VALUE: 28,
    INVALID_VALUE: 29,
    NOT_INSTALLED_WITH_PROVIDE: 31,
    UNEXPECTED_ERROR: 32
  };
  function Kn(t, ...e) {
    return Ay(t, null, void 0);
  }
  const ES = Ss("__translateVNode"), kS = Ss("__datetimeParts"), PS = Ss("__numberParts"), Qq = Ss("__setPluralRules"), Jq = Ss("__injectWithOption"), LS = Ss("__dispose");
  function Ad(t) {
    if (!zt(t)) return t;
    for (const e in t) if (Wi(t, e)) if (!e.includes(".")) zt(t[e]) && Ad(t[e]);
    else {
      const r = e.split("."), n = r.length - 1;
      let i = t, a = false;
      for (let o = 0; o < n; o++) {
        if (r[o] === "__proto__") throw new Error(`unsafe key: ${r[o]}`);
        if (r[o] in i || (i[r[o]] = Zt()), !zt(i[r[o]])) {
          a = true;
          break;
        }
        i = i[r[o]];
      }
      a || (i[r[n]] = t[e], delete t[e]), zt(i[r[n]]) && Ad(i[r[n]]);
    }
    return t;
  }
  function rA(t, e) {
    const { messages: r, __i18n: n, messageResolver: i, flatJson: a } = e, o = Ct(r) ? r : Sr(n) ? Zt() : {
      [t]: Zt()
    };
    if (Sr(n) && n.forEach((s) => {
      if ("locale" in s && "resource" in s) {
        const { locale: l, resource: u } = s;
        l ? (o[l] = o[l] || Zt(), xg(u, o[l])) : xg(u, o);
      } else Pe(s) && xg(JSON.parse(s), o);
    }), i == null && a) for (const s in o) Wi(o, s) && Ad(o[s]);
    return o;
  }
  function e7(t) {
    return t.type;
  }
  function t7(t, e, r) {
    let n = zt(e.messages) ? e.messages : Zt();
    "__i18nGlobal" in r && (n = rA(t.locale.value, {
      messages: n,
      __i18n: r.__i18nGlobal
    }));
    const i = Object.keys(n);
    i.length && i.forEach((a) => {
      t.mergeLocaleMessage(a, n[a]);
    });
    {
      if (zt(e.datetimeFormats)) {
        const a = Object.keys(e.datetimeFormats);
        a.length && a.forEach((o) => {
          t.mergeDateTimeFormat(o, e.datetimeFormats[o]);
        });
      }
      if (zt(e.numberFormats)) {
        const a = Object.keys(e.numberFormats);
        a.length && a.forEach((o) => {
          t.mergeNumberFormat(o, e.numberFormats[o]);
        });
      }
    }
  }
  function Gz(t) {
    return at(Hj, null, t, 0);
  }
  const Wz = "__INTLIFY_META__", Hz = () => [], C2e = () => false;
  let Uz = 0;
  function Yz(t) {
    return (e, r, n, i) => t(r, n, jn() || void 0, i);
  }
  const A2e = () => {
    const t = jn();
    let e = null;
    return t && (e = e7(t)[Wz]) ? {
      [Wz]: e
    } : null;
  };
  function nA(t = {}) {
    const { __root: e, __injectWithOption: r } = t, n = e === void 0, i = t.flatJson, a = km ? ot : Wj;
    let o = Rt(t.inheritLocale) ? t.inheritLocale : true;
    const s = a(e && o ? e.locale.value : Pe(t.locale) ? t.locale : Cd), l = a(e && o ? e.fallbackLocale.value : Pe(t.fallbackLocale) || Sr(t.fallbackLocale) || Ct(t.fallbackLocale) || t.fallbackLocale === false ? t.fallbackLocale : s.value), u = a(rA(s.value, t)), c = a(Ct(t.datetimeFormats) ? t.datetimeFormats : {
      [s.value]: {}
    }), h = a(Ct(t.numberFormats) ? t.numberFormats : {
      [s.value]: {}
    });
    let f = e ? e.missingWarn : Rt(t.missingWarn) || Lc(t.missingWarn) ? t.missingWarn : true, d = e ? e.fallbackWarn : Rt(t.fallbackWarn) || Lc(t.fallbackWarn) ? t.fallbackWarn : true, p = e ? e.fallbackRoot : Rt(t.fallbackRoot) ? t.fallbackRoot : true, v = !!t.fallbackFormat, g = nr(t.missing) ? t.missing : null, m = nr(t.missing) ? Yz(t.missing) : null, y = nr(t.postTranslation) ? t.postTranslation : null, _ = e ? e.warnHtmlMessage : Rt(t.warnHtmlMessage) ? t.warnHtmlMessage : true, b = !!t.escapeParameter;
    const w = e ? e.modifiers : Ct(t.modifiers) ? t.modifiers : {};
    let x = t.pluralRules || e && e.pluralRules, T;
    T = (() => {
      n && Lz(null);
      const ne = {
        version: S2e,
        locale: s.value,
        fallbackLocale: l.value,
        messages: u.value,
        modifiers: w,
        pluralRules: x,
        missing: m === null ? void 0 : m,
        missingWarn: f,
        fallbackWarn: d,
        fallbackFormat: v,
        unresolving: true,
        postTranslation: y === null ? void 0 : y,
        warnHtmlMessage: _,
        escapeParameter: b,
        messageResolver: t.messageResolver,
        messageCompiler: t.messageCompiler,
        __meta: {
          framework: "vue"
        }
      };
      ne.datetimeFormats = c.value, ne.numberFormats = h.value, ne.__datetimeFormatters = Ct(T) ? T.__datetimeFormatters : void 0, ne.__numberFormatters = Ct(T) ? T.__numberFormatters : void 0;
      const ce = l2e(ne);
      return n && Lz(ce), ce;
    })(), qh(T, s.value, l.value);
    function I() {
      return [
        s.value,
        l.value,
        u.value,
        c.value,
        h.value
      ];
    }
    const M = St({
      get: () => s.value,
      set: (ne) => {
        T.locale = ne, s.value = ne;
      }
    }), k = St({
      get: () => l.value,
      set: (ne) => {
        T.fallbackLocale = ne, l.value = ne, qh(T, s.value, ne);
      }
    }), B = St(() => u.value), L = St(() => c.value), z = St(() => h.value);
    function F() {
      return nr(y) ? y : null;
    }
    function E(ne) {
      y = ne, T.postTranslation = ne;
    }
    function O() {
      return g;
    }
    function N(ne) {
      ne !== null && (m = Yz(ne)), g = ne, T.missing = m;
    }
    const V = (ne, ce, Nt, ar, Ai, Nn) => {
      I();
      let Qn;
      try {
        __INTLIFY_PROD_DEVTOOLS__, n || (T.fallbackContext = e ? s2e() : void 0), Qn = ne(T);
      } finally {
        __INTLIFY_PROD_DEVTOOLS__, n || (T.fallbackContext = void 0);
      }
      if (Nt !== "translate exists" && br(Qn) && Qn === Iy || Nt === "translate exists" && !Qn) {
        const [Jd, Co] = ce();
        return e && p ? ar(e) : Ai(Jd);
      } else {
        if (Nn(Qn)) return Qn;
        throw Kn(Rn.UNEXPECTED_RETURN_TYPE);
      }
    };
    function H(...ne) {
      return V((ce) => Reflect.apply(Vz, null, [
        ce,
        ...ne
      ]), () => DS(...ne), "translate", (ce) => Reflect.apply(ce.t, ce, [
        ...ne
      ]), (ce) => ce, (ce) => Pe(ce));
    }
    function G(...ne) {
      const [ce, Nt, ar] = ne;
      if (ar && !zt(ar)) throw Kn(Rn.INVALID_ARGUMENT);
      return H(ce, Nt, Pr({
        resolvedMessage: true
      }, ar || {}));
    }
    function Y(...ne) {
      return V((ce) => Reflect.apply(Rz, null, [
        ce,
        ...ne
      ]), () => IS(...ne), "datetime format", (ce) => Reflect.apply(ce.d, ce, [
        ...ne
      ]), () => kz, (ce) => Pe(ce));
    }
    function U(...ne) {
      return V((ce) => Reflect.apply(Nz, null, [
        ce,
        ...ne
      ]), () => MS(...ne), "number format", (ce) => Reflect.apply(ce.n, ce, [
        ...ne
      ]), () => kz, (ce) => Pe(ce));
    }
    function Z(ne) {
      return ne.map((ce) => Pe(ce) || br(ce) || Rt(ce) ? Gz(String(ce)) : ce);
    }
    const we = {
      normalize: Z,
      interpolate: (ne) => ne,
      type: "vnode"
    };
    function Te(...ne) {
      return V((ce) => {
        let Nt;
        const ar = ce;
        try {
          ar.processor = we, Nt = Reflect.apply(Vz, null, [
            ar,
            ...ne
          ]);
        } finally {
          ar.processor = null;
        }
        return Nt;
      }, () => DS(...ne), "translate", (ce) => ce[ES](...ne), (ce) => [
        Gz(ce)
      ], (ce) => Sr(ce));
    }
    function le(...ne) {
      return V((ce) => Reflect.apply(Nz, null, [
        ce,
        ...ne
      ]), () => MS(...ne), "number format", (ce) => ce[PS](...ne), Hz, (ce) => Pe(ce) || Sr(ce));
    }
    function ue(...ne) {
      return V((ce) => Reflect.apply(Rz, null, [
        ce,
        ...ne
      ]), () => IS(...ne), "datetime format", (ce) => ce[kS](...ne), Hz, (ce) => Pe(ce) || Sr(ce));
    }
    function ye(ne) {
      x = ne, T.pluralRules = x;
    }
    function ve(ne, ce) {
      return V(() => {
        if (!ne) return false;
        const Nt = Pe(ce) ? ce : s.value, ar = Xe(Nt), Ai = T.messageResolver(ar, ne);
        return Rc(Ai) || pi(Ai) || Pe(Ai);
      }, () => [
        ne
      ], "translate exists", (Nt) => Reflect.apply(Nt.te, Nt, [
        ne,
        ce
      ]), C2e, (Nt) => Rt(Nt));
    }
    function Se(ne) {
      let ce = null;
      const Nt = Gq(T, l.value, s.value);
      for (let ar = 0; ar < Nt.length; ar++) {
        const Ai = u.value[Nt[ar]] || {}, Nn = T.messageResolver(Ai, ne);
        if (Nn != null) {
          ce = Nn;
          break;
        }
      }
      return ce;
    }
    function Qe(ne) {
      const ce = Se(ne);
      return ce ?? (e ? e.tm(ne) || {} : {});
    }
    function Xe(ne) {
      return u.value[ne] || {};
    }
    function be(ne, ce) {
      if (i) {
        const Nt = {
          [ne]: ce
        };
        for (const ar in Nt) Wi(Nt, ar) && Ad(Nt[ar]);
        ce = Nt[ne];
      }
      u.value[ne] = ce, T.messages = u.value;
    }
    function ke(ne, ce) {
      u.value[ne] = u.value[ne] || {};
      const Nt = {
        [ne]: ce
      };
      if (i) for (const ar in Nt) Wi(Nt, ar) && Ad(Nt[ar]);
      ce = Nt[ne], xg(ce, u.value[ne]), T.messages = u.value;
    }
    function Vt(ne) {
      return c.value[ne] || {};
    }
    function X(ne, ce) {
      c.value[ne] = ce, T.datetimeFormats = c.value, Oz(T, ne, ce);
    }
    function j(ne, ce) {
      c.value[ne] = Pr(c.value[ne] || {}, ce), T.datetimeFormats = c.value, Oz(T, ne, ce);
    }
    function he(ne) {
      return h.value[ne] || {};
    }
    function $e(ne, ce) {
      h.value[ne] = ce, T.numberFormats = h.value, Bz(T, ne, ce);
    }
    function jt(ne, ce) {
      h.value[ne] = Pr(h.value[ne] || {}, ce), T.numberFormats = h.value, Bz(T, ne, ce);
    }
    Uz++, e && km && (nn(e.locale, (ne) => {
      o && (s.value = ne, T.locale = ne, qh(T, s.value, l.value));
    }), nn(e.fallbackLocale, (ne) => {
      o && (l.value = ne, T.fallbackLocale = ne, qh(T, s.value, l.value));
    }));
    const pt = {
      id: Uz,
      locale: M,
      fallbackLocale: k,
      get inheritLocale() {
        return o;
      },
      set inheritLocale(ne) {
        o = ne, ne && e && (s.value = e.locale.value, l.value = e.fallbackLocale.value, qh(T, s.value, l.value));
      },
      get availableLocales() {
        return Object.keys(u.value).sort();
      },
      messages: B,
      get modifiers() {
        return w;
      },
      get pluralRules() {
        return x || {};
      },
      get isGlobal() {
        return n;
      },
      get missingWarn() {
        return f;
      },
      set missingWarn(ne) {
        f = ne, T.missingWarn = f;
      },
      get fallbackWarn() {
        return d;
      },
      set fallbackWarn(ne) {
        d = ne, T.fallbackWarn = d;
      },
      get fallbackRoot() {
        return p;
      },
      set fallbackRoot(ne) {
        p = ne;
      },
      get fallbackFormat() {
        return v;
      },
      set fallbackFormat(ne) {
        v = ne, T.fallbackFormat = v;
      },
      get warnHtmlMessage() {
        return _;
      },
      set warnHtmlMessage(ne) {
        _ = ne, T.warnHtmlMessage = ne;
      },
      get escapeParameter() {
        return b;
      },
      set escapeParameter(ne) {
        b = ne, T.escapeParameter = ne;
      },
      t: H,
      getLocaleMessage: Xe,
      setLocaleMessage: be,
      mergeLocaleMessage: ke,
      getPostTranslationHandler: F,
      setPostTranslationHandler: E,
      getMissingHandler: O,
      setMissingHandler: N,
      [Qq]: ye
    };
    return pt.datetimeFormats = L, pt.numberFormats = z, pt.rt = G, pt.te = ve, pt.tm = Qe, pt.d = Y, pt.n = U, pt.getDateTimeFormat = Vt, pt.setDateTimeFormat = X, pt.mergeDateTimeFormat = j, pt.getNumberFormat = he, pt.setNumberFormat = $e, pt.mergeNumberFormat = jt, pt[Jq] = r, pt[ES] = Te, pt[kS] = ue, pt[PS] = le, pt;
  }
  function I2e(t) {
    const e = Pe(t.locale) ? t.locale : Cd, r = Pe(t.fallbackLocale) || Sr(t.fallbackLocale) || Ct(t.fallbackLocale) || t.fallbackLocale === false ? t.fallbackLocale : e, n = nr(t.missing) ? t.missing : void 0, i = Rt(t.silentTranslationWarn) || Lc(t.silentTranslationWarn) ? !t.silentTranslationWarn : true, a = Rt(t.silentFallbackWarn) || Lc(t.silentFallbackWarn) ? !t.silentFallbackWarn : true, o = Rt(t.fallbackRoot) ? t.fallbackRoot : true, s = !!t.formatFallbackMessages, l = Ct(t.modifiers) ? t.modifiers : {}, u = t.pluralizationRules, c = nr(t.postTranslation) ? t.postTranslation : void 0, h = Pe(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : true, f = !!t.escapeParameterHtml, d = Rt(t.sync) ? t.sync : true;
    let p = t.messages;
    if (Ct(t.sharedMessages)) {
      const w = t.sharedMessages;
      p = Object.keys(w).reduce((T, A) => {
        const I = T[A] || (T[A] = {});
        return Pr(I, w[A]), T;
      }, p || {});
    }
    const { __i18n: v, __root: g, __injectWithOption: m } = t, y = t.datetimeFormats, _ = t.numberFormats, b = t.flatJson;
    return {
      locale: e,
      fallbackLocale: r,
      messages: p,
      flatJson: b,
      datetimeFormats: y,
      numberFormats: _,
      missing: n,
      missingWarn: i,
      fallbackWarn: a,
      fallbackRoot: o,
      fallbackFormat: s,
      modifiers: l,
      pluralRules: u,
      postTranslation: c,
      warnHtmlMessage: h,
      escapeParameter: f,
      messageResolver: t.messageResolver,
      inheritLocale: d,
      __i18n: v,
      __root: g,
      __injectWithOption: m
    };
  }
  function $S(t = {}) {
    const e = nA(I2e(t)), { __extender: r } = t, n = {
      id: e.id,
      get locale() {
        return e.locale.value;
      },
      set locale(i) {
        e.locale.value = i;
      },
      get fallbackLocale() {
        return e.fallbackLocale.value;
      },
      set fallbackLocale(i) {
        e.fallbackLocale.value = i;
      },
      get messages() {
        return e.messages.value;
      },
      get datetimeFormats() {
        return e.datetimeFormats.value;
      },
      get numberFormats() {
        return e.numberFormats.value;
      },
      get availableLocales() {
        return e.availableLocales;
      },
      get missing() {
        return e.getMissingHandler();
      },
      set missing(i) {
        e.setMissingHandler(i);
      },
      get silentTranslationWarn() {
        return Rt(e.missingWarn) ? !e.missingWarn : e.missingWarn;
      },
      set silentTranslationWarn(i) {
        e.missingWarn = Rt(i) ? !i : i;
      },
      get silentFallbackWarn() {
        return Rt(e.fallbackWarn) ? !e.fallbackWarn : e.fallbackWarn;
      },
      set silentFallbackWarn(i) {
        e.fallbackWarn = Rt(i) ? !i : i;
      },
      get modifiers() {
        return e.modifiers;
      },
      get formatFallbackMessages() {
        return e.fallbackFormat;
      },
      set formatFallbackMessages(i) {
        e.fallbackFormat = i;
      },
      get postTranslation() {
        return e.getPostTranslationHandler();
      },
      set postTranslation(i) {
        e.setPostTranslationHandler(i);
      },
      get sync() {
        return e.inheritLocale;
      },
      set sync(i) {
        e.inheritLocale = i;
      },
      get warnHtmlInMessage() {
        return e.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(i) {
        e.warnHtmlMessage = i !== "off";
      },
      get escapeParameterHtml() {
        return e.escapeParameter;
      },
      set escapeParameterHtml(i) {
        e.escapeParameter = i;
      },
      get pluralizationRules() {
        return e.pluralRules || {};
      },
      __composer: e,
      t(...i) {
        return Reflect.apply(e.t, e, [
          ...i
        ]);
      },
      rt(...i) {
        return Reflect.apply(e.rt, e, [
          ...i
        ]);
      },
      te(i, a) {
        return e.te(i, a);
      },
      tm(i) {
        return e.tm(i);
      },
      getLocaleMessage(i) {
        return e.getLocaleMessage(i);
      },
      setLocaleMessage(i, a) {
        e.setLocaleMessage(i, a);
      },
      mergeLocaleMessage(i, a) {
        e.mergeLocaleMessage(i, a);
      },
      d(...i) {
        return Reflect.apply(e.d, e, [
          ...i
        ]);
      },
      getDateTimeFormat(i) {
        return e.getDateTimeFormat(i);
      },
      setDateTimeFormat(i, a) {
        e.setDateTimeFormat(i, a);
      },
      mergeDateTimeFormat(i, a) {
        e.mergeDateTimeFormat(i, a);
      },
      n(...i) {
        return Reflect.apply(e.n, e, [
          ...i
        ]);
      },
      getNumberFormat(i) {
        return e.getNumberFormat(i);
      },
      setNumberFormat(i, a) {
        e.setNumberFormat(i, a);
      },
      mergeNumberFormat(i, a) {
        e.mergeNumberFormat(i, a);
      }
    };
    return n.__extender = r, n;
  }
  function M2e(t, e, r) {
    return {
      beforeCreate() {
        const n = jn();
        if (!n) throw Kn(Rn.UNEXPECTED_ERROR);
        const i = this.$options;
        if (i.i18n) {
          const a = i.i18n;
          if (i.__i18n && (a.__i18n = i.__i18n), a.__root = e, this === this.$root) this.$i18n = qz(t, a);
          else {
            a.__injectWithOption = true, a.__extender = r.__vueI18nExtend, this.$i18n = $S(a);
            const o = this.$i18n;
            o.__extender && (o.__disposer = o.__extender(this.$i18n));
          }
        } else if (i.__i18n) if (this === this.$root) this.$i18n = qz(t, i);
        else {
          this.$i18n = $S({
            __i18n: i.__i18n,
            __injectWithOption: true,
            __extender: r.__vueI18nExtend,
            __root: e
          });
          const a = this.$i18n;
          a.__extender && (a.__disposer = a.__extender(this.$i18n));
        }
        else this.$i18n = t;
        i.__i18nGlobal && t7(e, i, i), this.$t = (...a) => this.$i18n.t(...a), this.$rt = (...a) => this.$i18n.rt(...a), this.$te = (a, o) => this.$i18n.te(a, o), this.$d = (...a) => this.$i18n.d(...a), this.$n = (...a) => this.$i18n.n(...a), this.$tm = (a) => this.$i18n.tm(a), r.__setInstance(n, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const n = jn();
        if (!n) throw Kn(Rn.UNEXPECTED_ERROR);
        const i = this.$i18n;
        delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), r.__deleteInstance(n), delete this.$i18n;
      }
    };
  }
  function qz(t, e) {
    t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[Qq](e.pluralizationRules || t.pluralizationRules);
    const r = rA(t.locale, {
      messages: e.messages,
      __i18n: e.__i18n
    });
    return Object.keys(r).forEach((n) => t.mergeLocaleMessage(n, r[n])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach((n) => t.mergeDateTimeFormat(n, e.datetimeFormats[n])), e.numberFormats && Object.keys(e.numberFormats).forEach((n) => t.mergeNumberFormat(n, e.numberFormats[n])), t;
  }
  const iA = {
    tag: {
      type: [
        String,
        Object
      ]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (t) => t === "parent" || t === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  function D2e({ slots: t }, e) {
    return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((n, i) => [
      ...n,
      ...i.type === Bf ? i.children : [
        i
      ]
    ], []) : e.reduce((r, n) => {
      const i = t[n];
      return i && (r[n] = i()), r;
    }, Zt());
  }
  function r7() {
    return Bf;
  }
  const E2e = ht({
    name: "i18n-t",
    props: Pr({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [
          Number,
          String
        ],
        validator: (t) => br(t) || !isNaN(t)
      }
    }, iA),
    setup(t, e) {
      const { slots: r, attrs: n } = e, i = t.i18n || aA({
        useScope: t.scope,
        __useComponent: true
      });
      return () => {
        const a = Object.keys(r).filter((h) => h !== "_"), o = Zt();
        t.locale && (o.locale = t.locale), t.plural !== void 0 && (o.plural = Pe(t.plural) ? +t.plural : t.plural);
        const s = D2e(e, a), l = i[ES](t.keypath, s, o), u = Pr(Zt(), n), c = Pe(t.tag) || zt(t.tag) ? t.tag : r7();
        return Hi(c, u, l);
      };
    }
  }), Xz = E2e;
  function k2e(t) {
    return Sr(t) && !Pe(t[0]);
  }
  function n7(t, e, r, n) {
    const { slots: i, attrs: a } = e;
    return () => {
      const o = {
        part: true
      };
      let s = Zt();
      t.locale && (o.locale = t.locale), Pe(t.format) ? o.key = t.format : zt(t.format) && (Pe(t.format.key) && (o.key = t.format.key), s = Object.keys(t.format).reduce((f, d) => r.includes(d) ? Pr(Zt(), f, {
        [d]: t.format[d]
      }) : f, Zt()));
      const l = n(t.value, o, s);
      let u = [
        o.key
      ];
      Sr(l) ? u = l.map((f, d) => {
        const p = i[f.type], v = p ? p({
          [f.type]: f.value,
          index: d,
          parts: l
        }) : [
          f.value
        ];
        return k2e(v) && (v[0].key = `${f.type}-${d}`), v;
      }) : Pe(l) && (u = [
        l
      ]);
      const c = Pr(Zt(), a), h = Pe(t.tag) || zt(t.tag) ? t.tag : r7();
      return Hi(h, c, u);
    };
  }
  const P2e = ht({
    name: "i18n-n",
    props: Pr({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, iA),
    setup(t, e) {
      const r = t.i18n || aA({
        useScope: t.scope,
        __useComponent: true
      });
      return n7(t, e, jq, (...n) => r[PS](...n));
    }
  }), jz = P2e;
  function L2e(t, e) {
    const r = t;
    if (t.mode === "composition") return r.__getInstance(e) || t.global;
    {
      const n = r.__getInstance(e);
      return n != null ? n.__composer : t.global.__composer;
    }
  }
  function $2e(t) {
    const e = (o) => {
      const { instance: s, value: l } = o;
      if (!s || !s.$) throw Kn(Rn.UNEXPECTED_ERROR);
      const u = L2e(t, s.$), c = Kz(l);
      return [
        Reflect.apply(u.t, u, [
          ...Zz(c)
        ]),
        u
      ];
    };
    return {
      created: (o, s) => {
        const [l, u] = e(s);
        km && t.global === u && (o.__i18nWatcher = nn(u.locale, () => {
          s.instance && s.instance.$forceUpdate();
        })), o.__composer = u, o.textContent = l;
      },
      unmounted: (o) => {
        km && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer);
      },
      beforeUpdate: (o, { value: s }) => {
        if (o.__composer) {
          const l = o.__composer, u = Kz(s);
          o.textContent = Reflect.apply(l.t, l, [
            ...Zz(u)
          ]);
        }
      },
      getSSRProps: (o) => {
        const [s] = e(o);
        return {
          textContent: s
        };
      }
    };
  }
  function Kz(t) {
    if (Pe(t)) return {
      path: t
    };
    if (Ct(t)) {
      if (!("path" in t)) throw Kn(Rn.REQUIRED_VALUE, "path");
      return t;
    } else throw Kn(Rn.INVALID_VALUE);
  }
  function Zz(t) {
    const { path: e, locale: r, args: n, choice: i, plural: a } = t, o = {}, s = n || {};
    return Pe(r) && (o.locale = r), br(i) && (o.plural = i), br(a) && (o.plural = a), [
      e,
      s,
      o
    ];
  }
  function R2e(t, e, ...r) {
    const n = Ct(r[0]) ? r[0] : {};
    (Rt(n.globalInstall) ? n.globalInstall : true) && ([
      Xz.name,
      "I18nT"
    ].forEach((a) => t.component(a, Xz)), [
      jz.name,
      "I18nN"
    ].forEach((a) => t.component(a, jz)), [
      Jz.name,
      "I18nD"
    ].forEach((a) => t.component(a, Jz))), t.directive("t", $2e(e));
  }
  const O2e = Ss("global-vue-i18n");
  function N2e(t = {}) {
    const e = __VUE_I18N_LEGACY_API__ && Rt(t.legacy) ? t.legacy : __VUE_I18N_LEGACY_API__, r = Rt(t.globalInjection) ? t.globalInjection : true, n = /* @__PURE__ */ new Map(), [i, a] = B2e(t, e), o = Ss("");
    function s(h) {
      return n.get(h) || null;
    }
    function l(h, f) {
      n.set(h, f);
    }
    function u(h) {
      n.delete(h);
    }
    const c = {
      get mode() {
        return __VUE_I18N_LEGACY_API__ && e ? "legacy" : "composition";
      },
      async install(h, ...f) {
        if (h.__VUE_I18N_SYMBOL__ = o, h.provide(h.__VUE_I18N_SYMBOL__, c), Ct(f[0])) {
          const v = f[0];
          c.__composerExtend = v.__composerExtend, c.__vueI18nExtend = v.__vueI18nExtend;
        }
        let d = null;
        !e && r && (d = Y2e(h, c.global)), __VUE_I18N_FULL_INSTALL__ && R2e(h, c, ...f), __VUE_I18N_LEGACY_API__ && e && h.mixin(M2e(a, a.__composer, c));
        const p = h.unmount;
        h.unmount = () => {
          d && d(), c.dispose(), p();
        };
      },
      get global() {
        return a;
      },
      dispose() {
        i.stop();
      },
      __instances: n,
      __getInstance: s,
      __setInstance: l,
      __deleteInstance: u
    };
    return c;
  }
  function aA(t = {}) {
    const e = jn();
    if (e == null) throw Kn(Rn.MUST_BE_CALL_SETUP_TOP);
    if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw Kn(Rn.NOT_INSTALLED);
    const r = z2e(e), n = V2e(r), i = e7(e), a = F2e(t, i);
    if (a === "global") return t7(n, t, i), n;
    if (a === "parent") {
      let l = G2e(r, e, t.__useComponent);
      return l == null && (l = n), l;
    }
    const o = r;
    let s = o.__getInstance(e);
    if (s == null) {
      const l = Pr({}, t);
      "__i18n" in i && (l.__i18n = i.__i18n), n && (l.__root = n), s = nA(l), o.__composerExtend && (s[LS] = o.__composerExtend(s)), H2e(o, e, s), o.__setInstance(e, s);
    }
    return s;
  }
  function B2e(t, e) {
    const r = zS(), n = __VUE_I18N_LEGACY_API__ && e ? r.run(() => $S(t)) : r.run(() => nA(t));
    if (n == null) throw Kn(Rn.UNEXPECTED_ERROR);
    return [
      r,
      n
    ];
  }
  function z2e(t) {
    const e = mF(t.isCE ? O2e : t.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e) throw Kn(t.isCE ? Rn.NOT_INSTALLED_WITH_PROVIDE : Rn.UNEXPECTED_ERROR);
    return e;
  }
  function F2e(t, e) {
    return Cy(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local";
  }
  function V2e(t) {
    return t.mode === "composition" ? t.global : t.global.__composer;
  }
  function G2e(t, e, r = false) {
    let n = null;
    const i = e.root;
    let a = W2e(e, r);
    for (; a != null; ) {
      const o = t;
      if (t.mode === "composition") n = o.__getInstance(a);
      else if (__VUE_I18N_LEGACY_API__) {
        const s = o.__getInstance(a);
        s != null && (n = s.__composer, r && n && !n[Jq] && (n = null));
      }
      if (n != null || i === a) break;
      a = a.parent;
    }
    return n;
  }
  function W2e(t, e = false) {
    return t == null ? null : e && t.vnode.ctx || t.parent;
  }
  function H2e(t, e, r) {
    Oc(() => {
    }, e), Lm(() => {
      const n = r;
      t.__deleteInstance(e);
      const i = n[LS];
      i && (i(), delete n[LS]);
    }, e);
  }
  const U2e = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ], Qz = [
    "t",
    "rt",
    "d",
    "n",
    "tm",
    "te"
  ];
  function Y2e(t, e) {
    const r = /* @__PURE__ */ Object.create(null);
    return U2e.forEach((i) => {
      const a = Object.getOwnPropertyDescriptor(e, i);
      if (!a) throw Kn(Rn.UNEXPECTED_ERROR);
      const o = gF(a.value) ? {
        get() {
          return a.value.value;
        },
        set(s) {
          a.value.value = s;
        }
      } : {
        get() {
          return a.get && a.get();
        }
      };
      Object.defineProperty(r, i, o);
    }), t.config.globalProperties.$i18n = r, Qz.forEach((i) => {
      const a = Object.getOwnPropertyDescriptor(e, i);
      if (!a || !a.value) throw Kn(Rn.UNEXPECTED_ERROR);
      Object.defineProperty(t.config.globalProperties, `$${i}`, a);
    }), () => {
      delete t.config.globalProperties.$i18n, Qz.forEach((i) => {
        delete t.config.globalProperties[`$${i}`];
      });
    };
  }
  const q2e = ht({
    name: "i18n-d",
    props: Pr({
      value: {
        type: [
          Number,
          Date
        ],
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, iA),
    setup(t, e) {
      const r = t.i18n || aA({
        useScope: t.scope,
        __useComponent: true
      });
      return n7(t, e, Xq, (...n) => r[kS](...n));
    }
  }), Jz = q2e;
  T2e();
  r2e(NTe);
  n2e(JTe);
  i2e(Gq);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const t = Pl();
    t.__INTLIFY__ = true, BTe(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const X2e = vF("app", {
    state: () => ({
      lang: ""
    }),
    actions: {
      setNowLang(t) {
        this.lang = t;
      }
    }
  }), eF = await Z2e({
    locale: j2e()
  });
  function j2e() {
    const t = window.location.href, e = navigator.language, r = J2e(t).lang ?? e;
    return X2e().setNowLang(r), r;
  }
  function K2e(t) {
    return t.includes("zh");
  }
  async function Z2e(t = {
    locale: "zh-CN"
  }) {
    const e = N2e({
      legacy: false,
      globalInjection: true,
      fallbackLocale: "zh-CN",
      ...t
    });
    return Q2e(e, t.locale), await tF(e, "zh-CN"), K2e(t.locale) || await tF(e, t.locale), e;
  }
  function Q2e(t, e = "zh-CN") {
    var _a2;
    t.mode === "legacy" ? t.global.locale = e : typeof t.global.locale != "string" && (t.global.locale.value = e), (_a2 = document.querySelector("html")) == null ? void 0 : _a2.setAttribute("lang", e);
  }
  async function tF(t, e) {
    const r = await FSe(Object.assign({
      "./locales/en.json": () => Wl(() => import("./en-6Y5830hC.js"), []),
      "./locales/zh-CN.json": () => Wl(() => import("./zh-CN-HZdoqDhl.js"), [])
    }), `./locales/${e}.json`, 3);
    return t.global.setLocaleMessage(e, r.default), bo();
  }
  function J2e(t) {
    const e = {};
    if (!t || t === "" || typeof t != "string") return e;
    const r = t.split("?")[1];
    return r && r.split("&").forEach((i) => {
      const [a, o] = i.split("=");
      o === void 0 ? e[a] = null : o === "true" ? e[a] = true : o === "false" ? e[a] = false : e[a] = decodeURIComponent(o);
    }), e;
  }
  const eCe = () => {
    const t = St(() => Q(eF.global.locale)), e = St(() => t.value.includes("zh"));
    return {
      t: eF.global.t,
      locale: t,
      isZh: e
    };
  };
  function i7(t) {
    var e, r, n = "";
    if (typeof t == "string" || typeof t == "number") n += t;
    else if (typeof t == "object") if (Array.isArray(t)) {
      var i = t.length;
      for (e = 0; e < i; e++) t[e] && (r = i7(t[e])) && (n && (n += " "), n += r);
    } else for (r in t) t[r] && (n && (n += " "), n += r);
    return n;
  }
  function a7() {
    for (var t, e, r = 0, n = "", i = arguments.length; r < i; r++) (t = arguments[r]) && (e = i7(t)) && (n && (n += " "), n += e);
    return n;
  }
  const rF = (t) => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, nF = a7, tCe = (t, e) => (r) => {
    var n;
    if ((e == null ? void 0 : e.variants) == null) return nF(t, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
    const { variants: i, defaultVariants: a } = e, o = Object.keys(i).map((u) => {
      const c = r == null ? void 0 : r[u], h = a == null ? void 0 : a[u];
      if (c === null) return null;
      const f = rF(c) || rF(h);
      return i[u][f];
    }), s = r && Object.entries(r).reduce((u, c) => {
      let [h, f] = c;
      return f === void 0 || (u[h] = f), u;
    }, {}), l = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce((u, c) => {
      let { class: h, className: f, ...d } = c;
      return Object.entries(d).every((p) => {
        let [v, g] = p;
        return Array.isArray(g) ? g.includes({
          ...a,
          ...s
        }[v]) : {
          ...a,
          ...s
        }[v] === g;
      }) ? [
        ...u,
        h,
        f
      ] : u;
    }, []);
    return nF(t, o, l, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
  }, oA = "-", rCe = (t) => {
    const e = iCe(t), { conflictingClassGroups: r, conflictingClassGroupModifiers: n } = t;
    return {
      getClassGroupId: (o) => {
        const s = o.split(oA);
        return s[0] === "" && s.length !== 1 && s.shift(), o7(s, e) || nCe(o);
      },
      getConflictingClassGroupIds: (o, s) => {
        const l = r[o] || [];
        return s && n[o] ? [
          ...l,
          ...n[o]
        ] : l;
      }
    };
  }, o7 = (t, e) => {
    var _a2;
    if (t.length === 0) return e.classGroupId;
    const r = t[0], n = e.nextPart.get(r), i = n ? o7(t.slice(1), n) : void 0;
    if (i) return i;
    if (e.validators.length === 0) return;
    const a = t.join(oA);
    return (_a2 = e.validators.find(({ validator: o }) => o(a))) == null ? void 0 : _a2.classGroupId;
  }, iF = /^\[(.+)\]$/, nCe = (t) => {
    if (iF.test(t)) {
      const e = iF.exec(t)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
      if (r) return "arbitrary.." + r;
    }
  }, iCe = (t) => {
    const { theme: e, classGroups: r } = t, n = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    for (const i in r) RS(r[i], n, i, e);
    return n;
  }, RS = (t, e, r, n) => {
    t.forEach((i) => {
      if (typeof i == "string") {
        const a = i === "" ? e : aF(e, i);
        a.classGroupId = r;
        return;
      }
      if (typeof i == "function") {
        if (aCe(i)) {
          RS(i(n), e, r, n);
          return;
        }
        e.validators.push({
          validator: i,
          classGroupId: r
        });
        return;
      }
      Object.entries(i).forEach(([a, o]) => {
        RS(o, aF(e, a), r, n);
      });
    });
  }, aF = (t, e) => {
    let r = t;
    return e.split(oA).forEach((n) => {
      r.nextPart.has(n) || r.nextPart.set(n, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      }), r = r.nextPart.get(n);
    }), r;
  }, aCe = (t) => t.isThemeGetter, oCe = (t) => {
    if (t < 1) return {
      get: () => {
      },
      set: () => {
      }
    };
    let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    const i = (a, o) => {
      r.set(a, o), e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ new Map());
    };
    return {
      get(a) {
        let o = r.get(a);
        if (o !== void 0) return o;
        if ((o = n.get(a)) !== void 0) return i(a, o), o;
      },
      set(a, o) {
        r.has(a) ? r.set(a, o) : i(a, o);
      }
    };
  }, OS = "!", NS = ":", sCe = NS.length, lCe = (t) => {
    const { prefix: e, experimentalParseClassName: r } = t;
    let n = (i) => {
      const a = [];
      let o = 0, s = 0, l = 0, u;
      for (let p = 0; p < i.length; p++) {
        let v = i[p];
        if (o === 0 && s === 0) {
          if (v === NS) {
            a.push(i.slice(l, p)), l = p + sCe;
            continue;
          }
          if (v === "/") {
            u = p;
            continue;
          }
        }
        v === "[" ? o++ : v === "]" ? o-- : v === "(" ? s++ : v === ")" && s--;
      }
      const c = a.length === 0 ? i : i.substring(l), h = uCe(c), f = h !== c, d = u && u > l ? u - l : void 0;
      return {
        modifiers: a,
        hasImportantModifier: f,
        baseClassName: h,
        maybePostfixModifierPosition: d
      };
    };
    if (e) {
      const i = e + NS, a = n;
      n = (o) => o.startsWith(i) ? a(o.substring(i.length)) : {
        isExternal: true,
        modifiers: [],
        hasImportantModifier: false,
        baseClassName: o,
        maybePostfixModifierPosition: void 0
      };
    }
    if (r) {
      const i = n;
      n = (a) => r({
        className: a,
        parseClassName: i
      });
    }
    return n;
  }, uCe = (t) => t.endsWith(OS) ? t.substring(0, t.length - 1) : t.startsWith(OS) ? t.substring(1) : t, cCe = (t) => {
    const e = Object.fromEntries(t.orderSensitiveModifiers.map((n) => [
      n,
      true
    ]));
    return (n) => {
      if (n.length <= 1) return n;
      const i = [];
      let a = [];
      return n.forEach((o) => {
        o[0] === "[" || e[o] ? (i.push(...a.sort(), o), a = []) : a.push(o);
      }), i.push(...a.sort()), i;
    };
  }, hCe = (t) => ({
    cache: oCe(t.cacheSize),
    parseClassName: lCe(t),
    sortModifiers: cCe(t),
    ...rCe(t)
  }), fCe = /\s+/, dCe = (t, e) => {
    const { parseClassName: r, getClassGroupId: n, getConflictingClassGroupIds: i, sortModifiers: a } = e, o = [], s = t.trim().split(fCe);
    let l = "";
    for (let u = s.length - 1; u >= 0; u -= 1) {
      const c = s[u], { isExternal: h, modifiers: f, hasImportantModifier: d, baseClassName: p, maybePostfixModifierPosition: v } = r(c);
      if (h) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      let g = !!v, m = n(g ? p.substring(0, v) : p);
      if (!m) {
        if (!g) {
          l = c + (l.length > 0 ? " " + l : l);
          continue;
        }
        if (m = n(p), !m) {
          l = c + (l.length > 0 ? " " + l : l);
          continue;
        }
        g = false;
      }
      const y = a(f).join(":"), _ = d ? y + OS : y, b = _ + m;
      if (o.includes(b)) continue;
      o.push(b);
      const w = i(m, g);
      for (let x = 0; x < w.length; ++x) {
        const T = w[x];
        o.push(_ + T);
      }
      l = c + (l.length > 0 ? " " + l : l);
    }
    return l;
  };
  function pCe() {
    let t = 0, e, r, n = "";
    for (; t < arguments.length; ) (e = arguments[t++]) && (r = s7(e)) && (n && (n += " "), n += r);
    return n;
  }
  const s7 = (t) => {
    if (typeof t == "string") return t;
    let e, r = "";
    for (let n = 0; n < t.length; n++) t[n] && (e = s7(t[n])) && (r && (r += " "), r += e);
    return r;
  };
  function vCe(t, ...e) {
    let r, n, i, a = o;
    function o(l) {
      const u = e.reduce((c, h) => h(c), t());
      return r = hCe(u), n = r.cache.get, i = r.cache.set, a = s, s(l);
    }
    function s(l) {
      const u = n(l);
      if (u) return u;
      const c = dCe(l, r);
      return i(l, c), c;
    }
    return function() {
      return a(pCe.apply(null, arguments));
    };
  }
  const Or = (t) => {
    const e = (r) => r[t] || [];
    return e.isThemeGetter = true, e;
  }, l7 = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, u7 = /^\((?:(\w[\w-]*):)?(.+)\)$/i, gCe = /^\d+\/\d+$/, mCe = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, yCe = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, _Ce = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, bCe = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, xCe = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Gu = (t) => gCe.test(t), At = (t) => !!t && !Number.isNaN(Number(t)), Go = (t) => !!t && Number.isInteger(Number(t)), oF = (t) => t.endsWith("%") && At(t.slice(0, -1)), Wo = (t) => mCe.test(t), wCe = () => true, SCe = (t) => yCe.test(t) && !_Ce.test(t), sA = () => false, TCe = (t) => bCe.test(t), CCe = (t) => xCe.test(t), ACe = (t) => !ze(t) && !Fe(t), ICe = (t) => Jc(t, f7, sA), ze = (t) => l7.test(t), il = (t) => Jc(t, d7, SCe), W1 = (t) => Jc(t, BCe, At), MCe = (t) => Jc(t, c7, sA), DCe = (t) => Jc(t, h7, CCe), ECe = (t) => Jc(t, sA, TCe), Fe = (t) => u7.test(t), Xh = (t) => eh(t, d7), kCe = (t) => eh(t, zCe), PCe = (t) => eh(t, c7), LCe = (t) => eh(t, f7), $Ce = (t) => eh(t, h7), RCe = (t) => eh(t, FCe, true), Jc = (t, e, r) => {
    const n = l7.exec(t);
    return n ? n[1] ? e(n[1]) : r(n[2]) : false;
  }, eh = (t, e, r = false) => {
    const n = u7.exec(t);
    return n ? n[1] ? e(n[1]) : r : false;
  }, c7 = (t) => t === "position", OCe = /* @__PURE__ */ new Set([
    "image",
    "url"
  ]), h7 = (t) => OCe.has(t), NCe = /* @__PURE__ */ new Set([
    "length",
    "size",
    "percentage"
  ]), f7 = (t) => NCe.has(t), d7 = (t) => t === "length", BCe = (t) => t === "number", zCe = (t) => t === "family-name", FCe = (t) => t === "shadow", VCe = () => {
    const t = Or("color"), e = Or("font"), r = Or("text"), n = Or("font-weight"), i = Or("tracking"), a = Or("leading"), o = Or("breakpoint"), s = Or("container"), l = Or("spacing"), u = Or("radius"), c = Or("shadow"), h = Or("inset-shadow"), f = Or("drop-shadow"), d = Or("blur"), p = Or("perspective"), v = Or("aspect"), g = Or("ease"), m = Or("animate"), y = () => [
      "auto",
      "avoid",
      "all",
      "avoid-page",
      "page",
      "left",
      "right",
      "column"
    ], _ = () => [
      "bottom",
      "center",
      "left",
      "left-bottom",
      "left-top",
      "right",
      "right-bottom",
      "right-top",
      "top"
    ], b = () => [
      "auto",
      "hidden",
      "clip",
      "visible",
      "scroll"
    ], w = () => [
      "auto",
      "contain",
      "none"
    ], x = () => [
      Fe,
      ze,
      l
    ], T = () => [
      Gu,
      "full",
      "auto",
      ...x()
    ], A = () => [
      Go,
      "none",
      "subgrid",
      Fe,
      ze
    ], I = () => [
      "auto",
      {
        span: [
          "full",
          Go,
          Fe,
          ze
        ]
      },
      Go,
      Fe,
      ze
    ], M = () => [
      Go,
      "auto",
      Fe,
      ze
    ], k = () => [
      "auto",
      "min",
      "max",
      "fr",
      Fe,
      ze
    ], B = () => [
      "start",
      "end",
      "center",
      "between",
      "around",
      "evenly",
      "stretch",
      "baseline"
    ], L = () => [
      "start",
      "end",
      "center",
      "stretch"
    ], z = () => [
      "auto",
      ...x()
    ], F = () => [
      Gu,
      "auto",
      "full",
      "dvw",
      "dvh",
      "lvw",
      "lvh",
      "svw",
      "svh",
      "min",
      "max",
      "fit",
      ...x()
    ], E = () => [
      t,
      Fe,
      ze
    ], O = () => [
      oF,
      Xh,
      il
    ], N = () => [
      "",
      "none",
      "full",
      u,
      Fe,
      ze
    ], V = () => [
      "",
      At,
      Xh,
      il
    ], H = () => [
      "solid",
      "dashed",
      "dotted",
      "double"
    ], G = () => [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ], Y = () => [
      "",
      "none",
      d,
      Fe,
      ze
    ], U = () => [
      "center",
      "top",
      "top-right",
      "right",
      "bottom-right",
      "bottom",
      "bottom-left",
      "left",
      "top-left",
      Fe,
      ze
    ], Z = () => [
      "none",
      At,
      Fe,
      ze
    ], ee = () => [
      "none",
      At,
      Fe,
      ze
    ], we = () => [
      At,
      Fe,
      ze
    ], Te = () => [
      Gu,
      "full",
      ...x()
    ];
    return {
      cacheSize: 500,
      theme: {
        animate: [
          "spin",
          "ping",
          "pulse",
          "bounce"
        ],
        aspect: [
          "video"
        ],
        blur: [
          Wo
        ],
        breakpoint: [
          Wo
        ],
        color: [
          wCe
        ],
        container: [
          Wo
        ],
        "drop-shadow": [
          Wo
        ],
        ease: [
          "in",
          "out",
          "in-out"
        ],
        font: [
          ACe
        ],
        "font-weight": [
          "thin",
          "extralight",
          "light",
          "normal",
          "medium",
          "semibold",
          "bold",
          "extrabold",
          "black"
        ],
        "inset-shadow": [
          Wo
        ],
        leading: [
          "none",
          "tight",
          "snug",
          "normal",
          "relaxed",
          "loose"
        ],
        perspective: [
          "dramatic",
          "near",
          "normal",
          "midrange",
          "distant",
          "none"
        ],
        radius: [
          Wo
        ],
        shadow: [
          Wo
        ],
        spacing: [
          "px",
          At
        ],
        text: [
          Wo
        ],
        tracking: [
          "tighter",
          "tight",
          "normal",
          "wide",
          "wider",
          "widest"
        ]
      },
      classGroups: {
        aspect: [
          {
            aspect: [
              "auto",
              "square",
              Gu,
              ze,
              Fe,
              v
            ]
          }
        ],
        container: [
          "container"
        ],
        columns: [
          {
            columns: [
              At,
              ze,
              Fe,
              s
            ]
          }
        ],
        "break-after": [
          {
            "break-after": y()
          }
        ],
        "break-before": [
          {
            "break-before": y()
          }
        ],
        "break-inside": [
          {
            "break-inside": [
              "auto",
              "avoid",
              "avoid-page",
              "avoid-column"
            ]
          }
        ],
        "box-decoration": [
          {
            "box-decoration": [
              "slice",
              "clone"
            ]
          }
        ],
        box: [
          {
            box: [
              "border",
              "content"
            ]
          }
        ],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden"
        ],
        sr: [
          "sr-only",
          "not-sr-only"
        ],
        float: [
          {
            float: [
              "right",
              "left",
              "none",
              "start",
              "end"
            ]
          }
        ],
        clear: [
          {
            clear: [
              "left",
              "right",
              "both",
              "none",
              "start",
              "end"
            ]
          }
        ],
        isolation: [
          "isolate",
          "isolation-auto"
        ],
        "object-fit": [
          {
            object: [
              "contain",
              "cover",
              "fill",
              "none",
              "scale-down"
            ]
          }
        ],
        "object-position": [
          {
            object: [
              ..._(),
              ze,
              Fe
            ]
          }
        ],
        overflow: [
          {
            overflow: b()
          }
        ],
        "overflow-x": [
          {
            "overflow-x": b()
          }
        ],
        "overflow-y": [
          {
            "overflow-y": b()
          }
        ],
        overscroll: [
          {
            overscroll: w()
          }
        ],
        "overscroll-x": [
          {
            "overscroll-x": w()
          }
        ],
        "overscroll-y": [
          {
            "overscroll-y": w()
          }
        ],
        position: [
          "static",
          "fixed",
          "absolute",
          "relative",
          "sticky"
        ],
        inset: [
          {
            inset: T()
          }
        ],
        "inset-x": [
          {
            "inset-x": T()
          }
        ],
        "inset-y": [
          {
            "inset-y": T()
          }
        ],
        start: [
          {
            start: T()
          }
        ],
        end: [
          {
            end: T()
          }
        ],
        top: [
          {
            top: T()
          }
        ],
        right: [
          {
            right: T()
          }
        ],
        bottom: [
          {
            bottom: T()
          }
        ],
        left: [
          {
            left: T()
          }
        ],
        visibility: [
          "visible",
          "invisible",
          "collapse"
        ],
        z: [
          {
            z: [
              Go,
              "auto",
              Fe,
              ze
            ]
          }
        ],
        basis: [
          {
            basis: [
              Gu,
              "full",
              "auto",
              s,
              ...x()
            ]
          }
        ],
        "flex-direction": [
          {
            flex: [
              "row",
              "row-reverse",
              "col",
              "col-reverse"
            ]
          }
        ],
        "flex-wrap": [
          {
            flex: [
              "nowrap",
              "wrap",
              "wrap-reverse"
            ]
          }
        ],
        flex: [
          {
            flex: [
              At,
              Gu,
              "auto",
              "initial",
              "none",
              ze
            ]
          }
        ],
        grow: [
          {
            grow: [
              "",
              At,
              Fe,
              ze
            ]
          }
        ],
        shrink: [
          {
            shrink: [
              "",
              At,
              Fe,
              ze
            ]
          }
        ],
        order: [
          {
            order: [
              Go,
              "first",
              "last",
              "none",
              Fe,
              ze
            ]
          }
        ],
        "grid-cols": [
          {
            "grid-cols": A()
          }
        ],
        "col-start-end": [
          {
            col: I()
          }
        ],
        "col-start": [
          {
            "col-start": M()
          }
        ],
        "col-end": [
          {
            "col-end": M()
          }
        ],
        "grid-rows": [
          {
            "grid-rows": A()
          }
        ],
        "row-start-end": [
          {
            row: I()
          }
        ],
        "row-start": [
          {
            "row-start": M()
          }
        ],
        "row-end": [
          {
            "row-end": M()
          }
        ],
        "grid-flow": [
          {
            "grid-flow": [
              "row",
              "col",
              "dense",
              "row-dense",
              "col-dense"
            ]
          }
        ],
        "auto-cols": [
          {
            "auto-cols": k()
          }
        ],
        "auto-rows": [
          {
            "auto-rows": k()
          }
        ],
        gap: [
          {
            gap: x()
          }
        ],
        "gap-x": [
          {
            "gap-x": x()
          }
        ],
        "gap-y": [
          {
            "gap-y": x()
          }
        ],
        "justify-content": [
          {
            justify: [
              ...B(),
              "normal"
            ]
          }
        ],
        "justify-items": [
          {
            "justify-items": [
              ...L(),
              "normal"
            ]
          }
        ],
        "justify-self": [
          {
            "justify-self": [
              "auto",
              ...L()
            ]
          }
        ],
        "align-content": [
          {
            content: [
              "normal",
              ...B()
            ]
          }
        ],
        "align-items": [
          {
            items: [
              ...L(),
              "baseline"
            ]
          }
        ],
        "align-self": [
          {
            self: [
              "auto",
              ...L(),
              "baseline"
            ]
          }
        ],
        "place-content": [
          {
            "place-content": B()
          }
        ],
        "place-items": [
          {
            "place-items": [
              ...L(),
              "baseline"
            ]
          }
        ],
        "place-self": [
          {
            "place-self": [
              "auto",
              ...L()
            ]
          }
        ],
        p: [
          {
            p: x()
          }
        ],
        px: [
          {
            px: x()
          }
        ],
        py: [
          {
            py: x()
          }
        ],
        ps: [
          {
            ps: x()
          }
        ],
        pe: [
          {
            pe: x()
          }
        ],
        pt: [
          {
            pt: x()
          }
        ],
        pr: [
          {
            pr: x()
          }
        ],
        pb: [
          {
            pb: x()
          }
        ],
        pl: [
          {
            pl: x()
          }
        ],
        m: [
          {
            m: z()
          }
        ],
        mx: [
          {
            mx: z()
          }
        ],
        my: [
          {
            my: z()
          }
        ],
        ms: [
          {
            ms: z()
          }
        ],
        me: [
          {
            me: z()
          }
        ],
        mt: [
          {
            mt: z()
          }
        ],
        mr: [
          {
            mr: z()
          }
        ],
        mb: [
          {
            mb: z()
          }
        ],
        ml: [
          {
            ml: z()
          }
        ],
        "space-x": [
          {
            "space-x": x()
          }
        ],
        "space-x-reverse": [
          "space-x-reverse"
        ],
        "space-y": [
          {
            "space-y": x()
          }
        ],
        "space-y-reverse": [
          "space-y-reverse"
        ],
        size: [
          {
            size: F()
          }
        ],
        w: [
          {
            w: [
              s,
              "screen",
              ...F()
            ]
          }
        ],
        "min-w": [
          {
            "min-w": [
              s,
              "screen",
              "none",
              ...F()
            ]
          }
        ],
        "max-w": [
          {
            "max-w": [
              s,
              "screen",
              "none",
              "prose",
              {
                screen: [
                  o
                ]
              },
              ...F()
            ]
          }
        ],
        h: [
          {
            h: [
              "screen",
              ...F()
            ]
          }
        ],
        "min-h": [
          {
            "min-h": [
              "screen",
              "none",
              ...F()
            ]
          }
        ],
        "max-h": [
          {
            "max-h": [
              "screen",
              ...F()
            ]
          }
        ],
        "font-size": [
          {
            text: [
              "base",
              r,
              Xh,
              il
            ]
          }
        ],
        "font-smoothing": [
          "antialiased",
          "subpixel-antialiased"
        ],
        "font-style": [
          "italic",
          "not-italic"
        ],
        "font-weight": [
          {
            font: [
              n,
              Fe,
              W1
            ]
          }
        ],
        "font-stretch": [
          {
            "font-stretch": [
              "ultra-condensed",
              "extra-condensed",
              "condensed",
              "semi-condensed",
              "normal",
              "semi-expanded",
              "expanded",
              "extra-expanded",
              "ultra-expanded",
              oF,
              ze
            ]
          }
        ],
        "font-family": [
          {
            font: [
              kCe,
              ze,
              e
            ]
          }
        ],
        "fvn-normal": [
          "normal-nums"
        ],
        "fvn-ordinal": [
          "ordinal"
        ],
        "fvn-slashed-zero": [
          "slashed-zero"
        ],
        "fvn-figure": [
          "lining-nums",
          "oldstyle-nums"
        ],
        "fvn-spacing": [
          "proportional-nums",
          "tabular-nums"
        ],
        "fvn-fraction": [
          "diagonal-fractions",
          "stacked-fractions"
        ],
        tracking: [
          {
            tracking: [
              i,
              Fe,
              ze
            ]
          }
        ],
        "line-clamp": [
          {
            "line-clamp": [
              At,
              "none",
              Fe,
              W1
            ]
          }
        ],
        leading: [
          {
            leading: [
              a,
              ...x()
            ]
          }
        ],
        "list-image": [
          {
            "list-image": [
              "none",
              Fe,
              ze
            ]
          }
        ],
        "list-style-position": [
          {
            list: [
              "inside",
              "outside"
            ]
          }
        ],
        "list-style-type": [
          {
            list: [
              "disc",
              "decimal",
              "none",
              Fe,
              ze
            ]
          }
        ],
        "text-alignment": [
          {
            text: [
              "left",
              "center",
              "right",
              "justify",
              "start",
              "end"
            ]
          }
        ],
        "placeholder-color": [
          {
            placeholder: E()
          }
        ],
        "text-color": [
          {
            text: E()
          }
        ],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline"
        ],
        "text-decoration-style": [
          {
            decoration: [
              ...H(),
              "wavy"
            ]
          }
        ],
        "text-decoration-thickness": [
          {
            decoration: [
              At,
              "from-font",
              "auto",
              Fe,
              il
            ]
          }
        ],
        "text-decoration-color": [
          {
            decoration: E()
          }
        ],
        "underline-offset": [
          {
            "underline-offset": [
              At,
              "auto",
              Fe,
              ze
            ]
          }
        ],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case"
        ],
        "text-overflow": [
          "truncate",
          "text-ellipsis",
          "text-clip"
        ],
        "text-wrap": [
          {
            text: [
              "wrap",
              "nowrap",
              "balance",
              "pretty"
            ]
          }
        ],
        indent: [
          {
            indent: x()
          }
        ],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              Fe,
              ze
            ]
          }
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces"
            ]
          }
        ],
        break: [
          {
            break: [
              "normal",
              "words",
              "all",
              "keep"
            ]
          }
        ],
        hyphens: [
          {
            hyphens: [
              "none",
              "manual",
              "auto"
            ]
          }
        ],
        content: [
          {
            content: [
              "none",
              Fe,
              ze
            ]
          }
        ],
        "bg-attachment": [
          {
            bg: [
              "fixed",
              "local",
              "scroll"
            ]
          }
        ],
        "bg-clip": [
          {
            "bg-clip": [
              "border",
              "padding",
              "content",
              "text"
            ]
          }
        ],
        "bg-origin": [
          {
            "bg-origin": [
              "border",
              "padding",
              "content"
            ]
          }
        ],
        "bg-position": [
          {
            bg: [
              ..._(),
              PCe,
              MCe
            ]
          }
        ],
        "bg-repeat": [
          {
            bg: [
              "no-repeat",
              {
                repeat: [
                  "",
                  "x",
                  "y",
                  "space",
                  "round"
                ]
              }
            ]
          }
        ],
        "bg-size": [
          {
            bg: [
              "auto",
              "cover",
              "contain",
              LCe,
              ICe
            ]
          }
        ],
        "bg-image": [
          {
            bg: [
              "none",
              {
                linear: [
                  {
                    to: [
                      "t",
                      "tr",
                      "r",
                      "br",
                      "b",
                      "bl",
                      "l",
                      "tl"
                    ]
                  },
                  Go,
                  Fe,
                  ze
                ],
                radial: [
                  "",
                  Fe,
                  ze
                ],
                conic: [
                  Go,
                  Fe,
                  ze
                ]
              },
              $Ce,
              DCe
            ]
          }
        ],
        "bg-color": [
          {
            bg: E()
          }
        ],
        "gradient-from-pos": [
          {
            from: O()
          }
        ],
        "gradient-via-pos": [
          {
            via: O()
          }
        ],
        "gradient-to-pos": [
          {
            to: O()
          }
        ],
        "gradient-from": [
          {
            from: E()
          }
        ],
        "gradient-via": [
          {
            via: E()
          }
        ],
        "gradient-to": [
          {
            to: E()
          }
        ],
        rounded: [
          {
            rounded: N()
          }
        ],
        "rounded-s": [
          {
            "rounded-s": N()
          }
        ],
        "rounded-e": [
          {
            "rounded-e": N()
          }
        ],
        "rounded-t": [
          {
            "rounded-t": N()
          }
        ],
        "rounded-r": [
          {
            "rounded-r": N()
          }
        ],
        "rounded-b": [
          {
            "rounded-b": N()
          }
        ],
        "rounded-l": [
          {
            "rounded-l": N()
          }
        ],
        "rounded-ss": [
          {
            "rounded-ss": N()
          }
        ],
        "rounded-se": [
          {
            "rounded-se": N()
          }
        ],
        "rounded-ee": [
          {
            "rounded-ee": N()
          }
        ],
        "rounded-es": [
          {
            "rounded-es": N()
          }
        ],
        "rounded-tl": [
          {
            "rounded-tl": N()
          }
        ],
        "rounded-tr": [
          {
            "rounded-tr": N()
          }
        ],
        "rounded-br": [
          {
            "rounded-br": N()
          }
        ],
        "rounded-bl": [
          {
            "rounded-bl": N()
          }
        ],
        "border-w": [
          {
            border: V()
          }
        ],
        "border-w-x": [
          {
            "border-x": V()
          }
        ],
        "border-w-y": [
          {
            "border-y": V()
          }
        ],
        "border-w-s": [
          {
            "border-s": V()
          }
        ],
        "border-w-e": [
          {
            "border-e": V()
          }
        ],
        "border-w-t": [
          {
            "border-t": V()
          }
        ],
        "border-w-r": [
          {
            "border-r": V()
          }
        ],
        "border-w-b": [
          {
            "border-b": V()
          }
        ],
        "border-w-l": [
          {
            "border-l": V()
          }
        ],
        "divide-x": [
          {
            "divide-x": V()
          }
        ],
        "divide-x-reverse": [
          "divide-x-reverse"
        ],
        "divide-y": [
          {
            "divide-y": V()
          }
        ],
        "divide-y-reverse": [
          "divide-y-reverse"
        ],
        "border-style": [
          {
            border: [
              ...H(),
              "hidden",
              "none"
            ]
          }
        ],
        "divide-style": [
          {
            divide: [
              ...H(),
              "hidden",
              "none"
            ]
          }
        ],
        "border-color": [
          {
            border: E()
          }
        ],
        "border-color-x": [
          {
            "border-x": E()
          }
        ],
        "border-color-y": [
          {
            "border-y": E()
          }
        ],
        "border-color-s": [
          {
            "border-s": E()
          }
        ],
        "border-color-e": [
          {
            "border-e": E()
          }
        ],
        "border-color-t": [
          {
            "border-t": E()
          }
        ],
        "border-color-r": [
          {
            "border-r": E()
          }
        ],
        "border-color-b": [
          {
            "border-b": E()
          }
        ],
        "border-color-l": [
          {
            "border-l": E()
          }
        ],
        "divide-color": [
          {
            divide: E()
          }
        ],
        "outline-style": [
          {
            outline: [
              ...H(),
              "none",
              "hidden"
            ]
          }
        ],
        "outline-offset": [
          {
            "outline-offset": [
              At,
              Fe,
              ze
            ]
          }
        ],
        "outline-w": [
          {
            outline: [
              "",
              At,
              Xh,
              il
            ]
          }
        ],
        "outline-color": [
          {
            outline: [
              t
            ]
          }
        ],
        shadow: [
          {
            shadow: [
              "",
              "none",
              c,
              RCe,
              ECe
            ]
          }
        ],
        "shadow-color": [
          {
            shadow: E()
          }
        ],
        "inset-shadow": [
          {
            "inset-shadow": [
              "none",
              Fe,
              ze,
              h
            ]
          }
        ],
        "inset-shadow-color": [
          {
            "inset-shadow": E()
          }
        ],
        "ring-w": [
          {
            ring: V()
          }
        ],
        "ring-w-inset": [
          "ring-inset"
        ],
        "ring-color": [
          {
            ring: E()
          }
        ],
        "ring-offset-w": [
          {
            "ring-offset": [
              At,
              il
            ]
          }
        ],
        "ring-offset-color": [
          {
            "ring-offset": E()
          }
        ],
        "inset-ring-w": [
          {
            "inset-ring": V()
          }
        ],
        "inset-ring-color": [
          {
            "inset-ring": E()
          }
        ],
        opacity: [
          {
            opacity: [
              At,
              Fe,
              ze
            ]
          }
        ],
        "mix-blend": [
          {
            "mix-blend": [
              ...G(),
              "plus-darker",
              "plus-lighter"
            ]
          }
        ],
        "bg-blend": [
          {
            "bg-blend": G()
          }
        ],
        filter: [
          {
            filter: [
              "",
              "none",
              Fe,
              ze
            ]
          }
        ],
        blur: [
          {
            blur: Y()
          }
        ],
        brightness: [
          {
            brightness: [
              At,
              Fe,
              ze
            ]
          }
        ],
        contrast: [
          {
            contrast: [
              At,
              Fe,
              ze
            ]
          }
        ],
        "drop-shadow": [
          {
            "drop-shadow": [
              "",
              "none",
              f,
              Fe,
              ze
            ]
          }
        ],
        grayscale: [
          {
            grayscale: [
              "",
              At,
              Fe,
              ze
            ]
          }
        ],
        "hue-rotate": [
          {
            "hue-rotate": [
              At,
              Fe,
              ze
            ]
          }
        ],
        invert: [
          {
            invert: [
              "",
              At,
              Fe,
              ze
            ]
          }
        ],
        saturate: [
          {
            saturate: [
              At,
              Fe,
              ze
            ]
          }
        ],
        sepia: [
          {
            sepia: [
              "",
              At,
              Fe,
              ze
            ]
          }
        ],
        "backdrop-filter": [
          {
            "backdrop-filter": [
              "",
              "none",
              Fe,
              ze
            ]
          }
        ],
        "backdrop-blur": [
          {
            "backdrop-blur": Y()
          }
        ],
        "backdrop-brightness": [
          {
            "backdrop-brightness": [
              At,
              Fe,
              ze
            ]
          }
        ],
        "backdrop-contrast": [
          {
            "backdrop-contrast": [
              At,
              Fe,
              ze
            ]
          }
        ],
        "backdrop-grayscale": [
          {
            "backdrop-grayscale": [
              "",
              At,
              Fe,
              ze
            ]
          }
        ],
        "backdrop-hue-rotate": [
          {
            "backdrop-hue-rotate": [
              At,
              Fe,
              ze
            ]
          }
        ],
        "backdrop-invert": [
          {
            "backdrop-invert": [
              "",
              At,
              Fe,
              ze
            ]
          }
        ],
        "backdrop-opacity": [
          {
            "backdrop-opacity": [
              At,
              Fe,
              ze
            ]
          }
        ],
        "backdrop-saturate": [
          {
            "backdrop-saturate": [
              At,
              Fe,
              ze
            ]
          }
        ],
        "backdrop-sepia": [
          {
            "backdrop-sepia": [
              "",
              At,
              Fe,
              ze
            ]
          }
        ],
        "border-collapse": [
          {
            border: [
              "collapse",
              "separate"
            ]
          }
        ],
        "border-spacing": [
          {
            "border-spacing": x()
          }
        ],
        "border-spacing-x": [
          {
            "border-spacing-x": x()
          }
        ],
        "border-spacing-y": [
          {
            "border-spacing-y": x()
          }
        ],
        "table-layout": [
          {
            table: [
              "auto",
              "fixed"
            ]
          }
        ],
        caption: [
          {
            caption: [
              "top",
              "bottom"
            ]
          }
        ],
        transition: [
          {
            transition: [
              "",
              "all",
              "colors",
              "opacity",
              "shadow",
              "transform",
              "none",
              Fe,
              ze
            ]
          }
        ],
        "transition-behavior": [
          {
            transition: [
              "normal",
              "discrete"
            ]
          }
        ],
        duration: [
          {
            duration: [
              At,
              "initial",
              Fe,
              ze
            ]
          }
        ],
        ease: [
          {
            ease: [
              "linear",
              "initial",
              g,
              Fe,
              ze
            ]
          }
        ],
        delay: [
          {
            delay: [
              At,
              Fe,
              ze
            ]
          }
        ],
        animate: [
          {
            animate: [
              "none",
              m,
              Fe,
              ze
            ]
          }
        ],
        backface: [
          {
            backface: [
              "hidden",
              "visible"
            ]
          }
        ],
        perspective: [
          {
            perspective: [
              p,
              Fe,
              ze
            ]
          }
        ],
        "perspective-origin": [
          {
            "perspective-origin": U()
          }
        ],
        rotate: [
          {
            rotate: Z()
          }
        ],
        "rotate-x": [
          {
            "rotate-x": Z()
          }
        ],
        "rotate-y": [
          {
            "rotate-y": Z()
          }
        ],
        "rotate-z": [
          {
            "rotate-z": Z()
          }
        ],
        scale: [
          {
            scale: ee()
          }
        ],
        "scale-x": [
          {
            "scale-x": ee()
          }
        ],
        "scale-y": [
          {
            "scale-y": ee()
          }
        ],
        "scale-z": [
          {
            "scale-z": ee()
          }
        ],
        "scale-3d": [
          "scale-3d"
        ],
        skew: [
          {
            skew: we()
          }
        ],
        "skew-x": [
          {
            "skew-x": we()
          }
        ],
        "skew-y": [
          {
            "skew-y": we()
          }
        ],
        transform: [
          {
            transform: [
              Fe,
              ze,
              "",
              "none",
              "gpu",
              "cpu"
            ]
          }
        ],
        "transform-origin": [
          {
            origin: U()
          }
        ],
        "transform-style": [
          {
            transform: [
              "3d",
              "flat"
            ]
          }
        ],
        translate: [
          {
            translate: Te()
          }
        ],
        "translate-x": [
          {
            "translate-x": Te()
          }
        ],
        "translate-y": [
          {
            "translate-y": Te()
          }
        ],
        "translate-z": [
          {
            "translate-z": Te()
          }
        ],
        "translate-none": [
          "translate-none"
        ],
        accent: [
          {
            accent: E()
          }
        ],
        appearance: [
          {
            appearance: [
              "none",
              "auto"
            ]
          }
        ],
        "caret-color": [
          {
            caret: E()
          }
        ],
        "color-scheme": [
          {
            scheme: [
              "normal",
              "dark",
              "light",
              "light-dark",
              "only-dark",
              "only-light"
            ]
          }
        ],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              Fe,
              ze
            ]
          }
        ],
        "field-sizing": [
          {
            "field-sizing": [
              "fixed",
              "content"
            ]
          }
        ],
        "pointer-events": [
          {
            "pointer-events": [
              "auto",
              "none"
            ]
          }
        ],
        resize: [
          {
            resize: [
              "none",
              "",
              "y",
              "x"
            ]
          }
        ],
        "scroll-behavior": [
          {
            scroll: [
              "auto",
              "smooth"
            ]
          }
        ],
        "scroll-m": [
          {
            "scroll-m": x()
          }
        ],
        "scroll-mx": [
          {
            "scroll-mx": x()
          }
        ],
        "scroll-my": [
          {
            "scroll-my": x()
          }
        ],
        "scroll-ms": [
          {
            "scroll-ms": x()
          }
        ],
        "scroll-me": [
          {
            "scroll-me": x()
          }
        ],
        "scroll-mt": [
          {
            "scroll-mt": x()
          }
        ],
        "scroll-mr": [
          {
            "scroll-mr": x()
          }
        ],
        "scroll-mb": [
          {
            "scroll-mb": x()
          }
        ],
        "scroll-ml": [
          {
            "scroll-ml": x()
          }
        ],
        "scroll-p": [
          {
            "scroll-p": x()
          }
        ],
        "scroll-px": [
          {
            "scroll-px": x()
          }
        ],
        "scroll-py": [
          {
            "scroll-py": x()
          }
        ],
        "scroll-ps": [
          {
            "scroll-ps": x()
          }
        ],
        "scroll-pe": [
          {
            "scroll-pe": x()
          }
        ],
        "scroll-pt": [
          {
            "scroll-pt": x()
          }
        ],
        "scroll-pr": [
          {
            "scroll-pr": x()
          }
        ],
        "scroll-pb": [
          {
            "scroll-pb": x()
          }
        ],
        "scroll-pl": [
          {
            "scroll-pl": x()
          }
        ],
        "snap-align": [
          {
            snap: [
              "start",
              "end",
              "center",
              "align-none"
            ]
          }
        ],
        "snap-stop": [
          {
            snap: [
              "normal",
              "always"
            ]
          }
        ],
        "snap-type": [
          {
            snap: [
              "none",
              "x",
              "y",
              "both"
            ]
          }
        ],
        "snap-strictness": [
          {
            snap: [
              "mandatory",
              "proximity"
            ]
          }
        ],
        touch: [
          {
            touch: [
              "auto",
              "none",
              "manipulation"
            ]
          }
        ],
        "touch-x": [
          {
            "touch-pan": [
              "x",
              "left",
              "right"
            ]
          }
        ],
        "touch-y": [
          {
            "touch-pan": [
              "y",
              "up",
              "down"
            ]
          }
        ],
        "touch-pz": [
          "touch-pinch-zoom"
        ],
        select: [
          {
            select: [
              "none",
              "text",
              "all",
              "auto"
            ]
          }
        ],
        "will-change": [
          {
            "will-change": [
              "auto",
              "scroll",
              "contents",
              "transform",
              Fe,
              ze
            ]
          }
        ],
        fill: [
          {
            fill: [
              "none",
              ...E()
            ]
          }
        ],
        "stroke-w": [
          {
            stroke: [
              At,
              Xh,
              il,
              W1
            ]
          }
        ],
        stroke: [
          {
            stroke: [
              "none",
              ...E()
            ]
          }
        ],
        "forced-color-adjust": [
          {
            "forced-color-adjust": [
              "auto",
              "none"
            ]
          }
        ]
      },
      conflictingClassGroups: {
        overflow: [
          "overflow-x",
          "overflow-y"
        ],
        overscroll: [
          "overscroll-x",
          "overscroll-y"
        ],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left"
        ],
        "inset-x": [
          "right",
          "left"
        ],
        "inset-y": [
          "top",
          "bottom"
        ],
        flex: [
          "basis",
          "grow",
          "shrink"
        ],
        gap: [
          "gap-x",
          "gap-y"
        ],
        p: [
          "px",
          "py",
          "ps",
          "pe",
          "pt",
          "pr",
          "pb",
          "pl"
        ],
        px: [
          "pr",
          "pl"
        ],
        py: [
          "pt",
          "pb"
        ],
        m: [
          "mx",
          "my",
          "ms",
          "me",
          "mt",
          "mr",
          "mb",
          "ml"
        ],
        mx: [
          "mr",
          "ml"
        ],
        my: [
          "mt",
          "mb"
        ],
        size: [
          "w",
          "h"
        ],
        "font-size": [
          "leading"
        ],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction"
        ],
        "fvn-ordinal": [
          "fvn-normal"
        ],
        "fvn-slashed-zero": [
          "fvn-normal"
        ],
        "fvn-figure": [
          "fvn-normal"
        ],
        "fvn-spacing": [
          "fvn-normal"
        ],
        "fvn-fraction": [
          "fvn-normal"
        ],
        "line-clamp": [
          "display",
          "overflow"
        ],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-s": [
          "rounded-ss",
          "rounded-es"
        ],
        "rounded-e": [
          "rounded-se",
          "rounded-ee"
        ],
        "rounded-t": [
          "rounded-tl",
          "rounded-tr"
        ],
        "rounded-r": [
          "rounded-tr",
          "rounded-br"
        ],
        "rounded-b": [
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-l": [
          "rounded-tl",
          "rounded-bl"
        ],
        "border-spacing": [
          "border-spacing-x",
          "border-spacing-y"
        ],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l"
        ],
        "border-w-x": [
          "border-w-r",
          "border-w-l"
        ],
        "border-w-y": [
          "border-w-t",
          "border-w-b"
        ],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l"
        ],
        "border-color-x": [
          "border-color-r",
          "border-color-l"
        ],
        "border-color-y": [
          "border-color-t",
          "border-color-b"
        ],
        translate: [
          "translate-x",
          "translate-y",
          "translate-none"
        ],
        "translate-none": [
          "translate",
          "translate-x",
          "translate-y",
          "translate-z"
        ],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml"
        ],
        "scroll-mx": [
          "scroll-mr",
          "scroll-ml"
        ],
        "scroll-my": [
          "scroll-mt",
          "scroll-mb"
        ],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl"
        ],
        "scroll-px": [
          "scroll-pr",
          "scroll-pl"
        ],
        "scroll-py": [
          "scroll-pt",
          "scroll-pb"
        ],
        touch: [
          "touch-x",
          "touch-y",
          "touch-pz"
        ],
        "touch-x": [
          "touch"
        ],
        "touch-y": [
          "touch"
        ],
        "touch-pz": [
          "touch"
        ]
      },
      conflictingClassGroupModifiers: {
        "font-size": [
          "leading"
        ]
      },
      orderSensitiveModifiers: [
        "before",
        "after",
        "placeholder",
        "file",
        "marker",
        "selection",
        "first-line",
        "first-letter",
        "backdrop",
        "*",
        "**"
      ]
    };
  }, GCe = vCe(VCe);
  function jr(...t) {
    return GCe(a7(t));
  }
  function Zd(t, e) {
    const r = typeof t == "string" && !e ? `${t}Context` : e, n = Symbol(r);
    return [
      (i) => {
        const a = mF(n, i);
        if (a || a === null) return a;
        throw new Error(`Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(t) ? `one of the following components: ${t.join(", ")}` : `\`${t}\``}`);
      },
      (i) => (tK(n, i), i)
    ];
  }
  function p7(t, e, r) {
    const n = r.originalEvent.target, i = new CustomEvent(t, {
      bubbles: false,
      cancelable: true,
      detail: r
    });
    e && n.addEventListener(t, e, {
      once: true
    }), n.dispatchEvent(i);
  }
  function v7(t) {
    return Qj() ? (Jj(t), true) : false;
  }
  function WCe(t) {
    let e = false, r;
    const n = zS(true);
    return (...i) => (e || (r = n.run(() => t(...i)), e = true), r);
  }
  function HCe(t) {
    let e = 0, r, n;
    const i = () => {
      e -= 1, n && e <= 0 && (n.stop(), r = void 0, n = void 0);
    };
    return (...a) => (e += 1, r || (n = zS(true), r = n.run(() => t(...a))), v7(i), r);
  }
  function lA(t) {
    return typeof t == "function" ? t() : Q(t);
  }
  const pu = typeof window < "u" && typeof document < "u";
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const UCe = (t) => typeof t < "u", YCe = Object.prototype.toString, qCe = (t) => YCe.call(t) === "[object Object]", XCe = () => {
  }, sF = jCe();
  function jCe() {
    var t, e;
    return pu && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
  }
  function KCe(t) {
    return jn();
  }
  function ZCe(t, e) {
    KCe() && Zj(t, e);
  }
  function Qd(t) {
    var e;
    const r = lA(t);
    return (e = r == null ? void 0 : r.$el) != null ? e : r;
  }
  const uA = pu ? window : void 0;
  function g7(...t) {
    let e, r, n, i;
    if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([r, n, i] = t, e = uA) : [e, r, n, i] = t, !e) return XCe;
    Array.isArray(r) || (r = [
      r
    ]), Array.isArray(n) || (n = [
      n
    ]);
    const a = [], o = () => {
      a.forEach((c) => c()), a.length = 0;
    }, s = (c, h, f, d) => (c.addEventListener(h, f, d), () => c.removeEventListener(h, f, d)), l = nn(() => [
      Qd(e),
      lA(i)
    ], ([c, h]) => {
      if (o(), !c) return;
      const f = qCe(h) ? {
        ...h
      } : h;
      a.push(...r.flatMap((d) => n.map((p) => s(c, d, p, f))));
    }, {
      immediate: true,
      flush: "post"
    }), u = () => {
      l(), o();
    };
    return v7(u), u;
  }
  function QCe(t) {
    return typeof t == "function" ? t : typeof t == "string" ? (e) => e.key === t : Array.isArray(t) ? (e) => t.includes(e.key) : () => true;
  }
  function JCe(...t) {
    let e, r, n = {};
    t.length === 3 ? (e = t[0], r = t[1], n = t[2]) : t.length === 2 ? typeof t[1] == "object" ? (e = true, r = t[0], n = t[1]) : (e = t[0], r = t[1]) : (e = true, r = t[0]);
    const { target: i = uA, eventName: a = "keydown", passive: o = false, dedupe: s = false } = n, l = QCe(e);
    return g7(i, a, (u) => {
      u.repeat && lA(s) || l(u) && r(u);
    }, o);
  }
  function eAe() {
    const t = ot(false), e = jn();
    return e && Oc(() => {
      t.value = true;
    }, e), t;
  }
  function tAe(t) {
    return JSON.parse(JSON.stringify(t));
  }
  function cA(t, e, r, n = {}) {
    var i, a, o;
    const { clone: s = false, passive: l = false, eventName: u, deep: c = false, defaultValue: h, shouldEmit: f } = n, d = jn(), p = r || (d == null ? void 0 : d.emit) || ((i = d == null ? void 0 : d.$emit) == null ? void 0 : i.bind(d)) || ((o = (a = d == null ? void 0 : d.proxy) == null ? void 0 : a.$emit) == null ? void 0 : o.bind(d == null ? void 0 : d.proxy));
    let v = u;
    e || (e = "modelValue"), v = v || `update:${e.toString()}`;
    const g = (_) => s ? typeof s == "function" ? s(_) : tAe(_) : _, m = () => UCe(t[e]) ? g(t[e]) : h, y = (_) => {
      f ? f(_) && p(v, _) : p(v, _);
    };
    if (l) {
      const _ = m(), b = ot(_);
      let w = false;
      return nn(() => t[e], (x) => {
        w || (w = true, b.value = g(x), bo(() => w = false));
      }), nn(b, (x) => {
        !w && (x !== t[e] || c) && y(x);
      }, {
        deep: c
      }), b;
    } else return St({
      get() {
        return m();
      },
      set(_) {
        y(_);
      }
    });
  }
  function hA(t) {
    return t ? t.flatMap((e) => e.type === Bf ? hA(e.children) : [
      e
    ]) : [];
  }
  function Ea() {
    let t = document.activeElement;
    if (t == null) return null;
    for (; t != null && t.shadowRoot != null && t.shadowRoot.activeElement != null; ) t = t.shadowRoot.activeElement;
    return t;
  }
  function H1(t) {
    if (t === null || typeof t != "object") return false;
    const e = Object.getPrototypeOf(t);
    return e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.iterator in t ? false : Symbol.toStringTag in t ? Object.prototype.toString.call(t) === "[object Module]" : true;
  }
  function BS(t, e, r = ".", n) {
    if (!H1(e)) return BS(t, {}, r);
    const i = Object.assign({}, e);
    for (const a in t) {
      if (a === "__proto__" || a === "constructor") continue;
      const o = t[a];
      o != null && (Array.isArray(o) && Array.isArray(i[a]) ? i[a] = [
        ...o,
        ...i[a]
      ] : H1(o) && H1(i[a]) ? i[a] = BS(o, i[a], (r ? `${r}.` : "") + a.toString()) : i[a] = o);
    }
    return i;
  }
  function rAe(t) {
    return (...e) => e.reduce((r, n) => BS(r, n, ""), {});
  }
  const nAe = rAe(), [fA, XMe] = Zd("ConfigProvider");
  let iAe = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", aAe = (t = 21) => {
    let e = "", r = t;
    for (; r--; ) e += iAe[Math.random() * 64 | 0];
    return e;
  };
  const oAe = HCe(() => {
    const t = ot(/* @__PURE__ */ new Map()), e = ot(), r = St(() => {
      for (const o of t.value.values()) if (o) return true;
      return false;
    }), n = fA({
      scrollBody: ot(true)
    });
    let i = null;
    const a = () => {
      document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = e.value ?? "", sF && (i == null ? void 0 : i()), e.value = void 0;
    };
    return nn(r, (o, s) => {
      var l;
      if (!pu) return;
      if (!o) {
        s && a();
        return;
      }
      e.value === void 0 && (e.value = document.body.style.overflow);
      const u = window.innerWidth - document.documentElement.clientWidth, c = {
        padding: u,
        margin: 0
      }, h = (l = n.scrollBody) != null && l.value ? typeof n.scrollBody.value == "object" ? nAe({
        padding: n.scrollBody.value.padding === true ? u : n.scrollBody.value.padding,
        margin: n.scrollBody.value.margin === true ? u : n.scrollBody.value.margin
      }, c) : c : {
        padding: 0,
        margin: 0
      };
      u > 0 && (document.body.style.paddingRight = typeof h.padding == "number" ? `${h.padding}px` : String(h.padding), document.body.style.marginRight = typeof h.margin == "number" ? `${h.margin}px` : String(h.margin), document.body.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), sF && (i = g7(document, "touchmove", (f) => lAe(f), {
        passive: false
      })), bo(() => {
        document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
      });
    }, {
      immediate: true,
      flush: "sync"
    }), t;
  });
  function sAe(t) {
    const e = aAe(6), r = oAe();
    r.value.set(e, t);
    const n = St({
      get: () => r.value.get(e) ?? false,
      set: (i) => r.value.set(e, i)
    });
    return ZCe(() => {
      r.value.delete(e);
    }), n;
  }
  function m7(t) {
    const e = window.getComputedStyle(t);
    if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight) return true;
    {
      const r = t.parentNode;
      return !(r instanceof Element) || r.tagName === "BODY" ? false : m7(r);
    }
  }
  function lAe(t) {
    const e = t || window.event, r = e.target;
    return r instanceof Element && m7(r) ? false : e.touches.length > 1 ? true : (e.preventDefault && e.cancelable && e.preventDefault(), false);
  }
  function y7(t) {
    const e = fA({
      dir: ot("ltr")
    });
    return St(() => {
      var r;
      return (t == null ? void 0 : t.value) || ((r = e.dir) == null ? void 0 : r.value) || "ltr";
    });
  }
  function My(t) {
    const e = jn(), r = e == null ? void 0 : e.type.emits, n = {};
    return r != null && r.length || console.warn(`No emitted event found. Please check component: ${e == null ? void 0 : e.type.__name}`), r == null ? void 0 : r.forEach((i) => {
      n[Yj(yF(i))] = (...a) => t(i, ...a);
    }), n;
  }
  function dA(t) {
    const e = jn(), r = Object.keys((e == null ? void 0 : e.type.props) ?? {}).reduce((i, a) => {
      const o = (e == null ? void 0 : e.type.props[a]).default;
      return o !== void 0 && (i[a] = o), i;
    }, {}), n = Uj(t);
    return St(() => {
      const i = {}, a = (e == null ? void 0 : e.vnode.props) ?? {};
      return Object.keys(a).forEach((o) => {
        i[yF(o)] = a[o];
      }), Object.keys({
        ...r,
        ...i
      }).reduce((o, s) => (n.value[s] !== void 0 && (o[s] = n.value[s]), o), {});
    });
  }
  function pA(t, e) {
    const r = dA(t), n = e ? My(e) : {};
    return St(() => ({
      ...r.value,
      ...n
    }));
  }
  function On() {
    const t = jn(), e = ot(), r = St(() => {
      var o, s;
      return [
        "#text",
        "#comment"
      ].includes((o = e.value) == null ? void 0 : o.$el.nodeName) ? (s = e.value) == null ? void 0 : s.$el.nextElementSibling : Qd(e);
    }), n = Object.assign({}, t.exposed), i = {};
    for (const o in t.props) Object.defineProperty(i, o, {
      enumerable: true,
      configurable: true,
      get: () => t.props[o]
    });
    if (Object.keys(n).length > 0) for (const o in n) Object.defineProperty(i, o, {
      enumerable: true,
      configurable: true,
      get: () => n[o]
    });
    Object.defineProperty(i, "$el", {
      enumerable: true,
      configurable: true,
      get: () => t.vnode.el
    }), t.exposed = i;
    function a(o) {
      e.value = o, o && (Object.defineProperty(i, "$el", {
        enumerable: true,
        configurable: true,
        get: () => o instanceof Element ? o : o.$el
      }), t.exposed = i);
    }
    return {
      forwardRef: a,
      currentRef: e,
      currentElement: r
    };
  }
  var uAe = function(t) {
    if (typeof document > "u") return null;
    var e = Array.isArray(t) ? t[0] : t;
    return e.ownerDocument.body;
  }, Wu = /* @__PURE__ */ new WeakMap(), Hv = /* @__PURE__ */ new WeakMap(), Uv = {}, U1 = 0, _7 = function(t) {
    return t && (t.host || _7(t.parentNode));
  }, cAe = function(t, e) {
    return e.map(function(r) {
      if (t.contains(r)) return r;
      var n = _7(r);
      return n && t.contains(n) ? n : (console.error("aria-hidden", r, "in not contained inside", t, ". Doing nothing"), null);
    }).filter(function(r) {
      return !!r;
    });
  }, hAe = function(t, e, r, n) {
    var i = cAe(e, Array.isArray(t) ? t : [
      t
    ]);
    Uv[r] || (Uv[r] = /* @__PURE__ */ new WeakMap());
    var a = Uv[r], o = [], s = /* @__PURE__ */ new Set(), l = new Set(i), u = function(h) {
      !h || s.has(h) || (s.add(h), u(h.parentNode));
    };
    i.forEach(u);
    var c = function(h) {
      !h || l.has(h) || Array.prototype.forEach.call(h.children, function(f) {
        if (s.has(f)) c(f);
        else try {
          var d = f.getAttribute(n), p = d !== null && d !== "false", v = (Wu.get(f) || 0) + 1, g = (a.get(f) || 0) + 1;
          Wu.set(f, v), a.set(f, g), o.push(f), v === 1 && p && Hv.set(f, true), g === 1 && f.setAttribute(r, "true"), p || f.setAttribute(n, "true");
        } catch (m) {
          console.error("aria-hidden: cannot operate on ", f, m);
        }
      });
    };
    return c(e), s.clear(), U1++, function() {
      o.forEach(function(h) {
        var f = Wu.get(h) - 1, d = a.get(h) - 1;
        Wu.set(h, f), a.set(h, d), f || (Hv.has(h) || h.removeAttribute(n), Hv.delete(h)), d || h.removeAttribute(r);
      }), U1--, U1 || (Wu = /* @__PURE__ */ new WeakMap(), Wu = /* @__PURE__ */ new WeakMap(), Hv = /* @__PURE__ */ new WeakMap(), Uv = {});
    };
  }, fAe = function(t, e, r) {
    r === void 0 && (r = "data-aria-hidden");
    var n = Array.from(Array.isArray(t) ? t : [
      t
    ]), i = uAe(t);
    return i ? (n.push.apply(n, Array.from(i.querySelectorAll("[aria-live]"))), hAe(n, i, r, "aria-hidden")) : function() {
      return null;
    };
  };
  function dAe(t) {
    let e;
    nn(() => Qd(t), (r) => {
      r ? e = fAe(r) : e && e();
    }), Lm(() => {
      e && e();
    });
  }
  let pAe = 0;
  function Pm(t, e = "radix") {
    const r = fA({
      useId: void 0
    });
    return _M ? `${e}-${_M()}` : r.useId ? `${e}-${r.useId()}` : `${e}-${++pAe}`;
  }
  function vAe(t, e) {
    const r = ot(t);
    function n(i) {
      return e[r.value][i] ?? r.value;
    }
    return {
      state: r,
      dispatch: (i) => {
        r.value = n(i);
      }
    };
  }
  const vA = ht({
    name: "PrimitiveSlot",
    inheritAttrs: false,
    setup(t, { attrs: e, slots: r }) {
      return () => {
        var n, i;
        if (!r.default) return null;
        const a = hA(r.default()), o = a.findIndex((c) => c.type !== qj);
        if (o === -1) return a;
        const s = a[o];
        (n = s.props) == null || delete n.ref;
        const l = s.props ? Ln(e, s.props) : e;
        e.class && (i = s.props) != null && i.class && delete s.props.class;
        const u = Xj(s, l);
        for (const c in l) c.startsWith("on") && (u.props || (u.props = {}), u.props[c] = l[c]);
        return a.length === 1 ? u : (a[o] = u, a);
      };
    }
  }), Ci = ht({
    name: "Primitive",
    inheritAttrs: false,
    props: {
      asChild: {
        type: Boolean,
        default: false
      },
      as: {
        type: [
          String,
          Object
        ],
        default: "div"
      }
    },
    setup(t, { attrs: e, slots: r }) {
      const n = t.asChild ? "template" : t.as;
      return typeof n == "string" && [
        "area",
        "img",
        "input"
      ].includes(n) ? () => Hi(n, e) : n !== "template" ? () => Hi(t.as, e, {
        default: r.default
      }) : () => Hi(vA, e, {
        default: r.default
      });
    }
  });
  function b7() {
    const t = ot(), e = St(() => {
      var r, n;
      return [
        "#text",
        "#comment"
      ].includes((r = t.value) == null ? void 0 : r.$el.nodeName) ? (n = t.value) == null ? void 0 : n.$el.nextElementSibling : Qd(t);
    });
    return {
      primitiveElement: t,
      currentElement: e
    };
  }
  function gAe(t, e) {
    var r;
    const n = ot({}), i = ot("none"), a = ot(t), o = t.value ? "mounted" : "unmounted";
    let s;
    const l = ((r = e.value) == null ? void 0 : r.ownerDocument.defaultView) ?? uA, { state: u, dispatch: c } = vAe(o, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    }), h = (g) => {
      var m;
      if (pu) {
        const y = new CustomEvent(g, {
          bubbles: false,
          cancelable: false
        });
        (m = e.value) == null || m.dispatchEvent(y);
      }
    };
    nn(t, async (g, m) => {
      var y;
      const _ = m !== g;
      if (await bo(), _) {
        const b = i.value, w = Yv(e.value);
        g ? (c("MOUNT"), h("enter"), w === "none" && h("after-enter")) : w === "none" || ((y = n.value) == null ? void 0 : y.display) === "none" ? (c("UNMOUNT"), h("leave"), h("after-leave")) : m && b !== w ? (c("ANIMATION_OUT"), h("leave")) : (c("UNMOUNT"), h("after-leave"));
      }
    }, {
      immediate: true
    });
    const f = (g) => {
      const m = Yv(e.value), y = m.includes(g.animationName), _ = u.value === "mounted" ? "enter" : "leave";
      if (g.target === e.value && y && (h(`after-${_}`), c("ANIMATION_END"), !a.value)) {
        const b = e.value.style.animationFillMode;
        e.value.style.animationFillMode = "forwards", s = l == null ? void 0 : l.setTimeout(() => {
          var w;
          ((w = e.value) == null ? void 0 : w.style.animationFillMode) === "forwards" && (e.value.style.animationFillMode = b);
        });
      }
      g.target === e.value && m === "none" && c("ANIMATION_END");
    }, d = (g) => {
      g.target === e.value && (i.value = Yv(e.value));
    }, p = nn(e, (g, m) => {
      g ? (n.value = getComputedStyle(g), g.addEventListener("animationstart", d), g.addEventListener("animationcancel", f), g.addEventListener("animationend", f)) : (c("ANIMATION_END"), s !== void 0 && (l == null ? void 0 : l.clearTimeout(s)), m == null ? void 0 : m.removeEventListener("animationstart", d), m == null ? void 0 : m.removeEventListener("animationcancel", f), m == null ? void 0 : m.removeEventListener("animationend", f));
    }, {
      immediate: true
    }), v = nn(u, () => {
      const g = Yv(e.value);
      i.value = u.value === "mounted" ? g : "none";
    });
    return Lm(() => {
      p(), v();
    }), {
      isPresent: St(() => [
        "mounted",
        "unmountSuspended"
      ].includes(u.value))
    };
  }
  function Yv(t) {
    return t && getComputedStyle(t).animationName || "none";
  }
  const gA = ht({
    name: "Presence",
    props: {
      present: {
        type: Boolean,
        required: true
      },
      forceMount: {
        type: Boolean
      }
    },
    slots: {},
    setup(t, { slots: e, expose: r }) {
      var n;
      const { present: i, forceMount: a } = Id(t), o = ot(), { isPresent: s } = gAe(i, o);
      r({
        present: s
      });
      let l = e.default({
        present: s
      });
      l = hA(l || []);
      const u = jn();
      if (l && (l == null ? void 0 : l.length) > 1) {
        const c = (n = u == null ? void 0 : u.parent) != null && n.type.name ? `<${u.parent.type.name} />` : "component";
        throw new Error([
          `Detected an invalid children for \`${c}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((h) => `  - ${h}`).join(`
`)
        ].join(`
`));
      }
      return () => a.value || i.value || s.value ? Hi(e.default({
        present: s
      })[0], {
        ref: (c) => {
          const h = Qd(c);
          return typeof (h == null ? void 0 : h.hasAttribute) > "u" || (h != null && h.hasAttribute("data-radix-popper-content-wrapper") ? o.value = h.firstElementChild : o.value = h), h;
        }
      }) : null;
    }
  }), [As, mAe] = Zd("DialogRoot"), yAe = ht({
    inheritAttrs: false,
    __name: "DialogRoot",
    props: {
      open: {
        type: Boolean,
        default: void 0
      },
      defaultOpen: {
        type: Boolean,
        default: false
      },
      modal: {
        type: Boolean,
        default: true
      }
    },
    emits: [
      "update:open"
    ],
    setup(t, { emit: e }) {
      const r = t, n = cA(r, "open", e, {
        defaultValue: r.defaultOpen,
        passive: r.open === void 0
      }), i = ot(), a = ot(), { modal: o } = Id(r);
      return mAe({
        open: n,
        modal: o,
        openModal: () => {
          n.value = true;
        },
        onOpenChange: (s) => {
          n.value = s;
        },
        onOpenToggle: () => {
          n.value = !n.value;
        },
        contentId: "",
        titleId: "",
        descriptionId: "",
        triggerElement: i,
        contentElement: a
      }), (s, l) => Tt(s.$slots, "default", {
        open: Q(n)
      });
    }
  }), _Ae = ht({
    __name: "Teleport",
    props: {
      to: {
        default: "body"
      },
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(t) {
      const e = eAe();
      return (r, n) => Q(e) || r.forceMount ? (dt(), Wt(Kj, {
        key: 0,
        to: r.to,
        disabled: r.disabled
      }, [
        Tt(r.$slots, "default")
      ], 8, [
        "to",
        "disabled"
      ])) : zf("", true);
    }
  }), bAe = ht({
    __name: "DialogPortal",
    props: {
      to: {},
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), Wt(Q(_Ae), FS(VS(e)), {
        default: Me(() => [
          Tt(r.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), xAe = "dismissableLayer.pointerDownOutside", wAe = "dismissableLayer.focusOutside";
  function x7(t, e) {
    const r = e.closest("[data-dismissable-layer]"), n = t.dataset.dismissableLayer === "" ? t : t.querySelector("[data-dismissable-layer]"), i = Array.from(t.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
    return !!(r && n === r || i.indexOf(n) < i.indexOf(r));
  }
  function SAe(t, e) {
    var r;
    const n = ((r = e == null ? void 0 : e.value) == null ? void 0 : r.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = ot(false), a = ot(() => {
    });
    return Hl((o) => {
      if (!pu) return;
      const s = async (u) => {
        const c = u.target;
        if (e != null && e.value) {
          if (x7(e.value, c)) {
            i.value = false;
            return;
          }
          if (u.target && !i.value) {
            let h = function() {
              p7(xAe, t, f);
            };
            const f = {
              originalEvent: u
            };
            u.pointerType === "touch" ? (n.removeEventListener("click", a.value), a.value = h, n.addEventListener("click", a.value, {
              once: true
            })) : h();
          } else n.removeEventListener("click", a.value);
          i.value = false;
        }
      }, l = window.setTimeout(() => {
        n.addEventListener("pointerdown", s);
      }, 0);
      o(() => {
        window.clearTimeout(l), n.removeEventListener("pointerdown", s), n.removeEventListener("click", a.value);
      });
    }), {
      onPointerDownCapture: () => i.value = true
    };
  }
  function TAe(t, e) {
    var r;
    const n = ((r = e == null ? void 0 : e.value) == null ? void 0 : r.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = ot(false);
    return Hl((a) => {
      if (!pu) return;
      const o = async (s) => {
        e != null && e.value && (await bo(), !(!e.value || x7(e.value, s.target)) && s.target && !i.value && p7(wAe, t, {
          originalEvent: s
        }));
      };
      n.addEventListener("focusin", o), a(() => n.removeEventListener("focusin", o));
    }), {
      onFocusCapture: () => i.value = true,
      onBlurCapture: () => i.value = false
    };
  }
  const ja = _F({
    layersRoot: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  }), CAe = ht({
    __name: "DismissableLayer",
    props: {
      disableOutsidePointerEvents: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "dismiss"
    ],
    setup(t, { emit: e }) {
      const r = t, n = e, { forwardRef: i, currentElement: a } = On(), o = St(() => {
        var p;
        return ((p = a.value) == null ? void 0 : p.ownerDocument) ?? globalThis.document;
      }), s = St(() => ja.layersRoot), l = St(() => a.value ? Array.from(s.value).indexOf(a.value) : -1), u = St(() => ja.layersWithOutsidePointerEventsDisabled.size > 0), c = St(() => {
        const p = Array.from(s.value), [v] = [
          ...ja.layersWithOutsidePointerEventsDisabled
        ].slice(-1), g = p.indexOf(v);
        return l.value >= g;
      }), h = SAe(async (p) => {
        const v = [
          ...ja.branches
        ].some((g) => g == null ? void 0 : g.contains(p.target));
        !c.value || v || (n("pointerDownOutside", p), n("interactOutside", p), await bo(), p.defaultPrevented || n("dismiss"));
      }, a), f = TAe((p) => {
        [
          ...ja.branches
        ].some((v) => v == null ? void 0 : v.contains(p.target)) || (n("focusOutside", p), n("interactOutside", p), p.defaultPrevented || n("dismiss"));
      }, a);
      JCe("Escape", (p) => {
        l.value === s.value.size - 1 && (n("escapeKeyDown", p), p.defaultPrevented || n("dismiss"));
      });
      let d;
      return Hl((p) => {
        a.value && (r.disableOutsidePointerEvents && (ja.layersWithOutsidePointerEventsDisabled.size === 0 && (d = o.value.body.style.pointerEvents, o.value.body.style.pointerEvents = "none"), ja.layersWithOutsidePointerEventsDisabled.add(a.value)), s.value.add(a.value), p(() => {
          r.disableOutsidePointerEvents && ja.layersWithOutsidePointerEventsDisabled.size === 1 && (o.value.body.style.pointerEvents = d);
        }));
      }), Hl((p) => {
        p(() => {
          a.value && (s.value.delete(a.value), ja.layersWithOutsidePointerEventsDisabled.delete(a.value));
        });
      }), (p, v) => (dt(), Wt(Q(Ci), {
        ref: Q(i),
        "as-child": p.asChild,
        as: p.as,
        "data-dismissable-layer": "",
        style: bF({
          pointerEvents: u.value ? c.value ? "auto" : "none" : void 0
        }),
        onFocusCapture: Q(f).onFocusCapture,
        onBlurCapture: Q(f).onBlurCapture,
        onPointerdownCapture: Q(h).onPointerDownCapture
      }, {
        default: Me(() => [
          Tt(p.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "style",
        "onFocusCapture",
        "onBlurCapture",
        "onPointerdownCapture"
      ]));
    }
  }), Y1 = "focusScope.autoFocusOnMount", q1 = "focusScope.autoFocusOnUnmount", lF = {
    bubbles: false,
    cancelable: true
  };
  function AAe(t, { select: e = false } = {}) {
    const r = Ea();
    for (const n of t) if (Yo(n, {
      select: e
    }), Ea() !== r) return true;
  }
  function IAe(t) {
    const e = w7(t), r = uF(e, t), n = uF(e.reverse(), t);
    return [
      r,
      n
    ];
  }
  function w7(t) {
    const e = [], r = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (n) => {
        const i = n.tagName === "INPUT" && n.type === "hidden";
        return n.disabled || n.hidden || i ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; r.nextNode(); ) e.push(r.currentNode);
    return e;
  }
  function uF(t, e) {
    for (const r of t) if (!MAe(r, {
      upTo: e
    })) return r;
  }
  function MAe(t, { upTo: e }) {
    if (getComputedStyle(t).visibility === "hidden") return true;
    for (; t; ) {
      if (e !== void 0 && t === e) return false;
      if (getComputedStyle(t).display === "none") return true;
      t = t.parentElement;
    }
    return false;
  }
  function DAe(t) {
    return t instanceof HTMLInputElement && "select" in t;
  }
  function Yo(t, { select: e = false } = {}) {
    if (t && t.focus) {
      const r = Ea();
      t.focus({
        preventScroll: true
      }), t !== r && DAe(t) && e && t.select();
    }
  }
  const EAe = WCe(() => ot([]));
  function kAe() {
    const t = EAe();
    return {
      add(e) {
        const r = t.value[0];
        e !== r && (r == null ? void 0 : r.pause()), t.value = cF(t.value, e), t.value.unshift(e);
      },
      remove(e) {
        var r;
        t.value = cF(t.value, e), (r = t.value[0]) == null || r.resume();
      }
    };
  }
  function cF(t, e) {
    const r = [
      ...t
    ], n = r.indexOf(e);
    return n !== -1 && r.splice(n, 1), r;
  }
  function PAe(t) {
    return t.filter((e) => e.tagName !== "A");
  }
  const LAe = ht({
    __name: "FocusScope",
    props: {
      loop: {
        type: Boolean,
        default: false
      },
      trapped: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "mountAutoFocus",
      "unmountAutoFocus"
    ],
    setup(t, { emit: e }) {
      const r = t, n = e, { currentRef: i, currentElement: a } = On(), o = ot(null), s = kAe(), l = _F({
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      });
      Hl((c) => {
        if (!pu) return;
        const h = a.value;
        if (!r.trapped) return;
        function f(g) {
          if (l.paused || !h) return;
          const m = g.target;
          h.contains(m) ? o.value = m : Yo(o.value, {
            select: true
          });
        }
        function d(g) {
          if (l.paused || !h) return;
          const m = g.relatedTarget;
          m !== null && (h.contains(m) || Yo(o.value, {
            select: true
          }));
        }
        function p(g) {
          h.contains(o.value) || Yo(h);
        }
        document.addEventListener("focusin", f), document.addEventListener("focusout", d);
        const v = new MutationObserver(p);
        h && v.observe(h, {
          childList: true,
          subtree: true
        }), c(() => {
          document.removeEventListener("focusin", f), document.removeEventListener("focusout", d), v.disconnect();
        });
      }), Hl(async (c) => {
        const h = a.value;
        if (await bo(), !h) return;
        s.add(l);
        const f = Ea();
        if (!h.contains(f)) {
          const d = new CustomEvent(Y1, lF);
          h.addEventListener(Y1, (p) => n("mountAutoFocus", p)), h.dispatchEvent(d), d.defaultPrevented || (AAe(PAe(w7(h)), {
            select: true
          }), Ea() === f && Yo(h));
        }
        c(() => {
          h.removeEventListener(Y1, (v) => n("mountAutoFocus", v));
          const d = new CustomEvent(q1, lF), p = (v) => {
            n("unmountAutoFocus", v);
          };
          h.addEventListener(q1, p), h.dispatchEvent(d), setTimeout(() => {
            d.defaultPrevented || Yo(f ?? document.body, {
              select: true
            }), h.removeEventListener(q1, p), s.remove(l);
          }, 0);
        });
      });
      function u(c) {
        if (!r.loop && !r.trapped || l.paused) return;
        const h = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, f = Ea();
        if (h && f) {
          const d = c.currentTarget, [p, v] = IAe(d);
          p && v ? !c.shiftKey && f === v ? (c.preventDefault(), r.loop && Yo(p, {
            select: true
          })) : c.shiftKey && f === p && (c.preventDefault(), r.loop && Yo(v, {
            select: true
          })) : f === d && c.preventDefault();
        }
      }
      return (c, h) => (dt(), Wt(Q(Ci), {
        ref_key: "currentRef",
        ref: i,
        tabindex: "-1",
        "as-child": c.asChild,
        as: c.as,
        onKeydown: u
      }, {
        default: Me(() => [
          Tt(c.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as-child",
        "as"
      ]));
    }
  });
  function $Ae(t) {
    return t ? "open" : "closed";
  }
  const S7 = ht({
    __name: "DialogContentImpl",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(t, { emit: e }) {
      const r = t, n = e, i = As(), { forwardRef: a, currentElement: o } = On();
      return i.titleId || (i.titleId = Pm(void 0, "radix-vue-dialog-title")), i.descriptionId || (i.descriptionId = Pm(void 0, "radix-vue-dialog-description")), Oc(() => {
        i.contentElement = o, Ea() !== document.body && (i.triggerElement.value = Ea());
      }), (s, l) => (dt(), Wt(Q(LAe), {
        "as-child": "",
        loop: "",
        trapped: r.trapFocus,
        onMountAutoFocus: l[5] || (l[5] = (u) => n("openAutoFocus", u)),
        onUnmountAutoFocus: l[6] || (l[6] = (u) => n("closeAutoFocus", u))
      }, {
        default: Me(() => [
          at(Q(CAe), Ln({
            id: Q(i).contentId,
            ref: Q(a),
            as: s.as,
            "as-child": s.asChild,
            "disable-outside-pointer-events": s.disableOutsidePointerEvents,
            role: "dialog",
            "aria-describedby": Q(i).descriptionId,
            "aria-labelledby": Q(i).titleId,
            "data-state": Q($Ae)(Q(i).open.value)
          }, s.$attrs, {
            onDismiss: l[0] || (l[0] = (u) => Q(i).onOpenChange(false)),
            onEscapeKeyDown: l[1] || (l[1] = (u) => n("escapeKeyDown", u)),
            onFocusOutside: l[2] || (l[2] = (u) => n("focusOutside", u)),
            onInteractOutside: l[3] || (l[3] = (u) => n("interactOutside", u)),
            onPointerDownOutside: l[4] || (l[4] = (u) => n("pointerDownOutside", u))
          }), {
            default: Me(() => [
              Tt(s.$slots, "default")
            ]),
            _: 3
          }, 16, [
            "id",
            "as",
            "as-child",
            "disable-outside-pointer-events",
            "aria-describedby",
            "aria-labelledby",
            "data-state"
          ])
        ]),
        _: 3
      }, 8, [
        "trapped"
      ]));
    }
  }), RAe = ht({
    __name: "DialogContentModal",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(t, { emit: e }) {
      const r = t, n = e, i = As(), a = My(n), { forwardRef: o, currentElement: s } = On();
      return dAe(s), (l, u) => (dt(), Wt(S7, Ln({
        ...r,
        ...Q(a)
      }, {
        ref: Q(o),
        "trap-focus": Q(i).open.value,
        "disable-outside-pointer-events": true,
        onCloseAutoFocus: u[0] || (u[0] = (c) => {
          var h;
          c.defaultPrevented || (c.preventDefault(), (h = Q(i).triggerElement.value) == null || h.focus());
        }),
        onPointerDownOutside: u[1] || (u[1] = (c) => {
          const h = c.detail.originalEvent, f = h.button === 0 && h.ctrlKey === true;
          (h.button === 2 || f) && c.preventDefault();
        }),
        onFocusOutside: u[2] || (u[2] = (c) => {
          c.preventDefault();
        })
      }), {
        default: Me(() => [
          Tt(l.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "trap-focus"
      ]));
    }
  }), OAe = ht({
    __name: "DialogContentNonModal",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(t, { emit: e }) {
      const r = t, n = My(e);
      On();
      const i = As(), a = ot(false), o = ot(false);
      return (s, l) => (dt(), Wt(S7, Ln({
        ...r,
        ...Q(n)
      }, {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: l[0] || (l[0] = (u) => {
          var c;
          u.defaultPrevented || (a.value || (c = Q(i).triggerElement.value) == null || c.focus(), u.preventDefault()), a.value = false, o.value = false;
        }),
        onInteractOutside: l[1] || (l[1] = (u) => {
          var c;
          u.defaultPrevented || (a.value = true, u.detail.originalEvent.type === "pointerdown" && (o.value = true));
          const h = u.target;
          (c = Q(i).triggerElement.value) != null && c.contains(h) && u.preventDefault(), u.detail.originalEvent.type === "focusin" && o.value && u.preventDefault();
        })
      }), {
        default: Me(() => [
          Tt(s.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), NAe = ht({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(t, { emit: e }) {
      const r = t, n = e, i = As(), a = My(n), { forwardRef: o } = On();
      return (s, l) => (dt(), Wt(Q(gA), {
        present: s.forceMount || Q(i).open.value
      }, {
        default: Me(() => [
          Q(i).modal.value ? (dt(), Wt(RAe, Ln({
            key: 0,
            ref: Q(o)
          }, {
            ...r,
            ...Q(a),
            ...s.$attrs
          }), {
            default: Me(() => [
              Tt(s.$slots, "default")
            ]),
            _: 3
          }, 16)) : (dt(), Wt(OAe, Ln({
            key: 1,
            ref: Q(o)
          }, {
            ...r,
            ...Q(a),
            ...s.$attrs
          }), {
            default: Me(() => [
              Tt(s.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, [
        "present"
      ]));
    }
  }), BAe = ht({
    __name: "DialogOverlayImpl",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(t) {
      const e = As();
      return sAe(true), On(), (r, n) => (dt(), Wt(Q(Ci), {
        as: r.as,
        "as-child": r.asChild,
        "data-state": Q(e).open.value ? "open" : "closed",
        style: {
          "pointer-events": "auto"
        }
      }, {
        default: Me(() => [
          Tt(r.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ]));
    }
  }), zAe = ht({
    __name: "DialogOverlay",
    props: {
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(t) {
      const e = As(), { forwardRef: r } = On();
      return (n, i) => {
        var a;
        return (a = Q(e)) != null && a.modal.value ? (dt(), Wt(Q(gA), {
          key: 0,
          present: n.forceMount || Q(e).open.value
        }, {
          default: Me(() => [
            at(BAe, Ln(n.$attrs, {
              ref: Q(r),
              as: n.as,
              "as-child": n.asChild
            }), {
              default: Me(() => [
                Tt(n.$slots, "default")
              ]),
              _: 3
            }, 16, [
              "as",
              "as-child"
            ])
          ]),
          _: 3
        }, 8, [
          "present"
        ])) : zf("", true);
      };
    }
  }), FAe = ht({
    __name: "DialogClose",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(t) {
      const e = t;
      On();
      const r = As();
      return (n, i) => (dt(), Wt(Q(Ci), Ln(e, {
        type: n.as === "button" ? "button" : void 0,
        onClick: i[0] || (i[0] = (a) => Q(r).onOpenChange(false))
      }), {
        default: Me(() => [
          Tt(n.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "type"
      ]));
    }
  }), VAe = ht({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "h2"
      }
    },
    setup(t) {
      const e = t, r = As();
      return On(), (n, i) => (dt(), Wt(Q(Ci), Ln(e, {
        id: Q(r).titleId
      }), {
        default: Me(() => [
          Tt(n.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "id"
      ]));
    }
  }), GAe = "data-radix-vue-collection-item", [mA, WAe] = Zd("CollectionProvider");
  function HAe(t = GAe) {
    const e = ot(/* @__PURE__ */ new Map()), r = ot(), n = WAe({
      collectionRef: r,
      itemMap: e,
      attrName: t
    }), { getItems: i } = T7(n), a = St(() => Array.from(n.itemMap.value.values())), o = St(() => n.itemMap.value.size);
    return {
      getItems: i,
      reactiveItems: a,
      itemMapSize: o
    };
  }
  const UAe = ht({
    name: "CollectionSlot",
    setup(t, { slots: e }) {
      const r = mA(), { primitiveElement: n, currentElement: i } = b7();
      return nn(i, () => {
        r.collectionRef.value = i.value;
      }), () => Hi(vA, {
        ref: n
      }, e);
    }
  }), YAe = ht({
    name: "CollectionItem",
    inheritAttrs: false,
    props: {
      value: {
        validator: () => true
      }
    },
    setup(t, { slots: e, attrs: r }) {
      const n = mA(), { primitiveElement: i, currentElement: a } = b7();
      return Hl((o) => {
        if (a.value) {
          const s = eK(a.value);
          n.itemMap.value.set(s, {
            ref: a.value,
            value: t.value
          }), o(() => n.itemMap.value.delete(s));
        }
      }), () => Hi(vA, {
        ...r,
        [n.attrName]: "",
        ref: i
      }, e);
    }
  });
  function T7(t) {
    const e = t ?? mA();
    return {
      getItems: () => {
        const r = e.collectionRef.value;
        if (!r) return [];
        const n = Array.from(r.querySelectorAll(`[${e.attrName}]`));
        return Array.from(e.itemMap.value.values()).sort((i, a) => n.indexOf(i.ref) - n.indexOf(a.ref));
      }
    };
  }
  const qAe = "rovingFocusGroup.onEntryFocus", XAe = {
    bubbles: false,
    cancelable: true
  }, jAe = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function KAe(t, e) {
    return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
  }
  function ZAe(t, e, r) {
    const n = KAe(t.key, r);
    if (!(e === "vertical" && [
      "ArrowLeft",
      "ArrowRight"
    ].includes(n)) && !(e === "horizontal" && [
      "ArrowUp",
      "ArrowDown"
    ].includes(n))) return jAe[n];
  }
  function C7(t, e = false) {
    const r = Ea();
    for (const n of t) if (n === r || (n.focus({
      preventScroll: e
    }), Ea() !== r)) return;
  }
  function QAe(t, e) {
    return t.map((r, n) => t[(e + n) % t.length]);
  }
  const [JAe, eIe] = Zd("RovingFocusGroup"), tIe = ht({
    __name: "RovingFocusGroup",
    props: {
      orientation: {
        default: void 0
      },
      dir: {},
      loop: {
        type: Boolean,
        default: false
      },
      currentTabStopId: {},
      defaultCurrentTabStopId: {},
      preventScrollOnEntryFocus: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "entryFocus",
      "update:currentTabStopId"
    ],
    setup(t, { expose: e, emit: r }) {
      const n = t, i = r, { loop: a, orientation: o, dir: s } = Id(n), l = y7(s), u = cA(n, "currentTabStopId", i, {
        defaultValue: n.defaultCurrentTabStopId,
        passive: n.currentTabStopId === void 0
      }), c = ot(false), h = ot(false), f = ot(0), { getItems: d } = HAe();
      function p(g) {
        const m = !h.value;
        if (g.currentTarget && g.target === g.currentTarget && m && !c.value) {
          const y = new CustomEvent(qAe, XAe);
          if (g.currentTarget.dispatchEvent(y), i("entryFocus", y), !y.defaultPrevented) {
            const _ = d().map((T) => T.ref).filter((T) => T.dataset.disabled !== ""), b = _.find((T) => T.getAttribute("data-active") === "true"), w = _.find((T) => T.id === u.value), x = [
              b,
              w,
              ..._
            ].filter(Boolean);
            C7(x, n.preventScrollOnEntryFocus);
          }
        }
        h.value = false;
      }
      function v() {
        setTimeout(() => {
          h.value = false;
        }, 1);
      }
      return e({
        getItems: d
      }), eIe({
        loop: a,
        dir: l,
        orientation: o,
        currentTabStopId: u,
        onItemFocus: (g) => {
          u.value = g;
        },
        onItemShiftTab: () => {
          c.value = true;
        },
        onFocusableItemAdd: () => {
          f.value++;
        },
        onFocusableItemRemove: () => {
          f.value--;
        }
      }), (g, m) => (dt(), Wt(Q(UAe), null, {
        default: Me(() => [
          at(Q(Ci), {
            tabindex: c.value || f.value === 0 ? -1 : 0,
            "data-orientation": Q(o),
            as: g.as,
            "as-child": g.asChild,
            dir: Q(l),
            style: {
              outline: "none"
            },
            onMousedown: m[0] || (m[0] = (y) => h.value = true),
            onMouseup: v,
            onFocus: p,
            onBlur: m[1] || (m[1] = (y) => c.value = false)
          }, {
            default: Me(() => [
              Tt(g.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "as",
            "as-child",
            "dir"
          ])
        ]),
        _: 3
      }));
    }
  }), rIe = ht({
    __name: "RovingFocusItem",
    props: {
      tabStopId: {},
      focusable: {
        type: Boolean,
        default: true
      },
      active: {
        type: Boolean,
        default: true
      },
      allowShiftKey: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(t) {
      const e = t, r = JAe(), n = St(() => e.tabStopId || Pm()), i = St(() => r.currentTabStopId.value === n.value), { getItems: a } = T7();
      Oc(() => {
        e.focusable && r.onFocusableItemAdd();
      }), Lm(() => {
        e.focusable && r.onFocusableItemRemove();
      });
      function o(s) {
        if (s.key === "Tab" && s.shiftKey) {
          r.onItemShiftTab();
          return;
        }
        if (s.target !== s.currentTarget) return;
        const l = ZAe(s, r.orientation.value, r.dir.value);
        if (l !== void 0) {
          if (s.metaKey || s.ctrlKey || s.altKey || !e.allowShiftKey && s.shiftKey) return;
          s.preventDefault();
          let u = [
            ...a().map((c) => c.ref).filter((c) => c.dataset.disabled !== "")
          ];
          if (l === "last") u.reverse();
          else if (l === "prev" || l === "next") {
            l === "prev" && u.reverse();
            const c = u.indexOf(s.currentTarget);
            u = r.loop.value ? QAe(u, c + 1) : u.slice(c + 1);
          }
          bo(() => C7(u));
        }
      }
      return (s, l) => (dt(), Wt(Q(YAe), null, {
        default: Me(() => [
          at(Q(Ci), {
            tabindex: i.value ? 0 : -1,
            "data-orientation": Q(r).orientation.value,
            "data-active": s.active,
            "data-disabled": s.focusable ? void 0 : "",
            as: s.as,
            "as-child": s.asChild,
            onMousedown: l[0] || (l[0] = (u) => {
              s.focusable ? Q(r).onItemFocus(n.value) : u.preventDefault();
            }),
            onFocus: l[1] || (l[1] = (u) => Q(r).onItemFocus(n.value)),
            onKeydown: o
          }, {
            default: Me(() => [
              Tt(s.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "data-active",
            "data-disabled",
            "as",
            "as-child"
          ])
        ]),
        _: 3
      }));
    }
  });
  function nIe() {
    if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
  nIe();
  const [yA, iIe] = Zd("TabsRoot"), aIe = ht({
    __name: "TabsRoot",
    props: {
      defaultValue: {},
      orientation: {
        default: "horizontal"
      },
      dir: {},
      activationMode: {
        default: "automatic"
      },
      modelValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(t, { emit: e }) {
      const r = t, n = e, { orientation: i, dir: a } = Id(r), o = y7(a);
      On();
      const s = cA(r, "modelValue", n, {
        defaultValue: r.defaultValue,
        passive: r.modelValue === void 0
      }), l = ot();
      return iIe({
        modelValue: s,
        changeModelValue: (u) => {
          s.value = u;
        },
        orientation: i,
        dir: o,
        activationMode: r.activationMode,
        baseId: Pm(void 0, "radix-vue-tabs"),
        tabsList: l
      }), (u, c) => (dt(), Wt(Q(Ci), {
        dir: Q(o),
        "data-orientation": Q(i),
        "as-child": u.asChild,
        as: u.as
      }, {
        default: Me(() => [
          Tt(u.$slots, "default", {
            modelValue: Q(s)
          })
        ]),
        _: 3
      }, 8, [
        "dir",
        "data-orientation",
        "as-child",
        "as"
      ]));
    }
  }), oIe = ht({
    __name: "TabsList",
    props: {
      loop: {
        type: Boolean,
        default: true
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(t) {
      const e = t, { loop: r } = Id(e), { forwardRef: n, currentElement: i } = On(), a = yA();
      return a.tabsList = i, (o, s) => (dt(), Wt(Q(tIe), {
        "as-child": "",
        orientation: Q(a).orientation.value,
        dir: Q(a).dir.value,
        loop: Q(r)
      }, {
        default: Me(() => [
          at(Q(Ci), {
            ref: Q(n),
            role: "tablist",
            "as-child": o.asChild,
            as: o.as,
            "aria-orientation": Q(a).orientation.value
          }, {
            default: Me(() => [
              Tt(o.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "as-child",
            "as",
            "aria-orientation"
          ])
        ]),
        _: 3
      }, 8, [
        "orientation",
        "dir",
        "loop"
      ]));
    }
  });
  function A7(t, e) {
    return `${t}-trigger-${e}`;
  }
  function I7(t, e) {
    return `${t}-content-${e}`;
  }
  const sIe = ht({
    __name: "TabsContent",
    props: {
      value: {},
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(t) {
      const e = t, { forwardRef: r } = On(), n = yA(), i = St(() => A7(n.baseId, e.value)), a = St(() => I7(n.baseId, e.value)), o = St(() => e.value === n.modelValue.value), s = ot(o.value);
      return Oc(() => {
        requestAnimationFrame(() => {
          s.value = false;
        });
      }), (l, u) => (dt(), Wt(Q(gA), {
        present: o.value,
        "force-mount": ""
      }, {
        default: Me(({ present: c }) => [
          at(Q(Ci), {
            id: a.value,
            ref: Q(r),
            "as-child": l.asChild,
            as: l.as,
            role: "tabpanel",
            "data-state": o.value ? "active" : "inactive",
            "data-orientation": Q(n).orientation.value,
            "aria-labelledby": i.value,
            hidden: !c.value,
            tabindex: "0",
            style: bF({
              animationDuration: s.value ? "0s" : void 0
            })
          }, {
            default: Me(() => [
              l.forceMount || o.value ? Tt(l.$slots, "default", {
                key: 0
              }) : zf("", true)
            ]),
            _: 2
          }, 1032, [
            "id",
            "as-child",
            "as",
            "data-state",
            "data-orientation",
            "aria-labelledby",
            "hidden",
            "style"
          ])
        ]),
        _: 3
      }, 8, [
        "present"
      ]));
    }
  }), lIe = ht({
    __name: "TabsTrigger",
    props: {
      value: {},
      disabled: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(t) {
      const e = t, { forwardRef: r } = On(), n = yA(), i = St(() => A7(n.baseId, e.value)), a = St(() => I7(n.baseId, e.value)), o = St(() => e.value === n.modelValue.value);
      return (s, l) => (dt(), Wt(Q(rIe), {
        "as-child": "",
        focusable: !s.disabled,
        active: o.value
      }, {
        default: Me(() => [
          at(Q(Ci), {
            id: i.value,
            ref: Q(r),
            role: "tab",
            type: s.as === "button" ? "button" : void 0,
            as: s.as,
            "as-child": s.asChild,
            "aria-selected": o.value ? "true" : "false",
            "aria-controls": a.value,
            "data-state": o.value ? "active" : "inactive",
            disabled: s.disabled,
            "data-disabled": s.disabled ? "" : void 0,
            "data-orientation": Q(n).orientation.value,
            onMousedown: l[0] || (l[0] = jh((u) => {
              !s.disabled && u.ctrlKey === false ? Q(n).changeModelValue(s.value) : u.preventDefault();
            }, [
              "left"
            ])),
            onKeydown: l[1] || (l[1] = jj((u) => Q(n).changeModelValue(s.value), [
              "enter",
              "space"
            ])),
            onFocus: l[2] || (l[2] = () => {
              const u = Q(n).activationMode !== "manual";
              !o.value && !s.disabled && u && Q(n).changeModelValue(s.value);
            })
          }, {
            default: Me(() => [
              Tt(s.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "id",
            "type",
            "as",
            "as-child",
            "aria-selected",
            "aria-controls",
            "data-state",
            "disabled",
            "data-disabled",
            "data-orientation"
          ])
        ]),
        _: 3
      }, 8, [
        "focusable",
        "active"
      ]));
    }
  }), X1 = ht({
    __name: "Button",
    props: {
      variant: {},
      size: {},
      class: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), Wt(Q(Ci), {
        as: r.as,
        "as-child": r.asChild,
        class: Zn(Q(jr)(Q(uIe)({
          variant: r.variant,
          size: r.size
        }), e.class))
      }, {
        default: Me(() => [
          Tt(r.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "class"
      ]));
    }
  }), uIe = tCe("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }), cIe = ht({
    __name: "Card",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("div", {
        class: Zn(Q(jr)("rounded-lg border bg-card text-card-foreground shadow-sm", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), j1 = ht({
    __name: "CardContent",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("div", {
        class: Zn(Q(jr)("p-6 pt-0", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), hIe = ht({
    __name: "CardHeader",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("div", {
        class: Zn(Q(jr)("flex flex-col gap-y-1.5 p-6", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), fIe = ht({
    __name: "Dialog",
    props: {
      open: {
        type: Boolean
      },
      defaultOpen: {
        type: Boolean
      },
      modal: {
        type: Boolean
      }
    },
    emits: [
      "update:open"
    ],
    setup(t, { emit: e }) {
      const i = pA(t, e);
      return (a, o) => (dt(), Wt(Q(yAe), FS(VS(Q(i))), {
        default: Me(() => [
          Tt(a.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), dIe = ht({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(t, { emit: e }) {
      const r = t, n = e, i = St(() => {
        const { class: o, ...s } = r;
        return s;
      }), a = pA(i, n);
      return (o, s) => (dt(), Wt(Q(bAe), null, {
        default: Me(() => [
          at(Q(zAe), {
            class: "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
          }),
          at(Q(NAe), Ln(Q(a), {
            class: Q(jr)("fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", r.class)
          }), {
            default: Me(() => [
              Tt(o.$slots, "default"),
              at(Q(FAe), {
                class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground"
              }, {
                default: Me(() => [
                  at(Q(oye), {
                    class: "w-4 h-4"
                  }),
                  s[0] || (s[0] = Ie("span", {
                    class: "sr-only"
                  }, "Close", -1))
                ]),
                _: 1
              })
            ]),
            _: 3
          }, 16, [
            "class"
          ])
        ]),
        _: 3
      }));
    }
  }), pIe = ht({
    __name: "DialogHeader",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("div", {
        class: Zn(Q(jr)("flex flex-col gap-y-1.5 text-center sm:text-left", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), vIe = ht({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(t) {
      const e = t, r = St(() => {
        const { class: i, ...a } = e;
        return a;
      }), n = dA(r);
      return (i, a) => (dt(), Wt(Q(VAe), Ln(Q(n), {
        class: Q(jr)("text-lg font-semibold leading-none tracking-tight", e.class)
      }), {
        default: Me(() => [
          Tt(i.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  });
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const gIe = (t) => typeof t < "u";
  function mIe(t) {
    return JSON.parse(JSON.stringify(t));
  }
  function yIe(t, e, r, n = {}) {
    var i, a, o;
    const { clone: s = false, passive: l = false, eventName: u, deep: c = false, defaultValue: h, shouldEmit: f } = n, d = jn(), p = r || (d == null ? void 0 : d.emit) || ((i = d == null ? void 0 : d.$emit) == null ? void 0 : i.bind(d)) || ((o = (a = d == null ? void 0 : d.proxy) == null ? void 0 : a.$emit) == null ? void 0 : o.bind(d == null ? void 0 : d.proxy));
    let v = u;
    v = v || `update:${e.toString()}`;
    const g = (_) => s ? typeof s == "function" ? s(_) : mIe(_) : _, m = () => gIe(t[e]) ? g(t[e]) : h, y = (_) => {
      f ? f(_) && p(v, _) : p(v, _);
    };
    if (l) {
      const _ = m(), b = ot(_);
      let w = false;
      return nn(() => t[e], (x) => {
        w || (w = true, b.value = g(x), bo(() => w = false));
      }), nn(b, (x) => {
        !w && (x !== t[e] || c) && y(x);
      }, {
        deep: c
      }), b;
    } else return St({
      get() {
        return m();
      },
      set(_) {
        y(_);
      }
    });
  }
  const _Ie = ht({
    __name: "Textarea",
    props: {
      class: {},
      defaultValue: {},
      modelValue: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(t, { emit: e }) {
      const r = t, i = yIe(r, "modelValue", e, {
        passive: true,
        defaultValue: r.defaultValue
      });
      return (a, o) => qv((dt(), tn("textarea", {
        "onUpdate:modelValue": o[0] || (o[0] = (s) => gF(i) ? i.value = s : null),
        class: Zn(Q(jr)("flex min-h-20 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", r.class))
      }, null, 2)), [
        [
          Q1,
          Q(i)
        ]
      ]);
    }
  }), bIe = ht({
    __name: "Tabs",
    props: {
      defaultValue: {},
      orientation: {},
      dir: {},
      activationMode: {},
      modelValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(t, { emit: e }) {
      const i = pA(t, e);
      return (a, o) => (dt(), Wt(Q(aIe), FS(VS(Q(i))), {
        default: Me(() => [
          Tt(a.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), hF = ht({
    __name: "TabsContent",
    props: {
      value: {},
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(t) {
      const e = t, r = St(() => {
        const { class: n, ...i } = e;
        return i;
      });
      return (n, i) => (dt(), Wt(Q(sIe), Ln({
        class: Q(jr)("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", e.class)
      }, r.value), {
        default: Me(() => [
          Tt(n.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), xIe = ht({
    __name: "TabsList",
    props: {
      loop: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(t) {
      const e = t, r = St(() => {
        const { class: n, ...i } = e;
        return i;
      });
      return (n, i) => (dt(), Wt(Q(oIe), Ln(r.value, {
        class: Q(jr)("inline-flex items-center justify-center rounded-md bg-muted p-1 text-muted-foreground", e.class)
      }), {
        default: Me(() => [
          Tt(n.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), wIe = {
    class: "truncate"
  }, fF = ht({
    __name: "TabsTrigger",
    props: {
      value: {},
      disabled: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(t) {
      const e = t, r = St(() => {
        const { class: i, ...a } = e;
        return a;
      }), n = dA(r);
      return (i, a) => (dt(), Wt(Q(lIe), Ln(Q(n), {
        class: Q(jr)("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm", e.class)
      }), {
        default: Me(() => [
          Ie("span", wIe, [
            Tt(i.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), SIe = {
    class: "relative w-full overflow-auto"
  }, TIe = ht({
    __name: "Table",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("div", SIe, [
        Ie("table", {
          class: Zn(Q(jr)("w-full caption-bottom text-sm", e.class))
        }, [
          Tt(r.$slots, "default")
        ], 2)
      ]));
    }
  }), CIe = ht({
    __name: "TableBody",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("tbody", {
        class: Zn(Q(jr)("[&_tr:last-child]:border-0", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), Hu = ht({
    __name: "TableCell",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("td", {
        class: Zn(Q(jr)("p-4 align-middle [&:has([role=checkbox])]:pr-0", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), dF = ht({
    __name: "TableRow",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("tr", {
        class: Zn(Q(jr)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), Uu = ht({
    __name: "TableHead",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("th", {
        class: Zn(Q(jr)("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), AIe = ht({
    __name: "TableHeader",
    props: {
      class: {}
    },
    setup(t) {
      const e = t;
      return (r, n) => (dt(), tn("thead", {
        class: Zn(Q(jr)("[&_tr]:border-b", e.class))
      }, [
        Tt(r.$slots, "default")
      ], 2));
    }
  }), IIe = 1, MIe = 1e6, ro = {
    ADD_TOAST: "ADD_TOAST",
    UPDATE_TOAST: "UPDATE_TOAST",
    DISMISS_TOAST: "DISMISS_TOAST",
    REMOVE_TOAST: "REMOVE_TOAST"
  };
  let K1 = 0;
  function DIe() {
    return K1 = (K1 + 1) % Number.MAX_VALUE, K1.toString();
  }
  const Z1 = /* @__PURE__ */ new Map();
  function pF(t) {
    if (Z1.has(t)) return;
    const e = setTimeout(() => {
      Z1.delete(t), Nf({
        type: ro.REMOVE_TOAST,
        toastId: t
      });
    }, MIe);
    Z1.set(t, e);
  }
  const Oi = ot({
    toasts: []
  });
  function Nf(t) {
    switch (t.type) {
      case ro.ADD_TOAST:
        Oi.value.toasts = [
          t.toast,
          ...Oi.value.toasts
        ].slice(0, IIe);
        break;
      case ro.UPDATE_TOAST:
        Oi.value.toasts = Oi.value.toasts.map((e) => e.id === t.toast.id ? {
          ...e,
          ...t.toast
        } : e);
        break;
      case ro.DISMISS_TOAST: {
        const { toastId: e } = t;
        e ? pF(e) : Oi.value.toasts.forEach((r) => {
          pF(r.id);
        }), Oi.value.toasts = Oi.value.toasts.map((r) => r.id === e || e === void 0 ? {
          ...r,
          open: false
        } : r);
        break;
      }
      case ro.REMOVE_TOAST:
        t.toastId === void 0 ? Oi.value.toasts = [] : Oi.value.toasts = Oi.value.toasts.filter((e) => e.id !== t.toastId);
        break;
    }
  }
  function EIe() {
    return {
      toasts: St(() => Oi.value.toasts),
      toast: kIe,
      dismiss: (t) => Nf({
        type: ro.DISMISS_TOAST,
        toastId: t
      })
    };
  }
  function kIe(t) {
    const e = DIe(), r = (i) => Nf({
      type: ro.UPDATE_TOAST,
      toast: {
        ...i,
        id: e
      }
    }), n = () => Nf({
      type: ro.DISMISS_TOAST,
      toastId: e
    });
    return Nf({
      type: ro.ADD_TOAST,
      toast: {
        ...t,
        id: e,
        open: true,
        onOpenChange: (i) => {
          i || n();
        }
      }
    }), {
      id: e,
      dismiss: n,
      update: r
    };
  }
  let PIe, LIe, $Ie, RIe, OIe, NIe, BIe, zIe, FIe, VIe, GIe, WIe, HIe, UIe, YIe, qIe, XIe, jIe, KIe, ZIe, QIe, JIe, eMe, tMe, rMe, nMe, iMe, aMe, oMe, sMe, lMe, uMe, cMe, hMe, fMe, dMe, pMe, vMe, gMe, mMe, yMe, _Me, bMe, xMe, wMe, SMe, TMe, CMe, AMe, IMe, MMe, DMe, EMe, kMe, PMe, LMe, $Me, RMe, OMe, NMe, BMe, zMe, FMe, VMe, GMe, WMe, HMe;
  PIe = {
    class: "flex flex-col justify-start space-y-4 p-4 max-w-4xl mx-auto w-full"
  };
  LIe = {
    class: "text-lg font-bold"
  };
  $Ie = {
    class: "text-sm text-gray-600 text-center"
  };
  RIe = {
    class: "text-primary font-medium hover:underline"
  };
  OIe = {
    key: 0,
    class: "w-full max-w-2xl mx-auto"
  };
  NIe = {
    class: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"
  };
  BIe = [
    "onClick"
  ];
  zIe = [
    "src",
    "alt"
  ];
  FIe = {
    class: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-center justify-center"
  };
  VIe = {
    class: "text-white text-sm truncate max-w-[90%] px-2"
  };
  GIe = {
    class: "flex flex-col gap-4 items-center justify-center"
  };
  WIe = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  HIe = {
    class: "text-sm text-gray-600"
  };
  UIe = [
    "disabled"
  ];
  YIe = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  qIe = {
    class: "text-sm text-gray-600"
  };
  XIe = [
    "disabled"
  ];
  jIe = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  KIe = {
    class: "text-sm text-gray-600"
  };
  ZIe = [
    "disabled"
  ];
  QIe = {
    class: "flex gap-6"
  };
  JIe = {
    class: "bg-white rounded-xl shadow-sm"
  };
  eMe = {
    class: "mt-6 p-6 bg-gray-50/50 rounded-xl border border-gray-100"
  };
  tMe = {
    class: "border rounded-xl overflow-hidden overflow-x-auto"
  };
  rMe = {
    class: "flex flex-col gap-8 pt-4"
  };
  nMe = {
    class: "relative w-full overflow-hidden rounded-xl shadow-lg bg-gray-50/50"
  };
  iMe = [
    "src"
  ];
  aMe = {
    class: "grid grid-cols-2 gap-6 p-6 border rounded-xl bg-gray-50/30"
  };
  oMe = {
    class: "space-y-2"
  };
  sMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  lMe = {
    class: "font-medium"
  };
  uMe = {
    class: "space-y-2"
  };
  cMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  hMe = {
    class: "font-medium"
  };
  fMe = {
    class: "space-y-2"
  };
  dMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  pMe = {
    class: "font-medium"
  };
  vMe = {
    class: "space-y-2"
  };
  gMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  mMe = {
    class: "font-medium"
  };
  yMe = {
    class: "space-y-2"
  };
  _Me = {
    class: "text-sm font-semibold text-gray-500"
  };
  bMe = {
    class: "font-medium"
  };
  xMe = {
    class: "space-y-2"
  };
  wMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  SMe = {
    class: "font-medium"
  };
  TMe = {
    class: "space-y-2"
  };
  CMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  AMe = {
    class: "font-medium"
  };
  IMe = {
    class: "space-y-2"
  };
  MMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  DMe = {
    class: "font-medium"
  };
  EMe = {
    class: "space-y-2"
  };
  kMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  PMe = {
    class: "font-medium"
  };
  LMe = {
    class: "space-y-2"
  };
  $Me = {
    class: "text-sm font-semibold text-gray-500"
  };
  RMe = {
    class: "font-medium"
  };
  OMe = {
    class: "space-y-2"
  };
  NMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  BMe = {
    class: "font-medium"
  };
  zMe = {
    class: "space-y-2"
  };
  FMe = {
    class: "text-sm font-semibold text-gray-500"
  };
  VMe = {
    class: "font-medium"
  };
  GMe = 10;
  WMe = ht({
    __name: "ModelPerformanceTest",
    setup(t) {
      const { t: e } = eCe(), { toast: r } = EIe(), n = ot([]), i = ot(""), a = ot([]), o = ot(false), s = ot("chart"), l = ot(false), u = ot(null), c = ot(), h = ot(), f = ot(), d = ot(1), p = ot("webgl"), v = ot(GMe), g = zSe(), m = ot([]), y = ot(false), _ = (L) => {
        const F = L.target.value.split(`
`).filter((E) => E.trim()).map((E) => {
          if (E.includes(".json")) {
            const O = E.split("/");
            return O.slice(0, O.length - 1).join("/");
          }
          return E;
        });
        n.value = F.map((E) => {
          const O = E.split("/");
          return {
            name: O[O.length - 1].split(".")[0],
            url: E
          };
        });
      }, b = (L) => {
        const z = L.target.files;
        z && Array.from(z).forEach((F) => {
          const E = new FileReader();
          E.addEventListener("load", async () => {
            const O = new Image();
            O.src = E.result, await new Promise((V) => {
              O.onload = V;
            });
            const N = await createImageBitmap(O);
            a.value.push({
              file: F,
              preview: E.result,
              bitmap: N
            });
          }, false), E.readAsDataURL(F);
        });
      }, w = async () => {
        if (!n.value.length || !a.value.length) {
          r({
            variant: "destructive",
            title: e("modelTest.messages.selectModelAndImage")
          });
          return;
        }
        o.value = true, m.value = [], await g.setBackend(p.value);
        try {
          for (const L of n.value) {
            const { name: z, url: F } = L;
            await g.loadModel(I9.tfjs, F);
            for (const E of a.value) {
              const O = performance.now(), N = [];
              for (let Z = 0; Z < d.value; Z++) {
                const ee = await T(z, F, E.bitmap, E.file.name);
                N.push(ee);
              }
              const V = Math.round(N.reduce((Z, ee) => Z + ee.inferenceTime, 0) / d.value), H = [];
              for (let Z = 0; Z < v.value; Z++) {
                const ee = await T(z, F, E.bitmap, E.file.name);
                H.push(ee);
              }
              const Y = performance.now() - O, U = {
                modelName: z,
                modelUrl: F,
                imageName: E.file.name,
                warmupTime: V,
                inferenceTime: Math.round(H.reduce((Z, ee) => Z + ee.inferenceTime, 0) / v.value),
                fps: Math.round(H.reduce((Z, ee) => Z + ee.fps, 0) / v.value),
                detections: H[0].detections,
                batchSize: v.value,
                minInferenceTime: Math.min(...H.map((Z) => Z.inferenceTime)),
                maxInferenceTime: Math.max(...H.map((Z) => Z.inferenceTime)),
                totalTime: Y,
                warmupResults: N,
                warmupCount: d.value,
                backend: p.value
              };
              m.value.push(U);
            }
          }
          y.value = true, I();
        } catch (L) {
          r({
            variant: "destructive",
            title: e("modelTest.messages.testError"),
            description: L.message
          });
        } finally {
          o.value = false;
        }
      }, x = () => {
        const L = m.value.map((N) => `${N.modelName},${N.imageName},${N.inferenceTime},${N.minInferenceTime},${N.maxInferenceTime},${N.fps},${v.value}`).join(`
`), z = [
          e("modelTest.tableColumns.model"),
          e("modelTest.tableColumns.image"),
          e("modelTest.tableColumns.inferenceTime"),
          e("modelTest.tableColumns.minInferenceTime"),
          e("modelTest.tableColumns.maxInferenceTime"),
          e("modelTest.tableColumns.fps"),
          e("modelTest.dialog.testCount")
        ].join(","), F = new Blob([
          `${z}
${L}`
        ], {
          type: "text/csv"
        }), E = URL.createObjectURL(F), O = document.createElement("a");
        O.href = E, O.download = `model_performance_${(/* @__PURE__ */ new Date()).toISOString()}.csv`, O.click();
      }, T = async (L, z, F, E) => {
        var _a2;
        const O = performance.now(), V = await ((_a2 = kl.getInstance().model) == null ? void 0 : _a2.detect(F, {})), G = performance.now() - O;
        return {
          modelName: L,
          modelUrl: z,
          imageName: E,
          inferenceTime: G,
          fps: Math.round(1e3 / G),
          detections: ((V == null ? void 0 : V.boxes.length) ?? 0) / 4
        };
      }, A = (L) => {
        u.value = L, l.value = true;
      }, I = () => {
        if (!c.value) return;
        const L = jre(c.value), z = {
          tooltip: {
            trigger: "axis",
            backgroundColor: "rgba(255, 255, 255, 0.9)",
            borderColor: "#e5e7eb",
            textStyle: {
              color: "black"
            }
          },
          legend: {
            data: [
              e("modelTest.tableColumns.inferenceTime"),
              e("modelTest.tableColumns.fps")
            ],
            textStyle: {
              color: "black"
            }
          },
          xAxis: {
            type: "category",
            data: m.value.map((F) => F.modelName),
            axisLine: {
              lineStyle: {
                color: "#e5e7eb"
              }
            },
            axisLabel: {
              color: "#000"
            },
            nameTextStyle: {
              color: "#000"
            }
          },
          yAxis: [
            {
              type: "value",
              name: e("modelTest.tableColumns.inferenceTime"),
              axisLine: {
                lineStyle: {
                  color: "#e5e7eb"
                }
              },
              axisLabel: {
                color: "#000"
              },
              splitLine: {
                lineStyle: {
                  color: "#f3f4f6"
                }
              },
              nameTextStyle: {
                color: "#000"
              }
            },
            {
              type: "value",
              name: e("modelTest.tableColumns.fps"),
              axisLine: {
                lineStyle: {
                  color: "#e5e7eb"
                }
              },
              axisLabel: {
                color: "#000"
              },
              splitLine: {
                lineStyle: {
                  color: "#f3f4f6"
                }
              },
              nameTextStyle: {
                color: "#000"
              }
            }
          ],
          series: [
            {
              name: e("modelTest.tableColumns.inferenceTime"),
              type: "bar",
              data: m.value.map((F) => F.inferenceTime),
              itemStyle: {
                color: "#3b82f6"
              },
              emphasis: {
                itemStyle: {
                  color: "#2563eb"
                }
              }
            },
            {
              name: e("modelTest.tableColumns.fps"),
              type: "line",
              yAxisIndex: 1,
              data: m.value.map((F) => F.fps),
              lineStyle: {
                color: "#10b981"
              },
              itemStyle: {
                color: "#10b981"
              },
              emphasis: {
                itemStyle: {
                  color: "#059669"
                }
              }
            }
          ]
        };
        return L.setOption(z), window.addEventListener("resize", () => {
          L.resize();
        }), L;
      };
      nn([
        m
      ], I), nn(s, (L) => {
        L === "chart" && setTimeout(() => {
          I();
        }, 500);
      }), Oc(() => I());
      const M = (L) => {
        var _a2;
        const z = new Image();
        z.src = L, (_a2 = window.open("")) == null ? void 0 : _a2.document.write(z.outerHTML);
      }, k = ot(false), B = (L) => {
        var _a2;
        k.value = false;
        const z = (_a2 = L.dataTransfer) == null ? void 0 : _a2.files;
        z && Array.from(z).filter((F) => F.type.startsWith("image/")).forEach((F) => {
          const E = new FileReader();
          E.addEventListener("load", async () => {
            const O = new Image();
            O.src = E.result, await new Promise((V) => {
              O.onload = V;
            });
            const N = await createImageBitmap(O);
            a.value.push({
              file: F,
              preview: E.result,
              bitmap: N
            });
          }, false), E.readAsDataURL(F);
        });
      };
      return (L, z) => (dt(), tn("div", PIe, [
        at(Q(cIe), {
          class: "shadow-lg hover:shadow-2xl transition-all duration-300 rounded-xl overflow-hidden bg-white/50 backdrop-blur-sm border border-gray-100"
        }, {
          default: Me(() => [
            at(Q(hIe), null, {
              default: Me(() => [
                Ie("h1", LIe, it(Q(e)("modelTest.title")), 1)
              ]),
              _: 1
            }),
            at(Q(j1), null, {
              default: Me(() => [
                at(Q(_Ie), {
                  modelValue: i.value,
                  "onUpdate:modelValue": z[0] || (z[0] = (F) => i.value = F),
                  rows: "3",
                  class: "w-full max-w-2xl mx-auto transition-all duration-300 hover:shadow-md focus:ring-2 focus:ring-primary/20 rounded-lg",
                  placeholder: Q(e)("modelTest.enterModelUrls"),
                  onInput: _
                }, null, 8, [
                  "modelValue",
                  "placeholder"
                ])
              ]),
              _: 1
            }),
            at(Q(j1), {
              class: "space-y-6"
            }, {
              default: Me(() => [
                Ie("div", {
                  class: Zn([
                    "border-2 border-dashed border-gray-200 rounded-xl p-6 hover:border-primary/60 transition-all duration-300 hover:shadow-md bg-gray-50/50 group max-w-2xl mx-auto",
                    {
                      "border-primary/60 shadow-md": k.value
                    }
                  ]),
                  onDragover: z[4] || (z[4] = jh(() => {
                  }, [
                    "prevent"
                  ])),
                  onDrop: jh(B, [
                    "prevent"
                  ])
                }, [
                  Ie("input", {
                    type: "file",
                    accept: "image/*",
                    multiple: "",
                    class: "hidden",
                    ref_key: "fileInput",
                    ref: f,
                    onChange: b
                  }, null, 544),
                  Ie("div", {
                    class: "flex flex-col items-center justify-center h-full cursor-pointer space-y-4",
                    onClick: z[1] || (z[1] = () => f.value.click()),
                    onDragenter: z[2] || (z[2] = jh((F) => k.value = true, [
                      "prevent"
                    ])),
                    onDragleave: z[3] || (z[3] = jh((F) => k.value = false, [
                      "prevent"
                    ]))
                  }, [
                    at(Q(aye), {
                      class: "w-8 h-8 text-primary/70 group-hover:scale-110 transition-transform duration-300"
                    }),
                    Ie("div", $Ie, [
                      Rr(it(Q(e)("modelTest.uploadText")) + " ", 1),
                      Ie("span", RIe, it(Q(e)("modelTest.uploadClickText")), 1)
                    ])
                  ], 32)
                ], 34),
                a.value.length > 0 ? (dt(), tn("div", OIe, [
                  Ie("div", NIe, [
                    (dt(true), tn(Bf, null, bM(a.value, (F, E) => (dt(), tn("div", {
                      key: E,
                      class: "relative group cursor-pointer rounded-lg overflow-hidden shadow-sm hover:shadow-lg transition-all duration-300",
                      onClick: (O) => M(F.preview)
                    }, [
                      Ie("img", {
                        src: F.preview,
                        class: "w-full h-32 object-cover",
                        alt: F.file.name
                      }, null, 8, zIe),
                      Ie("div", FIe, [
                        Ie("span", VIe, it(F.file.name), 1)
                      ])
                    ], 8, BIe))), 128))
                  ])
                ])) : zf("", true)
              ]),
              _: 1
            }),
            at(Q(j1), null, {
              default: Me(() => [
                Ie("div", GIe, [
                  Ie("div", WIe, [
                    Ie("label", HIe, it(Q(e)("modelTest.warmupCount")) + ":", 1),
                    qv(Ie("input", {
                      type: "number",
                      "onUpdate:modelValue": z[5] || (z[5] = (F) => d.value = F),
                      min: "1",
                      max: "100",
                      disabled: o.value,
                      class: "w-24 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, null, 8, UIe), [
                      [
                        Q1,
                        d.value
                      ]
                    ])
                  ]),
                  Ie("div", YIe, [
                    Ie("label", qIe, it(Q(e)("modelTest.inferenceCount")) + ":", 1),
                    qv(Ie("input", {
                      type: "number",
                      "onUpdate:modelValue": z[6] || (z[6] = (F) => v.value = F),
                      min: "1",
                      max: "100",
                      disabled: o.value,
                      class: "w-24 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, null, 8, XIe), [
                      [
                        Q1,
                        v.value
                      ]
                    ])
                  ]),
                  Ie("div", jIe, [
                    Ie("label", KIe, it(Q(e)("modelTest.backend")) + ":", 1),
                    qv(Ie("select", {
                      "onUpdate:modelValue": z[7] || (z[7] = (F) => p.value = F),
                      disabled: o.value,
                      class: "w-32 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, z[10] || (z[10] = [
                      Ie("option", {
                        value: "webgl"
                      }, "WebGL", -1),
                      Ie("option", {
                        value: "webgpu"
                      }, "WebGPU", -1),
                      Ie("option", {
                        value: "wasm"
                      }, "WASM", -1)
                    ]), 8, ZIe), [
                      [
                        rK,
                        p.value
                      ]
                    ])
                  ]),
                  Ie("div", QIe, [
                    at(Q(X1), {
                      disabled: o.value || !n.value.length || !a.value.length,
                      class: "min-w-[140px] transition-all duration-300 hover:scale-105 shadow-md hover:shadow-lg disabled:opacity-50",
                      onClick: w
                    }, {
                      default: Me(() => [
                        o.value ? (dt(), Wt(Q(iye), {
                          key: 0,
                          class: "mr-2 h-4 w-4 animate-spin"
                        })) : zf("", true),
                        Rr(" " + it(Q(e)("modelTest.startTest")), 1)
                      ]),
                      _: 1
                    }, 8, [
                      "disabled"
                    ]),
                    at(Q(X1), {
                      variant: "outline",
                      disabled: !y.value,
                      class: "min-w-[140px] transition-all duration-300 hover:scale-105 shadow-sm hover:shadow-md disabled:opacity-50",
                      onClick: x
                    }, {
                      default: Me(() => [
                        Rr(it(Q(e)("modelTest.exportResults")), 1)
                      ]),
                      _: 1
                    }, 8, [
                      "disabled"
                    ])
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Ie("div", JIe, [
          at(Q(bIe), {
            modelValue: s.value,
            "onUpdate:modelValue": z[8] || (z[8] = (F) => s.value = F),
            class: "w-full"
          }, {
            default: Me(() => [
              at(Q(xIe), {
                class: "grid w-full grid-cols-2 p-1 bg-gray-100/50 rounded-lg"
              }, {
                default: Me(() => [
                  at(Q(fF), {
                    value: "chart",
                    class: "data-[state=active]:bg-white data-[state=active]:shadow-sm rounded-md transition-all duration-300"
                  }, {
                    default: Me(() => [
                      Rr(it(Q(e)("modelTest.performanceChart")), 1)
                    ]),
                    _: 1
                  }),
                  at(Q(fF), {
                    value: "table",
                    class: "data-[state=active]:bg-white data-[state=active]:shadow-sm rounded-md transition-all duration-300"
                  }, {
                    default: Me(() => [
                      Rr(it(Q(e)("modelTest.detailData")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              at(Q(hF), {
                value: "chart"
              }, {
                default: Me(() => [
                  Ie("div", eMe, [
                    Ie("div", {
                      ref_key: "performanceChart",
                      ref: c,
                      class: "h-[500px] w-full"
                    }, null, 512)
                  ])
                ]),
                _: 1
              }),
              at(Q(hF), {
                value: "table"
              }, {
                default: Me(() => [
                  Ie("div", tMe, [
                    at(Q(TIe), {
                      class: "min-w-full table-auto"
                    }, {
                      default: Me(() => [
                        at(Q(AIe), null, {
                          default: Me(() => [
                            at(Q(dF), {
                              class: "bg-gray-50/70 hover:bg-gray-50/90"
                            }, {
                              default: Me(() => [
                                at(Q(Uu), {
                                  class: "font-semibold"
                                }, {
                                  default: Me(() => [
                                    Rr(it(Q(e)("modelTest.tableColumns.model")), 1)
                                  ]),
                                  _: 1
                                }),
                                at(Q(Uu), {
                                  class: "font-semibold"
                                }, {
                                  default: Me(() => [
                                    Rr(it(Q(e)("modelTest.tableColumns.image")), 1)
                                  ]),
                                  _: 1
                                }),
                                at(Q(Uu), {
                                  class: "font-semibold"
                                }, {
                                  default: Me(() => [
                                    Rr(it(Q(e)("modelTest.tableColumns.warmupTime")), 1)
                                  ]),
                                  _: 1
                                }),
                                at(Q(Uu), {
                                  class: "font-semibold"
                                }, {
                                  default: Me(() => [
                                    Rr(it(Q(e)("modelTest.tableColumns.inferenceTime")), 1)
                                  ]),
                                  _: 1
                                }),
                                at(Q(Uu), {
                                  class: "font-semibold"
                                }, {
                                  default: Me(() => [
                                    Rr(it(Q(e)("modelTest.tableColumns.fps")), 1)
                                  ]),
                                  _: 1
                                }),
                                at(Q(Uu), {
                                  class: "font-semibold"
                                }, {
                                  default: Me(() => [
                                    Rr(it(Q(e)("modelTest.tableColumns.actions")), 1)
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        at(Q(CIe), null, {
                          default: Me(() => [
                            (dt(true), tn(Bf, null, bM(m.value, (F) => (dt(), Wt(Q(dF), {
                              key: F.modelName + F.imageName,
                              class: "hover:bg-gray-50/50 transition-colors duration-200"
                            }, {
                              default: Me(() => [
                                at(Q(Hu), {
                                  class: "font-medium"
                                }, {
                                  default: Me(() => [
                                    Rr(it(F.modelName), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                at(Q(Hu), null, {
                                  default: Me(() => [
                                    Rr(it(F.imageName), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                at(Q(Hu), null, {
                                  default: Me(() => [
                                    Rr(it(F.warmupTime), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                at(Q(Hu), null, {
                                  default: Me(() => [
                                    Rr(it(F.inferenceTime), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                at(Q(Hu), null, {
                                  default: Me(() => [
                                    Rr(it(F.fps), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                at(Q(Hu), null, {
                                  default: Me(() => [
                                    at(Q(X1), {
                                      variant: "ghost",
                                      class: "transition-all duration-300 hover:scale-110 hover:text-primary",
                                      onClick: (E) => A(F)
                                    }, {
                                      default: Me(() => [
                                        Rr(it(Q(e)("modelTest.tableColumns.viewDetail")), 1)
                                      ]),
                                      _: 2
                                    }, 1032, [
                                      "onClick"
                                    ])
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1024))), 128))
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, [
            "modelValue"
          ])
        ]),
        at(Q(fIe), {
          open: l.value,
          "onUpdate:open": z[9] || (z[9] = (F) => l.value = F)
        }, {
          default: Me(() => [
            at(Q(dIe), {
              class: "sm:max-w-[800px] rounded-xl overflow-hidden bg-white/95 shadow-xl border border-gray-100/20"
            }, {
              default: Me(() => {
                var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r2;
                return [
                  at(Q(pIe), {
                    class: "border-b pb-4"
                  }, {
                    default: Me(() => [
                      at(Q(vIe), {
                        class: "text-xl font-bold"
                      }, {
                        default: Me(() => [
                          Rr(it(Q(e)("modelTest.dialog.title")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  Ie("div", rMe, [
                    Ie("div", nMe, [
                      Ie("img", {
                        src: (_a2 = u.value) == null ? void 0 : _a2.image,
                        class: "max-w-full h-auto"
                      }, null, 8, iMe),
                      Ie("canvas", {
                        ref_key: "detailCanvas",
                        ref: h,
                        class: "max-w-full h-auto absolute top-0 left-0"
                      }, null, 512)
                    ]),
                    Ie("div", aMe, [
                      Ie("div", oMe, [
                        Ie("div", sMe, it(Q(e)("modelTest.dialog.modelName")), 1),
                        Ie("div", lMe, it((_b2 = u.value) == null ? void 0 : _b2.modelName), 1)
                      ]),
                      Ie("div", uMe, [
                        Ie("div", cMe, it(Q(e)("modelTest.dialog.backend")), 1),
                        Ie("div", hMe, it((_c2 = u.value) == null ? void 0 : _c2.backend), 1)
                      ]),
                      Ie("div", fMe, [
                        Ie("div", dMe, it(Q(e)("modelTest.dialog.detectionCount")), 1),
                        Ie("div", pMe, it((_d2 = u.value) == null ? void 0 : _d2.detections), 1)
                      ]),
                      Ie("div", vMe, [
                        Ie("div", gMe, it(Q(e)("modelTest.warmupCount")), 1),
                        Ie("div", mMe, it((_e2 = u.value) == null ? void 0 : _e2.warmupCount), 1)
                      ]),
                      Ie("div", yMe, [
                        Ie("div", _Me, it(Q(e)("modelTest.dialog.testCount")), 1),
                        Ie("div", bMe, it((_f2 = u.value) == null ? void 0 : _f2.batchSize), 1)
                      ]),
                      Ie("div", xMe, [
                        Ie("div", wMe, it(Q(e)("modelTest.dialog.totalCount")), 1),
                        Ie("div", SMe, it((((_g2 = u.value) == null ? void 0 : _g2.batchSize) ?? 0) + (((_h2 = u.value) == null ? void 0 : _h2.warmupCount) ?? 0)), 1)
                      ]),
                      Ie("div", TMe, [
                        Ie("div", CMe, it(Q(e)("modelTest.dialog.warmupTime")), 1),
                        Ie("div", AMe, it((_j = (_i2 = u.value) == null ? void 0 : _i2.warmupTime) == null ? void 0 : _j.toFixed(0)) + "ms", 1)
                      ]),
                      Ie("div", IMe, [
                        Ie("div", MMe, it(Q(e)("modelTest.dialog.avgInferenceTime")), 1),
                        Ie("div", DMe, it((_l2 = (_k2 = u.value) == null ? void 0 : _k2.inferenceTime) == null ? void 0 : _l2.toFixed(0)) + "ms", 1)
                      ]),
                      Ie("div", EMe, [
                        Ie("div", kMe, it(Q(e)("modelTest.dialog.avgFps")), 1),
                        Ie("div", PMe, it((_m2 = u.value) == null ? void 0 : _m2.fps), 1)
                      ]),
                      Ie("div", LMe, [
                        Ie("div", $Me, it(Q(e)("modelTest.dialog.minInferenceTime")), 1),
                        Ie("div", RMe, it((_o2 = (_n2 = u.value) == null ? void 0 : _n2.minInferenceTime) == null ? void 0 : _o2.toFixed(0)) + "ms", 1)
                      ]),
                      Ie("div", OMe, [
                        Ie("div", NMe, it(Q(e)("modelTest.dialog.maxInferenceTime")), 1),
                        Ie("div", BMe, it((_q2 = (_p2 = u.value) == null ? void 0 : _p2.maxInferenceTime) == null ? void 0 : _q2.toFixed(0)) + "ms", 1)
                      ]),
                      Ie("div", zMe, [
                        Ie("div", FMe, it(Q(e)("modelTest.dialog.totalTime")), 1),
                        Ie("div", VMe, it(((((_r2 = u.value) == null ? void 0 : _r2.totalTime) ?? 0) / 1e3).toFixed(1)) + "s", 1)
                      ])
                    ])
                  ])
                ];
              }),
              _: 1
            })
          ]),
          _: 1
        }, 8, [
          "open"
        ])
      ]));
    }
  });
  HMe = nK(WMe, [
    [
      "__scopeId",
      "data-v-adb1238b"
    ]
  ]);
  jMe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: HMe
  }, Symbol.toStringTag, {
    value: "Module"
  }));
});
export {
  jC as $,
  mq as A,
  En as B,
  du as C,
  Xi as D,
  qt as E,
  Zi as F,
  Sy as G,
  H1e as H,
  kB as I,
  kc as J,
  gxe as K,
  Cxe as L,
  $t as M,
  wr as N,
  Vr as O,
  rn as P,
  Dxe as Q,
  gS as R,
  jxe as S,
  Lv as T,
  dS as U,
  LB as V,
  T1 as W,
  RB as X,
  q1e as Y,
  an as Z,
  G9 as _,
  __tla,
  Fa as a,
  yq as a0,
  Jt as a1,
  fr as a2,
  $xe as a3,
  twe as a4,
  bwe as a5,
  wwe as a6,
  Iwe as a7,
  Dwe as a8,
  Ewe as a9,
  GC as aa,
  tu as ab,
  PSe as ac,
  LSe as ad,
  Mm as ae,
  TS as af,
  Ju as ag,
  ISe as ah,
  Pq as ai,
  ZB as aj,
  jB as ak,
  f1e as al,
  Em as am,
  p1e as an,
  Rq as ao,
  jMe as ap,
  xd as b,
  _g as c,
  zC as d,
  Ti as e,
  KB as f,
  Yxe as g,
  pq as h,
  Q9 as i,
  ta as j,
  dq as k,
  _we as l,
  xwe as m,
  _B as n,
  Cwe as o,
  Mwe as p,
  wq as q,
  I1e as r,
  FC as s,
  Kt as t,
  uq as u,
  d1e as v,
  Xn as w,
  Pwe as x,
  lo as y,
  z9 as z
};
