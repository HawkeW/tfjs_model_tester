const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/browserAll-C1Im70F6.js","assets/webworkerAll-Dv7AH6DU.js","assets/colorToUniform-C2GHuDhf.js","assets/CanvasPool-JF4hqPRV.js","assets/index-qfyYY3AK.js","assets/index-zZ77VIyj.css","assets/WebGPURenderer-DgUAOQ9Y.js","assets/SharedSystems-DLjwGstu.js","assets/WebGLRenderer-Cn8uWgK9.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { h as js, c as hse, _ as $g, d as h6, e as CN, r as Tt, s as dse, a as Zt, w as $i, i as d6, b as Rt, g as Ha, F as _0, f as f6, o as cm, j as lC, k as kt, T as fse, n as nu, u as J, t as Ax, l as kn, m as He, p as Qt, q as pse, v as p6, x as gse, y as O3, C as mse, z as Ca, A as vse, B as g6, D as $t, E as yse, G as Ay, H as m6, I as S0, J as IN, K as kN, L as xse, M as ld, N as bse, O as wse, P as _se, Q as Sse, R as Cse, S as qa, U as Ai, V as Ge, W as Xw, X as hD, Y as It, Z as Zr, $ as B3, a0 as Ise, a1 as kse, __tla as __tla_0 } from "./index-qfyYY3AK.js";
let e3, Nie, xa, yp, to, Nn, co, m2, Hdt, kH, am, vft, kft, pn, Dr, ri, Ri, Rft, tN, Kft, $w, Q$, AH, FA, RH, qdt, Ei, rie, fl, Eie, Gn, or, Pft, npt, wpt, Spt, Apt, Rpt, $pt, YL, Nd, Egt, Mgt, rC, uN, dg, Agt, Yie, XH, UH, fdt, aC, gdt, Kie, iwt, _x, T_, UL, $s, HH, Yft, Die, fie, mo, Aie, bpt, _pt, pH, kpt, Dpt, Fie, Adt, HL, Fn, Cie, pdt, Ua, Ept, Wl, eie;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })()
]).then(async () => {
  function TN(n, e) {
    for (var t = 0; t < e.length; t++) {
      const r = e[t];
      if (typeof r != "string" && !Array.isArray(r)) {
        for (const i in r) if (i !== "default" && !(i in n)) {
          const a = Object.getOwnPropertyDescriptor(r, i);
          a && Object.defineProperty(n, i, a.get ? a : {
            enumerable: true,
            get: () => r[i]
          });
        }
      }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
      value: "Module"
    }));
  }
  var dD = function(n, e) {
    return dD = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(t, r) {
      t.__proto__ = r;
    } || function(t, r) {
      for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
    }, dD(n, e);
  };
  function K(n, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    dD(n, e);
    function t() {
      this.constructor = n;
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
  }
  var Tse = /* @__PURE__ */ function() {
    function n() {
      this.firefox = false, this.ie = false, this.edge = false, this.newEdge = false, this.weChat = false;
    }
    return n;
  }(), Ase = /* @__PURE__ */ function() {
    function n() {
      this.browser = new Tse(), this.node = false, this.wxa = false, this.worker = false, this.svgSupported = false, this.touchEventsSupported = false, this.pointerEventsSupported = false, this.domSupported = false, this.transformSupported = false, this.transform3dSupported = false, this.hasGlobalWindow = typeof window < "u";
    }
    return n;
  }(), Dt = new Ase();
  typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (Dt.wxa = true, Dt.touchEventsSupported = true) : typeof document > "u" && typeof self < "u" ? Dt.worker = true : !Dt.hasGlobalWindow || "Deno" in window ? (Dt.node = true, Dt.svgSupported = true) : Dse(navigator.userAgent, Dt);
  function Dse(n, e) {
    var t = e.browser, r = n.match(/Firefox\/([\d.]+)/), i = n.match(/MSIE\s([\d.]+)/) || n.match(/Trident\/.+?rv:(([\d.]+))/), a = n.match(/Edge?\/([\d.]+)/), s = /micromessenger/i.test(n);
    r && (t.firefox = true, t.version = r[1]), i && (t.ie = true, t.version = i[1]), a && (t.edge = true, t.version = a[1], t.newEdge = +a[1].split(".")[0] > 18), s && (t.weChat = true), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !t.ie && !t.edge, e.pointerEventsSupported = "onpointerdown" in window && (t.edge || t.ie && +t.version >= 11), e.domSupported = typeof document < "u";
    var o = document.documentElement.style;
    e.transform3dSupported = (t.ie && "transition" in o || t.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in o) && !("OTransition" in o), e.transformSupported = e.transform3dSupported || t.ie && +t.version >= 9;
  }
  var AN = 12, v6 = "sans-serif", Ju = AN + "px " + v6, Rse = 20, $se = 100, Nse = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
  function Ese(n) {
    var e = {};
    if (typeof JSON > "u") return e;
    for (var t = 0; t < n.length; t++) {
      var r = String.fromCharCode(t + 32), i = (n.charCodeAt(t) - Rse) / $se;
      e[r] = i;
    }
    return e;
  }
  var Mse = Ese(Nse), ec = {
    createCanvas: function() {
      return typeof document < "u" && document.createElement("canvas");
    },
    measureText: /* @__PURE__ */ function() {
      var n, e;
      return function(t, r) {
        if (!n) {
          var i = ec.createCanvas();
          n = i && i.getContext("2d");
        }
        if (n) return e !== r && (e = n.font = r || Ju), n.measureText(t);
        t = t || "", r = r || Ju;
        var a = /((?:\d+)?\.?\d*)px/.exec(r), s = a && +a[1] || AN, o = 0;
        if (r.indexOf("mono") >= 0) o = s * t.length;
        else for (var l = 0; l < t.length; l++) {
          var u = Mse[t[l]];
          o += u == null ? s : u * s;
        }
        return {
          width: o
        };
      };
    }(),
    loadImage: function(n, e, t) {
      var r = new Image();
      return r.onload = e, r.onerror = t, r.src = n, r;
    }
  }, y6 = Qo([
    "Function",
    "RegExp",
    "Date",
    "Error",
    "CanvasGradient",
    "CanvasPattern",
    "Image",
    "Canvas"
  ], function(n, e) {
    return n["[object " + e + "]"] = true, n;
  }, {}), x6 = Qo([
    "Int8",
    "Uint8",
    "Uint8Clamped",
    "Int16",
    "Uint16",
    "Int32",
    "Uint32",
    "Float32",
    "Float64"
  ], function(n, e) {
    return n["[object " + e + "Array]"] = true, n;
  }, {}), hm = Object.prototype.toString, uC = Array.prototype, Pse = uC.forEach, Lse = uC.filter, DN = uC.slice, Fse = uC.map, z3 = (function() {
  }).constructor, h1 = z3 ? z3.prototype : null, RN = "__proto__", Ose = 2311;
  function b6() {
    return Ose++;
  }
  function $N() {
    for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
    typeof console < "u" && console.error.apply(console, n);
  }
  function Qe(n) {
    if (n == null || typeof n != "object") return n;
    var e = n, t = hm.call(n);
    if (t === "[object Array]") {
      if (!Jy(n)) {
        e = [];
        for (var r = 0, i = n.length; r < i; r++) e[r] = Qe(n[r]);
      }
    } else if (x6[t]) {
      if (!Jy(n)) {
        var a = n.constructor;
        if (a.from) e = a.from(n);
        else {
          e = new a(n.length);
          for (var r = 0, i = n.length; r < i; r++) e[r] = n[r];
        }
      }
    } else if (!y6[t] && !Jy(n) && !Ng(n)) {
      e = {};
      for (var s in n) n.hasOwnProperty(s) && s !== RN && (e[s] = Qe(n[s]));
    }
    return e;
  }
  function pt(n, e, t) {
    if (!Ze(e) || !Ze(n)) return t ? Qe(e) : n;
    for (var r in e) if (e.hasOwnProperty(r) && r !== RN) {
      var i = n[r], a = e[r];
      Ze(a) && Ze(i) && !de(a) && !de(i) && !Ng(a) && !Ng(i) && !V3(a) && !V3(i) && !Jy(a) && !Jy(i) ? pt(i, a, t) : (t || !(r in n)) && (n[r] = Qe(e[r]));
    }
    return n;
  }
  function NN(n, e) {
    for (var t = n[0], r = 1, i = n.length; r < i; r++) t = pt(t, n[r], e);
    return t;
  }
  function oe(n, e) {
    if (Object.assign) Object.assign(n, e);
    else for (var t in e) e.hasOwnProperty(t) && t !== RN && (n[t] = e[t]);
    return n;
  }
  function je(n, e, t) {
    for (var r = Mt(e), i = 0, a = r.length; i < a; i++) {
      var s = r[i];
      (t ? e[s] != null : n[s] == null) && (n[s] = e[s]);
    }
    return n;
  }
  function bt(n, e) {
    if (n) {
      if (n.indexOf) return n.indexOf(e);
      for (var t = 0, r = n.length; t < r; t++) if (n[t] === e) return t;
    }
    return -1;
  }
  function Bse(n, e) {
    var t = n.prototype;
    function r() {
    }
    r.prototype = e.prototype, n.prototype = new r();
    for (var i in t) t.hasOwnProperty(i) && (n.prototype[i] = t[i]);
    n.prototype.constructor = n, n.superClass = e;
  }
  function br(n, e, t) {
    if (n = "prototype" in n ? n.prototype : n, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames) for (var r = Object.getOwnPropertyNames(e), i = 0; i < r.length; i++) {
      var a = r[i];
      a !== "constructor" && (t ? e[a] != null : n[a] == null) && (n[a] = e[a]);
    }
    else je(n, e, t);
  }
  function Mi(n) {
    return !n || typeof n == "string" ? false : typeof n.length == "number";
  }
  function P(n, e, t) {
    if (n && e) if (n.forEach && n.forEach === Pse) n.forEach(e, t);
    else if (n.length === +n.length) for (var r = 0, i = n.length; r < i; r++) e.call(t, n[r], r, n);
    else for (var a in n) n.hasOwnProperty(a) && e.call(t, n[a], a, n);
  }
  function me(n, e, t) {
    if (!n) return [];
    if (!e) return EN(n);
    if (n.map && n.map === Fse) return n.map(e, t);
    for (var r = [], i = 0, a = n.length; i < a; i++) r.push(e.call(t, n[i], i, n));
    return r;
  }
  function Qo(n, e, t, r) {
    if (n && e) {
      for (var i = 0, a = n.length; i < a; i++) t = e.call(r, t, n[i], i, n);
      return t;
    }
  }
  function rn(n, e, t) {
    if (!n) return [];
    if (!e) return EN(n);
    if (n.filter && n.filter === Lse) return n.filter(e, t);
    for (var r = [], i = 0, a = n.length; i < a; i++) e.call(t, n[i], i, n) && r.push(n[i]);
    return r;
  }
  function zse(n, e, t) {
    if (n && e) {
      for (var r = 0, i = n.length; r < i; r++) if (e.call(t, n[r], r, n)) return n[r];
    }
  }
  function Mt(n) {
    if (!n) return [];
    if (Object.keys) return Object.keys(n);
    var e = [];
    for (var t in n) n.hasOwnProperty(t) && e.push(t);
    return e;
  }
  function Vse(n, e) {
    for (var t = [], r = 2; r < arguments.length; r++) t[r - 2] = arguments[r];
    return function() {
      return n.apply(e, t.concat(DN.call(arguments)));
    };
  }
  var Ae = h1 && Xe(h1.bind) ? h1.call.bind(h1.bind) : Vse;
  function lt(n) {
    for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
    return function() {
      return n.apply(this, e.concat(DN.call(arguments)));
    };
  }
  function de(n) {
    return Array.isArray ? Array.isArray(n) : hm.call(n) === "[object Array]";
  }
  function Xe(n) {
    return typeof n == "function";
  }
  function Ie(n) {
    return typeof n == "string";
  }
  function fD(n) {
    return hm.call(n) === "[object String]";
  }
  function Yt(n) {
    return typeof n == "number";
  }
  function Ze(n) {
    var e = typeof n;
    return e === "function" || !!n && e === "object";
  }
  function V3(n) {
    return !!y6[hm.call(n)];
  }
  function Ia(n) {
    return !!x6[hm.call(n)];
  }
  function Ng(n) {
    return typeof n == "object" && typeof n.nodeType == "number" && typeof n.ownerDocument == "object";
  }
  function cC(n) {
    return n.colorStops != null;
  }
  function Wse(n) {
    return n.image != null;
  }
  function Gse(n) {
    return hm.call(n) === "[object RegExp]";
  }
  function C0(n) {
    return n !== n;
  }
  function ni() {
    for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e];
    for (var t = 0, r = n.length; t < r; t++) if (n[t] != null) return n[t];
  }
  function it(n, e) {
    return n ?? e;
  }
  function Go(n, e, t) {
    return n ?? e ?? t;
  }
  function EN(n) {
    for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
    return DN.apply(n, e);
  }
  function MN(n) {
    if (typeof n == "number") return [
      n,
      n,
      n,
      n
    ];
    var e = n.length;
    return e === 2 ? [
      n[0],
      n[1],
      n[0],
      n[1]
    ] : e === 3 ? [
      n[0],
      n[1],
      n[2],
      n[1]
    ] : n;
  }
  function ta(n, e) {
    if (!n) throw new Error(e);
  }
  function Hs(n) {
    return n == null ? null : typeof n.trim == "function" ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
  var w6 = "__ec_primitive__";
  function R_(n) {
    n[w6] = true;
  }
  function Jy(n) {
    return n[w6];
  }
  var Use = function() {
    function n() {
      this.data = {};
    }
    return n.prototype.delete = function(e) {
      var t = this.has(e);
      return t && delete this.data[e], t;
    }, n.prototype.has = function(e) {
      return this.data.hasOwnProperty(e);
    }, n.prototype.get = function(e) {
      return this.data[e];
    }, n.prototype.set = function(e, t) {
      return this.data[e] = t, this;
    }, n.prototype.keys = function() {
      return Mt(this.data);
    }, n.prototype.forEach = function(e) {
      var t = this.data;
      for (var r in t) t.hasOwnProperty(r) && e(t[r], r);
    }, n;
  }(), _6 = typeof Map == "function";
  function Hse() {
    return _6 ? /* @__PURE__ */ new Map() : new Use();
  }
  var Xse = function() {
    function n(e) {
      var t = de(e);
      this.data = Hse();
      var r = this;
      e instanceof n ? e.each(i) : e && P(e, i);
      function i(a, s) {
        t ? r.set(a, s) : r.set(s, a);
      }
    }
    return n.prototype.hasKey = function(e) {
      return this.data.has(e);
    }, n.prototype.get = function(e) {
      return this.data.get(e);
    }, n.prototype.set = function(e, t) {
      return this.data.set(e, t), t;
    }, n.prototype.each = function(e, t) {
      this.data.forEach(function(r, i) {
        e.call(t, r, i);
      });
    }, n.prototype.keys = function() {
      var e = this.data.keys();
      return _6 ? Array.from(e) : e;
    }, n.prototype.removeKey = function(e) {
      this.data.delete(e);
    }, n;
  }();
  function Pe(n) {
    return new Xse(n);
  }
  function I0(n, e) {
    for (var t = new n.constructor(n.length + e.length), r = 0; r < n.length; r++) t[r] = n[r];
    for (var i = n.length, r = 0; r < e.length; r++) t[r + i] = e[r];
    return t;
  }
  function hC(n, e) {
    var t;
    if (Object.create) t = Object.create(n);
    else {
      var r = function() {
      };
      r.prototype = n, t = new r();
    }
    return e && oe(t, e), t;
  }
  function S6(n) {
    var e = n.style;
    e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none";
  }
  function $e(n, e) {
    return n.hasOwnProperty(e);
  }
  function ur() {
  }
  var Yw = 180 / Math.PI;
  function Ed(n, e) {
    return n == null && (n = 0), e == null && (e = 0), [
      n,
      e
    ];
  }
  function Wi(n, e) {
    return n[0] = e[0], n[1] = e[1], n;
  }
  function El(n) {
    return [
      n[0],
      n[1]
    ];
  }
  function Yse(n, e, t) {
    return n[0] = e, n[1] = t, n;
  }
  function W3(n, e, t) {
    return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
  }
  function pD(n, e, t, r) {
    return n[0] = e[0] + t[0] * r, n[1] = e[1] + t[1] * r, n;
  }
  function Ph(n, e, t) {
    return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n;
  }
  function gD(n) {
    return Math.sqrt(qse(n));
  }
  function qse(n) {
    return n[0] * n[0] + n[1] * n[1];
  }
  function qw(n, e, t) {
    return n[0] = e[0] * t, n[1] = e[1] * t, n;
  }
  function dm(n, e) {
    var t = gD(e);
    return t === 0 ? (n[0] = 0, n[1] = 0) : (n[0] = e[0] / t, n[1] = e[1] / t), n;
  }
  function mD(n, e) {
    return Math.sqrt((n[0] - e[0]) * (n[0] - e[0]) + (n[1] - e[1]) * (n[1] - e[1]));
  }
  var Nu = mD;
  function jse(n, e) {
    return (n[0] - e[0]) * (n[0] - e[0]) + (n[1] - e[1]) * (n[1] - e[1]);
  }
  var qh = jse;
  function jw(n, e, t, r) {
    return n[0] = e[0] + r * (t[0] - e[0]), n[1] = e[1] + r * (t[1] - e[1]), n;
  }
  function di(n, e, t) {
    var r = e[0], i = e[1];
    return n[0] = t[0] * r + t[2] * i + t[4], n[1] = t[1] * r + t[3] * i + t[5], n;
  }
  function Eu(n, e, t) {
    return n[0] = Math.min(e[0], t[0]), n[1] = Math.min(e[1], t[1]), n;
  }
  function Mu(n, e, t) {
    return n[0] = Math.max(e[0], t[0]), n[1] = Math.max(e[1], t[1]), n;
  }
  var Cp = /* @__PURE__ */ function() {
    function n(e, t) {
      this.target = e, this.topTarget = t && t.topTarget;
    }
    return n;
  }(), Kse = function() {
    function n(e) {
      this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this);
    }
    return n.prototype._dragStart = function(e) {
      for (var t = e.target; t && !t.draggable; ) t = t.parent || t.__hostTarget;
      t && (this._draggingTarget = t, t.dragging = true, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new Cp(t, e), "dragstart", e.event));
    }, n.prototype._drag = function(e) {
      var t = this._draggingTarget;
      if (t) {
        var r = e.offsetX, i = e.offsetY, a = r - this._x, s = i - this._y;
        this._x = r, this._y = i, t.drift(a, s, e), this.handler.dispatchToElement(new Cp(t, e), "drag", e.event);
        var o = this.handler.findHover(r, i, t).target, l = this._dropTarget;
        this._dropTarget = o, t !== o && (l && o !== l && this.handler.dispatchToElement(new Cp(l, e), "dragleave", e.event), o && o !== l && this.handler.dispatchToElement(new Cp(o, e), "dragenter", e.event));
      }
    }, n.prototype._dragEnd = function(e) {
      var t = this._draggingTarget;
      t && (t.dragging = false), this.handler.dispatchToElement(new Cp(t, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new Cp(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null;
    }, n;
  }(), Is = function() {
    function n(e) {
      e && (this._$eventProcessor = e);
    }
    return n.prototype.on = function(e, t, r, i) {
      this._$handlers || (this._$handlers = {});
      var a = this._$handlers;
      if (typeof t == "function" && (i = r, r = t, t = null), !r || !e) return this;
      var s = this._$eventProcessor;
      t != null && s && s.normalizeQuery && (t = s.normalizeQuery(t)), a[e] || (a[e] = []);
      for (var o = 0; o < a[e].length; o++) if (a[e][o].h === r) return this;
      var l = {
        h: r,
        query: t,
        ctx: i || this,
        callAtLast: r.zrEventfulCallAtLast
      }, u = a[e].length - 1, c = a[e][u];
      return c && c.callAtLast ? a[e].splice(u, 0, l) : a[e].push(l), this;
    }, n.prototype.isSilent = function(e) {
      var t = this._$handlers;
      return !t || !t[e] || !t[e].length;
    }, n.prototype.off = function(e, t) {
      var r = this._$handlers;
      if (!r) return this;
      if (!e) return this._$handlers = {}, this;
      if (t) {
        if (r[e]) {
          for (var i = [], a = 0, s = r[e].length; a < s; a++) r[e][a].h !== t && i.push(r[e][a]);
          r[e] = i;
        }
        r[e] && r[e].length === 0 && delete r[e];
      } else delete r[e];
      return this;
    }, n.prototype.trigger = function(e) {
      for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
      if (!this._$handlers) return this;
      var i = this._$handlers[e], a = this._$eventProcessor;
      if (i) for (var s = t.length, o = i.length, l = 0; l < o; l++) {
        var u = i[l];
        if (!(a && a.filter && u.query != null && !a.filter(e, u.query))) switch (s) {
          case 0:
            u.h.call(u.ctx);
            break;
          case 1:
            u.h.call(u.ctx, t[0]);
            break;
          case 2:
            u.h.call(u.ctx, t[0], t[1]);
            break;
          default:
            u.h.apply(u.ctx, t);
            break;
        }
      }
      return a && a.afterTrigger && a.afterTrigger(e), this;
    }, n.prototype.triggerWithContext = function(e) {
      for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
      if (!this._$handlers) return this;
      var i = this._$handlers[e], a = this._$eventProcessor;
      if (i) for (var s = t.length, o = t[s - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(a && a.filter && c.query != null && !a.filter(e, c.query))) switch (s) {
          case 0:
            c.h.call(o);
            break;
          case 1:
            c.h.call(o, t[0]);
            break;
          case 2:
            c.h.call(o, t[0], t[1]);
            break;
          default:
            c.h.apply(o, t.slice(1, s - 1));
            break;
        }
      }
      return a && a.afterTrigger && a.afterTrigger(e), this;
    }, n;
  }(), Zse = Math.log(2);
  function vD(n, e, t, r, i, a) {
    var s = r + "-" + i, o = n.length;
    if (a.hasOwnProperty(s)) return a[s];
    if (e === 1) {
      var l = Math.round(Math.log((1 << o) - 1 & ~i) / Zse);
      return n[t][l];
    }
    for (var u = r | 1 << t, c = t + 1; r & 1 << c; ) c++;
    for (var h = 0, d = 0, f = 0; d < o; d++) {
      var p = 1 << d;
      p & i || (h += (f % 2 ? -1 : 1) * n[t][d] * vD(n, e - 1, c, u, i | p, a), f++);
    }
    return a[s] = h, h;
  }
  function G3(n, e) {
    var t = [
      [
        n[0],
        n[1],
        1,
        0,
        0,
        0,
        -e[0] * n[0],
        -e[0] * n[1]
      ],
      [
        0,
        0,
        0,
        n[0],
        n[1],
        1,
        -e[1] * n[0],
        -e[1] * n[1]
      ],
      [
        n[2],
        n[3],
        1,
        0,
        0,
        0,
        -e[2] * n[2],
        -e[2] * n[3]
      ],
      [
        0,
        0,
        0,
        n[2],
        n[3],
        1,
        -e[3] * n[2],
        -e[3] * n[3]
      ],
      [
        n[4],
        n[5],
        1,
        0,
        0,
        0,
        -e[4] * n[4],
        -e[4] * n[5]
      ],
      [
        0,
        0,
        0,
        n[4],
        n[5],
        1,
        -e[5] * n[4],
        -e[5] * n[5]
      ],
      [
        n[6],
        n[7],
        1,
        0,
        0,
        0,
        -e[6] * n[6],
        -e[6] * n[7]
      ],
      [
        0,
        0,
        0,
        n[6],
        n[7],
        1,
        -e[7] * n[6],
        -e[7] * n[7]
      ]
    ], r = {}, i = vD(t, 8, 0, 0, 0, r);
    if (i !== 0) {
      for (var a = [], s = 0; s < 8; s++) for (var o = 0; o < 8; o++) a[o] == null && (a[o] = 0), a[o] += ((s + o) % 2 ? -1 : 1) * vD(t, 7, s === 0 ? 1 : 0, 1 << s, 1 << o, r) / i * e[s];
      return function(l, u, c) {
        var h = u * a[6] + c * a[7] + 1;
        l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
      };
    }
  }
  var U3 = "___zrEVENTSAVED", A2 = [];
  function Qse(n, e, t, r, i) {
    return yD(A2, e, r, i, true) && yD(n, t, A2[0], A2[1]);
  }
  function yD(n, e, t, r, i) {
    if (e.getBoundingClientRect && Dt.domSupported && !C6(e)) {
      var a = e[U3] || (e[U3] = {}), s = Jse(e, a), o = eoe(s, a, i);
      if (o) return o(n, t, r), true;
    }
    return false;
  }
  function Jse(n, e) {
    var t = e.markers;
    if (t) return t;
    t = e.markers = [];
    for (var r = [
      "left",
      "right"
    ], i = [
      "top",
      "bottom"
    ], a = 0; a < 4; a++) {
      var s = document.createElement("div"), o = s.style, l = a % 2, u = (a >> 1) % 2;
      o.cssText = [
        "position: absolute",
        "visibility: hidden",
        "padding: 0",
        "margin: 0",
        "border-width: 0",
        "user-select: none",
        "width:0",
        "height:0",
        r[l] + ":0",
        i[u] + ":0",
        r[1 - l] + ":auto",
        i[1 - u] + ":auto",
        ""
      ].join("!important;"), n.appendChild(s), t.push(s);
    }
    return t;
  }
  function eoe(n, e, t) {
    for (var r = t ? "invTrans" : "trans", i = e[r], a = e.srcCoords, s = [], o = [], l = true, u = 0; u < 4; u++) {
      var c = n[u].getBoundingClientRect(), h = 2 * u, d = c.left, f = c.top;
      s.push(d, f), l = l && a && d === a[h] && f === a[h + 1], o.push(n[u].offsetLeft, n[u].offsetTop);
    }
    return l && i ? i : (e.srcCoords = s, e[r] = t ? G3(o, s) : G3(s, o));
  }
  function C6(n) {
    return n.nodeName.toUpperCase() === "CANVAS";
  }
  var toe = /([&<>"'])/g, noe = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function Hi(n) {
    return n == null ? "" : (n + "").replace(toe, function(e, t) {
      return noe[t];
    });
  }
  var roe = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, D2 = [], ioe = Dt.browser.firefox && +Dt.browser.version.split(".")[0] < 39;
  function xD(n, e, t, r) {
    return t = t || {}, r ? H3(n, e, t) : ioe && e.layerX != null && e.layerX !== e.offsetX ? (t.zrX = e.layerX, t.zrY = e.layerY) : e.offsetX != null ? (t.zrX = e.offsetX, t.zrY = e.offsetY) : H3(n, e, t), t;
  }
  function H3(n, e, t) {
    if (Dt.domSupported && n.getBoundingClientRect) {
      var r = e.clientX, i = e.clientY;
      if (C6(n)) {
        var a = n.getBoundingClientRect();
        t.zrX = r - a.left, t.zrY = i - a.top;
        return;
      } else if (yD(D2, n, r, i)) {
        t.zrX = D2[0], t.zrY = D2[1];
        return;
      }
    }
    t.zrX = t.zrY = 0;
  }
  function PN(n) {
    return n || window.event;
  }
  function ss(n, e, t) {
    if (e = PN(e), e.zrX != null) return e;
    var r = e.type, i = r && r.indexOf("touch") >= 0;
    if (i) {
      var s = r !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
      s && xD(n, s, e, t);
    } else {
      xD(n, e, e, t);
      var a = aoe(e);
      e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3;
    }
    var o = e.button;
    return e.which == null && o !== void 0 && roe.test(e.type) && (e.which = o & 1 ? 1 : o & 2 ? 3 : o & 4 ? 2 : 0), e;
  }
  function aoe(n) {
    var e = n.wheelDelta;
    if (e) return e;
    var t = n.deltaX, r = n.deltaY;
    if (t == null || r == null) return e;
    var i = Math.abs(r !== 0 ? r : t), a = r > 0 ? -1 : r < 0 ? 1 : t > 0 ? -1 : 1;
    return 3 * i * a;
  }
  function bD(n, e, t, r) {
    n.addEventListener(e, t, r);
  }
  function soe(n, e, t, r) {
    n.removeEventListener(e, t, r);
  }
  var Ul = function(n) {
    n.preventDefault(), n.stopPropagation(), n.cancelBubble = true;
  };
  function X3(n) {
    return n.which === 2 || n.which === 3;
  }
  var ooe = function() {
    function n() {
      this._track = [];
    }
    return n.prototype.recognize = function(e, t, r) {
      return this._doTrack(e, t, r), this._recognize(e);
    }, n.prototype.clear = function() {
      return this._track.length = 0, this;
    }, n.prototype._doTrack = function(e, t, r) {
      var i = e.touches;
      if (i) {
        for (var a = {
          points: [],
          touches: [],
          target: t,
          event: e
        }, s = 0, o = i.length; s < o; s++) {
          var l = i[s], u = xD(r, l, {});
          a.points.push([
            u.zrX,
            u.zrY
          ]), a.touches.push(l);
        }
        this._track.push(a);
      }
    }, n.prototype._recognize = function(e) {
      for (var t in R2) if (R2.hasOwnProperty(t)) {
        var r = R2[t](this._track, e);
        if (r) return r;
      }
    }, n;
  }();
  function Y3(n) {
    var e = n[1][0] - n[0][0], t = n[1][1] - n[0][1];
    return Math.sqrt(e * e + t * t);
  }
  function loe(n) {
    return [
      (n[0][0] + n[1][0]) / 2,
      (n[0][1] + n[1][1]) / 2
    ];
  }
  var R2 = {
    pinch: function(n, e) {
      var t = n.length;
      if (t) {
        var r = (n[t - 1] || {}).points, i = (n[t - 2] || {}).points || r;
        if (i && i.length > 1 && r && r.length > 1) {
          var a = Y3(r) / Y3(i);
          !isFinite(a) && (a = 1), e.pinchScale = a;
          var s = loe(r);
          return e.pinchX = s[0], e.pinchY = s[1], {
            type: "pinch",
            target: n[0].target,
            event: e
          };
        }
      }
    }
  };
  function za() {
    return [
      1,
      0,
      0,
      1,
      0,
      0
    ];
  }
  function dC(n) {
    return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n;
  }
  function LN(n, e) {
    return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n;
  }
  function Ml(n, e, t) {
    var r = e[0] * t[0] + e[2] * t[1], i = e[1] * t[0] + e[3] * t[1], a = e[0] * t[2] + e[2] * t[3], s = e[1] * t[2] + e[3] * t[3], o = e[0] * t[4] + e[2] * t[5] + e[4], l = e[1] * t[4] + e[3] * t[5] + e[5];
    return n[0] = r, n[1] = i, n[2] = a, n[3] = s, n[4] = o, n[5] = l, n;
  }
  function Jo(n, e, t) {
    return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4] + t[0], n[5] = e[5] + t[1], n;
  }
  function Md(n, e, t, r) {
    r === void 0 && (r = [
      0,
      0
    ]);
    var i = e[0], a = e[2], s = e[4], o = e[1], l = e[3], u = e[5], c = Math.sin(t), h = Math.cos(t);
    return n[0] = i * h + o * c, n[1] = -i * c + o * h, n[2] = a * h + l * c, n[3] = -a * c + h * l, n[4] = h * (s - r[0]) + c * (u - r[1]) + r[0], n[5] = h * (u - r[1]) - c * (s - r[0]) + r[1], n;
  }
  function FN(n, e, t) {
    var r = t[0], i = t[1];
    return n[0] = e[0] * r, n[1] = e[1] * i, n[2] = e[2] * r, n[3] = e[3] * i, n[4] = e[4] * r, n[5] = e[5] * i, n;
  }
  function fm(n, e) {
    var t = e[0], r = e[2], i = e[4], a = e[1], s = e[3], o = e[5], l = t * s - a * r;
    return l ? (l = 1 / l, n[0] = s * l, n[1] = -a * l, n[2] = -r * l, n[3] = t * l, n[4] = (r * o - s * i) * l, n[5] = (a * i - t * o) * l, n) : null;
  }
  function uoe(n) {
    var e = za();
    return LN(e, n), e;
  }
  var mt = function() {
    function n(e, t) {
      this.x = e || 0, this.y = t || 0;
    }
    return n.prototype.copy = function(e) {
      return this.x = e.x, this.y = e.y, this;
    }, n.prototype.clone = function() {
      return new n(this.x, this.y);
    }, n.prototype.set = function(e, t) {
      return this.x = e, this.y = t, this;
    }, n.prototype.equal = function(e) {
      return e.x === this.x && e.y === this.y;
    }, n.prototype.add = function(e) {
      return this.x += e.x, this.y += e.y, this;
    }, n.prototype.scale = function(e) {
      this.x *= e, this.y *= e;
    }, n.prototype.scaleAndAdd = function(e, t) {
      this.x += e.x * t, this.y += e.y * t;
    }, n.prototype.sub = function(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }, n.prototype.dot = function(e) {
      return this.x * e.x + this.y * e.y;
    }, n.prototype.len = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }, n.prototype.lenSquare = function() {
      return this.x * this.x + this.y * this.y;
    }, n.prototype.normalize = function() {
      var e = this.len();
      return this.x /= e, this.y /= e, this;
    }, n.prototype.distance = function(e) {
      var t = this.x - e.x, r = this.y - e.y;
      return Math.sqrt(t * t + r * r);
    }, n.prototype.distanceSquare = function(e) {
      var t = this.x - e.x, r = this.y - e.y;
      return t * t + r * r;
    }, n.prototype.negate = function() {
      return this.x = -this.x, this.y = -this.y, this;
    }, n.prototype.transform = function(e) {
      if (e) {
        var t = this.x, r = this.y;
        return this.x = e[0] * t + e[2] * r + e[4], this.y = e[1] * t + e[3] * r + e[5], this;
      }
    }, n.prototype.toArray = function(e) {
      return e[0] = this.x, e[1] = this.y, e;
    }, n.prototype.fromArray = function(e) {
      this.x = e[0], this.y = e[1];
    }, n.set = function(e, t, r) {
      e.x = t, e.y = r;
    }, n.copy = function(e, t) {
      e.x = t.x, e.y = t.y;
    }, n.len = function(e) {
      return Math.sqrt(e.x * e.x + e.y * e.y);
    }, n.lenSquare = function(e) {
      return e.x * e.x + e.y * e.y;
    }, n.dot = function(e, t) {
      return e.x * t.x + e.y * t.y;
    }, n.add = function(e, t, r) {
      e.x = t.x + r.x, e.y = t.y + r.y;
    }, n.sub = function(e, t, r) {
      e.x = t.x - r.x, e.y = t.y - r.y;
    }, n.scale = function(e, t, r) {
      e.x = t.x * r, e.y = t.y * r;
    }, n.scaleAndAdd = function(e, t, r, i) {
      e.x = t.x + r.x * i, e.y = t.y + r.y * i;
    }, n.lerp = function(e, t, r, i) {
      var a = 1 - i;
      e.x = a * t.x + i * r.x, e.y = a * t.y + i * r.y;
    }, n;
  }(), d1 = Math.min, f1 = Math.max, Bc = new mt(), zc = new mt(), Vc = new mt(), Wc = new mt(), Uv = new mt(), Hv = new mt(), vt = function() {
    function n(e, t, r, i) {
      r < 0 && (e = e + r, r = -r), i < 0 && (t = t + i, i = -i), this.x = e, this.y = t, this.width = r, this.height = i;
    }
    return n.prototype.union = function(e) {
      var t = d1(e.x, this.x), r = d1(e.y, this.y);
      isFinite(this.x) && isFinite(this.width) ? this.width = f1(e.x + e.width, this.x + this.width) - t : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = f1(e.y + e.height, this.y + this.height) - r : this.height = e.height, this.x = t, this.y = r;
    }, n.prototype.applyTransform = function(e) {
      n.applyTransform(this, this, e);
    }, n.prototype.calculateTransform = function(e) {
      var t = this, r = e.width / t.width, i = e.height / t.height, a = za();
      return Jo(a, a, [
        -t.x,
        -t.y
      ]), FN(a, a, [
        r,
        i
      ]), Jo(a, a, [
        e.x,
        e.y
      ]), a;
    }, n.prototype.intersect = function(e, t) {
      if (!e) return false;
      e instanceof n || (e = n.create(e));
      var r = this, i = r.x, a = r.x + r.width, s = r.y, o = r.y + r.height, l = e.x, u = e.x + e.width, c = e.y, h = e.y + e.height, d = !(a < l || u < i || o < c || h < s);
      if (t) {
        var f = 1 / 0, p = 0, g = Math.abs(a - l), m = Math.abs(u - i), v = Math.abs(o - c), y = Math.abs(h - s), x = Math.min(g, m), b = Math.min(v, y);
        a < l || u < i ? x > p && (p = x, g < m ? mt.set(Hv, -g, 0) : mt.set(Hv, m, 0)) : x < f && (f = x, g < m ? mt.set(Uv, g, 0) : mt.set(Uv, -m, 0)), o < c || h < s ? b > p && (p = b, v < y ? mt.set(Hv, 0, -v) : mt.set(Hv, 0, y)) : x < f && (f = x, v < y ? mt.set(Uv, 0, v) : mt.set(Uv, 0, -y));
      }
      return t && mt.copy(t, d ? Uv : Hv), d;
    }, n.prototype.contain = function(e, t) {
      var r = this;
      return e >= r.x && e <= r.x + r.width && t >= r.y && t <= r.y + r.height;
    }, n.prototype.clone = function() {
      return new n(this.x, this.y, this.width, this.height);
    }, n.prototype.copy = function(e) {
      n.copy(this, e);
    }, n.prototype.plain = function() {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      };
    }, n.prototype.isFinite = function() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    }, n.prototype.isZero = function() {
      return this.width === 0 || this.height === 0;
    }, n.create = function(e) {
      return new n(e.x, e.y, e.width, e.height);
    }, n.copy = function(e, t) {
      e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height;
    }, n.applyTransform = function(e, t, r) {
      if (!r) {
        e !== t && n.copy(e, t);
        return;
      }
      if (r[1] < 1e-5 && r[1] > -1e-5 && r[2] < 1e-5 && r[2] > -1e-5) {
        var i = r[0], a = r[3], s = r[4], o = r[5];
        e.x = t.x * i + s, e.y = t.y * a + o, e.width = t.width * i, e.height = t.height * a, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
        return;
      }
      Bc.x = Vc.x = t.x, Bc.y = Wc.y = t.y, zc.x = Wc.x = t.x + t.width, zc.y = Vc.y = t.y + t.height, Bc.transform(r), Wc.transform(r), zc.transform(r), Vc.transform(r), e.x = d1(Bc.x, zc.x, Vc.x, Wc.x), e.y = d1(Bc.y, zc.y, Vc.y, Wc.y);
      var l = f1(Bc.x, zc.x, Vc.x, Wc.x), u = f1(Bc.y, zc.y, Vc.y, Wc.y);
      e.width = l - e.x, e.height = u - e.y;
    }, n;
  }(), I6 = "silent";
  function coe(n, e, t) {
    return {
      type: n,
      event: t,
      target: e.target,
      topTarget: e.topTarget,
      cancelBubble: false,
      offsetX: t.zrX,
      offsetY: t.zrY,
      gestureEvent: t.gestureEvent,
      pinchX: t.pinchX,
      pinchY: t.pinchY,
      pinchScale: t.pinchScale,
      wheelDelta: t.zrDelta,
      zrByTouch: t.zrByTouch,
      which: t.which,
      stop: hoe
    };
  }
  function hoe() {
    Ul(this.event);
  }
  var doe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.handler = null, t;
    }
    return e.prototype.dispose = function() {
    }, e.prototype.setCursor = function() {
    }, e;
  }(Is), Xv = /* @__PURE__ */ function() {
    function n(e, t) {
      this.x = e, this.y = t;
    }
    return n;
  }(), foe = [
    "click",
    "dblclick",
    "mousewheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], $2 = new vt(0, 0, 0, 0), k6 = function(n) {
    K(e, n);
    function e(t, r, i, a, s) {
      var o = n.call(this) || this;
      return o._hovered = new Xv(0, 0), o.storage = t, o.painter = r, o.painterRoot = a, o._pointerSize = s, i = i || new doe(), o.proxy = null, o.setHandlerProxy(i), o._draggingMgr = new Kse(o), o;
    }
    return e.prototype.setHandlerProxy = function(t) {
      this.proxy && this.proxy.dispose(), t && (P(foe, function(r) {
        t.on && t.on(r, this[r], this);
      }, this), t.handler = this), this.proxy = t;
    }, e.prototype.mousemove = function(t) {
      var r = t.zrX, i = t.zrY, a = T6(this, r, i), s = this._hovered, o = s.target;
      o && !o.__zr && (s = this.findHover(s.x, s.y), o = s.target);
      var l = this._hovered = a ? new Xv(r, i) : this.findHover(r, i), u = l.target, c = this.proxy;
      c.setCursor && c.setCursor(u ? u.cursor : "default"), o && u !== o && this.dispatchToElement(s, "mouseout", t), this.dispatchToElement(l, "mousemove", t), u && u !== o && this.dispatchToElement(l, "mouseover", t);
    }, e.prototype.mouseout = function(t) {
      var r = t.zrEventControl;
      r !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), r !== "no_globalout" && this.trigger("globalout", {
        type: "globalout",
        event: t
      });
    }, e.prototype.resize = function() {
      this._hovered = new Xv(0, 0);
    }, e.prototype.dispatch = function(t, r) {
      var i = this[t];
      i && i.call(this, r);
    }, e.prototype.dispose = function() {
      this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
    }, e.prototype.setCursorStyle = function(t) {
      var r = this.proxy;
      r.setCursor && r.setCursor(t);
    }, e.prototype.dispatchToElement = function(t, r, i) {
      t = t || {};
      var a = t.target;
      if (!(a && a.silent)) {
        for (var s = "on" + r, o = coe(r, t, i); a && (a[s] && (o.cancelBubble = !!a[s].call(a, o)), a.trigger(r, o), a = a.__hostTarget ? a.__hostTarget : a.parent, !o.cancelBubble); ) ;
        o.cancelBubble || (this.trigger(r, o), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
          typeof l[s] == "function" && l[s].call(l, o), l.trigger && l.trigger(r, o);
        }));
      }
    }, e.prototype.findHover = function(t, r, i) {
      var a = this.storage.getDisplayList(), s = new Xv(t, r);
      if (q3(a, s, t, r, i), this._pointerSize && !s.target) {
        for (var o = [], l = this._pointerSize, u = l / 2, c = new vt(t - u, r - u, l, l), h = a.length - 1; h >= 0; h--) {
          var d = a[h];
          d !== i && !d.ignore && !d.ignoreCoarsePointer && (!d.parent || !d.parent.ignoreCoarsePointer) && ($2.copy(d.getBoundingRect()), d.transform && $2.applyTransform(d.transform), $2.intersect(c) && o.push(d));
        }
        if (o.length) for (var f = 4, p = Math.PI / 12, g = Math.PI * 2, m = 0; m < u; m += f) for (var v = 0; v < g; v += p) {
          var y = t + m * Math.cos(v), x = r + m * Math.sin(v);
          if (q3(o, s, y, x, i), s.target) return s;
        }
      }
      return s;
    }, e.prototype.processGesture = function(t, r) {
      this._gestureMgr || (this._gestureMgr = new ooe());
      var i = this._gestureMgr;
      r === "start" && i.clear();
      var a = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
      if (r === "end" && i.clear(), a) {
        var s = a.type;
        t.gestureEvent = s;
        var o = new Xv();
        o.target = a.target, this.dispatchToElement(o, s, a.event);
      }
    }, e;
  }(Is);
  P([
    "click",
    "mousedown",
    "mouseup",
    "mousewheel",
    "dblclick",
    "contextmenu"
  ], function(n) {
    k6.prototype[n] = function(e) {
      var t = e.zrX, r = e.zrY, i = T6(this, t, r), a, s;
      if ((n !== "mouseup" || !i) && (a = this.findHover(t, r), s = a.target), n === "mousedown") this._downEl = s, this._downPoint = [
        e.zrX,
        e.zrY
      ], this._upEl = s;
      else if (n === "mouseup") this._upEl = s;
      else if (n === "click") {
        if (this._downEl !== this._upEl || !this._downPoint || Nu(this._downPoint, [
          e.zrX,
          e.zrY
        ]) > 4) return;
        this._downPoint = null;
      }
      this.dispatchToElement(a, n, e);
    };
  });
  function poe(n, e, t) {
    if (n[n.rectHover ? "rectContain" : "contain"](e, t)) {
      for (var r = n, i = void 0, a = false; r; ) {
        if (r.ignoreClip && (a = true), !a) {
          var s = r.getClipPath();
          if (s && !s.contain(e, t)) return false;
        }
        r.silent && (i = true);
        var o = r.__hostTarget;
        r = o || r.parent;
      }
      return i ? I6 : true;
    }
    return false;
  }
  function q3(n, e, t, r, i) {
    for (var a = n.length - 1; a >= 0; a--) {
      var s = n[a], o = void 0;
      if (s !== i && !s.ignore && (o = poe(s, t, r)) && (!e.topTarget && (e.topTarget = s), o !== I6)) {
        e.target = s;
        break;
      }
    }
  }
  function T6(n, e, t) {
    var r = n.painter;
    return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight();
  }
  var A6 = 32, Yv = 7;
  function goe(n) {
    for (var e = 0; n >= A6; ) e |= n & 1, n >>= 1;
    return n + e;
  }
  function j3(n, e, t, r) {
    var i = e + 1;
    if (i === t) return 1;
    if (r(n[i++], n[e]) < 0) {
      for (; i < t && r(n[i], n[i - 1]) < 0; ) i++;
      moe(n, e, i);
    } else for (; i < t && r(n[i], n[i - 1]) >= 0; ) i++;
    return i - e;
  }
  function moe(n, e, t) {
    for (t--; e < t; ) {
      var r = n[e];
      n[e++] = n[t], n[t--] = r;
    }
  }
  function K3(n, e, t, r, i) {
    for (r === e && r++; r < t; r++) {
      for (var a = n[r], s = e, o = r, l; s < o; ) l = s + o >>> 1, i(a, n[l]) < 0 ? o = l : s = l + 1;
      var u = r - s;
      switch (u) {
        case 3:
          n[s + 3] = n[s + 2];
        case 2:
          n[s + 2] = n[s + 1];
        case 1:
          n[s + 1] = n[s];
          break;
        default:
          for (; u > 0; ) n[s + u] = n[s + u - 1], u--;
      }
      n[s] = a;
    }
  }
  function N2(n, e, t, r, i, a) {
    var s = 0, o = 0, l = 1;
    if (a(n, e[t + i]) > 0) {
      for (o = r - i; l < o && a(n, e[t + i + l]) > 0; ) s = l, l = (l << 1) + 1, l <= 0 && (l = o);
      l > o && (l = o), s += i, l += i;
    } else {
      for (o = i + 1; l < o && a(n, e[t + i - l]) <= 0; ) s = l, l = (l << 1) + 1, l <= 0 && (l = o);
      l > o && (l = o);
      var u = s;
      s = i - l, l = i - u;
    }
    for (s++; s < l; ) {
      var c = s + (l - s >>> 1);
      a(n, e[t + c]) > 0 ? s = c + 1 : l = c;
    }
    return l;
  }
  function E2(n, e, t, r, i, a) {
    var s = 0, o = 0, l = 1;
    if (a(n, e[t + i]) < 0) {
      for (o = i + 1; l < o && a(n, e[t + i - l]) < 0; ) s = l, l = (l << 1) + 1, l <= 0 && (l = o);
      l > o && (l = o);
      var u = s;
      s = i - l, l = i - u;
    } else {
      for (o = r - i; l < o && a(n, e[t + i + l]) >= 0; ) s = l, l = (l << 1) + 1, l <= 0 && (l = o);
      l > o && (l = o), s += i, l += i;
    }
    for (s++; s < l; ) {
      var c = s + (l - s >>> 1);
      a(n, e[t + c]) < 0 ? l = c : s = c + 1;
    }
    return l;
  }
  function voe(n, e) {
    var t = Yv, r, i, a = 0, s = [];
    r = [], i = [];
    function o(f, p) {
      r[a] = f, i[a] = p, a += 1;
    }
    function l() {
      for (; a > 1; ) {
        var f = a - 2;
        if (f >= 1 && i[f - 1] <= i[f] + i[f + 1] || f >= 2 && i[f - 2] <= i[f] + i[f - 1]) i[f - 1] < i[f + 1] && f--;
        else if (i[f] > i[f + 1]) break;
        c(f);
      }
    }
    function u() {
      for (; a > 1; ) {
        var f = a - 2;
        f > 0 && i[f - 1] < i[f + 1] && f--, c(f);
      }
    }
    function c(f) {
      var p = r[f], g = i[f], m = r[f + 1], v = i[f + 1];
      i[f] = g + v, f === a - 3 && (r[f + 1] = r[f + 2], i[f + 1] = i[f + 2]), a--;
      var y = E2(n[m], n, p, g, 0, e);
      p += y, g -= y, g !== 0 && (v = N2(n[p + g - 1], n, m, v, v - 1, e), v !== 0 && (g <= v ? h(p, g, m, v) : d(p, g, m, v)));
    }
    function h(f, p, g, m) {
      var v = 0;
      for (v = 0; v < p; v++) s[v] = n[f + v];
      var y = 0, x = g, b = f;
      if (n[b++] = n[x++], --m === 0) {
        for (v = 0; v < p; v++) n[b + v] = s[y + v];
        return;
      }
      if (p === 1) {
        for (v = 0; v < m; v++) n[b + v] = n[x + v];
        n[b + m] = s[y];
        return;
      }
      for (var w = t, _, S, I; ; ) {
        _ = 0, S = 0, I = false;
        do
          if (e(n[x], s[y]) < 0) {
            if (n[b++] = n[x++], S++, _ = 0, --m === 0) {
              I = true;
              break;
            }
          } else if (n[b++] = s[y++], _++, S = 0, --p === 1) {
            I = true;
            break;
          }
        while ((_ | S) < w);
        if (I) break;
        do {
          if (_ = E2(n[x], s, y, p, 0, e), _ !== 0) {
            for (v = 0; v < _; v++) n[b + v] = s[y + v];
            if (b += _, y += _, p -= _, p <= 1) {
              I = true;
              break;
            }
          }
          if (n[b++] = n[x++], --m === 0) {
            I = true;
            break;
          }
          if (S = N2(s[y], n, x, m, 0, e), S !== 0) {
            for (v = 0; v < S; v++) n[b + v] = n[x + v];
            if (b += S, x += S, m -= S, m === 0) {
              I = true;
              break;
            }
          }
          if (n[b++] = s[y++], --p === 1) {
            I = true;
            break;
          }
          w--;
        } while (_ >= Yv || S >= Yv);
        if (I) break;
        w < 0 && (w = 0), w += 2;
      }
      if (t = w, t < 1 && (t = 1), p === 1) {
        for (v = 0; v < m; v++) n[b + v] = n[x + v];
        n[b + m] = s[y];
      } else {
        if (p === 0) throw new Error();
        for (v = 0; v < p; v++) n[b + v] = s[y + v];
      }
    }
    function d(f, p, g, m) {
      var v = 0;
      for (v = 0; v < m; v++) s[v] = n[g + v];
      var y = f + p - 1, x = m - 1, b = g + m - 1, w = 0, _ = 0;
      if (n[b--] = n[y--], --p === 0) {
        for (w = b - (m - 1), v = 0; v < m; v++) n[w + v] = s[v];
        return;
      }
      if (m === 1) {
        for (b -= p, y -= p, _ = b + 1, w = y + 1, v = p - 1; v >= 0; v--) n[_ + v] = n[w + v];
        n[b] = s[x];
        return;
      }
      for (var S = t; ; ) {
        var I = 0, C = 0, T = false;
        do
          if (e(s[x], n[y]) < 0) {
            if (n[b--] = n[y--], I++, C = 0, --p === 0) {
              T = true;
              break;
            }
          } else if (n[b--] = s[x--], C++, I = 0, --m === 1) {
            T = true;
            break;
          }
        while ((I | C) < S);
        if (T) break;
        do {
          if (I = p - E2(s[x], n, f, p, p - 1, e), I !== 0) {
            for (b -= I, y -= I, p -= I, _ = b + 1, w = y + 1, v = I - 1; v >= 0; v--) n[_ + v] = n[w + v];
            if (p === 0) {
              T = true;
              break;
            }
          }
          if (n[b--] = s[x--], --m === 1) {
            T = true;
            break;
          }
          if (C = m - N2(n[y], s, 0, m, m - 1, e), C !== 0) {
            for (b -= C, x -= C, m -= C, _ = b + 1, w = x + 1, v = 0; v < C; v++) n[_ + v] = s[w + v];
            if (m <= 1) {
              T = true;
              break;
            }
          }
          if (n[b--] = n[y--], --p === 0) {
            T = true;
            break;
          }
          S--;
        } while (I >= Yv || C >= Yv);
        if (T) break;
        S < 0 && (S = 0), S += 2;
      }
      if (t = S, t < 1 && (t = 1), m === 1) {
        for (b -= p, y -= p, _ = b + 1, w = y + 1, v = p - 1; v >= 0; v--) n[_ + v] = n[w + v];
        n[b] = s[x];
      } else {
        if (m === 0) throw new Error();
        for (w = b - (m - 1), v = 0; v < m; v++) n[w + v] = s[v];
      }
    }
    return {
      mergeRuns: l,
      forceMergeRuns: u,
      pushRun: o
    };
  }
  function Kw(n, e, t, r) {
    t || (t = 0), r || (r = n.length);
    var i = r - t;
    if (!(i < 2)) {
      var a = 0;
      if (i < A6) {
        a = j3(n, t, r, e), K3(n, t, r, t + a, e);
        return;
      }
      var s = voe(n, e), o = goe(i);
      do {
        if (a = j3(n, t, r, e), a < o) {
          var l = i;
          l > o && (l = o), K3(n, t, t + l, t + a, e), a = l;
        }
        s.pushRun(t, a), s.mergeRuns(), i -= a, t += a;
      } while (i !== 0);
      s.forceMergeRuns();
    }
  }
  var Uo = 1, Zw = 2, Dy = 4, Z3 = false;
  function M2() {
    Z3 || (Z3 = true, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
  }
  function Q3(n, e) {
    return n.zlevel === e.zlevel ? n.z === e.z ? n.z2 - e.z2 : n.z - e.z : n.zlevel - e.zlevel;
  }
  var yoe = function() {
    function n() {
      this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = Q3;
    }
    return n.prototype.traverse = function(e, t) {
      for (var r = 0; r < this._roots.length; r++) this._roots[r].traverse(e, t);
    }, n.prototype.getDisplayList = function(e, t) {
      t = t || false;
      var r = this._displayList;
      return (e || !r.length) && this.updateDisplayList(t), r;
    }, n.prototype.updateDisplayList = function(e) {
      this._displayListLen = 0;
      for (var t = this._roots, r = this._displayList, i = 0, a = t.length; i < a; i++) this._updateAndAddDisplayable(t[i], null, e);
      r.length = this._displayListLen, Kw(r, Q3);
    }, n.prototype._updateAndAddDisplayable = function(e, t, r) {
      if (!(e.ignore && !r)) {
        e.beforeUpdate(), e.update(), e.afterUpdate();
        var i = e.getClipPath();
        if (e.ignoreClip) t = null;
        else if (i) {
          t ? t = t.slice() : t = [];
          for (var a = i, s = e; a; ) a.parent = s, a.updateTransform(), t.push(a), s = a, a = a.getClipPath();
        }
        if (e.childrenRef) {
          for (var o = e.childrenRef(), l = 0; l < o.length; l++) {
            var u = o[l];
            e.__dirty && (u.__dirty |= Uo), this._updateAndAddDisplayable(u, t, r);
          }
          e.__dirty = 0;
        } else {
          var c = e;
          t && t.length ? c.__clipPaths = t : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (M2(), c.z = 0), isNaN(c.z2) && (M2(), c.z2 = 0), isNaN(c.zlevel) && (M2(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
        }
        var h = e.getDecalElement && e.getDecalElement();
        h && this._updateAndAddDisplayable(h, t, r);
        var d = e.getTextGuideLine();
        d && this._updateAndAddDisplayable(d, t, r);
        var f = e.getTextContent();
        f && this._updateAndAddDisplayable(f, t, r);
      }
    }, n.prototype.addRoot = function(e) {
      e.__zr && e.__zr.storage === this || this._roots.push(e);
    }, n.prototype.delRoot = function(e) {
      if (e instanceof Array) {
        for (var t = 0, r = e.length; t < r; t++) this.delRoot(e[t]);
        return;
      }
      var i = bt(this._roots, e);
      i >= 0 && this._roots.splice(i, 1);
    }, n.prototype.delAllRoots = function() {
      this._roots = [], this._displayList = [], this._displayListLen = 0;
    }, n.prototype.getRoots = function() {
      return this._roots;
    }, n.prototype.dispose = function() {
      this._displayList = null, this._roots = null;
    }, n;
  }(), $_;
  $_ = Dt.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(n) {
    return setTimeout(n, 16);
  };
  var e0 = {
    linear: function(n) {
      return n;
    },
    quadraticIn: function(n) {
      return n * n;
    },
    quadraticOut: function(n) {
      return n * (2 - n);
    },
    quadraticInOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);
    },
    cubicIn: function(n) {
      return n * n * n;
    },
    cubicOut: function(n) {
      return --n * n * n + 1;
    },
    cubicInOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);
    },
    quarticIn: function(n) {
      return n * n * n * n;
    },
    quarticOut: function(n) {
      return 1 - --n * n * n * n;
    },
    quarticInOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2);
    },
    quinticIn: function(n) {
      return n * n * n * n * n;
    },
    quinticOut: function(n) {
      return --n * n * n * n * n + 1;
    },
    quinticInOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2);
    },
    sinusoidalIn: function(n) {
      return 1 - Math.cos(n * Math.PI / 2);
    },
    sinusoidalOut: function(n) {
      return Math.sin(n * Math.PI / 2);
    },
    sinusoidalInOut: function(n) {
      return 0.5 * (1 - Math.cos(Math.PI * n));
    },
    exponentialIn: function(n) {
      return n === 0 ? 0 : Math.pow(1024, n - 1);
    },
    exponentialOut: function(n) {
      return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);
    },
    exponentialInOut: function(n) {
      return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? 0.5 * Math.pow(1024, n - 1) : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);
    },
    circularIn: function(n) {
      return 1 - Math.sqrt(1 - n * n);
    },
    circularOut: function(n) {
      return Math.sqrt(1 - --n * n);
    },
    circularInOut: function(n) {
      return (n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
    },
    elasticIn: function(n) {
      var e, t = 0.1, r = 0.4;
      return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r)));
    },
    elasticOut: function(n) {
      var e, t = 0.1, r = 0.4;
      return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * n) * Math.sin((n - e) * (2 * Math.PI) / r) + 1);
    },
    elasticInOut: function(n) {
      var e, t = 0.1, r = 0.4;
      return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), (n *= 2) < 1 ? -0.5 * (t * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r)) : t * Math.pow(2, -10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r) * 0.5 + 1);
    },
    backIn: function(n) {
      var e = 1.70158;
      return n * n * ((e + 1) * n - e);
    },
    backOut: function(n) {
      var e = 1.70158;
      return --n * n * ((e + 1) * n + e) + 1;
    },
    backInOut: function(n) {
      var e = 2.5949095;
      return (n *= 2) < 1 ? 0.5 * (n * n * ((e + 1) * n - e)) : 0.5 * ((n -= 2) * n * ((e + 1) * n + e) + 2);
    },
    bounceIn: function(n) {
      return 1 - e0.bounceOut(1 - n);
    },
    bounceOut: function(n) {
      return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
    },
    bounceInOut: function(n) {
      return n < 0.5 ? e0.bounceIn(n * 2) * 0.5 : e0.bounceOut(n * 2 - 1) * 0.5 + 0.5;
    }
  }, p1 = Math.pow, Hu = Math.sqrt, D6 = 1e-8, R6 = 1e-4, J3 = Hu(3), g1 = 1 / 3, Lo = Ed(), hs = Ed(), wg = Ed();
  function Pu(n) {
    return n > -1e-8 && n < D6;
  }
  function $6(n) {
    return n > D6 || n < -1e-8;
  }
  function Fr(n, e, t, r, i) {
    var a = 1 - i;
    return a * a * (a * n + 3 * i * e) + i * i * (i * r + 3 * a * t);
  }
  function eF(n, e, t, r, i) {
    var a = 1 - i;
    return 3 * (((e - n) * a + 2 * (t - e) * i) * a + (r - t) * i * i);
  }
  function N_(n, e, t, r, i, a) {
    var s = r + 3 * (e - t) - n, o = 3 * (t - e * 2 + n), l = 3 * (e - n), u = n - i, c = o * o - 3 * s * l, h = o * l - 9 * s * u, d = l * l - 3 * o * u, f = 0;
    if (Pu(c) && Pu(h)) if (Pu(o)) a[0] = 0;
    else {
      var p = -l / o;
      p >= 0 && p <= 1 && (a[f++] = p);
    }
    else {
      var g = h * h - 4 * c * d;
      if (Pu(g)) {
        var m = h / c, p = -o / s + m, v = -m / 2;
        p >= 0 && p <= 1 && (a[f++] = p), v >= 0 && v <= 1 && (a[f++] = v);
      } else if (g > 0) {
        var y = Hu(g), x = c * o + 1.5 * s * (-h + y), b = c * o + 1.5 * s * (-h - y);
        x < 0 ? x = -p1(-x, g1) : x = p1(x, g1), b < 0 ? b = -p1(-b, g1) : b = p1(b, g1);
        var p = (-o - (x + b)) / (3 * s);
        p >= 0 && p <= 1 && (a[f++] = p);
      } else {
        var w = (2 * c * o - 3 * s * h) / (2 * Hu(c * c * c)), _ = Math.acos(w) / 3, S = Hu(c), I = Math.cos(_), p = (-o - 2 * S * I) / (3 * s), v = (-o + S * (I + J3 * Math.sin(_))) / (3 * s), C = (-o + S * (I - J3 * Math.sin(_))) / (3 * s);
        p >= 0 && p <= 1 && (a[f++] = p), v >= 0 && v <= 1 && (a[f++] = v), C >= 0 && C <= 1 && (a[f++] = C);
      }
    }
    return f;
  }
  function N6(n, e, t, r, i) {
    var a = 6 * t - 12 * e + 6 * n, s = 9 * e + 3 * r - 3 * n - 9 * t, o = 3 * e - 3 * n, l = 0;
    if (Pu(s)) {
      if ($6(a)) {
        var u = -o / a;
        u >= 0 && u <= 1 && (i[l++] = u);
      }
    } else {
      var c = a * a - 4 * s * o;
      if (Pu(c)) i[0] = -a / (2 * s);
      else if (c > 0) {
        var h = Hu(c), u = (-a + h) / (2 * s), d = (-a - h) / (2 * s);
        u >= 0 && u <= 1 && (i[l++] = u), d >= 0 && d <= 1 && (i[l++] = d);
      }
    }
    return l;
  }
  function tc(n, e, t, r, i, a) {
    var s = (e - n) * i + n, o = (t - e) * i + e, l = (r - t) * i + t, u = (o - s) * i + s, c = (l - o) * i + o, h = (c - u) * i + u;
    a[0] = n, a[1] = s, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = r;
  }
  function E6(n, e, t, r, i, a, s, o, l, u, c) {
    var h, d = 5e-3, f = 1 / 0, p, g, m, v;
    Lo[0] = l, Lo[1] = u;
    for (var y = 0; y < 1; y += 0.05) hs[0] = Fr(n, t, i, s, y), hs[1] = Fr(e, r, a, o, y), m = qh(Lo, hs), m < f && (h = y, f = m);
    f = 1 / 0;
    for (var x = 0; x < 32 && !(d < R6); x++) p = h - d, g = h + d, hs[0] = Fr(n, t, i, s, p), hs[1] = Fr(e, r, a, o, p), m = qh(hs, Lo), p >= 0 && m < f ? (h = p, f = m) : (wg[0] = Fr(n, t, i, s, g), wg[1] = Fr(e, r, a, o, g), v = qh(wg, Lo), g <= 1 && v < f ? (h = g, f = v) : d *= 0.5);
    return c && (c[0] = Fr(n, t, i, s, h), c[1] = Fr(e, r, a, o, h)), Hu(f);
  }
  function xoe(n, e, t, r, i, a, s, o, l) {
    for (var u = n, c = e, h = 0, d = 1 / l, f = 1; f <= l; f++) {
      var p = f * d, g = Fr(n, t, i, s, p), m = Fr(e, r, a, o, p), v = g - u, y = m - c;
      h += Math.sqrt(v * v + y * y), u = g, c = m;
    }
    return h;
  }
  function Jr(n, e, t, r) {
    var i = 1 - r;
    return i * (i * n + 2 * r * e) + r * r * t;
  }
  function wD(n, e, t, r) {
    return 2 * ((1 - r) * (e - n) + r * (t - e));
  }
  function boe(n, e, t, r, i) {
    var a = n - 2 * e + t, s = 2 * (e - n), o = n - r, l = 0;
    if (Pu(a)) {
      if ($6(s)) {
        var u = -o / s;
        u >= 0 && u <= 1 && (i[l++] = u);
      }
    } else {
      var c = s * s - 4 * a * o;
      if (Pu(c)) {
        var u = -s / (2 * a);
        u >= 0 && u <= 1 && (i[l++] = u);
      } else if (c > 0) {
        var h = Hu(c), u = (-s + h) / (2 * a), d = (-s - h) / (2 * a);
        u >= 0 && u <= 1 && (i[l++] = u), d >= 0 && d <= 1 && (i[l++] = d);
      }
    }
    return l;
  }
  function M6(n, e, t) {
    var r = n + t - 2 * e;
    return r === 0 ? 0.5 : (n - e) / r;
  }
  function k0(n, e, t, r, i) {
    var a = (e - n) * r + n, s = (t - e) * r + e, o = (s - a) * r + a;
    i[0] = n, i[1] = a, i[2] = o, i[3] = o, i[4] = s, i[5] = t;
  }
  function P6(n, e, t, r, i, a, s, o, l) {
    var u, c = 5e-3, h = 1 / 0;
    Lo[0] = s, Lo[1] = o;
    for (var d = 0; d < 1; d += 0.05) {
      hs[0] = Jr(n, t, i, d), hs[1] = Jr(e, r, a, d);
      var f = qh(Lo, hs);
      f < h && (u = d, h = f);
    }
    h = 1 / 0;
    for (var p = 0; p < 32 && !(c < R6); p++) {
      var g = u - c, m = u + c;
      hs[0] = Jr(n, t, i, g), hs[1] = Jr(e, r, a, g);
      var f = qh(hs, Lo);
      if (g >= 0 && f < h) u = g, h = f;
      else {
        wg[0] = Jr(n, t, i, m), wg[1] = Jr(e, r, a, m);
        var v = qh(wg, Lo);
        m <= 1 && v < h ? (u = m, h = v) : c *= 0.5;
      }
    }
    return l && (l[0] = Jr(n, t, i, u), l[1] = Jr(e, r, a, u)), Hu(h);
  }
  function woe(n, e, t, r, i, a, s) {
    for (var o = n, l = e, u = 0, c = 1 / s, h = 1; h <= s; h++) {
      var d = h * c, f = Jr(n, t, i, d), p = Jr(e, r, a, d), g = f - o, m = p - l;
      u += Math.sqrt(g * g + m * m), o = f, l = p;
    }
    return u;
  }
  var _oe = /cubic-bezier\(([0-9,\.e ]+)\)/;
  function ON(n) {
    var e = n && _oe.exec(n);
    if (e) {
      var t = e[1].split(","), r = +Hs(t[0]), i = +Hs(t[1]), a = +Hs(t[2]), s = +Hs(t[3]);
      if (isNaN(r + i + a + s)) return;
      var o = [];
      return function(l) {
        return l <= 0 ? 0 : l >= 1 ? 1 : N_(0, r, a, 1, l, o) && Fr(0, i, s, 1, o[0]);
      };
    }
  }
  var Soe = function() {
    function n(e) {
      this._inited = false, this._startTime = 0, this._pausedTime = 0, this._paused = false, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || false, this.onframe = e.onframe || ur, this.ondestroy = e.ondestroy || ur, this.onrestart = e.onrestart || ur, e.easing && this.setEasing(e.easing);
    }
    return n.prototype.step = function(e, t) {
      if (this._inited || (this._startTime = e + this._delay, this._inited = true), this._paused) {
        this._pausedTime += t;
        return;
      }
      var r = this._life, i = e - this._startTime - this._pausedTime, a = i / r;
      a < 0 && (a = 0), a = Math.min(a, 1);
      var s = this.easingFunc, o = s ? s(a) : a;
      if (this.onframe(o), a === 1) if (this.loop) {
        var l = i % r;
        this._startTime = e - l, this._pausedTime = 0, this.onrestart();
      } else return true;
      return false;
    }, n.prototype.pause = function() {
      this._paused = true;
    }, n.prototype.resume = function() {
      this._paused = false;
    }, n.prototype.setEasing = function(e) {
      this.easing = e, this.easingFunc = Xe(e) ? e : e0[e] || ON(e);
    }, n;
  }(), L6 = /* @__PURE__ */ function() {
    function n(e) {
      this.value = e;
    }
    return n;
  }(), Coe = function() {
    function n() {
      this._len = 0;
    }
    return n.prototype.insert = function(e) {
      var t = new L6(e);
      return this.insertEntry(t), t;
    }, n.prototype.insertEntry = function(e) {
      this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
    }, n.prototype.remove = function(e) {
      var t = e.prev, r = e.next;
      t ? t.next = r : this.head = r, r ? r.prev = t : this.tail = t, e.next = e.prev = null, this._len--;
    }, n.prototype.len = function() {
      return this._len;
    }, n.prototype.clear = function() {
      this.head = this.tail = null, this._len = 0;
    }, n;
  }(), Dx = function() {
    function n(e) {
      this._list = new Coe(), this._maxSize = 10, this._map = {}, this._maxSize = e;
    }
    return n.prototype.put = function(e, t) {
      var r = this._list, i = this._map, a = null;
      if (i[e] == null) {
        var s = r.len(), o = this._lastRemovedEntry;
        if (s >= this._maxSize && s > 0) {
          var l = r.head;
          r.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l;
        }
        o ? o.value = t : o = new L6(t), o.key = e, r.insertEntry(o), i[e] = o;
      }
      return a;
    }, n.prototype.get = function(e) {
      var t = this._map[e], r = this._list;
      if (t != null) return t !== r.tail && (r.remove(t), r.insertEntry(t)), t.value;
    }, n.prototype.clear = function() {
      this._list.clear(), this._map = {};
    }, n.prototype.len = function() {
      return this._list.len();
    }, n;
  }(), tF = {
    transparent: [
      0,
      0,
      0,
      0
    ],
    aliceblue: [
      240,
      248,
      255,
      1
    ],
    antiquewhite: [
      250,
      235,
      215,
      1
    ],
    aqua: [
      0,
      255,
      255,
      1
    ],
    aquamarine: [
      127,
      255,
      212,
      1
    ],
    azure: [
      240,
      255,
      255,
      1
    ],
    beige: [
      245,
      245,
      220,
      1
    ],
    bisque: [
      255,
      228,
      196,
      1
    ],
    black: [
      0,
      0,
      0,
      1
    ],
    blanchedalmond: [
      255,
      235,
      205,
      1
    ],
    blue: [
      0,
      0,
      255,
      1
    ],
    blueviolet: [
      138,
      43,
      226,
      1
    ],
    brown: [
      165,
      42,
      42,
      1
    ],
    burlywood: [
      222,
      184,
      135,
      1
    ],
    cadetblue: [
      95,
      158,
      160,
      1
    ],
    chartreuse: [
      127,
      255,
      0,
      1
    ],
    chocolate: [
      210,
      105,
      30,
      1
    ],
    coral: [
      255,
      127,
      80,
      1
    ],
    cornflowerblue: [
      100,
      149,
      237,
      1
    ],
    cornsilk: [
      255,
      248,
      220,
      1
    ],
    crimson: [
      220,
      20,
      60,
      1
    ],
    cyan: [
      0,
      255,
      255,
      1
    ],
    darkblue: [
      0,
      0,
      139,
      1
    ],
    darkcyan: [
      0,
      139,
      139,
      1
    ],
    darkgoldenrod: [
      184,
      134,
      11,
      1
    ],
    darkgray: [
      169,
      169,
      169,
      1
    ],
    darkgreen: [
      0,
      100,
      0,
      1
    ],
    darkgrey: [
      169,
      169,
      169,
      1
    ],
    darkkhaki: [
      189,
      183,
      107,
      1
    ],
    darkmagenta: [
      139,
      0,
      139,
      1
    ],
    darkolivegreen: [
      85,
      107,
      47,
      1
    ],
    darkorange: [
      255,
      140,
      0,
      1
    ],
    darkorchid: [
      153,
      50,
      204,
      1
    ],
    darkred: [
      139,
      0,
      0,
      1
    ],
    darksalmon: [
      233,
      150,
      122,
      1
    ],
    darkseagreen: [
      143,
      188,
      143,
      1
    ],
    darkslateblue: [
      72,
      61,
      139,
      1
    ],
    darkslategray: [
      47,
      79,
      79,
      1
    ],
    darkslategrey: [
      47,
      79,
      79,
      1
    ],
    darkturquoise: [
      0,
      206,
      209,
      1
    ],
    darkviolet: [
      148,
      0,
      211,
      1
    ],
    deeppink: [
      255,
      20,
      147,
      1
    ],
    deepskyblue: [
      0,
      191,
      255,
      1
    ],
    dimgray: [
      105,
      105,
      105,
      1
    ],
    dimgrey: [
      105,
      105,
      105,
      1
    ],
    dodgerblue: [
      30,
      144,
      255,
      1
    ],
    firebrick: [
      178,
      34,
      34,
      1
    ],
    floralwhite: [
      255,
      250,
      240,
      1
    ],
    forestgreen: [
      34,
      139,
      34,
      1
    ],
    fuchsia: [
      255,
      0,
      255,
      1
    ],
    gainsboro: [
      220,
      220,
      220,
      1
    ],
    ghostwhite: [
      248,
      248,
      255,
      1
    ],
    gold: [
      255,
      215,
      0,
      1
    ],
    goldenrod: [
      218,
      165,
      32,
      1
    ],
    gray: [
      128,
      128,
      128,
      1
    ],
    green: [
      0,
      128,
      0,
      1
    ],
    greenyellow: [
      173,
      255,
      47,
      1
    ],
    grey: [
      128,
      128,
      128,
      1
    ],
    honeydew: [
      240,
      255,
      240,
      1
    ],
    hotpink: [
      255,
      105,
      180,
      1
    ],
    indianred: [
      205,
      92,
      92,
      1
    ],
    indigo: [
      75,
      0,
      130,
      1
    ],
    ivory: [
      255,
      255,
      240,
      1
    ],
    khaki: [
      240,
      230,
      140,
      1
    ],
    lavender: [
      230,
      230,
      250,
      1
    ],
    lavenderblush: [
      255,
      240,
      245,
      1
    ],
    lawngreen: [
      124,
      252,
      0,
      1
    ],
    lemonchiffon: [
      255,
      250,
      205,
      1
    ],
    lightblue: [
      173,
      216,
      230,
      1
    ],
    lightcoral: [
      240,
      128,
      128,
      1
    ],
    lightcyan: [
      224,
      255,
      255,
      1
    ],
    lightgoldenrodyellow: [
      250,
      250,
      210,
      1
    ],
    lightgray: [
      211,
      211,
      211,
      1
    ],
    lightgreen: [
      144,
      238,
      144,
      1
    ],
    lightgrey: [
      211,
      211,
      211,
      1
    ],
    lightpink: [
      255,
      182,
      193,
      1
    ],
    lightsalmon: [
      255,
      160,
      122,
      1
    ],
    lightseagreen: [
      32,
      178,
      170,
      1
    ],
    lightskyblue: [
      135,
      206,
      250,
      1
    ],
    lightslategray: [
      119,
      136,
      153,
      1
    ],
    lightslategrey: [
      119,
      136,
      153,
      1
    ],
    lightsteelblue: [
      176,
      196,
      222,
      1
    ],
    lightyellow: [
      255,
      255,
      224,
      1
    ],
    lime: [
      0,
      255,
      0,
      1
    ],
    limegreen: [
      50,
      205,
      50,
      1
    ],
    linen: [
      250,
      240,
      230,
      1
    ],
    magenta: [
      255,
      0,
      255,
      1
    ],
    maroon: [
      128,
      0,
      0,
      1
    ],
    mediumaquamarine: [
      102,
      205,
      170,
      1
    ],
    mediumblue: [
      0,
      0,
      205,
      1
    ],
    mediumorchid: [
      186,
      85,
      211,
      1
    ],
    mediumpurple: [
      147,
      112,
      219,
      1
    ],
    mediumseagreen: [
      60,
      179,
      113,
      1
    ],
    mediumslateblue: [
      123,
      104,
      238,
      1
    ],
    mediumspringgreen: [
      0,
      250,
      154,
      1
    ],
    mediumturquoise: [
      72,
      209,
      204,
      1
    ],
    mediumvioletred: [
      199,
      21,
      133,
      1
    ],
    midnightblue: [
      25,
      25,
      112,
      1
    ],
    mintcream: [
      245,
      255,
      250,
      1
    ],
    mistyrose: [
      255,
      228,
      225,
      1
    ],
    moccasin: [
      255,
      228,
      181,
      1
    ],
    navajowhite: [
      255,
      222,
      173,
      1
    ],
    navy: [
      0,
      0,
      128,
      1
    ],
    oldlace: [
      253,
      245,
      230,
      1
    ],
    olive: [
      128,
      128,
      0,
      1
    ],
    olivedrab: [
      107,
      142,
      35,
      1
    ],
    orange: [
      255,
      165,
      0,
      1
    ],
    orangered: [
      255,
      69,
      0,
      1
    ],
    orchid: [
      218,
      112,
      214,
      1
    ],
    palegoldenrod: [
      238,
      232,
      170,
      1
    ],
    palegreen: [
      152,
      251,
      152,
      1
    ],
    paleturquoise: [
      175,
      238,
      238,
      1
    ],
    palevioletred: [
      219,
      112,
      147,
      1
    ],
    papayawhip: [
      255,
      239,
      213,
      1
    ],
    peachpuff: [
      255,
      218,
      185,
      1
    ],
    peru: [
      205,
      133,
      63,
      1
    ],
    pink: [
      255,
      192,
      203,
      1
    ],
    plum: [
      221,
      160,
      221,
      1
    ],
    powderblue: [
      176,
      224,
      230,
      1
    ],
    purple: [
      128,
      0,
      128,
      1
    ],
    red: [
      255,
      0,
      0,
      1
    ],
    rosybrown: [
      188,
      143,
      143,
      1
    ],
    royalblue: [
      65,
      105,
      225,
      1
    ],
    saddlebrown: [
      139,
      69,
      19,
      1
    ],
    salmon: [
      250,
      128,
      114,
      1
    ],
    sandybrown: [
      244,
      164,
      96,
      1
    ],
    seagreen: [
      46,
      139,
      87,
      1
    ],
    seashell: [
      255,
      245,
      238,
      1
    ],
    sienna: [
      160,
      82,
      45,
      1
    ],
    silver: [
      192,
      192,
      192,
      1
    ],
    skyblue: [
      135,
      206,
      235,
      1
    ],
    slateblue: [
      106,
      90,
      205,
      1
    ],
    slategray: [
      112,
      128,
      144,
      1
    ],
    slategrey: [
      112,
      128,
      144,
      1
    ],
    snow: [
      255,
      250,
      250,
      1
    ],
    springgreen: [
      0,
      255,
      127,
      1
    ],
    steelblue: [
      70,
      130,
      180,
      1
    ],
    tan: [
      210,
      180,
      140,
      1
    ],
    teal: [
      0,
      128,
      128,
      1
    ],
    thistle: [
      216,
      191,
      216,
      1
    ],
    tomato: [
      255,
      99,
      71,
      1
    ],
    turquoise: [
      64,
      224,
      208,
      1
    ],
    violet: [
      238,
      130,
      238,
      1
    ],
    wheat: [
      245,
      222,
      179,
      1
    ],
    white: [
      255,
      255,
      255,
      1
    ],
    whitesmoke: [
      245,
      245,
      245,
      1
    ],
    yellow: [
      255,
      255,
      0,
      1
    ],
    yellowgreen: [
      154,
      205,
      50,
      1
    ]
  };
  function Ks(n) {
    return n = Math.round(n), n < 0 ? 0 : n > 255 ? 255 : n;
  }
  function Ioe(n) {
    return n = Math.round(n), n < 0 ? 0 : n > 360 ? 360 : n;
  }
  function T0(n) {
    return n < 0 ? 0 : n > 1 ? 1 : n;
  }
  function P2(n) {
    var e = n;
    return e.length && e.charAt(e.length - 1) === "%" ? Ks(parseFloat(e) / 100 * 255) : Ks(parseInt(e, 10));
  }
  function jh(n) {
    var e = n;
    return e.length && e.charAt(e.length - 1) === "%" ? T0(parseFloat(e) / 100) : T0(parseFloat(e));
  }
  function L2(n, e, t) {
    return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? n + (e - n) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? n + (e - n) * (2 / 3 - t) * 6 : n;
  }
  function Lu(n, e, t) {
    return n + (e - n) * t;
  }
  function as(n, e, t, r, i) {
    return n[0] = e, n[1] = t, n[2] = r, n[3] = i, n;
  }
  function _D(n, e) {
    return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n;
  }
  var F6 = new Dx(20), m1 = null;
  function Ip(n, e) {
    m1 && _D(m1, e), m1 = F6.put(n, m1 || e.slice());
  }
  function Va(n, e) {
    if (n) {
      e = e || [];
      var t = F6.get(n);
      if (t) return _D(e, t);
      n = n + "";
      var r = n.replace(/ /g, "").toLowerCase();
      if (r in tF) return _D(e, tF[r]), Ip(n, e), e;
      var i = r.length;
      if (r.charAt(0) === "#") {
        if (i === 4 || i === 5) {
          var a = parseInt(r.slice(1, 4), 16);
          if (!(a >= 0 && a <= 4095)) {
            as(e, 0, 0, 0, 1);
            return;
          }
          return as(e, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(r.slice(4), 16) / 15 : 1), Ip(n, e), e;
        } else if (i === 7 || i === 9) {
          var a = parseInt(r.slice(1, 7), 16);
          if (!(a >= 0 && a <= 16777215)) {
            as(e, 0, 0, 0, 1);
            return;
          }
          return as(e, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(r.slice(7), 16) / 255 : 1), Ip(n, e), e;
        }
        return;
      }
      var s = r.indexOf("("), o = r.indexOf(")");
      if (s !== -1 && o + 1 === i) {
        var l = r.substr(0, s), u = r.substr(s + 1, o - (s + 1)).split(","), c = 1;
        switch (l) {
          case "rgba":
            if (u.length !== 4) return u.length === 3 ? as(e, +u[0], +u[1], +u[2], 1) : as(e, 0, 0, 0, 1);
            c = jh(u.pop());
          case "rgb":
            if (u.length >= 3) return as(e, P2(u[0]), P2(u[1]), P2(u[2]), u.length === 3 ? c : jh(u[3])), Ip(n, e), e;
            as(e, 0, 0, 0, 1);
            return;
          case "hsla":
            if (u.length !== 4) {
              as(e, 0, 0, 0, 1);
              return;
            }
            return u[3] = jh(u[3]), SD(u, e), Ip(n, e), e;
          case "hsl":
            if (u.length !== 3) {
              as(e, 0, 0, 0, 1);
              return;
            }
            return SD(u, e), Ip(n, e), e;
          default:
            return;
        }
      }
      as(e, 0, 0, 0, 1);
    }
  }
  function SD(n, e) {
    var t = (parseFloat(n[0]) % 360 + 360) % 360 / 360, r = jh(n[1]), i = jh(n[2]), a = i <= 0.5 ? i * (r + 1) : i + r - i * r, s = i * 2 - a;
    return e = e || [], as(e, Ks(L2(s, a, t + 1 / 3) * 255), Ks(L2(s, a, t) * 255), Ks(L2(s, a, t - 1 / 3) * 255), 1), n.length === 4 && (e[3] = n[3]), e;
  }
  function koe(n) {
    if (n) {
      var e = n[0] / 255, t = n[1] / 255, r = n[2] / 255, i = Math.min(e, t, r), a = Math.max(e, t, r), s = a - i, o = (a + i) / 2, l, u;
      if (s === 0) l = 0, u = 0;
      else {
        o < 0.5 ? u = s / (a + i) : u = s / (2 - a - i);
        var c = ((a - e) / 6 + s / 2) / s, h = ((a - t) / 6 + s / 2) / s, d = ((a - r) / 6 + s / 2) / s;
        e === a ? l = d - h : t === a ? l = 1 / 3 + c - d : r === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
      }
      var f = [
        l * 360,
        u,
        o
      ];
      return n[3] != null && f.push(n[3]), f;
    }
  }
  function CD(n, e) {
    var t = Va(n);
    if (t) {
      for (var r = 0; r < 3; r++) e < 0 ? t[r] = t[r] * (1 - e) | 0 : t[r] = (255 - t[r]) * e + t[r] | 0, t[r] > 255 ? t[r] = 255 : t[r] < 0 && (t[r] = 0);
      return Pl(t, t.length === 4 ? "rgba" : "rgb");
    }
  }
  function F2(n, e, t) {
    if (!(!(e && e.length) || !(n >= 0 && n <= 1))) {
      t = t || [];
      var r = n * (e.length - 1), i = Math.floor(r), a = Math.ceil(r), s = e[i], o = e[a], l = r - i;
      return t[0] = Ks(Lu(s[0], o[0], l)), t[1] = Ks(Lu(s[1], o[1], l)), t[2] = Ks(Lu(s[2], o[2], l)), t[3] = T0(Lu(s[3], o[3], l)), t;
    }
  }
  function Toe(n, e, t) {
    if (!(!(e && e.length) || !(n >= 0 && n <= 1))) {
      var r = n * (e.length - 1), i = Math.floor(r), a = Math.ceil(r), s = Va(e[i]), o = Va(e[a]), l = r - i, u = Pl([
        Ks(Lu(s[0], o[0], l)),
        Ks(Lu(s[1], o[1], l)),
        Ks(Lu(s[2], o[2], l)),
        T0(Lu(s[3], o[3], l))
      ], "rgba");
      return t ? {
        color: u,
        leftIndex: i,
        rightIndex: a,
        value: r
      } : u;
    }
  }
  function t0(n, e, t, r) {
    var i = Va(n);
    if (n) return i = koe(i), e != null && (i[0] = Ioe(e)), t != null && (i[1] = jh(t)), r != null && (i[2] = jh(r)), Pl(SD(i), "rgba");
  }
  function E_(n, e) {
    var t = Va(n);
    if (t && e != null) return t[3] = T0(e), Pl(t, "rgba");
  }
  function Pl(n, e) {
    if (!(!n || !n.length)) {
      var t = n[0] + "," + n[1] + "," + n[2];
      return (e === "rgba" || e === "hsva" || e === "hsla") && (t += "," + n[3]), e + "(" + t + ")";
    }
  }
  function M_(n, e) {
    var t = Va(n);
    return t ? (0.299 * t[0] + 0.587 * t[1] + 0.114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0;
  }
  var nF = new Dx(100);
  function ID(n) {
    if (Ie(n)) {
      var e = nF.get(n);
      return e || (e = CD(n, -0.1), nF.put(n, e)), e;
    } else if (cC(n)) {
      var t = oe({}, n);
      return t.colorStops = me(n.colorStops, function(r) {
        return {
          offset: r.offset,
          color: CD(r.color, -0.1)
        };
      }), t;
    }
    return n;
  }
  var P_ = Math.round;
  function A0(n) {
    var e;
    if (!n || n === "transparent") n = "none";
    else if (typeof n == "string" && n.indexOf("rgba") > -1) {
      var t = Va(n);
      t && (n = "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")", e = t[3]);
    }
    return {
      color: n,
      opacity: e ?? 1
    };
  }
  var Aoe = 1e-4;
  function Fu(n) {
    return n < Aoe && n > -1e-4;
  }
  function v1(n) {
    return P_(n * 1e3) / 1e3;
  }
  function kD(n) {
    return P_(n * 1e4) / 1e4;
  }
  function Doe(n) {
    return "matrix(" + v1(n[0]) + "," + v1(n[1]) + "," + v1(n[2]) + "," + v1(n[3]) + "," + kD(n[4]) + "," + kD(n[5]) + ")";
  }
  var Roe = {
    left: "start",
    right: "end",
    center: "middle",
    middle: "middle"
  };
  function $oe(n, e, t) {
    return t === "top" ? n += e / 2 : t === "bottom" && (n -= e / 2), n;
  }
  function Noe(n) {
    return n && (n.shadowBlur || n.shadowOffsetX || n.shadowOffsetY);
  }
  function Eoe(n) {
    var e = n.style, t = n.getGlobalScale();
    return [
      e.shadowColor,
      (e.shadowBlur || 0).toFixed(2),
      (e.shadowOffsetX || 0).toFixed(2),
      (e.shadowOffsetY || 0).toFixed(2),
      t[0],
      t[1]
    ].join(",");
  }
  function O6(n) {
    return n && !!n.image;
  }
  function Moe(n) {
    return n && !!n.svgElement;
  }
  function BN(n) {
    return O6(n) || Moe(n);
  }
  function B6(n) {
    return n.type === "linear";
  }
  function z6(n) {
    return n.type === "radial";
  }
  function V6(n) {
    return n && (n.type === "linear" || n.type === "radial");
  }
  function fC(n) {
    return "url(#" + n + ")";
  }
  function W6(n) {
    var e = n.getGlobalScale(), t = Math.max(e[0], e[1]);
    return Math.max(Math.ceil(Math.log(t) / Math.log(10)), 1);
  }
  function G6(n) {
    var e = n.x || 0, t = n.y || 0, r = (n.rotation || 0) * Yw, i = it(n.scaleX, 1), a = it(n.scaleY, 1), s = n.skewX || 0, o = n.skewY || 0, l = [];
    return (e || t) && l.push("translate(" + e + "px," + t + "px)"), r && l.push("rotate(" + r + ")"), (i !== 1 || a !== 1) && l.push("scale(" + i + "," + a + ")"), (s || o) && l.push("skew(" + P_(s * Yw) + "deg, " + P_(o * Yw) + "deg)"), l.join(" ");
  }
  var Poe = function() {
    return Dt.hasGlobalWindow && Xe(window.btoa) ? function(n) {
      return window.btoa(unescape(encodeURIComponent(n)));
    } : typeof Buffer < "u" ? function(n) {
      return Buffer.from(n).toString("base64");
    } : function(n) {
      return null;
    };
  }(), TD = Array.prototype.slice;
  function Sl(n, e, t) {
    return (e - n) * t + n;
  }
  function O2(n, e, t, r) {
    for (var i = e.length, a = 0; a < i; a++) n[a] = Sl(e[a], t[a], r);
    return n;
  }
  function Loe(n, e, t, r) {
    for (var i = e.length, a = i && e[0].length, s = 0; s < i; s++) {
      n[s] || (n[s] = []);
      for (var o = 0; o < a; o++) n[s][o] = Sl(e[s][o], t[s][o], r);
    }
    return n;
  }
  function y1(n, e, t, r) {
    for (var i = e.length, a = 0; a < i; a++) n[a] = e[a] + t[a] * r;
    return n;
  }
  function rF(n, e, t, r) {
    for (var i = e.length, a = i && e[0].length, s = 0; s < i; s++) {
      n[s] || (n[s] = []);
      for (var o = 0; o < a; o++) n[s][o] = e[s][o] + t[s][o] * r;
    }
    return n;
  }
  function Foe(n, e) {
    for (var t = n.length, r = e.length, i = t > r ? e : n, a = Math.min(t, r), s = i[a - 1] || {
      color: [
        0,
        0,
        0,
        0
      ],
      offset: 0
    }, o = a; o < Math.max(t, r); o++) i.push({
      offset: s.offset,
      color: s.color.slice()
    });
  }
  function Ooe(n, e, t) {
    var r = n, i = e;
    if (!(!r.push || !i.push)) {
      var a = r.length, s = i.length;
      if (a !== s) {
        var o = a > s;
        if (o) r.length = s;
        else for (var l = a; l < s; l++) r.push(t === 1 ? i[l] : TD.call(i[l]));
      }
      for (var u = r[0] && r[0].length, l = 0; l < r.length; l++) if (t === 1) isNaN(r[l]) && (r[l] = i[l]);
      else for (var c = 0; c < u; c++) isNaN(r[l][c]) && (r[l][c] = i[l][c]);
    }
  }
  function n0(n) {
    if (Mi(n)) {
      var e = n.length;
      if (Mi(n[0])) {
        for (var t = [], r = 0; r < e; r++) t.push(TD.call(n[r]));
        return t;
      }
      return TD.call(n);
    }
    return n;
  }
  function Qw(n) {
    return n[0] = Math.floor(n[0]) || 0, n[1] = Math.floor(n[1]) || 0, n[2] = Math.floor(n[2]) || 0, n[3] = n[3] == null ? 1 : n[3], "rgba(" + n.join(",") + ")";
  }
  function Boe(n) {
    return Mi(n && n[0]) ? 2 : 1;
  }
  var x1 = 0, Jw = 1, U6 = 2, Ry = 3, AD = 4, DD = 5, iF = 6;
  function aF(n) {
    return n === AD || n === DD;
  }
  function b1(n) {
    return n === Jw || n === U6;
  }
  var qv = [
    0,
    0,
    0,
    0
  ], zoe = function() {
    function n(e) {
      this.keyframes = [], this.discrete = false, this._invalid = false, this._needsSort = false, this._lastFr = 0, this._lastFrP = 0, this.propName = e;
    }
    return n.prototype.isFinished = function() {
      return this._finished;
    }, n.prototype.setFinished = function() {
      this._finished = true, this._additiveTrack && this._additiveTrack.setFinished();
    }, n.prototype.needsAnimate = function() {
      return this.keyframes.length >= 1;
    }, n.prototype.getAdditiveTrack = function() {
      return this._additiveTrack;
    }, n.prototype.addKeyframe = function(e, t, r) {
      this._needsSort = true;
      var i = this.keyframes, a = i.length, s = false, o = iF, l = t;
      if (Mi(t)) {
        var u = Boe(t);
        o = u, (u === 1 && !Yt(t[0]) || u === 2 && !Yt(t[0][0])) && (s = true);
      } else if (Yt(t) && !C0(t)) o = x1;
      else if (Ie(t)) if (!isNaN(+t)) o = x1;
      else {
        var c = Va(t);
        c && (l = c, o = Ry);
      }
      else if (cC(t)) {
        var h = oe({}, l);
        h.colorStops = me(t.colorStops, function(f) {
          return {
            offset: f.offset,
            color: Va(f.color)
          };
        }), B6(t) ? o = AD : z6(t) && (o = DD), l = h;
      }
      a === 0 ? this.valType = o : (o !== this.valType || o === iF) && (s = true), this.discrete = this.discrete || s;
      var d = {
        time: e,
        value: l,
        rawValue: t,
        percent: 0
      };
      return r && (d.easing = r, d.easingFunc = Xe(r) ? r : e0[r] || ON(r)), i.push(d), d;
    }, n.prototype.prepare = function(e, t) {
      var r = this.keyframes;
      this._needsSort && r.sort(function(g, m) {
        return g.time - m.time;
      });
      for (var i = this.valType, a = r.length, s = r[a - 1], o = this.discrete, l = b1(i), u = aF(i), c = 0; c < a; c++) {
        var h = r[c], d = h.value, f = s.value;
        h.percent = h.time / e, o || (l && c !== a - 1 ? Ooe(d, f, i) : u && Foe(d.colorStops, f.colorStops));
      }
      if (!o && i !== DD && t && this.needsAnimate() && t.needsAnimate() && i === t.valType && !t._finished) {
        this._additiveTrack = t;
        for (var p = r[0].value, c = 0; c < a; c++) i === x1 ? r[c].additiveValue = r[c].value - p : i === Ry ? r[c].additiveValue = y1([], r[c].value, p, -1) : b1(i) && (r[c].additiveValue = i === Jw ? y1([], r[c].value, p, -1) : rF([], r[c].value, p, -1));
      }
    }, n.prototype.step = function(e, t) {
      if (!this._finished) {
        this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
        var r = this._additiveTrack != null, i = r ? "additiveValue" : "value", a = this.valType, s = this.keyframes, o = s.length, l = this.propName, u = a === Ry, c, h = this._lastFr, d = Math.min, f, p;
        if (o === 1) f = p = s[0];
        else {
          if (t < 0) c = 0;
          else if (t < this._lastFrP) {
            var g = d(h + 1, o - 1);
            for (c = g; c >= 0 && !(s[c].percent <= t); c--) ;
            c = d(c, o - 2);
          } else {
            for (c = h; c < o && !(s[c].percent > t); c++) ;
            c = d(c - 1, o - 2);
          }
          p = s[c + 1], f = s[c];
        }
        if (f && p) {
          this._lastFr = c, this._lastFrP = t;
          var m = p.percent - f.percent, v = m === 0 ? 1 : d((t - f.percent) / m, 1);
          p.easingFunc && (v = p.easingFunc(v));
          var y = r ? this._additiveValue : u ? qv : e[l];
          if ((b1(a) || u) && !y && (y = this._additiveValue = []), this.discrete) e[l] = v < 1 ? f.rawValue : p.rawValue;
          else if (b1(a)) a === Jw ? O2(y, f[i], p[i], v) : Loe(y, f[i], p[i], v);
          else if (aF(a)) {
            var x = f[i], b = p[i], w = a === AD;
            e[l] = {
              type: w ? "linear" : "radial",
              x: Sl(x.x, b.x, v),
              y: Sl(x.y, b.y, v),
              colorStops: me(x.colorStops, function(S, I) {
                var C = b.colorStops[I];
                return {
                  offset: Sl(S.offset, C.offset, v),
                  color: Qw(O2([], S.color, C.color, v))
                };
              }),
              global: b.global
            }, w ? (e[l].x2 = Sl(x.x2, b.x2, v), e[l].y2 = Sl(x.y2, b.y2, v)) : e[l].r = Sl(x.r, b.r, v);
          } else if (u) O2(y, f[i], p[i], v), r || (e[l] = Qw(y));
          else {
            var _ = Sl(f[i], p[i], v);
            r ? this._additiveValue = _ : e[l] = _;
          }
          r && this._addToTarget(e);
        }
      }
    }, n.prototype._addToTarget = function(e) {
      var t = this.valType, r = this.propName, i = this._additiveValue;
      t === x1 ? e[r] = e[r] + i : t === Ry ? (Va(e[r], qv), y1(qv, qv, i, 1), e[r] = Qw(qv)) : t === Jw ? y1(e[r], e[r], i, 1) : t === U6 && rF(e[r], e[r], i, 1);
    }, n;
  }(), zN = function() {
    function n(e, t, r, i) {
      if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = t, t && i) {
        $N("Can' use additive animation on looped animation.");
        return;
      }
      this._additiveAnimators = i, this._allowDiscrete = r;
    }
    return n.prototype.getMaxTime = function() {
      return this._maxTime;
    }, n.prototype.getDelay = function() {
      return this._delay;
    }, n.prototype.getLoop = function() {
      return this._loop;
    }, n.prototype.getTarget = function() {
      return this._target;
    }, n.prototype.changeTarget = function(e) {
      this._target = e;
    }, n.prototype.when = function(e, t, r) {
      return this.whenWithKeys(e, t, Mt(t), r);
    }, n.prototype.whenWithKeys = function(e, t, r, i) {
      for (var a = this._tracks, s = 0; s < r.length; s++) {
        var o = r[s], l = a[o];
        if (!l) {
          l = a[o] = new zoe(o);
          var u = void 0, c = this._getAdditiveTrack(o);
          if (c) {
            var h = c.keyframes, d = h[h.length - 1];
            u = d && d.value, c.valType === Ry && u && (u = Qw(u));
          } else u = this._target[o];
          if (u == null) continue;
          e > 0 && l.addKeyframe(0, n0(u), i), this._trackKeys.push(o);
        }
        l.addKeyframe(e, n0(t[o]), i);
      }
      return this._maxTime = Math.max(this._maxTime, e), this;
    }, n.prototype.pause = function() {
      this._clip.pause(), this._paused = true;
    }, n.prototype.resume = function() {
      this._clip.resume(), this._paused = false;
    }, n.prototype.isPaused = function() {
      return !!this._paused;
    }, n.prototype.duration = function(e) {
      return this._maxTime = e, this._force = true, this;
    }, n.prototype._doneCallback = function() {
      this._setTracksFinished(), this._clip = null;
      var e = this._doneCbs;
      if (e) for (var t = e.length, r = 0; r < t; r++) e[r].call(this);
    }, n.prototype._abortedCallback = function() {
      this._setTracksFinished();
      var e = this.animation, t = this._abortedCbs;
      if (e && e.removeClip(this._clip), this._clip = null, t) for (var r = 0; r < t.length; r++) t[r].call(this);
    }, n.prototype._setTracksFinished = function() {
      for (var e = this._tracks, t = this._trackKeys, r = 0; r < t.length; r++) e[t[r]].setFinished();
    }, n.prototype._getAdditiveTrack = function(e) {
      var t, r = this._additiveAnimators;
      if (r) for (var i = 0; i < r.length; i++) {
        var a = r[i].getTrack(e);
        a && (t = a);
      }
      return t;
    }, n.prototype.start = function(e) {
      if (!(this._started > 0)) {
        this._started = 1;
        for (var t = this, r = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
          var s = this._trackKeys[a], o = this._tracks[s], l = this._getAdditiveTrack(s), u = o.keyframes, c = u.length;
          if (o.prepare(i, l), o.needsAnimate()) if (!this._allowDiscrete && o.discrete) {
            var h = u[c - 1];
            h && (t._target[o.propName] = h.rawValue), o.setFinished();
          } else r.push(o);
        }
        if (r.length || this._force) {
          var d = new Soe({
            life: i,
            loop: this._loop,
            delay: this._delay || 0,
            onframe: function(f) {
              t._started = 2;
              var p = t._additiveAnimators;
              if (p) {
                for (var g = false, m = 0; m < p.length; m++) if (p[m]._clip) {
                  g = true;
                  break;
                }
                g || (t._additiveAnimators = null);
              }
              for (var m = 0; m < r.length; m++) r[m].step(t._target, f);
              var v = t._onframeCbs;
              if (v) for (var m = 0; m < v.length; m++) v[m](t._target, f);
            },
            ondestroy: function() {
              t._doneCallback();
            }
          });
          this._clip = d, this.animation && this.animation.addClip(d), e && d.setEasing(e);
        } else this._doneCallback();
        return this;
      }
    }, n.prototype.stop = function(e) {
      if (this._clip) {
        var t = this._clip;
        e && t.onframe(1), this._abortedCallback();
      }
    }, n.prototype.delay = function(e) {
      return this._delay = e, this;
    }, n.prototype.during = function(e) {
      return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this;
    }, n.prototype.done = function(e) {
      return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this;
    }, n.prototype.aborted = function(e) {
      return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this;
    }, n.prototype.getClip = function() {
      return this._clip;
    }, n.prototype.getTrack = function(e) {
      return this._tracks[e];
    }, n.prototype.getTracks = function() {
      var e = this;
      return me(this._trackKeys, function(t) {
        return e._tracks[t];
      });
    }, n.prototype.stopTracks = function(e, t) {
      if (!e.length || !this._clip) return true;
      for (var r = this._tracks, i = this._trackKeys, a = 0; a < e.length; a++) {
        var s = r[e[a]];
        s && !s.isFinished() && (t ? s.step(this._target, 1) : this._started === 1 && s.step(this._target, 0), s.setFinished());
      }
      for (var o = true, a = 0; a < i.length; a++) if (!r[i[a]].isFinished()) {
        o = false;
        break;
      }
      return o && this._abortedCallback(), o;
    }, n.prototype.saveTo = function(e, t, r) {
      if (e) {
        t = t || this._trackKeys;
        for (var i = 0; i < t.length; i++) {
          var a = t[i], s = this._tracks[a];
          if (!(!s || s.isFinished())) {
            var o = s.keyframes, l = o[r ? 0 : o.length - 1];
            l && (e[a] = n0(l.rawValue));
          }
        }
      }
    }, n.prototype.__changeFinalValue = function(e, t) {
      t = t || Mt(e);
      for (var r = 0; r < t.length; r++) {
        var i = t[r], a = this._tracks[i];
        if (a) {
          var s = a.keyframes;
          if (s.length > 1) {
            var o = s.pop();
            a.addKeyframe(o.time, e[i]), a.prepare(this._maxTime, a.getAdditiveTrack());
          }
        }
      }
    }, n;
  }();
  function gg() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  var Voe = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r._running = false, r._time = 0, r._pausedTime = 0, r._pauseStart = 0, r._paused = false, t = t || {}, r.stage = t.stage || {}, r;
    }
    return e.prototype.addClip = function(t) {
      t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this;
    }, e.prototype.addAnimator = function(t) {
      t.animation = this;
      var r = t.getClip();
      r && this.addClip(r);
    }, e.prototype.removeClip = function(t) {
      if (t.animation) {
        var r = t.prev, i = t.next;
        r ? r.next = i : this._head = i, i ? i.prev = r : this._tail = r, t.next = t.prev = t.animation = null;
      }
    }, e.prototype.removeAnimator = function(t) {
      var r = t.getClip();
      r && this.removeClip(r), t.animation = null;
    }, e.prototype.update = function(t) {
      for (var r = gg() - this._pausedTime, i = r - this._time, a = this._head; a; ) {
        var s = a.next, o = a.step(r, i);
        o && (a.ondestroy(), this.removeClip(a)), a = s;
      }
      this._time = r, t || (this.trigger("frame", i), this.stage.update && this.stage.update());
    }, e.prototype._startLoop = function() {
      var t = this;
      this._running = true;
      function r() {
        t._running && ($_(r), !t._paused && t.update());
      }
      $_(r);
    }, e.prototype.start = function() {
      this._running || (this._time = gg(), this._pausedTime = 0, this._startLoop());
    }, e.prototype.stop = function() {
      this._running = false;
    }, e.prototype.pause = function() {
      this._paused || (this._pauseStart = gg(), this._paused = true);
    }, e.prototype.resume = function() {
      this._paused && (this._pausedTime += gg() - this._pauseStart, this._paused = false);
    }, e.prototype.clear = function() {
      for (var t = this._head; t; ) {
        var r = t.next;
        t.prev = t.next = t.animation = null, t = r;
      }
      this._head = this._tail = null;
    }, e.prototype.isFinished = function() {
      return this._head == null;
    }, e.prototype.animate = function(t, r) {
      r = r || {}, this.start();
      var i = new zN(t, r.loop);
      return this.addAnimator(i), i;
    }, e;
  }(Is), Woe = 300, B2 = Dt.domSupported, z2 = function() {
    var n = [
      "click",
      "dblclick",
      "mousewheel",
      "wheel",
      "mouseout",
      "mouseup",
      "mousedown",
      "mousemove",
      "contextmenu"
    ], e = [
      "touchstart",
      "touchend",
      "touchmove"
    ], t = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    }, r = me(n, function(i) {
      var a = i.replace("mouse", "pointer");
      return t.hasOwnProperty(a) ? a : i;
    });
    return {
      mouse: n,
      touch: e,
      pointer: r
    };
  }(), sF = {
    mouse: [
      "mousemove",
      "mouseup"
    ],
    pointer: [
      "pointermove",
      "pointerup"
    ]
  }, oF = false;
  function RD(n) {
    var e = n.pointerType;
    return e === "pen" || e === "touch";
  }
  function Goe(n) {
    n.touching = true, n.touchTimer != null && (clearTimeout(n.touchTimer), n.touchTimer = null), n.touchTimer = setTimeout(function() {
      n.touching = false, n.touchTimer = null;
    }, 700);
  }
  function V2(n) {
    n && (n.zrByTouch = true);
  }
  function Uoe(n, e) {
    return ss(n.dom, new Hoe(n, e), true);
  }
  function H6(n, e) {
    for (var t = e, r = false; t && t.nodeType !== 9 && !(r = t.domBelongToZr || t !== e && t === n.painterRoot); ) t = t.parentNode;
    return r;
  }
  var Hoe = /* @__PURE__ */ function() {
    function n(e, t) {
      this.stopPropagation = ur, this.stopImmediatePropagation = ur, this.preventDefault = ur, this.type = t.type, this.target = this.currentTarget = e.dom, this.pointerType = t.pointerType, this.clientX = t.clientX, this.clientY = t.clientY;
    }
    return n;
  }(), Bs = {
    mousedown: function(n) {
      n = ss(this.dom, n), this.__mayPointerCapture = [
        n.zrX,
        n.zrY
      ], this.trigger("mousedown", n);
    },
    mousemove: function(n) {
      n = ss(this.dom, n);
      var e = this.__mayPointerCapture;
      e && (n.zrX !== e[0] || n.zrY !== e[1]) && this.__togglePointerCapture(true), this.trigger("mousemove", n);
    },
    mouseup: function(n) {
      n = ss(this.dom, n), this.__togglePointerCapture(false), this.trigger("mouseup", n);
    },
    mouseout: function(n) {
      n = ss(this.dom, n);
      var e = n.toElement || n.relatedTarget;
      H6(this, e) || (this.__pointerCapturing && (n.zrEventControl = "no_globalout"), this.trigger("mouseout", n));
    },
    wheel: function(n) {
      oF = true, n = ss(this.dom, n), this.trigger("mousewheel", n);
    },
    mousewheel: function(n) {
      oF || (n = ss(this.dom, n), this.trigger("mousewheel", n));
    },
    touchstart: function(n) {
      n = ss(this.dom, n), V2(n), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(n, "start"), Bs.mousemove.call(this, n), Bs.mousedown.call(this, n);
    },
    touchmove: function(n) {
      n = ss(this.dom, n), V2(n), this.handler.processGesture(n, "change"), Bs.mousemove.call(this, n);
    },
    touchend: function(n) {
      n = ss(this.dom, n), V2(n), this.handler.processGesture(n, "end"), Bs.mouseup.call(this, n), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < Woe && Bs.click.call(this, n);
    },
    pointerdown: function(n) {
      Bs.mousedown.call(this, n);
    },
    pointermove: function(n) {
      RD(n) || Bs.mousemove.call(this, n);
    },
    pointerup: function(n) {
      Bs.mouseup.call(this, n);
    },
    pointerout: function(n) {
      RD(n) || Bs.mouseout.call(this, n);
    }
  };
  P([
    "click",
    "dblclick",
    "contextmenu"
  ], function(n) {
    Bs[n] = function(e) {
      e = ss(this.dom, e), this.trigger(n, e);
    };
  });
  var $D = {
    pointermove: function(n) {
      RD(n) || $D.mousemove.call(this, n);
    },
    pointerup: function(n) {
      $D.mouseup.call(this, n);
    },
    mousemove: function(n) {
      this.trigger("mousemove", n);
    },
    mouseup: function(n) {
      var e = this.__pointerCapturing;
      this.__togglePointerCapture(false), this.trigger("mouseup", n), e && (n.zrEventControl = "only_globalout", this.trigger("mouseout", n));
    }
  };
  function Xoe(n, e) {
    var t = e.domHandlers;
    Dt.pointerEventsSupported ? P(z2.pointer, function(r) {
      e_(e, r, function(i) {
        t[r].call(n, i);
      });
    }) : (Dt.touchEventsSupported && P(z2.touch, function(r) {
      e_(e, r, function(i) {
        t[r].call(n, i), Goe(e);
      });
    }), P(z2.mouse, function(r) {
      e_(e, r, function(i) {
        i = PN(i), e.touching || t[r].call(n, i);
      });
    }));
  }
  function Yoe(n, e) {
    Dt.pointerEventsSupported ? P(sF.pointer, t) : Dt.touchEventsSupported || P(sF.mouse, t);
    function t(r) {
      function i(a) {
        a = PN(a), H6(n, a.target) || (a = Uoe(n, a), e.domHandlers[r].call(n, a));
      }
      e_(e, r, i, {
        capture: true
      });
    }
  }
  function e_(n, e, t, r) {
    n.mounted[e] = t, n.listenerOpts[e] = r, bD(n.domTarget, e, t, r);
  }
  function W2(n) {
    var e = n.mounted;
    for (var t in e) e.hasOwnProperty(t) && soe(n.domTarget, t, e[t], n.listenerOpts[t]);
    n.mounted = {};
  }
  var lF = /* @__PURE__ */ function() {
    function n(e, t) {
      this.mounted = {}, this.listenerOpts = {}, this.touching = false, this.domTarget = e, this.domHandlers = t;
    }
    return n;
  }(), qoe = function(n) {
    K(e, n);
    function e(t, r) {
      var i = n.call(this) || this;
      return i.__pointerCapturing = false, i.dom = t, i.painterRoot = r, i._localHandlerScope = new lF(t, Bs), B2 && (i._globalHandlerScope = new lF(document, $D)), Xoe(i, i._localHandlerScope), i;
    }
    return e.prototype.dispose = function() {
      W2(this._localHandlerScope), B2 && W2(this._globalHandlerScope);
    }, e.prototype.setCursor = function(t) {
      this.dom.style && (this.dom.style.cursor = t || "default");
    }, e.prototype.__togglePointerCapture = function(t) {
      if (this.__mayPointerCapture = null, B2 && +this.__pointerCapturing ^ +t) {
        this.__pointerCapturing = t;
        var r = this._globalHandlerScope;
        t ? Yoe(this, r) : W2(r);
      }
    }, e;
  }(Is), X6 = 1;
  Dt.hasGlobalWindow && (X6 = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
  var L_ = X6, ND = 0.4, ED = "#333", MD = "#ccc", joe = "#eee", uF = dC, Koe = 5e-5;
  function Gc(n) {
    return n > Koe || n < -5e-5;
  }
  var Uc = [], kp = [], G2 = za(), U2 = Math.abs, Tl = function() {
    function n() {
    }
    return n.prototype.getLocalTransform = function(e) {
      return n.getLocalTransform(this, e);
    }, n.prototype.setPosition = function(e) {
      this.x = e[0], this.y = e[1];
    }, n.prototype.setScale = function(e) {
      this.scaleX = e[0], this.scaleY = e[1];
    }, n.prototype.setSkew = function(e) {
      this.skewX = e[0], this.skewY = e[1];
    }, n.prototype.setOrigin = function(e) {
      this.originX = e[0], this.originY = e[1];
    }, n.prototype.needLocalTransform = function() {
      return Gc(this.rotation) || Gc(this.x) || Gc(this.y) || Gc(this.scaleX - 1) || Gc(this.scaleY - 1) || Gc(this.skewX) || Gc(this.skewY);
    }, n.prototype.updateTransform = function() {
      var e = this.parent && this.parent.transform, t = this.needLocalTransform(), r = this.transform;
      if (!(t || e)) {
        r && (uF(r), this.invTransform = null);
        return;
      }
      r = r || za(), t ? this.getLocalTransform(r) : uF(r), e && (t ? Ml(r, e, r) : LN(r, e)), this.transform = r, this._resolveGlobalScaleRatio(r);
    }, n.prototype._resolveGlobalScaleRatio = function(e) {
      var t = this.globalScaleRatio;
      if (t != null && t !== 1) {
        this.getGlobalScale(Uc);
        var r = Uc[0] < 0 ? -1 : 1, i = Uc[1] < 0 ? -1 : 1, a = ((Uc[0] - r) * t + r) / Uc[0] || 0, s = ((Uc[1] - i) * t + i) / Uc[1] || 0;
        e[0] *= a, e[1] *= a, e[2] *= s, e[3] *= s;
      }
      this.invTransform = this.invTransform || za(), fm(this.invTransform, e);
    }, n.prototype.getComputedTransform = function() {
      for (var e = this, t = []; e; ) t.push(e), e = e.parent;
      for (; e = t.pop(); ) e.updateTransform();
      return this.transform;
    }, n.prototype.setLocalTransform = function(e) {
      if (e) {
        var t = e[0] * e[0] + e[1] * e[1], r = e[2] * e[2] + e[3] * e[3], i = Math.atan2(e[1], e[0]), a = Math.PI / 2 + i - Math.atan2(e[3], e[2]);
        r = Math.sqrt(r) * Math.cos(a), t = Math.sqrt(t), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +e[4], this.y = +e[5], this.scaleX = t, this.scaleY = r, this.originX = 0, this.originY = 0;
      }
    }, n.prototype.decomposeTransform = function() {
      if (this.transform) {
        var e = this.parent, t = this.transform;
        e && e.transform && (e.invTransform = e.invTransform || za(), Ml(kp, e.invTransform, t), t = kp);
        var r = this.originX, i = this.originY;
        (r || i) && (G2[4] = r, G2[5] = i, Ml(kp, t, G2), kp[4] -= r, kp[5] -= i, t = kp), this.setLocalTransform(t);
      }
    }, n.prototype.getGlobalScale = function(e) {
      var t = this.transform;
      return e = e || [], t ? (e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1]), e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3]), t[0] < 0 && (e[0] = -e[0]), t[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e);
    }, n.prototype.transformCoordToLocal = function(e, t) {
      var r = [
        e,
        t
      ], i = this.invTransform;
      return i && di(r, r, i), r;
    }, n.prototype.transformCoordToGlobal = function(e, t) {
      var r = [
        e,
        t
      ], i = this.transform;
      return i && di(r, r, i), r;
    }, n.prototype.getLineScale = function() {
      var e = this.transform;
      return e && U2(e[0] - 1) > 1e-10 && U2(e[3] - 1) > 1e-10 ? Math.sqrt(U2(e[0] * e[3] - e[2] * e[1])) : 1;
    }, n.prototype.copyTransform = function(e) {
      Y6(this, e);
    }, n.getLocalTransform = function(e, t) {
      t = t || [];
      var r = e.originX || 0, i = e.originY || 0, a = e.scaleX, s = e.scaleY, o = e.anchorX, l = e.anchorY, u = e.rotation || 0, c = e.x, h = e.y, d = e.skewX ? Math.tan(e.skewX) : 0, f = e.skewY ? Math.tan(-e.skewY) : 0;
      if (r || i || o || l) {
        var p = r + o, g = i + l;
        t[4] = -p * a - d * g * s, t[5] = -g * s - f * p * a;
      } else t[4] = t[5] = 0;
      return t[0] = a, t[3] = s, t[1] = f * a, t[2] = d * s, u && Md(t, t, u), t[4] += r + c, t[5] += i + h, t;
    }, n.initDefaultProps = function() {
      var e = n.prototype;
      e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0;
    }(), n;
  }(), el = [
    "x",
    "y",
    "originX",
    "originY",
    "anchorX",
    "anchorY",
    "rotation",
    "scaleX",
    "scaleY",
    "skewX",
    "skewY"
  ];
  function Y6(n, e) {
    for (var t = 0; t < el.length; t++) {
      var r = el[t];
      n[r] = e[r];
    }
  }
  var cF = {};
  function Wa(n, e) {
    e = e || Ju;
    var t = cF[e];
    t || (t = cF[e] = new Dx(500));
    var r = t.get(n);
    return r == null && (r = ec.measureText(n, e).width, t.put(n, r)), r;
  }
  function hF(n, e, t, r) {
    var i = Wa(n, e), a = pC(e), s = $y(0, i, t), o = rg(0, a, r), l = new vt(s, o, i, a);
    return l;
  }
  function Rx(n, e, t, r) {
    var i = ((n || "") + "").split(`
`), a = i.length;
    if (a === 1) return hF(i[0], e, t, r);
    for (var s = new vt(0, 0, 0, 0), o = 0; o < i.length; o++) {
      var l = hF(i[o], e, t, r);
      o === 0 ? s.copy(l) : s.union(l);
    }
    return s;
  }
  function $y(n, e, t) {
    return t === "right" ? n -= e : t === "center" && (n -= e / 2), n;
  }
  function rg(n, e, t) {
    return t === "middle" ? n -= e / 2 : t === "bottom" && (n -= e), n;
  }
  function pC(n) {
    return Wa("\u56FD", n);
  }
  function no(n, e) {
    return typeof n == "string" ? n.lastIndexOf("%") >= 0 ? parseFloat(n) / 100 * e : parseFloat(n) : n;
  }
  function F_(n, e, t) {
    var r = e.position || "inside", i = e.distance != null ? e.distance : 5, a = t.height, s = t.width, o = a / 2, l = t.x, u = t.y, c = "left", h = "top";
    if (r instanceof Array) l += no(r[0], t.width), u += no(r[1], t.height), c = null, h = null;
    else switch (r) {
      case "left":
        l -= i, u += o, c = "right", h = "middle";
        break;
      case "right":
        l += i + s, u += o, h = "middle";
        break;
      case "top":
        l += s / 2, u -= i, c = "center", h = "bottom";
        break;
      case "bottom":
        l += s / 2, u += a + i, c = "center";
        break;
      case "inside":
        l += s / 2, u += o, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += i, u += o, h = "middle";
        break;
      case "insideRight":
        l += s - i, u += o, c = "right", h = "middle";
        break;
      case "insideTop":
        l += s / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += s / 2, u += a - i, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += s - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += a - i, h = "bottom";
        break;
      case "insideBottomRight":
        l += s - i, u += a - i, c = "right", h = "bottom";
        break;
    }
    return n = n || {}, n.x = l, n.y = u, n.align = c, n.verticalAlign = h, n;
  }
  var H2 = "__zr_normal__", X2 = el.concat([
    "ignore"
  ]), Zoe = Qo(el, function(n, e) {
    return n[e] = true, n;
  }, {
    ignore: false
  }), Tp = {}, Qoe = new vt(0, 0, 0, 0), gC = function() {
    function n(e) {
      this.id = b6(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e);
    }
    return n.prototype._init = function(e) {
      this.attr(e);
    }, n.prototype.drift = function(e, t, r) {
      switch (this.draggable) {
        case "horizontal":
          t = 0;
          break;
        case "vertical":
          e = 0;
          break;
      }
      var i = this.transform;
      i || (i = this.transform = [
        1,
        0,
        0,
        1,
        0,
        0
      ]), i[4] += e, i[5] += t, this.decomposeTransform(), this.markRedraw();
    }, n.prototype.beforeUpdate = function() {
    }, n.prototype.afterUpdate = function() {
    }, n.prototype.update = function() {
      this.updateTransform(), this.__dirty && this.updateInnerText();
    }, n.prototype.updateInnerText = function(e) {
      var t = this._textContent;
      if (t && (!t.ignore || e)) {
        this.textConfig || (this.textConfig = {});
        var r = this.textConfig, i = r.local, a = t.innerTransformable, s = void 0, o = void 0, l = false;
        a.parent = i ? this : null;
        var u = false;
        if (a.copyTransform(t), r.position != null) {
          var c = Qoe;
          r.layoutRect ? c.copy(r.layoutRect) : c.copy(this.getBoundingRect()), i || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Tp, r, c) : F_(Tp, r, c), a.x = Tp.x, a.y = Tp.y, s = Tp.align, o = Tp.verticalAlign;
          var h = r.origin;
          if (h && r.rotation != null) {
            var d = void 0, f = void 0;
            h === "center" ? (d = c.width * 0.5, f = c.height * 0.5) : (d = no(h[0], c.width), f = no(h[1], c.height)), u = true, a.originX = -a.x + d + (i ? 0 : c.x), a.originY = -a.y + f + (i ? 0 : c.y);
          }
        }
        r.rotation != null && (a.rotation = r.rotation);
        var p = r.offset;
        p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
        var g = r.inside == null ? typeof r.position == "string" && r.position.indexOf("inside") >= 0 : r.inside, m = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), v = void 0, y = void 0, x = void 0;
        g && this.canBeInsideText() ? (v = r.insideFill, y = r.insideStroke, (v == null || v === "auto") && (v = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(v), x = true)) : (v = r.outsideFill, y = r.outsideStroke, (v == null || v === "auto") && (v = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(v), x = true)), v = v || "#000", (v !== m.fill || y !== m.stroke || x !== m.autoStroke || s !== m.align || o !== m.verticalAlign) && (l = true, m.fill = v, m.stroke = y, m.autoStroke = x, m.align = s, m.verticalAlign = o, t.setDefaultTextStyle(m)), t.__dirty |= Uo, l && t.dirtyStyle(true);
      }
    }, n.prototype.canBeInsideText = function() {
      return true;
    }, n.prototype.getInsideTextFill = function() {
      return "#fff";
    }, n.prototype.getInsideTextStroke = function(e) {
      return "#000";
    }, n.prototype.getOutsideFill = function() {
      return this.__zr && this.__zr.isDarkMode() ? MD : ED;
    }, n.prototype.getOutsideStroke = function(e) {
      var t = this.__zr && this.__zr.getBackgroundColor(), r = typeof t == "string" && Va(t);
      r || (r = [
        255,
        255,
        255,
        1
      ]);
      for (var i = r[3], a = this.__zr.isDarkMode(), s = 0; s < 3; s++) r[s] = r[s] * i + (a ? 0 : 255) * (1 - i);
      return r[3] = 1, Pl(r, "rgba");
    }, n.prototype.traverse = function(e, t) {
    }, n.prototype.attrKV = function(e, t) {
      e === "textConfig" ? this.setTextConfig(t) : e === "textContent" ? this.setTextContent(t) : e === "clipPath" ? this.setClipPath(t) : e === "extra" ? (this.extra = this.extra || {}, oe(this.extra, t)) : this[e] = t;
    }, n.prototype.hide = function() {
      this.ignore = true, this.markRedraw();
    }, n.prototype.show = function() {
      this.ignore = false, this.markRedraw();
    }, n.prototype.attr = function(e, t) {
      if (typeof e == "string") this.attrKV(e, t);
      else if (Ze(e)) for (var r = e, i = Mt(r), a = 0; a < i.length; a++) {
        var s = i[a];
        this.attrKV(s, e[s]);
      }
      return this.markRedraw(), this;
    }, n.prototype.saveCurrentToNormalState = function(e) {
      this._innerSaveToNormal(e);
      for (var t = this._normalState, r = 0; r < this.animators.length; r++) {
        var i = this.animators[r], a = i.__fromStateTransition;
        if (!(i.getLoop() || a && a !== H2)) {
          var s = i.targetName, o = s ? t[s] : t;
          i.saveTo(o);
        }
      }
    }, n.prototype._innerSaveToNormal = function(e) {
      var t = this._normalState;
      t || (t = this._normalState = {}), e.textConfig && !t.textConfig && (t.textConfig = this.textConfig), this._savePrimaryToNormal(e, t, X2);
    }, n.prototype._savePrimaryToNormal = function(e, t, r) {
      for (var i = 0; i < r.length; i++) {
        var a = r[i];
        e[a] != null && !(a in t) && (t[a] = this[a]);
      }
    }, n.prototype.hasState = function() {
      return this.currentStates.length > 0;
    }, n.prototype.getState = function(e) {
      return this.states[e];
    }, n.prototype.ensureState = function(e) {
      var t = this.states;
      return t[e] || (t[e] = {}), t[e];
    }, n.prototype.clearStates = function(e) {
      this.useState(H2, false, e);
    }, n.prototype.useState = function(e, t, r, i) {
      var a = e === H2, s = this.hasState();
      if (!(!s && a)) {
        var o = this.currentStates, l = this.stateTransition;
        if (!(bt(o, e) >= 0 && (t || o.length === 1))) {
          var u;
          if (this.stateProxy && !a && (u = this.stateProxy(e)), u || (u = this.states && this.states[e]), !u && !a) {
            $N("State " + e + " not exists.");
            return;
          }
          a || this.saveCurrentToNormalState(u);
          var c = !!(u && u.hoverLayer || i);
          c && this._toggleHoverLayerFlag(true), this._applyStateObj(e, u, this._normalState, t, !r && !this.__inHover && l && l.duration > 0, l);
          var h = this._textContent, d = this._textGuide;
          return h && h.useState(e, t, r, c), d && d.useState(e, t, r, c), a ? (this.currentStates = [], this._normalState = {}) : t ? this.currentStates.push(e) : this.currentStates = [
            e
          ], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= -2), u;
        }
      }
    }, n.prototype.useStates = function(e, t, r) {
      if (!e.length) this.clearStates();
      else {
        var i = [], a = this.currentStates, s = e.length, o = s === a.length;
        if (o) {
          for (var l = 0; l < s; l++) if (e[l] !== a[l]) {
            o = false;
            break;
          }
        }
        if (o) return;
        for (var l = 0; l < s; l++) {
          var u = e[l], c = void 0;
          this.stateProxy && (c = this.stateProxy(u, e)), c || (c = this.states[u]), c && i.push(c);
        }
        var h = i[s - 1], d = !!(h && h.hoverLayer || r);
        d && this._toggleHoverLayerFlag(true);
        var f = this._mergeStates(i), p = this.stateTransition;
        this.saveCurrentToNormalState(f), this._applyStateObj(e.join(","), f, this._normalState, false, !t && !this.__inHover && p && p.duration > 0, p);
        var g = this._textContent, m = this._textGuide;
        g && g.useStates(e, t, d), m && m.useStates(e, t, d), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !d && this.__inHover && (this._toggleHoverLayerFlag(false), this.__dirty &= -2);
      }
    }, n.prototype.isSilent = function() {
      for (var e = this.silent, t = this.parent; !e && t; ) {
        if (t.silent) {
          e = true;
          break;
        }
        t = t.parent;
      }
      return e;
    }, n.prototype._updateAnimationTargets = function() {
      for (var e = 0; e < this.animators.length; e++) {
        var t = this.animators[e];
        t.targetName && t.changeTarget(this[t.targetName]);
      }
    }, n.prototype.removeState = function(e) {
      var t = bt(this.currentStates, e);
      if (t >= 0) {
        var r = this.currentStates.slice();
        r.splice(t, 1), this.useStates(r);
      }
    }, n.prototype.replaceState = function(e, t, r) {
      var i = this.currentStates.slice(), a = bt(i, e), s = bt(i, t) >= 0;
      a >= 0 ? s ? i.splice(a, 1) : i[a] = t : r && !s && i.push(t), this.useStates(i);
    }, n.prototype.toggleState = function(e, t) {
      t ? this.useState(e, true) : this.removeState(e);
    }, n.prototype._mergeStates = function(e) {
      for (var t = {}, r, i = 0; i < e.length; i++) {
        var a = e[i];
        oe(t, a), a.textConfig && (r = r || {}, oe(r, a.textConfig));
      }
      return r && (t.textConfig = r), t;
    }, n.prototype._applyStateObj = function(e, t, r, i, a, s) {
      var o = !(t && i);
      t && t.textConfig ? (this.textConfig = oe({}, i ? this.textConfig : r.textConfig), oe(this.textConfig, t.textConfig)) : o && r.textConfig && (this.textConfig = r.textConfig);
      for (var l = {}, u = false, c = 0; c < X2.length; c++) {
        var h = X2[c], d = a && Zoe[h];
        t && t[h] != null ? d ? (u = true, l[h] = t[h]) : this[h] = t[h] : o && r[h] != null && (d ? (u = true, l[h] = r[h]) : this[h] = r[h]);
      }
      if (!a) for (var c = 0; c < this.animators.length; c++) {
        var f = this.animators[c], p = f.targetName;
        f.getLoop() || f.__changeFinalValue(p ? (t || r)[p] : t || r);
      }
      u && this._transitionState(e, l, s);
    }, n.prototype._attachComponent = function(e) {
      if (!(e.__zr && !e.__hostTarget) && e !== this) {
        var t = this.__zr;
        t && e.addSelfToZr(t), e.__zr = t, e.__hostTarget = this;
      }
    }, n.prototype._detachComponent = function(e) {
      e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null;
    }, n.prototype.getClipPath = function() {
      return this._clipPath;
    }, n.prototype.setClipPath = function(e) {
      this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw();
    }, n.prototype.removeClipPath = function() {
      var e = this._clipPath;
      e && (this._detachComponent(e), this._clipPath = null, this.markRedraw());
    }, n.prototype.getTextContent = function() {
      return this._textContent;
    }, n.prototype.setTextContent = function(e) {
      var t = this._textContent;
      t !== e && (t && t !== e && this.removeTextContent(), e.innerTransformable = new Tl(), this._attachComponent(e), this._textContent = e, this.markRedraw());
    }, n.prototype.setTextConfig = function(e) {
      this.textConfig || (this.textConfig = {}), oe(this.textConfig, e), this.markRedraw();
    }, n.prototype.removeTextConfig = function() {
      this.textConfig = null, this.markRedraw();
    }, n.prototype.removeTextContent = function() {
      var e = this._textContent;
      e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
    }, n.prototype.getTextGuideLine = function() {
      return this._textGuide;
    }, n.prototype.setTextGuideLine = function(e) {
      this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw();
    }, n.prototype.removeTextGuideLine = function() {
      var e = this._textGuide;
      e && (this._detachComponent(e), this._textGuide = null, this.markRedraw());
    }, n.prototype.markRedraw = function() {
      this.__dirty |= Uo;
      var e = this.__zr;
      e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
    }, n.prototype.dirty = function() {
      this.markRedraw();
    }, n.prototype._toggleHoverLayerFlag = function(e) {
      this.__inHover = e;
      var t = this._textContent, r = this._textGuide;
      t && (t.__inHover = e), r && (r.__inHover = e);
    }, n.prototype.addSelfToZr = function(e) {
      if (this.__zr !== e) {
        this.__zr = e;
        var t = this.animators;
        if (t) for (var r = 0; r < t.length; r++) e.animation.addAnimator(t[r]);
        this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e);
      }
    }, n.prototype.removeSelfFromZr = function(e) {
      if (this.__zr) {
        this.__zr = null;
        var t = this.animators;
        if (t) for (var r = 0; r < t.length; r++) e.animation.removeAnimator(t[r]);
        this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e);
      }
    }, n.prototype.animate = function(e, t, r) {
      var i = e ? this[e] : this, a = new zN(i, t, r);
      return e && (a.targetName = e), this.addAnimator(a, e), a;
    }, n.prototype.addAnimator = function(e, t) {
      var r = this.__zr, i = this;
      e.during(function() {
        i.updateDuringAnimation(t);
      }).done(function() {
        var a = i.animators, s = bt(a, e);
        s >= 0 && a.splice(s, 1);
      }), this.animators.push(e), r && r.animation.addAnimator(e), r && r.wakeUp();
    }, n.prototype.updateDuringAnimation = function(e) {
      this.markRedraw();
    }, n.prototype.stopAnimation = function(e, t) {
      for (var r = this.animators, i = r.length, a = [], s = 0; s < i; s++) {
        var o = r[s];
        !e || e === o.scope ? o.stop(t) : a.push(o);
      }
      return this.animators = a, this;
    }, n.prototype.animateTo = function(e, t, r) {
      Y2(this, e, t, r);
    }, n.prototype.animateFrom = function(e, t, r) {
      Y2(this, e, t, r, true);
    }, n.prototype._transitionState = function(e, t, r, i) {
      for (var a = Y2(this, t, r, i), s = 0; s < a.length; s++) a[s].__fromStateTransition = e;
    }, n.prototype.getBoundingRect = function() {
      return null;
    }, n.prototype.getPaintRect = function() {
      return null;
    }, n.initDefaultProps = function() {
      var e = n.prototype;
      e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = false, e.__dirty = Uo;
      function t(r, i, a, s) {
        Object.defineProperty(e, r, {
          get: function() {
            if (!this[i]) {
              var l = this[i] = [];
              o(this, l);
            }
            return this[i];
          },
          set: function(l) {
            this[a] = l[0], this[s] = l[1], this[i] = l, o(this, l);
          }
        });
        function o(l, u) {
          Object.defineProperty(u, 0, {
            get: function() {
              return l[a];
            },
            set: function(c) {
              l[a] = c;
            }
          }), Object.defineProperty(u, 1, {
            get: function() {
              return l[s];
            },
            set: function(c) {
              l[s] = c;
            }
          });
        }
      }
      Object.defineProperty && (t("position", "_legacyPos", "x", "y"), t("scale", "_legacyScale", "scaleX", "scaleY"), t("origin", "_legacyOrigin", "originX", "originY"));
    }(), n;
  }();
  br(gC, Is);
  br(gC, Tl);
  function Y2(n, e, t, r, i) {
    t = t || {};
    var a = [];
    q6(n, "", n, e, t, r, a, i);
    var s = a.length, o = false, l = t.done, u = t.aborted, c = function() {
      o = true, s--, s <= 0 && (o ? l && l() : u && u());
    }, h = function() {
      s--, s <= 0 && (o ? l && l() : u && u());
    };
    s || l && l(), a.length > 0 && t.during && a[0].during(function(p, g) {
      t.during(g);
    });
    for (var d = 0; d < a.length; d++) {
      var f = a[d];
      c && f.done(c), h && f.aborted(h), t.force && f.duration(t.duration), f.start(t.easing);
    }
    return a;
  }
  function q2(n, e, t) {
    for (var r = 0; r < t; r++) n[r] = e[r];
  }
  function Joe(n) {
    return Mi(n[0]);
  }
  function ele(n, e, t) {
    if (Mi(e[t])) if (Mi(n[t]) || (n[t] = []), Ia(e[t])) {
      var r = e[t].length;
      n[t].length !== r && (n[t] = new e[t].constructor(r), q2(n[t], e[t], r));
    } else {
      var i = e[t], a = n[t], s = i.length;
      if (Joe(i)) for (var o = i[0].length, l = 0; l < s; l++) a[l] ? q2(a[l], i[l], o) : a[l] = Array.prototype.slice.call(i[l]);
      else q2(a, i, s);
      a.length = i.length;
    }
    else n[t] = e[t];
  }
  function tle(n, e) {
    return n === e || Mi(n) && Mi(e) && nle(n, e);
  }
  function nle(n, e) {
    var t = n.length;
    if (t !== e.length) return false;
    for (var r = 0; r < t; r++) if (n[r] !== e[r]) return false;
    return true;
  }
  function q6(n, e, t, r, i, a, s, o) {
    for (var l = Mt(r), u = i.duration, c = i.delay, h = i.additive, d = i.setToFinal, f = !Ze(a), p = n.animators, g = [], m = 0; m < l.length; m++) {
      var v = l[m], y = r[v];
      if (y != null && t[v] != null && (f || a[v])) if (Ze(y) && !Mi(y) && !cC(y)) {
        if (e) {
          o || (t[v] = y, n.updateDuringAnimation(e));
          continue;
        }
        q6(n, v, t[v], y, i, a && a[v], s, o);
      } else g.push(v);
      else o || (t[v] = y, n.updateDuringAnimation(e), g.push(v));
    }
    var x = g.length;
    if (!h && x) for (var b = 0; b < p.length; b++) {
      var w = p[b];
      if (w.targetName === e) {
        var _ = w.stopTracks(g);
        if (_) {
          var S = bt(p, w);
          p.splice(S, 1);
        }
      }
    }
    if (i.force || (g = rn(g, function(k) {
      return !tle(r[k], t[k]);
    }), x = g.length), x > 0 || i.force && !s.length) {
      var I = void 0, C = void 0, T = void 0;
      if (o) {
        C = {}, d && (I = {});
        for (var b = 0; b < x; b++) {
          var v = g[b];
          C[v] = t[v], d ? I[v] = r[v] : t[v] = r[v];
        }
      } else if (d) {
        T = {};
        for (var b = 0; b < x; b++) {
          var v = g[b];
          T[v] = n0(t[v]), ele(t, r, v);
        }
      }
      var w = new zN(t, false, false, h ? rn(p, function(D) {
        return D.targetName === e;
      }) : null);
      w.targetName = e, i.scope && (w.scope = i.scope), d && I && w.whenWithKeys(0, I, g), T && w.whenWithKeys(0, T, g), w.whenWithKeys(u ?? 500, o ? C : r, g).delay(c || 0), n.addAnimator(w, e), s.push(w);
    }
  }
  var tt = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r.isGroup = true, r._children = [], r.attr(t), r;
    }
    return e.prototype.childrenRef = function() {
      return this._children;
    }, e.prototype.children = function() {
      return this._children.slice();
    }, e.prototype.childAt = function(t) {
      return this._children[t];
    }, e.prototype.childOfName = function(t) {
      for (var r = this._children, i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
    }, e.prototype.childCount = function() {
      return this._children.length;
    }, e.prototype.add = function(t) {
      return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this;
    }, e.prototype.addBefore = function(t, r) {
      if (t && t !== this && t.parent !== this && r && r.parent === this) {
        var i = this._children, a = i.indexOf(r);
        a >= 0 && (i.splice(a, 0, t), this._doAdd(t));
      }
      return this;
    }, e.prototype.replace = function(t, r) {
      var i = bt(this._children, t);
      return i >= 0 && this.replaceAt(r, i), this;
    }, e.prototype.replaceAt = function(t, r) {
      var i = this._children, a = i[r];
      if (t && t !== this && t.parent !== this && t !== a) {
        i[r] = t, a.parent = null;
        var s = this.__zr;
        s && a.removeSelfFromZr(s), this._doAdd(t);
      }
      return this;
    }, e.prototype._doAdd = function(t) {
      t.parent && t.parent.remove(t), t.parent = this;
      var r = this.__zr;
      r && r !== t.__zr && t.addSelfToZr(r), r && r.refresh();
    }, e.prototype.remove = function(t) {
      var r = this.__zr, i = this._children, a = bt(i, t);
      return a < 0 ? this : (i.splice(a, 1), t.parent = null, r && t.removeSelfFromZr(r), r && r.refresh(), this);
    }, e.prototype.removeAll = function() {
      for (var t = this._children, r = this.__zr, i = 0; i < t.length; i++) {
        var a = t[i];
        r && a.removeSelfFromZr(r), a.parent = null;
      }
      return t.length = 0, this;
    }, e.prototype.eachChild = function(t, r) {
      for (var i = this._children, a = 0; a < i.length; a++) {
        var s = i[a];
        t.call(r, s, a);
      }
      return this;
    }, e.prototype.traverse = function(t, r) {
      for (var i = 0; i < this._children.length; i++) {
        var a = this._children[i], s = t.call(r, a);
        a.isGroup && !s && a.traverse(t, r);
      }
      return this;
    }, e.prototype.addSelfToZr = function(t) {
      n.prototype.addSelfToZr.call(this, t);
      for (var r = 0; r < this._children.length; r++) {
        var i = this._children[r];
        i.addSelfToZr(t);
      }
    }, e.prototype.removeSelfFromZr = function(t) {
      n.prototype.removeSelfFromZr.call(this, t);
      for (var r = 0; r < this._children.length; r++) {
        var i = this._children[r];
        i.removeSelfFromZr(t);
      }
    }, e.prototype.getBoundingRect = function(t) {
      for (var r = new vt(0, 0, 0, 0), i = t || this._children, a = [], s = null, o = 0; o < i.length; o++) {
        var l = i[o];
        if (!(l.ignore || l.invisible)) {
          var u = l.getBoundingRect(), c = l.getLocalTransform(a);
          c ? (vt.applyTransform(r, u, c), s = s || r.clone(), s.union(r)) : (s = s || u.clone(), s.union(u));
        }
      }
      return s || r;
    }, e;
  }(gC);
  tt.prototype.type = "group";
  var t_ = {}, j6 = {};
  function rle(n) {
    delete j6[n];
  }
  function ile(n) {
    if (!n) return false;
    if (typeof n == "string") return M_(n, 1) < ND;
    if (n.colorStops) {
      for (var e = n.colorStops, t = 0, r = e.length, i = 0; i < r; i++) t += M_(e[i].color, 1);
      return t /= r, t < ND;
    }
    return false;
  }
  var ale = function() {
    function n(e, t, r) {
      var i = this;
      this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = true, this._needsRefreshHover = true, this._darkMode = false, r = r || {}, this.dom = t, this.id = e;
      var a = new yoe(), s = r.renderer || "canvas";
      t_[s] || (s = Mt(t_)[0]), r.useDirtyRect = r.useDirtyRect == null ? false : r.useDirtyRect;
      var o = new t_[s](t, a, r, e), l = r.ssr || o.ssrOnly;
      this.storage = a, this.painter = o;
      var u = !Dt.node && !Dt.worker && !l ? new qoe(o.getViewportRoot(), o.root) : null, c = r.useCoarsePointer, h = c == null || c === "auto" ? Dt.touchEventsSupported : !!c, d = 44, f;
      h && (f = it(r.pointerSize, d)), this.handler = new k6(a, o, u, o.root, f), this.animation = new Voe({
        stage: {
          update: l ? null : function() {
            return i._flush(true);
          }
        }
      }), l || this.animation.start();
    }
    return n.prototype.add = function(e) {
      this._disposed || !e || (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh());
    }, n.prototype.remove = function(e) {
      this._disposed || !e || (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh());
    }, n.prototype.configLayer = function(e, t) {
      this._disposed || (this.painter.configLayer && this.painter.configLayer(e, t), this.refresh());
    }, n.prototype.setBackgroundColor = function(e) {
      this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = ile(e));
    }, n.prototype.getBackgroundColor = function() {
      return this._backgroundColor;
    }, n.prototype.setDarkMode = function(e) {
      this._darkMode = e;
    }, n.prototype.isDarkMode = function() {
      return this._darkMode;
    }, n.prototype.refreshImmediately = function(e) {
      this._disposed || (e || this.animation.update(true), this._needsRefresh = false, this.painter.refresh(), this._needsRefresh = false);
    }, n.prototype.refresh = function() {
      this._disposed || (this._needsRefresh = true, this.animation.start());
    }, n.prototype.flush = function() {
      this._disposed || this._flush(false);
    }, n.prototype._flush = function(e) {
      var t, r = gg();
      this._needsRefresh && (t = true, this.refreshImmediately(e)), this._needsRefreshHover && (t = true, this.refreshHoverImmediately());
      var i = gg();
      t ? (this._stillFrameAccum = 0, this.trigger("rendered", {
        elapsedTime: i - r
      })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
    }, n.prototype.setSleepAfterStill = function(e) {
      this._sleepAfterStill = e;
    }, n.prototype.wakeUp = function() {
      this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
    }, n.prototype.refreshHover = function() {
      this._needsRefreshHover = true;
    }, n.prototype.refreshHoverImmediately = function() {
      this._disposed || (this._needsRefreshHover = false, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
    }, n.prototype.resize = function(e) {
      this._disposed || (e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize());
    }, n.prototype.clearAnimation = function() {
      this._disposed || this.animation.clear();
    }, n.prototype.getWidth = function() {
      if (!this._disposed) return this.painter.getWidth();
    }, n.prototype.getHeight = function() {
      if (!this._disposed) return this.painter.getHeight();
    }, n.prototype.setCursorStyle = function(e) {
      this._disposed || this.handler.setCursorStyle(e);
    }, n.prototype.findHover = function(e, t) {
      if (!this._disposed) return this.handler.findHover(e, t);
    }, n.prototype.on = function(e, t, r) {
      return this._disposed || this.handler.on(e, t, r), this;
    }, n.prototype.off = function(e, t) {
      this._disposed || this.handler.off(e, t);
    }, n.prototype.trigger = function(e, t) {
      this._disposed || this.handler.trigger(e, t);
    }, n.prototype.clear = function() {
      if (!this._disposed) {
        for (var e = this.storage.getRoots(), t = 0; t < e.length; t++) e[t] instanceof tt && e[t].removeSelfFromZr(this);
        this.storage.delAllRoots(), this.painter.clear();
      }
    }, n.prototype.dispose = function() {
      this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = true, rle(this.id));
    }, n;
  }();
  function dF(n, e) {
    var t = new ale(b6(), n, e);
    return j6[t.id] = t, t;
  }
  function sle(n, e) {
    t_[n] = e;
  }
  var PD;
  function ole(n) {
    if (typeof PD == "function") return PD(n);
  }
  function lle(n) {
    PD = n;
  }
  var ule = 1e-4, K6 = 20;
  function cle(n) {
    return n.replace(/^\s+|\s+$/g, "");
  }
  function sn(n, e, t, r) {
    var i = e[0], a = e[1], s = t[0], o = t[1], l = a - i, u = o - s;
    if (l === 0) return u === 0 ? s : (s + o) / 2;
    if (r) if (l > 0) {
      if (n <= i) return s;
      if (n >= a) return o;
    } else {
      if (n >= i) return s;
      if (n <= a) return o;
    }
    else {
      if (n === i) return s;
      if (n === a) return o;
    }
    return (n - i) / l * u + s;
  }
  function _e(n, e) {
    switch (n) {
      case "center":
      case "middle":
        n = "50%";
        break;
      case "left":
      case "top":
        n = "0%";
        break;
      case "right":
      case "bottom":
        n = "100%";
        break;
    }
    return Ie(n) ? cle(n).match(/%$/) ? parseFloat(n) / 100 * e : parseFloat(n) : n == null ? NaN : +n;
  }
  function rr(n, e, t) {
    return e == null && (e = 10), e = Math.min(Math.max(0, e), K6), n = (+n).toFixed(e), t ? n : +n;
  }
  function vs(n) {
    return n.sort(function(e, t) {
      return e - t;
    }), n;
  }
  function Oo(n) {
    if (n = +n, isNaN(n)) return 0;
    if (n > 1e-14) {
      for (var e = 1, t = 0; t < 15; t++, e *= 10) if (Math.round(n * e) / e === n) return t;
    }
    return hle(n);
  }
  function hle(n) {
    var e = n.toString().toLowerCase(), t = e.indexOf("e"), r = t > 0 ? +e.slice(t + 1) : 0, i = t > 0 ? t : e.length, a = e.indexOf("."), s = a < 0 ? 0 : i - 1 - a;
    return Math.max(0, s - r);
  }
  function Z6(n, e) {
    var t = Math.log, r = Math.LN10, i = Math.floor(t(n[1] - n[0]) / r), a = Math.round(t(Math.abs(e[1] - e[0])) / r), s = Math.min(Math.max(-i + a, 0), 20);
    return isFinite(s) ? s : 20;
  }
  function dle(n, e) {
    var t = Qo(n, function(f, p) {
      return f + (isNaN(p) ? 0 : p);
    }, 0);
    if (t === 0) return [];
    for (var r = Math.pow(10, e), i = me(n, function(f) {
      return (isNaN(f) ? 0 : f) / t * r * 100;
    }), a = r * 100, s = me(i, function(f) {
      return Math.floor(f);
    }), o = Qo(s, function(f, p) {
      return f + p;
    }, 0), l = me(i, function(f, p) {
      return f - s[p];
    }); o < a; ) {
      for (var u = Number.NEGATIVE_INFINITY, c = null, h = 0, d = l.length; h < d; ++h) l[h] > u && (u = l[h], c = h);
      ++s[c], l[c] = 0, ++o;
    }
    return me(s, function(f) {
      return f / r;
    });
  }
  function fle(n, e) {
    var t = Math.max(Oo(n), Oo(e)), r = n + e;
    return t > K6 ? r : rr(r, t);
  }
  var fF = 9007199254740991;
  function Q6(n) {
    var e = Math.PI * 2;
    return (n % e + e) % e;
  }
  function D0(n) {
    return n > -1e-4 && n < ule;
  }
  var ple = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function tl(n) {
    if (n instanceof Date) return n;
    if (Ie(n)) {
      var e = ple.exec(n);
      if (!e) return /* @__PURE__ */ new Date(NaN);
      if (e[8]) {
        var t = +e[4] || 0;
        return e[8].toUpperCase() !== "Z" && (t -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, t, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0));
      } else return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0);
    } else if (n == null) return /* @__PURE__ */ new Date(NaN);
    return new Date(Math.round(n));
  }
  function gle(n) {
    return Math.pow(10, VN(n));
  }
  function VN(n) {
    if (n === 0) return 0;
    var e = Math.floor(Math.log(n) / Math.LN10);
    return n / Math.pow(10, e) >= 10 && e++, e;
  }
  function J6(n, e) {
    var t = VN(n), r = Math.pow(10, t), i = n / r, a;
    return i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10, n = a * r, t >= -20 ? +n.toFixed(t < 0 ? -t : 0) : n;
  }
  function j2(n, e) {
    var t = (n.length - 1) * e + 1, r = Math.floor(t), i = +n[r - 1], a = t - r;
    return a ? i + a * (n[r] - i) : i;
  }
  function pF(n) {
    n.sort(function(l, u) {
      return o(l, u, 0) ? -1 : 1;
    });
    for (var e = -1 / 0, t = 1, r = 0; r < n.length; ) {
      for (var i = n[r].interval, a = n[r].close, s = 0; s < 2; s++) i[s] <= e && (i[s] = e, a[s] = s ? 1 : 1 - t), e = i[s], t = a[s];
      i[0] === i[1] && a[0] * a[1] !== 1 ? n.splice(r, 1) : r++;
    }
    return n;
    function o(l, u, c) {
      return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && o(l, u, 1));
    }
  }
  function Hl(n) {
    var e = parseFloat(n);
    return e == n && (e !== 0 || !Ie(n) || n.indexOf("x") <= 0) ? e : NaN;
  }
  function e8(n) {
    return !isNaN(Hl(n));
  }
  function t8() {
    return Math.round(Math.random() * 9);
  }
  function n8(n, e) {
    return e === 0 ? n : n8(e, n % e);
  }
  function gF(n, e) {
    return n == null ? e : e == null ? n : n * e / n8(n, e);
  }
  function nn(n) {
    throw new Error(n);
  }
  function mF(n, e, t) {
    return (e - n) * t + n;
  }
  var r8 = "series\0", i8 = "\0_ec_\0";
  function xn(n) {
    return n instanceof Array ? n : n == null ? [] : [
      n
    ];
  }
  function ud(n, e, t) {
    if (n) {
      n[e] = n[e] || {}, n.emphasis = n.emphasis || {}, n.emphasis[e] = n.emphasis[e] || {};
      for (var r = 0, i = t.length; r < i; r++) {
        var a = t[r];
        !n.emphasis[e].hasOwnProperty(a) && n[e].hasOwnProperty(a) && (n.emphasis[e][a] = n[e][a]);
      }
    }
  }
  var vF = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "rich",
    "tag",
    "color",
    "textBorderColor",
    "textBorderWidth",
    "width",
    "height",
    "lineHeight",
    "align",
    "verticalAlign",
    "baseline",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "textShadowColor",
    "textShadowBlur",
    "textShadowOffsetX",
    "textShadowOffsetY",
    "backgroundColor",
    "borderColor",
    "borderWidth",
    "borderRadius",
    "padding"
  ];
  function pm(n) {
    return Ze(n) && !de(n) && !(n instanceof Date) ? n.value : n;
  }
  function mle(n) {
    return Ze(n) && !(n instanceof Array);
  }
  function a8(n, e, t) {
    var r = t === "normalMerge", i = t === "replaceMerge", a = t === "replaceAll";
    n = n || [], e = (e || []).slice();
    var s = Pe();
    P(e, function(l, u) {
      if (!Ze(l)) {
        e[u] = null;
        return;
      }
    });
    var o = vle(n, s, t);
    return (r || i) && yle(o, n, s, e), r && xle(o, e), r || i ? ble(o, e, i) : a && wle(o, e), _le(o), o;
  }
  function vle(n, e, t) {
    var r = [];
    if (t === "replaceAll") return r;
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      a && a.id != null && e.set(a.id, i), r.push({
        existing: t === "replaceMerge" || R0(a) ? null : a,
        newOption: null,
        keyInfo: null,
        brandNew: null
      });
    }
    return r;
  }
  function yle(n, e, t, r) {
    P(r, function(i, a) {
      if (!(!i || i.id == null)) {
        var s = r0(i.id), o = t.get(s);
        if (o != null) {
          var l = n[o];
          ta(!l.newOption, 'Duplicated option on id "' + s + '".'), l.newOption = i, l.existing = e[o], r[a] = null;
        }
      }
    });
  }
  function xle(n, e) {
    P(e, function(t, r) {
      if (!(!t || t.name == null)) for (var i = 0; i < n.length; i++) {
        var a = n[i].existing;
        if (!n[i].newOption && a && (a.id == null || t.id == null) && !R0(t) && !R0(a) && s8("name", a, t)) {
          n[i].newOption = t, e[r] = null;
          return;
        }
      }
    });
  }
  function ble(n, e, t) {
    P(e, function(r) {
      if (r) {
        for (var i, a = 0; (i = n[a]) && (i.newOption || R0(i.existing) || i.existing && r.id != null && !s8("id", r, i.existing)); ) a++;
        i ? (i.newOption = r, i.brandNew = t) : n.push({
          newOption: r,
          brandNew: t,
          existing: null,
          keyInfo: null
        }), a++;
      }
    });
  }
  function wle(n, e) {
    P(e, function(t) {
      n.push({
        newOption: t,
        brandNew: true,
        existing: null,
        keyInfo: null
      });
    });
  }
  function _le(n) {
    var e = Pe();
    P(n, function(t) {
      var r = t.existing;
      r && e.set(r.id, t);
    }), P(n, function(t) {
      var r = t.newOption;
      ta(!r || r.id == null || !e.get(r.id) || e.get(r.id) === t, "id duplicates: " + (r && r.id)), r && r.id != null && e.set(r.id, t), !t.keyInfo && (t.keyInfo = {});
    }), P(n, function(t, r) {
      var i = t.existing, a = t.newOption, s = t.keyInfo;
      if (Ze(a)) {
        if (s.name = a.name != null ? r0(a.name) : i ? i.name : r8 + r, i) s.id = r0(i.id);
        else if (a.id != null) s.id = r0(a.id);
        else {
          var o = 0;
          do
            s.id = "\0" + s.name + "\0" + o++;
          while (e.get(s.id));
        }
        e.set(s.id, t);
      }
    });
  }
  function s8(n, e, t) {
    var r = kr(e[n], null), i = kr(t[n], null);
    return r != null && i != null && r === i;
  }
  function r0(n) {
    return kr(n, "");
  }
  function kr(n, e) {
    return n == null ? e : Ie(n) ? n : Yt(n) || fD(n) ? n + "" : e;
  }
  function WN(n) {
    var e = n.name;
    return !!(e && e.indexOf(r8));
  }
  function R0(n) {
    return n && n.id != null && r0(n.id).indexOf(i8) === 0;
  }
  function Sle(n) {
    return i8 + n;
  }
  function Cle(n, e, t) {
    P(n, function(r) {
      var i = r.newOption;
      Ze(i) && (r.keyInfo.mainType = e, r.keyInfo.subType = Ile(e, i, r.existing, t));
    });
  }
  function Ile(n, e, t, r) {
    var i = e.type ? e.type : t ? t.subType : r.determineSubType(n, e);
    return i;
  }
  function kle(n, e) {
    var t = {}, r = {};
    return i(n || [], t), i(e || [], r, t), [
      a(t),
      a(r)
    ];
    function i(s, o, l) {
      for (var u = 0, c = s.length; u < c; u++) {
        var h = kr(s[u].seriesId, null);
        if (h == null) return;
        for (var d = xn(s[u].dataIndex), f = l && l[h], p = 0, g = d.length; p < g; p++) {
          var m = d[p];
          f && f[m] ? f[m] = null : (o[h] || (o[h] = {}))[m] = 1;
        }
      }
    }
    function a(s, o) {
      var l = [];
      for (var u in s) if (s.hasOwnProperty(u) && s[u] != null) if (o) l.push(+u);
      else {
        var c = a(s[u], true);
        c.length && l.push({
          seriesId: u,
          dataIndex: c
        });
      }
      return l;
    }
  }
  function cd(n, e) {
    if (e.dataIndexInside != null) return e.dataIndexInside;
    if (e.dataIndex != null) return de(e.dataIndex) ? me(e.dataIndex, function(t) {
      return n.indexOfRawIndex(t);
    }) : n.indexOfRawIndex(e.dataIndex);
    if (e.name != null) return de(e.name) ? me(e.name, function(t) {
      return n.indexOfName(t);
    }) : n.indexOfName(e.name);
  }
  function Wt() {
    var n = "__ec_inner_" + Tle++;
    return function(e) {
      return e[n] || (e[n] = {});
    };
  }
  var Tle = t8();
  function i0(n, e, t) {
    var r = GN(e, t), i = r.mainTypeSpecified, a = r.queryOptionMap, s = r.others, o = s, l = t ? t.defaultMainType : null;
    return !i && l && a.set(l, {}), a.each(function(u, c) {
      var h = $x(n, c, u, {
        useDefault: l === c,
        enableAll: t && t.enableAll != null ? t.enableAll : true,
        enableNone: t && t.enableNone != null ? t.enableNone : true
      });
      o[c + "Models"] = h.models, o[c + "Model"] = h.models[0];
    }), o;
  }
  function GN(n, e) {
    var t;
    if (Ie(n)) {
      var r = {};
      r[n + "Index"] = 0, t = r;
    } else t = n;
    var i = Pe(), a = {}, s = false;
    return P(t, function(o, l) {
      if (l === "dataIndex" || l === "dataIndexInside") {
        a[l] = o;
        return;
      }
      var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
      if (!(!c || !h || e && e.includeMainTypes && bt(e.includeMainTypes, c) < 0)) {
        s = s || !!c;
        var d = i.get(c) || i.set(c, {});
        d[h] = o;
      }
    }), {
      mainTypeSpecified: s,
      queryOptionMap: i,
      others: a
    };
  }
  var yr = {
    useDefault: true,
    enableAll: false,
    enableNone: false
  }, Ale = {
    useDefault: false,
    enableAll: true,
    enableNone: true
  };
  function $x(n, e, t, r) {
    r = r || yr;
    var i = t.index, a = t.id, s = t.name, o = {
      models: null,
      specified: i != null || a != null || s != null
    };
    if (!o.specified) {
      var l = void 0;
      return o.models = r.useDefault && (l = n.getComponent(e)) ? [
        l
      ] : [], o;
    }
    return i === "none" || i === false ? (ta(r.enableNone, '`"none"` or `false` is not a valid value on index option.'), o.models = [], o) : (i === "all" && (ta(r.enableAll, '`"all"` is not a valid value on index option.'), i = a = s = null), o.models = n.queryComponents({
      mainType: e,
      index: i,
      id: a,
      name: s
    }), o);
  }
  function o8(n, e, t) {
    n.setAttribute ? n.setAttribute(e, t) : n[e] = t;
  }
  function Dle(n, e) {
    return n.getAttribute ? n.getAttribute(e) : n[e];
  }
  function Rle(n) {
    return n === "auto" ? Dt.domSupported ? "html" : "richText" : n || "html";
  }
  function LD(n, e) {
    var t = Pe(), r = [];
    return P(n, function(i) {
      var a = e(i);
      (t.get(a) || (r.push(a), t.set(a, []))).push(i);
    }), {
      keys: r,
      buckets: t
    };
  }
  function l8(n, e, t, r, i) {
    var a = e == null || e === "auto";
    if (r == null) return r;
    if (Yt(r)) {
      var s = mF(t || 0, r, i);
      return rr(s, a ? Math.max(Oo(t || 0), Oo(r)) : e);
    } else {
      if (Ie(r)) return i < 1 ? t : r;
      for (var o = [], l = t, u = r, c = Math.max(l ? l.length : 0, u.length), h = 0; h < c; ++h) {
        var d = n.getDimensionInfo(h);
        if (d && d.type === "ordinal") o[h] = (i < 1 && l ? l : u)[h];
        else {
          var f = l && l[h] ? l[h] : 0, p = u[h], s = mF(f, p, i);
          o[h] = rr(s, a ? Math.max(Oo(f), Oo(p)) : e);
        }
      }
      return o;
    }
  }
  var $le = ".", Hc = "___EC__COMPONENT__CONTAINER___", u8 = "___EC__EXTENDED_CLASS___";
  function Bo(n) {
    var e = {
      main: "",
      sub: ""
    };
    if (n) {
      var t = n.split($le);
      e.main = t[0] || "", e.sub = t[1] || "";
    }
    return e;
  }
  function Nle(n) {
    ta(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(n), 'componentType "' + n + '" illegal');
  }
  function Ele(n) {
    return !!(n && n[u8]);
  }
  function UN(n, e) {
    n.$constructor = n, n.extend = function(t) {
      var r = this, i;
      return Mle(r) ? i = function(a) {
        K(s, a);
        function s() {
          return a.apply(this, arguments) || this;
        }
        return s;
      }(r) : (i = function() {
        (t.$constructor || r).apply(this, arguments);
      }, Bse(i, this)), oe(i.prototype, t), i[u8] = true, i.extend = this.extend, i.superCall = Fle, i.superApply = Ole, i.superClass = r, i;
    };
  }
  function Mle(n) {
    return Xe(n) && /^class\s/.test(Function.prototype.toString.call(n));
  }
  function c8(n, e) {
    n.extend = e.extend;
  }
  var Ple = Math.round(Math.random() * 10);
  function Lle(n) {
    var e = [
      "__\0is_clz",
      Ple++
    ].join("_");
    n.prototype[e] = true, n.isInstance = function(t) {
      return !!(t && t[e]);
    };
  }
  function Fle(n, e) {
    for (var t = [], r = 2; r < arguments.length; r++) t[r - 2] = arguments[r];
    return this.superClass.prototype[e].apply(n, t);
  }
  function Ole(n, e, t) {
    return this.superClass.prototype[e].apply(n, t);
  }
  function mC(n) {
    var e = {};
    n.registerClass = function(r) {
      var i = r.type || r.prototype.type;
      if (i) {
        Nle(i), r.prototype.type = i;
        var a = Bo(i);
        if (!a.sub) e[a.main] = r;
        else if (a.sub !== Hc) {
          var s = t(a);
          s[a.sub] = r;
        }
      }
      return r;
    }, n.getClass = function(r, i, a) {
      var s = e[r];
      if (s && s[Hc] && (s = i ? s[i] : null), a && !s) throw new Error(i ? "Component " + r + "." + (i || "") + " is used but not imported." : r + ".type should be specified.");
      return s;
    }, n.getClassesByMainType = function(r) {
      var i = Bo(r), a = [], s = e[i.main];
      return s && s[Hc] ? P(s, function(o, l) {
        l !== Hc && a.push(o);
      }) : a.push(s), a;
    }, n.hasClass = function(r) {
      var i = Bo(r);
      return !!e[i.main];
    }, n.getAllClassMainTypes = function() {
      var r = [];
      return P(e, function(i, a) {
        r.push(a);
      }), r;
    }, n.hasSubTypes = function(r) {
      var i = Bo(r), a = e[i.main];
      return a && a[Hc];
    };
    function t(r) {
      var i = e[r.main];
      return (!i || !i[Hc]) && (i = e[r.main] = {}, i[Hc] = true), i;
    }
  }
  function hd(n, e) {
    for (var t = 0; t < n.length; t++) n[t][1] || (n[t][1] = n[t][0]);
    return e = e || false, function(r, i, a) {
      for (var s = {}, o = 0; o < n.length; o++) {
        var l = n[o][1];
        if (!(i && bt(i, l) >= 0 || a && bt(a, l) < 0)) {
          var u = r.getShallow(l, e);
          u != null && (s[n[o][0]] = u);
        }
      }
      return s;
    };
  }
  var Ble = [
    [
      "fill",
      "color"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "opacity"
    ],
    [
      "shadowColor"
    ]
  ], zle = hd(Ble), Vle = function() {
    function n() {
    }
    return n.prototype.getAreaStyle = function(e, t) {
      return zle(this, e, t);
    }, n;
  }(), FD = new Dx(50);
  function Wle(n) {
    if (typeof n == "string") {
      var e = FD.get(n);
      return e && e.image;
    } else return n;
  }
  function HN(n, e, t, r, i) {
    if (n) if (typeof n == "string") {
      if (e && e.__zrImageSrc === n || !t) return e;
      var a = FD.get(n), s = {
        hostEl: t,
        cb: r,
        cbPayload: i
      };
      return a ? (e = a.image, !vC(e) && a.pending.push(s)) : (e = ec.loadImage(n, yF, yF), e.__zrImageSrc = n, FD.put(n, e.__cachedImgObj = {
        image: e,
        pending: [
          s
        ]
      })), e;
    } else return n;
    else return e;
  }
  function yF() {
    var n = this.__cachedImgObj;
    this.onload = this.onerror = this.__cachedImgObj = null;
    for (var e = 0; e < n.pending.length; e++) {
      var t = n.pending[e], r = t.cb;
      r && r(this, t.cbPayload), t.hostEl.dirty();
    }
    n.pending.length = 0;
  }
  function vC(n) {
    return n && n.width && n.height;
  }
  var K2 = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
  function Gle(n, e, t, r, i, a) {
    if (!t) {
      n.text = "", n.isTruncated = false;
      return;
    }
    var s = (e + "").split(`
`);
    a = h8(t, r, i, a);
    for (var o = false, l = {}, u = 0, c = s.length; u < c; u++) d8(l, s[u], a), s[u] = l.textLine, o = o || l.isTruncated;
    n.text = s.join(`
`), n.isTruncated = o;
  }
  function h8(n, e, t, r) {
    r = r || {};
    var i = oe({}, r);
    i.font = e, t = it(t, "..."), i.maxIterations = it(r.maxIterations, 2);
    var a = i.minChar = it(r.minChar, 0);
    i.cnCharWidth = Wa("\u56FD", e);
    var s = i.ascCharWidth = Wa("a", e);
    i.placeholder = it(r.placeholder, "");
    for (var o = n = Math.max(0, n - 1), l = 0; l < a && o >= s; l++) o -= s;
    var u = Wa(t, e);
    return u > o && (t = "", u = 0), o = n - u, i.ellipsis = t, i.ellipsisWidth = u, i.contentWidth = o, i.containerWidth = n, i;
  }
  function d8(n, e, t) {
    var r = t.containerWidth, i = t.font, a = t.contentWidth;
    if (!r) {
      n.textLine = "", n.isTruncated = false;
      return;
    }
    var s = Wa(e, i);
    if (s <= r) {
      n.textLine = e, n.isTruncated = false;
      return;
    }
    for (var o = 0; ; o++) {
      if (s <= a || o >= t.maxIterations) {
        e += t.ellipsis;
        break;
      }
      var l = o === 0 ? Ule(e, a, t.ascCharWidth, t.cnCharWidth) : s > 0 ? Math.floor(e.length * a / s) : 0;
      e = e.substr(0, l), s = Wa(e, i);
    }
    e === "" && (e = t.placeholder), n.textLine = e, n.isTruncated = true;
  }
  function Ule(n, e, t, r) {
    for (var i = 0, a = 0, s = n.length; a < s && i < e; a++) {
      var o = n.charCodeAt(a);
      i += 0 <= o && o <= 127 ? t : r;
    }
    return a;
  }
  function Hle(n, e) {
    n != null && (n += "");
    var t = e.overflow, r = e.padding, i = e.font, a = t === "truncate", s = pC(i), o = it(e.lineHeight, s), l = !!e.backgroundColor, u = e.lineOverflow === "truncate", c = false, h = e.width, d;
    h != null && (t === "break" || t === "breakAll") ? d = n ? f8(n, e.font, h, t === "breakAll", 0).lines : [] : d = n ? n.split(`
`) : [];
    var f = d.length * o, p = it(e.height, f);
    if (f > p && u) {
      var g = Math.floor(p / o);
      c = c || d.length > g, d = d.slice(0, g);
    }
    if (n && a && h != null) for (var m = h8(h, i, e.ellipsis, {
      minChar: e.truncateMinChar,
      placeholder: e.placeholder
    }), v = {}, y = 0; y < d.length; y++) d8(v, d[y], m), d[y] = v.textLine, c = c || v.isTruncated;
    for (var x = p, b = 0, y = 0; y < d.length; y++) b = Math.max(Wa(d[y], i), b);
    h == null && (h = b);
    var w = b;
    return r && (x += r[0] + r[2], w += r[1] + r[3], h += r[1] + r[3]), l && (w = h), {
      lines: d,
      height: p,
      outerWidth: w,
      outerHeight: x,
      lineHeight: o,
      calculatedLineHeight: s,
      contentWidth: b,
      contentHeight: f,
      width: h,
      isTruncated: c
    };
  }
  var Xle = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), xF = /* @__PURE__ */ function() {
    function n(e) {
      this.tokens = [], e && (this.tokens = e);
    }
    return n;
  }(), Yle = /* @__PURE__ */ function() {
    function n() {
      this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = false;
    }
    return n;
  }();
  function qle(n, e) {
    var t = new Yle();
    if (n != null && (n += ""), !n) return t;
    for (var r = e.width, i = e.height, a = e.overflow, s = (a === "break" || a === "breakAll") && r != null ? {
      width: r,
      accumWidth: 0,
      breakAll: a === "breakAll"
    } : null, o = K2.lastIndex = 0, l; (l = K2.exec(n)) != null; ) {
      var u = l.index;
      u > o && Z2(t, n.substring(o, u), e, s), Z2(t, l[2], e, s, l[1]), o = K2.lastIndex;
    }
    o < n.length && Z2(t, n.substring(o, n.length), e, s);
    var c = [], h = 0, d = 0, f = e.padding, p = a === "truncate", g = e.lineOverflow === "truncate", m = {};
    function v(F, O, z) {
      F.width = O, F.lineHeight = z, h += z, d = Math.max(d, O);
    }
    e: for (var y = 0; y < t.lines.length; y++) {
      for (var x = t.lines[y], b = 0, w = 0, _ = 0; _ < x.tokens.length; _++) {
        var S = x.tokens[_], I = S.styleName && e.rich[S.styleName] || {}, C = S.textPadding = I.padding, T = C ? C[1] + C[3] : 0, k = S.font = I.font || e.font;
        S.contentHeight = pC(k);
        var D = it(I.height, S.contentHeight);
        if (S.innerHeight = D, C && (D += C[0] + C[2]), S.height = D, S.lineHeight = Go(I.lineHeight, e.lineHeight, D), S.align = I && I.align || e.align, S.verticalAlign = I && I.verticalAlign || "middle", g && i != null && h + S.lineHeight > i) {
          var R = t.lines.length;
          _ > 0 ? (x.tokens = x.tokens.slice(0, _), v(x, w, b), t.lines = t.lines.slice(0, y + 1)) : t.lines = t.lines.slice(0, y), t.isTruncated = t.isTruncated || t.lines.length < R;
          break e;
        }
        var N = I.width, E = N == null || N === "auto";
        if (typeof N == "string" && N.charAt(N.length - 1) === "%") S.percentWidth = N, c.push(S), S.contentWidth = Wa(S.text, k);
        else {
          if (E) {
            var A = I.backgroundColor, M = A && A.image;
            M && (M = Wle(M), vC(M) && (S.width = Math.max(S.width, M.width * D / M.height)));
          }
          var $ = p && r != null ? r - w : null;
          $ != null && $ < S.width ? !E || $ < T ? (S.text = "", S.width = S.contentWidth = 0) : (Gle(m, S.text, $ - T, k, e.ellipsis, {
            minChar: e.truncateMinChar
          }), S.text = m.text, t.isTruncated = t.isTruncated || m.isTruncated, S.width = S.contentWidth = Wa(S.text, k)) : S.contentWidth = Wa(S.text, k);
        }
        S.width += T, w += S.width, I && (b = Math.max(b, S.lineHeight));
      }
      v(x, w, b);
    }
    t.outerWidth = t.width = it(r, d), t.outerHeight = t.height = it(i, h), t.contentHeight = h, t.contentWidth = d, f && (t.outerWidth += f[1] + f[3], t.outerHeight += f[0] + f[2]);
    for (var y = 0; y < c.length; y++) {
      var S = c[y], L = S.percentWidth;
      S.width = parseInt(L, 10) / 100 * t.width;
    }
    return t;
  }
  function Z2(n, e, t, r, i) {
    var a = e === "", s = i && t.rich[i] || {}, o = n.lines, l = s.font || t.font, u = false, c, h;
    if (r) {
      var d = s.padding, f = d ? d[1] + d[3] : 0;
      if (s.width != null && s.width !== "auto") {
        var p = no(s.width, r.width) + f;
        o.length > 0 && p + r.accumWidth > r.width && (c = e.split(`
`), u = true), r.accumWidth = p;
      } else {
        var g = f8(e, l, r.width, r.breakAll, r.accumWidth);
        r.accumWidth = g.accumWidth + f, h = g.linesWidths, c = g.lines;
      }
    } else c = e.split(`
`);
    for (var m = 0; m < c.length; m++) {
      var v = c[m], y = new Xle();
      if (y.styleName = i, y.text = v, y.isLineHolder = !v && !a, typeof s.width == "number" ? y.width = s.width : y.width = h ? h[m] : Wa(v, l), !m && !u) {
        var x = (o[o.length - 1] || (o[0] = new xF())).tokens, b = x.length;
        b === 1 && x[0].isLineHolder ? x[0] = y : (v || !b || a) && x.push(y);
      } else o.push(new xF([
        y
      ]));
    }
  }
  function jle(n) {
    var e = n.charCodeAt(0);
    return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303;
  }
  var Kle = Qo(",&?/;] ".split(""), function(n, e) {
    return n[e] = true, n;
  }, {});
  function Zle(n) {
    return jle(n) ? !!Kle[n] : true;
  }
  function f8(n, e, t, r, i) {
    for (var a = [], s = [], o = "", l = "", u = 0, c = 0, h = 0; h < n.length; h++) {
      var d = n.charAt(h);
      if (d === `
`) {
        l && (o += l, c += u), a.push(o), s.push(c), o = "", l = "", u = 0, c = 0;
        continue;
      }
      var f = Wa(d, e), p = r ? false : !Zle(d);
      if (a.length ? c + f > t : i + c + f > t) {
        c ? (o || l) && (p ? (o || (o = l, l = "", u = 0, c = u), a.push(o), s.push(c - u), l += d, u += f, o = "", c = u) : (l && (o += l, l = "", u = 0), a.push(o), s.push(c), o = d, c = f)) : p ? (a.push(l), s.push(u), l = d, u = f) : (a.push(d), s.push(f));
        continue;
      }
      c += f, p ? (l += d, u += f) : (l && (o += l, l = "", u = 0), o += d);
    }
    return !a.length && !o && (o = n, l = "", u = 0), l && (o += l), o && (a.push(o), s.push(c)), a.length === 1 && (c += i), {
      accumWidth: c,
      lines: a,
      linesWidths: s
    };
  }
  var OD = "__zr_style_" + Math.round(Math.random() * 10), Kh = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    opacity: 1,
    blend: "source-over"
  }, yC = {
    style: {
      shadowBlur: true,
      shadowOffsetX: true,
      shadowOffsetY: true,
      shadowColor: true,
      opacity: true
    }
  };
  Kh[OD] = true;
  var bF = [
    "z",
    "z2",
    "invisible"
  ], Qle = [
    "invisible"
  ], _s = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype._init = function(t) {
      for (var r = Mt(t), i = 0; i < r.length; i++) {
        var a = r[i];
        a === "style" ? this.useStyle(t[a]) : n.prototype.attrKV.call(this, a, t[a]);
      }
      this.style || this.useStyle({});
    }, e.prototype.beforeBrush = function() {
    }, e.prototype.afterBrush = function() {
    }, e.prototype.innerBeforeBrush = function() {
    }, e.prototype.innerAfterBrush = function() {
    }, e.prototype.shouldBePainted = function(t, r, i, a) {
      var s = this.transform;
      if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && Jle(this, t, r) || s && !s[0] && !s[3]) return false;
      if (i && this.__clipPaths) {
        for (var o = 0; o < this.__clipPaths.length; ++o) if (this.__clipPaths[o].isZeroArea()) return false;
      }
      if (a && this.parent) for (var l = this.parent; l; ) {
        if (l.ignore) return false;
        l = l.parent;
      }
      return true;
    }, e.prototype.contain = function(t, r) {
      return this.rectContain(t, r);
    }, e.prototype.traverse = function(t, r) {
      t.call(r, this);
    }, e.prototype.rectContain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect();
      return a.contain(i[0], i[1]);
    }, e.prototype.getPaintRect = function() {
      var t = this._paintRect;
      if (!this._paintRect || this.__dirty) {
        var r = this.transform, i = this.getBoundingRect(), a = this.style, s = a.shadowBlur || 0, o = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
        t = this._paintRect || (this._paintRect = new vt(0, 0, 0, 0)), r ? vt.applyTransform(t, i, r) : t.copy(i), (s || o || l) && (t.width += s * 2 + Math.abs(o), t.height += s * 2 + Math.abs(l), t.x = Math.min(t.x, t.x + o - s), t.y = Math.min(t.y, t.y + l - s));
        var u = this.dirtyRectTolerance;
        t.isZero() || (t.x = Math.floor(t.x - u), t.y = Math.floor(t.y - u), t.width = Math.ceil(t.width + 1 + u * 2), t.height = Math.ceil(t.height + 1 + u * 2));
      }
      return t;
    }, e.prototype.setPrevPaintRect = function(t) {
      t ? (this._prevPaintRect = this._prevPaintRect || new vt(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null;
    }, e.prototype.getPrevPaintRect = function() {
      return this._prevPaintRect;
    }, e.prototype.animateStyle = function(t) {
      return this.animate("style", t);
    }, e.prototype.updateDuringAnimation = function(t) {
      t === "style" ? this.dirtyStyle() : this.markRedraw();
    }, e.prototype.attrKV = function(t, r) {
      t !== "style" ? n.prototype.attrKV.call(this, t, r) : this.style ? this.setStyle(r) : this.useStyle(r);
    }, e.prototype.setStyle = function(t, r) {
      return typeof t == "string" ? this.style[t] = r : oe(this.style, t), this.dirtyStyle(), this;
    }, e.prototype.dirtyStyle = function(t) {
      t || this.markRedraw(), this.__dirty |= Zw, this._rect && (this._rect = null);
    }, e.prototype.dirty = function() {
      this.dirtyStyle();
    }, e.prototype.styleChanged = function() {
      return !!(this.__dirty & Zw);
    }, e.prototype.styleUpdated = function() {
      this.__dirty &= -3;
    }, e.prototype.createStyle = function(t) {
      return hC(Kh, t);
    }, e.prototype.useStyle = function(t) {
      t[OD] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle();
    }, e.prototype.isStyleObject = function(t) {
      return t[OD];
    }, e.prototype._innerSaveToNormal = function(t) {
      n.prototype._innerSaveToNormal.call(this, t);
      var r = this._normalState;
      t.style && !r.style && (r.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(t, r, bF);
    }, e.prototype._applyStateObj = function(t, r, i, a, s, o) {
      n.prototype._applyStateObj.call(this, t, r, i, a, s, o);
      var l = !(r && a), u;
      if (r && r.style ? s ? a ? u = r.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, r.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(u, r.style)) : l && (u = i.style), u) if (s) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l) for (var h = Mt(c), d = 0; d < h.length; d++) {
          var f = h[d];
          f in u && (u[f] = u[f], this.style[f] = c[f]);
        }
        for (var p = Mt(u), d = 0; d < p.length; d++) {
          var f = p[d];
          this.style[f] = this.style[f];
        }
        this._transitionState(t, {
          style: u
        }, o, this.getAnimationStyleProps());
      } else this.useStyle(u);
      for (var g = this.__inHover ? Qle : bF, d = 0; d < g.length; d++) {
        var f = g[d];
        r && r[f] != null ? this[f] = r[f] : l && i[f] != null && (this[f] = i[f]);
      }
    }, e.prototype._mergeStates = function(t) {
      for (var r = n.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) {
        var s = t[a];
        s.style && (i = i || {}, this._mergeStyle(i, s.style));
      }
      return i && (r.style = i), r;
    }, e.prototype._mergeStyle = function(t, r) {
      return oe(t, r), t;
    }, e.prototype.getAnimationStyleProps = function() {
      return yC;
    }, e.initDefaultProps = function() {
      var t = e.prototype;
      t.type = "displayable", t.invisible = false, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = false, t.cursor = "pointer", t.rectHover = false, t.incremental = false, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = Uo | Zw;
    }(), e;
  }(gC), Q2 = new vt(0, 0, 0, 0), J2 = new vt(0, 0, 0, 0);
  function Jle(n, e, t) {
    return Q2.copy(n.getBoundingRect()), n.transform && Q2.applyTransform(n.transform), J2.width = e, J2.height = t, !Q2.intersect(J2);
  }
  var va = Math.min, ya = Math.max, ek = Math.sin, tk = Math.cos, Xc = Math.PI * 2, w1 = Ed(), _1 = Ed(), S1 = Ed();
  function xC(n, e, t) {
    if (n.length !== 0) {
      for (var r = n[0], i = r[0], a = r[0], s = r[1], o = r[1], l = 1; l < n.length; l++) r = n[l], i = va(i, r[0]), a = ya(a, r[0]), s = va(s, r[1]), o = ya(o, r[1]);
      e[0] = i, e[1] = s, t[0] = a, t[1] = o;
    }
  }
  function wF(n, e, t, r, i, a) {
    i[0] = va(n, t), i[1] = va(e, r), a[0] = ya(n, t), a[1] = ya(e, r);
  }
  var _F = [], SF = [];
  function eue(n, e, t, r, i, a, s, o, l, u) {
    var c = N6, h = Fr, d = c(n, t, i, s, _F);
    l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
    for (var f = 0; f < d; f++) {
      var p = h(n, t, i, s, _F[f]);
      l[0] = va(p, l[0]), u[0] = ya(p, u[0]);
    }
    d = c(e, r, a, o, SF);
    for (var f = 0; f < d; f++) {
      var g = h(e, r, a, o, SF[f]);
      l[1] = va(g, l[1]), u[1] = ya(g, u[1]);
    }
    l[0] = va(n, l[0]), u[0] = ya(n, u[0]), l[0] = va(s, l[0]), u[0] = ya(s, u[0]), l[1] = va(e, l[1]), u[1] = ya(e, u[1]), l[1] = va(o, l[1]), u[1] = ya(o, u[1]);
  }
  function tue(n, e, t, r, i, a, s, o) {
    var l = M6, u = Jr, c = ya(va(l(n, t, i), 1), 0), h = ya(va(l(e, r, a), 1), 0), d = u(n, t, i, c), f = u(e, r, a, h);
    s[0] = va(n, i, d), s[1] = va(e, a, f), o[0] = ya(n, i, d), o[1] = ya(e, a, f);
  }
  function nue(n, e, t, r, i, a, s, o, l) {
    var u = Eu, c = Mu, h = Math.abs(i - a);
    if (h % Xc < 1e-4 && h > 1e-4) {
      o[0] = n - t, o[1] = e - r, l[0] = n + t, l[1] = e + r;
      return;
    }
    if (w1[0] = tk(i) * t + n, w1[1] = ek(i) * r + e, _1[0] = tk(a) * t + n, _1[1] = ek(a) * r + e, u(o, w1, _1), c(l, w1, _1), i = i % Xc, i < 0 && (i = i + Xc), a = a % Xc, a < 0 && (a = a + Xc), i > a && !s ? a += Xc : i < a && s && (i += Xc), s) {
      var d = a;
      a = i, i = d;
    }
    for (var f = 0; f < a; f += Math.PI / 2) f > i && (S1[0] = tk(f) * t + n, S1[1] = ek(f) * r + e, u(o, S1, o), c(l, S1, l));
  }
  var Cn = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  }, Yc = [], qc = [], xo = [], pu = [], bo = [], wo = [], nk = Math.min, rk = Math.max, jc = Math.cos, Kc = Math.sin, vl = Math.abs, BD = Math.PI, Iu = BD * 2, ik = typeof Float32Array < "u", jv = [];
  function ak(n) {
    var e = Math.round(n / BD * 1e8) / 1e8;
    return e % 2 * BD;
  }
  function XN(n, e) {
    var t = ak(n[0]);
    t < 0 && (t += Iu);
    var r = t - n[0], i = n[1];
    i += r, !e && i - t >= Iu ? i = t + Iu : e && t - i >= Iu ? i = t - Iu : !e && t > i ? i = t + (Iu - ak(t - i)) : e && t < i && (i = t - (Iu - ak(i - t))), n[0] = t, n[1] = i;
  }
  var nl = function() {
    function n(e) {
      this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = false), this._saveData && (this.data = []);
    }
    return n.prototype.increaseVersion = function() {
      this._version++;
    }, n.prototype.getVersion = function() {
      return this._version;
    }, n.prototype.setScale = function(e, t, r) {
      r = r || 0, r > 0 && (this._ux = vl(r / L_ / e) || 0, this._uy = vl(r / L_ / t) || 0);
    }, n.prototype.setDPR = function(e) {
      this.dpr = e;
    }, n.prototype.setContext = function(e) {
      this._ctx = e;
    }, n.prototype.getContext = function() {
      return this._ctx;
    }, n.prototype.beginPath = function() {
      return this._ctx && this._ctx.beginPath(), this.reset(), this;
    }, n.prototype.reset = function() {
      this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
    }, n.prototype.moveTo = function(e, t) {
      return this._drawPendingPt(), this.addData(Cn.M, e, t), this._ctx && this._ctx.moveTo(e, t), this._x0 = e, this._y0 = t, this._xi = e, this._yi = t, this;
    }, n.prototype.lineTo = function(e, t) {
      var r = vl(e - this._xi), i = vl(t - this._yi), a = r > this._ux || i > this._uy;
      if (this.addData(Cn.L, e, t), this._ctx && a && this._ctx.lineTo(e, t), a) this._xi = e, this._yi = t, this._pendingPtDist = 0;
      else {
        var s = r * r + i * i;
        s > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = t, this._pendingPtDist = s);
      }
      return this;
    }, n.prototype.bezierCurveTo = function(e, t, r, i, a, s) {
      return this._drawPendingPt(), this.addData(Cn.C, e, t, r, i, a, s), this._ctx && this._ctx.bezierCurveTo(e, t, r, i, a, s), this._xi = a, this._yi = s, this;
    }, n.prototype.quadraticCurveTo = function(e, t, r, i) {
      return this._drawPendingPt(), this.addData(Cn.Q, e, t, r, i), this._ctx && this._ctx.quadraticCurveTo(e, t, r, i), this._xi = r, this._yi = i, this;
    }, n.prototype.arc = function(e, t, r, i, a, s) {
      this._drawPendingPt(), jv[0] = i, jv[1] = a, XN(jv, s), i = jv[0], a = jv[1];
      var o = a - i;
      return this.addData(Cn.A, e, t, r, r, i, o, 0, s ? 0 : 1), this._ctx && this._ctx.arc(e, t, r, i, a, s), this._xi = jc(a) * r + e, this._yi = Kc(a) * r + t, this;
    }, n.prototype.arcTo = function(e, t, r, i, a) {
      return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, t, r, i, a), this;
    }, n.prototype.rect = function(e, t, r, i) {
      return this._drawPendingPt(), this._ctx && this._ctx.rect(e, t, r, i), this.addData(Cn.R, e, t, r, i), this;
    }, n.prototype.closePath = function() {
      this._drawPendingPt(), this.addData(Cn.Z);
      var e = this._ctx, t = this._x0, r = this._y0;
      return e && e.closePath(), this._xi = t, this._yi = r, this;
    }, n.prototype.fill = function(e) {
      e && e.fill(), this.toStatic();
    }, n.prototype.stroke = function(e) {
      e && e.stroke(), this.toStatic();
    }, n.prototype.len = function() {
      return this._len;
    }, n.prototype.setData = function(e) {
      var t = e.length;
      !(this.data && this.data.length === t) && ik && (this.data = new Float32Array(t));
      for (var r = 0; r < t; r++) this.data[r] = e[r];
      this._len = t;
    }, n.prototype.appendPath = function(e) {
      e instanceof Array || (e = [
        e
      ]);
      for (var t = e.length, r = 0, i = this._len, a = 0; a < t; a++) r += e[a].len();
      ik && this.data instanceof Float32Array && (this.data = new Float32Array(i + r));
      for (var a = 0; a < t; a++) for (var s = e[a].data, o = 0; o < s.length; o++) this.data[i++] = s[o];
      this._len = i;
    }, n.prototype.addData = function(e, t, r, i, a, s, o, l, u) {
      if (this._saveData) {
        var c = this.data;
        this._len + arguments.length > c.length && (this._expandData(), c = this.data);
        for (var h = 0; h < arguments.length; h++) c[this._len++] = arguments[h];
      }
    }, n.prototype._drawPendingPt = function() {
      this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
    }, n.prototype._expandData = function() {
      if (!(this.data instanceof Array)) {
        for (var e = [], t = 0; t < this._len; t++) e[t] = this.data[t];
        this.data = e;
      }
    }, n.prototype.toStatic = function() {
      if (this._saveData) {
        this._drawPendingPt();
        var e = this.data;
        e instanceof Array && (e.length = this._len, ik && this._len > 11 && (this.data = new Float32Array(e)));
      }
    }, n.prototype.getBoundingRect = function() {
      xo[0] = xo[1] = bo[0] = bo[1] = Number.MAX_VALUE, pu[0] = pu[1] = wo[0] = wo[1] = -Number.MAX_VALUE;
      var e = this.data, t = 0, r = 0, i = 0, a = 0, s;
      for (s = 0; s < this._len; ) {
        var o = e[s++], l = s === 1;
        switch (l && (t = e[s], r = e[s + 1], i = t, a = r), o) {
          case Cn.M:
            t = i = e[s++], r = a = e[s++], bo[0] = i, bo[1] = a, wo[0] = i, wo[1] = a;
            break;
          case Cn.L:
            wF(t, r, e[s], e[s + 1], bo, wo), t = e[s++], r = e[s++];
            break;
          case Cn.C:
            eue(t, r, e[s++], e[s++], e[s++], e[s++], e[s], e[s + 1], bo, wo), t = e[s++], r = e[s++];
            break;
          case Cn.Q:
            tue(t, r, e[s++], e[s++], e[s], e[s + 1], bo, wo), t = e[s++], r = e[s++];
            break;
          case Cn.A:
            var u = e[s++], c = e[s++], h = e[s++], d = e[s++], f = e[s++], p = e[s++] + f;
            s += 1;
            var g = !e[s++];
            l && (i = jc(f) * h + u, a = Kc(f) * d + c), nue(u, c, h, d, f, p, g, bo, wo), t = jc(p) * h + u, r = Kc(p) * d + c;
            break;
          case Cn.R:
            i = t = e[s++], a = r = e[s++];
            var m = e[s++], v = e[s++];
            wF(i, a, i + m, a + v, bo, wo);
            break;
          case Cn.Z:
            t = i, r = a;
            break;
        }
        Eu(xo, xo, bo), Mu(pu, pu, wo);
      }
      return s === 0 && (xo[0] = xo[1] = pu[0] = pu[1] = 0), new vt(xo[0], xo[1], pu[0] - xo[0], pu[1] - xo[1]);
    }, n.prototype._calculateLength = function() {
      var e = this.data, t = this._len, r = this._ux, i = this._uy, a = 0, s = 0, o = 0, l = 0;
      this._pathSegLen || (this._pathSegLen = []);
      for (var u = this._pathSegLen, c = 0, h = 0, d = 0; d < t; ) {
        var f = e[d++], p = d === 1;
        p && (a = e[d], s = e[d + 1], o = a, l = s);
        var g = -1;
        switch (f) {
          case Cn.M:
            a = o = e[d++], s = l = e[d++];
            break;
          case Cn.L: {
            var m = e[d++], v = e[d++], y = m - a, x = v - s;
            (vl(y) > r || vl(x) > i || d === t - 1) && (g = Math.sqrt(y * y + x * x), a = m, s = v);
            break;
          }
          case Cn.C: {
            var b = e[d++], w = e[d++], m = e[d++], v = e[d++], _ = e[d++], S = e[d++];
            g = xoe(a, s, b, w, m, v, _, S, 10), a = _, s = S;
            break;
          }
          case Cn.Q: {
            var b = e[d++], w = e[d++], m = e[d++], v = e[d++];
            g = woe(a, s, b, w, m, v, 10), a = m, s = v;
            break;
          }
          case Cn.A:
            var I = e[d++], C = e[d++], T = e[d++], k = e[d++], D = e[d++], R = e[d++], N = R + D;
            d += 1, p && (o = jc(D) * T + I, l = Kc(D) * k + C), g = rk(T, k) * nk(Iu, Math.abs(R)), a = jc(N) * T + I, s = Kc(N) * k + C;
            break;
          case Cn.R: {
            o = a = e[d++], l = s = e[d++];
            var E = e[d++], A = e[d++];
            g = E * 2 + A * 2;
            break;
          }
          case Cn.Z: {
            var y = o - a, x = l - s;
            g = Math.sqrt(y * y + x * x), a = o, s = l;
            break;
          }
        }
        g >= 0 && (u[h++] = g, c += g);
      }
      return this._pathLen = c, c;
    }, n.prototype.rebuildPath = function(e, t) {
      var r = this.data, i = this._ux, a = this._uy, s = this._len, o, l, u, c, h, d, f = t < 1, p, g, m = 0, v = 0, y, x = 0, b, w;
      if (!(f && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, y = t * g, !y))) e: for (var _ = 0; _ < s; ) {
        var S = r[_++], I = _ === 1;
        switch (I && (u = r[_], c = r[_ + 1], o = u, l = c), S !== Cn.L && x > 0 && (e.lineTo(b, w), x = 0), S) {
          case Cn.M:
            o = u = r[_++], l = c = r[_++], e.moveTo(u, c);
            break;
          case Cn.L: {
            h = r[_++], d = r[_++];
            var C = vl(h - u), T = vl(d - c);
            if (C > i || T > a) {
              if (f) {
                var k = p[v++];
                if (m + k > y) {
                  var D = (y - m) / k;
                  e.lineTo(u * (1 - D) + h * D, c * (1 - D) + d * D);
                  break e;
                }
                m += k;
              }
              e.lineTo(h, d), u = h, c = d, x = 0;
            } else {
              var R = C * C + T * T;
              R > x && (b = h, w = d, x = R);
            }
            break;
          }
          case Cn.C: {
            var N = r[_++], E = r[_++], A = r[_++], M = r[_++], $ = r[_++], L = r[_++];
            if (f) {
              var k = p[v++];
              if (m + k > y) {
                var D = (y - m) / k;
                tc(u, N, A, $, D, Yc), tc(c, E, M, L, D, qc), e.bezierCurveTo(Yc[1], qc[1], Yc[2], qc[2], Yc[3], qc[3]);
                break e;
              }
              m += k;
            }
            e.bezierCurveTo(N, E, A, M, $, L), u = $, c = L;
            break;
          }
          case Cn.Q: {
            var N = r[_++], E = r[_++], A = r[_++], M = r[_++];
            if (f) {
              var k = p[v++];
              if (m + k > y) {
                var D = (y - m) / k;
                k0(u, N, A, D, Yc), k0(c, E, M, D, qc), e.quadraticCurveTo(Yc[1], qc[1], Yc[2], qc[2]);
                break e;
              }
              m += k;
            }
            e.quadraticCurveTo(N, E, A, M), u = A, c = M;
            break;
          }
          case Cn.A:
            var F = r[_++], O = r[_++], z = r[_++], V = r[_++], H = r[_++], Y = r[_++], le = r[_++], ve = !r[_++], re = z > V ? z : V, ae = vl(z - V) > 1e-3, fe = H + Y, ce = false;
            if (f) {
              var k = p[v++];
              m + k > y && (fe = H + Y * (y - m) / k, ce = true), m += k;
            }
            if (ae && e.ellipse ? e.ellipse(F, O, z, V, le, H, fe, ve) : e.arc(F, O, re, H, fe, ve), ce) break e;
            I && (o = jc(H) * z + F, l = Kc(H) * V + O), u = jc(fe) * z + F, c = Kc(fe) * V + O;
            break;
          case Cn.R:
            o = u = r[_], l = c = r[_ + 1], h = r[_++], d = r[_++];
            var ye = r[_++], Le = r[_++];
            if (f) {
              var k = p[v++];
              if (m + k > y) {
                var Re = y - m;
                e.moveTo(h, d), e.lineTo(h + nk(Re, ye), d), Re -= ye, Re > 0 && e.lineTo(h + ye, d + nk(Re, Le)), Re -= Le, Re > 0 && e.lineTo(h + rk(ye - Re, 0), d + Le), Re -= ye, Re > 0 && e.lineTo(h, d + rk(Le - Re, 0));
                break e;
              }
              m += k;
            }
            e.rect(h, d, ye, Le);
            break;
          case Cn.Z:
            if (f) {
              var k = p[v++];
              if (m + k > y) {
                var D = (y - m) / k;
                e.lineTo(u * (1 - D) + o * D, c * (1 - D) + l * D);
                break e;
              }
              m += k;
            }
            e.closePath(), u = o, c = l;
        }
      }
    }, n.prototype.clone = function() {
      var e = new n(), t = this.data;
      return e.data = t.slice ? t.slice() : Array.prototype.slice.call(t), e._len = this._len, e;
    }, n.CMD = Cn, n.initDefaultProps = function() {
      var e = n.prototype;
      e._saveData = true, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
    }(), n;
  }();
  function Au(n, e, t, r, i, a, s) {
    if (i === 0) return false;
    var o = i, l = 0, u = n;
    if (s > e + o && s > r + o || s < e - o && s < r - o || a > n + o && a > t + o || a < n - o && a < t - o) return false;
    if (n !== t) l = (e - r) / (n - t), u = (n * r - t * e) / (n - t);
    else return Math.abs(a - n) <= o / 2;
    var c = l * a - s + u, h = c * c / (l * l + 1);
    return h <= o / 2 * o / 2;
  }
  function rue(n, e, t, r, i, a, s, o, l, u, c) {
    if (l === 0) return false;
    var h = l;
    if (c > e + h && c > r + h && c > a + h && c > o + h || c < e - h && c < r - h && c < a - h && c < o - h || u > n + h && u > t + h && u > i + h && u > s + h || u < n - h && u < t - h && u < i - h && u < s - h) return false;
    var d = E6(n, e, t, r, i, a, s, o, u, c, null);
    return d <= h / 2;
  }
  function p8(n, e, t, r, i, a, s, o, l) {
    if (s === 0) return false;
    var u = s;
    if (l > e + u && l > r + u && l > a + u || l < e - u && l < r - u && l < a - u || o > n + u && o > t + u && o > i + u || o < n - u && o < t - u && o < i - u) return false;
    var c = P6(n, e, t, r, i, a, o, l, null);
    return c <= u / 2;
  }
  var CF = Math.PI * 2;
  function Oa(n) {
    return n %= CF, n < 0 && (n += CF), n;
  }
  var Kv = Math.PI * 2;
  function iue(n, e, t, r, i, a, s, o, l) {
    if (s === 0) return false;
    var u = s;
    o -= n, l -= e;
    var c = Math.sqrt(o * o + l * l);
    if (c - u > t || c + u < t) return false;
    if (Math.abs(r - i) % Kv < 1e-4) return true;
    if (a) {
      var h = r;
      r = Oa(i), i = Oa(h);
    } else r = Oa(r), i = Oa(i);
    r > i && (i += Kv);
    var d = Math.atan2(l, o);
    return d < 0 && (d += Kv), d >= r && d <= i || d + Kv >= r && d + Kv <= i;
  }
  function Cl(n, e, t, r, i, a) {
    if (a > e && a > r || a < e && a < r || r === e) return 0;
    var s = (a - e) / (r - e), o = r < e ? 1 : -1;
    (s === 1 || s === 0) && (o = r < e ? 0.5 : -0.5);
    var l = s * (t - n) + n;
    return l === i ? 1 / 0 : l > i ? o : 0;
  }
  var gu = nl.CMD, Zc = Math.PI * 2, aue = 1e-4;
  function sue(n, e) {
    return Math.abs(n - e) < aue;
  }
  var Gi = [
    -1,
    -1,
    -1
  ], us = [
    -1,
    -1
  ];
  function oue() {
    var n = us[0];
    us[0] = us[1], us[1] = n;
  }
  function lue(n, e, t, r, i, a, s, o, l, u) {
    if (u > e && u > r && u > a && u > o || u < e && u < r && u < a && u < o) return 0;
    var c = N_(e, r, a, o, u, Gi);
    if (c === 0) return 0;
    for (var h = 0, d = -1, f = void 0, p = void 0, g = 0; g < c; g++) {
      var m = Gi[g], v = m === 0 || m === 1 ? 0.5 : 1, y = Fr(n, t, i, s, m);
      y < l || (d < 0 && (d = N6(e, r, a, o, us), us[1] < us[0] && d > 1 && oue(), f = Fr(e, r, a, o, us[0]), d > 1 && (p = Fr(e, r, a, o, us[1]))), d === 2 ? m < us[0] ? h += f < e ? v : -v : m < us[1] ? h += p < f ? v : -v : h += o < p ? v : -v : m < us[0] ? h += f < e ? v : -v : h += o < f ? v : -v);
    }
    return h;
  }
  function uue(n, e, t, r, i, a, s, o) {
    if (o > e && o > r && o > a || o < e && o < r && o < a) return 0;
    var l = boe(e, r, a, o, Gi);
    if (l === 0) return 0;
    var u = M6(e, r, a);
    if (u >= 0 && u <= 1) {
      for (var c = 0, h = Jr(e, r, a, u), d = 0; d < l; d++) {
        var f = Gi[d] === 0 || Gi[d] === 1 ? 0.5 : 1, p = Jr(n, t, i, Gi[d]);
        p < s || (Gi[d] < u ? c += h < e ? f : -f : c += a < h ? f : -f);
      }
      return c;
    } else {
      var f = Gi[0] === 0 || Gi[0] === 1 ? 0.5 : 1, p = Jr(n, t, i, Gi[0]);
      return p < s ? 0 : a < e ? f : -f;
    }
  }
  function cue(n, e, t, r, i, a, s, o) {
    if (o -= e, o > t || o < -t) return 0;
    var l = Math.sqrt(t * t - o * o);
    Gi[0] = -l, Gi[1] = l;
    var u = Math.abs(r - i);
    if (u < 1e-4) return 0;
    if (u >= Zc - 1e-4) {
      r = 0, i = Zc;
      var c = a ? 1 : -1;
      return s >= Gi[0] + n && s <= Gi[1] + n ? c : 0;
    }
    if (r > i) {
      var h = r;
      r = i, i = h;
    }
    r < 0 && (r += Zc, i += Zc);
    for (var d = 0, f = 0; f < 2; f++) {
      var p = Gi[f];
      if (p + n > s) {
        var g = Math.atan2(o, p), c = a ? 1 : -1;
        g < 0 && (g = Zc + g), (g >= r && g <= i || g + Zc >= r && g + Zc <= i) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), d += c);
      }
    }
    return d;
  }
  function g8(n, e, t, r, i) {
    for (var a = n.data, s = n.len(), o = 0, l = 0, u = 0, c = 0, h = 0, d, f, p = 0; p < s; ) {
      var g = a[p++], m = p === 1;
      switch (g === gu.M && p > 1 && (t || (o += Cl(l, u, c, h, r, i))), m && (l = a[p], u = a[p + 1], c = l, h = u), g) {
        case gu.M:
          c = a[p++], h = a[p++], l = c, u = h;
          break;
        case gu.L:
          if (t) {
            if (Au(l, u, a[p], a[p + 1], e, r, i)) return true;
          } else o += Cl(l, u, a[p], a[p + 1], r, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case gu.C:
          if (t) {
            if (rue(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], e, r, i)) return true;
          } else o += lue(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], r, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case gu.Q:
          if (t) {
            if (p8(l, u, a[p++], a[p++], a[p], a[p + 1], e, r, i)) return true;
          } else o += uue(l, u, a[p++], a[p++], a[p], a[p + 1], r, i) || 0;
          l = a[p++], u = a[p++];
          break;
        case gu.A:
          var v = a[p++], y = a[p++], x = a[p++], b = a[p++], w = a[p++], _ = a[p++];
          p += 1;
          var S = !!(1 - a[p++]);
          d = Math.cos(w) * x + v, f = Math.sin(w) * b + y, m ? (c = d, h = f) : o += Cl(l, u, d, f, r, i);
          var I = (r - v) * b / x + v;
          if (t) {
            if (iue(v, y, b, w, w + _, S, e, I, i)) return true;
          } else o += cue(v, y, b, w, w + _, S, I, i);
          l = Math.cos(w + _) * x + v, u = Math.sin(w + _) * b + y;
          break;
        case gu.R:
          c = l = a[p++], h = u = a[p++];
          var C = a[p++], T = a[p++];
          if (d = c + C, f = h + T, t) {
            if (Au(c, h, d, h, e, r, i) || Au(d, h, d, f, e, r, i) || Au(d, f, c, f, e, r, i) || Au(c, f, c, h, e, r, i)) return true;
          } else o += Cl(d, h, d, f, r, i), o += Cl(c, f, c, h, r, i);
          break;
        case gu.Z:
          if (t) {
            if (Au(l, u, c, h, e, r, i)) return true;
          } else o += Cl(l, u, c, h, r, i);
          l = c, u = h;
          break;
      }
    }
    return !t && !sue(u, h) && (o += Cl(l, u, c, h, r, i) || 0), o !== 0;
  }
  function hue(n, e, t) {
    return g8(n, 0, false, e, t);
  }
  function due(n, e, t, r) {
    return g8(n, e, true, t, r);
  }
  var O_ = je({
    fill: "#000",
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
  }, Kh), fue = {
    style: je({
      fill: true,
      stroke: true,
      strokePercent: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineDashOffset: true,
      lineWidth: true,
      miterLimit: true
    }, yC.style)
  }, sk = el.concat([
    "invisible",
    "culling",
    "z",
    "z2",
    "zlevel",
    "parent"
  ]), At = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.update = function() {
      var t = this;
      n.prototype.update.call(this);
      var r = this.style;
      if (r.decal) {
        var i = this._decalEl = this._decalEl || new e();
        i.buildPath === e.prototype.buildPath && (i.buildPath = function(l) {
          t.buildPath(l, t.shape);
        }), i.silent = true;
        var a = i.style;
        for (var s in r) a[s] !== r[s] && (a[s] = r[s]);
        a.fill = r.fill ? r.decal : null, a.decal = null, a.shadowColor = null, r.strokeFirst && (a.stroke = null);
        for (var o = 0; o < sk.length; ++o) i[sk[o]] = this[sk[o]];
        i.__dirty |= Uo;
      } else this._decalEl && (this._decalEl = null);
    }, e.prototype.getDecalElement = function() {
      return this._decalEl;
    }, e.prototype._init = function(t) {
      var r = Mt(t);
      this.shape = this.getDefaultShape();
      var i = this.getDefaultStyle();
      i && this.useStyle(i);
      for (var a = 0; a < r.length; a++) {
        var s = r[a], o = t[s];
        s === "style" ? this.style ? oe(this.style, o) : this.useStyle(o) : s === "shape" ? oe(this.shape, o) : n.prototype.attrKV.call(this, s, o);
      }
      this.style || this.useStyle({});
    }, e.prototype.getDefaultStyle = function() {
      return null;
    }, e.prototype.getDefaultShape = function() {
      return {};
    }, e.prototype.canBeInsideText = function() {
      return this.hasFill();
    }, e.prototype.getInsideTextFill = function() {
      var t = this.style.fill;
      if (t !== "none") {
        if (Ie(t)) {
          var r = M_(t, 0);
          return r > 0.5 ? ED : r > 0.2 ? joe : MD;
        } else if (t) return MD;
      }
      return ED;
    }, e.prototype.getInsideTextStroke = function(t) {
      var r = this.style.fill;
      if (Ie(r)) {
        var i = this.__zr, a = !!(i && i.isDarkMode()), s = M_(t, 0) < ND;
        if (a === s) return r;
      }
    }, e.prototype.buildPath = function(t, r, i) {
    }, e.prototype.pathUpdated = function() {
      this.__dirty &= -5;
    }, e.prototype.getUpdatedPathProxy = function(t) {
      return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path;
    }, e.prototype.createPathProxy = function() {
      this.path = new nl(false);
    }, e.prototype.hasStroke = function() {
      var t = this.style, r = t.stroke;
      return !(r == null || r === "none" || !(t.lineWidth > 0));
    }, e.prototype.hasFill = function() {
      var t = this.style, r = t.fill;
      return r != null && r !== "none";
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect, r = this.style, i = !t;
      if (i) {
        var a = false;
        this.path || (a = true, this.createPathProxy());
        var s = this.path;
        (a || this.__dirty & Dy) && (s.beginPath(), this.buildPath(s, this.shape, false), this.pathUpdated()), t = s.getBoundingRect();
      }
      if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) {
        var o = this._rectStroke || (this._rectStroke = t.clone());
        if (this.__dirty || i) {
          o.copy(t);
          var l = r.strokeNoScale ? this.getLineScale() : 1, u = r.lineWidth;
          if (!this.hasFill()) {
            var c = this.strokeContainThreshold;
            u = Math.max(u, c ?? 4);
          }
          l > 1e-10 && (o.width += u / l, o.height += u / l, o.x -= u / l / 2, o.y -= u / l / 2);
        }
        return o;
      }
      return t;
    }, e.prototype.contain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect(), s = this.style;
      if (t = i[0], r = i[1], a.contain(t, r)) {
        var o = this.path;
        if (this.hasStroke()) {
          var l = s.lineWidth, u = s.strokeNoScale ? this.getLineScale() : 1;
          if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), due(o, l / u, t, r))) return true;
        }
        if (this.hasFill()) return hue(o, t, r);
      }
      return false;
    }, e.prototype.dirtyShape = function() {
      this.__dirty |= Dy, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
    }, e.prototype.dirty = function() {
      this.dirtyStyle(), this.dirtyShape();
    }, e.prototype.animateShape = function(t) {
      return this.animate("shape", t);
    }, e.prototype.updateDuringAnimation = function(t) {
      t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw();
    }, e.prototype.attrKV = function(t, r) {
      t === "shape" ? this.setShape(r) : n.prototype.attrKV.call(this, t, r);
    }, e.prototype.setShape = function(t, r) {
      var i = this.shape;
      return i || (i = this.shape = {}), typeof t == "string" ? i[t] = r : oe(i, t), this.dirtyShape(), this;
    }, e.prototype.shapeChanged = function() {
      return !!(this.__dirty & Dy);
    }, e.prototype.createStyle = function(t) {
      return hC(O_, t);
    }, e.prototype._innerSaveToNormal = function(t) {
      n.prototype._innerSaveToNormal.call(this, t);
      var r = this._normalState;
      t.shape && !r.shape && (r.shape = oe({}, this.shape));
    }, e.prototype._applyStateObj = function(t, r, i, a, s, o) {
      n.prototype._applyStateObj.call(this, t, r, i, a, s, o);
      var l = !(r && a), u;
      if (r && r.shape ? s ? a ? u = r.shape : (u = oe({}, i.shape), oe(u, r.shape)) : (u = oe({}, a ? this.shape : i.shape), oe(u, r.shape)) : l && (u = i.shape), u) if (s) {
        this.shape = oe({}, this.shape);
        for (var c = {}, h = Mt(u), d = 0; d < h.length; d++) {
          var f = h[d];
          typeof u[f] == "object" ? this.shape[f] = u[f] : c[f] = u[f];
        }
        this._transitionState(t, {
          shape: c
        }, o);
      } else this.shape = u, this.dirtyShape();
    }, e.prototype._mergeStates = function(t) {
      for (var r = n.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) {
        var s = t[a];
        s.shape && (i = i || {}, this._mergeStyle(i, s.shape));
      }
      return i && (r.shape = i), r;
    }, e.prototype.getAnimationStyleProps = function() {
      return fue;
    }, e.prototype.isZeroArea = function() {
      return false;
    }, e.extend = function(t) {
      var r = function(a) {
        K(s, a);
        function s(o) {
          var l = a.call(this, o) || this;
          return t.init && t.init.call(l, o), l;
        }
        return s.prototype.getDefaultStyle = function() {
          return Qe(t.style);
        }, s.prototype.getDefaultShape = function() {
          return Qe(t.shape);
        }, s;
      }(e);
      for (var i in t) typeof t[i] == "function" && (r.prototype[i] = t[i]);
      return r;
    }, e.initDefaultProps = function() {
      var t = e.prototype;
      t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = false, t.autoBatch = false, t.__dirty = Uo | Zw | Dy;
    }(), e;
  }(_s), pue = je({
    strokeFirst: true,
    font: Ju,
    x: 0,
    y: 0,
    textAlign: "left",
    textBaseline: "top",
    miterLimit: 2
  }, O_), Eg = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.hasStroke = function() {
      var t = this.style, r = t.stroke;
      return r != null && r !== "none" && t.lineWidth > 0;
    }, e.prototype.hasFill = function() {
      var t = this.style, r = t.fill;
      return r != null && r !== "none";
    }, e.prototype.createStyle = function(t) {
      return hC(pue, t);
    }, e.prototype.setBoundingRect = function(t) {
      this._rect = t;
    }, e.prototype.getBoundingRect = function() {
      var t = this.style;
      if (!this._rect) {
        var r = t.text;
        r != null ? r += "" : r = "";
        var i = Rx(r, t.font, t.textAlign, t.textBaseline);
        if (i.x += t.x || 0, i.y += t.y || 0, this.hasStroke()) {
          var a = t.lineWidth;
          i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a;
        }
        this._rect = i;
      }
      return this._rect;
    }, e.initDefaultProps = function() {
      var t = e.prototype;
      t.dirtyRectTolerance = 10;
    }(), e;
  }(_s);
  Eg.prototype.type = "tspan";
  var gue = je({
    x: 0,
    y: 0
  }, Kh), mue = {
    style: je({
      x: true,
      y: true,
      width: true,
      height: true,
      sx: true,
      sy: true,
      sWidth: true,
      sHeight: true
    }, yC.style)
  };
  function vue(n) {
    return !!(n && typeof n != "string" && n.width && n.height);
  }
  var oi = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.createStyle = function(t) {
      return hC(gue, t);
    }, e.prototype._getSize = function(t) {
      var r = this.style, i = r[t];
      if (i != null) return i;
      var a = vue(r.image) ? r.image : this.__image;
      if (!a) return 0;
      var s = t === "width" ? "height" : "width", o = r[s];
      return o == null ? a[t] : a[t] / a[s] * o;
    }, e.prototype.getWidth = function() {
      return this._getSize("width");
    }, e.prototype.getHeight = function() {
      return this._getSize("height");
    }, e.prototype.getAnimationStyleProps = function() {
      return mue;
    }, e.prototype.getBoundingRect = function() {
      var t = this.style;
      return this._rect || (this._rect = new vt(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect;
    }, e;
  }(_s);
  oi.prototype.type = "image";
  function yue(n, e) {
    var t = e.x, r = e.y, i = e.width, a = e.height, s = e.r, o, l, u, c;
    i < 0 && (t = t + i, i = -i), a < 0 && (r = r + a, a = -a), typeof s == "number" ? o = l = u = c = s : s instanceof Array ? s.length === 1 ? o = l = u = c = s[0] : s.length === 2 ? (o = u = s[0], l = c = s[1]) : s.length === 3 ? (o = s[0], l = c = s[1], u = s[2]) : (o = s[0], l = s[1], u = s[2], c = s[3]) : o = l = u = c = 0;
    var h;
    o + l > i && (h = o + l, o *= i / h, l *= i / h), u + c > i && (h = u + c, u *= i / h, c *= i / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), o + c > a && (h = o + c, o *= a / h, c *= a / h), n.moveTo(t + o, r), n.lineTo(t + i - l, r), l !== 0 && n.arc(t + i - l, r + l, l, -Math.PI / 2, 0), n.lineTo(t + i, r + a - u), u !== 0 && n.arc(t + i - u, r + a - u, u, 0, Math.PI / 2), n.lineTo(t + c, r + a), c !== 0 && n.arc(t + c, r + a - c, c, Math.PI / 2, Math.PI), n.lineTo(t, r + o), o !== 0 && n.arc(t + o, r + o, o, Math.PI, Math.PI * 1.5);
  }
  var mg = Math.round;
  function m8(n, e, t) {
    if (e) {
      var r = e.x1, i = e.x2, a = e.y1, s = e.y2;
      n.x1 = r, n.x2 = i, n.y1 = a, n.y2 = s;
      var o = t && t.lineWidth;
      return o && (mg(r * 2) === mg(i * 2) && (n.x1 = n.x2 = Lh(r, o, true)), mg(a * 2) === mg(s * 2) && (n.y1 = n.y2 = Lh(a, o, true))), n;
    }
  }
  function v8(n, e, t) {
    if (e) {
      var r = e.x, i = e.y, a = e.width, s = e.height;
      n.x = r, n.y = i, n.width = a, n.height = s;
      var o = t && t.lineWidth;
      return o && (n.x = Lh(r, o, true), n.y = Lh(i, o, true), n.width = Math.max(Lh(r + a, o, false) - n.x, a === 0 ? 0 : 1), n.height = Math.max(Lh(i + s, o, false) - n.y, s === 0 ? 0 : 1)), n;
    }
  }
  function Lh(n, e, t) {
    if (!e) return n;
    var r = mg(n * 2);
    return (r + mg(e)) % 2 === 0 ? r / 2 : (r + (t ? 1 : -1)) / 2;
  }
  var xue = /* @__PURE__ */ function() {
    function n() {
      this.x = 0, this.y = 0, this.width = 0, this.height = 0;
    }
    return n;
  }(), bue = {}, Vt = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new xue();
    }, e.prototype.buildPath = function(t, r) {
      var i, a, s, o;
      if (this.subPixelOptimize) {
        var l = v8(bue, r, this.style);
        i = l.x, a = l.y, s = l.width, o = l.height, l.r = r.r, r = l;
      } else i = r.x, a = r.y, s = r.width, o = r.height;
      r.r ? yue(t, r) : t.rect(i, a, s, o);
    }, e.prototype.isZeroArea = function() {
      return !this.shape.width || !this.shape.height;
    }, e;
  }(At);
  Vt.prototype.type = "rect";
  var IF = {
    fill: "#000"
  }, kF = 2, wue = {
    style: je({
      fill: true,
      stroke: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineWidth: true,
      fontSize: true,
      lineHeight: true,
      width: true,
      height: true,
      textShadowColor: true,
      textShadowBlur: true,
      textShadowOffsetX: true,
      textShadowOffsetY: true,
      backgroundColor: true,
      padding: true,
      borderColor: true,
      borderWidth: true,
      borderRadius: true
    }, yC.style)
  }, Gt = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r.type = "text", r._children = [], r._defaultStyle = IF, r.attr(t), r;
    }
    return e.prototype.childrenRef = function() {
      return this._children;
    }, e.prototype.update = function() {
      n.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
      for (var t = 0; t < this._children.length; t++) {
        var r = this._children[t];
        r.zlevel = this.zlevel, r.z = this.z, r.z2 = this.z2, r.culling = this.culling, r.cursor = this.cursor, r.invisible = this.invisible;
      }
    }, e.prototype.updateTransform = function() {
      var t = this.innerTransformable;
      t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : n.prototype.updateTransform.call(this);
    }, e.prototype.getLocalTransform = function(t) {
      var r = this.innerTransformable;
      return r ? r.getLocalTransform(t) : n.prototype.getLocalTransform.call(this, t);
    }, e.prototype.getComputedTransform = function() {
      return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(true)), n.prototype.getComputedTransform.call(this);
    }, e.prototype._updateSubTexts = function() {
      this._childCursor = 0, Cue(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
    }, e.prototype.addSelfToZr = function(t) {
      n.prototype.addSelfToZr.call(this, t);
      for (var r = 0; r < this._children.length; r++) this._children[r].__zr = t;
    }, e.prototype.removeSelfFromZr = function(t) {
      n.prototype.removeSelfFromZr.call(this, t);
      for (var r = 0; r < this._children.length; r++) this._children[r].__zr = null;
    }, e.prototype.getBoundingRect = function() {
      if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
        for (var t = new vt(0, 0, 0, 0), r = this._children, i = [], a = null, s = 0; s < r.length; s++) {
          var o = r[s], l = o.getBoundingRect(), u = o.getLocalTransform(i);
          u ? (t.copy(l), t.applyTransform(u), a = a || t.clone(), a.union(t)) : (a = a || l.clone(), a.union(l));
        }
        this._rect = a || t;
      }
      return this._rect;
    }, e.prototype.setDefaultTextStyle = function(t) {
      this._defaultStyle = t || IF;
    }, e.prototype.setTextContent = function(t) {
    }, e.prototype._mergeStyle = function(t, r) {
      if (!r) return t;
      var i = r.rich, a = t.rich || i && {};
      return oe(t, r), i && a ? (this._mergeRich(a, i), t.rich = a) : a && (t.rich = a), t;
    }, e.prototype._mergeRich = function(t, r) {
      for (var i = Mt(r), a = 0; a < i.length; a++) {
        var s = i[a];
        t[s] = t[s] || {}, oe(t[s], r[s]);
      }
    }, e.prototype.getAnimationStyleProps = function() {
      return wue;
    }, e.prototype._getOrCreateChild = function(t) {
      var r = this._children[this._childCursor];
      return (!r || !(r instanceof t)) && (r = new t()), this._children[this._childCursor++] = r, r.__zr = this.__zr, r.parent = this, r;
    }, e.prototype._updatePlainTexts = function() {
      var t = this.style, r = t.font || Ju, i = t.padding, a = EF(t), s = Hle(a, t), o = ok(t), l = !!t.backgroundColor, u = s.outerHeight, c = s.outerWidth, h = s.contentWidth, d = s.lines, f = s.lineHeight, p = this._defaultStyle;
      this.isTruncated = !!s.isTruncated;
      var g = t.x || 0, m = t.y || 0, v = t.align || p.align || "left", y = t.verticalAlign || p.verticalAlign || "top", x = g, b = rg(m, s.contentHeight, y);
      if (o || i) {
        var w = $y(g, c, v), _ = rg(m, u, y);
        o && this._renderBackground(t, t, w, _, c, u);
      }
      b += f / 2, i && (x = NF(g, v, i), y === "top" ? b += i[0] : y === "bottom" && (b -= i[2]));
      for (var S = 0, I = false, C = $F("fill" in t ? t.fill : (I = true, p.fill)), T = RF("stroke" in t ? t.stroke : !l && (!p.autoStroke || I) ? (S = kF, p.stroke) : null), k = t.textShadowBlur > 0, D = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), R = s.calculatedLineHeight, N = 0; N < d.length; N++) {
        var E = this._getOrCreateChild(Eg), A = E.createStyle();
        E.useStyle(A), A.text = d[N], A.x = x, A.y = b, A.textAlign = v, A.textBaseline = "middle", A.opacity = t.opacity, A.strokeFirst = true, k && (A.shadowBlur = t.textShadowBlur || 0, A.shadowColor = t.textShadowColor || "transparent", A.shadowOffsetX = t.textShadowOffsetX || 0, A.shadowOffsetY = t.textShadowOffsetY || 0), A.stroke = T, A.fill = C, T && (A.lineWidth = t.lineWidth || S, A.lineDash = t.lineDash, A.lineDashOffset = t.lineDashOffset || 0), A.font = r, AF(A, t), b += f, D && E.setBoundingRect(new vt($y(A.x, h, A.textAlign), rg(A.y, R, A.textBaseline), h, R));
      }
    }, e.prototype._updateRichTexts = function() {
      var t = this.style, r = EF(t), i = qle(r, t), a = i.width, s = i.outerWidth, o = i.outerHeight, l = t.padding, u = t.x || 0, c = t.y || 0, h = this._defaultStyle, d = t.align || h.align, f = t.verticalAlign || h.verticalAlign;
      this.isTruncated = !!i.isTruncated;
      var p = $y(u, s, d), g = rg(c, o, f), m = p, v = g;
      l && (m += l[3], v += l[0]);
      var y = m + a;
      ok(t) && this._renderBackground(t, t, p, g, s, o);
      for (var x = !!t.backgroundColor, b = 0; b < i.lines.length; b++) {
        for (var w = i.lines[b], _ = w.tokens, S = _.length, I = w.lineHeight, C = w.width, T = 0, k = m, D = y, R = S - 1, N = void 0; T < S && (N = _[T], !N.align || N.align === "left"); ) this._placeToken(N, t, I, v, k, "left", x), C -= N.width, k += N.width, T++;
        for (; R >= 0 && (N = _[R], N.align === "right"); ) this._placeToken(N, t, I, v, D, "right", x), C -= N.width, D -= N.width, R--;
        for (k += (a - (k - m) - (y - D) - C) / 2; T <= R; ) N = _[T], this._placeToken(N, t, I, v, k + N.width / 2, "center", x), k += N.width, T++;
        v += I;
      }
    }, e.prototype._placeToken = function(t, r, i, a, s, o, l) {
      var u = r.rich[t.styleName] || {};
      u.text = t.text;
      var c = t.verticalAlign, h = a + i / 2;
      c === "top" ? h = a + t.height / 2 : c === "bottom" && (h = a + i - t.height / 2);
      var d = !t.isLineHolder && ok(u);
      d && this._renderBackground(u, r, o === "right" ? s - t.width : o === "center" ? s - t.width / 2 : s, h - t.height / 2, t.width, t.height);
      var f = !!u.backgroundColor, p = t.textPadding;
      p && (s = NF(s, o, p), h -= t.height / 2 - p[0] - t.innerHeight / 2);
      var g = this._getOrCreateChild(Eg), m = g.createStyle();
      g.useStyle(m);
      var v = this._defaultStyle, y = false, x = 0, b = $F("fill" in u ? u.fill : "fill" in r ? r.fill : (y = true, v.fill)), w = RF("stroke" in u ? u.stroke : "stroke" in r ? r.stroke : !f && !l && (!v.autoStroke || y) ? (x = kF, v.stroke) : null), _ = u.textShadowBlur > 0 || r.textShadowBlur > 0;
      m.text = t.text, m.x = s, m.y = h, _ && (m.shadowBlur = u.textShadowBlur || r.textShadowBlur || 0, m.shadowColor = u.textShadowColor || r.textShadowColor || "transparent", m.shadowOffsetX = u.textShadowOffsetX || r.textShadowOffsetX || 0, m.shadowOffsetY = u.textShadowOffsetY || r.textShadowOffsetY || 0), m.textAlign = o, m.textBaseline = "middle", m.font = t.font || Ju, m.opacity = Go(u.opacity, r.opacity, 1), AF(m, u), w && (m.lineWidth = Go(u.lineWidth, r.lineWidth, x), m.lineDash = it(u.lineDash, r.lineDash), m.lineDashOffset = r.lineDashOffset || 0, m.stroke = w), b && (m.fill = b);
      var S = t.contentWidth, I = t.contentHeight;
      g.setBoundingRect(new vt($y(m.x, S, m.textAlign), rg(m.y, I, m.textBaseline), S, I));
    }, e.prototype._renderBackground = function(t, r, i, a, s, o) {
      var l = t.backgroundColor, u = t.borderWidth, c = t.borderColor, h = l && l.image, d = l && !h, f = t.borderRadius, p = this, g, m;
      if (d || t.lineHeight || u && c) {
        g = this._getOrCreateChild(Vt), g.useStyle(g.createStyle()), g.style.fill = null;
        var v = g.shape;
        v.x = i, v.y = a, v.width = s, v.height = o, v.r = f, g.dirtyShape();
      }
      if (d) {
        var y = g.style;
        y.fill = l || null, y.fillOpacity = it(t.fillOpacity, 1);
      } else if (h) {
        m = this._getOrCreateChild(oi), m.onload = function() {
          p.dirtyStyle();
        };
        var x = m.style;
        x.image = l.image, x.x = i, x.y = a, x.width = s, x.height = o;
      }
      if (u && c) {
        var y = g.style;
        y.lineWidth = u, y.stroke = c, y.strokeOpacity = it(t.strokeOpacity, 1), y.lineDash = t.borderDash, y.lineDashOffset = t.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = true, y.lineWidth *= 2);
      }
      var b = (g || m).style;
      b.shadowBlur = t.shadowBlur || 0, b.shadowColor = t.shadowColor || "transparent", b.shadowOffsetX = t.shadowOffsetX || 0, b.shadowOffsetY = t.shadowOffsetY || 0, b.opacity = Go(t.opacity, r.opacity, 1);
    }, e.makeFont = function(t) {
      var r = "";
      return x8(t) && (r = [
        t.fontStyle,
        t.fontWeight,
        y8(t.fontSize),
        t.fontFamily || "sans-serif"
      ].join(" ")), r && Hs(r) || t.textFont || t.font;
    }, e;
  }(_s), _ue = {
    left: true,
    right: 1,
    center: 1
  }, Sue = {
    top: 1,
    bottom: 1,
    middle: 1
  }, TF = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily"
  ];
  function y8(n) {
    return typeof n == "string" && (n.indexOf("px") !== -1 || n.indexOf("rem") !== -1 || n.indexOf("em") !== -1) ? n : isNaN(+n) ? AN + "px" : n + "px";
  }
  function AF(n, e) {
    for (var t = 0; t < TF.length; t++) {
      var r = TF[t], i = e[r];
      i != null && (n[r] = i);
    }
  }
  function x8(n) {
    return n.fontSize != null || n.fontFamily || n.fontWeight;
  }
  function Cue(n) {
    return DF(n), P(n.rich, DF), n;
  }
  function DF(n) {
    if (n) {
      n.font = Gt.makeFont(n);
      var e = n.align;
      e === "middle" && (e = "center"), n.align = e == null || _ue[e] ? e : "left";
      var t = n.verticalAlign;
      t === "center" && (t = "middle"), n.verticalAlign = t == null || Sue[t] ? t : "top";
      var r = n.padding;
      r && (n.padding = MN(n.padding));
    }
  }
  function RF(n, e) {
    return n == null || e <= 0 || n === "transparent" || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
  }
  function $F(n) {
    return n == null || n === "none" ? null : n.image || n.colorStops ? "#000" : n;
  }
  function NF(n, e, t) {
    return e === "right" ? n - t[1] : e === "center" ? n + t[3] / 2 - t[1] / 2 : n + t[3];
  }
  function EF(n) {
    var e = n.text;
    return e != null && (e += ""), e;
  }
  function ok(n) {
    return !!(n.backgroundColor || n.lineHeight || n.borderWidth && n.borderColor);
  }
  var rt = Wt(), zD = function(n, e, t, r) {
    if (r) {
      var i = rt(r);
      i.dataIndex = t, i.dataType = e, i.seriesIndex = n, i.ssrType = "chart", r.type === "group" && r.traverse(function(a) {
        var s = rt(a);
        s.seriesIndex = n, s.dataIndex = t, s.dataType = e, s.ssrType = "chart";
      });
    }
  }, MF = 1, PF = {}, b8 = Wt(), YN = Wt(), qN = 0, Nx = 1, bC = 2, na = [
    "emphasis",
    "blur",
    "select"
  ], $0 = [
    "normal",
    "emphasis",
    "blur",
    "select"
  ], gm = 10, Iue = 9, Zh = "highlight", n_ = "downplay", a0 = "select", r_ = "unselect", s0 = "toggleSelect";
  function Ap(n) {
    return n != null && n !== "none";
  }
  function wC(n, e, t) {
    n.onHoverStateChange && (n.hoverState || 0) !== t && n.onHoverStateChange(e), n.hoverState = t;
  }
  function w8(n) {
    wC(n, "emphasis", bC);
  }
  function _8(n) {
    n.hoverState === bC && wC(n, "normal", qN);
  }
  function jN(n) {
    wC(n, "blur", Nx);
  }
  function S8(n) {
    n.hoverState === Nx && wC(n, "normal", qN);
  }
  function kue(n) {
    n.selected = true;
  }
  function Tue(n) {
    n.selected = false;
  }
  function LF(n, e, t) {
    e(n, t);
  }
  function ru(n, e, t) {
    LF(n, e, t), n.isGroup && n.traverse(function(r) {
      LF(r, e, t);
    });
  }
  function B_(n, e) {
    switch (e) {
      case "emphasis":
        n.hoverState = bC;
        break;
      case "normal":
        n.hoverState = qN;
        break;
      case "blur":
        n.hoverState = Nx;
        break;
      case "select":
        n.selected = true;
    }
  }
  function Aue(n, e, t, r) {
    for (var i = n.style, a = {}, s = 0; s < e.length; s++) {
      var o = e[s], l = i[o];
      a[o] = l ?? (r && r[o]);
    }
    for (var s = 0; s < n.animators.length; s++) {
      var u = n.animators[s];
      u.__fromStateTransition && u.__fromStateTransition.indexOf(t) < 0 && u.targetName === "style" && u.saveTo(a, e);
    }
    return a;
  }
  function Due(n, e, t, r) {
    var i = t && bt(t, "select") >= 0, a = false;
    if (n instanceof At) {
      var s = b8(n), o = i && s.selectFill || s.normalFill, l = i && s.selectStroke || s.normalStroke;
      if (Ap(o) || Ap(l)) {
        r = r || {};
        var u = r.style || {};
        u.fill === "inherit" ? (a = true, r = oe({}, r), u = oe({}, u), u.fill = o) : !Ap(u.fill) && Ap(o) ? (a = true, r = oe({}, r), u = oe({}, u), u.fill = ID(o)) : !Ap(u.stroke) && Ap(l) && (a || (r = oe({}, r), u = oe({}, u)), u.stroke = ID(l)), r.style = u;
      }
    }
    if (r && r.z2 == null) {
      a || (r = oe({}, r));
      var c = n.z2EmphasisLift;
      r.z2 = n.z2 + (c ?? gm);
    }
    return r;
  }
  function Rue(n, e, t) {
    if (t && t.z2 == null) {
      t = oe({}, t);
      var r = n.z2SelectLift;
      t.z2 = n.z2 + (r ?? Iue);
    }
    return t;
  }
  function $ue(n, e, t) {
    var r = bt(n.currentStates, e) >= 0, i = n.style.opacity, a = r ? null : Aue(n, [
      "opacity"
    ], e, {
      opacity: 1
    });
    t = t || {};
    var s = t.style || {};
    return s.opacity == null && (t = oe({}, t), s = oe({
      opacity: r ? i : a.opacity * 0.1
    }, s), t.style = s), t;
  }
  function lk(n, e) {
    var t = this.states[n];
    if (this.style) {
      if (n === "emphasis") return Due(this, n, e, t);
      if (n === "blur") return $ue(this, n, t);
      if (n === "select") return Rue(this, n, t);
    }
    return t;
  }
  function dd(n) {
    n.stateProxy = lk;
    var e = n.getTextContent(), t = n.getTextGuideLine();
    e && (e.stateProxy = lk), t && (t.stateProxy = lk);
  }
  function FF(n, e) {
    !T8(n, e) && !n.__highByOuter && ru(n, w8);
  }
  function OF(n, e) {
    !T8(n, e) && !n.__highByOuter && ru(n, _8);
  }
  function Xl(n, e) {
    n.__highByOuter |= 1 << (e || 0), ru(n, w8);
  }
  function Yl(n, e) {
    !(n.__highByOuter &= ~(1 << (e || 0))) && ru(n, _8);
  }
  function C8(n) {
    ru(n, jN);
  }
  function KN(n) {
    ru(n, S8);
  }
  function I8(n) {
    ru(n, kue);
  }
  function k8(n) {
    ru(n, Tue);
  }
  function T8(n, e) {
    return n.__highDownSilentOnTouch && e.zrByTouch;
  }
  function A8(n) {
    var e = n.getModel(), t = [], r = [];
    e.eachComponent(function(i, a) {
      var s = YN(a), o = i === "series", l = o ? n.getViewOfSeriesModel(a) : n.getViewOfComponentModel(a);
      !o && r.push(l), s.isBlured && (l.group.traverse(function(u) {
        S8(u);
      }), o && t.push(a)), s.isBlured = false;
    }), P(r, function(i) {
      i && i.toggleBlurSeries && i.toggleBlurSeries(t, false, e);
    });
  }
  function VD(n, e, t, r) {
    var i = r.getModel();
    t = t || "coordinateSystem";
    function a(u, c) {
      for (var h = 0; h < c.length; h++) {
        var d = u.getItemGraphicEl(c[h]);
        d && KN(d);
      }
    }
    if (n != null && !(!e || e === "none")) {
      var s = i.getSeriesByIndex(n), o = s.coordinateSystem;
      o && o.master && (o = o.master);
      var l = [];
      i.eachSeries(function(u) {
        var c = s === u, h = u.coordinateSystem;
        h && h.master && (h = h.master);
        var d = h && o ? h === o : c;
        if (!(t === "series" && !c || t === "coordinateSystem" && !d || e === "series" && c)) {
          var f = r.getViewOfSeriesModel(u);
          if (f.group.traverse(function(m) {
            m.__highByOuter && c && e === "self" || jN(m);
          }), Mi(e)) a(u.getData(), e);
          else if (Ze(e)) for (var p = Mt(e), g = 0; g < p.length; g++) a(u.getData(p[g]), e[p[g]]);
          l.push(u), YN(u).isBlured = true;
        }
      }), i.eachComponent(function(u, c) {
        if (u !== "series") {
          var h = r.getViewOfComponentModel(c);
          h && h.toggleBlurSeries && h.toggleBlurSeries(l, true, i);
        }
      });
    }
  }
  function WD(n, e, t) {
    if (!(n == null || e == null)) {
      var r = t.getModel().getComponent(n, e);
      if (r) {
        YN(r).isBlured = true;
        var i = t.getViewOfComponentModel(r);
        !i || !i.focusBlurEnabled || i.group.traverse(function(a) {
          jN(a);
        });
      }
    }
  }
  function Nue(n, e, t) {
    var r = n.seriesIndex, i = n.getData(e.dataType);
    if (i) {
      var a = cd(i, e);
      a = (de(a) ? a[0] : a) || 0;
      var s = i.getItemGraphicEl(a);
      if (!s) for (var o = i.count(), l = 0; !s && l < o; ) s = i.getItemGraphicEl(l++);
      if (s) {
        var u = rt(s);
        VD(r, u.focus, u.blurScope, t);
      } else {
        var c = n.get([
          "emphasis",
          "focus"
        ]), h = n.get([
          "emphasis",
          "blurScope"
        ]);
        c != null && VD(r, c, h, t);
      }
    }
  }
  function ZN(n, e, t, r) {
    var i = {
      focusSelf: false,
      dispatchers: null
    };
    if (n == null || n === "series" || e == null || t == null) return i;
    var a = r.getModel().getComponent(n, e);
    if (!a) return i;
    var s = r.getViewOfComponentModel(a);
    if (!s || !s.findHighDownDispatchers) return i;
    for (var o = s.findHighDownDispatchers(t), l, u = 0; u < o.length; u++) if (rt(o[u]).focus === "self") {
      l = true;
      break;
    }
    return {
      focusSelf: l,
      dispatchers: o
    };
  }
  function Eue(n, e, t) {
    var r = rt(n), i = ZN(r.componentMainType, r.componentIndex, r.componentHighDownName, t), a = i.dispatchers, s = i.focusSelf;
    a ? (s && WD(r.componentMainType, r.componentIndex, t), P(a, function(o) {
      return FF(o, e);
    })) : (VD(r.seriesIndex, r.focus, r.blurScope, t), r.focus === "self" && WD(r.componentMainType, r.componentIndex, t), FF(n, e));
  }
  function Mue(n, e, t) {
    A8(t);
    var r = rt(n), i = ZN(r.componentMainType, r.componentIndex, r.componentHighDownName, t).dispatchers;
    i ? P(i, function(a) {
      return OF(a, e);
    }) : OF(n, e);
  }
  function Pue(n, e, t) {
    if (UD(e)) {
      var r = e.dataType, i = n.getData(r), a = cd(i, e);
      de(a) || (a = [
        a
      ]), n[e.type === s0 ? "toggleSelect" : e.type === a0 ? "select" : "unselect"](a, r);
    }
  }
  function BF(n) {
    var e = n.getAllData();
    P(e, function(t) {
      var r = t.data, i = t.type;
      r.eachItemGraphicEl(function(a, s) {
        n.isSelected(s, i) ? I8(a) : k8(a);
      });
    });
  }
  function Lue(n) {
    var e = [];
    return n.eachSeries(function(t) {
      var r = t.getAllData();
      P(r, function(i) {
        i.data;
        var a = i.type, s = t.getSelectedDataIndices();
        if (s.length > 0) {
          var o = {
            dataIndex: s,
            seriesIndex: t.seriesIndex
          };
          a != null && (o.dataType = a), e.push(o);
        }
      });
    }), e;
  }
  function Qh(n, e, t) {
    Fh(n, true), ru(n, dd), GD(n, e, t);
  }
  function Fue(n) {
    Fh(n, false);
  }
  function Qn(n, e, t, r) {
    r ? Fue(n) : Qh(n, e, t);
  }
  function GD(n, e, t) {
    var r = rt(n);
    e != null ? (r.focus = e, r.blurScope = t) : r.focus && (r.focus = null);
  }
  var zF = [
    "emphasis",
    "blur",
    "select"
  ], Oue = {
    itemStyle: "getItemStyle",
    lineStyle: "getLineStyle",
    areaStyle: "getAreaStyle"
  };
  function pi(n, e, t, r) {
    t = t || "itemStyle";
    for (var i = 0; i < zF.length; i++) {
      var a = zF[i], s = e.getModel([
        a,
        t
      ]), o = n.ensureState(a);
      o.style = r ? r(s) : s[Oue[t]]();
    }
  }
  function Fh(n, e) {
    var t = e === false, r = n;
    n.highDownSilentOnTouch && (r.__highDownSilentOnTouch = n.highDownSilentOnTouch), (!t || r.__highDownDispatcher) && (r.__highByOuter = r.__highByOuter || 0, r.__highDownDispatcher = !t);
  }
  function N0(n) {
    return !!(n && n.__highDownDispatcher);
  }
  function Bue(n, e, t) {
    var r = rt(n);
    r.componentMainType = e.mainType, r.componentIndex = e.componentIndex, r.componentHighDownName = t;
  }
  function zue(n) {
    var e = PF[n];
    return e == null && MF <= 32 && (e = PF[n] = MF++), e;
  }
  function UD(n) {
    var e = n.type;
    return e === a0 || e === r_ || e === s0;
  }
  function VF(n) {
    var e = n.type;
    return e === Zh || e === n_;
  }
  function Vue(n) {
    var e = b8(n);
    e.normalFill = n.style.fill, e.normalStroke = n.style.stroke;
    var t = n.states.select || {};
    e.selectFill = t.style && t.style.fill || null, e.selectStroke = t.style && t.style.stroke || null;
  }
  var Dp = nl.CMD, Wue = [
    [],
    [],
    []
  ], WF = Math.sqrt, Gue = Math.atan2;
  function D8(n, e) {
    if (e) {
      var t = n.data, r = n.len(), i, a, s, o, l, u, c = Dp.M, h = Dp.C, d = Dp.L, f = Dp.R, p = Dp.A, g = Dp.Q;
      for (s = 0, o = 0; s < r; ) {
        switch (i = t[s++], o = s, a = 0, i) {
          case c:
            a = 1;
            break;
          case d:
            a = 1;
            break;
          case h:
            a = 3;
            break;
          case g:
            a = 2;
            break;
          case p:
            var m = e[4], v = e[5], y = WF(e[0] * e[0] + e[1] * e[1]), x = WF(e[2] * e[2] + e[3] * e[3]), b = Gue(-e[1] / x, e[0] / y);
            t[s] *= y, t[s++] += m, t[s] *= x, t[s++] += v, t[s++] *= y, t[s++] *= x, t[s++] += b, t[s++] += b, s += 2, o = s;
            break;
          case f:
            u[0] = t[s++], u[1] = t[s++], di(u, u, e), t[o++] = u[0], t[o++] = u[1], u[0] += t[s++], u[1] += t[s++], di(u, u, e), t[o++] = u[0], t[o++] = u[1];
        }
        for (l = 0; l < a; l++) {
          var w = Wue[l];
          w[0] = t[s++], w[1] = t[s++], di(w, w, e), t[o++] = w[0], t[o++] = w[1];
        }
      }
      n.increaseVersion();
    }
  }
  var uk = Math.sqrt, C1 = Math.sin, I1 = Math.cos, Zv = Math.PI;
  function GF(n) {
    return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
  }
  function HD(n, e) {
    return (n[0] * e[0] + n[1] * e[1]) / (GF(n) * GF(e));
  }
  function UF(n, e) {
    return (n[0] * e[1] < n[1] * e[0] ? -1 : 1) * Math.acos(HD(n, e));
  }
  function HF(n, e, t, r, i, a, s, o, l, u, c) {
    var h = l * (Zv / 180), d = I1(h) * (n - t) / 2 + C1(h) * (e - r) / 2, f = -1 * C1(h) * (n - t) / 2 + I1(h) * (e - r) / 2, p = d * d / (s * s) + f * f / (o * o);
    p > 1 && (s *= uk(p), o *= uk(p));
    var g = (i === a ? -1 : 1) * uk((s * s * (o * o) - s * s * (f * f) - o * o * (d * d)) / (s * s * (f * f) + o * o * (d * d))) || 0, m = g * s * f / o, v = g * -o * d / s, y = (n + t) / 2 + I1(h) * m - C1(h) * v, x = (e + r) / 2 + C1(h) * m + I1(h) * v, b = UF([
      1,
      0
    ], [
      (d - m) / s,
      (f - v) / o
    ]), w = [
      (d - m) / s,
      (f - v) / o
    ], _ = [
      (-1 * d - m) / s,
      (-1 * f - v) / o
    ], S = UF(w, _);
    if (HD(w, _) <= -1 && (S = Zv), HD(w, _) >= 1 && (S = 0), S < 0) {
      var I = Math.round(S / Zv * 1e6) / 1e6;
      S = Zv * 2 + I % 2 * Zv;
    }
    c.addData(u, y, x, s, o, b, S, h, a);
  }
  var Uue = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, Hue = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function Xue(n) {
    var e = new nl();
    if (!n) return e;
    var t = 0, r = 0, i = t, a = r, s, o = nl.CMD, l = n.match(Uue);
    if (!l) return e;
    for (var u = 0; u < l.length; u++) {
      for (var c = l[u], h = c.charAt(0), d = void 0, f = c.match(Hue) || [], p = f.length, g = 0; g < p; g++) f[g] = parseFloat(f[g]);
      for (var m = 0; m < p; ) {
        var v = void 0, y = void 0, x = void 0, b = void 0, w = void 0, _ = void 0, S = void 0, I = t, C = r, T = void 0, k = void 0;
        switch (h) {
          case "l":
            t += f[m++], r += f[m++], d = o.L, e.addData(d, t, r);
            break;
          case "L":
            t = f[m++], r = f[m++], d = o.L, e.addData(d, t, r);
            break;
          case "m":
            t += f[m++], r += f[m++], d = o.M, e.addData(d, t, r), i = t, a = r, h = "l";
            break;
          case "M":
            t = f[m++], r = f[m++], d = o.M, e.addData(d, t, r), i = t, a = r, h = "L";
            break;
          case "h":
            t += f[m++], d = o.L, e.addData(d, t, r);
            break;
          case "H":
            t = f[m++], d = o.L, e.addData(d, t, r);
            break;
          case "v":
            r += f[m++], d = o.L, e.addData(d, t, r);
            break;
          case "V":
            r = f[m++], d = o.L, e.addData(d, t, r);
            break;
          case "C":
            d = o.C, e.addData(d, f[m++], f[m++], f[m++], f[m++], f[m++], f[m++]), t = f[m - 2], r = f[m - 1];
            break;
          case "c":
            d = o.C, e.addData(d, f[m++] + t, f[m++] + r, f[m++] + t, f[m++] + r, f[m++] + t, f[m++] + r), t += f[m - 2], r += f[m - 1];
            break;
          case "S":
            v = t, y = r, T = e.len(), k = e.data, s === o.C && (v += t - k[T - 4], y += r - k[T - 3]), d = o.C, I = f[m++], C = f[m++], t = f[m++], r = f[m++], e.addData(d, v, y, I, C, t, r);
            break;
          case "s":
            v = t, y = r, T = e.len(), k = e.data, s === o.C && (v += t - k[T - 4], y += r - k[T - 3]), d = o.C, I = t + f[m++], C = r + f[m++], t += f[m++], r += f[m++], e.addData(d, v, y, I, C, t, r);
            break;
          case "Q":
            I = f[m++], C = f[m++], t = f[m++], r = f[m++], d = o.Q, e.addData(d, I, C, t, r);
            break;
          case "q":
            I = f[m++] + t, C = f[m++] + r, t += f[m++], r += f[m++], d = o.Q, e.addData(d, I, C, t, r);
            break;
          case "T":
            v = t, y = r, T = e.len(), k = e.data, s === o.Q && (v += t - k[T - 4], y += r - k[T - 3]), t = f[m++], r = f[m++], d = o.Q, e.addData(d, v, y, t, r);
            break;
          case "t":
            v = t, y = r, T = e.len(), k = e.data, s === o.Q && (v += t - k[T - 4], y += r - k[T - 3]), t += f[m++], r += f[m++], d = o.Q, e.addData(d, v, y, t, r);
            break;
          case "A":
            x = f[m++], b = f[m++], w = f[m++], _ = f[m++], S = f[m++], I = t, C = r, t = f[m++], r = f[m++], d = o.A, HF(I, C, t, r, _, S, x, b, w, d, e);
            break;
          case "a":
            x = f[m++], b = f[m++], w = f[m++], _ = f[m++], S = f[m++], I = t, C = r, t += f[m++], r += f[m++], d = o.A, HF(I, C, t, r, _, S, x, b, w, d, e);
            break;
        }
      }
      (h === "z" || h === "Z") && (d = o.Z, e.addData(d), t = i, r = a), s = d;
    }
    return e.toStatic(), e;
  }
  var R8 = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.applyTransform = function(t) {
    }, e;
  }(At);
  function $8(n) {
    return n.setData != null;
  }
  function N8(n, e) {
    var t = Xue(n), r = oe({}, e);
    return r.buildPath = function(i) {
      if ($8(i)) {
        i.setData(t.data);
        var a = i.getContext();
        a && i.rebuildPath(a, 1);
      } else {
        var a = i;
        t.rebuildPath(a, 1);
      }
    }, r.applyTransform = function(i) {
      D8(t, i), this.dirtyShape();
    }, r;
  }
  function E8(n, e) {
    return new R8(N8(n, e));
  }
  function Yue(n, e) {
    var t = N8(n, e), r = function(i) {
      K(a, i);
      function a(s) {
        var o = i.call(this, s) || this;
        return o.applyTransform = t.applyTransform, o.buildPath = t.buildPath, o;
      }
      return a;
    }(R8);
    return r;
  }
  function que(n, e) {
    for (var t = [], r = n.length, i = 0; i < r; i++) {
      var a = n[i];
      t.push(a.getUpdatedPathProxy(true));
    }
    var s = new At(e);
    return s.createPathProxy(), s.buildPath = function(o) {
      if ($8(o)) {
        o.appendPath(t);
        var l = o.getContext();
        l && o.rebuildPath(l, 1);
      }
    }, s;
  }
  function QN(n, e) {
    e = e || {};
    var t = new At();
    return n.shape && t.setShape(n.shape), t.setStyle(n.style), e.bakeTransform ? D8(t.path, n.getComputedTransform()) : e.toLocal ? t.setLocalTransform(n.getComputedTransform()) : t.copyTransform(n), t.buildPath = n.buildPath, t.applyTransform = t.applyTransform, t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel, t;
  }
  var jue = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r = 0;
    }
    return n;
  }(), iu = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new jue();
    }, e.prototype.buildPath = function(t, r) {
      t.moveTo(r.cx + r.r, r.cy), t.arc(r.cx, r.cy, r.r, 0, Math.PI * 2);
    }, e;
  }(At);
  iu.prototype.type = "circle";
  var Kue = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
    }
    return n;
  }(), _C = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new Kue();
    }, e.prototype.buildPath = function(t, r) {
      var i = 0.5522848, a = r.cx, s = r.cy, o = r.rx, l = r.ry, u = o * i, c = l * i;
      t.moveTo(a - o, s), t.bezierCurveTo(a - o, s - c, a - u, s - l, a, s - l), t.bezierCurveTo(a + u, s - l, a + o, s - c, a + o, s), t.bezierCurveTo(a + o, s + c, a + u, s + l, a, s + l), t.bezierCurveTo(a - u, s + l, a - o, s + c, a - o, s), t.closePath();
    }, e;
  }(At);
  _C.prototype.type = "ellipse";
  var M8 = Math.PI, ck = M8 * 2, Qc = Math.sin, Rp = Math.cos, Zue = Math.acos, wi = Math.atan2, XF = Math.abs, o0 = Math.sqrt, Ny = Math.max, _o = Math.min, Fs = 1e-4;
  function Que(n, e, t, r, i, a, s, o) {
    var l = t - n, u = r - e, c = s - i, h = o - a, d = h * l - c * u;
    if (!(d * d < Fs)) return d = (c * (e - a) - h * (n - i)) / d, [
      n + d * l,
      e + d * u
    ];
  }
  function k1(n, e, t, r, i, a, s) {
    var o = n - t, l = e - r, u = (s ? a : -a) / o0(o * o + l * l), c = u * l, h = -u * o, d = n + c, f = e + h, p = t + c, g = r + h, m = (d + p) / 2, v = (f + g) / 2, y = p - d, x = g - f, b = y * y + x * x, w = i - a, _ = d * g - p * f, S = (x < 0 ? -1 : 1) * o0(Ny(0, w * w * b - _ * _)), I = (_ * x - y * S) / b, C = (-_ * y - x * S) / b, T = (_ * x + y * S) / b, k = (-_ * y + x * S) / b, D = I - m, R = C - v, N = T - m, E = k - v;
    return D * D + R * R > N * N + E * E && (I = T, C = k), {
      cx: I,
      cy: C,
      x0: -c,
      y0: -h,
      x1: I * (i / w - 1),
      y1: C * (i / w - 1)
    };
  }
  function Jue(n) {
    var e;
    if (de(n)) {
      var t = n.length;
      if (!t) return n;
      t === 1 ? e = [
        n[0],
        n[0],
        0,
        0
      ] : t === 2 ? e = [
        n[0],
        n[0],
        n[1],
        n[1]
      ] : t === 3 ? e = n.concat(n[2]) : e = n;
    } else e = [
      n,
      n,
      n,
      n
    ];
    return e;
  }
  function ece(n, e) {
    var t, r = Ny(e.r, 0), i = Ny(e.r0 || 0, 0), a = r > 0, s = i > 0;
    if (!(!a && !s)) {
      if (a || (r = i, i = 0), i > r) {
        var o = r;
        r = i, i = o;
      }
      var l = e.startAngle, u = e.endAngle;
      if (!(isNaN(l) || isNaN(u))) {
        var c = e.cx, h = e.cy, d = !!e.clockwise, f = XF(u - l), p = f > ck && f % ck;
        if (p > Fs && (f = p), !(r > Fs)) n.moveTo(c, h);
        else if (f > ck - Fs) n.moveTo(c + r * Rp(l), h + r * Qc(l)), n.arc(c, h, r, l, u, !d), i > Fs && (n.moveTo(c + i * Rp(u), h + i * Qc(u)), n.arc(c, h, i, u, l, d));
        else {
          var g = void 0, m = void 0, v = void 0, y = void 0, x = void 0, b = void 0, w = void 0, _ = void 0, S = void 0, I = void 0, C = void 0, T = void 0, k = void 0, D = void 0, R = void 0, N = void 0, E = r * Rp(l), A = r * Qc(l), M = i * Rp(u), $ = i * Qc(u), L = f > Fs;
          if (L) {
            var F = e.cornerRadius;
            F && (t = Jue(F), g = t[0], m = t[1], v = t[2], y = t[3]);
            var O = XF(r - i) / 2;
            if (x = _o(O, v), b = _o(O, y), w = _o(O, g), _ = _o(O, m), C = S = Ny(x, b), T = I = Ny(w, _), (S > Fs || I > Fs) && (k = r * Rp(u), D = r * Qc(u), R = i * Rp(l), N = i * Qc(l), f < M8)) {
              var z = Que(E, A, R, N, k, D, M, $);
              if (z) {
                var V = E - z[0], H = A - z[1], Y = k - z[0], le = D - z[1], ve = 1 / Qc(Zue((V * Y + H * le) / (o0(V * V + H * H) * o0(Y * Y + le * le))) / 2), re = o0(z[0] * z[0] + z[1] * z[1]);
                C = _o(S, (r - re) / (ve + 1)), T = _o(I, (i - re) / (ve - 1));
              }
            }
          }
          if (!L) n.moveTo(c + E, h + A);
          else if (C > Fs) {
            var ae = _o(v, C), fe = _o(y, C), ce = k1(R, N, E, A, r, ae, d), ye = k1(k, D, M, $, r, fe, d);
            n.moveTo(c + ce.cx + ce.x0, h + ce.cy + ce.y0), C < S && ae === fe ? n.arc(c + ce.cx, h + ce.cy, C, wi(ce.y0, ce.x0), wi(ye.y0, ye.x0), !d) : (ae > 0 && n.arc(c + ce.cx, h + ce.cy, ae, wi(ce.y0, ce.x0), wi(ce.y1, ce.x1), !d), n.arc(c, h, r, wi(ce.cy + ce.y1, ce.cx + ce.x1), wi(ye.cy + ye.y1, ye.cx + ye.x1), !d), fe > 0 && n.arc(c + ye.cx, h + ye.cy, fe, wi(ye.y1, ye.x1), wi(ye.y0, ye.x0), !d));
          } else n.moveTo(c + E, h + A), n.arc(c, h, r, l, u, !d);
          if (!(i > Fs) || !L) n.lineTo(c + M, h + $);
          else if (T > Fs) {
            var ae = _o(g, T), fe = _o(m, T), ce = k1(M, $, k, D, i, -fe, d), ye = k1(E, A, R, N, i, -ae, d);
            n.lineTo(c + ce.cx + ce.x0, h + ce.cy + ce.y0), T < I && ae === fe ? n.arc(c + ce.cx, h + ce.cy, T, wi(ce.y0, ce.x0), wi(ye.y0, ye.x0), !d) : (fe > 0 && n.arc(c + ce.cx, h + ce.cy, fe, wi(ce.y0, ce.x0), wi(ce.y1, ce.x1), !d), n.arc(c, h, i, wi(ce.cy + ce.y1, ce.cx + ce.x1), wi(ye.cy + ye.y1, ye.cx + ye.x1), d), ae > 0 && n.arc(c + ye.cx, h + ye.cy, ae, wi(ye.y1, ye.x1), wi(ye.y0, ye.x0), !d));
          } else n.lineTo(c + M, h + $), n.arc(c, h, i, u, l, d);
        }
        n.closePath();
      }
    }
  }
  var tce = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true, this.cornerRadius = 0;
    }
    return n;
  }(), ra = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new tce();
    }, e.prototype.buildPath = function(t, r) {
      ece(t, r);
    }, e.prototype.isZeroArea = function() {
      return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
    }, e;
  }(At);
  ra.prototype.type = "sector";
  var nce = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
    }
    return n;
  }(), Ex = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new nce();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.cx, a = r.cy, s = Math.PI * 2;
      t.moveTo(i + r.r, a), t.arc(i, a, r.r, 0, s, false), t.moveTo(i + r.r0, a), t.arc(i, a, r.r0, 0, s, true);
    }, e;
  }(At);
  Ex.prototype.type = "ring";
  function rce(n, e, t, r) {
    var i = [], a = [], s = [], o = [], l, u, c, h;
    if (r) {
      c = [
        1 / 0,
        1 / 0
      ], h = [
        -1 / 0,
        -1 / 0
      ];
      for (var d = 0, f = n.length; d < f; d++) Eu(c, c, n[d]), Mu(h, h, n[d]);
      Eu(c, c, r[0]), Mu(h, h, r[1]);
    }
    for (var d = 0, f = n.length; d < f; d++) {
      var p = n[d];
      if (t) l = n[d ? d - 1 : f - 1], u = n[(d + 1) % f];
      else if (d === 0 || d === f - 1) {
        i.push(El(n[d]));
        continue;
      } else l = n[d - 1], u = n[d + 1];
      Ph(a, u, l), qw(a, a, e);
      var g = mD(p, l), m = mD(p, u), v = g + m;
      v !== 0 && (g /= v, m /= v), qw(s, a, -g), qw(o, a, m);
      var y = W3([], p, s), x = W3([], p, o);
      r && (Mu(y, y, c), Eu(y, y, h), Mu(x, x, c), Eu(x, x, h)), i.push(y), i.push(x);
    }
    return t && i.push(i.shift()), i;
  }
  function P8(n, e, t) {
    var r = e.smooth, i = e.points;
    if (i && i.length >= 2) {
      if (r) {
        var a = rce(i, r, t, e.smoothConstraint);
        n.moveTo(i[0][0], i[0][1]);
        for (var s = i.length, o = 0; o < (t ? s : s - 1); o++) {
          var l = a[o * 2], u = a[o * 2 + 1], c = i[(o + 1) % s];
          n.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
        }
      } else {
        n.moveTo(i[0][0], i[0][1]);
        for (var o = 1, h = i.length; o < h; o++) n.lineTo(i[o][0], i[o][1]);
      }
      t && n.closePath();
    }
  }
  var ice = /* @__PURE__ */ function() {
    function n() {
      this.points = null, this.smooth = 0, this.smoothConstraint = null;
    }
    return n;
  }(), ia = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new ice();
    }, e.prototype.buildPath = function(t, r) {
      P8(t, r, true);
    }, e;
  }(At);
  ia.prototype.type = "polygon";
  var ace = /* @__PURE__ */ function() {
    function n() {
      this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
    }
    return n;
  }(), oa = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new ace();
    }, e.prototype.buildPath = function(t, r) {
      P8(t, r, false);
    }, e;
  }(At);
  oa.prototype.type = "polyline";
  var sce = {}, oce = /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return n;
  }(), zr = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new oce();
    }, e.prototype.buildPath = function(t, r) {
      var i, a, s, o;
      if (this.subPixelOptimize) {
        var l = m8(sce, r, this.style);
        i = l.x1, a = l.y1, s = l.x2, o = l.y2;
      } else i = r.x1, a = r.y1, s = r.x2, o = r.y2;
      var u = r.percent;
      u !== 0 && (t.moveTo(i, a), u < 1 && (s = i * (1 - u) + s * u, o = a * (1 - u) + o * u), t.lineTo(s, o));
    }, e.prototype.pointAt = function(t) {
      var r = this.shape;
      return [
        r.x1 * (1 - t) + r.x2 * t,
        r.y1 * (1 - t) + r.y2 * t
      ];
    }, e;
  }(At);
  zr.prototype.type = "line";
  var da = [], lce = /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
    }
    return n;
  }();
  function YF(n, e, t) {
    var r = n.cpx2, i = n.cpy2;
    return r != null || i != null ? [
      (t ? eF : Fr)(n.x1, n.cpx1, n.cpx2, n.x2, e),
      (t ? eF : Fr)(n.y1, n.cpy1, n.cpy2, n.y2, e)
    ] : [
      (t ? wD : Jr)(n.x1, n.cpx1, n.x2, e),
      (t ? wD : Jr)(n.y1, n.cpy1, n.y2, e)
    ];
  }
  var Mx = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new lce();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.x1, a = r.y1, s = r.x2, o = r.y2, l = r.cpx1, u = r.cpy1, c = r.cpx2, h = r.cpy2, d = r.percent;
      d !== 0 && (t.moveTo(i, a), c == null || h == null ? (d < 1 && (k0(i, l, s, d, da), l = da[1], s = da[2], k0(a, u, o, d, da), u = da[1], o = da[2]), t.quadraticCurveTo(l, u, s, o)) : (d < 1 && (tc(i, l, c, s, d, da), l = da[1], c = da[2], s = da[3], tc(a, u, h, o, d, da), u = da[1], h = da[2], o = da[3]), t.bezierCurveTo(l, u, c, h, s, o)));
    }, e.prototype.pointAt = function(t) {
      return YF(this.shape, t, false);
    }, e.prototype.tangentAt = function(t) {
      var r = YF(this.shape, t, true);
      return dm(r, r);
    }, e;
  }(At);
  Mx.prototype.type = "bezier-curve";
  var uce = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
    }
    return n;
  }(), SC = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new uce();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.cx, a = r.cy, s = Math.max(r.r, 0), o = r.startAngle, l = r.endAngle, u = r.clockwise, c = Math.cos(o), h = Math.sin(o);
      t.moveTo(c * s + i, h * s + a), t.arc(i, a, s, o, l, !u);
    }, e;
  }(At);
  SC.prototype.type = "arc";
  var JN = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "compound", t;
    }
    return e.prototype._updatePathDirty = function() {
      for (var t = this.shape.paths, r = this.shapeChanged(), i = 0; i < t.length; i++) r = r || t[i].shapeChanged();
      r && this.dirtyShape();
    }, e.prototype.beforeBrush = function() {
      this._updatePathDirty();
      for (var t = this.shape.paths || [], r = this.getGlobalScale(), i = 0; i < t.length; i++) t[i].path || t[i].createPathProxy(), t[i].path.setScale(r[0], r[1], t[i].segmentIgnoreThreshold);
    }, e.prototype.buildPath = function(t, r) {
      for (var i = r.paths || [], a = 0; a < i.length; a++) i[a].buildPath(t, i[a].shape, true);
    }, e.prototype.afterBrush = function() {
      for (var t = this.shape.paths || [], r = 0; r < t.length; r++) t[r].pathUpdated();
    }, e.prototype.getBoundingRect = function() {
      return this._updatePathDirty.call(this), At.prototype.getBoundingRect.call(this);
    }, e;
  }(At), L8 = function() {
    function n(e) {
      this.colorStops = e || [];
    }
    return n.prototype.addColorStop = function(e, t) {
      this.colorStops.push({
        offset: e,
        color: t
      });
    }, n;
  }(), Px = function(n) {
    K(e, n);
    function e(t, r, i, a, s, o) {
      var l = n.call(this, s) || this;
      return l.x = t ?? 0, l.y = r ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = o || false, l;
    }
    return e;
  }(L8), F8 = function(n) {
    K(e, n);
    function e(t, r, i, a, s) {
      var o = n.call(this, a) || this;
      return o.x = t ?? 0.5, o.y = r ?? 0.5, o.r = i ?? 0.5, o.type = "radial", o.global = s || false, o;
    }
    return e;
  }(L8), Jc = [
    0,
    0
  ], eh = [
    0,
    0
  ], T1 = new mt(), A1 = new mt(), z_ = function() {
    function n(e, t) {
      this._corners = [], this._axes = [], this._origin = [
        0,
        0
      ];
      for (var r = 0; r < 4; r++) this._corners[r] = new mt();
      for (var r = 0; r < 2; r++) this._axes[r] = new mt();
      e && this.fromBoundingRect(e, t);
    }
    return n.prototype.fromBoundingRect = function(e, t) {
      var r = this._corners, i = this._axes, a = e.x, s = e.y, o = a + e.width, l = s + e.height;
      if (r[0].set(a, s), r[1].set(o, s), r[2].set(o, l), r[3].set(a, l), t) for (var u = 0; u < 4; u++) r[u].transform(t);
      mt.sub(i[0], r[1], r[0]), mt.sub(i[1], r[3], r[0]), i[0].normalize(), i[1].normalize();
      for (var u = 0; u < 2; u++) this._origin[u] = i[u].dot(r[0]);
    }, n.prototype.intersect = function(e, t) {
      var r = true, i = !t;
      return T1.set(1 / 0, 1 / 0), A1.set(0, 0), !this._intersectCheckOneSide(this, e, T1, A1, i, 1) && (r = false, i) || !this._intersectCheckOneSide(e, this, T1, A1, i, -1) && (r = false, i) || i || mt.copy(t, r ? T1 : A1), r;
    }, n.prototype._intersectCheckOneSide = function(e, t, r, i, a, s) {
      for (var o = true, l = 0; l < 2; l++) {
        var u = this._axes[l];
        if (this._getProjMinMaxOnAxis(l, e._corners, Jc), this._getProjMinMaxOnAxis(l, t._corners, eh), Jc[1] < eh[0] || Jc[0] > eh[1]) {
          if (o = false, a) return o;
          var c = Math.abs(eh[0] - Jc[1]), h = Math.abs(Jc[0] - eh[1]);
          Math.min(c, h) > i.len() && (c < h ? mt.scale(i, u, -c * s) : mt.scale(i, u, h * s));
        } else if (r) {
          var c = Math.abs(eh[0] - Jc[1]), h = Math.abs(Jc[0] - eh[1]);
          Math.min(c, h) < r.len() && (c < h ? mt.scale(r, u, c * s) : mt.scale(r, u, -h * s));
        }
      }
      return o;
    }, n.prototype._getProjMinMaxOnAxis = function(e, t, r) {
      for (var i = this._axes[e], a = this._origin, s = t[0].dot(i) + a[e], o = s, l = s, u = 1; u < t.length; u++) {
        var c = t[u].dot(i) + a[e];
        o = Math.min(c, o), l = Math.max(c, l);
      }
      r[0] = o, r[1] = l;
    }, n;
  }(), cce = [], hce = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.notClear = true, t.incremental = true, t._displayables = [], t._temporaryDisplayables = [], t._cursor = 0, t;
    }
    return e.prototype.traverse = function(t, r) {
      t.call(r, this);
    }, e.prototype.useStyle = function() {
      this.style = {};
    }, e.prototype.getCursor = function() {
      return this._cursor;
    }, e.prototype.innerAfterBrush = function() {
      this._cursor = this._displayables.length;
    }, e.prototype.clearDisplaybles = function() {
      this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = false;
    }, e.prototype.clearTemporalDisplayables = function() {
      this._temporaryDisplayables = [];
    }, e.prototype.addDisplayable = function(t, r) {
      r ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw();
    }, e.prototype.addDisplayables = function(t, r) {
      r = r || false;
      for (var i = 0; i < t.length; i++) this.addDisplayable(t[i], r);
    }, e.prototype.getDisplayables = function() {
      return this._displayables;
    }, e.prototype.getTemporalDisplayables = function() {
      return this._temporaryDisplayables;
    }, e.prototype.eachPendingDisplayable = function(t) {
      for (var r = this._cursor; r < this._displayables.length; r++) t && t(this._displayables[r]);
      for (var r = 0; r < this._temporaryDisplayables.length; r++) t && t(this._temporaryDisplayables[r]);
    }, e.prototype.update = function() {
      this.updateTransform();
      for (var t = this._cursor; t < this._displayables.length; t++) {
        var r = this._displayables[t];
        r.parent = this, r.update(), r.parent = null;
      }
      for (var t = 0; t < this._temporaryDisplayables.length; t++) {
        var r = this._temporaryDisplayables[t];
        r.parent = this, r.update(), r.parent = null;
      }
    }, e.prototype.getBoundingRect = function() {
      if (!this._rect) {
        for (var t = new vt(1 / 0, 1 / 0, -1 / 0, -1 / 0), r = 0; r < this._displayables.length; r++) {
          var i = this._displayables[r], a = i.getBoundingRect().clone();
          i.needLocalTransform() && a.applyTransform(i.getLocalTransform(cce)), t.union(a);
        }
        this._rect = t;
      }
      return this._rect;
    }, e.prototype.contain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect();
      if (a.contain(i[0], i[1])) for (var s = 0; s < this._displayables.length; s++) {
        var o = this._displayables[s];
        if (o.contain(t, r)) return true;
      }
      return false;
    }, e;
  }(_s), O8 = Wt();
  function mm(n, e, t, r, i) {
    var a;
    if (e && e.ecModel) {
      var s = e.ecModel.getUpdatePayload();
      a = s && s.animation;
    }
    var o = e && e.isAnimationEnabled(), l = n === "update";
    if (o) {
      var u = void 0, c = void 0, h = void 0;
      r ? (u = it(r.duration, 200), c = it(r.easing, "cubicOut"), h = 0) : (u = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), Xe(h) && (h = h(t, i)), Xe(u) && (u = u(t));
      var d = {
        duration: u || 0,
        delay: h,
        easing: c
      };
      return d;
    } else return null;
  }
  function eE(n, e, t, r, i, a, s) {
    var o = false, l;
    Xe(i) ? (s = a, a = i, i = null) : Ze(i) && (a = i.cb, s = i.during, o = i.isFrom, l = i.removeOpt, i = i.dataIndex);
    var u = n === "leave";
    u || e.stopAnimation("leave");
    var c = mm(n, r, i, u ? l || {} : null, r && r.getAnimationDelayParams ? r.getAnimationDelayParams(e, i) : null);
    if (c && c.duration > 0) {
      var h = c.duration, d = c.delay, f = c.easing, p = {
        duration: h,
        delay: d || 0,
        easing: f,
        done: a,
        force: !!a || !!s,
        setToFinal: !u,
        scope: n,
        during: s
      };
      o ? e.animateFrom(t, p) : e.animateTo(t, p);
    } else e.stopAnimation(), !o && e.attr(t), s && s(1), a && a();
  }
  function Kt(n, e, t, r, i, a) {
    eE("update", n, e, t, r, i, a);
  }
  function Un(n, e, t, r, i, a) {
    eE("enter", n, e, t, r, i, a);
  }
  function _g(n) {
    if (!n.__zr) return true;
    for (var e = 0; e < n.animators.length; e++) {
      var t = n.animators[e];
      if (t.scope === "leave") return true;
    }
    return false;
  }
  function nc(n, e, t, r, i, a) {
    _g(n) || eE("leave", n, e, t, r, i, a);
  }
  function qF(n, e, t, r) {
    n.removeTextContent(), n.removeTextGuideLine(), nc(n, {
      style: {
        opacity: 0
      }
    }, e, t, r);
  }
  function E0(n, e, t) {
    function r() {
      n.parent && n.parent.remove(n);
    }
    n.isGroup ? n.traverse(function(i) {
      i.isGroup || qF(i, e, t, r);
    }) : qF(n, e, t, r);
  }
  function ro(n) {
    O8(n).oldStyle = n.style;
  }
  function dce(n) {
    return O8(n).oldStyle;
  }
  var V_ = Math.max, W_ = Math.min, XD = {};
  function fce(n) {
    return At.extend(n);
  }
  var pce = Yue;
  function gce(n, e) {
    return pce(n, e);
  }
  function ho(n, e) {
    XD[n] = e;
  }
  function tE(n) {
    if (XD.hasOwnProperty(n)) return XD[n];
  }
  function CC(n, e, t, r) {
    var i = E8(n, e);
    return t && (r === "center" && (t = z8(t, i.getBoundingRect())), V8(i, t)), i;
  }
  function B8(n, e, t) {
    var r = new oi({
      style: {
        image: n,
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      onload: function(i) {
        if (t === "center") {
          var a = {
            width: i.width,
            height: i.height
          };
          r.setStyle(z8(e, a));
        }
      }
    });
    return r;
  }
  function z8(n, e) {
    var t = e.width / e.height, r = n.height * t, i;
    r <= n.width ? i = n.height : (r = n.width, i = r / t);
    var a = n.x + n.width / 2, s = n.y + n.height / 2;
    return {
      x: a - r / 2,
      y: s - i / 2,
      width: r,
      height: i
    };
  }
  var ps = que;
  function V8(n, e) {
    if (n.applyTransform) {
      var t = n.getBoundingRect(), r = t.calculateTransform(e);
      n.applyTransform(r);
    }
  }
  function Mg(n, e) {
    return m8(n, n, {
      lineWidth: e
    }), n;
  }
  function mce(n) {
    return v8(n.shape, n.shape, n.style), n;
  }
  var i_ = Lh;
  function Jh(n, e) {
    for (var t = dC([]); n && n !== e; ) Ml(t, n.getLocalTransform(), t), n = n.parent;
    return t;
  }
  function Zs(n, e, t) {
    return e && !Mi(e) && (e = Tl.getLocalTransform(e)), t && (e = fm([], e)), di([], n, e);
  }
  function IC(n, e, t) {
    var r = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), i = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), a = [
      n === "left" ? -r : n === "right" ? r : 0,
      n === "top" ? -i : n === "bottom" ? i : 0
    ];
    return a = Zs(a, e, t), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
  }
  function jF(n) {
    return !n.isGroup;
  }
  function vce(n) {
    return n.shape != null;
  }
  function Lx(n, e, t) {
    if (!n || !e) return;
    function r(s) {
      var o = {};
      return s.traverse(function(l) {
        jF(l) && l.anid && (o[l.anid] = l);
      }), o;
    }
    function i(s) {
      var o = {
        x: s.x,
        y: s.y,
        rotation: s.rotation
      };
      return vce(s) && (o.shape = oe({}, s.shape)), o;
    }
    var a = r(n);
    e.traverse(function(s) {
      if (jF(s) && s.anid) {
        var o = a[s.anid];
        if (o) {
          var l = i(s);
          s.attr(i(o)), Kt(s, l, t, rt(s).dataIndex);
        }
      }
    });
  }
  function W8(n, e) {
    return me(n, function(t) {
      var r = t[0];
      r = V_(r, e.x), r = W_(r, e.x + e.width);
      var i = t[1];
      return i = V_(i, e.y), i = W_(i, e.y + e.height), [
        r,
        i
      ];
    });
  }
  function yce(n, e) {
    var t = V_(n.x, e.x), r = W_(n.x + n.width, e.x + e.width), i = V_(n.y, e.y), a = W_(n.y + n.height, e.y + e.height);
    if (r >= t && a >= i) return {
      x: t,
      y: i,
      width: r - t,
      height: a - i
    };
  }
  function Fx(n, e, t) {
    var r = oe({
      rectHover: true
    }, e), i = r.style = {
      strokeNoScale: true
    };
    if (t = t || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }, n) return n.indexOf("image://") === 0 ? (i.image = n.slice(8), je(i, t), new oi(r)) : CC(n.replace("path://", ""), r, t, "center");
  }
  function Ey(n, e, t, r, i) {
    for (var a = 0, s = i[i.length - 1]; a < i.length; a++) {
      var o = i[a];
      if (G8(n, e, t, r, o[0], o[1], s[0], s[1])) return true;
      s = o;
    }
  }
  function G8(n, e, t, r, i, a, s, o) {
    var l = t - n, u = r - e, c = s - i, h = o - a, d = hk(c, h, l, u);
    if (xce(d)) return false;
    var f = n - i, p = e - a, g = hk(f, p, l, u) / d;
    if (g < 0 || g > 1) return false;
    var m = hk(f, p, c, h) / d;
    return !(m < 0 || m > 1);
  }
  function hk(n, e, t, r) {
    return n * r - t * e;
  }
  function xce(n) {
    return n <= 1e-6 && n >= -1e-6;
  }
  function Pd(n) {
    var e = n.itemTooltipOption, t = n.componentModel, r = n.itemName, i = Ie(e) ? {
      formatter: e
    } : e, a = t.mainType, s = t.componentIndex, o = {
      componentType: a,
      name: r,
      $vars: [
        "name"
      ]
    };
    o[a + "Index"] = s;
    var l = n.formatterParamsExtra;
    l && P(Mt(l), function(c) {
      $e(o, c) || (o[c] = l[c], o.$vars.push(c));
    });
    var u = rt(n.el);
    u.componentMainType = a, u.componentIndex = s, u.tooltipConfig = {
      name: r,
      option: je({
        content: r,
        encodeHTMLContent: true,
        formatterParams: o
      }, i)
    };
  }
  function KF(n, e) {
    var t;
    n.isGroup && (t = e(n)), t || n.traverse(e);
  }
  function gc(n, e) {
    if (n) if (de(n)) for (var t = 0; t < n.length; t++) KF(n[t], e);
    else KF(n, e);
  }
  ho("circle", iu);
  ho("ellipse", _C);
  ho("sector", ra);
  ho("ring", Ex);
  ho("polygon", ia);
  ho("polyline", oa);
  ho("rect", Vt);
  ho("line", zr);
  ho("bezierCurve", Mx);
  ho("arc", SC);
  const Ld = Object.freeze(Object.defineProperty({
    __proto__: null,
    Arc: SC,
    BezierCurve: Mx,
    BoundingRect: vt,
    Circle: iu,
    CompoundPath: JN,
    Ellipse: _C,
    Group: tt,
    Image: oi,
    IncrementalDisplayable: hce,
    Line: zr,
    LinearGradient: Px,
    OrientedBoundingRect: z_,
    Path: At,
    Point: mt,
    Polygon: ia,
    Polyline: oa,
    RadialGradient: F8,
    Rect: Vt,
    Ring: Ex,
    Sector: ra,
    Text: Gt,
    applyTransform: Zs,
    clipPointsByRect: W8,
    clipRectByRect: yce,
    createIcon: Fx,
    extendPath: gce,
    extendShape: fce,
    getShapeClass: tE,
    getTransform: Jh,
    groupTransition: Lx,
    initProps: Un,
    isElementRemoved: _g,
    lineLineIntersect: G8,
    linePolygonIntersect: Ey,
    makeImage: B8,
    makePath: CC,
    mergePath: ps,
    registerShape: ho,
    removeElement: nc,
    removeElementWithFadeOut: E0,
    resizePath: V8,
    setTooltipConfig: Pd,
    subPixelOptimize: i_,
    subPixelOptimizeLine: Mg,
    subPixelOptimizeRect: mce,
    transformDirection: IC,
    traverseElements: gc,
    updateProps: Kt
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var kC = {};
  function U8(n, e) {
    for (var t = 0; t < na.length; t++) {
      var r = na[t], i = e[r], a = n.ensureState(r);
      a.style = a.style || {}, a.style.text = i;
    }
    var s = n.currentStates.slice();
    n.clearStates(true), n.setStyle({
      text: e.normal
    }), n.useStates(s, true);
  }
  function YD(n, e, t) {
    var r = n.labelFetcher, i = n.labelDataIndex, a = n.labelDimIndex, s = e.normal, o;
    r && (o = r.getFormattedLabel(i, "normal", null, a, s && s.get("formatter"), t != null ? {
      interpolatedValue: t
    } : null)), o == null && (o = Xe(n.defaultText) ? n.defaultText(i, n, t) : n.defaultText);
    for (var l = {
      normal: o
    }, u = 0; u < na.length; u++) {
      var c = na[u], h = e[c];
      l[c] = it(r ? r.getFormattedLabel(i, c, null, a, h && h.get("formatter")) : null, o);
    }
    return l;
  }
  function gi(n, e, t, r) {
    t = t || kC;
    for (var i = n instanceof Gt, a = false, s = 0; s < $0.length; s++) {
      var o = e[$0[s]];
      if (o && o.getShallow("show")) {
        a = true;
        break;
      }
    }
    var l = i ? n : n.getTextContent();
    if (a) {
      i || (l || (l = new Gt(), n.setTextContent(l)), n.stateProxy && (l.stateProxy = n.stateProxy));
      var u = YD(t, e), c = e.normal, h = !!c.getShallow("show"), d = $n(c, r && r.normal, t, false, !i);
      d.text = u.normal, i || n.setTextConfig(G_(c, t, false));
      for (var s = 0; s < na.length; s++) {
        var f = na[s], o = e[f];
        if (o) {
          var p = l.ensureState(f), g = !!it(o.getShallow("show"), h);
          if (g !== h && (p.ignore = !g), p.style = $n(o, r && r[f], t, true, !i), p.style.text = u[f], !i) {
            var m = n.ensureState(f);
            m.textConfig = G_(o, t, true);
          }
        }
      }
      l.silent = !!c.getShallow("silent"), l.style.x != null && (d.x = l.style.x), l.style.y != null && (d.y = l.style.y), l.ignore = !h, l.useStyle(d), l.dirty(), t.enableTextSetter && (vm(l).setLabelText = function(v) {
        var y = YD(t, e, v);
        U8(l, y);
      });
    } else l && (l.ignore = true);
    n.dirty();
  }
  function Hr(n, e) {
    e = e || "label";
    for (var t = {
      normal: n.getModel(e)
    }, r = 0; r < na.length; r++) {
      var i = na[r];
      t[i] = n.getModel([
        i,
        e
      ]);
    }
    return t;
  }
  function $n(n, e, t, r, i) {
    var a = {};
    return bce(a, n, t, r, i), e && oe(a, e), a;
  }
  function G_(n, e, t) {
    e = e || {};
    var r = {}, i, a = n.getShallow("rotate"), s = it(n.getShallow("distance"), t ? null : 5), o = n.getShallow("offset");
    return i = n.getShallow("position") || (t ? null : "inside"), i === "outside" && (i = e.defaultOutsidePosition || "top"), i != null && (r.position = i), o != null && (r.offset = o), a != null && (a *= Math.PI / 180, r.rotation = a), s != null && (r.distance = s), r.outsideFill = n.get("color") === "inherit" ? e.inheritColor || null : "auto", r;
  }
  function bce(n, e, t, r, i) {
    t = t || kC;
    var a = e.ecModel, s = a && a.option.textStyle, o = wce(e), l;
    if (o) {
      l = {};
      for (var u in o) if (o.hasOwnProperty(u)) {
        var c = e.getModel([
          "rich",
          u
        ]);
        eO(l[u] = {}, c, s, t, r, i, false, true);
      }
    }
    l && (n.rich = l);
    var h = e.get("overflow");
    h && (n.overflow = h);
    var d = e.get("minMargin");
    d != null && (n.margin = d), eO(n, e, s, t, r, i, true, false);
  }
  function wce(n) {
    for (var e; n && n !== n.ecModel; ) {
      var t = (n.option || kC).rich;
      if (t) {
        e = e || {};
        for (var r = Mt(t), i = 0; i < r.length; i++) {
          var a = r[i];
          e[a] = 1;
        }
      }
      n = n.parentModel;
    }
    return e;
  }
  var ZF = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "textShadowColor",
    "textShadowBlur",
    "textShadowOffsetX",
    "textShadowOffsetY"
  ], QF = [
    "align",
    "lineHeight",
    "width",
    "height",
    "tag",
    "verticalAlign",
    "ellipsis"
  ], JF = [
    "padding",
    "borderWidth",
    "borderRadius",
    "borderDashOffset",
    "backgroundColor",
    "borderColor",
    "shadowColor",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY"
  ];
  function eO(n, e, t, r, i, a, s, o) {
    t = !i && t || kC;
    var l = r && r.inheritColor, u = e.getShallow("color"), c = e.getShallow("textBorderColor"), h = it(e.getShallow("opacity"), t.opacity);
    (u === "inherit" || u === "auto") && (l ? u = l : u = null), (c === "inherit" || c === "auto") && (l ? c = l : c = null), a || (u = u || t.color, c = c || t.textBorderColor), u != null && (n.fill = u), c != null && (n.stroke = c);
    var d = it(e.getShallow("textBorderWidth"), t.textBorderWidth);
    d != null && (n.lineWidth = d);
    var f = it(e.getShallow("textBorderType"), t.textBorderType);
    f != null && (n.lineDash = f);
    var p = it(e.getShallow("textBorderDashOffset"), t.textBorderDashOffset);
    p != null && (n.lineDashOffset = p), !i && h == null && !o && (h = r && r.defaultOpacity), h != null && (n.opacity = h), !i && !a && n.fill == null && r.inheritColor && (n.fill = r.inheritColor);
    for (var g = 0; g < ZF.length; g++) {
      var m = ZF[g], v = it(e.getShallow(m), t[m]);
      v != null && (n[m] = v);
    }
    for (var g = 0; g < QF.length; g++) {
      var m = QF[g], v = e.getShallow(m);
      v != null && (n[m] = v);
    }
    if (n.verticalAlign == null) {
      var y = e.getShallow("baseline");
      y != null && (n.verticalAlign = y);
    }
    if (!s || !r.disableBox) {
      for (var g = 0; g < JF.length; g++) {
        var m = JF[g], v = e.getShallow(m);
        v != null && (n[m] = v);
      }
      var x = e.getShallow("borderType");
      x != null && (n.borderDash = x), (n.backgroundColor === "auto" || n.backgroundColor === "inherit") && l && (n.backgroundColor = l), (n.borderColor === "auto" || n.borderColor === "inherit") && l && (n.borderColor = l);
    }
  }
  function nE(n, e) {
    var t = e && e.getModel("textStyle");
    return Hs([
      n.fontStyle || t && t.getShallow("fontStyle") || "",
      n.fontWeight || t && t.getShallow("fontWeight") || "",
      (n.fontSize || t && t.getShallow("fontSize") || 12) + "px",
      n.fontFamily || t && t.getShallow("fontFamily") || "sans-serif"
    ].join(" "));
  }
  var vm = Wt();
  function H8(n, e, t, r) {
    if (n) {
      var i = vm(n);
      i.prevValue = i.value, i.value = t;
      var a = e.normal;
      i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = r, i.statesModels = e);
    }
  }
  function X8(n, e, t, r, i) {
    var a = vm(n);
    if (!a.valueAnimation || a.prevValue === a.value) return;
    var s = a.defaultInterpolatedText, o = it(a.interpolatedValue, a.prevValue), l = a.value;
    function u(c) {
      var h = l8(t, a.precision, o, l, c);
      a.interpolatedValue = c === 1 ? null : h;
      var d = YD({
        labelDataIndex: e,
        labelFetcher: i,
        defaultText: s ? s(h) : h + ""
      }, a.statesModels, h);
      U8(n, d);
    }
    n.percent = 0, (a.prevValue == null ? Un : Kt)(n, {
      percent: 1
    }, r, e, null, u);
  }
  var _ce = [
    "textStyle",
    "color"
  ], dk = [
    "fontStyle",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "padding",
    "lineHeight",
    "rich",
    "width",
    "height",
    "overflow"
  ], fk = new Gt(), Sce = function() {
    function n() {
    }
    return n.prototype.getTextColor = function(e) {
      var t = this.ecModel;
      return this.getShallow("color") || (!e && t ? t.get(_ce) : null);
    }, n.prototype.getFont = function() {
      return nE({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, n.prototype.getTextRect = function(e) {
      for (var t = {
        text: e,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, r = 0; r < dk.length; r++) t[dk[r]] = this.getShallow(dk[r]);
      return fk.useStyle(t), fk.update(), fk.getBoundingRect();
    }, n;
  }(), Y8 = [
    [
      "lineWidth",
      "width"
    ],
    [
      "stroke",
      "color"
    ],
    [
      "opacity"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ],
    [
      "lineDash",
      "type"
    ],
    [
      "lineDashOffset",
      "dashOffset"
    ],
    [
      "lineCap",
      "cap"
    ],
    [
      "lineJoin",
      "join"
    ],
    [
      "miterLimit"
    ]
  ], Cce = hd(Y8), Ice = function() {
    function n() {
    }
    return n.prototype.getLineStyle = function(e) {
      return Cce(this, e);
    }, n;
  }(), q8 = [
    [
      "fill",
      "color"
    ],
    [
      "stroke",
      "borderColor"
    ],
    [
      "lineWidth",
      "borderWidth"
    ],
    [
      "opacity"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ],
    [
      "lineDash",
      "borderType"
    ],
    [
      "lineDashOffset",
      "borderDashOffset"
    ],
    [
      "lineCap",
      "borderCap"
    ],
    [
      "lineJoin",
      "borderJoin"
    ],
    [
      "miterLimit",
      "borderMiterLimit"
    ]
  ], kce = hd(q8), Tce = function() {
    function n() {
    }
    return n.prototype.getItemStyle = function(e, t) {
      return kce(this, e, t);
    }, n;
  }(), on = function() {
    function n(e, t, r) {
      this.parentModel = t, this.ecModel = r, this.option = e;
    }
    return n.prototype.init = function(e, t, r) {
    }, n.prototype.mergeOption = function(e, t) {
      pt(this.option, e, true);
    }, n.prototype.get = function(e, t) {
      return e == null ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel);
    }, n.prototype.getShallow = function(e, t) {
      var r = this.option, i = r == null ? r : r[e];
      if (i == null && !t) {
        var a = this.parentModel;
        a && (i = a.getShallow(e));
      }
      return i;
    }, n.prototype.getModel = function(e, t) {
      var r = e != null, i = r ? this.parsePath(e) : null, a = r ? this._doGet(i) : this.option;
      return t = t || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new n(a, t, this.ecModel);
    }, n.prototype.isEmpty = function() {
      return this.option == null;
    }, n.prototype.restoreData = function() {
    }, n.prototype.clone = function() {
      var e = this.constructor;
      return new e(Qe(this.option));
    }, n.prototype.parsePath = function(e) {
      return typeof e == "string" ? e.split(".") : e;
    }, n.prototype.resolveParentPath = function(e) {
      return e;
    }, n.prototype.isAnimationEnabled = function() {
      if (!Dt.node && this.option) {
        if (this.option.animation != null) return !!this.option.animation;
        if (this.parentModel) return this.parentModel.isAnimationEnabled();
      }
    }, n.prototype._doGet = function(e, t) {
      var r = this.option;
      if (!e) return r;
      for (var i = 0; i < e.length && !(e[i] && (r = r && typeof r == "object" ? r[e[i]] : null, r == null)); i++) ;
      return r == null && t && (r = t._doGet(this.resolveParentPath(e), t.parentModel)), r;
    }, n;
  }();
  UN(on);
  Lle(on);
  br(on, Ice);
  br(on, Tce);
  br(on, Vle);
  br(on, Sce);
  var Ace = Math.round(Math.random() * 10);
  function ym(n) {
    return [
      n || "",
      Ace++
    ].join("_");
  }
  function Dce(n) {
    var e = {};
    n.registerSubTypeDefaulter = function(t, r) {
      var i = Bo(t);
      e[i.main] = r;
    }, n.determineSubType = function(t, r) {
      var i = r.type;
      if (!i) {
        var a = Bo(t).main;
        n.hasSubTypes(t) && e[a] && (i = e[a](r));
      }
      return i;
    };
  }
  function Rce(n, e) {
    n.topologicalTravel = function(a, s, o, l) {
      if (!a.length) return;
      var u = t(s), c = u.graph, h = u.noEntryList, d = {};
      for (P(a, function(y) {
        d[y] = true;
      }); h.length; ) {
        var f = h.pop(), p = c[f], g = !!d[f];
        g && (o.call(l, f, p.originalDeps.slice()), delete d[f]), P(p.successor, g ? v : m);
      }
      P(d, function() {
        var y = "";
        throw new Error(y);
      });
      function m(y) {
        c[y].entryCount--, c[y].entryCount === 0 && h.push(y);
      }
      function v(y) {
        d[y] = true, m(y);
      }
    };
    function t(a) {
      var s = {}, o = [];
      return P(a, function(l) {
        var u = r(s, l), c = u.originalDeps = e(l), h = i(c, a);
        u.entryCount = h.length, u.entryCount === 0 && o.push(l), P(h, function(d) {
          bt(u.predecessor, d) < 0 && u.predecessor.push(d);
          var f = r(s, d);
          bt(f.successor, d) < 0 && f.successor.push(l);
        });
      }), {
        graph: s,
        noEntryList: o
      };
    }
    function r(a, s) {
      return a[s] || (a[s] = {
        predecessor: [],
        successor: []
      }), a[s];
    }
    function i(a, s) {
      var o = [];
      return P(a, function(l) {
        bt(s, l) >= 0 && o.push(l);
      }), o;
    }
  }
  function mc(n, e) {
    return pt(pt({}, n, true), e, true);
  }
  const $ce = {
    time: {
      month: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ],
      monthAbbr: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      dayOfWeek: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ],
      dayOfWeekAbbr: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ]
    },
    legend: {
      selector: {
        all: "All",
        inverse: "Inv"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "Box Select",
          polygon: "Lasso Select",
          lineX: "Horizontally Select",
          lineY: "Vertically Select",
          keep: "Keep Selections",
          clear: "Clear Selections"
        }
      },
      dataView: {
        title: "Data View",
        lang: [
          "Data View",
          "Close",
          "Refresh"
        ]
      },
      dataZoom: {
        title: {
          zoom: "Zoom",
          back: "Zoom Reset"
        }
      },
      magicType: {
        title: {
          line: "Switch to Line Chart",
          bar: "Switch to Bar Chart",
          stack: "Stack",
          tiled: "Tile"
        }
      },
      restore: {
        title: "Restore"
      },
      saveAsImage: {
        title: "Save as Image",
        lang: [
          "Right Click to Save Image"
        ]
      }
    },
    series: {
      typeNames: {
        pie: "Pie chart",
        bar: "Bar chart",
        line: "Line chart",
        scatter: "Scatter plot",
        effectScatter: "Ripple scatter plot",
        radar: "Radar chart",
        tree: "Tree",
        treemap: "Treemap",
        boxplot: "Boxplot",
        candlestick: "Candlestick",
        k: "K line chart",
        heatmap: "Heat map",
        map: "Map",
        parallel: "Parallel coordinate map",
        lines: "Line graph",
        graph: "Relationship graph",
        sankey: "Sankey diagram",
        funnel: "Funnel chart",
        gauge: "Gauge",
        pictorialBar: "Pictorial bar",
        themeRiver: "Theme River Map",
        sunburst: "Sunburst",
        custom: "Custom chart",
        chart: "Chart"
      }
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: "This is a chart"
      },
      series: {
        single: {
          prefix: "",
          withName: " with type {seriesType} named {seriesName}.",
          withoutName: " with type {seriesType}."
        },
        multiple: {
          prefix: ". It consists of {seriesCount} series count.",
          withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
          withoutName: " The {seriesId} series is a {seriesType}.",
          separator: {
            middle: "",
            end: ""
          }
        }
      },
      data: {
        allData: "The data is as follows: ",
        partialData: "The first {displayCnt} items are: ",
        withName: "the data for {name} is {value}",
        withoutName: "{value}",
        separator: {
          middle: ", ",
          end: ". "
        }
      }
    }
  }, Nce = {
    time: {
      month: [
        "\u4E00\u6708",
        "\u4E8C\u6708",
        "\u4E09\u6708",
        "\u56DB\u6708",
        "\u4E94\u6708",
        "\u516D\u6708",
        "\u4E03\u6708",
        "\u516B\u6708",
        "\u4E5D\u6708",
        "\u5341\u6708",
        "\u5341\u4E00\u6708",
        "\u5341\u4E8C\u6708"
      ],
      monthAbbr: [
        "1\u6708",
        "2\u6708",
        "3\u6708",
        "4\u6708",
        "5\u6708",
        "6\u6708",
        "7\u6708",
        "8\u6708",
        "9\u6708",
        "10\u6708",
        "11\u6708",
        "12\u6708"
      ],
      dayOfWeek: [
        "\u661F\u671F\u65E5",
        "\u661F\u671F\u4E00",
        "\u661F\u671F\u4E8C",
        "\u661F\u671F\u4E09",
        "\u661F\u671F\u56DB",
        "\u661F\u671F\u4E94",
        "\u661F\u671F\u516D"
      ],
      dayOfWeekAbbr: [
        "\u65E5",
        "\u4E00",
        "\u4E8C",
        "\u4E09",
        "\u56DB",
        "\u4E94",
        "\u516D"
      ]
    },
    legend: {
      selector: {
        all: "\u5168\u9009",
        inverse: "\u53CD\u9009"
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: "\u77E9\u5F62\u9009\u62E9",
          polygon: "\u5708\u9009",
          lineX: "\u6A2A\u5411\u9009\u62E9",
          lineY: "\u7EB5\u5411\u9009\u62E9",
          keep: "\u4FDD\u6301\u9009\u62E9",
          clear: "\u6E05\u9664\u9009\u62E9"
        }
      },
      dataView: {
        title: "\u6570\u636E\u89C6\u56FE",
        lang: [
          "\u6570\u636E\u89C6\u56FE",
          "\u5173\u95ED",
          "\u5237\u65B0"
        ]
      },
      dataZoom: {
        title: {
          zoom: "\u533A\u57DF\u7F29\u653E",
          back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
        }
      },
      magicType: {
        title: {
          line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
          bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
          stack: "\u5207\u6362\u4E3A\u5806\u53E0",
          tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
        }
      },
      restore: {
        title: "\u8FD8\u539F"
      },
      saveAsImage: {
        title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
        lang: [
          "\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"
        ]
      }
    },
    series: {
      typeNames: {
        pie: "\u997C\u56FE",
        bar: "\u67F1\u72B6\u56FE",
        line: "\u6298\u7EBF\u56FE",
        scatter: "\u6563\u70B9\u56FE",
        effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
        radar: "\u96F7\u8FBE\u56FE",
        tree: "\u6811\u56FE",
        treemap: "\u77E9\u5F62\u6811\u56FE",
        boxplot: "\u7BB1\u578B\u56FE",
        candlestick: "K\u7EBF\u56FE",
        k: "K\u7EBF\u56FE",
        heatmap: "\u70ED\u529B\u56FE",
        map: "\u5730\u56FE",
        parallel: "\u5E73\u884C\u5750\u6807\u56FE",
        lines: "\u7EBF\u56FE",
        graph: "\u5173\u7CFB\u56FE",
        sankey: "\u6851\u57FA\u56FE",
        funnel: "\u6F0F\u6597\u56FE",
        gauge: "\u4EEA\u8868\u76D8\u56FE",
        pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
        themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
        sunburst: "\u65ED\u65E5\u56FE",
        custom: "\u81EA\u5B9A\u4E49\u56FE\u8868",
        chart: "\u56FE\u8868"
      }
    },
    aria: {
      general: {
        withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
        withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
      },
      series: {
        single: {
          prefix: "",
          withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
          withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
        },
        multiple: {
          prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
          withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
          withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
          separator: {
            middle: "\uFF1B",
            end: "\u3002"
          }
        }
      },
      data: {
        allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
        partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
        withName: "{name}\u7684\u6570\u636E\u662F{value}",
        withoutName: "{value}",
        separator: {
          middle: "\uFF0C",
          end: ""
        }
      }
    }
  };
  var U_ = "ZH", rE = "EN", Sg = rE, a_ = {}, iE = {}, j8 = Dt.domSupported ? function() {
    var n = (document.documentElement.lang || navigator.language || navigator.browserLanguage || Sg).toUpperCase();
    return n.indexOf(U_) > -1 ? U_ : Sg;
  }() : Sg;
  function K8(n, e) {
    n = n.toUpperCase(), iE[n] = new on(e), a_[n] = e;
  }
  function Ece(n) {
    if (Ie(n)) {
      var e = a_[n.toUpperCase()] || {};
      return n === U_ || n === rE ? Qe(e) : pt(Qe(e), Qe(a_[Sg]), false);
    } else return pt(Qe(n), Qe(a_[Sg]), false);
  }
  function qD(n) {
    return iE[n];
  }
  function Mce() {
    return iE[Sg];
  }
  K8(rE, $ce);
  K8(U_, Nce);
  var aE = 1e3, sE = aE * 60, l0 = sE * 60, gs = l0 * 24, tO = gs * 365, My = {
    year: "{yyyy}",
    month: "{MMM}",
    day: "{d}",
    hour: "{HH}:{mm}",
    minute: "{HH}:{mm}",
    second: "{HH}:{mm}:{ss}",
    millisecond: "{HH}:{mm}:{ss} {SSS}",
    none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
  }, D1 = "{yyyy}-{MM}-{dd}", nO = {
    year: "{yyyy}",
    month: "{yyyy}-{MM}",
    day: D1,
    hour: D1 + " " + My.hour,
    minute: D1 + " " + My.minute,
    second: D1 + " " + My.second,
    millisecond: My.none
  }, pk = [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ], Z8 = [
    "year",
    "half-year",
    "quarter",
    "month",
    "week",
    "half-week",
    "day",
    "half-day",
    "quarter-day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  function mu(n, e) {
    return n += "", "0000".substr(0, e - n.length) + n;
  }
  function Cg(n) {
    switch (n) {
      case "half-year":
      case "quarter":
        return "month";
      case "week":
      case "half-week":
        return "day";
      case "half-day":
      case "quarter-day":
        return "hour";
      default:
        return n;
    }
  }
  function Pce(n) {
    return n === Cg(n);
  }
  function Lce(n) {
    switch (n) {
      case "year":
      case "month":
        return "day";
      case "millisecond":
        return "millisecond";
      default:
        return "second";
    }
  }
  function TC(n, e, t, r) {
    var i = tl(n), a = i[oE(t)](), s = i[Ig(t)]() + 1, o = Math.floor((s - 1) / 3) + 1, l = i[AC(t)](), u = i["get" + (t ? "UTC" : "") + "Day"](), c = i[M0(t)](), h = (c - 1) % 12 + 1, d = i[DC(t)](), f = i[RC(t)](), p = i[$C(t)](), g = c >= 12 ? "pm" : "am", m = g.toUpperCase(), v = r instanceof on ? r : qD(r || j8) || Mce(), y = v.getModel("time"), x = y.get("month"), b = y.get("monthAbbr"), w = y.get("dayOfWeek"), _ = y.get("dayOfWeekAbbr");
    return (e || "").replace(/{a}/g, g + "").replace(/{A}/g, m + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, mu(a % 100 + "", 2)).replace(/{Q}/g, o + "").replace(/{MMMM}/g, x[s - 1]).replace(/{MMM}/g, b[s - 1]).replace(/{MM}/g, mu(s, 2)).replace(/{M}/g, s + "").replace(/{dd}/g, mu(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, w[u]).replace(/{ee}/g, _[u]).replace(/{e}/g, u + "").replace(/{HH}/g, mu(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, mu(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, mu(d, 2)).replace(/{m}/g, d + "").replace(/{ss}/g, mu(f, 2)).replace(/{s}/g, f + "").replace(/{SSS}/g, mu(p, 3)).replace(/{S}/g, p + "");
  }
  function Fce(n, e, t, r, i) {
    var a = null;
    if (Ie(t)) a = t;
    else if (Xe(t)) a = t(n.value, e, {
      level: n.level
    });
    else {
      var s = oe({}, My);
      if (n.level > 0) for (var o = 0; o < pk.length; ++o) s[pk[o]] = "{primary|" + s[pk[o]] + "}";
      var l = t ? t.inherit === false ? t : je(t, s) : s, u = Q8(n.value, i);
      if (l[u]) a = l[u];
      else if (l.inherit) {
        for (var c = Z8.indexOf(u), o = c - 1; o >= 0; --o) if (l[u]) {
          a = l[u];
          break;
        }
        a = a || s.none;
      }
      if (de(a)) {
        var h = n.level == null ? 0 : n.level >= 0 ? n.level : a.length + n.level;
        h = Math.min(h, a.length - 1), a = a[h];
      }
    }
    return TC(new Date(n.value), a, i, r);
  }
  function Q8(n, e) {
    var t = tl(n), r = t[Ig(e)]() + 1, i = t[AC(e)](), a = t[M0(e)](), s = t[DC(e)](), o = t[RC(e)](), l = t[$C(e)](), u = l === 0, c = u && o === 0, h = c && s === 0, d = h && a === 0, f = d && i === 1, p = f && r === 1;
    return p ? "year" : f ? "month" : d ? "day" : h ? "hour" : c ? "minute" : u ? "second" : "millisecond";
  }
  function rO(n, e, t) {
    var r = Yt(n) ? tl(n) : n;
    switch (e = e || Q8(n, t), e) {
      case "year":
        return r[oE(t)]();
      case "half-year":
        return r[Ig(t)]() >= 6 ? 1 : 0;
      case "quarter":
        return Math.floor((r[Ig(t)]() + 1) / 4);
      case "month":
        return r[Ig(t)]();
      case "day":
        return r[AC(t)]();
      case "half-day":
        return r[M0(t)]() / 24;
      case "hour":
        return r[M0(t)]();
      case "minute":
        return r[DC(t)]();
      case "second":
        return r[RC(t)]();
      case "millisecond":
        return r[$C(t)]();
    }
  }
  function oE(n) {
    return n ? "getUTCFullYear" : "getFullYear";
  }
  function Ig(n) {
    return n ? "getUTCMonth" : "getMonth";
  }
  function AC(n) {
    return n ? "getUTCDate" : "getDate";
  }
  function M0(n) {
    return n ? "getUTCHours" : "getHours";
  }
  function DC(n) {
    return n ? "getUTCMinutes" : "getMinutes";
  }
  function RC(n) {
    return n ? "getUTCSeconds" : "getSeconds";
  }
  function $C(n) {
    return n ? "getUTCMilliseconds" : "getMilliseconds";
  }
  function Oce(n) {
    return n ? "setUTCFullYear" : "setFullYear";
  }
  function J8(n) {
    return n ? "setUTCMonth" : "setMonth";
  }
  function eX(n) {
    return n ? "setUTCDate" : "setDate";
  }
  function tX(n) {
    return n ? "setUTCHours" : "setHours";
  }
  function nX(n) {
    return n ? "setUTCMinutes" : "setMinutes";
  }
  function rX(n) {
    return n ? "setUTCSeconds" : "setSeconds";
  }
  function iX(n) {
    return n ? "setUTCMilliseconds" : "setMilliseconds";
  }
  function aX(n) {
    if (!e8(n)) return Ie(n) ? n : "-";
    var e = (n + "").split(".");
    return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "");
  }
  function sX(n, e) {
    return n = (n || "").toLowerCase().replace(/-(.)/g, function(t, r) {
      return r.toUpperCase();
    }), e && n && (n = n.charAt(0).toUpperCase() + n.slice(1)), n;
  }
  var xm = MN;
  function jD(n, e, t) {
    var r = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
    function i(c) {
      return c && Hs(c) ? c : "-";
    }
    function a(c) {
      return !!(c != null && !isNaN(c) && isFinite(c));
    }
    var s = e === "time", o = n instanceof Date;
    if (s || o) {
      var l = s ? tl(n) : n;
      if (isNaN(+l)) {
        if (o) return "-";
      } else return TC(l, r, t);
    }
    if (e === "ordinal") return fD(n) ? i(n) : Yt(n) && a(n) ? n + "" : "-";
    var u = Hl(n);
    return a(u) ? aX(u) : fD(n) ? i(n) : typeof n == "boolean" ? n + "" : "-";
  }
  var iO = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g"
  ], gk = function(n, e) {
    return "{" + n + (e ?? "") + "}";
  };
  function oX(n, e, t) {
    de(e) || (e = [
      e
    ]);
    var r = e.length;
    if (!r) return "";
    for (var i = e[0].$vars || [], a = 0; a < i.length; a++) {
      var s = iO[a];
      n = n.replace(gk(s), gk(s, 0));
    }
    for (var o = 0; o < r; o++) for (var l = 0; l < i.length; l++) {
      var u = e[o][i[l]];
      n = n.replace(gk(iO[l], o), t ? Hi(u) : u);
    }
    return n;
  }
  function Bce(n, e, t) {
    return P(e, function(r, i) {
      n = n.replace("{" + i + "}", r);
    }), n;
  }
  function zce(n, e) {
    var t = Ie(n) ? {
      color: n,
      extraCssText: e
    } : n || {}, r = t.color, i = t.type;
    e = t.extraCssText;
    var a = t.renderMode || "html";
    if (!r) return "";
    if (a === "html") return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Hi(r) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Hi(r) + ";" + (e || "") + '"></span>';
    var s = t.markerId || "markerX";
    return {
      renderMode: a,
      content: "{" + s + "|}  ",
      style: i === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: r
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: r
      }
    };
  }
  function fd(n, e) {
    return e = e || "transparent", Ie(n) ? n : Ze(n) && n.colorStops && (n.colorStops[0] || {}).color || e;
  }
  function H_(n, e) {
    if (e === "_blank" || e === "blank") {
      var t = window.open();
      t.opener = null, t.location.href = n;
    } else window.open(n, e);
  }
  var s_ = P, lX = [
    "left",
    "right",
    "top",
    "bottom",
    "width",
    "height"
  ], Oh = [
    [
      "width",
      "left",
      "right"
    ],
    [
      "height",
      "top",
      "bottom"
    ]
  ];
  function lE(n, e, t, r, i) {
    var a = 0, s = 0;
    r == null && (r = 1 / 0), i == null && (i = 1 / 0);
    var o = 0;
    e.eachChild(function(l, u) {
      var c = l.getBoundingRect(), h = e.childAt(u + 1), d = h && h.getBoundingRect(), f, p;
      if (n === "horizontal") {
        var g = c.width + (d ? -d.x + c.x : 0);
        f = a + g, f > r || l.newline ? (a = 0, f = g, s += o + t, o = c.height) : o = Math.max(o, c.height);
      } else {
        var m = c.height + (d ? -d.y + c.y : 0);
        p = s + m, p > i || l.newline ? (a += o + t, s = 0, p = m, o = c.width) : o = Math.max(o, c.width);
      }
      l.newline || (l.x = a, l.y = s, l.markRedraw(), n === "horizontal" ? a = f + t : s = p + t);
    });
  }
  var ed = lE;
  lt(lE, "vertical");
  lt(lE, "horizontal");
  function Vce(n, e, t) {
    var r = e.width, i = e.height, a = _e(n.left, r), s = _e(n.top, i), o = _e(n.right, r), l = _e(n.bottom, i);
    return (isNaN(a) || isNaN(parseFloat(n.left))) && (a = 0), (isNaN(o) || isNaN(parseFloat(n.right))) && (o = r), (isNaN(s) || isNaN(parseFloat(n.top))) && (s = 0), (isNaN(l) || isNaN(parseFloat(n.bottom))) && (l = i), t = xm(t || 0), {
      width: Math.max(o - a - t[1] - t[3], 0),
      height: Math.max(l - s - t[0] - t[2], 0)
    };
  }
  function Er(n, e, t) {
    t = xm(t || 0);
    var r = e.width, i = e.height, a = _e(n.left, r), s = _e(n.top, i), o = _e(n.right, r), l = _e(n.bottom, i), u = _e(n.width, r), c = _e(n.height, i), h = t[2] + t[0], d = t[1] + t[3], f = n.aspect;
    switch (isNaN(u) && (u = r - o - d - a), isNaN(c) && (c = i - l - h - s), f != null && (isNaN(u) && isNaN(c) && (f > r / i ? u = r * 0.8 : c = i * 0.8), isNaN(u) && (u = f * c), isNaN(c) && (c = u / f)), isNaN(a) && (a = r - o - u - d), isNaN(s) && (s = i - l - c - h), n.left || n.right) {
      case "center":
        a = r / 2 - u / 2 - t[3];
        break;
      case "right":
        a = r - u - d;
        break;
    }
    switch (n.top || n.bottom) {
      case "middle":
      case "center":
        s = i / 2 - c / 2 - t[0];
        break;
      case "bottom":
        s = i - c - h;
        break;
    }
    a = a || 0, s = s || 0, isNaN(u) && (u = r - d - a - (o || 0)), isNaN(c) && (c = i - h - s - (l || 0));
    var p = new vt(a + t[3], s + t[0], u, c);
    return p.margin = t, p;
  }
  function NC(n, e, t, r, i, a) {
    var s = !i || !i.hv || i.hv[0], o = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
    if (a = a || n, a.x = n.x, a.y = n.y, !s && !o) return false;
    var u;
    if (l === "raw") u = n.type === "group" ? new vt(0, 0, +e.width || 0, +e.height || 0) : n.getBoundingRect();
    else if (u = n.getBoundingRect(), n.needLocalTransform()) {
      var c = n.getLocalTransform();
      u = u.clone(), u.applyTransform(c);
    }
    var h = Er(je({
      width: u.width,
      height: u.height
    }, e), t, r), d = s ? h.x - u.x : 0, f = o ? h.y - u.y : 0;
    return l === "raw" ? (a.x = d, a.y = f) : (a.x += d, a.y += f), a === n && n.markRedraw(), true;
  }
  function Wce(n, e) {
    return n[Oh[e][0]] != null || n[Oh[e][1]] != null && n[Oh[e][2]] != null;
  }
  function P0(n) {
    var e = n.layoutMode || n.constructor.layoutMode;
    return Ze(e) ? e : e ? {
      type: e
    } : null;
  }
  function rc(n, e, t) {
    var r = t && t.ignoreSize;
    !de(r) && (r = [
      r,
      r
    ]);
    var i = s(Oh[0], 0), a = s(Oh[1], 1);
    u(Oh[0], n, i), u(Oh[1], n, a);
    function s(c, h) {
      var d = {}, f = 0, p = {}, g = 0, m = 2;
      if (s_(c, function(x) {
        p[x] = n[x];
      }), s_(c, function(x) {
        o(e, x) && (d[x] = p[x] = e[x]), l(d, x) && f++, l(p, x) && g++;
      }), r[h]) return l(e, c[1]) ? p[c[2]] = null : l(e, c[2]) && (p[c[1]] = null), p;
      if (g === m || !f) return p;
      if (f >= m) return d;
      for (var v = 0; v < c.length; v++) {
        var y = c[v];
        if (!o(d, y) && o(n, y)) {
          d[y] = n[y];
          break;
        }
      }
      return d;
    }
    function o(c, h) {
      return c.hasOwnProperty(h);
    }
    function l(c, h) {
      return c[h] != null && c[h] !== "auto";
    }
    function u(c, h, d) {
      s_(c, function(f) {
        h[f] = d[f];
      });
    }
  }
  function bm(n) {
    return uX({}, n);
  }
  function uX(n, e) {
    return e && n && s_(lX, function(t) {
      e.hasOwnProperty(t) && (n[t] = e[t]);
    }), n;
  }
  var Gce = Wt(), Et = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this, t, r, i) || this;
      return a.uid = ym("ec_cpt_model"), a;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.mergeDefaultAndTheme = function(t, r) {
      var i = P0(this), a = i ? bm(t) : {}, s = r.getTheme();
      pt(t, s.get(this.mainType)), pt(t, this.getDefaultOption()), i && rc(t, a, i);
    }, e.prototype.mergeOption = function(t, r) {
      pt(this.option, t, true);
      var i = P0(this);
      i && rc(this.option, t, i);
    }, e.prototype.optionUpdated = function(t, r) {
    }, e.prototype.getDefaultOption = function() {
      var t = this.constructor;
      if (!Ele(t)) return t.defaultOption;
      var r = Gce(this);
      if (!r.defaultOption) {
        for (var i = [], a = t; a; ) {
          var s = a.prototype.defaultOption;
          s && i.push(s), a = a.superClass;
        }
        for (var o = {}, l = i.length - 1; l >= 0; l--) o = pt(o, i[l], true);
        r.defaultOption = o;
      }
      return r.defaultOption;
    }, e.prototype.getReferringComponents = function(t, r) {
      var i = t + "Index", a = t + "Id";
      return $x(this.ecModel, t, {
        index: this.get(i, true),
        id: this.get(a, true)
      }, r);
    }, e.prototype.getBoxLayoutParams = function() {
      var t = this;
      return {
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      };
    }, e.prototype.getZLevelKey = function() {
      return "";
    }, e.prototype.setZLevel = function(t) {
      this.option.zlevel = t;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0;
    }(), e;
  }(on);
  c8(Et, on);
  mC(Et);
  Dce(Et);
  Rce(Et, Uce);
  function Uce(n) {
    var e = [];
    return P(Et.getClassesByMainType(n), function(t) {
      e = e.concat(t.dependencies || t.prototype.dependencies || []);
    }), e = me(e, function(t) {
      return Bo(t).main;
    }), n !== "dataset" && bt(e, "dataset") <= 0 && e.unshift("dataset"), e;
  }
  var cX = "";
  typeof navigator < "u" && (cX = navigator.platform || "");
  var $p = "rgba(0, 0, 0, 0.2)";
  const Hce = {
    darkMode: "auto",
    colorBy: "series",
    color: [
      "#5470c6",
      "#91cc75",
      "#fac858",
      "#ee6666",
      "#73c0de",
      "#3ba272",
      "#fc8452",
      "#9a60b4",
      "#ea7ccc"
    ],
    gradientColor: [
      "#f6efa6",
      "#d88273",
      "#bf444c"
    ],
    aria: {
      decal: {
        decals: [
          {
            color: $p,
            dashArrayX: [
              1,
              0
            ],
            dashArrayY: [
              2,
              5
            ],
            symbolSize: 1,
            rotation: Math.PI / 6
          },
          {
            color: $p,
            symbol: "circle",
            dashArrayX: [
              [
                8,
                8
              ],
              [
                0,
                8,
                8,
                0
              ]
            ],
            dashArrayY: [
              6,
              0
            ],
            symbolSize: 0.8
          },
          {
            color: $p,
            dashArrayX: [
              1,
              0
            ],
            dashArrayY: [
              4,
              3
            ],
            rotation: -Math.PI / 4
          },
          {
            color: $p,
            dashArrayX: [
              [
                6,
                6
              ],
              [
                0,
                6,
                6,
                0
              ]
            ],
            dashArrayY: [
              6,
              0
            ]
          },
          {
            color: $p,
            dashArrayX: [
              [
                1,
                0
              ],
              [
                1,
                6
              ]
            ],
            dashArrayY: [
              1,
              0,
              6,
              0
            ],
            rotation: Math.PI / 4
          },
          {
            color: $p,
            symbol: "triangle",
            dashArrayX: [
              [
                9,
                9
              ],
              [
                0,
                9,
                9,
                0
              ]
            ],
            dashArrayY: [
              7,
              2
            ],
            symbolSize: 0.75
          }
        ]
      }
    },
    textStyle: {
      fontFamily: cX.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
      fontSize: 12,
      fontStyle: "normal",
      fontWeight: "normal"
    },
    blendMode: null,
    stateAnimation: {
      duration: 300,
      easing: "cubicOut"
    },
    animation: "auto",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut",
    animationEasingUpdate: "cubicInOut",
    animationThreshold: 2e3,
    progressiveThreshold: 3e3,
    progressive: 400,
    hoverLayerThreshold: 3e3,
    useUTC: false
  };
  var hX = Pe([
    "tooltip",
    "label",
    "itemName",
    "itemId",
    "itemGroupId",
    "itemChildGroupId",
    "seriesName"
  ]), ks = "original", Pi = "arrayRows", Ts = "objectRows", ul = "keyedColumns", Xu = "typedArray", dX = "unknown", Ho = "column", wm = "row", ci = {
    Must: 1,
    Might: 2,
    Not: 3
  }, fX = Wt();
  function Xce(n) {
    fX(n).datasetMap = Pe();
  }
  function pX(n, e, t) {
    var r = {}, i = cE(e);
    if (!i || !n) return r;
    var a = [], s = [], o = e.ecModel, l = fX(o).datasetMap, u = i.uid + "_" + t.seriesLayoutBy, c, h;
    n = n.slice(), P(n, function(g, m) {
      var v = Ze(g) ? g : n[m] = {
        name: g
      };
      v.type === "ordinal" && c == null && (c = m, h = p(v)), r[v.name] = [];
    });
    var d = l.get(u) || l.set(u, {
      categoryWayDim: h,
      valueWayDim: 0
    });
    P(n, function(g, m) {
      var v = g.name, y = p(g);
      if (c == null) {
        var x = d.valueWayDim;
        f(r[v], x, y), f(s, x, y), d.valueWayDim += y;
      } else if (c === m) f(r[v], 0, y), f(a, 0, y);
      else {
        var x = d.categoryWayDim;
        f(r[v], x, y), f(s, x, y), d.categoryWayDim += y;
      }
    });
    function f(g, m, v) {
      for (var y = 0; y < v; y++) g.push(m + y);
    }
    function p(g) {
      var m = g.dimsDef;
      return m ? m.length : 1;
    }
    return a.length && (r.itemName = a), s.length && (r.seriesName = s), r;
  }
  function uE(n, e, t) {
    var r = {}, i = cE(n);
    if (!i) return r;
    var a = e.sourceFormat, s = e.dimensionsDefine, o;
    (a === Ts || a === ul) && P(s, function(c, h) {
      (Ze(c) ? c.name : c) === "name" && (o = h);
    });
    var l = function() {
      for (var c = {}, h = {}, d = [], f = 0, p = Math.min(5, t); f < p; f++) {
        var g = mX(e.data, a, e.seriesLayoutBy, s, e.startIndex, f);
        d.push(g);
        var m = g === ci.Not;
        if (m && c.v == null && f !== o && (c.v = f), (c.n == null || c.n === c.v || !m && d[c.n] === ci.Not) && (c.n = f), v(c) && d[c.n] !== ci.Not) return c;
        m || (g === ci.Might && h.v == null && f !== o && (h.v = f), (h.n == null || h.n === h.v) && (h.n = f));
      }
      function v(y) {
        return y.v != null && y.n != null;
      }
      return v(c) ? c : v(h) ? h : null;
    }();
    if (l) {
      r.value = [
        l.v
      ];
      var u = o ?? l.n;
      r.itemName = [
        u
      ], r.seriesName = [
        u
      ];
    }
    return r;
  }
  function cE(n) {
    var e = n.get("data", true);
    if (!e) return $x(n.ecModel, "dataset", {
      index: n.get("datasetIndex", true),
      id: n.get("datasetId", true)
    }, yr).models[0];
  }
  function Yce(n) {
    return !n.get("transform", true) && !n.get("fromTransformResult", true) ? [] : $x(n.ecModel, "dataset", {
      index: n.get("fromDatasetIndex", true),
      id: n.get("fromDatasetId", true)
    }, yr).models;
  }
  function gX(n, e) {
    return mX(n.data, n.sourceFormat, n.seriesLayoutBy, n.dimensionsDefine, n.startIndex, e);
  }
  function mX(n, e, t, r, i, a) {
    var s, o = 5;
    if (Ia(n)) return ci.Not;
    var l, u;
    if (r) {
      var c = r[a];
      Ze(c) ? (l = c.name, u = c.type) : Ie(c) && (l = c);
    }
    if (u != null) return u === "ordinal" ? ci.Must : ci.Not;
    if (e === Pi) {
      var h = n;
      if (t === wm) {
        for (var d = h[a], f = 0; f < (d || []).length && f < o; f++) if ((s = b(d[i + f])) != null) return s;
      } else for (var f = 0; f < h.length && f < o; f++) {
        var p = h[i + f];
        if (p && (s = b(p[a])) != null) return s;
      }
    } else if (e === Ts) {
      var g = n;
      if (!l) return ci.Not;
      for (var f = 0; f < g.length && f < o; f++) {
        var m = g[f];
        if (m && (s = b(m[l])) != null) return s;
      }
    } else if (e === ul) {
      var v = n;
      if (!l) return ci.Not;
      var d = v[l];
      if (!d || Ia(d)) return ci.Not;
      for (var f = 0; f < d.length && f < o; f++) if ((s = b(d[f])) != null) return s;
    } else if (e === ks) for (var y = n, f = 0; f < y.length && f < o; f++) {
      var m = y[f], x = pm(m);
      if (!de(x)) return ci.Not;
      if ((s = b(x[a])) != null) return s;
    }
    function b(w) {
      var _ = Ie(w);
      if (w != null && Number.isFinite(Number(w)) && w !== "") return _ ? ci.Might : ci.Not;
      if (_ && w !== "-") return ci.Must;
    }
    return ci.Not;
  }
  var KD = Pe();
  function qce(n, e) {
    ta(KD.get(n) == null && e), KD.set(n, e);
  }
  function jce(n, e, t) {
    var r = KD.get(e);
    if (!r) return t;
    var i = r(n);
    return i ? t.concat(i) : t;
  }
  var aO = Wt(), Kce = Wt(), hE = function() {
    function n() {
    }
    return n.prototype.getColorFromPalette = function(e, t, r) {
      var i = xn(this.get("color", true)), a = this.get("colorLayer", true);
      return vX(this, aO, i, a, e, t, r);
    }, n.prototype.clearColorPalette = function() {
      Qce(this, aO);
    }, n;
  }();
  function ZD(n, e, t, r) {
    var i = xn(n.get([
      "aria",
      "decal",
      "decals"
    ]));
    return vX(n, Kce, i, null, e, t, r);
  }
  function Zce(n, e) {
    for (var t = n.length, r = 0; r < t; r++) if (n[r].length > e) return n[r];
    return n[t - 1];
  }
  function vX(n, e, t, r, i, a, s) {
    a = a || n;
    var o = e(a), l = o.paletteIdx || 0, u = o.paletteNameMap = o.paletteNameMap || {};
    if (u.hasOwnProperty(i)) return u[i];
    var c = s == null || !r ? t : Zce(r, s);
    if (c = c || t, !(!c || !c.length)) {
      var h = c[l];
      return i && (u[i] = h), o.paletteIdx = (l + 1) % c.length, h;
    }
  }
  function Qce(n, e) {
    e(n).paletteIdx = 0, e(n).paletteNameMap = {};
  }
  var R1, Qv, sO, oO = "\0_ec_inner", Jce = 1, dE = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, r, i, a, s, o) {
      a = a || {}, this.option = null, this._theme = new on(a), this._locale = new on(s), this._optionManager = o;
    }, e.prototype.setOption = function(t, r, i) {
      var a = cO(r);
      this._optionManager.setOption(t, i, a), this._resetOption(null, a);
    }, e.prototype.resetOption = function(t, r) {
      return this._resetOption(t, cO(r));
    }, e.prototype._resetOption = function(t, r) {
      var i = false, a = this._optionManager;
      if (!t || t === "recreate") {
        var s = a.mountOption(t === "recreate");
        !this.option || t === "recreate" ? sO(this, s) : (this.restoreData(), this._mergeOption(s, r)), i = true;
      }
      if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") {
        var o = a.getTimelineOption(this);
        o && (i = true, this._mergeOption(o, r));
      }
      if (!t || t === "recreate" || t === "media") {
        var l = a.getMediaOption(this);
        l.length && P(l, function(u) {
          i = true, this._mergeOption(u, r);
        }, this);
      }
      return i;
    }, e.prototype.mergeOption = function(t) {
      this._mergeOption(t, null);
    }, e.prototype._mergeOption = function(t, r) {
      var i = this.option, a = this._componentsMap, s = this._componentsCount, o = [], l = Pe(), u = r && r.replaceMergeMainTypeMap;
      Xce(this), P(t, function(h, d) {
        h != null && (Et.hasClass(d) ? d && (o.push(d), l.set(d, true)) : i[d] = i[d] == null ? Qe(h) : pt(i[d], h, true));
      }), u && u.each(function(h, d) {
        Et.hasClass(d) && !l.get(d) && (o.push(d), l.set(d, true));
      }), Et.topologicalTravel(o, Et.getAllClassMainTypes(), c, this);
      function c(h) {
        var d = jce(this, h, xn(t[h])), f = a.get(h), p = f ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll", g = a8(f, d, p);
        Cle(g, h, Et), i[h] = null, a.set(h, null), s.set(h, 0);
        var m = [], v = [], y = 0, x;
        P(g, function(b, w) {
          var _ = b.existing, S = b.newOption;
          if (!S) _ && (_.mergeOption({}, this), _.optionUpdated({}, false));
          else {
            var I = h === "series", C = Et.getClass(h, b.keyInfo.subType, !I);
            if (!C) return;
            if (h === "tooltip") {
              if (x) return;
              x = true;
            }
            if (_ && _.constructor === C) _.name = b.keyInfo.name, _.mergeOption(S, this), _.optionUpdated(S, false);
            else {
              var T = oe({
                componentIndex: w
              }, b.keyInfo);
              _ = new C(S, this, this, T), oe(_, T), b.brandNew && (_.__requireNewView = true), _.init(S, this, this), _.optionUpdated(null, true);
            }
          }
          _ ? (m.push(_.option), v.push(_), y++) : (m.push(void 0), v.push(void 0));
        }, this), i[h] = m, a.set(h, v), s.set(h, y), h === "series" && R1(this);
      }
      this._seriesIndices || R1(this);
    }, e.prototype.getOption = function() {
      var t = Qe(this.option);
      return P(t, function(r, i) {
        if (Et.hasClass(i)) {
          for (var a = xn(r), s = a.length, o = false, l = s - 1; l >= 0; l--) a[l] && !R0(a[l]) ? o = true : (a[l] = null, !o && s--);
          a.length = s, t[i] = a;
        }
      }), delete t[oO], t;
    }, e.prototype.getTheme = function() {
      return this._theme;
    }, e.prototype.getLocaleModel = function() {
      return this._locale;
    }, e.prototype.setUpdatePayload = function(t) {
      this._payload = t;
    }, e.prototype.getUpdatePayload = function() {
      return this._payload;
    }, e.prototype.getComponent = function(t, r) {
      var i = this._componentsMap.get(t);
      if (i) {
        var a = i[r || 0];
        if (a) return a;
        if (r == null) {
          for (var s = 0; s < i.length; s++) if (i[s]) return i[s];
        }
      }
    }, e.prototype.queryComponents = function(t) {
      var r = t.mainType;
      if (!r) return [];
      var i = t.index, a = t.id, s = t.name, o = this._componentsMap.get(r);
      if (!o || !o.length) return [];
      var l;
      return i != null ? (l = [], P(xn(i), function(u) {
        o[u] && l.push(o[u]);
      })) : a != null ? l = lO("id", a, o) : s != null ? l = lO("name", s, o) : l = rn(o, function(u) {
        return !!u;
      }), uO(l, t);
    }, e.prototype.findComponents = function(t) {
      var r = t.query, i = t.mainType, a = o(r), s = a ? this.queryComponents(a) : rn(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(uO(s, t));
      function o(u) {
        var c = i + "Index", h = i + "Id", d = i + "Name";
        return u && (u[c] != null || u[h] != null || u[d] != null) ? {
          mainType: i,
          index: u[c],
          id: u[h],
          name: u[d]
        } : null;
      }
      function l(u) {
        return t.filter ? rn(u, t.filter) : u;
      }
    }, e.prototype.eachComponent = function(t, r, i) {
      var a = this._componentsMap;
      if (Xe(t)) {
        var s = r, o = t;
        a.each(function(h, d) {
          for (var f = 0; h && f < h.length; f++) {
            var p = h[f];
            p && o.call(s, d, p, p.componentIndex);
          }
        });
      } else for (var l = Ie(t) ? a.get(t) : Ze(t) ? this.findComponents(t) : null, u = 0; l && u < l.length; u++) {
        var c = l[u];
        c && r.call(i, c, c.componentIndex);
      }
    }, e.prototype.getSeriesByName = function(t) {
      var r = kr(t, null);
      return rn(this._componentsMap.get("series"), function(i) {
        return !!i && r != null && i.name === r;
      });
    }, e.prototype.getSeriesByIndex = function(t) {
      return this._componentsMap.get("series")[t];
    }, e.prototype.getSeriesByType = function(t) {
      return rn(this._componentsMap.get("series"), function(r) {
        return !!r && r.subType === t;
      });
    }, e.prototype.getSeries = function() {
      return rn(this._componentsMap.get("series"), function(t) {
        return !!t;
      });
    }, e.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, e.prototype.eachSeries = function(t, r) {
      Qv(this), P(this._seriesIndices, function(i) {
        var a = this._componentsMap.get("series")[i];
        t.call(r, a, i);
      }, this);
    }, e.prototype.eachRawSeries = function(t, r) {
      P(this._componentsMap.get("series"), function(i) {
        i && t.call(r, i, i.componentIndex);
      });
    }, e.prototype.eachSeriesByType = function(t, r, i) {
      Qv(this), P(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        s.subType === t && r.call(i, s, a);
      }, this);
    }, e.prototype.eachRawSeriesByType = function(t, r, i) {
      return P(this.getSeriesByType(t), r, i);
    }, e.prototype.isSeriesFiltered = function(t) {
      return Qv(this), this._seriesIndicesMap.get(t.componentIndex) == null;
    }, e.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, e.prototype.filterSeries = function(t, r) {
      Qv(this);
      var i = [];
      P(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        t.call(r, s, a) && i.push(a);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = Pe(i);
    }, e.prototype.restoreData = function(t) {
      R1(this);
      var r = this._componentsMap, i = [];
      r.each(function(a, s) {
        Et.hasClass(s) && i.push(s);
      }), Et.topologicalTravel(i, Et.getAllClassMainTypes(), function(a) {
        P(r.get(a), function(s) {
          s && (a !== "series" || !ehe(s, t)) && s.restoreData();
        });
      });
    }, e.internalField = function() {
      R1 = function(t) {
        var r = t._seriesIndices = [];
        P(t._componentsMap.get("series"), function(i) {
          i && r.push(i.componentIndex);
        }), t._seriesIndicesMap = Pe(r);
      }, Qv = function(t) {
      }, sO = function(t, r) {
        t.option = {}, t.option[oO] = Jce, t._componentsMap = Pe({
          series: []
        }), t._componentsCount = Pe();
        var i = r.aria;
        Ze(i) && i.enabled == null && (i.enabled = true), the(r, t._theme.option), pt(r, Hce, false), t._mergeOption(r, null);
      };
    }(), e;
  }(on);
  function ehe(n, e) {
    if (e) {
      var t = e.seriesIndex, r = e.seriesId, i = e.seriesName;
      return t != null && n.componentIndex !== t || r != null && n.id !== r || i != null && n.name !== i;
    }
  }
  function the(n, e) {
    var t = n.color && !n.colorLayer;
    P(e, function(r, i) {
      i === "colorLayer" && t || Et.hasClass(i) || (typeof r == "object" ? n[i] = n[i] ? pt(n[i], r, false) : Qe(r) : n[i] == null && (n[i] = r));
    });
  }
  function lO(n, e, t) {
    if (de(e)) {
      var r = Pe();
      return P(e, function(a) {
        if (a != null) {
          var s = kr(a, null);
          s != null && r.set(a, true);
        }
      }), rn(t, function(a) {
        return a && r.get(a[n]);
      });
    } else {
      var i = kr(e, null);
      return rn(t, function(a) {
        return a && i != null && a[n] === i;
      });
    }
  }
  function uO(n, e) {
    return e.hasOwnProperty("subType") ? rn(n, function(t) {
      return t && t.subType === e.subType;
    }) : n;
  }
  function cO(n) {
    var e = Pe();
    return n && P(xn(n.replaceMerge), function(t) {
      e.set(t, true);
    }), {
      replaceMergeMainTypeMap: e
    };
  }
  br(dE, hE);
  var nhe = [
    "getDom",
    "getZr",
    "getWidth",
    "getHeight",
    "getDevicePixelRatio",
    "dispatchAction",
    "isSSR",
    "isDisposed",
    "on",
    "off",
    "getDataURL",
    "getConnectedDataURL",
    "getOption",
    "getId",
    "updateLabelLayout"
  ], yX = /* @__PURE__ */ function() {
    function n(e) {
      P(nhe, function(t) {
        this[t] = Ae(e[t], e);
      }, this);
    }
    return n;
  }(), mk = {}, Ox = function() {
    function n() {
      this._coordinateSystems = [];
    }
    return n.prototype.create = function(e, t) {
      var r = [];
      P(mk, function(i, a) {
        var s = i.create(e, t);
        r = r.concat(s || []);
      }), this._coordinateSystems = r;
    }, n.prototype.update = function(e, t) {
      P(this._coordinateSystems, function(r) {
        r.update && r.update(e, t);
      });
    }, n.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, n.register = function(e, t) {
      mk[e] = t;
    }, n.get = function(e) {
      return mk[e];
    }, n;
  }(), rhe = /^(min|max)?(.+)$/, ihe = function() {
    function n(e) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e;
    }
    return n.prototype.setOption = function(e, t, r) {
      e && (P(xn(e.series), function(s) {
        s && s.data && Ia(s.data) && R_(s.data);
      }), P(xn(e.dataset), function(s) {
        s && s.source && Ia(s.source) && R_(s.source);
      })), e = Qe(e);
      var i = this._optionBackup, a = ahe(e, t, !i);
      this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, n.prototype.mountOption = function(e) {
      var t = this._optionBackup;
      return this._timelineOptions = t.timelineOptions, this._mediaList = t.mediaList, this._mediaDefault = t.mediaDefault, this._currentMediaIndices = [], Qe(e ? t.baseOption : this._newBaseOption);
    }, n.prototype.getTimelineOption = function(e) {
      var t, r = this._timelineOptions;
      if (r.length) {
        var i = e.getComponent("timeline");
        i && (t = Qe(r[i.getCurrentIndex()]));
      }
      return t;
    }, n.prototype.getMediaOption = function(e) {
      var t = this._api.getWidth(), r = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, s = [], o = [];
      if (!i.length && !a) return o;
      for (var l = 0, u = i.length; l < u; l++) she(i[l].query, t, r) && s.push(l);
      return !s.length && a && (s = [
        -1
      ]), s.length && !lhe(s, this._currentMediaIndices) && (o = me(s, function(c) {
        return Qe(c === -1 ? a.option : i[c].option);
      })), this._currentMediaIndices = s, o;
    }, n;
  }();
  function ahe(n, e, t) {
    var r = [], i, a, s = n.baseOption, o = n.timeline, l = n.options, u = n.media, c = !!n.media, h = !!(l || o || s && s.timeline);
    s ? (a = s, a.timeline || (a.timeline = o)) : ((h || c) && (n.options = n.media = null), a = n), c && de(u) && P(u, function(f) {
      f && f.option && (f.query ? r.push(f) : i || (i = f));
    }), d(a), P(l, function(f) {
      return d(f);
    }), P(r, function(f) {
      return d(f.option);
    });
    function d(f) {
      P(e, function(p) {
        p(f, t);
      });
    }
    return {
      baseOption: a,
      timelineOptions: l || [],
      mediaDefault: i,
      mediaList: r
    };
  }
  function she(n, e, t) {
    var r = {
      width: e,
      height: t,
      aspectratio: e / t
    }, i = true;
    return P(n, function(a, s) {
      var o = s.match(rhe);
      if (!(!o || !o[1] || !o[2])) {
        var l = o[1], u = o[2].toLowerCase();
        ohe(r[u], a, l) || (i = false);
      }
    }), i;
  }
  function ohe(n, e, t) {
    return t === "min" ? n >= e : t === "max" ? n <= e : n === e;
  }
  function lhe(n, e) {
    return n.join(",") === e.join(",");
  }
  var Es = P, L0 = Ze, hO = [
    "areaStyle",
    "lineStyle",
    "nodeStyle",
    "linkStyle",
    "chordStyle",
    "label",
    "labelLine"
  ];
  function vk(n) {
    var e = n && n.itemStyle;
    if (e) for (var t = 0, r = hO.length; t < r; t++) {
      var i = hO[t], a = e.normal, s = e.emphasis;
      a && a[i] && (n[i] = n[i] || {}, n[i].normal ? pt(n[i].normal, a[i]) : n[i].normal = a[i], a[i] = null), s && s[i] && (n[i] = n[i] || {}, n[i].emphasis ? pt(n[i].emphasis, s[i]) : n[i].emphasis = s[i], s[i] = null);
    }
  }
  function Ii(n, e, t) {
    if (n && n[e] && (n[e].normal || n[e].emphasis)) {
      var r = n[e].normal, i = n[e].emphasis;
      r && (t ? (n[e].normal = n[e].emphasis = null, je(n[e], r)) : n[e] = r), i && (n.emphasis = n.emphasis || {}, n.emphasis[e] = i, i.focus && (n.emphasis.focus = i.focus), i.blurScope && (n.emphasis.blurScope = i.blurScope));
    }
  }
  function Py(n) {
    Ii(n, "itemStyle"), Ii(n, "lineStyle"), Ii(n, "areaStyle"), Ii(n, "label"), Ii(n, "labelLine"), Ii(n, "upperLabel"), Ii(n, "edgeLabel");
  }
  function mr(n, e) {
    var t = L0(n) && n[e], r = L0(t) && t.textStyle;
    if (r) for (var i = 0, a = vF.length; i < a; i++) {
      var s = vF[i];
      r.hasOwnProperty(s) && (t[s] = r[s]);
    }
  }
  function os(n) {
    n && (Py(n), mr(n, "label"), n.emphasis && mr(n.emphasis, "label"));
  }
  function uhe(n) {
    if (L0(n)) {
      vk(n), Py(n), mr(n, "label"), mr(n, "upperLabel"), mr(n, "edgeLabel"), n.emphasis && (mr(n.emphasis, "label"), mr(n.emphasis, "upperLabel"), mr(n.emphasis, "edgeLabel"));
      var e = n.markPoint;
      e && (vk(e), os(e));
      var t = n.markLine;
      t && (vk(t), os(t));
      var r = n.markArea;
      r && os(r);
      var i = n.data;
      if (n.type === "graph") {
        i = i || n.nodes;
        var a = n.links || n.edges;
        if (a && !Ia(a)) for (var s = 0; s < a.length; s++) os(a[s]);
        P(n.categories, function(u) {
          Py(u);
        });
      }
      if (i && !Ia(i)) for (var s = 0; s < i.length; s++) os(i[s]);
      if (e = n.markPoint, e && e.data) for (var o = e.data, s = 0; s < o.length; s++) os(o[s]);
      if (t = n.markLine, t && t.data) for (var l = t.data, s = 0; s < l.length; s++) de(l[s]) ? (os(l[s][0]), os(l[s][1])) : os(l[s]);
      n.type === "gauge" ? (mr(n, "axisLabel"), mr(n, "title"), mr(n, "detail")) : n.type === "treemap" ? (Ii(n.breadcrumb, "itemStyle"), P(n.levels, function(u) {
        Py(u);
      })) : n.type === "tree" && Py(n.leaves);
    }
  }
  function yl(n) {
    return de(n) ? n : n ? [
      n
    ] : [];
  }
  function dO(n) {
    return (de(n) ? n[0] : n) || {};
  }
  function che(n, e) {
    Es(yl(n.series), function(r) {
      L0(r) && uhe(r);
    });
    var t = [
      "xAxis",
      "yAxis",
      "radiusAxis",
      "angleAxis",
      "singleAxis",
      "parallelAxis",
      "radar"
    ];
    e && t.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Es(t, function(r) {
      Es(yl(n[r]), function(i) {
        i && (mr(i, "axisLabel"), mr(i.axisPointer, "label"));
      });
    }), Es(yl(n.parallel), function(r) {
      var i = r && r.parallelAxisDefault;
      mr(i, "axisLabel"), mr(i && i.axisPointer, "label");
    }), Es(yl(n.calendar), function(r) {
      Ii(r, "itemStyle"), mr(r, "dayLabel"), mr(r, "monthLabel"), mr(r, "yearLabel");
    }), Es(yl(n.radar), function(r) {
      mr(r, "name"), r.name && r.axisName == null && (r.axisName = r.name, delete r.name), r.nameGap != null && r.axisNameGap == null && (r.axisNameGap = r.nameGap, delete r.nameGap);
    }), Es(yl(n.geo), function(r) {
      L0(r) && (os(r), Es(yl(r.regions), function(i) {
        os(i);
      }));
    }), Es(yl(n.timeline), function(r) {
      os(r), Ii(r, "label"), Ii(r, "itemStyle"), Ii(r, "controlStyle", true);
      var i = r.data;
      de(i) && P(i, function(a) {
        Ze(a) && (Ii(a, "label"), Ii(a, "itemStyle"));
      });
    }), Es(yl(n.toolbox), function(r) {
      Ii(r, "iconStyle"), Es(r.feature, function(i) {
        Ii(i, "iconStyle");
      });
    }), mr(dO(n.axisPointer), "label"), mr(dO(n.tooltip).axisPointer, "label");
  }
  function hhe(n, e) {
    for (var t = e.split(","), r = n, i = 0; i < t.length && (r = r && r[t[i]], r != null); i++) ;
    return r;
  }
  function dhe(n, e, t, r) {
    for (var i = e.split(","), a = n, s, o = 0; o < i.length - 1; o++) s = i[o], a[s] == null && (a[s] = {}), a = a[s];
    a[i[o]] == null && (a[i[o]] = t);
  }
  function fO(n) {
    n && P(fhe, function(e) {
      e[0] in n && !(e[1] in n) && (n[e[1]] = n[e[0]]);
    });
  }
  var fhe = [
    [
      "x",
      "left"
    ],
    [
      "y",
      "top"
    ],
    [
      "x2",
      "right"
    ],
    [
      "y2",
      "bottom"
    ]
  ], phe = [
    "grid",
    "geo",
    "parallel",
    "legend",
    "toolbox",
    "title",
    "visualMap",
    "dataZoom",
    "timeline"
  ], yk = [
    [
      "borderRadius",
      "barBorderRadius"
    ],
    [
      "borderColor",
      "barBorderColor"
    ],
    [
      "borderWidth",
      "barBorderWidth"
    ]
  ];
  function Jv(n) {
    var e = n && n.itemStyle;
    if (e) for (var t = 0; t < yk.length; t++) {
      var r = yk[t][1], i = yk[t][0];
      e[r] != null && (e[i] = e[r]);
    }
  }
  function pO(n) {
    n && n.alignTo === "edge" && n.margin != null && n.edgeDistance == null && (n.edgeDistance = n.margin);
  }
  function gO(n) {
    n && n.downplay && !n.blur && (n.blur = n.downplay);
  }
  function ghe(n) {
    n && n.focusNodeAdjacency != null && (n.emphasis = n.emphasis || {}, n.emphasis.focus == null && (n.emphasis.focus = "adjacency"));
  }
  function xX(n, e) {
    if (n) for (var t = 0; t < n.length; t++) e(n[t]), n[t] && xX(n[t].children, e);
  }
  function bX(n, e) {
    che(n, e), n.series = xn(n.series), P(n.series, function(t) {
      if (Ze(t)) {
        var r = t.type;
        if (r === "line") t.clipOverflow != null && (t.clip = t.clipOverflow);
        else if (r === "pie" || r === "gauge") {
          t.clockWise != null && (t.clockwise = t.clockWise), pO(t.label);
          var i = t.data;
          if (i && !Ia(i)) for (var a = 0; a < i.length; a++) pO(i[a]);
          t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && (t.emphasis.scaleSize = t.hoverOffset));
        } else if (r === "gauge") {
          var s = hhe(t, "pointer.color");
          s != null && dhe(t, "itemStyle.color", s);
        } else if (r === "bar") {
          Jv(t), Jv(t.backgroundStyle), Jv(t.emphasis);
          var i = t.data;
          if (i && !Ia(i)) for (var a = 0; a < i.length; a++) typeof i[a] == "object" && (Jv(i[a]), Jv(i[a] && i[a].emphasis));
        } else if (r === "sunburst") {
          var o = t.highlightPolicy;
          o && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = o)), gO(t), xX(t.data, gO);
        } else r === "graph" || r === "sankey" ? ghe(t) : r === "map" && (t.mapType && !t.map && (t.map = t.mapType), t.mapLocation && je(t, t.mapLocation));
        t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && (t.emphasis.scale = t.hoverAnimation)), fO(t);
      }
    }), n.dataRange && (n.visualMap = n.dataRange), P(phe, function(t) {
      var r = n[t];
      r && (de(r) || (r = [
        r
      ]), P(r, function(i) {
        fO(i);
      }));
    });
  }
  function mhe(n) {
    var e = Pe();
    n.eachSeries(function(t) {
      var r = t.get("stack");
      if (r) {
        var i = e.get(r) || e.set(r, []), a = t.getData(), s = {
          stackResultDimension: a.getCalculationInfo("stackResultDimension"),
          stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
          stackedDimension: a.getCalculationInfo("stackedDimension"),
          stackedByDimension: a.getCalculationInfo("stackedByDimension"),
          isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
          data: a,
          seriesModel: t
        };
        if (!s.stackedDimension || !(s.isStackedByIndex || s.stackedByDimension)) return;
        i.length && a.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(s);
      }
    }), e.each(vhe);
  }
  function vhe(n) {
    P(n, function(e, t) {
      var r = [], i = [
        NaN,
        NaN
      ], a = [
        e.stackResultDimension,
        e.stackedOverDimension
      ], s = e.data, o = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign";
      s.modify(a, function(u, c, h) {
        var d = s.get(e.stackedDimension, h);
        if (isNaN(d)) return i;
        var f, p;
        o ? p = s.getRawIndex(h) : f = s.get(e.stackedByDimension, h);
        for (var g = NaN, m = t - 1; m >= 0; m--) {
          var v = n[m];
          if (o || (p = v.data.rawIndexOf(v.stackedByDimension, f)), p >= 0) {
            var y = v.data.getByRawIndex(v.stackResultDimension, p);
            if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && d >= 0 && y > 0 || l === "samesign" && d <= 0 && y < 0) {
              d = fle(d, y), g = y;
              break;
            }
          }
        }
        return r[0] = d, r[1] = g, r;
      });
    });
  }
  var EC = /* @__PURE__ */ function() {
    function n(e) {
      this.data = e.data || (e.sourceFormat === ul ? {} : []), this.sourceFormat = e.sourceFormat || dX, this.seriesLayoutBy = e.seriesLayoutBy || Ho, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption;
      var t = this.dimensionsDefine = e.dimensionsDefine;
      if (t) for (var r = 0; r < t.length; r++) {
        var i = t[r];
        i.type == null && gX(this, r) === ci.Must && (i.type = "ordinal");
      }
    }
    return n;
  }();
  function fE(n) {
    return n instanceof EC;
  }
  function QD(n, e, t) {
    t = t || wX(n);
    var r = e.seriesLayoutBy, i = xhe(n, t, r, e.sourceHeader, e.dimensions), a = new EC({
      data: n,
      sourceFormat: t,
      seriesLayoutBy: r,
      dimensionsDefine: i.dimensionsDefine,
      startIndex: i.startIndex,
      dimensionsDetectedCount: i.dimensionsDetectedCount,
      metaRawOption: Qe(e)
    });
    return a;
  }
  function pE(n) {
    return new EC({
      data: n,
      sourceFormat: Ia(n) ? Xu : ks
    });
  }
  function yhe(n) {
    return new EC({
      data: n.data,
      sourceFormat: n.sourceFormat,
      seriesLayoutBy: n.seriesLayoutBy,
      dimensionsDefine: Qe(n.dimensionsDefine),
      startIndex: n.startIndex,
      dimensionsDetectedCount: n.dimensionsDetectedCount
    });
  }
  function wX(n) {
    var e = dX;
    if (Ia(n)) e = Xu;
    else if (de(n)) {
      n.length === 0 && (e = Pi);
      for (var t = 0, r = n.length; t < r; t++) {
        var i = n[t];
        if (i != null) {
          if (de(i) || Ia(i)) {
            e = Pi;
            break;
          } else if (Ze(i)) {
            e = Ts;
            break;
          }
        }
      }
    } else if (Ze(n)) {
      for (var a in n) if ($e(n, a) && Mi(n[a])) {
        e = ul;
        break;
      }
    }
    return e;
  }
  function xhe(n, e, t, r, i) {
    var a, s;
    if (!n) return {
      dimensionsDefine: mO(i),
      startIndex: s,
      dimensionsDetectedCount: a
    };
    if (e === Pi) {
      var o = n;
      r === "auto" || r == null ? vO(function(u) {
        u != null && u !== "-" && (Ie(u) ? s == null && (s = 1) : s = 0);
      }, t, o, 10) : s = Yt(r) ? r : r ? 1 : 0, !i && s === 1 && (i = [], vO(function(u, c) {
        i[c] = u != null ? u + "" : "";
      }, t, o, 1 / 0)), a = i ? i.length : t === wm ? o.length : o[0] ? o[0].length : null;
    } else if (e === Ts) i || (i = bhe(n));
    else if (e === ul) i || (i = [], P(n, function(u, c) {
      i.push(c);
    }));
    else if (e === ks) {
      var l = pm(n[0]);
      a = de(l) && l.length || 1;
    }
    return {
      startIndex: s,
      dimensionsDefine: mO(i),
      dimensionsDetectedCount: a
    };
  }
  function bhe(n) {
    for (var e = 0, t; e < n.length && !(t = n[e++]); ) ;
    if (t) return Mt(t);
  }
  function mO(n) {
    if (n) {
      var e = Pe();
      return me(n, function(t, r) {
        t = Ze(t) ? t : {
          name: t
        };
        var i = {
          name: t.name,
          displayName: t.displayName,
          type: t.type
        };
        if (i.name == null) return i;
        i.name += "", i.displayName == null && (i.displayName = i.name);
        var a = e.get(i.name);
        return a ? i.name += "-" + a.count++ : e.set(i.name, {
          count: 1
        }), i;
      });
    }
  }
  function vO(n, e, t, r) {
    if (e === wm) for (var i = 0; i < t.length && i < r; i++) n(t[i] ? t[i][0] : null, i);
    else for (var a = t[0] || [], i = 0; i < a.length && i < r; i++) n(a[i], i);
  }
  function _X(n) {
    var e = n.sourceFormat;
    return e === Ts || e === ul;
  }
  var th, nh, rh, yO, xO, SX = function() {
    function n(e, t) {
      var r = fE(e) ? e : pE(e);
      this._source = r;
      var i = this._data = r.data;
      r.sourceFormat === Xu && (this._offset = 0, this._dimSize = t, this._data = i), xO(this, i, r);
    }
    return n.prototype.getSource = function() {
      return this._source;
    }, n.prototype.count = function() {
      return 0;
    }, n.prototype.getItem = function(e, t) {
    }, n.prototype.appendData = function(e) {
    }, n.prototype.clean = function() {
    }, n.protoInitialize = function() {
      var e = n.prototype;
      e.pure = false, e.persistent = true;
    }(), n.internalField = function() {
      var e;
      xO = function(s, o, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, d = l.dimensionsDefine, f = yO[gE(u, c)];
        if (oe(s, f), u === Xu) s.getItem = t, s.count = i, s.fillStorage = r;
        else {
          var p = CX(u, c);
          s.getItem = Ae(p, null, o, h, d);
          var g = IX(u, c);
          s.count = Ae(g, null, o, h, d);
        }
      };
      var t = function(s, o) {
        s = s - this._offset, o = o || [];
        for (var l = this._data, u = this._dimSize, c = u * s, h = 0; h < u; h++) o[h] = l[c + h];
        return o;
      }, r = function(s, o, l, u) {
        for (var c = this._data, h = this._dimSize, d = 0; d < h; d++) {
          for (var f = u[d], p = f[0] == null ? 1 / 0 : f[0], g = f[1] == null ? -1 / 0 : f[1], m = o - s, v = l[d], y = 0; y < m; y++) {
            var x = c[y * h + d];
            v[s + y] = x, x < p && (p = x), x > g && (g = x);
          }
          f[0] = p, f[1] = g;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      yO = (e = {}, e[Pi + "_" + Ho] = {
        pure: true,
        appendData: a
      }, e[Pi + "_" + wm] = {
        pure: true,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, e[Ts] = {
        pure: true,
        appendData: a
      }, e[ul] = {
        pure: true,
        appendData: function(s) {
          var o = this._data;
          P(s, function(l, u) {
            for (var c = o[u] || (o[u] = []), h = 0; h < (l || []).length; h++) c.push(l[h]);
          });
        }
      }, e[ks] = {
        appendData: a
      }, e[Xu] = {
        persistent: false,
        pure: true,
        appendData: function(s) {
          this._data = s;
        },
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, e);
      function a(s) {
        for (var o = 0; o < s.length; o++) this._data.push(s[o]);
      }
    }(), n;
  }(), bO = function(n, e, t, r) {
    return n[r];
  }, whe = (th = {}, th[Pi + "_" + Ho] = function(n, e, t, r) {
    return n[r + e];
  }, th[Pi + "_" + wm] = function(n, e, t, r, i) {
    r += e;
    for (var a = i || [], s = n, o = 0; o < s.length; o++) {
      var l = s[o];
      a[o] = l ? l[r] : null;
    }
    return a;
  }, th[Ts] = bO, th[ul] = function(n, e, t, r, i) {
    for (var a = i || [], s = 0; s < t.length; s++) {
      var o = t[s].name, l = n[o];
      a[s] = l ? l[r] : null;
    }
    return a;
  }, th[ks] = bO, th);
  function CX(n, e) {
    var t = whe[gE(n, e)];
    return t;
  }
  var wO = function(n, e, t) {
    return n.length;
  }, _he = (nh = {}, nh[Pi + "_" + Ho] = function(n, e, t) {
    return Math.max(0, n.length - e);
  }, nh[Pi + "_" + wm] = function(n, e, t) {
    var r = n[0];
    return r ? Math.max(0, r.length - e) : 0;
  }, nh[Ts] = wO, nh[ul] = function(n, e, t) {
    var r = t[0].name, i = n[r];
    return i ? i.length : 0;
  }, nh[ks] = wO, nh);
  function IX(n, e) {
    var t = _he[gE(n, e)];
    return t;
  }
  var xk = function(n, e, t) {
    return n[e];
  }, She = (rh = {}, rh[Pi] = xk, rh[Ts] = function(n, e, t) {
    return n[t];
  }, rh[ul] = xk, rh[ks] = function(n, e, t) {
    var r = pm(n);
    return r instanceof Array ? r[e] : r;
  }, rh[Xu] = xk, rh);
  function kX(n) {
    var e = She[n];
    return e;
  }
  function gE(n, e) {
    return n === Pi ? n + "_" + e : n;
  }
  function Pg(n, e, t) {
    if (n) {
      var r = n.getRawDataItem(e);
      if (r != null) {
        var i = n.getStore(), a = i.getSource().sourceFormat;
        if (t != null) {
          var s = n.getDimensionIndex(t), o = i.getDimensionProperty(s);
          return kX(a)(r, s, o);
        } else {
          var l = r;
          return a === ks && (l = pm(r)), l;
        }
      }
    }
  }
  var Che = /\{@(.+?)\}/g, MC = function() {
    function n() {
    }
    return n.prototype.getDataParams = function(e, t) {
      var r = this.getData(t), i = this.getRawValue(e, t), a = r.getRawIndex(e), s = r.getName(e), o = r.getRawDataItem(e), l = r.getItemVisual(e, "style"), u = l && l[r.getItemVisual(e, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, d = h === "series", f = r.userOutput && r.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: d ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: d ? this.id : null,
        seriesName: d ? this.name : null,
        name: s,
        dataIndex: a,
        data: o,
        dataType: t,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: f ? f.fullDimensions : null,
        encode: f ? f.encode : null,
        $vars: [
          "seriesName",
          "name",
          "value"
        ]
      };
    }, n.prototype.getFormattedLabel = function(e, t, r, i, a, s) {
      t = t || "normal";
      var o = this.getData(r), l = this.getDataParams(e, r);
      if (s && (l.value = s.interpolatedValue), i != null && de(l.value) && (l.value = l.value[i]), !a) {
        var u = o.getItemModel(e);
        a = u.get(t === "normal" ? [
          "label",
          "formatter"
        ] : [
          t,
          "label",
          "formatter"
        ]);
      }
      if (Xe(a)) return l.status = t, l.dimensionIndex = i, a(l);
      if (Ie(a)) {
        var c = oX(a, l);
        return c.replace(Che, function(h, d) {
          var f = d.length, p = d;
          p.charAt(0) === "[" && p.charAt(f - 1) === "]" && (p = +p.slice(1, f - 1));
          var g = Pg(o, e, p);
          if (s && de(s.interpolatedValue)) {
            var m = o.getDimensionIndex(p);
            m >= 0 && (g = s.interpolatedValue[m]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, n.prototype.getRawValue = function(e, t) {
      return Pg(this.getData(t), e);
    }, n.prototype.formatTooltip = function(e, t, r) {
    }, n;
  }();
  function _O(n) {
    var e, t;
    return Ze(n) ? n.type && (t = n) : e = n, {
      text: e,
      frag: t
    };
  }
  function u0(n) {
    return new Ihe(n);
  }
  var Ihe = function() {
    function n(e) {
      e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = true;
    }
    return n.prototype.perform = function(e) {
      var t = this._upstream, r = e && e.skip;
      if (this._dirty && t) {
        var i = this.context;
        i.data = i.outputData = t.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !r && (a = this._plan(this.context));
      var s = c(this._modBy), o = this._modDataCount || 0, l = c(e && e.modBy), u = e && e.modDataCount || 0;
      (s !== l || o !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = false, h = this._doReset(r)), this._modBy = l, this._modDataCount = u;
      var d = e && e.step;
      if (t ? this._dueEnd = t._outputDueEnd : this._dueEnd = this._count ? this._count(this.context) : 1 / 0, this._progress) {
        var f = this._dueIndex, p = Math.min(d != null ? this._dueIndex + d : 1 / 0, this._dueEnd);
        if (!r && (h || f < p)) {
          var g = this._progress;
          if (de(g)) for (var m = 0; m < g.length; m++) this._doProgress(g[m], f, p, l, u);
          else this._doProgress(g, f, p, l, u);
        }
        this._dueIndex = p;
        var v = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        this._outputDueEnd = v;
      } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, n.prototype.dirty = function() {
      this._dirty = true, this._onDirty && this._onDirty(this.context);
    }, n.prototype._doProgress = function(e, t, r, i, a) {
      SO.reset(t, r, i, a), this._callingProgress = e, this._callingProgress({
        start: t,
        end: r,
        count: r - t,
        next: SO.next
      }, this.context);
    }, n.prototype._doReset = function(e) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var t, r;
      !e && this._reset && (t = this._reset(this.context), t && t.progress && (r = t.forceFirstProgress, t = t.progress), de(t) && !t.length && (t = null)), this._progress = t, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), r;
    }, n.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, n.prototype.pipe = function(e) {
      (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty());
    }, n.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = false, this._disposed = true);
    }, n.prototype.getUpstream = function() {
      return this._upstream;
    }, n.prototype.getDownstream = function() {
      return this._downstream;
    }, n.prototype.setOutputEnd = function(e) {
      this._outputDueEnd = this._settedOutputEnd = e;
    }, n;
  }(), SO = /* @__PURE__ */ function() {
    var n, e, t, r, i, a = {
      reset: function(l, u, c, h) {
        e = l, n = u, t = c, r = h, i = Math.ceil(r / t), a.next = t > 1 && r > 0 ? o : s;
      }
    };
    return a;
    function s() {
      return e < n ? e++ : null;
    }
    function o() {
      var l = e % i * t + Math.ceil(e / i), u = e >= n ? null : l < r ? l : e;
      return e++, u;
    }
  }();
  function Yu(n, e) {
    var t = e && e.type;
    return t === "ordinal" ? n : (t === "time" && !Yt(n) && n != null && n !== "-" && (n = +tl(n)), n == null || n === "" ? NaN : Number(n));
  }
  var khe = Pe({
    number: function(n) {
      return parseFloat(n);
    },
    time: function(n) {
      return +tl(n);
    },
    trim: function(n) {
      return Ie(n) ? Hs(n) : n;
    }
  });
  function TX(n) {
    return khe.get(n);
  }
  var AX = {
    lt: function(n, e) {
      return n < e;
    },
    lte: function(n, e) {
      return n <= e;
    },
    gt: function(n, e) {
      return n > e;
    },
    gte: function(n, e) {
      return n >= e;
    }
  }, The = function() {
    function n(e, t) {
      if (!Yt(t)) {
        var r = "";
        nn(r);
      }
      this._opFn = AX[e], this._rvalFloat = Hl(t);
    }
    return n.prototype.evaluate = function(e) {
      return Yt(e) ? this._opFn(e, this._rvalFloat) : this._opFn(Hl(e), this._rvalFloat);
    }, n;
  }(), DX = function() {
    function n(e, t) {
      var r = e === "desc";
      this._resultLT = r ? 1 : -1, t == null && (t = r ? "min" : "max"), this._incomparable = t === "min" ? -1 / 0 : 1 / 0;
    }
    return n.prototype.evaluate = function(e, t) {
      var r = Yt(e) ? e : Hl(e), i = Yt(t) ? t : Hl(t), a = isNaN(r), s = isNaN(i);
      if (a && (r = this._incomparable), s && (i = this._incomparable), a && s) {
        var o = Ie(e), l = Ie(t);
        o && (r = l ? e : 0), l && (i = o ? t : 0);
      }
      return r < i ? this._resultLT : r > i ? -this._resultLT : 0;
    }, n;
  }(), Ahe = function() {
    function n(e, t) {
      this._rval = t, this._isEQ = e, this._rvalTypeof = typeof t, this._rvalFloat = Hl(t);
    }
    return n.prototype.evaluate = function(e) {
      var t = e === this._rval;
      if (!t) {
        var r = typeof e;
        r !== this._rvalTypeof && (r === "number" || this._rvalTypeof === "number") && (t = Hl(e) === this._rvalFloat);
      }
      return this._isEQ ? t : !t;
    }, n;
  }();
  function Dhe(n, e) {
    return n === "eq" || n === "ne" ? new Ahe(n === "eq", e) : $e(AX, n) ? new The(n, e) : null;
  }
  var Rhe = function() {
    function n() {
    }
    return n.prototype.getRawData = function() {
      throw new Error("not supported");
    }, n.prototype.getRawDataItem = function(e) {
      throw new Error("not supported");
    }, n.prototype.cloneRawData = function() {
    }, n.prototype.getDimensionInfo = function(e) {
    }, n.prototype.cloneAllDimensionInfo = function() {
    }, n.prototype.count = function() {
    }, n.prototype.retrieveValue = function(e, t) {
    }, n.prototype.retrieveValueFromItem = function(e, t) {
    }, n.prototype.convertValue = function(e, t) {
      return Yu(e, t);
    }, n;
  }();
  function $he(n, e) {
    var t = new Rhe(), r = n.data, i = t.sourceFormat = n.sourceFormat, a = n.startIndex, s = "";
    n.seriesLayoutBy !== Ho && nn(s);
    var o = [], l = {}, u = n.dimensionsDefine;
    if (u) P(u, function(g, m) {
      var v = g.name, y = {
        index: m,
        name: v,
        displayName: g.displayName
      };
      if (o.push(y), v != null) {
        var x = "";
        $e(l, v) && nn(x), l[v] = y;
      }
    });
    else for (var c = 0; c < n.dimensionsDetectedCount; c++) o.push({
      index: c
    });
    var h = CX(i, Ho);
    e.__isBuiltIn && (t.getRawDataItem = function(g) {
      return h(r, a, o, g);
    }, t.getRawData = Ae(Nhe, null, n)), t.cloneRawData = Ae(Ehe, null, n);
    var d = IX(i, Ho);
    t.count = Ae(d, null, r, a, o);
    var f = kX(i);
    t.retrieveValue = function(g, m) {
      var v = h(r, a, o, g);
      return p(v, m);
    };
    var p = t.retrieveValueFromItem = function(g, m) {
      if (g != null) {
        var v = o[m];
        if (v) return f(g, m, v.name);
      }
    };
    return t.getDimensionInfo = Ae(Mhe, null, o, l), t.cloneAllDimensionInfo = Ae(Phe, null, o), t;
  }
  function Nhe(n) {
    var e = n.sourceFormat;
    if (!mE(e)) {
      var t = "";
      nn(t);
    }
    return n.data;
  }
  function Ehe(n) {
    var e = n.sourceFormat, t = n.data;
    if (!mE(e)) {
      var r = "";
      nn(r);
    }
    if (e === Pi) {
      for (var i = [], a = 0, s = t.length; a < s; a++) i.push(t[a].slice());
      return i;
    } else if (e === Ts) {
      for (var i = [], a = 0, s = t.length; a < s; a++) i.push(oe({}, t[a]));
      return i;
    }
  }
  function Mhe(n, e, t) {
    if (t != null) {
      if (Yt(t) || !isNaN(t) && !$e(e, t)) return n[t];
      if ($e(e, t)) return e[t];
    }
  }
  function Phe(n) {
    return Qe(n);
  }
  var RX = Pe();
  function Lhe(n) {
    n = Qe(n);
    var e = n.type, t = "";
    e || nn(t);
    var r = e.split(":");
    r.length !== 2 && nn(t);
    var i = false;
    r[0] === "echarts" && (e = r[1], i = true), n.__isBuiltIn = i, RX.set(e, n);
  }
  function Fhe(n, e, t) {
    var r = xn(n), i = r.length, a = "";
    i || nn(a);
    for (var s = 0, o = i; s < o; s++) {
      var l = r[s];
      e = Ohe(l, e), s !== o - 1 && (e.length = Math.max(e.length, 1));
    }
    return e;
  }
  function Ohe(n, e, t, r) {
    var i = "";
    e.length || nn(i), Ze(n) || nn(i);
    var a = n.type, s = RX.get(a);
    s || nn(i);
    var o = me(e, function(u) {
      return $he(u, s);
    }), l = xn(s.transform({
      upstream: o[0],
      upstreamList: o,
      config: Qe(n.config)
    }));
    return me(l, function(u, c) {
      var h = "";
      Ze(u) || nn(h), u.data || nn(h);
      var d = wX(u.data);
      mE(d) || nn(h);
      var f, p = e[0];
      if (p && c === 0 && !u.dimensions) {
        var g = p.startIndex;
        g && (u.data = p.data.slice(0, g).concat(u.data)), f = {
          seriesLayoutBy: Ho,
          sourceHeader: g,
          dimensions: p.metaRawOption.dimensions
        };
      } else f = {
        seriesLayoutBy: Ho,
        sourceHeader: 0,
        dimensions: u.dimensions
      };
      return QD(u.data, f, null);
    });
  }
  function mE(n) {
    return n === Pi || n === Ts;
  }
  var PC = "undefined", Bhe = typeof Uint32Array === PC ? Array : Uint32Array, zhe = typeof Uint16Array === PC ? Array : Uint16Array, $X = typeof Int32Array === PC ? Array : Int32Array, CO = typeof Float64Array === PC ? Array : Float64Array, NX = {
    float: CO,
    int: $X,
    ordinal: Array,
    number: Array,
    time: CO
  }, bk;
  function Np(n) {
    return n > 65535 ? Bhe : zhe;
  }
  function Ep() {
    return [
      1 / 0,
      -1 / 0
    ];
  }
  function Vhe(n) {
    var e = n.constructor;
    return e === Array ? n.slice() : new e(n);
  }
  function IO(n, e, t, r, i) {
    var a = NX[t || "float"];
    if (i) {
      var s = n[e], o = s && s.length;
      if (o !== r) {
        for (var l = new a(r), u = 0; u < o; u++) l[u] = s[u];
        n[e] = l;
      }
    } else n[e] = new a(r);
  }
  var JD = function() {
    function n() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = Pe();
    }
    return n.prototype.initData = function(e, t, r) {
      this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = e.getSource(), a = this.defaultDimValueGetter = bk[i.sourceFormat];
      this._dimValueGetter = r || a, this._rawExtent = [], _X(i), this._dimensions = me(t, function(s) {
        return {
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, e.count());
    }, n.prototype.getProvider = function() {
      return this._provider;
    }, n.prototype.getSource = function() {
      return this._provider.getSource();
    }, n.prototype.ensureCalculationDimension = function(e, t) {
      var r = this._calcDimNameToIdx, i = this._dimensions, a = r.get(e);
      if (a != null) {
        if (i[a].type === t) return a;
      } else a = i.length;
      return i[a] = {
        type: t
      }, r.set(e, a), this._chunks[a] = new NX[t || "float"](this._rawCount), this._rawExtent[a] = Ep(), a;
    }, n.prototype.collectOrdinalMeta = function(e, t) {
      var r = this._chunks[e], i = this._dimensions[e], a = this._rawExtent, s = i.ordinalOffset || 0, o = r.length;
      s === 0 && (a[e] = Ep());
      for (var l = a[e], u = s; u < o; u++) {
        var c = r[u] = t.parseAndCollect(r[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = t, i.ordinalOffset = o, i.type = "ordinal";
    }, n.prototype.getOrdinalMeta = function(e) {
      var t = this._dimensions[e], r = t.ordinalMeta;
      return r;
    }, n.prototype.getDimensionProperty = function(e) {
      var t = this._dimensions[e];
      return t && t.property;
    }, n.prototype.appendData = function(e) {
      var t = this._provider, r = this.count();
      t.appendData(e);
      var i = t.count();
      return t.persistent || (i += r), r < i && this._initDataFromProvider(r, i, true), [
        r,
        i
      ];
    }, n.prototype.appendValues = function(e, t) {
      for (var r = this._chunks, i = this._dimensions, a = i.length, s = this._rawExtent, o = this.count(), l = o + Math.max(e.length, t || 0), u = 0; u < a; u++) {
        var c = i[u];
        IO(r, u, c.type, l, true);
      }
      for (var h = [], d = o; d < l; d++) for (var f = d - o, p = 0; p < a; p++) {
        var c = i[p], g = bk.arrayRows.call(this, e[f] || h, c.property, f, p);
        r[p][d] = g;
        var m = s[p];
        g < m[0] && (m[0] = g), g > m[1] && (m[1] = g);
      }
      return this._rawCount = this._count = l, {
        start: o,
        end: l
      };
    }, n.prototype._initDataFromProvider = function(e, t, r) {
      for (var i = this._provider, a = this._chunks, s = this._dimensions, o = s.length, l = this._rawExtent, u = me(s, function(y) {
        return y.property;
      }), c = 0; c < o; c++) {
        var h = s[c];
        l[c] || (l[c] = Ep()), IO(a, c, h.type, t, r);
      }
      if (i.fillStorage) i.fillStorage(e, t, a, l);
      else for (var d = [], f = e; f < t; f++) {
        d = i.getItem(f, d);
        for (var p = 0; p < o; p++) {
          var g = a[p], m = this._dimValueGetter(d, u[p], f, p);
          g[f] = m;
          var v = l[p];
          m < v[0] && (v[0] = m), m > v[1] && (v[1] = m);
        }
      }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = t, this._extent = [];
    }, n.prototype.count = function() {
      return this._count;
    }, n.prototype.get = function(e, t) {
      if (!(t >= 0 && t < this._count)) return NaN;
      var r = this._chunks[e];
      return r ? r[this.getRawIndex(t)] : NaN;
    }, n.prototype.getValues = function(e, t) {
      var r = [], i = [];
      if (t == null) {
        t = e, e = [];
        for (var a = 0; a < this._dimensions.length; a++) i.push(a);
      } else i = e;
      for (var a = 0, s = i.length; a < s; a++) r.push(this.get(i[a], t));
      return r;
    }, n.prototype.getByRawIndex = function(e, t) {
      if (!(t >= 0 && t < this._rawCount)) return NaN;
      var r = this._chunks[e];
      return r ? r[t] : NaN;
    }, n.prototype.getSum = function(e) {
      var t = this._chunks[e], r = 0;
      if (t) for (var i = 0, a = this.count(); i < a; i++) {
        var s = this.get(e, i);
        isNaN(s) || (r += s);
      }
      return r;
    }, n.prototype.getMedian = function(e) {
      var t = [];
      this.each([
        e
      ], function(a) {
        isNaN(a) || t.push(a);
      });
      var r = t.sort(function(a, s) {
        return a - s;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? r[(i - 1) / 2] : (r[i / 2] + r[i / 2 - 1]) / 2;
    }, n.prototype.indexOfRawIndex = function(e) {
      if (e >= this._rawCount || e < 0) return -1;
      if (!this._indices) return e;
      var t = this._indices, r = t[e];
      if (r != null && r < this._count && r === e) return e;
      for (var i = 0, a = this._count - 1; i <= a; ) {
        var s = (i + a) / 2 | 0;
        if (t[s] < e) i = s + 1;
        else if (t[s] > e) a = s - 1;
        else return s;
      }
      return -1;
    }, n.prototype.indicesOfNearest = function(e, t, r) {
      var i = this._chunks, a = i[e], s = [];
      if (!a) return s;
      r == null && (r = 1 / 0);
      for (var o = 1 / 0, l = -1, u = 0, c = 0, h = this.count(); c < h; c++) {
        var d = this.getRawIndex(c), f = t - a[d], p = Math.abs(f);
        p <= r && ((p < o || p === o && f >= 0 && l < 0) && (o = p, l = f, u = 0), f === l && (s[u++] = c));
      }
      return s.length = u, s;
    }, n.prototype.getIndices = function() {
      var e, t = this._indices;
      if (t) {
        var r = t.constructor, i = this._count;
        if (r === Array) {
          e = new r(i);
          for (var a = 0; a < i; a++) e[a] = t[a];
        } else e = new r(t.buffer, 0, i);
      } else {
        var r = Np(this._rawCount);
        e = new r(this.count());
        for (var a = 0; a < e.length; a++) e[a] = a;
      }
      return e;
    }, n.prototype.filter = function(e, t) {
      if (!this._count) return this;
      for (var r = this.clone(), i = r.count(), a = Np(r._rawCount), s = new a(i), o = [], l = e.length, u = 0, c = e[0], h = r._chunks, d = 0; d < i; d++) {
        var f = void 0, p = r.getRawIndex(d);
        if (l === 0) f = t(d);
        else if (l === 1) {
          var g = h[c][p];
          f = t(g, d);
        } else {
          for (var m = 0; m < l; m++) o[m] = h[e[m]][p];
          o[m] = d, f = t.apply(null, o);
        }
        f && (s[u++] = p);
      }
      return u < i && (r._indices = s), r._count = u, r._extent = [], r._updateGetRawIdx(), r;
    }, n.prototype.selectRange = function(e) {
      var t = this.clone(), r = t._count;
      if (!r) return this;
      var i = Mt(e), a = i.length;
      if (!a) return this;
      var s = t.count(), o = Np(t._rawCount), l = new o(s), u = 0, c = i[0], h = e[c][0], d = e[c][1], f = t._chunks, p = false;
      if (!t._indices) {
        var g = 0;
        if (a === 1) {
          for (var m = f[i[0]], v = 0; v < r; v++) {
            var y = m[v];
            (y >= h && y <= d || isNaN(y)) && (l[u++] = g), g++;
          }
          p = true;
        } else if (a === 2) {
          for (var m = f[i[0]], x = f[i[1]], b = e[i[1]][0], w = e[i[1]][1], v = 0; v < r; v++) {
            var y = m[v], _ = x[v];
            (y >= h && y <= d || isNaN(y)) && (_ >= b && _ <= w || isNaN(_)) && (l[u++] = g), g++;
          }
          p = true;
        }
      }
      if (!p) if (a === 1) for (var v = 0; v < s; v++) {
        var S = t.getRawIndex(v), y = f[i[0]][S];
        (y >= h && y <= d || isNaN(y)) && (l[u++] = S);
      }
      else for (var v = 0; v < s; v++) {
        for (var I = true, S = t.getRawIndex(v), C = 0; C < a; C++) {
          var T = i[C], y = f[T][S];
          (y < e[T][0] || y > e[T][1]) && (I = false);
        }
        I && (l[u++] = t.getRawIndex(v));
      }
      return u < s && (t._indices = l), t._count = u, t._extent = [], t._updateGetRawIdx(), t;
    }, n.prototype.map = function(e, t) {
      var r = this.clone(e);
      return this._updateDims(r, e, t), r;
    }, n.prototype.modify = function(e, t) {
      this._updateDims(this, e, t);
    }, n.prototype._updateDims = function(e, t, r) {
      for (var i = e._chunks, a = [], s = t.length, o = e.count(), l = [], u = e._rawExtent, c = 0; c < t.length; c++) u[t[c]] = Ep();
      for (var h = 0; h < o; h++) {
        for (var d = e.getRawIndex(h), f = 0; f < s; f++) l[f] = i[t[f]][d];
        l[s] = h;
        var p = r && r.apply(null, l);
        if (p != null) {
          typeof p != "object" && (a[0] = p, p = a);
          for (var c = 0; c < p.length; c++) {
            var g = t[c], m = p[c], v = u[g], y = i[g];
            y && (y[d] = m), m < v[0] && (v[0] = m), m > v[1] && (v[1] = m);
          }
        }
      }
    }, n.prototype.lttbDownSample = function(e, t) {
      var r = this.clone([
        e
      ], true), i = r._chunks, a = i[e], s = this.count(), o = 0, l = Math.floor(1 / t), u = this.getRawIndex(0), c, h, d, f = new (Np(this._rawCount))(Math.min((Math.ceil(s / l) + 2) * 2, s));
      f[o++] = u;
      for (var p = 1; p < s - 1; p += l) {
        for (var g = Math.min(p + l, s - 1), m = Math.min(p + l * 2, s), v = (m + g) / 2, y = 0, x = g; x < m; x++) {
          var b = this.getRawIndex(x), w = a[b];
          isNaN(w) || (y += w);
        }
        y /= m - g;
        var _ = p, S = Math.min(p + l, s), I = p - 1, C = a[u];
        c = -1, d = _;
        for (var T = -1, k = 0, x = _; x < S; x++) {
          var b = this.getRawIndex(x), w = a[b];
          if (isNaN(w)) {
            k++, T < 0 && (T = b);
            continue;
          }
          h = Math.abs((I - v) * (w - C) - (I - x) * (y - C)), h > c && (c = h, d = b);
        }
        k > 0 && k < S - _ && (f[o++] = Math.min(T, d), d = Math.max(T, d)), f[o++] = d, u = d;
      }
      return f[o++] = this.getRawIndex(s - 1), r._count = o, r._indices = f, r.getRawIndex = this._getRawIdx, r;
    }, n.prototype.minmaxDownSample = function(e, t) {
      for (var r = this.clone([
        e
      ], true), i = r._chunks, a = Math.floor(1 / t), s = i[e], o = this.count(), l = new (Np(this._rawCount))(Math.ceil(o / a) * 2), u = 0, c = 0; c < o; c += a) {
        var h = c, d = s[this.getRawIndex(h)], f = c, p = s[this.getRawIndex(f)], g = a;
        c + a > o && (g = o - c);
        for (var m = 0; m < g; m++) {
          var v = this.getRawIndex(c + m), y = s[v];
          y < d && (d = y, h = c + m), y > p && (p = y, f = c + m);
        }
        var x = this.getRawIndex(h), b = this.getRawIndex(f);
        h < f ? (l[u++] = x, l[u++] = b) : (l[u++] = b, l[u++] = x);
      }
      return r._count = u, r._indices = l, r._updateGetRawIdx(), r;
    }, n.prototype.downSample = function(e, t, r, i) {
      for (var a = this.clone([
        e
      ], true), s = a._chunks, o = [], l = Math.floor(1 / t), u = s[e], c = this.count(), h = a._rawExtent[e] = Ep(), d = new (Np(this._rawCount))(Math.ceil(c / l)), f = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, o.length = l);
        for (var g = 0; g < l; g++) {
          var m = this.getRawIndex(p + g);
          o[g] = u[m];
        }
        var v = r(o), y = this.getRawIndex(Math.min(p + i(o, v) || 0, c - 1));
        u[y] = v, v < h[0] && (h[0] = v), v > h[1] && (h[1] = v), d[f++] = y;
      }
      return a._count = f, a._indices = d, a._updateGetRawIdx(), a;
    }, n.prototype.each = function(e, t) {
      if (this._count) for (var r = e.length, i = this._chunks, a = 0, s = this.count(); a < s; a++) {
        var o = this.getRawIndex(a);
        switch (r) {
          case 0:
            t(a);
            break;
          case 1:
            t(i[e[0]][o], a);
            break;
          case 2:
            t(i[e[0]][o], i[e[1]][o], a);
            break;
          default:
            for (var l = 0, u = []; l < r; l++) u[l] = i[e[l]][o];
            u[l] = a, t.apply(null, u);
        }
      }
    }, n.prototype.getDataExtent = function(e) {
      var t = this._chunks[e], r = Ep();
      if (!t) return r;
      var i = this.count(), a = !this._indices, s;
      if (a) return this._rawExtent[e].slice();
      if (s = this._extent[e], s) return s.slice();
      s = r;
      for (var o = s[0], l = s[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), h = t[c];
        h < o && (o = h), h > l && (l = h);
      }
      return s = [
        o,
        l
      ], this._extent[e] = s, s;
    }, n.prototype.getRawDataItem = function(e) {
      var t = this.getRawIndex(e);
      if (this._provider.persistent) return this._provider.getItem(t);
      for (var r = [], i = this._chunks, a = 0; a < i.length; a++) r.push(i[a][t]);
      return r;
    }, n.prototype.clone = function(e, t) {
      var r = new n(), i = this._chunks, a = e && Qo(e, function(o, l) {
        return o[l] = true, o;
      }, {});
      if (a) for (var s = 0; s < i.length; s++) r._chunks[s] = a[s] ? Vhe(i[s]) : i[s];
      else r._chunks = i;
      return this._copyCommonProps(r), t || (r._indices = this._cloneIndices()), r._updateGetRawIdx(), r;
    }, n.prototype._copyCommonProps = function(e) {
      e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = Qe(this._extent), e._rawExtent = Qe(this._rawExtent);
    }, n.prototype._cloneIndices = function() {
      if (this._indices) {
        var e = this._indices.constructor, t = void 0;
        if (e === Array) {
          var r = this._indices.length;
          t = new e(r);
          for (var i = 0; i < r; i++) t[i] = this._indices[i];
        } else t = new e(this._indices);
        return t;
      }
      return null;
    }, n.prototype._getRawIdxIdentity = function(e) {
      return e;
    }, n.prototype._getRawIdx = function(e) {
      return e < this._count && e >= 0 ? this._indices[e] : -1;
    }, n.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, n.internalField = function() {
      function e(t, r, i, a) {
        return Yu(t[a], this._dimensions[a]);
      }
      bk = {
        arrayRows: e,
        objectRows: function(t, r, i, a) {
          return Yu(t[r], this._dimensions[a]);
        },
        keyedColumns: e,
        original: function(t, r, i, a) {
          var s = t && (t.value == null ? t : t.value);
          return Yu(s instanceof Array ? s[a] : s, this._dimensions[a]);
        },
        typedArray: function(t, r, i, a) {
          return t[a];
        }
      };
    }(), n;
  }(), EX = function() {
    function n(e) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = true, this._sourceHost = e;
    }
    return n.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = true;
    }, n.prototype._setLocalSource = function(e, t) {
      this._sourceList = e, this._upstreamSignList = t, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, n.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, n.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = false);
    }, n.prototype._createSource = function() {
      this._setLocalSource([], []);
      var e = this._sourceHost, t = this._getUpstreamSourceManagers(), r = !!t.length, i, a;
      if ($1(e)) {
        var s = e, o = void 0, l = void 0, u = void 0;
        if (r) {
          var c = t[0];
          c.prepareSource(), u = c.getSource(), o = u.data, l = u.sourceFormat, a = [
            c._getVersionSign()
          ];
        } else o = s.get("data", true), l = Ia(o) ? Xu : ks, a = [];
        var h = this._getSourceMetaRawOption() || {}, d = u && u.metaRawOption || {}, f = it(h.seriesLayoutBy, d.seriesLayoutBy) || null, p = it(h.sourceHeader, d.sourceHeader), g = it(h.dimensions, d.dimensions), m = f !== d.seriesLayoutBy || !!p != !!d.sourceHeader || g;
        i = m ? [
          QD(o, {
            seriesLayoutBy: f,
            sourceHeader: p,
            dimensions: g
          }, l)
        ] : [];
      } else {
        var v = e;
        if (r) {
          var y = this._applyTransform(t);
          i = y.sourceList, a = y.upstreamSignList;
        } else {
          var x = v.get("source", true);
          i = [
            QD(x, this._getSourceMetaRawOption(), null)
          ], a = [];
        }
      }
      this._setLocalSource(i, a);
    }, n.prototype._applyTransform = function(e) {
      var t = this._sourceHost, r = t.get("transform", true), i = t.get("fromTransformResult", true);
      if (i != null) {
        var a = "";
        e.length !== 1 && TO(a);
      }
      var s, o = [], l = [];
      return P(e, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), h = "";
        i != null && !c && TO(h), o.push(c), l.push(u._getVersionSign());
      }), r ? s = Fhe(r, o, {
        datasetIndex: t.componentIndex
      }) : i != null && (s = [
        yhe(o[0])
      ]), {
        sourceList: s,
        upstreamSignList: l
      };
    }, n.prototype._isDirty = function() {
      if (this._dirty) return true;
      for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) {
        var r = e[t];
        if (r._isDirty() || this._upstreamSignList[t] !== r._getVersionSign()) return true;
      }
    }, n.prototype.getSource = function(e) {
      e = e || 0;
      var t = this._sourceList[e];
      if (!t) {
        var r = this._getUpstreamSourceManagers();
        return r[0] && r[0].getSource(e);
      }
      return t;
    }, n.prototype.getSharedDataStore = function(e) {
      var t = e.makeStoreSchema();
      return this._innerGetDataStore(t.dimensions, e.source, t.hash);
    }, n.prototype._innerGetDataStore = function(e, t, r) {
      var i = 0, a = this._storeList, s = a[i];
      s || (s = a[i] = {});
      var o = s[r];
      if (!o) {
        var l = this._getUpstreamSourceManagers()[0];
        $1(this._sourceHost) && l ? o = l._innerGetDataStore(e, t, r) : (o = new JD(), o.initData(new SX(t, e.length), e)), s[r] = o;
      }
      return o;
    }, n.prototype._getUpstreamSourceManagers = function() {
      var e = this._sourceHost;
      if ($1(e)) {
        var t = cE(e);
        return t ? [
          t.getSourceManager()
        ] : [];
      } else return me(Yce(e), function(r) {
        return r.getSourceManager();
      });
    }, n.prototype._getSourceMetaRawOption = function() {
      var e = this._sourceHost, t, r, i;
      if ($1(e)) t = e.get("seriesLayoutBy", true), r = e.get("sourceHeader", true), i = e.get("dimensions", true);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = e;
        t = a.get("seriesLayoutBy", true), r = a.get("sourceHeader", true), i = a.get("dimensions", true);
      }
      return {
        seriesLayoutBy: t,
        sourceHeader: r,
        dimensions: i
      };
    }, n;
  }();
  function kO(n) {
    var e = n.option.transform;
    e && R_(n.option.transform);
  }
  function $1(n) {
    return n.mainType === "series";
  }
  function TO(n) {
    throw new Error(n);
  }
  var Whe = "line-height:1";
  function MX(n) {
    var e = n.lineHeight;
    return e == null ? Whe : "line-height:" + Hi(e + "") + "px";
  }
  function PX(n, e) {
    var t = n.color || "#6e7079", r = n.fontSize || 12, i = n.fontWeight || "400", a = n.color || "#464646", s = n.fontSize || 14, o = n.fontWeight || "900";
    return e === "html" ? {
      nameStyle: "font-size:" + Hi(r + "") + "px;color:" + Hi(t) + ";font-weight:" + Hi(i + ""),
      valueStyle: "font-size:" + Hi(s + "") + "px;color:" + Hi(a) + ";font-weight:" + Hi(o + "")
    } : {
      nameStyle: {
        fontSize: r,
        fill: t,
        fontWeight: i
      },
      valueStyle: {
        fontSize: s,
        fill: a,
        fontWeight: o
      }
    };
  }
  var Ghe = [
    0,
    10,
    20,
    30
  ], Uhe = [
    "",
    `
`,
    `

`,
    `


`
  ];
  function Xr(n, e) {
    return e.type = n, e;
  }
  function eR(n) {
    return n.type === "section";
  }
  function LX(n) {
    return eR(n) ? Hhe : Xhe;
  }
  function FX(n) {
    if (eR(n)) {
      var e = 0, t = n.blocks.length, r = t > 1 || t > 0 && !n.noHeader;
      return P(n.blocks, function(i) {
        var a = FX(i);
        a >= e && (e = a + +(r && (!a || eR(i) && !i.noHeader)));
      }), e;
    }
    return 0;
  }
  function Hhe(n, e, t, r) {
    var i = e.noHeader, a = Yhe(FX(e)), s = [], o = e.blocks || [];
    ta(!o || de(o)), o = o || [];
    var l = n.orderMode;
    if (e.sortBlocks && l) {
      o = o.slice();
      var u = {
        valueAsc: "asc",
        valueDesc: "desc"
      };
      if ($e(u, l)) {
        var c = new DX(u[l], null);
        o.sort(function(g, m) {
          return c.evaluate(g.sortParam, m.sortParam);
        });
      } else l === "seriesDesc" && o.reverse();
    }
    P(o, function(g, m) {
      var v = e.valueFormatter, y = LX(g)(v ? oe(oe({}, n), {
        valueFormatter: v
      }) : n, g, m > 0 ? a.html : 0, r);
      y != null && s.push(y);
    });
    var h = n.renderMode === "richText" ? s.join(a.richText) : tR(r, s.join(""), i ? t : a.html);
    if (i) return h;
    var d = jD(e.header, "ordinal", n.useUTC), f = PX(r, n.renderMode).nameStyle, p = MX(r);
    return n.renderMode === "richText" ? OX(n, d, f) + a.richText + h : tR(r, '<div style="' + f + ";" + p + ';">' + Hi(d) + "</div>" + h, t);
  }
  function Xhe(n, e, t, r) {
    var i = n.renderMode, a = e.noName, s = e.noValue, o = !e.markerType, l = e.name, u = n.useUTC, c = e.valueFormatter || n.valueFormatter || function(b) {
      return b = de(b) ? b : [
        b
      ], me(b, function(w, _) {
        return jD(w, de(f) ? f[_] : f, u);
      });
    };
    if (!(a && s)) {
      var h = o ? "" : n.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", i), d = a ? "" : jD(l, "ordinal", u), f = e.valueType, p = s ? [] : c(e.value, e.dataIndex), g = !o || !a, m = !o && a, v = PX(r, i), y = v.nameStyle, x = v.valueStyle;
      return i === "richText" ? (o ? "" : h) + (a ? "" : OX(n, d, y)) + (s ? "" : Khe(n, p, g, m, x)) : tR(r, (o ? "" : h) + (a ? "" : qhe(d, !o, y)) + (s ? "" : jhe(p, g, m, x)), t);
    }
  }
  function AO(n, e, t, r, i, a) {
    if (n) {
      var s = LX(n), o = {
        useUTC: i,
        renderMode: t,
        orderMode: r,
        markupStyleCreator: e,
        valueFormatter: n.valueFormatter
      };
      return s(o, n, 0, a);
    }
  }
  function Yhe(n) {
    return {
      html: Ghe[n],
      richText: Uhe[n]
    };
  }
  function tR(n, e, t) {
    var r = '<div style="clear:both"></div>', i = "margin: " + t + "px 0 0", a = MX(n);
    return '<div style="' + i + ";" + a + ';">' + e + r + "</div>";
  }
  function qhe(n, e, t) {
    var r = e ? "margin-left:2px" : "";
    return '<span style="' + t + ";" + r + '">' + Hi(n) + "</span>";
  }
  function jhe(n, e, t, r) {
    var i = t ? "10px" : "20px", a = e ? "float:right;margin-left:" + i : "";
    return n = de(n) ? n : [
      n
    ], '<span style="' + a + ";" + r + '">' + me(n, function(s) {
      return Hi(s);
    }).join("&nbsp;&nbsp;") + "</span>";
  }
  function OX(n, e, t) {
    return n.markupStyleCreator.wrapRichTextStyle(e, t);
  }
  function Khe(n, e, t, r, i) {
    var a = [
      i
    ], s = r ? 10 : 20;
    return t && a.push({
      padding: [
        0,
        0,
        0,
        s
      ],
      align: "right"
    }), n.markupStyleCreator.wrapRichTextStyle(de(e) ? e.join("  ") : e, a);
  }
  function BX(n, e) {
    var t = n.getData().getItemVisual(e, "style"), r = t[n.visualDrawType];
    return fd(r);
  }
  function zX(n, e) {
    var t = n.get("padding");
    return t ?? (e === "richText" ? [
      8,
      10
    ] : 10);
  }
  var wk = function() {
    function n() {
      this.richTextStyles = {}, this._nextStyleNameId = t8();
    }
    return n.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, n.prototype.makeTooltipMarker = function(e, t, r) {
      var i = r === "richText" ? this._generateStyleName() : null, a = zce({
        color: t,
        type: e,
        renderMode: r,
        markerId: i
      });
      return Ie(a) ? a : (this.richTextStyles[i] = a.style, a.content);
    }, n.prototype.wrapRichTextStyle = function(e, t) {
      var r = {};
      de(t) ? P(t, function(a) {
        return oe(r, a);
      }) : oe(r, t);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = r, "{" + i + "|" + e + "}";
    }, n;
  }();
  function VX(n) {
    var e = n.series, t = n.dataIndex, r = n.multipleSeries, i = e.getData(), a = i.mapDimensionsAll("defaultedTooltip"), s = a.length, o = e.getRawValue(t), l = de(o), u = BX(e, t), c, h, d, f;
    if (s > 1 || l && !s) {
      var p = Zhe(o, e, t, a, u);
      c = p.inlineValues, h = p.inlineValueTypes, d = p.blocks, f = p.inlineValues[0];
    } else if (s) {
      var g = i.getDimensionInfo(a[0]);
      f = c = Pg(i, t, a[0]), h = g.type;
    } else f = c = l ? o[0] : o;
    var m = WN(e), v = m && e.name || "", y = i.getName(t), x = r ? v : y;
    return Xr("section", {
      header: v,
      noHeader: r || !m,
      sortParam: f,
      blocks: [
        Xr("nameValue", {
          markerType: "item",
          markerColor: u,
          name: x,
          noName: !Hs(x),
          value: c,
          valueType: h,
          dataIndex: t
        })
      ].concat(d || [])
    });
  }
  function Zhe(n, e, t, r, i) {
    var a = e.getData(), s = Qo(n, function(h, d, f) {
      var p = a.getDimensionInfo(f);
      return h = h || p && p.tooltip !== false && p.displayName != null;
    }, false), o = [], l = [], u = [];
    r.length ? P(r, function(h) {
      c(Pg(a, t, h), h);
    }) : P(n, c);
    function c(h, d) {
      var f = a.getDimensionInfo(d);
      !f || f.otherDims.tooltip === false || (s ? u.push(Xr("nameValue", {
        markerType: "subItem",
        markerColor: i,
        name: f.displayName,
        value: h,
        valueType: f.type
      })) : (o.push(h), l.push(f.type)));
    }
    return {
      inlineValues: o,
      inlineValueTypes: l,
      blocks: u
    };
  }
  var vu = Wt();
  function N1(n, e) {
    return n.getName(e) || n.getId(e);
  }
  var o_ = "__universalTransitionEnabled", En = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t._selectedDataIndicesMap = {}, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = u0({
        count: Jhe,
        reset: ede
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(t, i);
      var a = vu(this).sourceManager = new EX(this);
      a.prepareSource();
      var s = this.getInitialData(t, i);
      RO(s, this), this.dataTask.context.data = s, vu(this).dataBeforeProcessed = s, DO(this), this._initSelectedMapFromData(s);
    }, e.prototype.mergeDefaultAndTheme = function(t, r) {
      var i = P0(this), a = i ? bm(t) : {}, s = this.subType;
      Et.hasClass(s) && (s += "Series"), pt(t, r.getTheme().get(this.subType)), pt(t, this.getDefaultOption()), ud(t, "label", [
        "show"
      ]), this.fillDataTextStyle(t.data), i && rc(t, a, i);
    }, e.prototype.mergeOption = function(t, r) {
      t = pt(this.option, t, true), this.fillDataTextStyle(t.data);
      var i = P0(this);
      i && rc(this.option, t, i);
      var a = vu(this).sourceManager;
      a.dirty(), a.prepareSource();
      var s = this.getInitialData(t, r);
      RO(s, this), this.dataTask.dirty(), this.dataTask.context.data = s, vu(this).dataBeforeProcessed = s, DO(this), this._initSelectedMapFromData(s);
    }, e.prototype.fillDataTextStyle = function(t) {
      if (t && !Ia(t)) for (var r = [
        "show"
      ], i = 0; i < t.length; i++) t[i] && t[i].label && ud(t[i], "label", r);
    }, e.prototype.getInitialData = function(t, r) {
    }, e.prototype.appendData = function(t) {
      var r = this.getRawData();
      r.appendData(t.data);
    }, e.prototype.getData = function(t) {
      var r = nR(this);
      if (r) {
        var i = r.context.data;
        return t == null || !i.getLinkedData ? i : i.getLinkedData(t);
      } else return vu(this).data;
    }, e.prototype.getAllData = function() {
      var t = this.getData();
      return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [
        {
          data: t
        }
      ];
    }, e.prototype.setData = function(t) {
      var r = nR(this);
      if (r) {
        var i = r.context;
        i.outputData = t, r !== this.dataTask && (i.data = t);
      }
      vu(this).data = t;
    }, e.prototype.getEncode = function() {
      var t = this.get("encode", true);
      if (t) return Pe(t);
    }, e.prototype.getSourceManager = function() {
      return vu(this).sourceManager;
    }, e.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, e.prototype.getRawData = function() {
      return vu(this).dataBeforeProcessed;
    }, e.prototype.getColorBy = function() {
      var t = this.get("colorBy");
      return t || "series";
    }, e.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, e.prototype.getBaseAxis = function() {
      var t = this.coordinateSystem;
      return t && t.getBaseAxis && t.getBaseAxis();
    }, e.prototype.formatTooltip = function(t, r, i) {
      return VX({
        series: this,
        dataIndex: t,
        multipleSeries: r
      });
    }, e.prototype.isAnimationEnabled = function() {
      var t = this.ecModel;
      if (Dt.node && !(t && t.ssr)) return false;
      var r = this.getShallow("animation");
      return r && this.getData().count() > this.getShallow("animationThreshold") && (r = false), !!r;
    }, e.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, e.prototype.getColorFromPalette = function(t, r, i) {
      var a = this.ecModel, s = hE.prototype.getColorFromPalette.call(this, t, r, i);
      return s || (s = a.getColorFromPalette(t, r, i)), s;
    }, e.prototype.coordDimToDataDim = function(t) {
      return this.getRawData().mapDimensionsAll(t);
    }, e.prototype.getProgressive = function() {
      return this.get("progressive");
    }, e.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, e.prototype.select = function(t, r) {
      this._innerSelect(this.getData(r), t);
    }, e.prototype.unselect = function(t, r) {
      var i = this.option.selectedMap;
      if (i) {
        var a = this.option.selectedMode, s = this.getData(r);
        if (a === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var o = 0; o < t.length; o++) {
          var l = t[o], u = N1(s, l);
          i[u] = false, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, e.prototype.toggleSelect = function(t, r) {
      for (var i = [], a = 0; a < t.length; a++) i[0] = t[a], this.isSelected(t[a], r) ? this.unselect(i, r) : this.select(i, r);
    }, e.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices());
      for (var t = this._selectedDataIndicesMap, r = Mt(t), i = [], a = 0; a < r.length; a++) {
        var s = t[r[a]];
        s >= 0 && i.push(s);
      }
      return i;
    }, e.prototype.isSelected = function(t, r) {
      var i = this.option.selectedMap;
      if (!i) return false;
      var a = this.getData(r);
      return (i === "all" || i[N1(a, t)]) && !a.getItemModel(t).get([
        "select",
        "disabled"
      ]);
    }, e.prototype.isUniversalTransitionEnabled = function() {
      if (this[o_]) return true;
      var t = this.option.universalTransition;
      return t ? t === true ? true : t && t.enabled : false;
    }, e.prototype._innerSelect = function(t, r) {
      var i, a, s = this.option, o = s.selectedMode, l = r.length;
      if (!(!o || !l)) {
        if (o === "series") s.selectedMap = "all";
        else if (o === "multiple") {
          Ze(s.selectedMap) || (s.selectedMap = {});
          for (var u = s.selectedMap, c = 0; c < l; c++) {
            var h = r[c], d = N1(t, h);
            u[d] = true, this._selectedDataIndicesMap[d] = t.getRawIndex(h);
          }
        } else if (o === "single" || o === true) {
          var f = r[l - 1], d = N1(t, f);
          s.selectedMap = (i = {}, i[d] = true, i), this._selectedDataIndicesMap = (a = {}, a[d] = t.getRawIndex(f), a);
        }
      }
    }, e.prototype._initSelectedMapFromData = function(t) {
      if (!this.option.selectedMap) {
        var r = [];
        t.hasItemOption && t.each(function(i) {
          var a = t.getRawDataItem(i);
          a && a.selected && r.push(i);
        }), r.length > 0 && this._innerSelect(t, r);
      }
    }, e.registerClass = function(t) {
      return Et.registerClass(t);
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = false, t.hasSymbolVisual = false, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill";
    }(), e;
  }(Et);
  br(En, MC);
  br(En, hE);
  c8(En, Et);
  function DO(n) {
    var e = n.name;
    WN(n) || (n.name = Qhe(n) || e);
  }
  function Qhe(n) {
    var e = n.getRawData(), t = e.mapDimensionsAll("seriesName"), r = [];
    return P(t, function(i) {
      var a = e.getDimensionInfo(i);
      a.displayName && r.push(a.displayName);
    }), r.join(" ");
  }
  function Jhe(n) {
    return n.model.getRawData().count();
  }
  function ede(n) {
    var e = n.model;
    return e.setData(e.getRawData().cloneShallow()), tde;
  }
  function tde(n, e) {
    e.outputData && n.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
  }
  function RO(n, e) {
    P(I0(n.CHANGABLE_METHODS, n.DOWNSAMPLE_METHODS), function(t) {
      n.wrapMethod(t, lt(nde, e));
    });
  }
  function nde(n, e) {
    var t = nR(n);
    return t && t.setOutputEnd((e || this).count()), e;
  }
  function nR(n) {
    var e = (n.ecModel || {}).scheduler, t = e && e.getPipeline(n.uid);
    if (t) {
      var r = t.currentTask;
      if (r) {
        var i = r.agentStubMap;
        i && (r = i.get(n.uid));
      }
      return r;
    }
  }
  var Yn = function() {
    function n() {
      this.group = new tt(), this.uid = ym("viewComponent");
    }
    return n.prototype.init = function(e, t) {
    }, n.prototype.render = function(e, t, r, i) {
    }, n.prototype.dispose = function(e, t) {
    }, n.prototype.updateView = function(e, t, r, i) {
    }, n.prototype.updateLayout = function(e, t, r, i) {
    }, n.prototype.updateVisual = function(e, t, r, i) {
    }, n.prototype.toggleBlurSeries = function(e, t, r) {
    }, n.prototype.eachRendered = function(e) {
      var t = this.group;
      t && t.traverse(e);
    }, n;
  }();
  UN(Yn);
  mC(Yn);
  function _m() {
    var n = Wt();
    return function(e) {
      var t = n(e), r = e.pipelineContext, i = !!t.large, a = !!t.progressiveRender, s = t.large = !!(r && r.large), o = t.progressiveRender = !!(r && r.progressiveRender);
      return (i !== s || a !== o) && "reset";
    };
  }
  var WX = Wt(), rde = _m(), _n = function() {
    function n() {
      this.group = new tt(), this.uid = ym("viewChart"), this.renderTask = u0({
        plan: ide,
        reset: ade
      }), this.renderTask.context = {
        view: this
      };
    }
    return n.prototype.init = function(e, t) {
    }, n.prototype.render = function(e, t, r, i) {
    }, n.prototype.highlight = function(e, t, r, i) {
      var a = e.getData(i && i.dataType);
      a && NO(a, i, "emphasis");
    }, n.prototype.downplay = function(e, t, r, i) {
      var a = e.getData(i && i.dataType);
      a && NO(a, i, "normal");
    }, n.prototype.remove = function(e, t) {
      this.group.removeAll();
    }, n.prototype.dispose = function(e, t) {
    }, n.prototype.updateView = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.updateLayout = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.updateVisual = function(e, t, r, i) {
      this.render(e, t, r, i);
    }, n.prototype.eachRendered = function(e) {
      gc(this.group, e);
    }, n.markUpdateMethod = function(e, t) {
      WX(e).updateMethod = t;
    }, n.protoInitialize = function() {
      var e = n.prototype;
      e.type = "chart";
    }(), n;
  }();
  function $O(n, e, t) {
    n && N0(n) && (e === "emphasis" ? Xl : Yl)(n, t);
  }
  function NO(n, e, t) {
    var r = cd(n, e), i = e && e.highlightKey != null ? zue(e.highlightKey) : null;
    r != null ? P(xn(r), function(a) {
      $O(n.getItemGraphicEl(a), t, i);
    }) : n.eachItemGraphicEl(function(a) {
      $O(a, t, i);
    });
  }
  UN(_n);
  mC(_n);
  function ide(n) {
    return rde(n.model);
  }
  function ade(n) {
    var e = n.model, t = n.ecModel, r = n.api, i = n.payload, a = e.pipelineContext.progressiveRender, s = n.view, o = i && WX(i).updateMethod, l = a ? "incrementalPrepareRender" : o && s[o] ? o : "render";
    return l !== "render" && s[l](e, t, r, i), sde[l];
  }
  var sde = {
    incrementalPrepareRender: {
      progress: function(n, e) {
        e.view.incrementalRender(n, e.model, e.ecModel, e.api, e.payload);
      }
    },
    render: {
      forceFirstProgress: true,
      progress: function(n, e) {
        e.view.render(e.model, e.ecModel, e.api, e.payload);
      }
    }
  }, X_ = "\0__throttleOriginMethod", EO = "\0__throttleRate", MO = "\0__throttleType";
  function vE(n, e, t) {
    var r, i = 0, a = 0, s = null, o, l, u, c;
    e = e || 0;
    function h() {
      a = (/* @__PURE__ */ new Date()).getTime(), s = null, n.apply(l, u || []);
    }
    var d = function() {
      for (var f = [], p = 0; p < arguments.length; p++) f[p] = arguments[p];
      r = (/* @__PURE__ */ new Date()).getTime(), l = this, u = f;
      var g = c || e, m = c || t;
      c = null, o = r - (m ? i : a) - g, clearTimeout(s), m ? s = setTimeout(h, g) : o >= 0 ? h() : s = setTimeout(h, -o), i = r;
    };
    return d.clear = function() {
      s && (clearTimeout(s), s = null);
    }, d.debounceNextCall = function(f) {
      c = f;
    }, d;
  }
  function Sm(n, e, t, r) {
    var i = n[e];
    if (i) {
      var a = i[X_] || i, s = i[MO], o = i[EO];
      if (o !== t || s !== r) {
        if (t == null || !r) return n[e] = a;
        i = n[e] = vE(a, t, r === "debounce"), i[X_] = a, i[MO] = r, i[EO] = t;
      }
      return i;
    }
  }
  function F0(n, e) {
    var t = n[e];
    t && t[X_] && (t.clear && t.clear(), n[e] = t[X_]);
  }
  var PO = Wt(), LO = {
    itemStyle: hd(q8, true),
    lineStyle: hd(Y8, true)
  }, ode = {
    lineStyle: "stroke",
    itemStyle: "fill"
  };
  function GX(n, e) {
    var t = n.visualStyleMapper || LO[e];
    return t || (console.warn("Unknown style type '" + e + "'."), LO.itemStyle);
  }
  function UX(n, e) {
    var t = n.visualDrawType || ode[e];
    return t || (console.warn("Unknown style type '" + e + "'."), "fill");
  }
  var lde = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(n, e) {
      var t = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = n.getModel(r), a = GX(n, r), s = a(i), o = i.getShallow("decal");
      o && (t.setVisual("decal", o), o.dirty = true);
      var l = UX(n, r), u = s[l], c = Xe(u) ? u : null, h = s.fill === "auto" || s.stroke === "auto";
      if (!s[l] || c || h) {
        var d = n.getColorFromPalette(n.name, null, e.getSeriesCount());
        s[l] || (s[l] = d, t.setVisual("colorFromPalette", true)), s.fill = s.fill === "auto" || Xe(s.fill) ? d : s.fill, s.stroke = s.stroke === "auto" || Xe(s.stroke) ? d : s.stroke;
      }
      if (t.setVisual("style", s), t.setVisual("drawType", l), !e.isSeriesFiltered(n) && c) return t.setVisual("colorFromPalette", false), {
        dataEach: function(f, p) {
          var g = n.getDataParams(p), m = oe({}, s);
          m[l] = c(g), f.setItemVisual(p, "style", m);
        }
      };
    }
  }, ey = new on(), ude = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(n, e) {
      if (!(n.ignoreStyleOnData || e.isSeriesFiltered(n))) {
        var t = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = GX(n, r), a = t.getVisual("drawType");
        return {
          dataEach: t.hasItemOption ? function(s, o) {
            var l = s.getRawDataItem(o);
            if (l && l[r]) {
              ey.option = l[r];
              var u = i(ey), c = s.ensureUniqueItemVisual(o, "style");
              oe(c, u), ey.option.decal && (s.setItemVisual(o, "decal", ey.option.decal), ey.option.decal.dirty = true), a in u && s.setItemVisual(o, "colorFromPalette", false);
            }
          } : null
        };
      }
    }
  }, cde = {
    performRawSeries: true,
    overallReset: function(n) {
      var e = Pe();
      n.eachSeries(function(t) {
        var r = t.getColorBy();
        if (!t.isColorBySeries()) {
          var i = t.type + "-" + r, a = e.get(i);
          a || (a = {}, e.set(i, a)), PO(t).scope = a;
        }
      }), n.eachSeries(function(t) {
        if (!(t.isColorBySeries() || n.isSeriesFiltered(t))) {
          var r = t.getRawData(), i = {}, a = t.getData(), s = PO(t).scope, o = t.visualStyleAccessPath || "itemStyle", l = UX(t, o);
          a.each(function(u) {
            var c = a.getRawIndex(u);
            i[c] = u;
          }), r.each(function(u) {
            var c = i[u], h = a.getItemVisual(c, "colorFromPalette");
            if (h) {
              var d = a.ensureUniqueItemVisual(c, "style"), f = r.getName(u) || u + "", p = r.count();
              d[l] = t.getColorFromPalette(f, s, p);
            }
          });
        }
      });
    }
  }, E1 = Math.PI;
  function hde(n, e) {
    e = e || {}, je(e, {
      text: "loading",
      textColor: "#000",
      fontSize: 12,
      fontWeight: "normal",
      fontStyle: "normal",
      fontFamily: "sans-serif",
      maskColor: "rgba(255, 255, 255, 0.8)",
      showSpinner: true,
      color: "#5470c6",
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    });
    var t = new tt(), r = new Vt({
      style: {
        fill: e.maskColor
      },
      zlevel: e.zlevel,
      z: 1e4
    });
    t.add(r);
    var i = new Gt({
      style: {
        text: e.text,
        fill: e.textColor,
        fontSize: e.fontSize,
        fontWeight: e.fontWeight,
        fontStyle: e.fontStyle,
        fontFamily: e.fontFamily
      },
      zlevel: e.zlevel,
      z: 10001
    }), a = new Vt({
      style: {
        fill: "none"
      },
      textContent: i,
      textConfig: {
        position: "right",
        distance: 10
      },
      zlevel: e.zlevel,
      z: 10001
    });
    t.add(a);
    var s;
    return e.showSpinner && (s = new SC({
      shape: {
        startAngle: -E1 / 2,
        endAngle: -E1 / 2 + 0.1,
        r: e.spinnerRadius
      },
      style: {
        stroke: e.color,
        lineCap: "round",
        lineWidth: e.lineWidth
      },
      zlevel: e.zlevel,
      z: 10001
    }), s.animateShape(true).when(1e3, {
      endAngle: E1 * 3 / 2
    }).start("circularInOut"), s.animateShape(true).when(1e3, {
      startAngle: E1 * 3 / 2
    }).delay(300).start("circularInOut"), t.add(s)), t.resize = function() {
      var o = i.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, u = (n.getWidth() - l * 2 - (e.showSpinner && o ? 10 : 0) - o) / 2 - (e.showSpinner && o ? 0 : 5 + o / 2) + (e.showSpinner ? 0 : o / 2) + (o ? 0 : l), c = n.getHeight() / 2;
      e.showSpinner && s.setShape({
        cx: u,
        cy: c
      }), a.setShape({
        x: u - l,
        y: c - l,
        width: l * 2,
        height: l * 2
      }), r.setShape({
        x: 0,
        y: 0,
        width: n.getWidth(),
        height: n.getHeight()
      });
    }, t.resize(), t;
  }
  var HX = function() {
    function n(e, t, r, i) {
      this._stageTaskMap = Pe(), this.ecInstance = e, this.api = t, r = this._dataProcessorHandlers = r.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = r.concat(i);
    }
    return n.prototype.restoreData = function(e, t) {
      e.restoreData(t), this._stageTaskMap.each(function(r) {
        var i = r.overallTask;
        i && i.dirty();
      });
    }, n.prototype.getPerformArgs = function(e, t) {
      if (e.__pipeline) {
        var r = this._pipelineMap.get(e.__pipeline.id), i = r.context, a = !t && r.progressiveEnabled && (!i || i.progressiveRender) && e.__idxInPipeline > r.blockIndex, s = a ? r.step : null, o = i && i.modDataCount, l = o != null ? Math.ceil(o / s) : null;
        return {
          step: s,
          modBy: l,
          modDataCount: o
        };
      }
    }, n.prototype.getPipeline = function(e) {
      return this._pipelineMap.get(e);
    }, n.prototype.updateStreamModes = function(e, t) {
      var r = this._pipelineMap.get(e.uid), i = e.getData(), a = i.count(), s = r.progressiveEnabled && t.incrementalPrepareRender && a >= r.threshold, o = e.get("large") && a >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? a : null;
      e.pipelineContext = r.context = {
        progressiveRender: s,
        modDataCount: l,
        large: o
      };
    }, n.prototype.restorePipelines = function(e) {
      var t = this, r = t._pipelineMap = Pe();
      e.eachSeries(function(i) {
        var a = i.getProgressive(), s = i.uid;
        r.set(s, {
          id: s,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), t._pipe(i, i.dataTask);
      });
    }, n.prototype.prepareStageTasks = function() {
      var e = this._stageTaskMap, t = this.api.getModel(), r = this.api;
      P(this._allHandlers, function(i) {
        var a = e.get(i.uid) || e.set(i.uid, {}), s = "";
        ta(!(i.reset && i.overallReset), s), i.reset && this._createSeriesStageTask(i, a, t, r), i.overallReset && this._createOverallStageTask(i, a, t, r);
      }, this);
    }, n.prototype.prepareView = function(e, t, r, i) {
      var a = e.renderTask, s = a.context;
      s.model = t, s.ecModel = r, s.api = i, a.__block = !e.incrementalPrepareRender, this._pipe(t, a);
    }, n.prototype.performDataProcessorTasks = function(e, t) {
      this._performStageTasks(this._dataProcessorHandlers, e, t, {
        block: true
      });
    }, n.prototype.performVisualTasks = function(e, t, r) {
      this._performStageTasks(this._visualHandlers, e, t, r);
    }, n.prototype._performStageTasks = function(e, t, r, i) {
      i = i || {};
      var a = false, s = this;
      P(e, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = s._stageTaskMap.get(l.uid), h = c.seriesTaskMap, d = c.overallTask;
          if (d) {
            var f, p = d.agentStubMap;
            p.each(function(m) {
              o(i, m) && (m.dirty(), f = true);
            }), f && d.dirty(), s.updatePayload(d, r);
            var g = s.getPerformArgs(d, i.block);
            p.each(function(m) {
              m.perform(g);
            }), d.perform(g) && (a = true);
          } else h && h.each(function(m, v) {
            o(i, m) && m.dirty();
            var y = s.getPerformArgs(m, i.block);
            y.skip = !l.performRawSeries && t.isSeriesFiltered(m.context.model), s.updatePayload(m, r), m.perform(y) && (a = true);
          });
        }
      });
      function o(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, n.prototype.performSeriesTasks = function(e) {
      var t;
      e.eachSeries(function(r) {
        t = r.dataTask.perform() || t;
      }), this.unfinished = t || this.unfinished;
    }, n.prototype.plan = function() {
      this._pipelineMap.each(function(e) {
        var t = e.tail;
        do {
          if (t.__block) {
            e.blockIndex = t.__idxInPipeline;
            break;
          }
          t = t.getUpstream();
        } while (t);
      });
    }, n.prototype.updatePayload = function(e, t) {
      t !== "remain" && (e.context.payload = t);
    }, n.prototype._createSeriesStageTask = function(e, t, r, i) {
      var a = this, s = t.seriesTaskMap, o = t.seriesTaskMap = Pe(), l = e.seriesType, u = e.getTargetSeries;
      e.createOnAllSeries ? r.eachRawSeries(c) : l ? r.eachRawSeriesByType(l, c) : u && u(r, i).each(c);
      function c(h) {
        var d = h.uid, f = o.set(d, s && s.get(d) || u0({
          plan: mde,
          reset: vde,
          count: xde
        }));
        f.context = {
          model: h,
          ecModel: r,
          api: i,
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: a
        }, a._pipe(h, f);
      }
    }, n.prototype._createOverallStageTask = function(e, t, r, i) {
      var a = this, s = t.overallTask = t.overallTask || u0({
        reset: dde
      });
      s.context = {
        ecModel: r,
        api: i,
        overallReset: e.overallReset,
        scheduler: a
      };
      var o = s.agentStubMap, l = s.agentStubMap = Pe(), u = e.seriesType, c = e.getTargetSeries, h = true, d = false, f = "";
      ta(!e.createOnAllSeries, f), u ? r.eachRawSeriesByType(u, p) : c ? c(r, i).each(p) : (h = false, P(r.getSeries(), p));
      function p(g) {
        var m = g.uid, v = l.set(m, o && o.get(m) || (d = true, u0({
          reset: fde,
          onDirty: gde
        })));
        v.context = {
          model: g,
          overallProgress: h
        }, v.agent = s, v.__block = h, a._pipe(g, v);
      }
      d && s.dirty();
    }, n.prototype._pipe = function(e, t) {
      var r = e.uid, i = this._pipelineMap.get(r);
      !i.head && (i.head = t), i.tail && i.tail.pipe(t), i.tail = t, t.__idxInPipeline = i.count++, t.__pipeline = i;
    }, n.wrapStageHandler = function(e, t) {
      return Xe(e) && (e = {
        overallReset: e,
        seriesType: bde(e)
      }), e.uid = ym("stageHandler"), t && (e.visualType = t), e;
    }, n;
  }();
  function dde(n) {
    n.overallReset(n.ecModel, n.api, n.payload);
  }
  function fde(n) {
    return n.overallProgress && pde;
  }
  function pde() {
    this.agent.dirty(), this.getDownstream().dirty();
  }
  function gde() {
    this.agent && this.agent.dirty();
  }
  function mde(n) {
    return n.plan ? n.plan(n.model, n.ecModel, n.api, n.payload) : null;
  }
  function vde(n) {
    n.useClearVisual && n.data.clearAllVisual();
    var e = n.resetDefines = xn(n.reset(n.model, n.ecModel, n.api, n.payload));
    return e.length > 1 ? me(e, function(t, r) {
      return XX(r);
    }) : yde;
  }
  var yde = XX(0);
  function XX(n) {
    return function(e, t) {
      var r = t.data, i = t.resetDefines[n];
      if (i && i.dataEach) for (var a = e.start; a < e.end; a++) i.dataEach(r, a);
      else i && i.progress && i.progress(e, r);
    };
  }
  function xde(n) {
    return n.data.count();
  }
  function bde(n) {
    Y_ = null;
    try {
      n(O0, YX);
    } catch {
    }
    return Y_;
  }
  var O0 = {}, YX = {}, Y_;
  qX(O0, dE);
  qX(YX, yX);
  O0.eachSeriesByType = O0.eachRawSeriesByType = function(n) {
    Y_ = n;
  };
  O0.eachComponent = function(n) {
    n.mainType === "series" && n.subType && (Y_ = n.subType);
  };
  function qX(n, e) {
    for (var t in e.prototype) n[t] = ur;
  }
  var FO = [
    "#37A2DA",
    "#32C5E9",
    "#67E0E3",
    "#9FE6B8",
    "#FFDB5C",
    "#ff9f7f",
    "#fb7293",
    "#E062AE",
    "#E690D1",
    "#e7bcf3",
    "#9d96f5",
    "#8378EA",
    "#96BFFF"
  ];
  const wde = {
    color: FO,
    colorLayer: [
      [
        "#37A2DA",
        "#ffd85c",
        "#fd7b5f"
      ],
      [
        "#37A2DA",
        "#67E0E3",
        "#FFDB5C",
        "#ff9f7f",
        "#E062AE",
        "#9d96f5"
      ],
      [
        "#37A2DA",
        "#32C5E9",
        "#9FE6B8",
        "#FFDB5C",
        "#ff9f7f",
        "#fb7293",
        "#e7bcf3",
        "#8378EA",
        "#96BFFF"
      ],
      FO
    ]
  };
  var Si = "#B9B8CE", OO = "#100C2A", M1 = function() {
    return {
      axisLine: {
        lineStyle: {
          color: Si
        }
      },
      splitLine: {
        lineStyle: {
          color: "#484753"
        }
      },
      splitArea: {
        areaStyle: {
          color: [
            "rgba(255,255,255,0.02)",
            "rgba(255,255,255,0.05)"
          ]
        }
      },
      minorSplitLine: {
        lineStyle: {
          color: "#20203B"
        }
      }
    };
  }, BO = [
    "#4992ff",
    "#7cffb2",
    "#fddd60",
    "#ff6e76",
    "#58d9f9",
    "#05c091",
    "#ff8a45",
    "#8d48e3",
    "#dd79ff"
  ], jX = {
    darkMode: true,
    color: BO,
    backgroundColor: OO,
    axisPointer: {
      lineStyle: {
        color: "#817f91"
      },
      crossStyle: {
        color: "#817f91"
      },
      label: {
        color: "#fff"
      }
    },
    legend: {
      textStyle: {
        color: Si
      },
      pageTextStyle: {
        color: Si
      }
    },
    textStyle: {
      color: Si
    },
    title: {
      textStyle: {
        color: "#EEF1FA"
      },
      subtextStyle: {
        color: "#B9B8CE"
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: Si
      }
    },
    dataZoom: {
      borderColor: "#71708A",
      textStyle: {
        color: Si
      },
      brushStyle: {
        color: "rgba(135,163,206,0.3)"
      },
      handleStyle: {
        color: "#353450",
        borderColor: "#C5CBE3"
      },
      moveHandleStyle: {
        color: "#B0B6C3",
        opacity: 0.3
      },
      fillerColor: "rgba(135,163,206,0.2)",
      emphasis: {
        handleStyle: {
          borderColor: "#91B7F2",
          color: "#4D587D"
        },
        moveHandleStyle: {
          color: "#636D9A",
          opacity: 0.7
        }
      },
      dataBackground: {
        lineStyle: {
          color: "#71708A",
          width: 1
        },
        areaStyle: {
          color: "#71708A"
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#87A3CE"
        },
        areaStyle: {
          color: "#87A3CE"
        }
      }
    },
    visualMap: {
      textStyle: {
        color: Si
      }
    },
    timeline: {
      lineStyle: {
        color: Si
      },
      label: {
        color: Si
      },
      controlStyle: {
        color: Si,
        borderColor: Si
      }
    },
    calendar: {
      itemStyle: {
        color: OO
      },
      dayLabel: {
        color: Si
      },
      monthLabel: {
        color: Si
      },
      yearLabel: {
        color: Si
      }
    },
    timeAxis: M1(),
    logAxis: M1(),
    valueAxis: M1(),
    categoryAxis: M1(),
    line: {
      symbol: "circle"
    },
    graph: {
      color: BO
    },
    gauge: {
      title: {
        color: Si
      },
      axisLine: {
        lineStyle: {
          color: [
            [
              1,
              "rgba(207,212,219,0.2)"
            ]
          ]
        }
      },
      axisLabel: {
        color: Si
      },
      detail: {
        color: "#EEF1FA"
      }
    },
    candlestick: {
      itemStyle: {
        color: "#f64e56",
        color0: "#54ea92",
        borderColor: "#f64e56",
        borderColor0: "#54ea92"
      }
    }
  };
  jX.categoryAxis.splitLine.show = false;
  var _de = function() {
    function n() {
    }
    return n.prototype.normalizeQuery = function(e) {
      var t = {}, r = {}, i = {};
      if (Ie(e)) {
        var a = Bo(e);
        t.mainType = a.main || null, t.subType = a.sub || null;
      } else {
        var s = [
          "Index",
          "Name",
          "Id"
        ], o = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        P(e, function(l, u) {
          for (var c = false, h = 0; h < s.length; h++) {
            var d = s[h], f = u.lastIndexOf(d);
            if (f > 0 && f === u.length - d.length) {
              var p = u.slice(0, f);
              p !== "data" && (t.mainType = p, t[d.toLowerCase()] = l, c = true);
            }
          }
          o.hasOwnProperty(u) && (r[u] = l, c = true), c || (i[u] = l);
        });
      }
      return {
        cptQuery: t,
        dataQuery: r,
        otherQuery: i
      };
    }, n.prototype.filter = function(e, t) {
      var r = this.eventInfo;
      if (!r) return true;
      var i = r.targetEl, a = r.packedEvent, s = r.model, o = r.view;
      if (!s || !o) return true;
      var l = t.cptQuery, u = t.dataQuery;
      return c(l, s, "mainType") && c(l, s, "subType") && c(l, s, "index", "componentIndex") && c(l, s, "name") && c(l, s, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!o.filterForExposedEvent || o.filterForExposedEvent(e, t.otherQuery, i, a));
      function c(h, d, f, p) {
        return h[f] == null || d[p || f] === h[f];
      }
    }, n.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, n;
  }(), rR = [
    "symbol",
    "symbolSize",
    "symbolRotate",
    "symbolOffset"
  ], zO = rR.concat([
    "symbolKeepAspect"
  ]), Sde = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(n, e) {
      var t = n.getData();
      if (n.legendIcon && t.setVisual("legendIcon", n.legendIcon), !n.hasSymbolVisual) return;
      for (var r = {}, i = {}, a = false, s = 0; s < rR.length; s++) {
        var o = rR[s], l = n.get(o);
        Xe(l) ? (a = true, i[o] = l) : r[o] = l;
      }
      if (r.symbol = r.symbol || n.defaultSymbol, t.setVisual(oe({
        legendIcon: n.legendIcon || r.symbol,
        symbolKeepAspect: n.get("symbolKeepAspect")
      }, r)), e.isSeriesFiltered(n)) return;
      var u = Mt(i);
      function c(h, d) {
        for (var f = n.getRawValue(d), p = n.getDataParams(d), g = 0; g < u.length; g++) {
          var m = u[g];
          h.setItemVisual(d, m, i[m](f, p));
        }
      }
      return {
        dataEach: a ? c : null
      };
    }
  }, Cde = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function(n, e) {
      if (!n.hasSymbolVisual || e.isSeriesFiltered(n)) return;
      var t = n.getData();
      function r(i, a) {
        for (var s = i.getItemModel(a), o = 0; o < zO.length; o++) {
          var l = zO[o], u = s.getShallow(l, true);
          u != null && i.setItemVisual(a, l, u);
        }
      }
      return {
        dataEach: t.hasItemOption ? r : null
      };
    }
  };
  function yE(n, e, t) {
    switch (t) {
      case "color":
        var r = n.getItemVisual(e, "style");
        return r[n.getVisual("drawType")];
      case "opacity":
        return n.getItemVisual(e, "style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return n.getItemVisual(e, t);
    }
  }
  function Bx(n, e) {
    switch (e) {
      case "color":
        var t = n.getVisual("style");
        return t[n.getVisual("drawType")];
      case "opacity":
        return n.getVisual("style").opacity;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        return n.getVisual(e);
    }
  }
  function KX(n, e, t, r) {
    switch (t) {
      case "color":
        var i = n.ensureUniqueItemVisual(e, "style");
        i[n.getVisual("drawType")] = r, n.setItemVisual(e, "colorFromPalette", false);
        break;
      case "opacity":
        n.ensureUniqueItemVisual(e, "style").opacity = r;
        break;
      case "symbol":
      case "symbolSize":
      case "liftZ":
        n.setItemVisual(e, t, r);
        break;
    }
  }
  function ZX(n, e) {
    function t(r, i) {
      var a = [];
      return r.eachComponent({
        mainType: "series",
        subType: n,
        query: i
      }, function(s) {
        a.push(s.seriesIndex);
      }), a;
    }
    P([
      [
        n + "ToggleSelect",
        "toggleSelect"
      ],
      [
        n + "Select",
        "select"
      ],
      [
        n + "UnSelect",
        "unselect"
      ]
    ], function(r) {
      e(r[0], function(i, a, s) {
        i = oe({}, i), s.dispatchAction(oe(i, {
          type: r[1],
          seriesIndex: t(a, i)
        }));
      });
    });
  }
  function Mp(n, e, t, r, i) {
    var a = n + e;
    t.isSilent(a) || r.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(s) {
      for (var o = s.seriesIndex, l = s.option.selectedMap, u = i.selected, c = 0; c < u.length; c++) if (u[c].seriesIndex === o) {
        var h = s.getData(), d = cd(h, i.fromActionPayload);
        t.trigger(a, {
          type: a,
          seriesId: s.id,
          name: de(d) ? h.getName(d[0]) : h.getName(d),
          selected: Ie(l) ? l : oe({}, l)
        });
      }
    });
  }
  function Ide(n, e, t) {
    n.on("selectchanged", function(r) {
      var i = t.getModel();
      r.isFromClick ? (Mp("map", "selectchanged", e, i, r), Mp("pie", "selectchanged", e, i, r)) : r.fromAction === "select" ? (Mp("map", "selected", e, i, r), Mp("pie", "selected", e, i, r)) : r.fromAction === "unselect" && (Mp("map", "unselected", e, i, r), Mp("pie", "unselected", e, i, r));
    });
  }
  function Bh(n, e, t) {
    for (var r; n && !(e(n) && (r = n, t)); ) n = n.__hostTarget || n.parent;
    return r;
  }
  var kde = Math.round(Math.random() * 9), Tde = typeof Object.defineProperty == "function", Ade = function() {
    function n() {
      this._id = "__ec_inner_" + kde++;
    }
    return n.prototype.get = function(e) {
      return this._guard(e)[this._id];
    }, n.prototype.set = function(e, t) {
      var r = this._guard(e);
      return Tde ? Object.defineProperty(r, this._id, {
        value: t,
        enumerable: false,
        configurable: true
      }) : r[this._id] = t, this;
    }, n.prototype.delete = function(e) {
      return this.has(e) ? (delete this._guard(e)[this._id], true) : false;
    }, n.prototype.has = function(e) {
      return !!this._guard(e)[this._id];
    }, n.prototype._guard = function(e) {
      if (e !== Object(e)) throw TypeError("Value of WeakMap is not a non-null object.");
      return e;
    }, n;
  }(), Dde = At.extend({
    type: "triangle",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(n, e) {
      var t = e.cx, r = e.cy, i = e.width / 2, a = e.height / 2;
      n.moveTo(t, r - a), n.lineTo(t + i, r + a), n.lineTo(t - i, r + a), n.closePath();
    }
  }), Rde = At.extend({
    type: "diamond",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(n, e) {
      var t = e.cx, r = e.cy, i = e.width / 2, a = e.height / 2;
      n.moveTo(t, r - a), n.lineTo(t + i, r), n.lineTo(t, r + a), n.lineTo(t - i, r), n.closePath();
    }
  }), $de = At.extend({
    type: "pin",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(n, e) {
      var t = e.x, r = e.y, i = e.width / 5 * 3, a = Math.max(i, e.height), s = i / 2, o = s * s / (a - s), l = r - a + s + o, u = Math.asin(o / s), c = Math.cos(u) * s, h = Math.sin(u), d = Math.cos(u), f = s * 0.6, p = s * 0.7;
      n.moveTo(t - c, l + o), n.arc(t, l, s, Math.PI - u, Math.PI * 2 + u), n.bezierCurveTo(t + c - h * f, l + o + d * f, t, r - p, t, r), n.bezierCurveTo(t, r - p, t - c + h * f, l + o + d * f, t - c, l + o), n.closePath();
    }
  }), Nde = At.extend({
    type: "arrow",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(n, e) {
      var t = e.height, r = e.width, i = e.x, a = e.y, s = r / 3 * 2;
      n.moveTo(i, a), n.lineTo(i + s, a + t), n.lineTo(i, a + t / 4 * 3), n.lineTo(i - s, a + t), n.lineTo(i, a), n.closePath();
    }
  }), Ede = {
    line: zr,
    rect: Vt,
    roundRect: Vt,
    square: Vt,
    circle: iu,
    diamond: Rde,
    pin: $de,
    arrow: Nde,
    triangle: Dde
  }, Mde = {
    line: function(n, e, t, r, i) {
      i.x1 = n, i.y1 = e + r / 2, i.x2 = n + t, i.y2 = e + r / 2;
    },
    rect: function(n, e, t, r, i) {
      i.x = n, i.y = e, i.width = t, i.height = r;
    },
    roundRect: function(n, e, t, r, i) {
      i.x = n, i.y = e, i.width = t, i.height = r, i.r = Math.min(t, r) / 4;
    },
    square: function(n, e, t, r, i) {
      var a = Math.min(t, r);
      i.x = n, i.y = e, i.width = a, i.height = a;
    },
    circle: function(n, e, t, r, i) {
      i.cx = n + t / 2, i.cy = e + r / 2, i.r = Math.min(t, r) / 2;
    },
    diamond: function(n, e, t, r, i) {
      i.cx = n + t / 2, i.cy = e + r / 2, i.width = t, i.height = r;
    },
    pin: function(n, e, t, r, i) {
      i.x = n + t / 2, i.y = e + r / 2, i.width = t, i.height = r;
    },
    arrow: function(n, e, t, r, i) {
      i.x = n + t / 2, i.y = e + r / 2, i.width = t, i.height = r;
    },
    triangle: function(n, e, t, r, i) {
      i.cx = n + t / 2, i.cy = e + r / 2, i.width = t, i.height = r;
    }
  }, q_ = {};
  P(Ede, function(n, e) {
    q_[e] = new n();
  });
  var Pde = At.extend({
    type: "symbol",
    shape: {
      symbolType: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function(n, e, t) {
      var r = F_(n, e, t), i = this.shape;
      return i && i.symbolType === "pin" && e.position === "inside" && (r.y = t.y + t.height * 0.4), r;
    },
    buildPath: function(n, e, t) {
      var r = e.symbolType;
      if (r !== "none") {
        var i = q_[r];
        i || (r = "rect", i = q_[r]), Mde[r](e.x, e.y, e.width, e.height, i.shape), i.buildPath(n, i.shape, t);
      }
    }
  });
  function Lde(n, e) {
    if (this.type !== "image") {
      var t = this.style;
      this.__isEmptyBrush ? (t.stroke = n, t.fill = e || "#fff", t.lineWidth = 2) : this.shape.symbolType === "line" ? t.stroke = n : t.fill = n, this.markRedraw();
    }
  }
  function xr(n, e, t, r, i, a, s) {
    var o = n.indexOf("empty") === 0;
    o && (n = n.substr(5, 1).toLowerCase() + n.substr(6));
    var l;
    return n.indexOf("image://") === 0 ? l = B8(n.slice(8), new vt(e, t, r, i), s ? "center" : "cover") : n.indexOf("path://") === 0 ? l = CC(n.slice(7), {}, new vt(e, t, r, i), s ? "center" : "cover") : l = new Pde({
      shape: {
        symbolType: n,
        x: e,
        y: t,
        width: r,
        height: i
      }
    }), l.__isEmptyBrush = o, l.setColor = Lde, a && l.setColor(a), l;
  }
  function Cm(n) {
    return de(n) || (n = [
      +n,
      +n
    ]), [
      n[0] || 0,
      n[1] || 0
    ];
  }
  function Fd(n, e) {
    if (n != null) return de(n) || (n = [
      n,
      n
    ]), [
      _e(n[0], e[0]) || 0,
      _e(it(n[1], n[0]), e[1]) || 0
    ];
  }
  function zh(n) {
    return isFinite(n);
  }
  function Fde(n, e, t) {
    var r = e.x == null ? 0 : e.x, i = e.x2 == null ? 1 : e.x2, a = e.y == null ? 0 : e.y, s = e.y2 == null ? 0 : e.y2;
    e.global || (r = r * t.width + t.x, i = i * t.width + t.x, a = a * t.height + t.y, s = s * t.height + t.y), r = zh(r) ? r : 0, i = zh(i) ? i : 1, a = zh(a) ? a : 0, s = zh(s) ? s : 0;
    var o = n.createLinearGradient(r, a, i, s);
    return o;
  }
  function Ode(n, e, t) {
    var r = t.width, i = t.height, a = Math.min(r, i), s = e.x == null ? 0.5 : e.x, o = e.y == null ? 0.5 : e.y, l = e.r == null ? 0.5 : e.r;
    e.global || (s = s * r + t.x, o = o * i + t.y, l = l * a), s = zh(s) ? s : 0.5, o = zh(o) ? o : 0.5, l = l >= 0 && zh(l) ? l : 0.5;
    var u = n.createRadialGradient(s, o, 0, s, o, l);
    return u;
  }
  function iR(n, e, t) {
    for (var r = e.type === "radial" ? Ode(n, e, t) : Fde(n, e, t), i = e.colorStops, a = 0; a < i.length; a++) r.addColorStop(i[a].offset, i[a].color);
    return r;
  }
  function Bde(n, e) {
    if (n === e || !n && !e) return false;
    if (!n || !e || n.length !== e.length) return true;
    for (var t = 0; t < n.length; t++) if (n[t] !== e[t]) return true;
    return false;
  }
  function P1(n) {
    return parseInt(n, 10);
  }
  function vg(n, e, t) {
    var r = [
      "width",
      "height"
    ][e], i = [
      "clientWidth",
      "clientHeight"
    ][e], a = [
      "paddingLeft",
      "paddingTop"
    ][e], s = [
      "paddingRight",
      "paddingBottom"
    ][e];
    if (t[r] != null && t[r] !== "auto") return parseFloat(t[r]);
    var o = document.defaultView.getComputedStyle(n);
    return (n[i] || P1(o[r]) || P1(n.style[r])) - (P1(o[a]) || 0) - (P1(o[s]) || 0) | 0;
  }
  function zde(n, e) {
    return !n || n === "solid" || !(e > 0) ? null : n === "dashed" ? [
      4 * e,
      2 * e
    ] : n === "dotted" ? [
      e
    ] : Yt(n) ? [
      n
    ] : de(n) ? n : null;
  }
  function xE(n) {
    var e = n.style, t = e.lineDash && e.lineWidth > 0 && zde(e.lineDash, e.lineWidth), r = e.lineDashOffset;
    if (t) {
      var i = e.strokeNoScale && n.getLineScale ? n.getLineScale() : 1;
      i && i !== 1 && (t = me(t, function(a) {
        return a / i;
      }), r /= i);
    }
    return [
      t,
      r
    ];
  }
  var Vde = new nl(true);
  function j_(n) {
    var e = n.stroke;
    return !(e == null || e === "none" || !(n.lineWidth > 0));
  }
  function VO(n) {
    return typeof n == "string" && n !== "none";
  }
  function K_(n) {
    var e = n.fill;
    return e != null && e !== "none";
  }
  function WO(n, e) {
    if (e.fillOpacity != null && e.fillOpacity !== 1) {
      var t = n.globalAlpha;
      n.globalAlpha = e.fillOpacity * e.opacity, n.fill(), n.globalAlpha = t;
    } else n.fill();
  }
  function GO(n, e) {
    if (e.strokeOpacity != null && e.strokeOpacity !== 1) {
      var t = n.globalAlpha;
      n.globalAlpha = e.strokeOpacity * e.opacity, n.stroke(), n.globalAlpha = t;
    } else n.stroke();
  }
  function aR(n, e, t) {
    var r = HN(e.image, e.__image, t);
    if (vC(r)) {
      var i = n.createPattern(r, e.repeat || "repeat");
      if (typeof DOMMatrix == "function" && i && i.setTransform) {
        var a = new DOMMatrix();
        a.translateSelf(e.x || 0, e.y || 0), a.rotateSelf(0, 0, (e.rotation || 0) * Yw), a.scaleSelf(e.scaleX || 1, e.scaleY || 1), i.setTransform(a);
      }
      return i;
    }
  }
  function Wde(n, e, t, r) {
    var i, a = j_(t), s = K_(t), o = t.strokePercent, l = o < 1, u = !e.path;
    (!e.silent || l) && u && e.createPathProxy();
    var c = e.path || Vde, h = e.__dirty;
    if (!r) {
      var d = t.fill, f = t.stroke, p = s && !!d.colorStops, g = a && !!f.colorStops, m = s && !!d.image, v = a && !!f.image, y = void 0, x = void 0, b = void 0, w = void 0, _ = void 0;
      (p || g) && (_ = e.getBoundingRect()), p && (y = h ? iR(n, d, _) : e.__canvasFillGradient, e.__canvasFillGradient = y), g && (x = h ? iR(n, f, _) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = x), m && (b = h || !e.__canvasFillPattern ? aR(n, d, e) : e.__canvasFillPattern, e.__canvasFillPattern = b), v && (w = h || !e.__canvasStrokePattern ? aR(n, f, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = b), p ? n.fillStyle = y : m && (b ? n.fillStyle = b : s = false), g ? n.strokeStyle = x : v && (w ? n.strokeStyle = w : a = false);
    }
    var S = e.getGlobalScale();
    c.setScale(S[0], S[1], e.segmentIgnoreThreshold);
    var I, C;
    n.setLineDash && t.lineDash && (i = xE(e), I = i[0], C = i[1]);
    var T = true;
    (u || h & Dy) && (c.setDPR(n.dpr), l ? c.setContext(null) : (c.setContext(n), T = false), c.reset(), e.buildPath(c, e.shape, r), c.toStatic(), e.pathUpdated()), T && c.rebuildPath(n, l ? o : 1), I && (n.setLineDash(I), n.lineDashOffset = C), r || (t.strokeFirst ? (a && GO(n, t), s && WO(n, t)) : (s && WO(n, t), a && GO(n, t))), I && n.setLineDash([]);
  }
  function Gde(n, e, t) {
    var r = e.__image = HN(t.image, e.__image, e, e.onload);
    if (!(!r || !vC(r))) {
      var i = t.x || 0, a = t.y || 0, s = e.getWidth(), o = e.getHeight(), l = r.width / r.height;
      if (s == null && o != null ? s = o * l : o == null && s != null ? o = s / l : s == null && o == null && (s = r.width, o = r.height), t.sWidth && t.sHeight) {
        var u = t.sx || 0, c = t.sy || 0;
        n.drawImage(r, u, c, t.sWidth, t.sHeight, i, a, s, o);
      } else if (t.sx && t.sy) {
        var u = t.sx, c = t.sy, h = s - u, d = o - c;
        n.drawImage(r, u, c, h, d, i, a, s, o);
      } else n.drawImage(r, i, a, s, o);
    }
  }
  function Ude(n, e, t) {
    var r, i = t.text;
    if (i != null && (i += ""), i) {
      n.font = t.font || Ju, n.textAlign = t.textAlign, n.textBaseline = t.textBaseline;
      var a = void 0, s = void 0;
      n.setLineDash && t.lineDash && (r = xE(e), a = r[0], s = r[1]), a && (n.setLineDash(a), n.lineDashOffset = s), t.strokeFirst ? (j_(t) && n.strokeText(i, t.x, t.y), K_(t) && n.fillText(i, t.x, t.y)) : (K_(t) && n.fillText(i, t.x, t.y), j_(t) && n.strokeText(i, t.x, t.y)), a && n.setLineDash([]);
    }
  }
  var UO = [
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY"
  ], HO = [
    [
      "lineCap",
      "butt"
    ],
    [
      "lineJoin",
      "miter"
    ],
    [
      "miterLimit",
      10
    ]
  ];
  function QX(n, e, t, r, i) {
    var a = false;
    if (!r && (t = t || {}, e === t)) return false;
    if (r || e.opacity !== t.opacity) {
      ba(n, i), a = true;
      var s = Math.max(Math.min(e.opacity, 1), 0);
      n.globalAlpha = isNaN(s) ? Kh.opacity : s;
    }
    (r || e.blend !== t.blend) && (a || (ba(n, i), a = true), n.globalCompositeOperation = e.blend || Kh.blend);
    for (var o = 0; o < UO.length; o++) {
      var l = UO[o];
      (r || e[l] !== t[l]) && (a || (ba(n, i), a = true), n[l] = n.dpr * (e[l] || 0));
    }
    return (r || e.shadowColor !== t.shadowColor) && (a || (ba(n, i), a = true), n.shadowColor = e.shadowColor || Kh.shadowColor), a;
  }
  function XO(n, e, t, r, i) {
    var a = B0(e, i.inHover), s = r ? null : t && B0(t, i.inHover) || {};
    if (a === s) return false;
    var o = QX(n, a, s, r, i);
    if ((r || a.fill !== s.fill) && (o || (ba(n, i), o = true), VO(a.fill) && (n.fillStyle = a.fill)), (r || a.stroke !== s.stroke) && (o || (ba(n, i), o = true), VO(a.stroke) && (n.strokeStyle = a.stroke)), (r || a.opacity !== s.opacity) && (o || (ba(n, i), o = true), n.globalAlpha = a.opacity == null ? 1 : a.opacity), e.hasStroke()) {
      var l = a.lineWidth, u = l / (a.strokeNoScale && e.getLineScale ? e.getLineScale() : 1);
      n.lineWidth !== u && (o || (ba(n, i), o = true), n.lineWidth = u);
    }
    for (var c = 0; c < HO.length; c++) {
      var h = HO[c], d = h[0];
      (r || a[d] !== s[d]) && (o || (ba(n, i), o = true), n[d] = a[d] || h[1]);
    }
    return o;
  }
  function Hde(n, e, t, r, i) {
    return QX(n, B0(e, i.inHover), t && B0(t, i.inHover), r, i);
  }
  function JX(n, e) {
    var t = e.transform, r = n.dpr || 1;
    t ? n.setTransform(r * t[0], r * t[1], r * t[2], r * t[3], r * t[4], r * t[5]) : n.setTransform(r, 0, 0, r, 0, 0);
  }
  function Xde(n, e, t) {
    for (var r = false, i = 0; i < n.length; i++) {
      var a = n[i];
      r = r || a.isZeroArea(), JX(e, a), e.beginPath(), a.buildPath(e, a.shape), e.clip();
    }
    t.allClipped = r;
  }
  function Yde(n, e) {
    return n && e ? n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] || n[4] !== e[4] || n[5] !== e[5] : !(!n && !e);
  }
  var YO = 1, qO = 2, jO = 3, KO = 4;
  function qde(n) {
    var e = K_(n), t = j_(n);
    return !(n.lineDash || !(+e ^ +t) || e && typeof n.fill != "string" || t && typeof n.stroke != "string" || n.strokePercent < 1 || n.strokeOpacity < 1 || n.fillOpacity < 1);
  }
  function ba(n, e) {
    e.batchFill && n.fill(), e.batchStroke && n.stroke(), e.batchFill = "", e.batchStroke = "";
  }
  function B0(n, e) {
    return e && n.__hoverStyle || n.style;
  }
  function eY(n, e) {
    Vh(n, e, {
      inHover: false,
      viewWidth: 0,
      viewHeight: 0
    }, true);
  }
  function Vh(n, e, t, r) {
    var i = e.transform;
    if (!e.shouldBePainted(t.viewWidth, t.viewHeight, false, false)) {
      e.__dirty &= -2, e.__isRendered = false;
      return;
    }
    var a = e.__clipPaths, s = t.prevElClipPaths, o = false, l = false;
    if ((!s || Bde(a, s)) && (s && s.length && (ba(n, t), n.restore(), l = o = true, t.prevElClipPaths = null, t.allClipped = false, t.prevEl = null), a && a.length && (ba(n, t), n.save(), Xde(a, n, t), o = true), t.prevElClipPaths = a), t.allClipped) {
      e.__isRendered = false;
      return;
    }
    e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
    var u = t.prevEl;
    u || (l = o = true);
    var c = e instanceof At && e.autoBatch && qde(e.style);
    o || Yde(i, u.transform) ? (ba(n, t), JX(n, e)) : c || ba(n, t);
    var h = B0(e, t.inHover);
    e instanceof At ? (t.lastDrawType !== YO && (l = true, t.lastDrawType = YO), XO(n, e, u, l, t), (!c || !t.batchFill && !t.batchStroke) && n.beginPath(), Wde(n, e, h, c), c && (t.batchFill = h.fill || "", t.batchStroke = h.stroke || "")) : e instanceof Eg ? (t.lastDrawType !== jO && (l = true, t.lastDrawType = jO), XO(n, e, u, l, t), Ude(n, e, h)) : e instanceof oi ? (t.lastDrawType !== qO && (l = true, t.lastDrawType = qO), Hde(n, e, u, l, t), Gde(n, e, h)) : e.getTemporalDisplayables && (t.lastDrawType !== KO && (l = true, t.lastDrawType = KO), jde(n, e, t)), c && r && ba(n, t), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), t.prevEl = e, e.__dirty = 0, e.__isRendered = true;
  }
  function jde(n, e, t) {
    var r = e.getDisplayables(), i = e.getTemporalDisplayables();
    n.save();
    var a = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: false,
      viewWidth: t.viewWidth,
      viewHeight: t.viewHeight,
      inHover: t.inHover
    }, s, o;
    for (s = e.getCursor(), o = r.length; s < o; s++) {
      var l = r[s];
      l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Vh(n, l, a, s === o - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
    }
    for (var u = 0, c = i.length; u < c; u++) {
      var l = i[u];
      l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Vh(n, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
    }
    e.clearTemporalDisplayables(), e.notClear = true, n.restore();
  }
  var _k = new Ade(), ZO = new Dx(100), QO = [
    "symbol",
    "symbolSize",
    "symbolKeepAspect",
    "color",
    "backgroundColor",
    "dashArrayX",
    "dashArrayY",
    "maxTileWidth",
    "maxTileHeight"
  ];
  function Lg(n, e) {
    if (n === "none") return null;
    var t = e.getDevicePixelRatio(), r = e.getZr(), i = r.painter.type === "svg";
    n.dirty && _k.delete(n);
    var a = _k.get(n);
    if (a) return a;
    var s = je(n, {
      symbol: "rect",
      symbolSize: 1,
      symbolKeepAspect: true,
      color: "rgba(0, 0, 0, 0.2)",
      backgroundColor: null,
      dashArrayX: 5,
      dashArrayY: 5,
      rotation: 0,
      maxTileWidth: 512,
      maxTileHeight: 512
    });
    s.backgroundColor === "none" && (s.backgroundColor = null);
    var o = {
      repeat: "repeat"
    };
    return l(o), o.rotation = s.rotation, o.scaleX = o.scaleY = i ? 1 : 1 / t, _k.set(n, o), n.dirty = false, o;
    function l(u) {
      for (var c = [
        t
      ], h = true, d = 0; d < QO.length; ++d) {
        var f = s[QO[d]];
        if (f != null && !de(f) && !Ie(f) && !Yt(f) && typeof f != "boolean") {
          h = false;
          break;
        }
        c.push(f);
      }
      var p;
      if (h) {
        p = c.join(",") + (i ? "-svg" : "");
        var g = ZO.get(p);
        g && (i ? u.svgElement = g : u.image = g);
      }
      var m = nY(s.dashArrayX), v = Kde(s.dashArrayY), y = tY(s.symbol), x = Zde(m), b = rY(v), w = !i && ec.createCanvas(), _ = i && {
        tag: "g",
        attrs: {},
        key: "dcl",
        children: []
      }, S = C(), I;
      w && (w.width = S.width * t, w.height = S.height * t, I = w.getContext("2d")), T(), h && ZO.put(p, w || _), u.image = w, u.svgElement = _, u.svgWidth = S.width, u.svgHeight = S.height;
      function C() {
        for (var k = 1, D = 0, R = x.length; D < R; ++D) k = gF(k, x[D]);
        for (var N = 1, D = 0, R = y.length; D < R; ++D) N = gF(N, y[D].length);
        k *= N;
        var E = b * x.length * y.length;
        return {
          width: Math.max(1, Math.min(k, s.maxTileWidth)),
          height: Math.max(1, Math.min(E, s.maxTileHeight))
        };
      }
      function T() {
        I && (I.clearRect(0, 0, w.width, w.height), s.backgroundColor && (I.fillStyle = s.backgroundColor, I.fillRect(0, 0, w.width, w.height)));
        for (var k = 0, D = 0; D < v.length; ++D) k += v[D];
        if (k <= 0) return;
        for (var R = -b, N = 0, E = 0, A = 0; R < S.height; ) {
          if (N % 2 === 0) {
            for (var M = E / 2 % y.length, $ = 0, L = 0, F = 0; $ < S.width * 2; ) {
              for (var O = 0, D = 0; D < m[A].length; ++D) O += m[A][D];
              if (O <= 0) break;
              if (L % 2 === 0) {
                var z = (1 - s.symbolSize) * 0.5, V = $ + m[A][L] * z, H = R + v[N] * z, Y = m[A][L] * s.symbolSize, le = v[N] * s.symbolSize, ve = F / 2 % y[M].length;
                re(V, H, Y, le, y[M][ve]);
              }
              $ += m[A][L], ++F, ++L, L === m[A].length && (L = 0);
            }
            ++A, A === m.length && (A = 0);
          }
          R += v[N], ++E, ++N, N === v.length && (N = 0);
        }
        function re(ae, fe, ce, ye, Le) {
          var Re = i ? 1 : t, be = xr(Le, ae * Re, fe * Re, ce * Re, ye * Re, s.color, s.symbolKeepAspect);
          if (i) {
            var xe = r.painter.renderOneToVNode(be);
            xe && _.children.push(xe);
          } else eY(I, be);
        }
      }
    }
  }
  function tY(n) {
    if (!n || n.length === 0) return [
      [
        "rect"
      ]
    ];
    if (Ie(n)) return [
      [
        n
      ]
    ];
    for (var e = true, t = 0; t < n.length; ++t) if (!Ie(n[t])) {
      e = false;
      break;
    }
    if (e) return tY([
      n
    ]);
    for (var r = [], t = 0; t < n.length; ++t) Ie(n[t]) ? r.push([
      n[t]
    ]) : r.push(n[t]);
    return r;
  }
  function nY(n) {
    if (!n || n.length === 0) return [
      [
        0,
        0
      ]
    ];
    if (Yt(n)) {
      var e = Math.ceil(n);
      return [
        [
          e,
          e
        ]
      ];
    }
    for (var t = true, r = 0; r < n.length; ++r) if (!Yt(n[r])) {
      t = false;
      break;
    }
    if (t) return nY([
      n
    ]);
    for (var i = [], r = 0; r < n.length; ++r) if (Yt(n[r])) {
      var e = Math.ceil(n[r]);
      i.push([
        e,
        e
      ]);
    } else {
      var e = me(n[r], function(o) {
        return Math.ceil(o);
      });
      e.length % 2 === 1 ? i.push(e.concat(e)) : i.push(e);
    }
    return i;
  }
  function Kde(n) {
    if (!n || typeof n == "object" && n.length === 0) return [
      0,
      0
    ];
    if (Yt(n)) {
      var e = Math.ceil(n);
      return [
        e,
        e
      ];
    }
    var t = me(n, function(r) {
      return Math.ceil(r);
    });
    return n.length % 2 ? t.concat(t) : t;
  }
  function Zde(n) {
    return me(n, function(e) {
      return rY(e);
    });
  }
  function rY(n) {
    for (var e = 0, t = 0; t < n.length; ++t) e += n[t];
    return n.length % 2 === 1 ? e * 2 : e;
  }
  function Qde(n, e) {
    n.eachRawSeries(function(t) {
      if (!n.isSeriesFiltered(t)) {
        var r = t.getData();
        r.hasItemVisual() && r.each(function(s) {
          var o = r.getItemVisual(s, "decal");
          if (o) {
            var l = r.ensureUniqueItemVisual(s, "style");
            l.decal = Lg(o, e);
          }
        });
        var i = r.getVisual("decal");
        if (i) {
          var a = r.getVisual("style");
          a.decal = Lg(i, e);
        }
      }
    });
  }
  var zs = new Is(), iY = {};
  function Jde(n, e) {
    iY[n] = e;
  }
  function efe(n) {
    return iY[n];
  }
  var tfe = 1, nfe = 800, rfe = 900, ife = 1e3, afe = 2e3, sfe = 5e3, aY = 1e3, ofe = 1100, bE = 2e3, sY = 3e3, lfe = 4e3, LC = 4500, ufe = 4600, cfe = 5e3, hfe = 6e3, oY = 7e3, dfe = {
    PROCESSOR: {
      FILTER: ife,
      SERIES_FILTER: nfe,
      STATISTIC: sfe
    },
    VISUAL: {
      LAYOUT: aY,
      PROGRESSIVE_LAYOUT: ofe,
      GLOBAL: bE,
      CHART: sY,
      POST_CHART_LAYOUT: ufe,
      COMPONENT: lfe,
      BRUSH: cfe,
      CHART_ITEM: LC,
      ARIA: hfe,
      DECAL: oY
    }
  }, _i = "__flagInMainProcess", fa = "__pendingUpdate", Sk = "__needsUpdateStatus", JO = /^[a-zA-Z0-9_]+$/, Ck = "__connectUpdateStatus", eB = 0, ffe = 1, pfe = 2;
  function lY(n) {
    return function() {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      if (this.isDisposed()) {
        this.id;
        return;
      }
      return cY(this, n, e);
    };
  }
  function uY(n) {
    return function() {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      return cY(this, n, e);
    };
  }
  function cY(n, e, t) {
    return t[0] = t[0] && t[0].toLowerCase(), Is.prototype[e].apply(n, t);
  }
  var hY = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e;
  }(Is), dY = hY.prototype;
  dY.on = uY("on");
  dY.off = uY("off");
  var Pp, Ik, L1, yu, kk, Tk, Ak, ty, ny, tB, nB, Dk, rB, F1, iB, fY, Ja, aB, pY = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this, new _de()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, Ie(r) && (r = gY[r]), a._dom = t;
      var s = "canvas", o = "auto", l = false;
      i.ssr && lle(function(d) {
        var f = rt(d), p = f.dataIndex;
        if (p != null) {
          var g = Pe();
          return g.set("series_index", f.seriesIndex), g.set("data_index", p), f.ssrType && g.set("ssr_type", f.ssrType), g;
        }
      });
      var u = a._zr = dF(t, {
        renderer: i.renderer || s,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: it(i.useDirtyRect, l),
        useCoarsePointer: it(i.useCoarsePointer, o),
        pointerSize: i.pointerSize
      });
      a._ssr = i.ssr, a._throttledZrFlush = vE(Ae(u.flush, u), 17), r = Qe(r), r && bX(r, true), a._theme = r, a._locale = Ece(i.locale || j8), a._coordSysMgr = new Ox();
      var c = a._api = iB(a);
      function h(d, f) {
        return d.__prio - f.__prio;
      }
      return Kw(Q_, h), Kw(sR, h), a._scheduler = new HX(a, c, sR, Q_), a._messageCenter = new hY(), a._initEvents(), a.resize = Ae(a.resize, a), u.animation.on("frame", a._onframe, a), tB(u, a), nB(u, a), R_(a), a;
    }
    return e.prototype._onframe = function() {
      if (!this._disposed) {
        aB(this);
        var t = this._scheduler;
        if (this[fa]) {
          var r = this[fa].silent;
          this[_i] = true;
          try {
            Pp(this), yu.update.call(this, null, this[fa].updateParams);
          } catch (l) {
            throw this[_i] = false, this[fa] = null, l;
          }
          this._zr.flush(), this[_i] = false, this[fa] = null, ty.call(this, r), ny.call(this, r);
        } else if (t.unfinished) {
          var i = tfe, a = this._model, s = this._api;
          t.unfinished = false;
          do {
            var o = +/* @__PURE__ */ new Date();
            t.performSeriesTasks(a), t.performDataProcessorTasks(a), Tk(this, a), t.performVisualTasks(a), F1(this, this._model, s, "remain", {}), i -= +/* @__PURE__ */ new Date() - o;
          } while (i > 0 && t.unfinished);
          t.unfinished || this._zr.flush();
        }
      }
    }, e.prototype.getDom = function() {
      return this._dom;
    }, e.prototype.getId = function() {
      return this.id;
    }, e.prototype.getZr = function() {
      return this._zr;
    }, e.prototype.isSSR = function() {
      return this._ssr;
    }, e.prototype.setOption = function(t, r, i) {
      if (!this[_i]) {
        if (this._disposed) {
          this.id;
          return;
        }
        var a, s, o;
        if (Ze(r) && (i = r.lazyUpdate, a = r.silent, s = r.replaceMerge, o = r.transition, r = r.notMerge), this[_i] = true, !this._model || r) {
          var l = new ihe(this._api), u = this._theme, c = this._model = new dE();
          c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
        }
        this._model.setOption(t, {
          replaceMerge: s
        }, oR);
        var h = {
          seriesTransition: o,
          optionChanged: true
        };
        if (i) this[fa] = {
          silent: a,
          updateParams: h
        }, this[_i] = false, this.getZr().wakeUp();
        else {
          try {
            Pp(this), yu.update.call(this, null, h);
          } catch (d) {
            throw this[fa] = null, this[_i] = false, d;
          }
          this._ssr || this._zr.flush(), this[fa] = null, this[_i] = false, ty.call(this, a), ny.call(this, a);
        }
      }
    }, e.prototype.setTheme = function() {
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, e.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, e.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, e.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || Dt.hasGlobalWindow && window.devicePixelRatio || 1;
    }, e.prototype.getRenderedCanvas = function(t) {
      return this.renderToCanvas(t);
    }, e.prototype.renderToCanvas = function(t) {
      t = t || {};
      var r = this._zr.painter;
      return r.getRenderedCanvas({
        backgroundColor: t.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
      });
    }, e.prototype.renderToSVGString = function(t) {
      t = t || {};
      var r = this._zr.painter;
      return r.renderToString({
        useViewBox: t.useViewBox
      });
    }, e.prototype.getSvgDataURL = function() {
      if (Dt.svgSupported) {
        var t = this._zr, r = t.storage.getDisplayList();
        return P(r, function(i) {
          i.stopAnimation(null, true);
        }), t.painter.toDataURL();
      }
    }, e.prototype.getDataURL = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      t = t || {};
      var r = t.excludeComponents, i = this._model, a = [], s = this;
      P(r, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = s._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = true);
        });
      });
      var o = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png"));
      return P(a, function(l) {
        l.group.ignore = false;
      }), o;
    }, e.prototype.getConnectedDataURL = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      var r = t.type === "svg", i = this.group, a = Math.min, s = Math.max, o = 1 / 0;
      if (sB[i]) {
        var l = o, u = o, c = -o, h = -o, d = [], f = t && t.pixelRatio || this.getDevicePixelRatio();
        P(h0, function(x, b) {
          if (x.group === i) {
            var w = r ? x.getZr().painter.getSvgDom().innerHTML : x.renderToCanvas(Qe(t)), _ = x.getDom().getBoundingClientRect();
            l = a(_.left, l), u = a(_.top, u), c = s(_.right, c), h = s(_.bottom, h), d.push({
              dom: w,
              left: _.left,
              top: _.top
            });
          }
        }), l *= f, u *= f, c *= f, h *= f;
        var p = c - l, g = h - u, m = ec.createCanvas(), v = dF(m, {
          renderer: r ? "svg" : "canvas"
        });
        if (v.resize({
          width: p,
          height: g
        }), r) {
          var y = "";
          return P(d, function(x) {
            var b = x.left - l, w = x.top - u;
            y += '<g transform="translate(' + b + "," + w + ')">' + x.dom + "</g>";
          }), v.painter.getSvgRoot().innerHTML = y, t.connectedBackgroundColor && v.painter.setBackgroundColor(t.connectedBackgroundColor), v.refreshImmediately(), v.painter.toDataURL();
        } else return t.connectedBackgroundColor && v.add(new Vt({
          shape: {
            x: 0,
            y: 0,
            width: p,
            height: g
          },
          style: {
            fill: t.connectedBackgroundColor
          }
        })), P(d, function(x) {
          var b = new oi({
            style: {
              x: x.left * f - l,
              y: x.top * f - u,
              image: x.dom
            }
          });
          v.add(b);
        }), v.refreshImmediately(), m.toDataURL("image/" + (t && t.type || "png"));
      } else return this.getDataURL(t);
    }, e.prototype.convertToPixel = function(t, r) {
      return kk(this, "convertToPixel", t, r);
    }, e.prototype.convertFromPixel = function(t, r) {
      return kk(this, "convertFromPixel", t, r);
    }, e.prototype.containPixel = function(t, r) {
      if (this._disposed) {
        this.id;
        return;
      }
      var i = this._model, a, s = i0(i, t);
      return P(s, function(o, l) {
        l.indexOf("Models") >= 0 && P(o, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint) a = a || !!c.containPoint(r);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint && (a = a || h.containPoint(r, u));
          }
        }, this);
      }, this), !!a;
    }, e.prototype.getVisual = function(t, r) {
      var i = this._model, a = i0(i, t, {
        defaultMainType: "series"
      }), s = a.seriesModel, o = s.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? o.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? yE(o, l, r) : Bx(o, r);
    }, e.prototype.getViewOfComponentModel = function(t) {
      return this._componentsMap[t.__viewId];
    }, e.prototype.getViewOfSeriesModel = function(t) {
      return this._chartsMap[t.__viewId];
    }, e.prototype._initEvents = function() {
      var t = this;
      P(gfe, function(r) {
        var i = function(a) {
          var s = t.getModel(), o = a.target, l, u = r === "globalout";
          if (u ? l = {} : o && Bh(o, function(p) {
            var g = rt(p);
            if (g && g.dataIndex != null) {
              var m = g.dataModel || s.getSeriesByIndex(g.seriesIndex);
              return l = m && m.getDataParams(g.dataIndex, g.dataType, o) || {}, true;
            } else if (g.eventData) return l = oe({}, g.eventData), true;
          }, true), l) {
            var c = l.componentType, h = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", h = l.seriesIndex);
            var d = c && h != null && s.getComponent(c, h), f = d && t[d.mainType === "series" ? "_chartsMap" : "_componentsMap"][d.__viewId];
            l.event = a, l.type = r, t._$eventProcessor.eventInfo = {
              targetEl: o,
              packedEvent: l,
              model: d,
              view: f
            }, t.trigger(r, l);
          }
        };
        i.zrEventfulCallAtLast = true, t._zr.on(r, i, t);
      }), P(c0, function(r, i) {
        t._messageCenter.on(i, function(a) {
          this.trigger(i, a);
        }, t);
      }), P([
        "selectchanged"
      ], function(r) {
        t._messageCenter.on(r, function(i) {
          this.trigger(r, i);
        }, t);
      }), Ide(this._messageCenter, this, this._api);
    }, e.prototype.isDisposed = function() {
      return this._disposed;
    }, e.prototype.clear = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this.setOption({
        series: []
      }, true);
    }, e.prototype.dispose = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._disposed = true;
      var t = this.getDom();
      t && o8(this.getDom(), _E, "");
      var r = this, i = r._api, a = r._model;
      P(r._componentsViews, function(s) {
        s.dispose(a, i);
      }), P(r._chartsViews, function(s) {
        s.dispose(a, i);
      }), r._zr.dispose(), r._dom = r._model = r._chartsMap = r._componentsMap = r._chartsViews = r._componentsViews = r._scheduler = r._api = r._zr = r._throttledZrFlush = r._theme = r._coordSysMgr = r._messageCenter = null, delete h0[r.id];
    }, e.prototype.resize = function(t) {
      if (!this[_i]) {
        if (this._disposed) {
          this.id;
          return;
        }
        this._zr.resize(t);
        var r = this._model;
        if (this._loadingFX && this._loadingFX.resize(), !!r) {
          var i = r.resetOption("media"), a = t && t.silent;
          this[fa] && (a == null && (a = this[fa].silent), i = true, this[fa] = null), this[_i] = true;
          try {
            i && Pp(this), yu.update.call(this, {
              type: "resize",
              animation: oe({
                duration: 0
              }, t && t.animation)
            });
          } catch (s) {
            throw this[_i] = false, s;
          }
          this[_i] = false, ty.call(this, a), ny.call(this, a);
        }
      }
    }, e.prototype.showLoading = function(t, r) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (Ze(t) && (r = t, t = ""), t = t || "default", this.hideLoading(), !!lR[t]) {
        var i = lR[t](this._api, r), a = this._zr;
        this._loadingFX = i, a.add(i);
      }
    }, e.prototype.hideLoading = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, e.prototype.makeActionFromEvent = function(t) {
      var r = oe({}, t);
      return r.type = c0[t.type], r;
    }, e.prototype.dispatchAction = function(t, r) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (Ze(r) || (r = {
        silent: !!r
      }), !!Z_[t.type] && this._model) {
        if (this[_i]) {
          this._pendingActions.push(t);
          return;
        }
        var i = r.silent;
        Ak.call(this, t, i);
        var a = r.flush;
        a ? this._zr.flush() : a !== false && Dt.browser.weChat && this._throttledZrFlush(), ty.call(this, i), ny.call(this, i);
      }
    }, e.prototype.updateLabelLayout = function() {
      zs.trigger("series:layoutlabels", this._model, this._api, {
        updatedSeries: []
      });
    }, e.prototype.appendData = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      var r = t.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(r);
      a.appendData(t), this._scheduler.unfinished = true, this.getZr().wakeUp();
    }, e.internalField = function() {
      Pp = function(h) {
        var d = h._scheduler;
        d.restorePipelines(h._model), d.prepareStageTasks(), Ik(h, true), Ik(h, false), d.plan();
      }, Ik = function(h, d) {
        for (var f = h._model, p = h._scheduler, g = d ? h._componentsViews : h._chartsViews, m = d ? h._componentsMap : h._chartsMap, v = h._zr, y = h._api, x = 0; x < g.length; x++) g[x].__alive = false;
        d ? f.eachComponent(function(_, S) {
          _ !== "series" && b(S);
        }) : f.eachSeries(b);
        function b(_) {
          var S = _.__requireNewView;
          _.__requireNewView = false;
          var I = "_ec_" + _.id + "_" + _.type, C = !S && m[I];
          if (!C) {
            var T = Bo(_.type), k = d ? Yn.getClass(T.main, T.sub) : _n.getClass(T.sub);
            C = new k(), C.init(f, y), m[I] = C, g.push(C), v.add(C.group);
          }
          _.__viewId = C.__id = I, C.__alive = true, C.__model = _, C.group.__ecComponentInfo = {
            mainType: _.mainType,
            index: _.componentIndex
          }, !d && p.prepareView(C, _, f, y);
        }
        for (var x = 0; x < g.length; ) {
          var w = g[x];
          w.__alive ? x++ : (!d && w.renderTask.dispose(), v.remove(w.group), w.dispose(f, y), g.splice(x, 1), m[w.__id] === w && delete m[w.__id], w.__id = w.group.__ecComponentInfo = null);
        }
      }, L1 = function(h, d, f, p, g) {
        var m = h._model;
        if (m.setUpdatePayload(f), !p) {
          P([].concat(h._componentsViews).concat(h._chartsViews), w);
          return;
        }
        var v = {};
        v[p + "Id"] = f[p + "Id"], v[p + "Index"] = f[p + "Index"], v[p + "Name"] = f[p + "Name"];
        var y = {
          mainType: p,
          query: v
        };
        g && (y.subType = g);
        var x = f.excludeSeriesId, b;
        x != null && (b = Pe(), P(xn(x), function(_) {
          var S = kr(_, null);
          S != null && b.set(S, true);
        })), m && m.eachComponent(y, function(_) {
          var S = b && b.get(_.id) != null;
          if (!S) if (VF(f)) if (_ instanceof En) f.type === Zh && !f.notBlur && !_.get([
            "emphasis",
            "disabled"
          ]) && Nue(_, f, h._api);
          else {
            var I = ZN(_.mainType, _.componentIndex, f.name, h._api), C = I.focusSelf, T = I.dispatchers;
            f.type === Zh && C && !f.notBlur && WD(_.mainType, _.componentIndex, h._api), T && P(T, function(k) {
              f.type === Zh ? Xl(k) : Yl(k);
            });
          }
          else UD(f) && _ instanceof En && (Pue(_, f, h._api), BF(_), Ja(h));
        }, h), m && m.eachComponent(y, function(_) {
          var S = b && b.get(_.id) != null;
          S || w(h[p === "series" ? "_chartsMap" : "_componentsMap"][_.__viewId]);
        }, h);
        function w(_) {
          _ && _.__alive && _[d] && _[d](_.__model, m, h._api, f);
        }
      }, yu = {
        prepareAndUpdate: function(h) {
          Pp(this), yu.update.call(this, h, {
            optionChanged: h.newOption != null
          });
        },
        update: function(h, d) {
          var f = this._model, p = this._api, g = this._zr, m = this._coordSysMgr, v = this._scheduler;
          if (f) {
            f.setUpdatePayload(h), v.restoreData(f, h), v.performSeriesTasks(f), m.create(f, p), v.performDataProcessorTasks(f, h), Tk(this, f), m.update(f, p), t(f), v.performVisualTasks(f, h), Dk(this, f, p, h, d);
            var y = f.get("backgroundColor") || "transparent", x = f.get("darkMode");
            g.setBackgroundColor(y), x != null && x !== "auto" && g.setDarkMode(x), zs.trigger("afterupdate", f, p);
          }
        },
        updateTransform: function(h) {
          var d = this, f = this._model, p = this._api;
          if (f) {
            f.setUpdatePayload(h);
            var g = [];
            f.eachComponent(function(v, y) {
              if (v !== "series") {
                var x = d.getViewOfComponentModel(y);
                if (x && x.__alive) if (x.updateTransform) {
                  var b = x.updateTransform(y, f, p, h);
                  b && b.update && g.push(x);
                } else g.push(x);
              }
            });
            var m = Pe();
            f.eachSeries(function(v) {
              var y = d._chartsMap[v.__viewId];
              if (y.updateTransform) {
                var x = y.updateTransform(v, f, p, h);
                x && x.update && m.set(v.uid, 1);
              } else m.set(v.uid, 1);
            }), t(f), this._scheduler.performVisualTasks(f, h, {
              setDirty: true,
              dirtyMap: m
            }), F1(this, f, p, h, {}, m), zs.trigger("afterupdate", f, p);
          }
        },
        updateView: function(h) {
          var d = this._model;
          d && (d.setUpdatePayload(h), _n.markUpdateMethod(h, "updateView"), t(d), this._scheduler.performVisualTasks(d, h, {
            setDirty: true
          }), Dk(this, d, this._api, h, {}), zs.trigger("afterupdate", d, this._api));
        },
        updateVisual: function(h) {
          var d = this, f = this._model;
          f && (f.setUpdatePayload(h), f.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), _n.markUpdateMethod(h, "updateVisual"), t(f), this._scheduler.performVisualTasks(f, h, {
            visualType: "visual",
            setDirty: true
          }), f.eachComponent(function(p, g) {
            if (p !== "series") {
              var m = d.getViewOfComponentModel(g);
              m && m.__alive && m.updateVisual(g, f, d._api, h);
            }
          }), f.eachSeries(function(p) {
            var g = d._chartsMap[p.__viewId];
            g.updateVisual(p, f, d._api, h);
          }), zs.trigger("afterupdate", f, this._api));
        },
        updateLayout: function(h) {
          yu.update.call(this, h);
        }
      }, kk = function(h, d, f, p) {
        if (h._disposed) {
          h.id;
          return;
        }
        for (var g = h._model, m = h._coordSysMgr.getCoordinateSystems(), v, y = i0(g, f), x = 0; x < m.length; x++) {
          var b = m[x];
          if (b[d] && (v = b[d](g, y, p)) != null) return v;
        }
      }, Tk = function(h, d) {
        var f = h._chartsMap, p = h._scheduler;
        d.eachSeries(function(g) {
          p.updateStreamModes(g, f[g.__viewId]);
        });
      }, Ak = function(h, d) {
        var f = this, p = this.getModel(), g = h.type, m = h.escapeConnect, v = Z_[g], y = v.actionInfo, x = (y.update || "update").split(":"), b = x.pop(), w = x[0] != null && Bo(x[0]);
        this[_i] = true;
        var _ = [
          h
        ], S = false;
        h.batch && (S = true, _ = me(h.batch, function(N) {
          return N = je(oe({}, N), h), N.batch = null, N;
        }));
        var I = [], C, T = UD(h), k = VF(h);
        if (k && A8(this._api), P(_, function(N) {
          if (C = v.action(N, f._model, f._api), C = C || oe({}, N), C.type = y.event || C.type, I.push(C), k) {
            var E = GN(h), A = E.queryOptionMap, M = E.mainTypeSpecified, $ = M ? A.keys()[0] : "series";
            L1(f, b, N, $), Ja(f);
          } else T ? (L1(f, b, N, "series"), Ja(f)) : w && L1(f, b, N, w.main, w.sub);
        }), b !== "none" && !k && !T && !w) try {
          this[fa] ? (Pp(this), yu.update.call(this, h), this[fa] = null) : yu[b].call(this, h);
        } catch (N) {
          throw this[_i] = false, N;
        }
        if (S ? C = {
          type: y.event || g,
          escapeConnect: m,
          batch: I
        } : C = I[0], this[_i] = false, !d) {
          var D = this._messageCenter;
          if (D.trigger(C.type, C), T) {
            var R = {
              type: "selectchanged",
              escapeConnect: m,
              selected: Lue(p),
              isFromClick: h.isFromClick || false,
              fromAction: h.type,
              fromActionPayload: h
            };
            D.trigger(R.type, R);
          }
        }
      }, ty = function(h) {
        for (var d = this._pendingActions; d.length; ) {
          var f = d.shift();
          Ak.call(this, f, h);
        }
      }, ny = function(h) {
        !h && this.trigger("updated");
      }, tB = function(h, d) {
        h.on("rendered", function(f) {
          d.trigger("rendered", f), h.animation.isFinished() && !d[fa] && !d._scheduler.unfinished && !d._pendingActions.length && d.trigger("finished");
        });
      }, nB = function(h, d) {
        h.on("mouseover", function(f) {
          var p = f.target, g = Bh(p, N0);
          g && (Eue(g, f, d._api), Ja(d));
        }).on("mouseout", function(f) {
          var p = f.target, g = Bh(p, N0);
          g && (Mue(g, f, d._api), Ja(d));
        }).on("click", function(f) {
          var p = f.target, g = Bh(p, function(y) {
            return rt(y).dataIndex != null;
          }, true);
          if (g) {
            var m = g.selected ? "unselect" : "select", v = rt(g);
            d._api.dispatchAction({
              type: m,
              dataType: v.dataType,
              dataIndexInside: v.dataIndex,
              seriesIndex: v.seriesIndex,
              isFromClick: true
            });
          }
        });
      };
      function t(h) {
        h.clearColorPalette(), h.eachSeries(function(d) {
          d.clearColorPalette();
        });
      }
      function r(h) {
        var d = [], f = [], p = false;
        if (h.eachComponent(function(y, x) {
          var b = x.get("zlevel") || 0, w = x.get("z") || 0, _ = x.getZLevelKey();
          p = p || !!_, (y === "series" ? f : d).push({
            zlevel: b,
            z: w,
            idx: x.componentIndex,
            type: y,
            key: _
          });
        }), p) {
          var g = d.concat(f), m, v;
          Kw(g, function(y, x) {
            return y.zlevel === x.zlevel ? y.z - x.z : y.zlevel - x.zlevel;
          }), P(g, function(y) {
            var x = h.getComponent(y.type, y.idx), b = y.zlevel, w = y.key;
            m != null && (b = Math.max(m, b)), w ? (b === m && w !== v && b++, v = w) : v && (b === m && b++, v = ""), m = b, x.setZLevel(b);
          });
        }
      }
      Dk = function(h, d, f, p, g) {
        r(d), rB(h, d, f, p, g), P(h._chartsViews, function(m) {
          m.__alive = false;
        }), F1(h, d, f, p, g), P(h._chartsViews, function(m) {
          m.__alive || m.remove(d, f);
        });
      }, rB = function(h, d, f, p, g, m) {
        P(m || h._componentsViews, function(v) {
          var y = v.__model;
          u(y, v), v.render(y, d, f, p), o(y, v), c(y, v);
        });
      }, F1 = function(h, d, f, p, g, m) {
        var v = h._scheduler;
        g = oe(g || {}, {
          updatedSeries: d.getSeries()
        }), zs.trigger("series:beforeupdate", d, f, g);
        var y = false;
        d.eachSeries(function(x) {
          var b = h._chartsMap[x.__viewId];
          b.__alive = true;
          var w = b.renderTask;
          v.updatePayload(w, p), u(x, b), m && m.get(x.uid) && w.dirty(), w.perform(v.getPerformArgs(w)) && (y = true), b.group.silent = !!x.get("silent"), s(x, b), BF(x);
        }), v.unfinished = y || v.unfinished, zs.trigger("series:layoutlabels", d, f, g), zs.trigger("series:transition", d, f, g), d.eachSeries(function(x) {
          var b = h._chartsMap[x.__viewId];
          o(x, b), c(x, b);
        }), a(h, d), zs.trigger("series:afterupdate", d, f, g);
      }, Ja = function(h) {
        h[Sk] = true, h.getZr().wakeUp();
      }, aB = function(h) {
        h[Sk] && (h.getZr().storage.traverse(function(d) {
          _g(d) || i(d);
        }), h[Sk] = false);
      };
      function i(h) {
        for (var d = [], f = h.currentStates, p = 0; p < f.length; p++) {
          var g = f[p];
          g === "emphasis" || g === "blur" || g === "select" || d.push(g);
        }
        h.selected && h.states.select && d.push("select"), h.hoverState === bC && h.states.emphasis ? d.push("emphasis") : h.hoverState === Nx && h.states.blur && d.push("blur"), h.useStates(d);
      }
      function a(h, d) {
        var f = h._zr, p = f.storage, g = 0;
        p.traverse(function(m) {
          m.isGroup || g++;
        }), g > d.get("hoverLayerThreshold") && !Dt.node && !Dt.worker && d.eachSeries(function(m) {
          if (!m.preventUsingHoverLayer) {
            var v = h._chartsMap[m.__viewId];
            v.__alive && v.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = true);
            });
          }
        });
      }
      function s(h, d) {
        var f = h.get("blendMode") || null;
        d.eachRendered(function(p) {
          p.isGroup || (p.style.blend = f);
        });
      }
      function o(h, d) {
        if (!h.preventAutoZ) {
          var f = h.get("z") || 0, p = h.get("zlevel") || 0;
          d.eachRendered(function(g) {
            return l(g, f, p, -1 / 0), true;
          });
        }
      }
      function l(h, d, f, p) {
        var g = h.getTextContent(), m = h.getTextGuideLine(), v = h.isGroup;
        if (v) for (var y = h.childrenRef(), x = 0; x < y.length; x++) p = Math.max(l(y[x], d, f, p), p);
        else h.z = d, h.zlevel = f, p = Math.max(h.z2, p);
        if (g && (g.z = d, g.zlevel = f, isFinite(p) && (g.z2 = p + 2)), m) {
          var b = h.textGuideLineConfig;
          m.z = d, m.zlevel = f, isFinite(p) && (m.z2 = p + (b && b.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(h, d) {
        d.eachRendered(function(f) {
          if (!_g(f)) {
            var p = f.getTextContent(), g = f.getTextGuideLine();
            f.stateTransition && (f.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), f.hasState() ? (f.prevStates = f.currentStates, f.clearStates()) : f.prevStates && (f.prevStates = null);
          }
        });
      }
      function c(h, d) {
        var f = h.getModel("stateAnimation"), p = h.isAnimationEnabled(), g = f.get("duration"), m = g > 0 ? {
          duration: g,
          delay: f.get("delay"),
          easing: f.get("easing")
        } : null;
        d.eachRendered(function(v) {
          if (v.states && v.states.emphasis) {
            if (_g(v)) return;
            if (v instanceof At && Vue(v), v.__dirty) {
              var y = v.prevStates;
              y && v.useStates(y);
            }
            if (p) {
              v.stateTransition = m;
              var x = v.getTextContent(), b = v.getTextGuideLine();
              x && (x.stateTransition = m), b && (b.stateTransition = m);
            }
            v.__dirty && i(v);
          }
        });
      }
      iB = function(h) {
        return new (function(d) {
          K(f, d);
          function f() {
            return d !== null && d.apply(this, arguments) || this;
          }
          return f.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, f.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null) return h._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, f.prototype.enterEmphasis = function(p, g) {
            Xl(p, g), Ja(h);
          }, f.prototype.leaveEmphasis = function(p, g) {
            Yl(p, g), Ja(h);
          }, f.prototype.enterBlur = function(p) {
            C8(p), Ja(h);
          }, f.prototype.leaveBlur = function(p) {
            KN(p), Ja(h);
          }, f.prototype.enterSelect = function(p) {
            I8(p), Ja(h);
          }, f.prototype.leaveSelect = function(p) {
            k8(p), Ja(h);
          }, f.prototype.getModel = function() {
            return h.getModel();
          }, f.prototype.getViewOfComponentModel = function(p) {
            return h.getViewOfComponentModel(p);
          }, f.prototype.getViewOfSeriesModel = function(p) {
            return h.getViewOfSeriesModel(p);
          }, f;
        }(yX))(h);
      }, fY = function(h) {
        function d(f, p) {
          for (var g = 0; g < f.length; g++) {
            var m = f[g];
            m[Ck] = p;
          }
        }
        P(c0, function(f, p) {
          h._messageCenter.on(p, function(g) {
            if (sB[h.group] && h[Ck] !== eB) {
              if (g && g.escapeConnect) return;
              var m = h.makeActionFromEvent(g), v = [];
              P(h0, function(y) {
                y !== h && y.group === h.group && v.push(y);
              }), d(v, eB), P(v, function(y) {
                y[Ck] !== ffe && y.dispatchAction(m);
              }), d(v, pfe);
            }
          });
        });
      };
    }(), e;
  }(Is), wE = pY.prototype;
  wE.on = lY("on");
  wE.off = lY("off");
  wE.one = function(n, e, t) {
    var r = this;
    function i() {
      for (var a = [], s = 0; s < arguments.length; s++) a[s] = arguments[s];
      e && e.apply && e.apply(this, a), r.off(n, i);
    }
    this.on.call(this, n, i, t);
  };
  var gfe = [
    "click",
    "dblclick",
    "mouseover",
    "mouseout",
    "mousemove",
    "mousedown",
    "mouseup",
    "globalout",
    "contextmenu"
  ];
  var Z_ = {}, c0 = {}, sR = [], oR = [], Q_ = [], gY = {}, lR = {}, h0 = {}, sB = {}, mfe = +/* @__PURE__ */ new Date() - 0, _E = "_echarts_instance_";
  function vfe(n, e, t) {
    {
      var r = yfe(n);
      if (r) return r;
    }
    var i = new pY(n, e, t);
    return i.id = "ec_" + mfe++, h0[i.id] = i, o8(n, _E, i.id), fY(i), zs.trigger("afterinit", i), i;
  }
  function yfe(n) {
    return h0[Dle(n, _E)];
  }
  function mY(n, e) {
    gY[n] = e;
  }
  function vY(n) {
    bt(oR, n) < 0 && oR.push(n);
  }
  function yY(n, e) {
    CE(sR, n, e, afe);
  }
  function xfe(n) {
    SE("afterinit", n);
  }
  function bfe(n) {
    SE("afterupdate", n);
  }
  function SE(n, e) {
    zs.on(n, e);
  }
  function cl(n, e, t) {
    Xe(e) && (t = e, e = "");
    var r = Ze(n) ? n.type : [
      n,
      n = {
        event: e
      }
    ][0];
    n.event = (n.event || r).toLowerCase(), e = n.event, !c0[e] && (ta(JO.test(r) && JO.test(e)), Z_[r] || (Z_[r] = {
      action: t,
      actionInfo: n
    }), c0[e] = r);
  }
  function wfe(n, e) {
    Ox.register(n, e);
  }
  function _fe(n, e) {
    CE(Q_, n, e, aY, "layout");
  }
  function Od(n, e) {
    CE(Q_, n, e, sY, "visual");
  }
  var oB = [];
  function CE(n, e, t, r, i) {
    if ((Xe(e) || Ze(e)) && (t = e, e = r), !(bt(oB, t) >= 0)) {
      oB.push(t);
      var a = HX.wrapStageHandler(t, i);
      a.__prio = e, a.__raw = t, n.push(a);
    }
  }
  function xY(n, e) {
    lR[n] = e;
  }
  function Sfe(n, e, t) {
    var r = efe("registerMap");
    r && r(n, e, t);
  }
  var Cfe = Lhe;
  Od(bE, lde);
  Od(LC, ude);
  Od(LC, cde);
  Od(bE, Sde);
  Od(LC, Cde);
  Od(oY, Qde);
  vY(bX);
  yY(rfe, mhe);
  xY("default", hde);
  cl({
    type: Zh,
    event: Zh,
    update: Zh
  }, ur);
  cl({
    type: n_,
    event: n_,
    update: n_
  }, ur);
  cl({
    type: a0,
    event: a0,
    update: a0
  }, ur);
  cl({
    type: r_,
    event: r_,
    update: r_
  }, ur);
  cl({
    type: s0,
    event: s0,
    update: s0
  }, ur);
  mY("light", wde);
  mY("dark", jX);
  var lB = [], Ife = {
    registerPreprocessor: vY,
    registerProcessor: yY,
    registerPostInit: xfe,
    registerPostUpdate: bfe,
    registerUpdateLifecycle: SE,
    registerAction: cl,
    registerCoordinateSystem: wfe,
    registerLayout: _fe,
    registerVisual: Od,
    registerTransform: Cfe,
    registerLoading: xY,
    registerMap: Sfe,
    registerImpl: Jde,
    PRIORITY: dfe,
    ComponentModel: Et,
    ComponentView: Yn,
    SeriesModel: En,
    ChartView: _n,
    registerComponentModel: function(n) {
      Et.registerClass(n);
    },
    registerComponentView: function(n) {
      Yn.registerClass(n);
    },
    registerSeriesModel: function(n) {
      En.registerClass(n);
    },
    registerChartView: function(n) {
      _n.registerClass(n);
    },
    registerSubTypeDefaulter: function(n, e) {
      Et.registerSubTypeDefaulter(n, e);
    },
    registerPainter: function(n, e) {
      sle(n, e);
    }
  };
  function Ct(n) {
    if (de(n)) {
      P(n, function(e) {
        Ct(e);
      });
      return;
    }
    bt(lB, n) >= 0 || (lB.push(n), Xe(n) && (n = {
      install: n
    }), n.install(Ife));
  }
  function ry(n) {
    return n == null ? 0 : n.length || 1;
  }
  function uB(n) {
    return n;
  }
  var ql = function() {
    function n(e, t, r, i, a, s) {
      this._old = e, this._new = t, this._oldKeyGetter = r || uB, this._newKeyGetter = i || uB, this.context = a, this._diffModeMultiple = s === "multiple";
    }
    return n.prototype.add = function(e) {
      return this._add = e, this;
    }, n.prototype.update = function(e) {
      return this._update = e, this;
    }, n.prototype.updateManyToOne = function(e) {
      return this._updateManyToOne = e, this;
    }, n.prototype.updateOneToMany = function(e) {
      return this._updateOneToMany = e, this;
    }, n.prototype.updateManyToMany = function(e) {
      return this._updateManyToMany = e, this;
    }, n.prototype.remove = function(e) {
      return this._remove = e, this;
    }, n.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, n.prototype._executeOneToOne = function() {
      var e = this._old, t = this._new, r = {}, i = new Array(e.length), a = new Array(t.length);
      this._initIndexMap(e, null, i, "_oldKeyGetter"), this._initIndexMap(t, r, a, "_newKeyGetter");
      for (var s = 0; s < e.length; s++) {
        var o = i[s], l = r[o], u = ry(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (r[o] = l[0]), this._update && this._update(c, s);
        } else u === 1 ? (r[o] = null, this._update && this._update(l, s)) : this._remove && this._remove(s);
      }
      this._performRestAdd(a, r);
    }, n.prototype._executeMultiple = function() {
      var e = this._old, t = this._new, r = {}, i = {}, a = [], s = [];
      this._initIndexMap(e, r, a, "_oldKeyGetter"), this._initIndexMap(t, i, s, "_newKeyGetter");
      for (var o = 0; o < a.length; o++) {
        var l = a[o], u = r[l], c = i[l], h = ry(u), d = ry(c);
        if (h > 1 && d === 1) this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (h === 1 && d > 1) this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (h === 1 && d === 1) this._update && this._update(c, u), i[l] = null;
        else if (h > 1 && d > 1) this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (h > 1) for (var f = 0; f < h; f++) this._remove && this._remove(u[f]);
        else this._remove && this._remove(u);
      }
      this._performRestAdd(s, i);
    }, n.prototype._performRestAdd = function(e, t) {
      for (var r = 0; r < e.length; r++) {
        var i = e[r], a = t[i], s = ry(a);
        if (s > 1) for (var o = 0; o < s; o++) this._add && this._add(a[o]);
        else s === 1 && this._add && this._add(a);
        t[i] = null;
      }
    }, n.prototype._initIndexMap = function(e, t, r, i) {
      for (var a = this._diffModeMultiple, s = 0; s < e.length; s++) {
        var o = "_ec_" + this[i](e[s], s);
        if (a || (r[s] = o), !!t) {
          var l = t[o], u = ry(l);
          u === 0 ? (t[o] = s, a && r.push(o)) : u === 1 ? t[o] = [
            l,
            s
          ] : l.push(s);
        }
      }
    }, n;
  }(), kfe = function() {
    function n(e, t) {
      this._encode = e, this._schema = t;
    }
    return n.prototype.get = function() {
      return {
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, n.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, n;
  }();
  function Tfe(n, e) {
    var t = {}, r = t.encode = {}, i = Pe(), a = [], s = [], o = {};
    P(n.dimensions, function(d) {
      var f = n.getDimensionInfo(d), p = f.coordDim;
      if (p) {
        var g = f.coordDimIndex;
        Rk(r, p)[g] = d, f.isExtraCoord || (i.set(p, 1), Afe(f.type) && (a[0] = d), Rk(o, p)[g] = n.getDimensionIndex(f.name)), f.defaultTooltip && s.push(d);
      }
      hX.each(function(m, v) {
        var y = Rk(r, v), x = f.otherDims[v];
        x != null && x !== false && (y[x] = f.name);
      });
    });
    var l = [], u = {};
    i.each(function(d, f) {
      var p = r[f];
      u[f] = p[0], l = l.concat(p);
    }), t.dataDimsOnCoord = l, t.dataDimIndicesOnCoord = me(l, function(d) {
      return n.getDimensionInfo(d).storeDimIndex;
    }), t.encodeFirstDimNotExtra = u;
    var c = r.label;
    c && c.length && (a = c.slice());
    var h = r.tooltip;
    return h && h.length ? s = h.slice() : s.length || (s = a.slice()), r.defaultedLabel = a, r.defaultedTooltip = s, t.userOutput = new kfe(o, e), t;
  }
  function Rk(n, e) {
    return n.hasOwnProperty(e) || (n[e] = []), n[e];
  }
  function J_(n) {
    return n === "category" ? "ordinal" : n === "time" ? "time" : "float";
  }
  function Afe(n) {
    return !(n === "ordinal" || n === "time");
  }
  var l_ = /* @__PURE__ */ function() {
    function n(e) {
      this.otherDims = {}, e != null && oe(this, e);
    }
    return n;
  }(), Dfe = Wt(), Rfe = {
    float: "f",
    int: "i",
    ordinal: "o",
    number: "n",
    time: "t"
  }, bY = function() {
    function n(e) {
      this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted);
    }
    return n.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, n.prototype._updateDimOmitted = function(e) {
      this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = SY(this.source)));
    }, n.prototype.getSourceDimensionIndex = function(e) {
      return it(this._dimNameMap.get(e), -1);
    }, n.prototype.getSourceDimension = function(e) {
      var t = this.source.dimensionsDefine;
      if (t) return t[e];
    }, n.prototype.makeStoreSchema = function() {
      for (var e = this._fullDimCount, t = _X(this.source), r = !CY(e), i = "", a = [], s = 0, o = 0; s < e; s++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[o];
        if (h && h.storeDimIndex === s) l = t ? h.name : null, u = h.type, c = h.ordinalMeta, o++;
        else {
          var d = this.getSourceDimension(s);
          d && (l = t ? d.name : null, u = d.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), t && l != null && (!h || !h.isCalculationCoord) && (i += r ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += Rfe[u] || "f", c && (i += c.uid), i += "$";
      }
      var f = this.source, p = [
        f.seriesLayoutBy,
        f.startIndex,
        i
      ].join("$$");
      return {
        dimensions: a,
        hash: p
      };
    }, n.prototype.makeOutputDimensionNames = function() {
      for (var e = [], t = 0, r = 0; t < this._fullDimCount; t++) {
        var i = void 0, a = this.dimensions[r];
        if (a && a.storeDimIndex === t) a.isCalculationCoord || (i = a.name), r++;
        else {
          var s = this.getSourceDimension(t);
          s && (i = s.name);
        }
        e.push(i);
      }
      return e;
    }, n.prototype.appendCalculationDimension = function(e) {
      this.dimensions.push(e), e.isCalculationCoord = true, this._fullDimCount++, this._updateDimOmitted(true);
    }, n;
  }();
  function wY(n) {
    return n instanceof bY;
  }
  function _Y(n) {
    for (var e = Pe(), t = 0; t < (n || []).length; t++) {
      var r = n[t], i = Ze(r) ? r.name : r;
      i != null && e.get(i) == null && e.set(i, t);
    }
    return e;
  }
  function SY(n) {
    var e = Dfe(n);
    return e.dimNameMap || (e.dimNameMap = _Y(n.dimensionsDefine));
  }
  function CY(n) {
    return n > 30;
  }
  var iy = Ze, xu = me, $fe = typeof Int32Array > "u" ? Array : Int32Array, Nfe = "e\0\0", cB = -1, Efe = [
    "hasItemOption",
    "_nameList",
    "_idList",
    "_invertedIndicesMap",
    "_dimSummary",
    "userOutput",
    "_rawData",
    "_dimValueGetter",
    "_nameDimIdx",
    "_idDimIdx",
    "_nameRepeatCount"
  ], Mfe = [
    "_approximateExtent"
  ], hB, O1, ay, sy, $k, oy, Nk, Ki = function() {
    function n(e, t) {
      this.type = "list", this._dimOmitted = false, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = false, this.TRANSFERABLE_METHODS = [
        "cloneShallow",
        "downSample",
        "minmaxDownSample",
        "lttbDownSample",
        "map"
      ], this.CHANGABLE_METHODS = [
        "filterSelf",
        "selectRange"
      ], this.DOWNSAMPLE_METHODS = [
        "downSample",
        "minmaxDownSample",
        "lttbDownSample"
      ];
      var r, i = false;
      wY(e) ? (r = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (i = true, r = e), r = r || [
        "x",
        "y"
      ];
      for (var a = {}, s = [], o = {}, l = false, u = {}, c = 0; c < r.length; c++) {
        var h = r[c], d = Ie(h) ? new l_({
          name: h
        }) : h instanceof l_ ? h : new l_(h), f = d.name;
        d.type = d.type || "float", d.coordDim || (d.coordDim = f, d.coordDimIndex = 0);
        var p = d.otherDims = d.otherDims || {};
        s.push(f), a[f] = d, u[f] != null && (l = true), d.createInvertedIndices && (o[f] = []), p.itemName === 0 && (this._nameDimIdx = c), p.itemId === 0 && (this._idDimIdx = c), i && (d.storeDimIndex = c);
      }
      if (this.dimensions = s, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = t, this._invertedIndicesMap = o, this._dimOmitted) {
        var g = this._dimIdxToName = Pe();
        P(s, function(m) {
          g.set(a[m].storeDimIndex, m);
        });
      }
    }
    return n.prototype.getDimension = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t == null) return e;
      if (t = e, !this._dimOmitted) return this.dimensions[t];
      var r = this._dimIdxToName.get(t);
      if (r != null) return r;
      var i = this._schema.getSourceDimension(t);
      if (i) return i.name;
    }, n.prototype.getDimensionIndex = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t != null) return t;
      if (e == null) return -1;
      var r = this._getDimInfo(e);
      return r ? r.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1;
    }, n.prototype._recognizeDimIndex = function(e) {
      if (Yt(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0)) return +e;
    }, n.prototype._getStoreDimIndex = function(e) {
      var t = this.getDimensionIndex(e);
      return t;
    }, n.prototype.getDimensionInfo = function(e) {
      return this._getDimInfo(this.getDimension(e));
    }, n.prototype._initGetDimensionInfo = function(e) {
      var t = this._dimInfos;
      this._getDimInfo = e ? function(r) {
        return t.hasOwnProperty(r) ? t[r] : void 0;
      } : function(r) {
        return t[r];
      };
    }, n.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, n.prototype.mapDimension = function(e, t) {
      var r = this._dimSummary;
      if (t == null) return r.encodeFirstDimNotExtra[e];
      var i = r.encode[e];
      return i ? i[t] : null;
    }, n.prototype.mapDimensionsAll = function(e) {
      var t = this._dimSummary, r = t.encode[e];
      return (r || []).slice();
    }, n.prototype.getStore = function() {
      return this._store;
    }, n.prototype.initData = function(e, t, r) {
      var i = this, a;
      if (e instanceof JD && (a = e), !a) {
        var s = this.dimensions, o = fE(e) || Mi(e) ? new SX(e, s.length) : e;
        a = new JD();
        var l = xu(s, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        a.initData(o, l, r);
      }
      this._store = a, this._nameList = (t || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = Tfe(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, n.prototype.appendData = function(e) {
      var t = this._store.appendData(e);
      this._doInit(t[0], t[1]);
    }, n.prototype.appendValues = function(e, t) {
      var r = this._store.appendValues(e, t && t.length), i = r.start, a = r.end, s = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), t) for (var o = i; o < a; o++) {
        var l = o - i;
        this._nameList[o] = t[l], s && Nk(this, o);
      }
    }, n.prototype._updateOrdinalMeta = function() {
      for (var e = this._store, t = this.dimensions, r = 0; r < t.length; r++) {
        var i = this._dimInfos[t[r]];
        i.ordinalMeta && e.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, n.prototype._shouldMakeIdFromName = function() {
      var e = this._store.getProvider();
      return this._idDimIdx == null && e.getSource().sourceFormat !== Xu && !e.fillStorage;
    }, n.prototype._doInit = function(e, t) {
      if (!(e >= t)) {
        var r = this._store, i = r.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, s = this._idList, o = i.getSource().sourceFormat, l = o === ks;
        if (l && !i.pure) for (var u = [], c = e; c < t; c++) {
          var h = i.getItem(c, u);
          if (!this.hasItemOption && mle(h) && (this.hasItemOption = true), h) {
            var d = h.name;
            a[c] == null && d != null && (a[c] = kr(d, null));
            var f = h.id;
            s[c] == null && f != null && (s[c] = kr(f, null));
          }
        }
        if (this._shouldMakeIdFromName()) for (var c = e; c < t; c++) Nk(this, c);
        hB(this);
      }
    }, n.prototype.getApproximateExtent = function(e) {
      return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e));
    }, n.prototype.setApproximateExtent = function(e, t) {
      t = this.getDimension(t), this._approximateExtent[t] = e.slice();
    }, n.prototype.getCalculationInfo = function(e) {
      return this._calculationInfo[e];
    }, n.prototype.setCalculationInfo = function(e, t) {
      iy(e) ? oe(this._calculationInfo, e) : this._calculationInfo[e] = t;
    }, n.prototype.getName = function(e) {
      var t = this.getRawIndex(e), r = this._nameList[t];
      return r == null && this._nameDimIdx != null && (r = ay(this, this._nameDimIdx, t)), r == null && (r = ""), r;
    }, n.prototype._getCategory = function(e, t) {
      var r = this._store.get(e, t), i = this._store.getOrdinalMeta(e);
      return i ? i.categories[r] : r;
    }, n.prototype.getId = function(e) {
      return O1(this, this.getRawIndex(e));
    }, n.prototype.count = function() {
      return this._store.count();
    }, n.prototype.get = function(e, t) {
      var r = this._store, i = this._dimInfos[e];
      if (i) return r.get(i.storeDimIndex, t);
    }, n.prototype.getByRawIndex = function(e, t) {
      var r = this._store, i = this._dimInfos[e];
      if (i) return r.getByRawIndex(i.storeDimIndex, t);
    }, n.prototype.getIndices = function() {
      return this._store.getIndices();
    }, n.prototype.getDataExtent = function(e) {
      return this._store.getDataExtent(this._getStoreDimIndex(e));
    }, n.prototype.getSum = function(e) {
      return this._store.getSum(this._getStoreDimIndex(e));
    }, n.prototype.getMedian = function(e) {
      return this._store.getMedian(this._getStoreDimIndex(e));
    }, n.prototype.getValues = function(e, t) {
      var r = this, i = this._store;
      return de(e) ? i.getValues(xu(e, function(a) {
        return r._getStoreDimIndex(a);
      }), t) : i.getValues(e);
    }, n.prototype.hasValue = function(e) {
      for (var t = this._dimSummary.dataDimIndicesOnCoord, r = 0, i = t.length; r < i; r++) if (isNaN(this._store.get(t[r], e))) return false;
      return true;
    }, n.prototype.indexOfName = function(e) {
      for (var t = 0, r = this._store.count(); t < r; t++) if (this.getName(t) === e) return t;
      return -1;
    }, n.prototype.getRawIndex = function(e) {
      return this._store.getRawIndex(e);
    }, n.prototype.indexOfRawIndex = function(e) {
      return this._store.indexOfRawIndex(e);
    }, n.prototype.rawIndexOf = function(e, t) {
      var r = e && this._invertedIndicesMap[e], i = r && r[t];
      return i == null || isNaN(i) ? cB : i;
    }, n.prototype.indicesOfNearest = function(e, t, r) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(e), t, r);
    }, n.prototype.each = function(e, t, r) {
      Xe(e) && (r = t, t = e, e = []);
      var i = r || this, a = xu(sy(e), this._getStoreDimIndex, this);
      this._store.each(a, i ? Ae(t, i) : t);
    }, n.prototype.filterSelf = function(e, t, r) {
      Xe(e) && (r = t, t = e, e = []);
      var i = r || this, a = xu(sy(e), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, i ? Ae(t, i) : t), this;
    }, n.prototype.selectRange = function(e) {
      var t = this, r = {}, i = Mt(e);
      return P(i, function(a) {
        var s = t._getStoreDimIndex(a);
        r[s] = e[a];
      }), this._store = this._store.selectRange(r), this;
    }, n.prototype.mapArray = function(e, t, r) {
      Xe(e) && (r = t, t = e, e = []), r = r || this;
      var i = [];
      return this.each(e, function() {
        i.push(t && t.apply(this, arguments));
      }, r), i;
    }, n.prototype.map = function(e, t, r, i) {
      var a = r || i || this, s = xu(sy(e), this._getStoreDimIndex, this), o = oy(this);
      return o._store = this._store.map(s, a ? Ae(t, a) : t), o;
    }, n.prototype.modify = function(e, t, r, i) {
      var a = r || i || this, s = xu(sy(e), this._getStoreDimIndex, this);
      this._store.modify(s, a ? Ae(t, a) : t);
    }, n.prototype.downSample = function(e, t, r, i) {
      var a = oy(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(e), t, r, i), a;
    }, n.prototype.minmaxDownSample = function(e, t) {
      var r = oy(this);
      return r._store = this._store.minmaxDownSample(this._getStoreDimIndex(e), t), r;
    }, n.prototype.lttbDownSample = function(e, t) {
      var r = oy(this);
      return r._store = this._store.lttbDownSample(this._getStoreDimIndex(e), t), r;
    }, n.prototype.getRawDataItem = function(e) {
      return this._store.getRawDataItem(e);
    }, n.prototype.getItemModel = function(e) {
      var t = this.hostModel, r = this.getRawDataItem(e);
      return new on(r, t, t && t.ecModel);
    }, n.prototype.diff = function(e) {
      var t = this;
      return new ql(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(r) {
        return O1(e, r);
      }, function(r) {
        return O1(t, r);
      });
    }, n.prototype.getVisual = function(e) {
      var t = this._visual;
      return t && t[e];
    }, n.prototype.setVisual = function(e, t) {
      this._visual = this._visual || {}, iy(e) ? oe(this._visual, e) : this._visual[e] = t;
    }, n.prototype.getItemVisual = function(e, t) {
      var r = this._itemVisuals[e], i = r && r[t];
      return i ?? this.getVisual(t);
    }, n.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, n.prototype.ensureUniqueItemVisual = function(e, t) {
      var r = this._itemVisuals, i = r[e];
      i || (i = r[e] = {});
      var a = i[t];
      return a == null && (a = this.getVisual(t), de(a) ? a = a.slice() : iy(a) && (a = oe({}, a)), i[t] = a), a;
    }, n.prototype.setItemVisual = function(e, t, r) {
      var i = this._itemVisuals[e] || {};
      this._itemVisuals[e] = i, iy(t) ? oe(i, t) : i[t] = r;
    }, n.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, n.prototype.setLayout = function(e, t) {
      iy(e) ? oe(this._layout, e) : this._layout[e] = t;
    }, n.prototype.getLayout = function(e) {
      return this._layout[e];
    }, n.prototype.getItemLayout = function(e) {
      return this._itemLayouts[e];
    }, n.prototype.setItemLayout = function(e, t, r) {
      this._itemLayouts[e] = r ? oe(this._itemLayouts[e] || {}, t) : t;
    }, n.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, n.prototype.setItemGraphicEl = function(e, t) {
      var r = this.hostModel && this.hostModel.seriesIndex;
      zD(r, this.dataType, e, t), this._graphicEls[e] = t;
    }, n.prototype.getItemGraphicEl = function(e) {
      return this._graphicEls[e];
    }, n.prototype.eachItemGraphicEl = function(e, t) {
      P(this._graphicEls, function(r, i) {
        r && e && e.call(t, r, i);
      });
    }, n.prototype.cloneShallow = function(e) {
      return e || (e = new n(this._schema ? this._schema : xu(this.dimensions, this._getDimInfo, this), this.hostModel)), $k(e, this), e._store = this._store, e;
    }, n.prototype.wrapMethod = function(e, t) {
      var r = this[e];
      Xe(r) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function() {
        var i = r.apply(this, arguments);
        return t.apply(this, [
          i
        ].concat(EN(arguments)));
      });
    }, n.internalField = function() {
      hB = function(e) {
        var t = e._invertedIndicesMap;
        P(t, function(r, i) {
          var a = e._dimInfos[i], s = a.ordinalMeta, o = e._store;
          if (s) {
            r = t[i] = new $fe(s.categories.length);
            for (var l = 0; l < r.length; l++) r[l] = cB;
            for (var l = 0; l < o.count(); l++) r[o.get(a.storeDimIndex, l)] = l;
          }
        });
      }, ay = function(e, t, r) {
        return kr(e._getCategory(t, r), null);
      }, O1 = function(e, t) {
        var r = e._idList[t];
        return r == null && e._idDimIdx != null && (r = ay(e, e._idDimIdx, t)), r == null && (r = Nfe + t), r;
      }, sy = function(e) {
        return de(e) || (e = e != null ? [
          e
        ] : []), e;
      }, oy = function(e) {
        var t = new n(e._schema ? e._schema : xu(e.dimensions, e._getDimInfo, e), e.hostModel);
        return $k(t, e), t;
      }, $k = function(e, t) {
        P(Efe.concat(t.__wrappedMethods || []), function(r) {
          t.hasOwnProperty(r) && (e[r] = t[r]);
        }), e.__wrappedMethods = t.__wrappedMethods, P(Mfe, function(r) {
          e[r] = Qe(t[r]);
        }), e._calculationInfo = oe({}, t._calculationInfo);
      }, Nk = function(e, t) {
        var r = e._nameList, i = e._idList, a = e._nameDimIdx, s = e._idDimIdx, o = r[t], l = i[t];
        if (o == null && a != null && (r[t] = o = ay(e, a, t)), l == null && s != null && (i[t] = l = ay(e, s, t)), l == null && o != null) {
          var u = e._nameRepeatCount, c = u[o] = (u[o] || 0) + 1;
          l = o, c > 1 && (l += "__ec__" + c), i[t] = l;
        }
      };
    }(), n;
  }();
  function zx(n, e) {
    fE(n) || (n = pE(n)), e = e || {};
    var t = e.coordDimensions || [], r = e.dimensionsDefine || n.dimensionsDefine || [], i = Pe(), a = [], s = Lfe(n, t, r, e.dimensionsCount), o = e.canOmitUnusedDimensions && CY(s), l = r === n.dimensionsDefine, u = l ? SY(n) : _Y(r), c = e.encodeDefine;
    !c && e.encodeDefaulter && (c = e.encodeDefaulter(n, s));
    for (var h = Pe(c), d = new $X(s), f = 0; f < d.length; f++) d[f] = -1;
    function p(C) {
      var T = d[C];
      if (T < 0) {
        var k = r[C], D = Ze(k) ? k : {
          name: k
        }, R = new l_(), N = D.name;
        N != null && u.get(N) != null && (R.name = R.displayName = N), D.type != null && (R.type = D.type), D.displayName != null && (R.displayName = D.displayName);
        var E = a.length;
        return d[C] = E, R.storeDimIndex = C, a.push(R), R;
      }
      return a[T];
    }
    if (!o) for (var f = 0; f < s; f++) p(f);
    h.each(function(C, T) {
      var k = xn(C).slice();
      if (k.length === 1 && !Ie(k[0]) && k[0] < 0) {
        h.set(T, false);
        return;
      }
      var D = h.set(T, []);
      P(k, function(R, N) {
        var E = Ie(R) ? u.get(R) : R;
        E != null && E < s && (D[N] = E, m(p(E), T, N));
      });
    });
    var g = 0;
    P(t, function(C) {
      var T, k, D, R;
      if (Ie(C)) T = C, R = {};
      else {
        R = C, T = R.name;
        var N = R.ordinalMeta;
        R.ordinalMeta = null, R = oe({}, R), R.ordinalMeta = N, k = R.dimsDef, D = R.otherDims, R.name = R.coordDim = R.coordDimIndex = R.dimsDef = R.otherDims = null;
      }
      var E = h.get(T);
      if (E !== false) {
        if (E = xn(E), !E.length) for (var A = 0; A < (k && k.length || 1); A++) {
          for (; g < s && p(g).coordDim != null; ) g++;
          g < s && E.push(g++);
        }
        P(E, function(M, $) {
          var L = p(M);
          if (l && R.type != null && (L.type = R.type), m(je(L, R), T, $), L.name == null && k) {
            var F = k[$];
            !Ze(F) && (F = {
              name: F
            }), L.name = L.displayName = F.name, L.defaultTooltip = F.defaultTooltip;
          }
          D && je(L.otherDims, D);
        });
      }
    });
    function m(C, T, k) {
      hX.get(T) != null ? C.otherDims[T] = k : (C.coordDim = T, C.coordDimIndex = k, i.set(T, true));
    }
    var v = e.generateCoord, y = e.generateCoordCount, x = y != null;
    y = v ? y || 1 : 0;
    var b = v || "value";
    function w(C) {
      C.name == null && (C.name = C.coordDim);
    }
    if (o) P(a, function(C) {
      w(C);
    }), a.sort(function(C, T) {
      return C.storeDimIndex - T.storeDimIndex;
    });
    else for (var _ = 0; _ < s; _++) {
      var S = p(_), I = S.coordDim;
      I == null && (S.coordDim = Ffe(b, i, x), S.coordDimIndex = 0, (!v || y <= 0) && (S.isExtraCoord = true), y--), w(S), S.type == null && (gX(n, _) === ci.Must || S.isExtraCoord && (S.otherDims.itemName != null || S.otherDims.seriesName != null)) && (S.type = "ordinal");
    }
    return Pfe(a), new bY({
      source: n,
      dimensions: a,
      fullDimensionCount: s,
      dimensionOmitted: o
    });
  }
  function Pfe(n) {
    for (var e = Pe(), t = 0; t < n.length; t++) {
      var r = n[t], i = r.name, a = e.get(i) || 0;
      a > 0 && (r.name = i + (a - 1)), a++, e.set(i, a);
    }
  }
  function Lfe(n, e, t, r) {
    var i = Math.max(n.dimensionsDetectedCount || 1, e.length, t.length, r || 0);
    return P(e, function(a) {
      var s;
      Ze(a) && (s = a.dimsDef) && (i = Math.max(i, s.length));
    }), i;
  }
  function Ffe(n, e, t) {
    if (t || e.hasKey(n)) {
      for (var r = 0; e.hasKey(n + r); ) r++;
      n += r;
    }
    return e.set(n, true), n;
  }
  var Ofe = /* @__PURE__ */ function() {
    function n(e) {
      this.coordSysDims = [], this.axisMap = Pe(), this.categoryAxisMap = Pe(), this.coordSysName = e;
    }
    return n;
  }();
  function Bfe(n) {
    var e = n.get("coordinateSystem"), t = new Ofe(e), r = zfe[e];
    if (r) return r(n, t, t.axisMap, t.categoryAxisMap), t;
  }
  var zfe = {
    cartesian2d: function(n, e, t, r) {
      var i = n.getReferringComponents("xAxis", yr).models[0], a = n.getReferringComponents("yAxis", yr).models[0];
      e.coordSysDims = [
        "x",
        "y"
      ], t.set("x", i), t.set("y", a), Lp(i) && (r.set("x", i), e.firstCategoryDimIndex = 0), Lp(a) && (r.set("y", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
    },
    singleAxis: function(n, e, t, r) {
      var i = n.getReferringComponents("singleAxis", yr).models[0];
      e.coordSysDims = [
        "single"
      ], t.set("single", i), Lp(i) && (r.set("single", i), e.firstCategoryDimIndex = 0);
    },
    polar: function(n, e, t, r) {
      var i = n.getReferringComponents("polar", yr).models[0], a = i.findAxisModel("radiusAxis"), s = i.findAxisModel("angleAxis");
      e.coordSysDims = [
        "radius",
        "angle"
      ], t.set("radius", a), t.set("angle", s), Lp(a) && (r.set("radius", a), e.firstCategoryDimIndex = 0), Lp(s) && (r.set("angle", s), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
    },
    geo: function(n, e, t, r) {
      e.coordSysDims = [
        "lng",
        "lat"
      ];
    },
    parallel: function(n, e, t, r) {
      var i = n.ecModel, a = i.getComponent("parallel", n.get("parallelIndex")), s = e.coordSysDims = a.dimensions.slice();
      P(a.parallelAxisIndex, function(o, l) {
        var u = i.getComponent("parallelAxis", o), c = s[l];
        t.set(c, u), Lp(u) && (r.set(c, u), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l));
      });
    }
  };
  function Lp(n) {
    return n.get("type") === "category";
  }
  function Vfe(n, e, t) {
    t = t || {};
    var r = t.byIndex, i = t.stackedCoordDimension, a, s, o;
    Wfe(e) ? a = e : (s = e.schema, a = s.dimensions, o = e.store);
    var l = !!(n && n.get("stack")), u, c, h, d;
    if (P(a, function(y, x) {
      Ie(y) && (a[x] = y = {
        name: y
      }), l && !y.isExtraCoord && (!r && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
    }), c && !r && !u && (r = true), c) {
      h = "__\0ecstackresult_" + n.id, d = "__\0ecstackedover_" + n.id, u && (u.createInvertedIndices = true);
      var f = c.coordDim, p = c.type, g = 0;
      P(a, function(y) {
        y.coordDim === f && g++;
      });
      var m = {
        name: h,
        coordDim: f,
        coordDimIndex: g,
        type: p,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: a.length
      }, v = {
        name: d,
        coordDim: d,
        coordDimIndex: g + 1,
        type: p,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: a.length + 1
      };
      s ? (o && (m.storeDimIndex = o.ensureCalculationDimension(d, p), v.storeDimIndex = o.ensureCalculationDimension(h, p)), s.appendCalculationDimension(m), s.appendCalculationDimension(v)) : (a.push(m), a.push(v));
    }
    return {
      stackedDimension: c && c.name,
      stackedByDimension: u && u.name,
      isStackedByIndex: r,
      stackedOverDimension: d,
      stackResultDimension: h
    };
  }
  function Wfe(n) {
    return !wY(n.schema);
  }
  function ic(n, e) {
    return !!e && e === n.getCalculationInfo("stackedDimension");
  }
  function IY(n, e) {
    return ic(n, e) ? n.getCalculationInfo("stackResultDimension") : e;
  }
  function Gfe(n, e) {
    var t = n.get("coordinateSystem"), r = Ox.get(t), i;
    return e && e.coordSysDims && (i = me(e.coordSysDims, function(a) {
      var s = {
        name: a
      }, o = e.axisMap.get(a);
      if (o) {
        var l = o.get("type");
        s.type = J_(l);
      }
      return s;
    })), i || (i = r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || [
      "x",
      "y"
    ]), i;
  }
  function Ufe(n, e, t) {
    var r, i;
    return t && P(n, function(a, s) {
      var o = a.coordDim, l = t.categoryAxisMap.get(o);
      l && (r == null && (r = s), a.ordinalMeta = l.getOrdinalMeta(), e && (a.createInvertedIndices = true)), a.otherDims.itemName != null && (i = true);
    }), !i && r != null && (n[r].otherDims.itemName = 0), r;
  }
  function au(n, e, t) {
    t = t || {};
    var r = e.getSourceManager(), i, a = false;
    n ? (a = true, i = pE(n)) : (i = r.getSource(), a = i.sourceFormat === ks);
    var s = Bfe(e), o = Gfe(e, s), l = t.useEncodeDefaulter, u = Xe(l) ? l : l ? lt(pX, o, e) : null, c = {
      coordDimensions: o,
      generateCoord: t.generateCoord,
      encodeDefine: e.getEncode(),
      encodeDefaulter: u,
      canOmitUnusedDimensions: !a
    }, h = zx(i, c), d = Ufe(h.dimensions, t.createInvertedIndices, s), f = a ? null : r.getSharedDataStore(h), p = Vfe(e, {
      schema: h,
      store: f
    }), g = new Ki(h, e);
    g.setCalculationInfo(p);
    var m = d != null && Hfe(i) ? function(v, y, x, b) {
      return b === d ? x : this.defaultDimValueGetter(v, y, x, b);
    } : null;
    return g.hasItemOption = false, g.initData(a ? i : f, null, m), g;
  }
  function Hfe(n) {
    if (n.sourceFormat === ks) {
      var e = Xfe(n.data || []);
      return !de(pm(e));
    }
  }
  function Xfe(n) {
    for (var e = 0; e < n.length && n[e] == null; ) e++;
    return n[e];
  }
  var hl = function() {
    function n(e) {
      this._setting = e || {}, this._extent = [
        1 / 0,
        -1 / 0
      ];
    }
    return n.prototype.getSetting = function(e) {
      return this._setting[e];
    }, n.prototype.unionExtent = function(e) {
      var t = this._extent;
      e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]);
    }, n.prototype.unionExtentFromData = function(e, t) {
      this.unionExtent(e.getApproximateExtent(t));
    }, n.prototype.getExtent = function() {
      return this._extent.slice();
    }, n.prototype.setExtent = function(e, t) {
      var r = this._extent;
      isNaN(e) || (r[0] = e), isNaN(t) || (r[1] = t);
    }, n.prototype.isInExtentRange = function(e) {
      return this._extent[0] <= e && this._extent[1] >= e;
    }, n.prototype.isBlank = function() {
      return this._isBlank;
    }, n.prototype.setBlank = function(e) {
      this._isBlank = e;
    }, n;
  }();
  mC(hl);
  var Yfe = 0, uR = function() {
    function n(e) {
      this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++Yfe;
    }
    return n.createByAxisModel = function(e) {
      var t = e.option, r = t.data, i = r && me(r, qfe);
      return new n({
        categories: i,
        needCollect: !i,
        deduplication: t.dedplication !== false
      });
    }, n.prototype.getOrdinal = function(e) {
      return this._getOrCreateMap().get(e);
    }, n.prototype.parseAndCollect = function(e) {
      var t, r = this._needCollect;
      if (!Ie(e) && !r) return e;
      if (r && !this._deduplication) return t = this.categories.length, this.categories[t] = e, t;
      var i = this._getOrCreateMap();
      return t = i.get(e), t == null && (r ? (t = this.categories.length, this.categories[t] = e, i.set(e, t)) : t = NaN), t;
    }, n.prototype._getOrCreateMap = function() {
      return this._map || (this._map = Pe(this.categories));
    }, n;
  }();
  function qfe(n) {
    return Ze(n) && n.value != null ? n.value : n + "";
  }
  function cR(n) {
    return n.type === "interval" || n.type === "log";
  }
  function jfe(n, e, t, r) {
    var i = {}, a = n[1] - n[0], s = i.interval = J6(a / e);
    t != null && s < t && (s = i.interval = t), r != null && s > r && (s = i.interval = r);
    var o = i.intervalPrecision = kY(s), l = i.niceTickExtent = [
      rr(Math.ceil(n[0] / s) * s, o),
      rr(Math.floor(n[1] / s) * s, o)
    ];
    return Kfe(l, n), i;
  }
  function Ek(n) {
    var e = Math.pow(10, VN(n)), t = n / e;
    return t ? t === 2 ? t = 3 : t === 3 ? t = 5 : t *= 2 : t = 1, rr(t * e);
  }
  function kY(n) {
    return Oo(n) + 2;
  }
  function dB(n, e, t) {
    n[e] = Math.max(Math.min(n[e], t[1]), t[0]);
  }
  function Kfe(n, e) {
    !isFinite(n[0]) && (n[0] = e[0]), !isFinite(n[1]) && (n[1] = e[1]), dB(n, 0, e), dB(n, 1, e), n[0] > n[1] && (n[0] = n[1]);
  }
  function FC(n, e) {
    return n >= e[0] && n <= e[1];
  }
  function OC(n, e) {
    return e[1] === e[0] ? 0.5 : (n - e[0]) / (e[1] - e[0]);
  }
  function BC(n, e) {
    return n * (e[1] - e[0]) + e[0];
  }
  var zC = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      r.type = "ordinal";
      var i = r.getSetting("ordinalMeta");
      return i || (i = new uR({})), de(i) && (i = new uR({
        categories: me(i, function(a) {
          return Ze(a) ? a.value : a;
        })
      })), r._ordinalMeta = i, r._extent = r.getSetting("extent") || [
        0,
        i.categories.length - 1
      ], r;
    }
    return e.prototype.parse = function(t) {
      return t == null ? NaN : Ie(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
    }, e.prototype.contain = function(t) {
      return t = this.parse(t), FC(t, this._extent) && this._ordinalMeta.categories[t] != null;
    }, e.prototype.normalize = function(t) {
      return t = this._getTickNumber(this.parse(t)), OC(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = Math.round(BC(t, this._extent)), this.getRawOrdinalNumber(t);
    }, e.prototype.getTicks = function() {
      for (var t = [], r = this._extent, i = r[0]; i <= r[1]; ) t.push({
        value: i
      }), i++;
      return t;
    }, e.prototype.getMinorTicks = function(t) {
    }, e.prototype.setSortInfo = function(t) {
      if (t == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var r = t.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], s = 0, o = this._ordinalMeta.categories.length, l = Math.min(o, r.length); s < l; ++s) {
        var u = r[s];
        i[s] = u, a[u] = s;
      }
      for (var c = 0; s < o; ++s) {
        for (; a[c] != null; ) c++;
        i.push(c), a[c] = s;
      }
    }, e.prototype._getTickNumber = function(t) {
      var r = this._ticksByOrdinalNumber;
      return r && t >= 0 && t < r.length ? r[t] : t;
    }, e.prototype.getRawOrdinalNumber = function(t) {
      var r = this._ordinalNumbersByTick;
      return r && t >= 0 && t < r.length ? r[t] : t;
    }, e.prototype.getLabel = function(t) {
      if (!this.isBlank()) {
        var r = this.getRawOrdinalNumber(t.value), i = this._ordinalMeta.categories[r];
        return i == null ? "" : i + "";
      }
    }, e.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, e.prototype.unionExtentFromData = function(t, r) {
      this.unionExtent(t.getApproximateExtent(r));
    }, e.prototype.isInExtentRange = function(t) {
      return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, e.prototype.calcNiceTicks = function() {
    }, e.prototype.calcNiceExtent = function() {
    }, e.type = "ordinal", e;
  }(hl);
  hl.registerClass(zC);
  var ih = rr, jl = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t;
    }
    return e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return FC(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return OC(t, this._extent);
    }, e.prototype.scale = function(t) {
      return BC(t, this._extent);
    }, e.prototype.setExtent = function(t, r) {
      var i = this._extent;
      isNaN(t) || (i[0] = parseFloat(t)), isNaN(r) || (i[1] = parseFloat(r));
    }, e.prototype.unionExtent = function(t) {
      var r = this._extent;
      t[0] < r[0] && (r[0] = t[0]), t[1] > r[1] && (r[1] = t[1]), this.setExtent(r[0], r[1]);
    }, e.prototype.getInterval = function() {
      return this._interval;
    }, e.prototype.setInterval = function(t) {
      this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = kY(t);
    }, e.prototype.getTicks = function(t) {
      var r = this._interval, i = this._extent, a = this._niceExtent, s = this._intervalPrecision, o = [];
      if (!r) return o;
      var l = 1e4;
      i[0] < a[0] && (t ? o.push({
        value: ih(a[0] - r, s)
      }) : o.push({
        value: i[0]
      }));
      for (var u = a[0]; u <= a[1] && (o.push({
        value: u
      }), u = ih(u + r, s), u !== o[o.length - 1].value); ) if (o.length > l) return [];
      var c = o.length ? o[o.length - 1].value : a[1];
      return i[1] > c && (t ? o.push({
        value: ih(c + r, s)
      }) : o.push({
        value: i[1]
      })), o;
    }, e.prototype.getMinorTicks = function(t) {
      for (var r = this.getTicks(true), i = [], a = this.getExtent(), s = 1; s < r.length; s++) {
        for (var o = r[s], l = r[s - 1], u = 0, c = [], h = o.value - l.value, d = h / t; u < t - 1; ) {
          var f = ih(l.value + (u + 1) * d);
          f > a[0] && f < a[1] && c.push(f), u++;
        }
        i.push(c);
      }
      return i;
    }, e.prototype.getLabel = function(t, r) {
      if (t == null) return "";
      var i = r && r.precision;
      i == null ? i = Oo(t.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var a = ih(t.value, i, true);
      return aX(a);
    }, e.prototype.calcNiceTicks = function(t, r, i) {
      t = t || 5;
      var a = this._extent, s = a[1] - a[0];
      if (isFinite(s)) {
        s < 0 && (s = -s, a.reverse());
        var o = jfe(a, t, r, i);
        this._intervalPrecision = o.intervalPrecision, this._interval = o.interval, this._niceExtent = o.niceTickExtent;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      var r = this._extent;
      if (r[0] === r[1]) if (r[0] !== 0) {
        var i = Math.abs(r[0]);
        t.fixMax || (r[1] += i / 2), r[0] -= i / 2;
      } else r[1] = 1;
      var a = r[1] - r[0];
      isFinite(a) || (r[0] = 0, r[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
      var s = this._interval;
      t.fixMin || (r[0] = ih(Math.floor(r[0] / s) * s)), t.fixMax || (r[1] = ih(Math.ceil(r[1] / s) * s));
    }, e.prototype.setNiceExtent = function(t, r) {
      this._niceExtent = [
        t,
        r
      ];
    }, e.type = "interval", e;
  }(hl);
  hl.registerClass(jl);
  var TY = typeof Float32Array < "u", Zfe = TY ? Float32Array : Array;
  function zo(n) {
    return de(n) ? TY ? new Float32Array(n) : n : new Zfe(n);
  }
  var hR = "__ec_stack_";
  function AY(n) {
    return n.get("stack") || hR + n.seriesIndex;
  }
  function IE(n) {
    return n.dim + n.index;
  }
  function Qfe(n) {
    var e = [], t = n.axis, r = "axis0";
    if (t.type === "category") {
      for (var i = t.getBandWidth(), a = 0; a < n.count; a++) e.push(je({
        bandWidth: i,
        axisKey: r,
        stackId: hR + a
      }, n));
      for (var s = $Y(e), o = [], a = 0; a < n.count; a++) {
        var l = s[r][hR + a];
        l.offsetCenter = l.offset + l.width / 2, o.push(l);
      }
      return o;
    }
  }
  function DY(n, e) {
    var t = [];
    return e.eachSeriesByType(n, function(r) {
      MY(r) && t.push(r);
    }), t;
  }
  function Jfe(n) {
    var e = {};
    P(n, function(l) {
      var u = l.coordinateSystem, c = u.getBaseAxis();
      if (!(c.type !== "time" && c.type !== "value")) for (var h = l.getData(), d = c.dim + "_" + c.index, f = h.getDimensionIndex(h.mapDimension(c.dim)), p = h.getStore(), g = 0, m = p.count(); g < m; ++g) {
        var v = p.get(f, g);
        e[d] ? e[d].push(v) : e[d] = [
          v
        ];
      }
    });
    var t = {};
    for (var r in e) if (e.hasOwnProperty(r)) {
      var i = e[r];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, s = 1; s < i.length; ++s) {
          var o = i[s] - i[s - 1];
          o > 0 && (a = a === null ? o : Math.min(a, o));
        }
        t[r] = a;
      }
    }
    return t;
  }
  function RY(n) {
    var e = Jfe(n), t = [];
    return P(n, function(r) {
      var i = r.coordinateSystem, a = i.getBaseAxis(), s = a.getExtent(), o;
      if (a.type === "category") o = a.getBandWidth();
      else if (a.type === "value" || a.type === "time") {
        var l = a.dim + "_" + a.index, u = e[l], c = Math.abs(s[1] - s[0]), h = a.scale.getExtent(), d = Math.abs(h[1] - h[0]);
        o = u ? c / d * u : c;
      } else {
        var f = r.getData();
        o = Math.abs(s[1] - s[0]) / f.count();
      }
      var p = _e(r.get("barWidth"), o), g = _e(r.get("barMaxWidth"), o), m = _e(r.get("barMinWidth") || (PY(r) ? 0.5 : 1), o), v = r.get("barGap"), y = r.get("barCategoryGap");
      t.push({
        bandWidth: o,
        barWidth: p,
        barMaxWidth: g,
        barMinWidth: m,
        barGap: v,
        barCategoryGap: y,
        axisKey: IE(a),
        stackId: AY(r)
      });
    }), $Y(t);
  }
  function $Y(n) {
    var e = {};
    P(n, function(r, i) {
      var a = r.axisKey, s = r.bandWidth, o = e[a] || {
        bandWidth: s,
        remainedWidth: s,
        autoWidthCount: 0,
        categoryGap: null,
        gap: "20%",
        stacks: {}
      }, l = o.stacks;
      e[a] = o;
      var u = r.stackId;
      l[u] || o.autoWidthCount++, l[u] = l[u] || {
        width: 0,
        maxWidth: 0
      };
      var c = r.barWidth;
      c && !l[u].width && (l[u].width = c, c = Math.min(o.remainedWidth, c), o.remainedWidth -= c);
      var h = r.barMaxWidth;
      h && (l[u].maxWidth = h);
      var d = r.barMinWidth;
      d && (l[u].minWidth = d);
      var f = r.barGap;
      f != null && (o.gap = f);
      var p = r.barCategoryGap;
      p != null && (o.categoryGap = p);
    });
    var t = {};
    return P(e, function(r, i) {
      t[i] = {};
      var a = r.stacks, s = r.bandWidth, o = r.categoryGap;
      if (o == null) {
        var l = Mt(a).length;
        o = Math.max(35 - l * 4, 15) + "%";
      }
      var u = _e(o, s), c = _e(r.gap, 1), h = r.remainedWidth, d = r.autoWidthCount, f = (h - u) / (d + (d - 1) * c);
      f = Math.max(f, 0), P(a, function(v) {
        var y = v.maxWidth, x = v.minWidth;
        if (v.width) {
          var b = v.width;
          y && (b = Math.min(b, y)), x && (b = Math.max(b, x)), v.width = b, h -= b + c * b, d--;
        } else {
          var b = f;
          y && y < b && (b = Math.min(y, h)), x && x > b && (b = x), b !== f && (v.width = b, h -= b + c * b, d--);
        }
      }), f = (h - u) / (d + (d - 1) * c), f = Math.max(f, 0);
      var p = 0, g;
      P(a, function(v, y) {
        v.width || (v.width = f), g = v, p += v.width * (1 + c);
      }), g && (p -= g.width * c);
      var m = -p / 2;
      P(a, function(v, y) {
        t[i][y] = t[i][y] || {
          bandWidth: s,
          offset: m,
          width: v.width
        }, m += v.width * (1 + c);
      });
    }), t;
  }
  function epe(n, e, t) {
    if (n && e) {
      var r = n[IE(e)];
      return r;
    }
  }
  function NY(n, e) {
    var t = DY(n, e), r = RY(t);
    P(t, function(i) {
      var a = i.getData(), s = i.coordinateSystem, o = s.getBaseAxis(), l = AY(i), u = r[IE(o)][l], c = u.offset, h = u.width;
      a.setLayout({
        bandWidth: u.bandWidth,
        offset: c,
        size: h
      });
    });
  }
  function EY(n) {
    return {
      seriesType: n,
      plan: _m(),
      reset: function(e) {
        if (MY(e)) {
          var t = e.getData(), r = e.coordinateSystem, i = r.getBaseAxis(), a = r.getOtherAxis(i), s = t.getDimensionIndex(t.mapDimension(a.dim)), o = t.getDimensionIndex(t.mapDimension(i.dim)), l = e.get("showBackground", true), u = t.mapDimension(a.dim), c = t.getCalculationInfo("stackResultDimension"), h = ic(t, u) && !!t.getCalculationInfo("stackedOnSeries"), d = a.isHorizontal(), f = tpe(i, a), p = PY(e), g = e.get("barMinHeight") || 0, m = c && t.getDimensionIndex(c), v = t.getLayout("size"), y = t.getLayout("offset");
          return {
            progress: function(x, b) {
              for (var w = x.count, _ = p && zo(w * 3), S = p && l && zo(w * 3), I = p && zo(w), C = r.master.getRect(), T = d ? C.width : C.height, k, D = b.getStore(), R = 0; (k = x.next()) != null; ) {
                var N = D.get(h ? m : s, k), E = D.get(o, k), A = f, M = void 0;
                h && (M = +N - D.get(s, k));
                var $ = void 0, L = void 0, F = void 0, O = void 0;
                if (d) {
                  var z = r.dataToPoint([
                    N,
                    E
                  ]);
                  if (h) {
                    var V = r.dataToPoint([
                      M,
                      E
                    ]);
                    A = V[0];
                  }
                  $ = A, L = z[1] + y, F = z[0] - A, O = v, Math.abs(F) < g && (F = (F < 0 ? -1 : 1) * g);
                } else {
                  var z = r.dataToPoint([
                    E,
                    N
                  ]);
                  if (h) {
                    var V = r.dataToPoint([
                      E,
                      M
                    ]);
                    A = V[1];
                  }
                  $ = z[0] + y, L = A, F = v, O = z[1] - A, Math.abs(O) < g && (O = (O <= 0 ? -1 : 1) * g);
                }
                p ? (_[R] = $, _[R + 1] = L, _[R + 2] = d ? F : O, S && (S[R] = d ? C.x : $, S[R + 1] = d ? L : C.y, S[R + 2] = T), I[k] = k) : b.setItemLayout(k, {
                  x: $,
                  y: L,
                  width: F,
                  height: O
                }), R += 3;
              }
              p && b.setLayout({
                largePoints: _,
                largeDataIndices: I,
                largeBackgroundPoints: S,
                valueAxisHorizontal: d
              });
            }
          };
        }
      }
    };
  }
  function MY(n) {
    return n.coordinateSystem && n.coordinateSystem.type === "cartesian2d";
  }
  function PY(n) {
    return n.pipelineContext && n.pipelineContext.large;
  }
  function tpe(n, e) {
    var t = e.model.get("startValue");
    return t || (t = 0), e.toGlobalCoord(e.dataToCoord(e.type === "log" ? t > 0 ? t : 1 : t));
  }
  var npe = function(n, e, t, r) {
    for (; t < r; ) {
      var i = t + r >>> 1;
      n[i][1] < e ? t = i + 1 : r = i;
    }
    return t;
  }, kE = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "time", r;
    }
    return e.prototype.getLabel = function(t) {
      var r = this.getSetting("useUTC");
      return TC(t.value, nO[Lce(Cg(this._minLevelUnit))] || nO.second, r, this.getSetting("locale"));
    }, e.prototype.getFormattedLabel = function(t, r, i) {
      var a = this.getSetting("useUTC"), s = this.getSetting("locale");
      return Fce(t, r, i, s, a);
    }, e.prototype.getTicks = function() {
      var t = this._interval, r = this._extent, i = [];
      if (!t) return i;
      i.push({
        value: r[0],
        level: 0
      });
      var a = this.getSetting("useUTC"), s = upe(this._minLevelUnit, this._approxInterval, a, r);
      return i = i.concat(s), i.push({
        value: r[1],
        level: 0
      }), i;
    }, e.prototype.calcNiceExtent = function(t) {
      var r = this._extent;
      if (r[0] === r[1] && (r[0] -= gs, r[1] += gs), r[1] === -1 / 0 && r[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        r[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), r[0] = r[1] - gs;
      }
      this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
    }, e.prototype.calcNiceTicks = function(t, r, i) {
      t = t || 10;
      var a = this._extent, s = a[1] - a[0];
      this._approxInterval = s / t, r != null && this._approxInterval < r && (this._approxInterval = r), i != null && this._approxInterval > i && (this._approxInterval = i);
      var o = B1.length, l = Math.min(npe(B1, this._approxInterval, 0, o), o - 1);
      this._interval = B1[l][1], this._minLevelUnit = B1[Math.max(l - 1, 0)][0];
    }, e.prototype.parse = function(t) {
      return Yt(t) ? t : +tl(t);
    }, e.prototype.contain = function(t) {
      return FC(this.parse(t), this._extent);
    }, e.prototype.normalize = function(t) {
      return OC(this.parse(t), this._extent);
    }, e.prototype.scale = function(t) {
      return BC(t, this._extent);
    }, e.type = "time", e;
  }(jl), B1 = [
    [
      "second",
      aE
    ],
    [
      "minute",
      sE
    ],
    [
      "hour",
      l0
    ],
    [
      "quarter-day",
      l0 * 6
    ],
    [
      "half-day",
      l0 * 12
    ],
    [
      "day",
      gs * 1.2
    ],
    [
      "half-week",
      gs * 3.5
    ],
    [
      "week",
      gs * 7
    ],
    [
      "month",
      gs * 31
    ],
    [
      "quarter",
      gs * 95
    ],
    [
      "half-year",
      tO / 2
    ],
    [
      "year",
      tO
    ]
  ];
  function rpe(n, e, t, r) {
    var i = tl(e), a = tl(t), s = function(p) {
      return rO(i, p, r) === rO(a, p, r);
    }, o = function() {
      return s("year");
    }, l = function() {
      return o() && s("month");
    }, u = function() {
      return l() && s("day");
    }, c = function() {
      return u() && s("hour");
    }, h = function() {
      return c() && s("minute");
    }, d = function() {
      return h() && s("second");
    }, f = function() {
      return d() && s("millisecond");
    };
    switch (n) {
      case "year":
        return o();
      case "month":
        return l();
      case "day":
        return u();
      case "hour":
        return c();
      case "minute":
        return h();
      case "second":
        return d();
      case "millisecond":
        return f();
    }
  }
  function ipe(n, e) {
    return n /= gs, n > 16 ? 16 : n > 7.5 ? 7 : n > 3.5 ? 4 : n > 1.5 ? 2 : 1;
  }
  function ape(n) {
    var e = 30 * gs;
    return n /= e, n > 6 ? 6 : n > 3 ? 3 : n > 2 ? 2 : 1;
  }
  function spe(n) {
    return n /= l0, n > 12 ? 12 : n > 6 ? 6 : n > 3.5 ? 4 : n > 2 ? 2 : 1;
  }
  function fB(n, e) {
    return n /= e ? sE : aE, n > 30 ? 30 : n > 20 ? 20 : n > 15 ? 15 : n > 10 ? 10 : n > 5 ? 5 : n > 2 ? 2 : 1;
  }
  function ope(n) {
    return J6(n);
  }
  function lpe(n, e, t) {
    var r = new Date(n);
    switch (Cg(e)) {
      case "year":
      case "month":
        r[J8(t)](0);
      case "day":
        r[eX(t)](1);
      case "hour":
        r[tX(t)](0);
      case "minute":
        r[nX(t)](0);
      case "second":
        r[rX(t)](0), r[iX(t)](0);
    }
    return r.getTime();
  }
  function upe(n, e, t, r) {
    var i = 1e4, a = Z8, s = 0;
    function o(T, k, D, R, N, E, A) {
      for (var M = new Date(k), $ = k, L = M[R](); $ < D && $ <= r[1]; ) A.push({
        value: $
      }), L += T, M[N](L), $ = M.getTime();
      A.push({
        value: $,
        notAdd: true
      });
    }
    function l(T, k, D) {
      var R = [], N = !k.length;
      if (!rpe(Cg(T), r[0], r[1], t)) {
        N && (k = [
          {
            value: lpe(new Date(r[0]), T, t)
          },
          {
            value: r[1]
          }
        ]);
        for (var E = 0; E < k.length - 1; E++) {
          var A = k[E].value, M = k[E + 1].value;
          if (A !== M) {
            var $ = void 0, L = void 0, F = void 0, O = false;
            switch (T) {
              case "year":
                $ = Math.max(1, Math.round(e / gs / 365)), L = oE(t), F = Oce(t);
                break;
              case "half-year":
              case "quarter":
              case "month":
                $ = ape(e), L = Ig(t), F = J8(t);
                break;
              case "week":
              case "half-week":
              case "day":
                $ = ipe(e), L = AC(t), F = eX(t), O = true;
                break;
              case "half-day":
              case "quarter-day":
              case "hour":
                $ = spe(e), L = M0(t), F = tX(t);
                break;
              case "minute":
                $ = fB(e, true), L = DC(t), F = nX(t);
                break;
              case "second":
                $ = fB(e, false), L = RC(t), F = rX(t);
                break;
              case "millisecond":
                $ = ope(e), L = $C(t), F = iX(t);
                break;
            }
            o($, A, M, L, F, O, R), T === "year" && D.length > 1 && E === 0 && D.unshift({
              value: D[0].value - $
            });
          }
        }
        for (var E = 0; E < R.length; E++) D.push(R[E]);
        return R;
      }
    }
    for (var u = [], c = [], h = 0, d = 0, f = 0; f < a.length && s++ < i; ++f) {
      var p = Cg(a[f]);
      if (Pce(a[f])) {
        l(a[f], u[u.length - 1] || [], c);
        var g = a[f + 1] ? Cg(a[f + 1]) : null;
        if (p !== g) {
          if (c.length) {
            d = h, c.sort(function(T, k) {
              return T.value - k.value;
            });
            for (var m = [], v = 0; v < c.length; ++v) {
              var y = c[v].value;
              (v === 0 || c[v - 1].value !== y) && (m.push(c[v]), y >= r[0] && y <= r[1] && h++);
            }
            var x = (r[1] - r[0]) / e;
            if (h > x * 1.5 && d > x / 1.5 || (u.push(m), h > x || n === a[f])) break;
          }
          c = [];
        }
      }
    }
    for (var b = rn(me(u, function(T) {
      return rn(T, function(k) {
        return k.value >= r[0] && k.value <= r[1] && !k.notAdd;
      });
    }), function(T) {
      return T.length > 0;
    }), w = [], _ = b.length - 1, f = 0; f < b.length; ++f) for (var S = b[f], I = 0; I < S.length; ++I) w.push({
      value: S[I].value,
      level: _ - f
    });
    w.sort(function(T, k) {
      return T.value - k.value;
    });
    for (var C = [], f = 0; f < w.length; ++f) (f === 0 || w[f].value !== w[f - 1].value) && C.push(w[f]);
    return C;
  }
  hl.registerClass(kE);
  var pB = hl.prototype, d0 = jl.prototype, cpe = rr, hpe = Math.floor, dpe = Math.ceil, z1 = Math.pow, Ms = Math.log, TE = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "log", t.base = 10, t._originalScale = new jl(), t._interval = 0, t;
    }
    return e.prototype.getTicks = function(t) {
      var r = this._originalScale, i = this._extent, a = r.getExtent(), s = d0.getTicks.call(this, t);
      return me(s, function(o) {
        var l = o.value, u = rr(z1(this.base, l));
        return u = l === i[0] && this._fixMin ? V1(u, a[0]) : u, u = l === i[1] && this._fixMax ? V1(u, a[1]) : u, {
          value: u
        };
      }, this);
    }, e.prototype.setExtent = function(t, r) {
      var i = Ms(this.base);
      t = Ms(Math.max(0, t)) / i, r = Ms(Math.max(0, r)) / i, d0.setExtent.call(this, t, r);
    }, e.prototype.getExtent = function() {
      var t = this.base, r = pB.getExtent.call(this);
      r[0] = z1(t, r[0]), r[1] = z1(t, r[1]);
      var i = this._originalScale, a = i.getExtent();
      return this._fixMin && (r[0] = V1(r[0], a[0])), this._fixMax && (r[1] = V1(r[1], a[1])), r;
    }, e.prototype.unionExtent = function(t) {
      this._originalScale.unionExtent(t);
      var r = this.base;
      t[0] = Ms(t[0]) / Ms(r), t[1] = Ms(t[1]) / Ms(r), pB.unionExtent.call(this, t);
    }, e.prototype.unionExtentFromData = function(t, r) {
      this.unionExtent(t.getApproximateExtent(r));
    }, e.prototype.calcNiceTicks = function(t) {
      t = t || 10;
      var r = this._extent, i = r[1] - r[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var a = gle(i), s = t / i * a;
        for (s <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; ) a *= 10;
        var o = [
          rr(dpe(r[0] / a) * a),
          rr(hpe(r[1] / a) * a)
        ];
        this._interval = a, this._niceExtent = o;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      d0.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax;
    }, e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return t = Ms(t) / Ms(this.base), FC(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return t = Ms(t) / Ms(this.base), OC(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = BC(t, this._extent), z1(this.base, t);
    }, e.type = "log", e;
  }(hl), LY = TE.prototype;
  LY.getMinorTicks = d0.getMinorTicks;
  LY.getLabel = d0.getLabel;
  function V1(n, e) {
    return cpe(n, Oo(e));
  }
  hl.registerClass(TE);
  var fpe = function() {
    function n(e, t, r) {
      this._prepareParams(e, t, r);
    }
    return n.prototype._prepareParams = function(e, t, r) {
      r[1] < r[0] && (r = [
        NaN,
        NaN
      ]), this._dataMin = r[0], this._dataMax = r[1];
      var i = this._isOrdinal = e.type === "ordinal";
      this._needCrossZero = e.type === "interval" && t.getNeedCrossZero && t.getNeedCrossZero();
      var a = t.get("min", true);
      a == null && (a = t.get("startValue", true));
      var s = this._modelMinRaw = a;
      Xe(s) ? this._modelMinNum = W1(e, s({
        min: r[0],
        max: r[1]
      })) : s !== "dataMin" && (this._modelMinNum = W1(e, s));
      var o = this._modelMaxRaw = t.get("max", true);
      if (Xe(o) ? this._modelMaxNum = W1(e, o({
        min: r[0],
        max: r[1]
      })) : o !== "dataMax" && (this._modelMaxNum = W1(e, o)), i) this._axisDataLen = t.getCategories().length;
      else {
        var l = t.get("boundaryGap"), u = de(l) ? l : [
          l || 0,
          l || 0
        ];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? this._boundaryGapInner = [
          0,
          0
        ] : this._boundaryGapInner = [
          no(u[0], 1),
          no(u[1], 1)
        ];
      }
    }, n.prototype.calculate = function() {
      var e = this._isOrdinal, t = this._dataMin, r = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, s = e ? null : r - t || Math.abs(t), o = this._modelMinRaw === "dataMin" ? t : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? r : this._modelMaxNum, u = o != null, c = l != null;
      o == null && (o = e ? i ? 0 : NaN : t - a[0] * s), l == null && (l = e ? i ? i - 1 : NaN : r + a[1] * s), (o == null || !isFinite(o)) && (o = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var h = C0(o) || C0(l) || e && !i;
      this._needCrossZero && (o > 0 && l > 0 && !u && (o = 0), o < 0 && l < 0 && !c && (l = 0));
      var d = this._determinedMin, f = this._determinedMax;
      return d != null && (o = d, u = true), f != null && (l = f, c = true), {
        min: o,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: h
      };
    }, n.prototype.modifyDataMinMax = function(e, t) {
      this[gpe[e]] = t;
    }, n.prototype.setDeterminedMinMax = function(e, t) {
      var r = ppe[e];
      this[r] = t;
    }, n.prototype.freeze = function() {
      this.frozen = true;
    }, n;
  }(), ppe = {
    min: "_determinedMin",
    max: "_determinedMax"
  }, gpe = {
    min: "_dataMin",
    max: "_dataMax"
  };
  function FY(n, e, t) {
    var r = n.rawExtentInfo;
    return r || (r = new fpe(n, e, t), n.rawExtentInfo = r, r);
  }
  function W1(n, e) {
    return e == null ? null : C0(e) ? NaN : n.parse(e);
  }
  function OY(n, e) {
    var t = n.type, r = FY(n, e, n.getExtent()).calculate();
    n.setBlank(r.isBlank);
    var i = r.min, a = r.max, s = e.ecModel;
    if (s && t === "time") {
      var o = DY("bar", s), l = false;
      if (P(o, function(h) {
        l = l || h.getBaseAxis() === e.axis;
      }), l) {
        var u = RY(o), c = mpe(i, a, e, u);
        i = c.min, a = c.max;
      }
    }
    return {
      extent: [
        i,
        a
      ],
      fixMin: r.minFixed,
      fixMax: r.maxFixed
    };
  }
  function mpe(n, e, t, r) {
    var i = t.axis.getExtent(), a = Math.abs(i[1] - i[0]), s = epe(r, t.axis);
    if (s === void 0) return {
      min: n,
      max: e
    };
    var o = 1 / 0;
    P(s, function(f) {
      o = Math.min(f.offset, o);
    });
    var l = -1 / 0;
    P(s, function(f) {
      l = Math.max(f.offset + f.width, l);
    }), o = Math.abs(o), l = Math.abs(l);
    var u = o + l, c = e - n, h = 1 - (o + l) / a, d = c / h - c;
    return e += d * (l / u), n -= d * (o / u), {
      min: n,
      max: e
    };
  }
  function Fg(n, e) {
    var t = e, r = OY(n, t), i = r.extent, a = t.get("splitNumber");
    n instanceof TE && (n.base = t.get("logBase"));
    var s = n.type, o = t.get("interval"), l = s === "interval" || s === "time";
    n.setExtent(i[0], i[1]), n.calcNiceExtent({
      splitNumber: a,
      fixMin: r.fixMin,
      fixMax: r.fixMax,
      minInterval: l ? t.get("minInterval") : null,
      maxInterval: l ? t.get("maxInterval") : null
    }), o != null && n.setInterval && n.setInterval(o);
  }
  function VC(n, e) {
    if (e = e || n.get("type"), e) switch (e) {
      case "category":
        return new zC({
          ordinalMeta: n.getOrdinalMeta ? n.getOrdinalMeta() : n.getCategories(),
          extent: [
            1 / 0,
            -1 / 0
          ]
        });
      case "time":
        return new kE({
          locale: n.ecModel.getLocaleModel(),
          useUTC: n.ecModel.get("useUTC")
        });
      default:
        return new (hl.getClass(e) || jl)();
    }
  }
  function vpe(n) {
    var e = n.scale.getExtent(), t = e[0], r = e[1];
    return !(t > 0 && r > 0 || t < 0 && r < 0);
  }
  function Im(n) {
    var e = n.getLabelModel().get("formatter"), t = n.type === "category" ? n.scale.getExtent()[0] : null;
    return n.scale.type === "time" ? /* @__PURE__ */ function(r) {
      return function(i, a) {
        return n.scale.getFormattedLabel(i, a, r);
      };
    }(e) : Ie(e) ? /* @__PURE__ */ function(r) {
      return function(i) {
        var a = n.scale.getLabel(i), s = r.replace("{value}", a ?? "");
        return s;
      };
    }(e) : Xe(e) ? /* @__PURE__ */ function(r) {
      return function(i, a) {
        return t != null && (a = i.value - t), r(AE(n, i), a, i.level != null ? {
          level: i.level
        } : null);
      };
    }(e) : function(r) {
      return n.scale.getLabel(r);
    };
  }
  function AE(n, e) {
    return n.type === "category" ? n.scale.getLabel(e) : e.value;
  }
  function ype(n) {
    var e = n.model, t = n.scale;
    if (!(!e.get([
      "axisLabel",
      "show"
    ]) || t.isBlank())) {
      var r, i, a = t.getExtent();
      t instanceof zC ? i = t.count() : (r = t.getTicks(), i = r.length);
      var s = n.getLabelModel(), o = Im(n), l, u = 1;
      i > 40 && (u = Math.ceil(i / 40));
      for (var c = 0; c < i; c += u) {
        var h = r ? r[c] : {
          value: a[0] + c
        }, d = o(h, c), f = s.getTextRect(d), p = xpe(f, s.get("rotate") || 0);
        l ? l.union(p) : l = p;
      }
      return l;
    }
  }
  function xpe(n, e) {
    var t = e * Math.PI / 180, r = n.width, i = n.height, a = r * Math.abs(Math.cos(t)) + Math.abs(i * Math.sin(t)), s = r * Math.abs(Math.sin(t)) + Math.abs(i * Math.cos(t)), o = new vt(n.x, n.y, a, s);
    return o;
  }
  function DE(n) {
    var e = n.get("interval");
    return e ?? "auto";
  }
  function BY(n) {
    return n.type === "category" && DE(n.getLabelModel()) === 0;
  }
  function eS(n, e) {
    var t = {};
    return P(n.mapDimensionsAll(e), function(r) {
      t[IY(n, r)] = true;
    }), Mt(t);
  }
  function bpe(n, e, t) {
    e && P(eS(e, t), function(r) {
      var i = e.getApproximateExtent(r);
      i[0] < n[0] && (n[0] = i[0]), i[1] > n[1] && (n[1] = i[1]);
    });
  }
  var Vx = function() {
    function n() {
    }
    return n.prototype.getNeedCrossZero = function() {
      var e = this.option;
      return !e.scale;
    }, n.prototype.getCoordSysModel = function() {
    }, n;
  }(), wpe = 1e-8;
  function gB(n, e) {
    return Math.abs(n - e) < wpe;
  }
  function Th(n, e, t) {
    var r = 0, i = n[0];
    if (!i) return false;
    for (var a = 1; a < n.length; a++) {
      var s = n[a];
      r += Cl(i[0], i[1], s[0], s[1], e, t), i = s;
    }
    var o = n[0];
    return (!gB(i[0], o[0]) || !gB(i[1], o[1])) && (r += Cl(i[0], i[1], o[0], o[1], e, t)), r !== 0;
  }
  var _pe = [];
  function Mk(n, e) {
    for (var t = 0; t < n.length; t++) di(n[t], n[t], e);
  }
  function mB(n, e, t, r) {
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      r && (a = r.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Eu(e, e, a), Mu(t, t, a));
    }
  }
  function Spe(n) {
    for (var e = 0, t = 0, r = 0, i = n.length, a = n[i - 1][0], s = n[i - 1][1], o = 0; o < i; o++) {
      var l = n[o][0], u = n[o][1], c = a * u - l * s;
      e += c, t += (a + l) * c, r += (s + u) * c, a = l, s = u;
    }
    return e ? [
      t / e / 3,
      r / e / 3,
      e
    ] : [
      n[0][0] || 0,
      n[0][1] || 0
    ];
  }
  var zY = function() {
    function n(e) {
      this.name = e;
    }
    return n.prototype.setCenter = function(e) {
      this._center = e;
    }, n.prototype.getCenter = function() {
      var e = this._center;
      return e || (e = this._center = this.calcCenter()), e;
    }, n;
  }(), vB = /* @__PURE__ */ function() {
    function n(e, t) {
      this.type = "polygon", this.exterior = e, this.interiors = t;
    }
    return n;
  }(), yB = /* @__PURE__ */ function() {
    function n(e) {
      this.type = "linestring", this.points = e;
    }
    return n;
  }(), VY = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this, t) || this;
      return a.type = "geoJSON", a.geometries = r, a._center = i && [
        i[0],
        i[1]
      ], a;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this.geometries, r, i = 0, a = 0; a < t.length; a++) {
        var s = t[a], o = s.exterior, l = o && o.length;
        l > i && (r = s, i = l);
      }
      if (r) return Spe(r.exterior);
      var u = this.getBoundingRect();
      return [
        u.x + u.width / 2,
        u.y + u.height / 2
      ];
    }, e.prototype.getBoundingRect = function(t) {
      var r = this._rect;
      if (r && !t) return r;
      var i = [
        1 / 0,
        1 / 0
      ], a = [
        -1 / 0,
        -1 / 0
      ], s = this.geometries;
      return P(s, function(o) {
        o.type === "polygon" ? mB(o.exterior, i, a, t) : P(o.points, function(l) {
          mB(l, i, a, t);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), r = new vt(i[0], i[1], a[0] - i[0], a[1] - i[1]), t || (this._rect = r), r;
    }, e.prototype.contain = function(t) {
      var r = this.getBoundingRect(), i = this.geometries;
      if (!r.contain(t[0], t[1])) return false;
      e: for (var a = 0, s = i.length; a < s; a++) {
        var o = i[a];
        if (o.type === "polygon") {
          var l = o.exterior, u = o.interiors;
          if (Th(l, t[0], t[1])) {
            for (var c = 0; c < (u ? u.length : 0); c++) if (Th(u[c], t[0], t[1])) continue e;
            return true;
          }
        }
      }
      return false;
    }, e.prototype.transformTo = function(t, r, i, a) {
      var s = this.getBoundingRect(), o = s.width / s.height;
      i ? a || (a = i / o) : i = o * a;
      for (var l = new vt(t, r, i, a), u = s.calculateTransform(l), c = this.geometries, h = 0; h < c.length; h++) {
        var d = c[h];
        d.type === "polygon" ? (Mk(d.exterior, u), P(d.interiors, function(f) {
          Mk(f, u);
        })) : P(d.points, function(f) {
          Mk(f, u);
        });
      }
      s = this._rect, s.copy(l), this._center = [
        s.x + s.width / 2,
        s.y + s.height / 2
      ];
    }, e.prototype.cloneShallow = function(t) {
      t == null && (t = this.name);
      var r = new e(t, this.geometries, this._center);
      return r._rect = this._rect, r.transformTo = null, r;
    }, e;
  }(zY), Cpe = function(n) {
    K(e, n);
    function e(t, r) {
      var i = n.call(this, t) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = r, i;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this._elOnlyForCalculate, r = t.getBoundingRect(), i = [
        r.x + r.width / 2,
        r.y + r.height / 2
      ], a = dC(_pe), s = t; s && !s.isGeoSVGGraphicRoot; ) Ml(a, s.getLocalTransform(), a), s = s.parent;
      return fm(a, a), di(i, i, a), i;
    }, e;
  }(zY);
  function Ipe(n) {
    if (!n.UTF8Encoding) return n;
    var e = n, t = e.UTF8Scale;
    t == null && (t = 1024);
    var r = e.features;
    return P(r, function(i) {
      var a = i.geometry, s = a.encodeOffsets, o = a.coordinates;
      if (s) switch (a.type) {
        case "LineString":
          a.coordinates = WY(o, s, t);
          break;
        case "Polygon":
          Pk(o, s, t);
          break;
        case "MultiLineString":
          Pk(o, s, t);
          break;
        case "MultiPolygon":
          P(o, function(l, u) {
            return Pk(l, s[u], t);
          });
      }
    }), e.UTF8Encoding = false, e;
  }
  function Pk(n, e, t) {
    for (var r = 0; r < n.length; r++) n[r] = WY(n[r], e[r], t);
  }
  function WY(n, e, t) {
    for (var r = [], i = e[0], a = e[1], s = 0; s < n.length; s += 2) {
      var o = n.charCodeAt(s) - 64, l = n.charCodeAt(s + 1) - 64;
      o = o >> 1 ^ -(o & 1), l = l >> 1 ^ -(l & 1), o += i, l += a, i = o, a = l, r.push([
        o / t,
        l / t
      ]);
    }
    return r;
  }
  function kpe(n, e) {
    return n = Ipe(n), me(rn(n.features, function(t) {
      return t.geometry && t.properties && t.geometry.coordinates.length > 0;
    }), function(t) {
      var r = t.properties, i = t.geometry, a = [];
      switch (i.type) {
        case "Polygon":
          var s = i.coordinates;
          a.push(new vB(s[0], s.slice(1)));
          break;
        case "MultiPolygon":
          P(i.coordinates, function(l) {
            l[0] && a.push(new vB(l[0], l.slice(1)));
          });
          break;
        case "LineString":
          a.push(new yB([
            i.coordinates
          ]));
          break;
        case "MultiLineString":
          a.push(new yB(i.coordinates));
      }
      var o = new VY(r[e || "name"], a, r.cp);
      return o.properties = r, o;
    });
  }
  var z0 = Wt();
  function GY(n, e) {
    var t = me(e, function(r) {
      return n.scale.parse(r);
    });
    return n.type === "time" && t.length > 0 && (t.sort(), t.unshift(t[0]), t.push(t[t.length - 1])), t;
  }
  function Tpe(n) {
    var e = n.getLabelModel().get("customValues");
    if (e) {
      var t = Im(n), r = n.scale.getExtent(), i = GY(n, e), a = rn(i, function(s) {
        return s >= r[0] && s <= r[1];
      });
      return {
        labels: me(a, function(s) {
          var o = {
            value: s
          };
          return {
            formattedLabel: t(o),
            rawLabel: n.scale.getLabel(o),
            tickValue: s
          };
        })
      };
    }
    return n.type === "category" ? Dpe(n) : $pe(n);
  }
  function Ape(n, e) {
    var t = n.getTickModel().get("customValues");
    if (t) {
      var r = n.scale.getExtent(), i = GY(n, t);
      return {
        ticks: rn(i, function(a) {
          return a >= r[0] && a <= r[1];
        })
      };
    }
    return n.type === "category" ? Rpe(n, e) : {
      ticks: me(n.scale.getTicks(), function(a) {
        return a.value;
      })
    };
  }
  function Dpe(n) {
    var e = n.getLabelModel(), t = UY(n, e);
    return !e.get("show") || n.scale.isBlank() ? {
      labels: [],
      labelCategoryInterval: t.labelCategoryInterval
    } : t;
  }
  function UY(n, e) {
    var t = HY(n, "labels"), r = DE(e), i = XY(t, r);
    if (i) return i;
    var a, s;
    return Xe(r) ? a = jY(n, r) : (s = r === "auto" ? Npe(n) : r, a = qY(n, s)), YY(t, r, {
      labels: a,
      labelCategoryInterval: s
    });
  }
  function Rpe(n, e) {
    var t = HY(n, "ticks"), r = DE(e), i = XY(t, r);
    if (i) return i;
    var a, s;
    if ((!e.get("show") || n.scale.isBlank()) && (a = []), Xe(r)) a = jY(n, r, true);
    else if (r === "auto") {
      var o = UY(n, n.getLabelModel());
      s = o.labelCategoryInterval, a = me(o.labels, function(l) {
        return l.tickValue;
      });
    } else s = r, a = qY(n, s, true);
    return YY(t, r, {
      ticks: a,
      tickCategoryInterval: s
    });
  }
  function $pe(n) {
    var e = n.scale.getTicks(), t = Im(n);
    return {
      labels: me(e, function(r, i) {
        return {
          level: r.level,
          formattedLabel: t(r, i),
          rawLabel: n.scale.getLabel(r),
          tickValue: r.value
        };
      })
    };
  }
  function HY(n, e) {
    return z0(n)[e] || (z0(n)[e] = []);
  }
  function XY(n, e) {
    for (var t = 0; t < n.length; t++) if (n[t].key === e) return n[t].value;
  }
  function YY(n, e, t) {
    return n.push({
      key: e,
      value: t
    }), t;
  }
  function Npe(n) {
    var e = z0(n).autoInterval;
    return e ?? (z0(n).autoInterval = n.calculateCategoryInterval());
  }
  function Epe(n) {
    var e = Mpe(n), t = Im(n), r = (e.axisRotate - e.labelRotate) / 180 * Math.PI, i = n.scale, a = i.getExtent(), s = i.count();
    if (a[1] - a[0] < 1) return 0;
    var o = 1;
    s > 40 && (o = Math.max(1, Math.floor(s / 40)));
    for (var l = a[0], u = n.dataToCoord(l + 1) - n.dataToCoord(l), c = Math.abs(u * Math.cos(r)), h = Math.abs(u * Math.sin(r)), d = 0, f = 0; l <= a[1]; l += o) {
      var p = 0, g = 0, m = Rx(t({
        value: l
      }), e.font, "center", "top");
      p = m.width * 1.3, g = m.height * 1.3, d = Math.max(d, p, 7), f = Math.max(f, g, 7);
    }
    var v = d / c, y = f / h;
    isNaN(v) && (v = 1 / 0), isNaN(y) && (y = 1 / 0);
    var x = Math.max(0, Math.floor(Math.min(v, y))), b = z0(n.model), w = n.getExtent(), _ = b.lastAutoInterval, S = b.lastTickCount;
    return _ != null && S != null && Math.abs(_ - x) <= 1 && Math.abs(S - s) <= 1 && _ > x && b.axisExtent0 === w[0] && b.axisExtent1 === w[1] ? x = _ : (b.lastTickCount = s, b.lastAutoInterval = x, b.axisExtent0 = w[0], b.axisExtent1 = w[1]), x;
  }
  function Mpe(n) {
    var e = n.getLabelModel();
    return {
      axisRotate: n.getRotate ? n.getRotate() : n.isHorizontal && !n.isHorizontal() ? 90 : 0,
      labelRotate: e.get("rotate") || 0,
      font: e.getFont()
    };
  }
  function qY(n, e, t) {
    var r = Im(n), i = n.scale, a = i.getExtent(), s = n.getLabelModel(), o = [], l = Math.max((e || 0) + 1, 1), u = a[0], c = i.count();
    u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
    var h = BY(n), d = s.get("showMinLabel") || h, f = s.get("showMaxLabel") || h;
    d && u !== a[0] && g(a[0]);
    for (var p = u; p <= a[1]; p += l) g(p);
    f && p - l !== a[1] && g(a[1]);
    function g(m) {
      var v = {
        value: m
      };
      o.push(t ? m : {
        formattedLabel: r(v),
        rawLabel: i.getLabel(v),
        tickValue: m
      });
    }
    return o;
  }
  function jY(n, e, t) {
    var r = n.scale, i = Im(n), a = [];
    return P(r.getTicks(), function(s) {
      var o = r.getLabel(s), l = s.value;
      e(s.value, o) && a.push(t ? l : {
        formattedLabel: i(s),
        rawLabel: o,
        tickValue: l
      });
    }), a;
  }
  var xB = [
    0,
    1
  ], fo = function() {
    function n(e, t, r) {
      this.onBand = false, this.inverse = false, this.dim = e, this.scale = t, this._extent = r || [
        0,
        0
      ];
    }
    return n.prototype.contain = function(e) {
      var t = this._extent, r = Math.min(t[0], t[1]), i = Math.max(t[0], t[1]);
      return e >= r && e <= i;
    }, n.prototype.containData = function(e) {
      return this.scale.contain(e);
    }, n.prototype.getExtent = function() {
      return this._extent.slice();
    }, n.prototype.getPixelPrecision = function(e) {
      return Z6(e || this.scale.getExtent(), this._extent);
    }, n.prototype.setExtent = function(e, t) {
      var r = this._extent;
      r[0] = e, r[1] = t;
    }, n.prototype.dataToCoord = function(e, t) {
      var r = this._extent, i = this.scale;
      return e = i.normalize(e), this.onBand && i.type === "ordinal" && (r = r.slice(), bB(r, i.count())), sn(e, xB, r, t);
    }, n.prototype.coordToData = function(e, t) {
      var r = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (r = r.slice(), bB(r, i.count()));
      var a = sn(e, r, xB, t);
      return this.scale.scale(a);
    }, n.prototype.pointToData = function(e, t) {
    }, n.prototype.getTicksCoords = function(e) {
      e = e || {};
      var t = e.tickModel || this.getTickModel(), r = Ape(this, t), i = r.ticks, a = me(i, function(o) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(o) : o),
          tickValue: o
        };
      }, this), s = t.get("alignWithLabel");
      return Ppe(this, a, s, e.clamp), a;
    }, n.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal") return [];
      var e = this.model.getModel("minorTick"), t = e.get("splitNumber");
      t > 0 && t < 100 || (t = 5);
      var r = this.scale.getMinorTicks(t), i = me(r, function(a) {
        return me(a, function(s) {
          return {
            coord: this.dataToCoord(s),
            tickValue: s
          };
        }, this);
      }, this);
      return i;
    }, n.prototype.getViewLabels = function() {
      return Tpe(this).labels;
    }, n.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, n.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, n.prototype.getBandWidth = function() {
      var e = this._extent, t = this.scale.getExtent(), r = t[1] - t[0] + (this.onBand ? 1 : 0);
      r === 0 && (r = 1);
      var i = Math.abs(e[1] - e[0]);
      return Math.abs(i) / r;
    }, n.prototype.calculateCategoryInterval = function() {
      return Epe(this);
    }, n;
  }();
  function bB(n, e) {
    var t = n[1] - n[0], r = e, i = t / r / 2;
    n[0] += i, n[1] -= i;
  }
  function Ppe(n, e, t, r) {
    var i = e.length;
    if (!n.onBand || t || !i) return;
    var a = n.getExtent(), s, o;
    if (i === 1) e[0].coord = a[0], s = e[1] = {
      coord: a[1],
      tickValue: e[0].tickValue
    };
    else {
      var l = e[i - 1].tickValue - e[0].tickValue, u = (e[i - 1].coord - e[0].coord) / l;
      P(e, function(f) {
        f.coord -= u / 2;
      });
      var c = n.scale.getExtent();
      o = 1 + c[1] - e[i - 1].tickValue, s = {
        coord: e[i - 1].coord + u * o,
        tickValue: c[1] + 1
      }, e.push(s);
    }
    var h = a[0] > a[1];
    d(e[0].coord, a[0]) && (r ? e[0].coord = a[0] : e.shift()), r && d(a[0], e[0].coord) && e.unshift({
      coord: a[0]
    }), d(a[1], s.coord) && (r ? s.coord = a[1] : e.pop()), r && d(s.coord, a[1]) && e.push({
      coord: a[1]
    });
    function d(f, p) {
      return f = rr(f), p = rr(p), h ? f > p : f < p;
    }
  }
  var ly = Math.PI * 2, ah = nl.CMD, Lpe = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function Fpe(n, e, t, r, i) {
    var a = t.width, s = t.height;
    switch (n) {
      case "top":
        r.set(t.x + a / 2, t.y - e), i.set(0, -1);
        break;
      case "bottom":
        r.set(t.x + a / 2, t.y + s + e), i.set(0, 1);
        break;
      case "left":
        r.set(t.x - e, t.y + s / 2), i.set(-1, 0);
        break;
      case "right":
        r.set(t.x + a + e, t.y + s / 2), i.set(1, 0);
        break;
    }
  }
  function Ope(n, e, t, r, i, a, s, o, l) {
    s -= n, o -= e;
    var u = Math.sqrt(s * s + o * o);
    s /= u, o /= u;
    var c = s * t + n, h = o * t + e;
    if (Math.abs(r - i) % ly < 1e-4) return l[0] = c, l[1] = h, u - t;
    if (a) {
      var d = r;
      r = Oa(i), i = Oa(d);
    } else r = Oa(r), i = Oa(i);
    r > i && (i += ly);
    var f = Math.atan2(o, s);
    if (f < 0 && (f += ly), f >= r && f <= i || f + ly >= r && f + ly <= i) return l[0] = c, l[1] = h, u - t;
    var p = t * Math.cos(r) + n, g = t * Math.sin(r) + e, m = t * Math.cos(i) + n, v = t * Math.sin(i) + e, y = (p - s) * (p - s) + (g - o) * (g - o), x = (m - s) * (m - s) + (v - o) * (v - o);
    return y < x ? (l[0] = p, l[1] = g, Math.sqrt(y)) : (l[0] = m, l[1] = v, Math.sqrt(x));
  }
  function tS(n, e, t, r, i, a, s, o) {
    var l = i - n, u = a - e, c = t - n, h = r - e, d = Math.sqrt(c * c + h * h);
    c /= d, h /= d;
    var f = l * c + u * h, p = f / d;
    o && (p = Math.min(Math.max(p, 0), 1)), p *= d;
    var g = s[0] = n + p * c, m = s[1] = e + p * h;
    return Math.sqrt((g - i) * (g - i) + (m - a) * (m - a));
  }
  function KY(n, e, t, r, i, a, s) {
    t < 0 && (n = n + t, t = -t), r < 0 && (e = e + r, r = -r);
    var o = n + t, l = e + r, u = s[0] = Math.min(Math.max(i, n), o), c = s[1] = Math.min(Math.max(a, e), l);
    return Math.sqrt((u - i) * (u - i) + (c - a) * (c - a));
  }
  var Vs = [];
  function Bpe(n, e, t) {
    var r = KY(e.x, e.y, e.width, e.height, n.x, n.y, Vs);
    return t.set(Vs[0], Vs[1]), r;
  }
  function zpe(n, e, t) {
    for (var r = 0, i = 0, a = 0, s = 0, o, l, u = 1 / 0, c = e.data, h = n.x, d = n.y, f = 0; f < c.length; ) {
      var p = c[f++];
      f === 1 && (r = c[f], i = c[f + 1], a = r, s = i);
      var g = u;
      switch (p) {
        case ah.M:
          a = c[f++], s = c[f++], r = a, i = s;
          break;
        case ah.L:
          g = tS(r, i, c[f], c[f + 1], h, d, Vs, true), r = c[f++], i = c[f++];
          break;
        case ah.C:
          g = E6(r, i, c[f++], c[f++], c[f++], c[f++], c[f], c[f + 1], h, d, Vs), r = c[f++], i = c[f++];
          break;
        case ah.Q:
          g = P6(r, i, c[f++], c[f++], c[f], c[f + 1], h, d, Vs), r = c[f++], i = c[f++];
          break;
        case ah.A:
          var m = c[f++], v = c[f++], y = c[f++], x = c[f++], b = c[f++], w = c[f++];
          f += 1;
          var _ = !!(1 - c[f++]);
          o = Math.cos(b) * y + m, l = Math.sin(b) * x + v, f <= 1 && (a = o, s = l);
          var S = (h - m) * x / y + m;
          g = Ope(m, v, x, b, b + w, _, S, d, Vs), r = Math.cos(b + w) * y + m, i = Math.sin(b + w) * x + v;
          break;
        case ah.R:
          a = r = c[f++], s = i = c[f++];
          var I = c[f++], C = c[f++];
          g = KY(a, s, I, C, h, d, Vs);
          break;
        case ah.Z:
          g = tS(r, i, a, s, h, d, Vs, true), r = a, i = s;
          break;
      }
      g < u && (u = g, t.set(Vs[0], Vs[1]));
    }
    return u;
  }
  var Xs = new mt(), Rn = new mt(), sr = new mt(), Vo = new mt(), Fo = new mt();
  function wB(n, e) {
    if (n) {
      var t = n.getTextGuideLine(), r = n.getTextContent();
      if (r && t) {
        var i = n.textGuideLineConfig || {}, a = [
          [
            0,
            0
          ],
          [
            0,
            0
          ],
          [
            0,
            0
          ]
        ], s = i.candidates || Lpe, o = r.getBoundingRect().clone();
        o.applyTransform(r.getComputedTransform());
        var l = 1 / 0, u = i.anchor, c = n.getComputedTransform(), h = c && fm([], c), d = e.get("length2") || 0;
        u && sr.copy(u);
        for (var f = 0; f < s.length; f++) {
          var p = s[f];
          Fpe(p, 0, o, Xs, Vo), mt.scaleAndAdd(Rn, Xs, Vo, d), Rn.transform(h);
          var g = n.getBoundingRect(), m = u ? u.distance(Rn) : n instanceof At ? zpe(Rn, n.path, sr) : Bpe(Rn, g, sr);
          m < l && (l = m, Rn.transform(c), sr.transform(c), sr.toArray(a[0]), Rn.toArray(a[1]), Xs.toArray(a[2]));
        }
        ZY(a, e.get("minTurnAngle")), t.setShape({
          points: a
        });
      }
    }
  }
  var nS = [], Ui = new mt();
  function ZY(n, e) {
    if (e <= 180 && e > 0) {
      e = e / 180 * Math.PI, Xs.fromArray(n[0]), Rn.fromArray(n[1]), sr.fromArray(n[2]), mt.sub(Vo, Xs, Rn), mt.sub(Fo, sr, Rn);
      var t = Vo.len(), r = Fo.len();
      if (!(t < 1e-3 || r < 1e-3)) {
        Vo.scale(1 / t), Fo.scale(1 / r);
        var i = Vo.dot(Fo), a = Math.cos(e);
        if (a < i) {
          var s = tS(Rn.x, Rn.y, sr.x, sr.y, Xs.x, Xs.y, nS, false);
          Ui.fromArray(nS), Ui.scaleAndAdd(Fo, s / Math.tan(Math.PI - e));
          var o = sr.x !== Rn.x ? (Ui.x - Rn.x) / (sr.x - Rn.x) : (Ui.y - Rn.y) / (sr.y - Rn.y);
          if (isNaN(o)) return;
          o < 0 ? mt.copy(Ui, Rn) : o > 1 && mt.copy(Ui, sr), Ui.toArray(n[1]);
        }
      }
    }
  }
  function Vpe(n, e, t) {
    if (t <= 180 && t > 0) {
      t = t / 180 * Math.PI, Xs.fromArray(n[0]), Rn.fromArray(n[1]), sr.fromArray(n[2]), mt.sub(Vo, Rn, Xs), mt.sub(Fo, sr, Rn);
      var r = Vo.len(), i = Fo.len();
      if (!(r < 1e-3 || i < 1e-3)) {
        Vo.scale(1 / r), Fo.scale(1 / i);
        var a = Vo.dot(e), s = Math.cos(t);
        if (a < s) {
          var o = tS(Rn.x, Rn.y, sr.x, sr.y, Xs.x, Xs.y, nS, false);
          Ui.fromArray(nS);
          var l = Math.PI / 2, u = Math.acos(Fo.dot(e)), c = l + u - t;
          if (c >= l) mt.copy(Ui, sr);
          else {
            Ui.scaleAndAdd(Fo, o / Math.tan(Math.PI / 2 - c));
            var h = sr.x !== Rn.x ? (Ui.x - Rn.x) / (sr.x - Rn.x) : (Ui.y - Rn.y) / (sr.y - Rn.y);
            if (isNaN(h)) return;
            h < 0 ? mt.copy(Ui, Rn) : h > 1 && mt.copy(Ui, sr);
          }
          Ui.toArray(n[1]);
        }
      }
    }
  }
  function Lk(n, e, t, r) {
    var i = t === "normal", a = i ? n : n.ensureState(t);
    a.ignore = e;
    var s = r.get("smooth");
    s && s === true && (s = 0.3), a.shape = a.shape || {}, s > 0 && (a.shape.smooth = s);
    var o = r.getModel("lineStyle").getLineStyle();
    i ? n.useStyle(o) : a.style = o;
  }
  function Wpe(n, e) {
    var t = e.smooth, r = e.points;
    if (r) if (n.moveTo(r[0][0], r[0][1]), t > 0 && r.length >= 3) {
      var i = Nu(r[0], r[1]), a = Nu(r[1], r[2]);
      if (!i || !a) {
        n.lineTo(r[1][0], r[1][1]), n.lineTo(r[2][0], r[2][1]);
        return;
      }
      var s = Math.min(i, a) * t, o = jw([], r[1], r[0], s / i), l = jw([], r[1], r[2], s / a), u = jw([], o, l, 0.5);
      n.bezierCurveTo(o[0], o[1], o[0], o[1], u[0], u[1]), n.bezierCurveTo(l[0], l[1], l[0], l[1], r[2][0], r[2][1]);
    } else for (var c = 1; c < r.length; c++) n.lineTo(r[c][0], r[c][1]);
  }
  function RE(n, e, t) {
    var r = n.getTextGuideLine(), i = n.getTextContent();
    if (!i) {
      r && n.removeTextGuideLine();
      return;
    }
    for (var a = e.normal, s = a.get("show"), o = i.ignore, l = 0; l < $0.length; l++) {
      var u = $0[l], c = e[u], h = u === "normal";
      if (c) {
        var d = c.get("show"), f = h ? o : it(i.states[u] && i.states[u].ignore, o);
        if (f || !it(d, s)) {
          var p = h ? r : r && r.states[u];
          p && (p.ignore = true), r && Lk(r, true, u, c);
          continue;
        }
        r || (r = new oa(), n.setTextGuideLine(r), !h && (o || !s) && Lk(r, true, "normal", e.normal), n.stateProxy && (r.stateProxy = n.stateProxy)), Lk(r, false, u, c);
      }
    }
    if (r) {
      je(r.style, t), r.style.fill = null;
      var g = a.get("showAbove"), m = n.textGuideLineConfig = n.textGuideLineConfig || {};
      m.showAbove = g || false, r.buildPath = Wpe;
    }
  }
  function $E(n, e) {
    e = e || "labelLine";
    for (var t = {
      normal: n.getModel(e)
    }, r = 0; r < na.length; r++) {
      var i = na[r];
      t[i] = n.getModel([
        i,
        e
      ]);
    }
    return t;
  }
  function QY(n) {
    for (var e = [], t = 0; t < n.length; t++) {
      var r = n[t];
      if (!r.defaultAttr.ignore) {
        var i = r.label, a = i.getComputedTransform(), s = i.getBoundingRect(), o = !a || a[1] < 1e-5 && a[2] < 1e-5, l = i.style.margin || 0, u = s.clone();
        u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
        var c = o ? new z_(s, a) : null;
        e.push({
          label: i,
          labelLine: r.labelLine,
          rect: u,
          localRect: s,
          obb: c,
          priority: r.priority,
          defaultAttr: r.defaultAttr,
          layoutOption: r.computedLayoutOption,
          axisAligned: o,
          transform: a
        });
      }
    }
    return e;
  }
  function JY(n, e, t, r, i, a) {
    var s = n.length;
    if (s < 2) return;
    n.sort(function(_, S) {
      return _.rect[e] - S.rect[e];
    });
    for (var o = 0, l, u = false, c = 0; c < s; c++) {
      var h = n[c], d = h.rect;
      l = d[e] - o, l < 0 && (d[e] -= l, h.label[e] -= l, u = true), o = d[e] + d[t];
    }
    var f = n[0], p = n[s - 1], g, m;
    v(), g < 0 && b(-g, 0.8), m < 0 && b(m, 0.8), v(), y(g, m, 1), y(m, g, -1), v(), g < 0 && w(-g), m < 0 && w(m);
    function v() {
      g = f.rect[e] - r, m = i - p.rect[e] - p.rect[t];
    }
    function y(_, S, I) {
      if (_ < 0) {
        var C = Math.min(S, -_);
        if (C > 0) {
          x(C * I, 0, s);
          var T = C + _;
          T < 0 && b(-T * I, 1);
        } else b(-_ * I, 1);
      }
    }
    function x(_, S, I) {
      _ !== 0 && (u = true);
      for (var C = S; C < I; C++) {
        var T = n[C], k = T.rect;
        k[e] += _, T.label[e] += _;
      }
    }
    function b(_, S) {
      for (var I = [], C = 0, T = 1; T < s; T++) {
        var k = n[T - 1].rect, D = Math.max(n[T].rect[e] - k[e] - k[t], 0);
        I.push(D), C += D;
      }
      if (C) {
        var R = Math.min(Math.abs(_) / C, S);
        if (_ > 0) for (var T = 0; T < s - 1; T++) {
          var N = I[T] * R;
          x(N, 0, T + 1);
        }
        else for (var T = s - 1; T > 0; T--) {
          var N = I[T - 1] * R;
          x(-N, T, s);
        }
      }
    }
    function w(_) {
      var S = _ < 0 ? -1 : 1;
      _ = Math.abs(_);
      for (var I = Math.ceil(_ / (s - 1)), C = 0; C < s - 1; C++) if (S > 0 ? x(I, 0, C + 1) : x(-I, s - C - 1, s), _ -= I, _ <= 0) return;
    }
    return u;
  }
  function Gpe(n, e, t, r) {
    return JY(n, "x", "width", e, t);
  }
  function eq(n, e, t, r) {
    return JY(n, "y", "height", e, t);
  }
  function tq(n) {
    var e = [];
    n.sort(function(g, m) {
      return m.priority - g.priority;
    });
    var t = new vt(0, 0, 0, 0);
    function r(g) {
      if (!g.ignore) {
        var m = g.ensureState("emphasis");
        m.ignore == null && (m.ignore = false);
      }
      g.ignore = true;
    }
    for (var i = 0; i < n.length; i++) {
      var a = n[i], s = a.axisAligned, o = a.localRect, l = a.transform, u = a.label, c = a.labelLine;
      t.copy(a.rect), t.width -= 0.1, t.height -= 0.1, t.x += 0.05, t.y += 0.05;
      for (var h = a.obb, d = false, f = 0; f < e.length; f++) {
        var p = e[f];
        if (t.intersect(p.rect)) {
          if (s && p.axisAligned) {
            d = true;
            break;
          }
          if (p.obb || (p.obb = new z_(p.localRect, p.transform)), h || (h = new z_(o, l)), h.intersect(p.obb)) {
            d = true;
            break;
          }
        }
      }
      d ? (r(u), c && r(c)) : (u.attr("ignore", a.defaultAttr.ignore), c && c.attr("ignore", a.defaultAttr.labelGuideIgnore), e.push(a));
    }
  }
  function Upe(n) {
    if (n) {
      for (var e = [], t = 0; t < n.length; t++) e.push(n[t].slice());
      return e;
    }
  }
  function Hpe(n, e) {
    var t = n.label, r = e && e.getTextGuideLine();
    return {
      dataIndex: n.dataIndex,
      dataType: n.dataType,
      seriesIndex: n.seriesModel.seriesIndex,
      text: n.label.style.text,
      rect: n.hostRect,
      labelRect: n.rect,
      align: t.style.align,
      verticalAlign: t.style.verticalAlign,
      labelLinePoints: Upe(r && r.shape.points)
    };
  }
  var _B = [
    "align",
    "verticalAlign",
    "width",
    "height",
    "fontSize"
  ], zi = new Tl(), Fk = Wt(), Xpe = Wt();
  function G1(n, e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      e[i] != null && (n[i] = e[i]);
    }
  }
  var U1 = [
    "x",
    "y",
    "rotation"
  ], Ype = function() {
    function n() {
      this._labelList = [], this._chartViewList = [];
    }
    return n.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, n.prototype._addLabel = function(e, t, r, i, a) {
      var s = i.style, o = i.__hostTarget, l = o.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      vt.applyTransform(c, c, u), u ? zi.setLocalTransform(u) : (zi.x = zi.y = zi.rotation = zi.originX = zi.originY = 0, zi.scaleX = zi.scaleY = 1), zi.rotation = Oa(zi.rotation);
      var h = i.__hostTarget, d;
      if (h) {
        d = h.getBoundingRect().plain();
        var f = h.getComputedTransform();
        vt.applyTransform(d, d, f);
      }
      var p = d && h.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: r,
        dataIndex: e,
        dataType: t,
        layoutOption: a,
        computedLayoutOption: null,
        rect: c,
        hostRect: d,
        priority: d ? d.width * d.height : 0,
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: zi.x,
          y: zi.y,
          scaleX: zi.scaleX,
          scaleY: zi.scaleY,
          rotation: zi.rotation,
          style: {
            x: s.x,
            y: s.y,
            align: s.align,
            verticalAlign: s.verticalAlign,
            width: s.width,
            height: s.height,
            fontSize: s.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, n.prototype.addLabelsOfSeries = function(e) {
      var t = this;
      this._chartViewList.push(e);
      var r = e.__model, i = r.get("labelLayout");
      (Xe(i) || Mt(i).length) && e.group.traverse(function(a) {
        if (a.ignore) return true;
        var s = a.getTextContent(), o = rt(a);
        s && !s.disableLabelLayout && t._addLabel(o.dataIndex, o.dataType, r, s, i);
      });
    }, n.prototype.updateLayoutConfig = function(e) {
      var t = e.getWidth(), r = e.getHeight();
      function i(x, b) {
        return function() {
          wB(x, b);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var s = this._labelList[a], o = s.label, l = o.__hostTarget, u = s.defaultAttr, c = void 0;
        Xe(s.layoutOption) ? c = s.layoutOption(Hpe(s, l)) : c = s.layoutOption, c = c || {}, s.computedLayoutOption = c;
        var h = Math.PI / 180;
        l && l.setTextConfig({
          local: false,
          position: c.x != null || c.y != null ? null : u.attachedPos,
          rotation: c.rotate != null ? c.rotate * h : u.attachedRot,
          offset: [
            c.dx || 0,
            c.dy || 0
          ]
        });
        var d = false;
        if (c.x != null ? (o.x = _e(c.x, t), o.setStyle("x", 0), d = true) : (o.x = u.x, o.setStyle("x", u.style.x)), c.y != null ? (o.y = _e(c.y, r), o.setStyle("y", 0), d = true) : (o.y = u.y, o.setStyle("y", u.style.y)), c.labelLinePoints) {
          var f = l.getTextGuideLine();
          f && (f.setShape({
            points: c.labelLinePoints
          }), d = false);
        }
        var p = Fk(o);
        p.needsUpdateLabelLine = d, o.rotation = c.rotate != null ? c.rotate * h : u.rotation, o.scaleX = u.scaleX, o.scaleY = u.scaleY;
        for (var g = 0; g < _B.length; g++) {
          var m = _B[g];
          o.setStyle(m, c[m] != null ? c[m] : u.style[m]);
        }
        if (c.draggable) {
          if (o.draggable = true, o.cursor = "move", l) {
            var v = s.seriesModel;
            if (s.dataIndex != null) {
              var y = s.seriesModel.getData(s.dataType);
              v = y.getItemModel(s.dataIndex);
            }
            o.on("drag", i(l, v.getModel("labelLine")));
          }
        } else o.off("drag"), o.cursor = u.cursor;
      }
    }, n.prototype.layout = function(e) {
      var t = e.getWidth(), r = e.getHeight(), i = QY(this._labelList), a = rn(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), s = rn(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      Gpe(a, 0, t), eq(s, 0, r);
      var o = rn(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      tq(o);
    }, n.prototype.processLabelsOverall = function() {
      var e = this;
      P(this._chartViewList, function(t) {
        var r = t.__model, i = t.ignoreLabelLineUpdate, a = r.isAnimationEnabled();
        t.group.traverse(function(s) {
          if (s.ignore && !s.forceLabelAnimation) return true;
          var o = !i, l = s.getTextContent();
          !o && l && (o = Fk(l).needsUpdateLabelLine), o && e._updateLabelLine(s, r), a && e._animateLabels(s, r);
        });
      });
    }, n.prototype._updateLabelLine = function(e, t) {
      var r = e.getTextContent(), i = rt(e), a = i.dataIndex;
      if (r && a != null) {
        var s = t.getData(i.dataType), o = s.getItemModel(a), l = {}, u = s.getItemVisual(a, "style");
        if (u) {
          var c = s.getVisual("drawType");
          l.stroke = u[c];
        }
        var h = o.getModel("labelLine");
        RE(e, $E(o), l), wB(e, h);
      }
    }, n.prototype._animateLabels = function(e, t) {
      var r = e.getTextContent(), i = e.getTextGuideLine();
      if (r && (e.forceLabelAnimation || !r.ignore && !r.invisible && !e.disableLabelAnimation && !_g(e))) {
        var a = Fk(r), s = a.oldLayout, o = rt(e), l = o.dataIndex, u = {
          x: r.x,
          y: r.y,
          rotation: r.rotation
        }, c = t.getData(o.dataType);
        if (s) {
          r.attr(s);
          var d = e.prevStates;
          d && (bt(d, "select") >= 0 && r.attr(a.oldLayoutSelect), bt(d, "emphasis") >= 0 && r.attr(a.oldLayoutEmphasis)), Kt(r, u, t, l);
        } else if (r.attr(u), !vm(r).valueAnimation) {
          var h = it(r.style.opacity, 1);
          r.style.opacity = 0, Un(r, {
            style: {
              opacity: h
            }
          }, t, l);
        }
        if (a.oldLayout = u, r.states.select) {
          var f = a.oldLayoutSelect = {};
          G1(f, u, U1), G1(f, r.states.select, U1);
        }
        if (r.states.emphasis) {
          var p = a.oldLayoutEmphasis = {};
          G1(p, u, U1), G1(p, r.states.emphasis, U1);
        }
        X8(r, l, c, t, t);
      }
      if (i && !i.ignore && !i.invisible) {
        var a = Xpe(i), s = a.oldLayout, g = {
          points: i.shape.points
        };
        s ? (i.attr({
          shape: s
        }), Kt(i, {
          shape: g
        }, t)) : (i.setShape(g), i.style.strokePercent = 0, Un(i, {
          style: {
            strokePercent: 1
          }
        }, t)), a.oldLayout = g;
      }
    }, n;
  }(), Ok = Wt();
  function qpe(n) {
    n.registerUpdateLifecycle("series:beforeupdate", function(e, t, r) {
      var i = Ok(t).labelManager;
      i || (i = Ok(t).labelManager = new Ype()), i.clearLabels();
    }), n.registerUpdateLifecycle("series:layoutlabels", function(e, t, r) {
      var i = Ok(t).labelManager;
      r.updatedSeries.forEach(function(a) {
        i.addLabelsOfSeries(t.getViewOfSeriesModel(a));
      }), i.updateLayoutConfig(t), i.layout(t), i.processLabelsOverall();
    });
  }
  var Bk = Math.sin, zk = Math.cos, nq = Math.PI, sh = Math.PI * 2, jpe = 180 / nq, rq = function() {
    function n() {
    }
    return n.prototype.reset = function(e) {
      this._start = true, this._d = [], this._str = "", this._p = Math.pow(10, e || 4);
    }, n.prototype.moveTo = function(e, t) {
      this._add("M", e, t);
    }, n.prototype.lineTo = function(e, t) {
      this._add("L", e, t);
    }, n.prototype.bezierCurveTo = function(e, t, r, i, a, s) {
      this._add("C", e, t, r, i, a, s);
    }, n.prototype.quadraticCurveTo = function(e, t, r, i) {
      this._add("Q", e, t, r, i);
    }, n.prototype.arc = function(e, t, r, i, a, s) {
      this.ellipse(e, t, r, r, 0, i, a, s);
    }, n.prototype.ellipse = function(e, t, r, i, a, s, o, l) {
      var u = o - s, c = !l, h = Math.abs(u), d = Fu(h - sh) || (c ? u >= sh : -u >= sh), f = u > 0 ? u % sh : u % sh + sh, p = false;
      d ? p = true : Fu(h) ? p = false : p = f >= nq == !!c;
      var g = e + r * zk(s), m = t + i * Bk(s);
      this._start && this._add("M", g, m);
      var v = Math.round(a * jpe);
      if (d) {
        var y = 1 / this._p, x = (c ? 1 : -1) * (sh - y);
        this._add("A", r, i, v, 1, +c, e + r * zk(s + x), t + i * Bk(s + x)), y > 0.01 && this._add("A", r, i, v, 0, +c, g, m);
      } else {
        var b = e + r * zk(o), w = t + i * Bk(o);
        this._add("A", r, i, v, +p, +c, b, w);
      }
    }, n.prototype.rect = function(e, t, r, i) {
      this._add("M", e, t), this._add("l", r, 0), this._add("l", 0, i), this._add("l", -r, 0), this._add("Z");
    }, n.prototype.closePath = function() {
      this._d.length > 0 && this._add("Z");
    }, n.prototype._add = function(e, t, r, i, a, s, o, l, u) {
      for (var c = [], h = this._p, d = 1; d < arguments.length; d++) {
        var f = arguments[d];
        if (isNaN(f)) {
          this._invalid = true;
          return;
        }
        c.push(Math.round(f * h) / h);
      }
      this._d.push(e + c.join(" ")), this._start = e === "Z";
    }, n.prototype.generateStr = function() {
      this._str = this._invalid ? "" : this._d.join(""), this._d = [];
    }, n.prototype.getStr = function() {
      return this._str;
    }, n;
  }(), NE = "none", Kpe = Math.round;
  function Zpe(n) {
    var e = n.fill;
    return e != null && e !== NE;
  }
  function Qpe(n) {
    var e = n.stroke;
    return e != null && e !== NE;
  }
  var dR = [
    "lineCap",
    "miterLimit",
    "lineJoin"
  ], Jpe = me(dR, function(n) {
    return "stroke-" + n.toLowerCase();
  });
  function ege(n, e, t, r) {
    var i = e.opacity == null ? 1 : e.opacity;
    if (t instanceof oi) {
      n("opacity", i);
      return;
    }
    if (Zpe(e)) {
      var a = A0(e.fill);
      n("fill", a.color);
      var s = e.fillOpacity != null ? e.fillOpacity * a.opacity * i : a.opacity * i;
      s < 1 && n("fill-opacity", s);
    } else n("fill", NE);
    if (Qpe(e)) {
      var o = A0(e.stroke);
      n("stroke", o.color);
      var l = e.strokeNoScale ? t.getLineScale() : 1, u = l ? (e.lineWidth || 0) / l : 0, c = e.strokeOpacity != null ? e.strokeOpacity * o.opacity * i : o.opacity * i, h = e.strokeFirst;
      if (u !== 1 && n("stroke-width", u), h && n("paint-order", h ? "stroke" : "fill"), c < 1 && n("stroke-opacity", c), e.lineDash) {
        var d = xE(t), f = d[0], p = d[1];
        f && (p = Kpe(p || 0), n("stroke-dasharray", f.join(",")), (p || r) && n("stroke-dashoffset", p));
      }
      for (var g = 0; g < dR.length; g++) {
        var m = dR[g];
        if (e[m] !== O_[m]) {
          var v = e[m] || O_[m];
          v && n(Jpe[g], v);
        }
      }
    }
  }
  var iq = "http://www.w3.org/2000/svg", aq = "http://www.w3.org/1999/xlink", tge = "http://www.w3.org/2000/xmlns/", nge = "http://www.w3.org/XML/1998/namespace", SB = "ecmeta_";
  function sq(n) {
    return document.createElementNS(iq, n);
  }
  function Vr(n, e, t, r, i) {
    return {
      tag: n,
      attrs: t || {},
      children: r,
      text: i,
      key: e
    };
  }
  function rge(n, e) {
    var t = [];
    if (e) for (var r in e) {
      var i = e[r], a = r;
      i !== false && (i !== true && i != null && (a += '="' + i + '"'), t.push(a));
    }
    return "<" + n + " " + t.join(" ") + ">";
  }
  function ige(n) {
    return "</" + n + ">";
  }
  function EE(n, e) {
    e = e || {};
    var t = e.newline ? `
` : "";
    function r(i) {
      var a = i.children, s = i.tag, o = i.attrs, l = i.text;
      return rge(s, o) + (s !== "style" ? Hi(l) : l || "") + (a ? "" + t + me(a, function(u) {
        return r(u);
      }).join(t) + t : "") + ige(s);
    }
    return r(n);
  }
  function age(n, e, t) {
    t = t || {};
    var r = t.newline ? `
` : "", i = " {" + r, a = r + "}", s = me(Mt(n), function(l) {
      return l + i + me(Mt(n[l]), function(u) {
        return u + ":" + n[l][u] + ";";
      }).join(r) + a;
    }).join(r), o = me(Mt(e), function(l) {
      return "@keyframes " + l + i + me(Mt(e[l]), function(u) {
        return u + i + me(Mt(e[l][u]), function(c) {
          var h = e[l][u][c];
          return c === "d" && (h = 'path("' + h + '")'), c + ":" + h + ";";
        }).join(r) + a;
      }).join(r) + a;
    }).join(r);
    return !s && !o ? "" : [
      "<![CDATA[",
      s,
      o,
      "]]>"
    ].join(r);
  }
  function fR(n) {
    return {
      zrId: n,
      shadowCache: {},
      patternCache: {},
      gradientCache: {},
      clipPathCache: {},
      defs: {},
      cssNodes: {},
      cssAnims: {},
      cssStyleCache: {},
      cssAnimIdx: 0,
      shadowIdx: 0,
      gradientIdx: 0,
      patternIdx: 0,
      clipPathIdx: 0
    };
  }
  function CB(n, e, t, r) {
    return Vr("svg", "root", {
      width: n,
      height: e,
      xmlns: iq,
      "xmlns:xlink": aq,
      version: "1.1",
      baseProfile: "full",
      viewBox: r ? "0 0 " + n + " " + e : false
    }, t);
  }
  var sge = 0;
  function oq() {
    return sge++;
  }
  var IB = {
    cubicIn: "0.32,0,0.67,0",
    cubicOut: "0.33,1,0.68,1",
    cubicInOut: "0.65,0,0.35,1",
    quadraticIn: "0.11,0,0.5,0",
    quadraticOut: "0.5,1,0.89,1",
    quadraticInOut: "0.45,0,0.55,1",
    quarticIn: "0.5,0,0.75,0",
    quarticOut: "0.25,1,0.5,1",
    quarticInOut: "0.76,0,0.24,1",
    quinticIn: "0.64,0,0.78,0",
    quinticOut: "0.22,1,0.36,1",
    quinticInOut: "0.83,0,0.17,1",
    sinusoidalIn: "0.12,0,0.39,0",
    sinusoidalOut: "0.61,1,0.88,1",
    sinusoidalInOut: "0.37,0,0.63,1",
    exponentialIn: "0.7,0,0.84,0",
    exponentialOut: "0.16,1,0.3,1",
    exponentialInOut: "0.87,0,0.13,1",
    circularIn: "0.55,0,1,0.45",
    circularOut: "0,0.55,0.45,1",
    circularInOut: "0.85,0,0.15,1"
  }, gh = "transform-origin";
  function oge(n, e, t) {
    var r = oe({}, n.shape);
    oe(r, e), n.buildPath(t, r);
    var i = new rq();
    return i.reset(W6(n)), t.rebuildPath(i, 1), i.generateStr(), i.getStr();
  }
  function lge(n, e) {
    var t = e.originX, r = e.originY;
    (t || r) && (n[gh] = t + "px " + r + "px");
  }
  var uge = {
    fill: "fill",
    opacity: "opacity",
    lineWidth: "stroke-width",
    lineDashOffset: "stroke-dashoffset"
  };
  function lq(n, e) {
    var t = e.zrId + "-ani-" + e.cssAnimIdx++;
    return e.cssAnims[t] = n, t;
  }
  function cge(n, e, t) {
    var r = n.shape.paths, i = {}, a, s;
    if (P(r, function(l) {
      var u = fR(t.zrId);
      u.animation = true, WC(l, {}, u, true);
      var c = u.cssAnims, h = u.cssNodes, d = Mt(c), f = d.length;
      if (f) {
        s = d[f - 1];
        var p = c[s];
        for (var g in p) {
          var m = p[g];
          i[g] = i[g] || {
            d: ""
          }, i[g].d += m.d || "";
        }
        for (var v in h) {
          var y = h[v].animation;
          y.indexOf(s) >= 0 && (a = y);
        }
      }
    }), !!a) {
      e.d = false;
      var o = lq(i, t);
      return a.replace(s, o);
    }
  }
  function kB(n) {
    return Ie(n) ? IB[n] ? "cubic-bezier(" + IB[n] + ")" : ON(n) ? n : "" : "";
  }
  function WC(n, e, t, r) {
    var i = n.animators, a = i.length, s = [];
    if (n instanceof JN) {
      var o = cge(n, e, t);
      if (o) s.push(o);
      else if (!a) return;
    } else if (!a) return;
    for (var l = {}, u = 0; u < a; u++) {
      var c = i[u], h = [
        c.getMaxTime() / 1e3 + "s"
      ], d = kB(c.getClip().easing), f = c.getDelay();
      d ? h.push(d) : h.push("linear"), f && h.push(f / 1e3 + "s"), c.getLoop() && h.push("infinite");
      var p = h.join(" ");
      l[p] = l[p] || [
        p,
        []
      ], l[p][1].push(c);
    }
    function g(y) {
      var x = y[1], b = x.length, w = {}, _ = {}, S = {}, I = "animation-timing-function";
      function C(re, ae, fe) {
        for (var ce = re.getTracks(), ye = re.getMaxTime(), Le = 0; Le < ce.length; Le++) {
          var Re = ce[Le];
          if (Re.needsAnimate()) {
            var be = Re.keyframes, xe = Re.propName;
            if (fe && (xe = fe(xe)), xe) for (var ot = 0; ot < be.length; ot++) {
              var G = be[ot], q = Math.round(G.time / ye * 100) + "%", ge = kB(G.easing), Fe = G.rawValue;
              (Ie(Fe) || Yt(Fe)) && (ae[q] = ae[q] || {}, ae[q][xe] = G.rawValue, ge && (ae[q][I] = ge));
            }
          }
        }
      }
      for (var T = 0; T < b; T++) {
        var k = x[T], D = k.targetName;
        D ? D === "shape" && C(k, _) : !r && C(k, w);
      }
      for (var R in w) {
        var N = {};
        Y6(N, n), oe(N, w[R]);
        var E = G6(N), A = w[R][I];
        S[R] = E ? {
          transform: E
        } : {}, lge(S[R], N), A && (S[R][I] = A);
      }
      var M, $ = true;
      for (var R in _) {
        S[R] = S[R] || {};
        var L = !M, A = _[R][I];
        L && (M = new nl());
        var F = M.len();
        M.reset(), S[R].d = oge(n, _[R], M);
        var O = M.len();
        if (!L && F !== O) {
          $ = false;
          break;
        }
        A && (S[R][I] = A);
      }
      if (!$) for (var R in S) delete S[R].d;
      if (!r) for (var T = 0; T < b; T++) {
        var k = x[T], D = k.targetName;
        D === "style" && C(k, S, function(ce) {
          return uge[ce];
        });
      }
      for (var z = Mt(S), V = true, H, T = 1; T < z.length; T++) {
        var Y = z[T - 1], le = z[T];
        if (S[Y][gh] !== S[le][gh]) {
          V = false;
          break;
        }
        H = S[Y][gh];
      }
      if (V && H) {
        for (var R in S) S[R][gh] && delete S[R][gh];
        e[gh] = H;
      }
      if (rn(z, function(re) {
        return Mt(S[re]).length > 0;
      }).length) {
        var ve = lq(S, t);
        return ve + " " + y[0] + " both";
      }
    }
    for (var m in l) {
      var o = g(l[m]);
      o && s.push(o);
    }
    if (s.length) {
      var v = t.zrId + "-cls-" + oq();
      t.cssNodes["." + v] = {
        animation: s.join(",")
      }, e.class = v;
    }
  }
  function hge(n, e, t) {
    if (!n.ignore) if (n.isSilent()) {
      var r = {
        "pointer-events": "none"
      };
      TB(r, e, t);
    } else {
      var i = n.states.emphasis && n.states.emphasis.style ? n.states.emphasis.style : {}, a = i.fill;
      if (!a) {
        var s = n.style && n.style.fill, o = n.states.select && n.states.select.style && n.states.select.style.fill, l = n.currentStates.indexOf("select") >= 0 && o || s;
        l && (a = ID(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && n.transform ? n.transform[0] : 1;
        u = u / c;
      }
      var r = {
        cursor: "pointer"
      };
      a && (r.fill = a), i.stroke && (r.stroke = i.stroke), u && (r["stroke-width"] = u), TB(r, e, t);
    }
  }
  function TB(n, e, t, r) {
    var i = JSON.stringify(n), a = t.cssStyleCache[i];
    a || (a = t.zrId + "-cls-" + oq(), t.cssStyleCache[i] = a, t.cssNodes["." + a + ":hover"] = n), e.class = e.class ? e.class + " " + a : a;
  }
  var V0 = Math.round;
  function uq(n) {
    return n && Ie(n.src);
  }
  function cq(n) {
    return n && Xe(n.toDataURL);
  }
  function ME(n, e, t, r) {
    ege(function(i, a) {
      var s = i === "fill" || i === "stroke";
      s && V6(a) ? dq(e, n, i, r) : s && BN(a) ? fq(t, n, i, r) : n[i] = a, s && r.ssr && a === "none" && (n["pointer-events"] = "visible");
    }, e, t, false), yge(t, n, r);
  }
  function PE(n, e) {
    var t = ole(e);
    t && (t.each(function(r, i) {
      r != null && (n[(SB + i).toLowerCase()] = r + "");
    }), e.isSilent() && (n[SB + "silent"] = "true"));
  }
  function AB(n) {
    return Fu(n[0] - 1) && Fu(n[1]) && Fu(n[2]) && Fu(n[3] - 1);
  }
  function dge(n) {
    return Fu(n[4]) && Fu(n[5]);
  }
  function LE(n, e, t) {
    if (e && !(dge(e) && AB(e))) {
      var r = 1e4;
      n.transform = AB(e) ? "translate(" + V0(e[4] * r) / r + " " + V0(e[5] * r) / r + ")" : Doe(e);
    }
  }
  function DB(n, e, t) {
    for (var r = n.points, i = [], a = 0; a < r.length; a++) i.push(V0(r[a][0] * t) / t), i.push(V0(r[a][1] * t) / t);
    e.points = i.join(" ");
  }
  function RB(n) {
    return !n.smooth;
  }
  function fge(n) {
    var e = me(n, function(t) {
      return typeof t == "string" ? [
        t,
        t
      ] : t;
    });
    return function(t, r, i) {
      for (var a = 0; a < e.length; a++) {
        var s = e[a], o = t[s[0]];
        o != null && (r[s[1]] = V0(o * i) / i);
      }
    };
  }
  var pge = {
    circle: [
      fge([
        "cx",
        "cy",
        "r"
      ])
    ],
    polyline: [
      DB,
      RB
    ],
    polygon: [
      DB,
      RB
    ]
  };
  function gge(n) {
    for (var e = n.animators, t = 0; t < e.length; t++) if (e[t].targetName === "shape") return true;
    return false;
  }
  function hq(n, e) {
    var t = n.style, r = n.shape, i = pge[n.type], a = {}, s = e.animation, o = "path", l = n.style.strokePercent, u = e.compress && W6(n) || 4;
    if (i && !e.willUpdate && !(i[1] && !i[1](r)) && !(s && gge(n)) && !(l < 1)) {
      o = n.type;
      var c = Math.pow(10, u);
      i[0](r, a, c);
    } else {
      var h = !n.path || n.shapeChanged();
      n.path || n.createPathProxy();
      var d = n.path;
      h && (d.beginPath(), n.buildPath(d, n.shape), n.pathUpdated());
      var f = d.getVersion(), p = n, g = p.__svgPathBuilder;
      (p.__svgPathVersion !== f || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new rq()), g.reset(u), d.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = f, p.__svgPathStrokePercent = l), a.d = g.getStr();
    }
    return LE(a, n.transform), ME(a, t, n, e), PE(a, n), e.animation && WC(n, a, e), e.emphasis && hge(n, a, e), Vr(o, n.id + "", a);
  }
  function mge(n, e) {
    var t = n.style, r = t.image;
    if (r && !Ie(r) && (uq(r) ? r = r.src : cq(r) && (r = r.toDataURL())), !!r) {
      var i = t.x || 0, a = t.y || 0, s = t.width, o = t.height, l = {
        href: r,
        width: s,
        height: o
      };
      return i && (l.x = i), a && (l.y = a), LE(l, n.transform), ME(l, t, n, e), PE(l, n), e.animation && WC(n, l, e), Vr("image", n.id + "", l);
    }
  }
  function vge(n, e) {
    var t = n.style, r = t.text;
    if (r != null && (r += ""), !(!r || isNaN(t.x) || isNaN(t.y))) {
      var i = t.font || Ju, a = t.x || 0, s = $oe(t.y || 0, pC(i), t.textBaseline), o = Roe[t.textAlign] || t.textAlign, l = {
        "dominant-baseline": "central",
        "text-anchor": o
      };
      if (x8(t)) {
        var u = "", c = t.fontStyle, h = y8(t.fontSize);
        if (!parseFloat(h)) return;
        var d = t.fontFamily || v6, f = t.fontWeight;
        u += "font-size:" + h + ";font-family:" + d + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), f && f !== "normal" && (u += "font-weight:" + f + ";"), l.style = u;
      } else l.style = "font: " + i;
      return r.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), s && (l.y = s), LE(l, n.transform), ME(l, t, n, e), PE(l, n), e.animation && WC(n, l, e), Vr("text", n.id + "", l, void 0, r);
    }
  }
  function $B(n, e) {
    if (n instanceof At) return hq(n, e);
    if (n instanceof oi) return mge(n, e);
    if (n instanceof Eg) return vge(n, e);
  }
  function yge(n, e, t) {
    var r = n.style;
    if (Noe(r)) {
      var i = Eoe(n), a = t.shadowCache, s = a[i];
      if (!s) {
        var o = n.getGlobalScale(), l = o[0], u = o[1];
        if (!l || !u) return;
        var c = r.shadowOffsetX || 0, h = r.shadowOffsetY || 0, d = r.shadowBlur, f = A0(r.shadowColor), p = f.opacity, g = f.color, m = d / 2 / l, v = d / 2 / u, y = m + " " + v;
        s = t.zrId + "-s" + t.shadowIdx++, t.defs[s] = Vr("filter", s, {
          id: s,
          x: "-100%",
          y: "-100%",
          width: "300%",
          height: "300%"
        }, [
          Vr("feDropShadow", "", {
            dx: c / l,
            dy: h / u,
            stdDeviation: y,
            "flood-color": g,
            "flood-opacity": p
          })
        ]), a[i] = s;
      }
      e.filter = fC(s);
    }
  }
  function dq(n, e, t, r) {
    var i = n[t], a, s = {
      gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
    };
    if (B6(i)) a = "linearGradient", s.x1 = i.x, s.y1 = i.y, s.x2 = i.x2, s.y2 = i.y2;
    else if (z6(i)) a = "radialGradient", s.cx = it(i.x, 0.5), s.cy = it(i.y, 0.5), s.r = it(i.r, 0.5);
    else return;
    for (var o = i.colorStops, l = [], u = 0, c = o.length; u < c; ++u) {
      var h = kD(o[u].offset) * 100 + "%", d = o[u].color, f = A0(d), p = f.color, g = f.opacity, m = {
        offset: h
      };
      m["stop-color"] = p, g < 1 && (m["stop-opacity"] = g), l.push(Vr("stop", u + "", m));
    }
    var v = Vr(a, "", s, l), y = EE(v), x = r.gradientCache, b = x[y];
    b || (b = r.zrId + "-g" + r.gradientIdx++, x[y] = b, s.id = b, r.defs[b] = Vr(a, b, s, l)), e[t] = fC(b);
  }
  function fq(n, e, t, r) {
    var i = n.style[t], a = n.getBoundingRect(), s = {}, o = i.repeat, l = o === "no-repeat", u = o === "repeat-x", c = o === "repeat-y", h;
    if (O6(i)) {
      var d = i.imageWidth, f = i.imageHeight, p = void 0, g = i.image;
      if (Ie(g) ? p = g : uq(g) ? p = g.src : cq(g) && (p = g.toDataURL()), typeof Image > "u") {
        var m = "Image width/height must been given explictly in svg-ssr renderer.";
        ta(d, m), ta(f, m);
      } else if (d == null || f == null) {
        var v = function(T, k) {
          if (T) {
            var D = T.elm, R = d || k.width, N = f || k.height;
            T.tag === "pattern" && (u ? (N = 1, R /= a.width) : c && (R = 1, N /= a.height)), T.attrs.width = R, T.attrs.height = N, D && (D.setAttribute("width", R), D.setAttribute("height", N));
          }
        }, y = HN(p, null, n, function(T) {
          l || v(_, T), v(h, T);
        });
        y && y.width && y.height && (d = d || y.width, f = f || y.height);
      }
      h = Vr("image", "img", {
        href: p,
        width: d,
        height: f
      }), s.width = d, s.height = f;
    } else i.svgElement && (h = Qe(i.svgElement), s.width = i.svgWidth, s.height = i.svgHeight);
    if (h) {
      var x, b;
      l ? x = b = 1 : u ? (b = 1, x = s.width / a.width) : c ? (x = 1, b = s.height / a.height) : s.patternUnits = "userSpaceOnUse", x != null && !isNaN(x) && (s.width = x), b != null && !isNaN(b) && (s.height = b);
      var w = G6(i);
      w && (s.patternTransform = w);
      var _ = Vr("pattern", "", s, [
        h
      ]), S = EE(_), I = r.patternCache, C = I[S];
      C || (C = r.zrId + "-p" + r.patternIdx++, I[S] = C, s.id = C, _ = r.defs[C] = Vr("pattern", C, s, [
        h
      ])), e[t] = fC(C);
    }
  }
  function xge(n, e, t) {
    var r = t.clipPathCache, i = t.defs, a = r[n.id];
    if (!a) {
      a = t.zrId + "-c" + t.clipPathIdx++;
      var s = {
        id: a
      };
      r[n.id] = a, i[a] = Vr("clipPath", a, s, [
        hq(n, t)
      ]);
    }
    e["clip-path"] = fC(a);
  }
  function NB(n) {
    return document.createTextNode(n);
  }
  function Ah(n, e, t) {
    n.insertBefore(e, t);
  }
  function EB(n, e) {
    n.removeChild(e);
  }
  function MB(n, e) {
    n.appendChild(e);
  }
  function pq(n) {
    return n.parentNode;
  }
  function gq(n) {
    return n.nextSibling;
  }
  function Vk(n, e) {
    n.textContent = e;
  }
  var PB = 58, bge = 120, wge = Vr("", "");
  function pR(n) {
    return n === void 0;
  }
  function $o(n) {
    return n !== void 0;
  }
  function _ge(n, e, t) {
    for (var r = {}, i = e; i <= t; ++i) {
      var a = n[i].key;
      a !== void 0 && (r[a] = i);
    }
    return r;
  }
  function Ly(n, e) {
    var t = n.key === e.key, r = n.tag === e.tag;
    return r && t;
  }
  function W0(n) {
    var e, t = n.children, r = n.tag;
    if ($o(r)) {
      var i = n.elm = sq(r);
      if (FE(wge, n), de(t)) for (e = 0; e < t.length; ++e) {
        var a = t[e];
        a != null && MB(i, W0(a));
      }
      else $o(n.text) && !Ze(n.text) && MB(i, NB(n.text));
    } else n.elm = NB(n.text);
    return n.elm;
  }
  function mq(n, e, t, r, i) {
    for (; r <= i; ++r) {
      var a = t[r];
      a != null && Ah(n, W0(a), e);
    }
  }
  function rS(n, e, t, r) {
    for (; t <= r; ++t) {
      var i = e[t];
      if (i != null) if ($o(i.tag)) {
        var a = pq(i.elm);
        EB(a, i.elm);
      } else EB(n, i.elm);
    }
  }
  function FE(n, e) {
    var t, r = e.elm, i = n && n.attrs || {}, a = e.attrs || {};
    if (i !== a) {
      for (t in a) {
        var s = a[t], o = i[t];
        o !== s && (s === true ? r.setAttribute(t, "") : s === false ? r.removeAttribute(t) : t === "style" ? r.style.cssText = s : t.charCodeAt(0) !== bge ? r.setAttribute(t, s) : t === "xmlns:xlink" || t === "xmlns" ? r.setAttributeNS(tge, t, s) : t.charCodeAt(3) === PB ? r.setAttributeNS(nge, t, s) : t.charCodeAt(5) === PB ? r.setAttributeNS(aq, t, s) : r.setAttribute(t, s));
      }
      for (t in i) t in a || r.removeAttribute(t);
    }
  }
  function Sge(n, e, t) {
    for (var r = 0, i = 0, a = e.length - 1, s = e[0], o = e[a], l = t.length - 1, u = t[0], c = t[l], h, d, f, p; r <= a && i <= l; ) s == null ? s = e[++r] : o == null ? o = e[--a] : u == null ? u = t[++i] : c == null ? c = t[--l] : Ly(s, u) ? (ig(s, u), s = e[++r], u = t[++i]) : Ly(o, c) ? (ig(o, c), o = e[--a], c = t[--l]) : Ly(s, c) ? (ig(s, c), Ah(n, s.elm, gq(o.elm)), s = e[++r], c = t[--l]) : Ly(o, u) ? (ig(o, u), Ah(n, o.elm, s.elm), o = e[--a], u = t[++i]) : (pR(h) && (h = _ge(e, r, a)), d = h[u.key], pR(d) ? Ah(n, W0(u), s.elm) : (f = e[d], f.tag !== u.tag ? Ah(n, W0(u), s.elm) : (ig(f, u), e[d] = void 0, Ah(n, f.elm, s.elm))), u = t[++i]);
    (r <= a || i <= l) && (r > a ? (p = t[l + 1] == null ? null : t[l + 1].elm, mq(n, p, t, i, l)) : rS(n, e, r, a));
  }
  function ig(n, e) {
    var t = e.elm = n.elm, r = n.children, i = e.children;
    n !== e && (FE(n, e), pR(e.text) ? $o(r) && $o(i) ? r !== i && Sge(t, r, i) : $o(i) ? ($o(n.text) && Vk(t, ""), mq(t, null, i, 0, i.length - 1)) : $o(r) ? rS(t, r, 0, r.length - 1) : $o(n.text) && Vk(t, "") : n.text !== e.text && ($o(r) && rS(t, r, 0, r.length - 1), Vk(t, e.text)));
  }
  function Cge(n, e) {
    if (Ly(n, e)) ig(n, e);
    else {
      var t = n.elm, r = pq(t);
      W0(e), r !== null && (Ah(r, e.elm, gq(t)), rS(r, [
        n
      ], 0, 0));
    }
    return e;
  }
  var Ige = 0, kge = function() {
    function n(e, t, r) {
      if (this.type = "svg", this.refreshHover = LB(), this.configLayer = LB(), this.storage = t, this._opts = r = oe({}, r), this.root = e, this._id = "zr" + Ige++, this._oldVNode = CB(r.width, r.height), e && !r.ssr) {
        var i = this._viewport = document.createElement("div");
        i.style.cssText = "position:relative;overflow:hidden";
        var a = this._svgDom = this._oldVNode.elm = sq("svg");
        FE(null, this._oldVNode), i.appendChild(a), e.appendChild(i);
      }
      this.resize(r.width, r.height);
    }
    return n.prototype.getType = function() {
      return this.type;
    }, n.prototype.getViewportRoot = function() {
      return this._viewport;
    }, n.prototype.getViewportRootOffset = function() {
      var e = this.getViewportRoot();
      if (e) return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
    }, n.prototype.getSvgDom = function() {
      return this._svgDom;
    }, n.prototype.refresh = function() {
      if (this.root) {
        var e = this.renderToVNode({
          willUpdate: true
        });
        e.attrs.style = "position:absolute;left:0;top:0;user-select:none", Cge(this._oldVNode, e), this._oldVNode = e;
      }
    }, n.prototype.renderOneToVNode = function(e) {
      return $B(e, fR(this._id));
    }, n.prototype.renderToVNode = function(e) {
      e = e || {};
      var t = this.storage.getDisplayList(true), r = this._width, i = this._height, a = fR(this._id);
      a.animation = e.animation, a.willUpdate = e.willUpdate, a.compress = e.compress, a.emphasis = e.emphasis, a.ssr = this._opts.ssr;
      var s = [], o = this._bgVNode = Tge(r, i, this._backgroundColor, a);
      o && s.push(o);
      var l = e.compress ? null : this._mainVNode = Vr("g", "main", {}, []);
      this._paintList(t, a, l ? l.children : s), l && s.push(l);
      var u = me(Mt(a.defs), function(d) {
        return a.defs[d];
      });
      if (u.length && s.push(Vr("defs", "defs", {}, u)), e.animation) {
        var c = age(a.cssNodes, a.cssAnims, {
          newline: true
        });
        if (c) {
          var h = Vr("style", "stl", {}, [], c);
          s.push(h);
        }
      }
      return CB(r, i, s, e.useViewBox);
    }, n.prototype.renderToString = function(e) {
      return e = e || {}, EE(this.renderToVNode({
        animation: it(e.cssAnimation, true),
        emphasis: it(e.cssEmphasis, true),
        willUpdate: false,
        compress: true,
        useViewBox: it(e.useViewBox, true)
      }), {
        newline: true
      });
    }, n.prototype.setBackgroundColor = function(e) {
      this._backgroundColor = e;
    }, n.prototype.getSvgRoot = function() {
      return this._mainVNode && this._mainVNode.elm;
    }, n.prototype._paintList = function(e, t, r) {
      for (var i = e.length, a = [], s = 0, o, l, u = 0, c = 0; c < i; c++) {
        var h = e[c];
        if (!h.invisible) {
          var d = h.__clipPaths, f = d && d.length || 0, p = l && l.length || 0, g = void 0;
          for (g = Math.max(f - 1, p - 1); g >= 0 && !(d && l && d[g] === l[g]); g--) ;
          for (var m = p - 1; m > g; m--) s--, o = a[s - 1];
          for (var v = g + 1; v < f; v++) {
            var y = {};
            xge(d[v], y, t);
            var x = Vr("g", "clip-g-" + u++, y, []);
            (o ? o.children : r).push(x), a[s++] = x, o = x;
          }
          l = d;
          var b = $B(h, t);
          b && (o ? o.children : r).push(b);
        }
      }
    }, n.prototype.resize = function(e, t) {
      var r = this._opts, i = this.root, a = this._viewport;
      if (e != null && (r.width = e), t != null && (r.height = t), i && a && (a.style.display = "none", e = vg(i, 0, r), t = vg(i, 1, r), a.style.display = ""), this._width !== e || this._height !== t) {
        if (this._width = e, this._height = t, a) {
          var s = a.style;
          s.width = e + "px", s.height = t + "px";
        }
        if (BN(this._backgroundColor)) this.refresh();
        else {
          var o = this._svgDom;
          o && (o.setAttribute("width", e), o.setAttribute("height", t));
          var l = this._bgVNode && this._bgVNode.elm;
          l && (l.setAttribute("width", e), l.setAttribute("height", t));
        }
      }
    }, n.prototype.getWidth = function() {
      return this._width;
    }, n.prototype.getHeight = function() {
      return this._height;
    }, n.prototype.dispose = function() {
      this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
    }, n.prototype.clear = function() {
      this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
    }, n.prototype.toDataURL = function(e) {
      var t = this.renderToString(), r = "data:image/svg+xml;";
      return e ? (t = Poe(t), t && r + "base64," + t) : r + "charset=UTF-8," + encodeURIComponent(t);
    }, n;
  }();
  function LB(n) {
    return function() {
    };
  }
  function Tge(n, e, t, r) {
    var i;
    if (t && t !== "none") if (i = Vr("rect", "bg", {
      width: n,
      height: e,
      x: "0",
      y: "0"
    }), V6(t)) dq({
      fill: t
    }, i.attrs, "fill", r);
    else if (BN(t)) fq({
      style: {
        fill: t
      },
      dirty: ur,
      getBoundingRect: function() {
        return {
          width: n,
          height: e
        };
      }
    }, i.attrs, "fill", r);
    else {
      var a = A0(t), s = a.color, o = a.opacity;
      i.attrs.fill = s, o < 1 && (i.attrs["fill-opacity"] = o);
    }
    return i;
  }
  function Age(n) {
    n.registerPainter("svg", kge);
  }
  function FB(n, e, t) {
    var r = ec.createCanvas(), i = e.getWidth(), a = e.getHeight(), s = r.style;
    return s && (s.position = "absolute", s.left = "0", s.top = "0", s.width = i + "px", s.height = a + "px", r.setAttribute("data-zr-dom-id", n)), r.width = i * t, r.height = a * t, r;
  }
  var Wk = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      a.motionBlur = false, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = false, a.config = {}, a.incremental = false, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = true, a.__firstTimePaint = true, a.__used = false, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
      var s;
      i = i || L_, typeof t == "string" ? s = FB(t, r, i) : Ze(t) && (s = t, t = s.id), a.id = t, a.dom = s;
      var o = s.style;
      return o && (S6(s), s.onselectstart = function() {
        return false;
      }, o.padding = "0", o.margin = "0", o.borderWidth = "0"), a.painter = r, a.dpr = i, a;
    }
    return e.prototype.getElementCount = function() {
      return this.__endIndex - this.__startIndex;
    }, e.prototype.afterBrush = function() {
      this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
    }, e.prototype.initContext = function() {
      this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
    }, e.prototype.setUnpainted = function() {
      this.__firstTimePaint = true;
    }, e.prototype.createBackBuffer = function() {
      var t = this.dpr;
      this.domBack = FB("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t);
    }, e.prototype.createRepaintRects = function(t, r, i, a) {
      if (this.__firstTimePaint) return this.__firstTimePaint = false, null;
      var s = [], o = this.maxRepaintRectCount, l = false, u = new vt(0, 0, 0, 0);
      function c(y) {
        if (!(!y.isFinite() || y.isZero())) if (s.length === 0) {
          var x = new vt(0, 0, 0, 0);
          x.copy(y), s.push(x);
        } else {
          for (var b = false, w = 1 / 0, _ = 0, S = 0; S < s.length; ++S) {
            var I = s[S];
            if (I.intersect(y)) {
              var C = new vt(0, 0, 0, 0);
              C.copy(I), C.union(y), s[S] = C, b = true;
              break;
            } else if (l) {
              u.copy(y), u.union(I);
              var T = y.width * y.height, k = I.width * I.height, D = u.width * u.height, R = D - T - k;
              R < w && (w = R, _ = S);
            }
          }
          if (l && (s[_].union(y), b = true), !b) {
            var x = new vt(0, 0, 0, 0);
            x.copy(y), s.push(x);
          }
          l || (l = s.length >= o);
        }
      }
      for (var h = this.__startIndex; h < this.__endIndex; ++h) {
        var d = t[h];
        if (d) {
          var f = d.shouldBePainted(i, a, true, true), p = d.__isRendered && (d.__dirty & Uo || !f) ? d.getPrevPaintRect() : null;
          p && c(p);
          var g = f && (d.__dirty & Uo || !d.__isRendered) ? d.getPaintRect() : null;
          g && c(g);
        }
      }
      for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
        var d = r[h], f = d && d.shouldBePainted(i, a, true, true);
        if (d && (!f || !d.__zr) && d.__isRendered) {
          var p = d.getPrevPaintRect();
          p && c(p);
        }
      }
      var m;
      do {
        m = false;
        for (var h = 0; h < s.length; ) {
          if (s[h].isZero()) {
            s.splice(h, 1);
            continue;
          }
          for (var v = h + 1; v < s.length; ) s[h].intersect(s[v]) ? (m = true, s[h].union(s[v]), s.splice(v, 1)) : v++;
          h++;
        }
      } while (m);
      return this._paintRects = s, s;
    }, e.prototype.debugGetPaintRects = function() {
      return (this._paintRects || []).slice();
    }, e.prototype.resize = function(t, r) {
      var i = this.dpr, a = this.dom, s = a.style, o = this.domBack;
      s && (s.width = t + "px", s.height = r + "px"), a.width = t * i, a.height = r * i, o && (o.width = t * i, o.height = r * i, i !== 1 && this.ctxBack.scale(i, i));
    }, e.prototype.clear = function(t, r, i) {
      var a = this.dom, s = this.ctx, o = a.width, l = a.height;
      r = r || this.clearColor;
      var u = this.motionBlur && !t, c = this.lastFrameAlpha, h = this.dpr, d = this;
      u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, o / h, l / h));
      var f = this.domBack;
      function p(g, m, v, y) {
        if (s.clearRect(g, m, v, y), r && r !== "transparent") {
          var x = void 0;
          if (cC(r)) {
            var b = r.global || r.__width === v && r.__height === y;
            x = b && r.__canvasGradient || iR(s, r, {
              x: 0,
              y: 0,
              width: v,
              height: y
            }), r.__canvasGradient = x, r.__width = v, r.__height = y;
          } else Wse(r) && (r.scaleX = r.scaleX || h, r.scaleY = r.scaleY || h, x = aR(s, r, {
            dirty: function() {
              d.setUnpainted(), d.painter.refresh();
            }
          }));
          s.save(), s.fillStyle = x || r, s.fillRect(g, m, v, y), s.restore();
        }
        u && (s.save(), s.globalAlpha = c, s.drawImage(f, g, m, v, y), s.restore());
      }
      !i || u ? p(0, 0, o, l) : i.length && P(i, function(g) {
        p(g.x * h, g.y * h, g.width * h, g.height * h);
      });
    }, e;
  }(Is), OB = 1e5, oh = 314159, H1 = 0.01, Dge = 1e-3;
  function Rge(n) {
    return n ? n.__builtin__ ? true : !(typeof n.resize != "function" || typeof n.refresh != "function") : false;
  }
  function $ge(n, e) {
    var t = document.createElement("div");
    return t.style.cssText = [
      "position:relative",
      "width:" + n + "px",
      "height:" + e + "px",
      "padding:0",
      "margin:0",
      "border-width:0"
    ].join(";") + ";", t;
  }
  var Nge = function() {
    function n(e, t, r, i) {
      this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = false, this.type = "canvas";
      var a = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
      this._opts = r = oe({}, r || {}), this.dpr = r.devicePixelRatio || L_, this._singleCanvas = a, this.root = e;
      var s = e.style;
      s && (S6(e), e.innerHTML = ""), this.storage = t;
      var o = this._zlevelList;
      this._prevDisplayList = [];
      var l = this._layers;
      if (a) {
        var c = e, h = c.width, d = c.height;
        r.width != null && (h = r.width), r.height != null && (d = r.height), this.dpr = r.devicePixelRatio || 1, c.width = h * this.dpr, c.height = d * this.dpr, this._width = h, this._height = d;
        var f = new Wk(c, this, this.dpr);
        f.__builtin__ = true, f.initContext(), l[oh] = f, f.zlevel = oh, o.push(oh), this._domRoot = e;
      } else {
        this._width = vg(e, 0, r), this._height = vg(e, 1, r);
        var u = this._domRoot = $ge(this._width, this._height);
        e.appendChild(u);
      }
    }
    return n.prototype.getType = function() {
      return "canvas";
    }, n.prototype.isSingleCanvas = function() {
      return this._singleCanvas;
    }, n.prototype.getViewportRoot = function() {
      return this._domRoot;
    }, n.prototype.getViewportRootOffset = function() {
      var e = this.getViewportRoot();
      if (e) return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
    }, n.prototype.refresh = function(e) {
      var t = this.storage.getDisplayList(true), r = this._prevDisplayList, i = this._zlevelList;
      this._redrawId = Math.random(), this._paintList(t, r, e, this._redrawId);
      for (var a = 0; a < i.length; a++) {
        var s = i[a], o = this._layers[s];
        if (!o.__builtin__ && o.refresh) {
          var l = a === 0 ? this._backgroundColor : null;
          o.refresh(l);
        }
      }
      return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this;
    }, n.prototype.refreshHover = function() {
      this._paintHoverList(this.storage.getDisplayList(false));
    }, n.prototype._paintHoverList = function(e) {
      var t = e.length, r = this._hoverlayer;
      if (r && r.clear(), !!t) {
        for (var i = {
          inHover: true,
          viewWidth: this._width,
          viewHeight: this._height
        }, a, s = 0; s < t; s++) {
          var o = e[s];
          o.__inHover && (r || (r = this._hoverlayer = this.getLayer(OB)), a || (a = r.ctx, a.save()), Vh(a, o, i, s === t - 1));
        }
        a && a.restore();
      }
    }, n.prototype.getHoverLayer = function() {
      return this.getLayer(OB);
    }, n.prototype.paintOne = function(e, t) {
      eY(e, t);
    }, n.prototype._paintList = function(e, t, r, i) {
      if (this._redrawId === i) {
        r = r || false, this._updateLayerStatus(e);
        var a = this._doPaintList(e, t, r), s = a.finished, o = a.needsRefreshHover;
        if (this._needsManuallyCompositing && this._compositeManually(), o && this._paintHoverList(e), s) this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
        else {
          var l = this;
          $_(function() {
            l._paintList(e, t, r, i);
          });
        }
      }
    }, n.prototype._compositeManually = function() {
      var e = this.getLayer(oh).ctx, t = this._domRoot.width, r = this._domRoot.height;
      e.clearRect(0, 0, t, r), this.eachBuiltinLayer(function(i) {
        i.virtual && e.drawImage(i.dom, 0, 0, t, r);
      });
    }, n.prototype._doPaintList = function(e, t, r) {
      for (var i = this, a = [], s = this._opts.useDirtyRect, o = 0; o < this._zlevelList.length; o++) {
        var l = this._zlevelList[o], u = this._layers[l];
        u.__builtin__ && u !== this._hoverlayer && (u.__dirty || r) && a.push(u);
      }
      for (var c = true, h = false, d = function(g) {
        var m = a[g], v = m.ctx, y = s && m.createRepaintRects(e, t, f._width, f._height), x = r ? m.__startIndex : m.__drawIndex, b = !r && m.incremental && Date.now, w = b && Date.now(), _ = m.zlevel === f._zlevelList[0] ? f._backgroundColor : null;
        if (m.__startIndex === m.__endIndex) m.clear(false, _, y);
        else if (x === m.__startIndex) {
          var S = e[x];
          (!S.incremental || !S.notClear || r) && m.clear(false, _, y);
        }
        x === -1 && (console.error("For some unknown reason. drawIndex is -1"), x = m.__startIndex);
        var I, C = function(R) {
          var N = {
            inHover: false,
            allClipped: false,
            prevEl: null,
            viewWidth: i._width,
            viewHeight: i._height
          };
          for (I = x; I < m.__endIndex; I++) {
            var E = e[I];
            if (E.__inHover && (h = true), i._doPaintEl(E, m, s, R, N, I === m.__endIndex - 1), b) {
              var A = Date.now() - w;
              if (A > 15) break;
            }
          }
          N.prevElClipPaths && v.restore();
        };
        if (y) if (y.length === 0) I = m.__endIndex;
        else for (var T = f.dpr, k = 0; k < y.length; ++k) {
          var D = y[k];
          v.save(), v.beginPath(), v.rect(D.x * T, D.y * T, D.width * T, D.height * T), v.clip(), C(D), v.restore();
        }
        else v.save(), C(), v.restore();
        m.__drawIndex = I, m.__drawIndex < m.__endIndex && (c = false);
      }, f = this, p = 0; p < a.length; p++) d(p);
      return Dt.wxa && P(this._layers, function(g) {
        g && g.ctx && g.ctx.draw && g.ctx.draw();
      }), {
        finished: c,
        needsRefreshHover: h
      };
    }, n.prototype._doPaintEl = function(e, t, r, i, a, s) {
      var o = t.ctx;
      if (r) {
        var l = e.getPaintRect();
        (!i || l && l.intersect(i)) && (Vh(o, e, a, s), e.setPrevPaintRect(l));
      } else Vh(o, e, a, s);
    }, n.prototype.getLayer = function(e, t) {
      this._singleCanvas && !this._needsManuallyCompositing && (e = oh);
      var r = this._layers[e];
      return r || (r = new Wk("zr_" + e, this, this.dpr), r.zlevel = e, r.__builtin__ = true, this._layerConfig[e] ? pt(r, this._layerConfig[e], true) : this._layerConfig[e - H1] && pt(r, this._layerConfig[e - H1], true), t && (r.virtual = t), this.insertLayer(e, r), r.initContext()), r;
    }, n.prototype.insertLayer = function(e, t) {
      var r = this._layers, i = this._zlevelList, a = i.length, s = this._domRoot, o = null, l = -1;
      if (!r[e] && Rge(t)) {
        if (a > 0 && e > i[0]) {
          for (l = 0; l < a - 1 && !(i[l] < e && i[l + 1] > e); l++) ;
          o = r[i[l]];
        }
        if (i.splice(l + 1, 0, e), r[e] = t, !t.virtual) if (o) {
          var u = o.dom;
          u.nextSibling ? s.insertBefore(t.dom, u.nextSibling) : s.appendChild(t.dom);
        } else s.firstChild ? s.insertBefore(t.dom, s.firstChild) : s.appendChild(t.dom);
        t.painter || (t.painter = this);
      }
    }, n.prototype.eachLayer = function(e, t) {
      for (var r = this._zlevelList, i = 0; i < r.length; i++) {
        var a = r[i];
        e.call(t, this._layers[a], a);
      }
    }, n.prototype.eachBuiltinLayer = function(e, t) {
      for (var r = this._zlevelList, i = 0; i < r.length; i++) {
        var a = r[i], s = this._layers[a];
        s.__builtin__ && e.call(t, s, a);
      }
    }, n.prototype.eachOtherLayer = function(e, t) {
      for (var r = this._zlevelList, i = 0; i < r.length; i++) {
        var a = r[i], s = this._layers[a];
        s.__builtin__ || e.call(t, s, a);
      }
    }, n.prototype.getLayers = function() {
      return this._layers;
    }, n.prototype._updateLayerStatus = function(e) {
      this.eachBuiltinLayer(function(h, d) {
        h.__dirty = h.__used = false;
      });
      function t(h) {
        a && (a.__endIndex !== h && (a.__dirty = true), a.__endIndex = h);
      }
      if (this._singleCanvas) for (var r = 1; r < e.length; r++) {
        var i = e[r];
        if (i.zlevel !== e[r - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
      var a = null, s = 0, o, l;
      for (l = 0; l < e.length; l++) {
        var i = e[l], u = i.zlevel, c = void 0;
        o !== u && (o = u, s = 0), i.incremental ? (c = this.getLayer(u + Dge, this._needsManuallyCompositing), c.incremental = true, s = 1) : c = this.getLayer(u + (s > 0 ? H1 : 0), this._needsManuallyCompositing), c.__builtin__ || $N("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = true, c.__startIndex !== l && (c.__dirty = true), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, t(l), a = c), i.__dirty & Uo && !i.__inHover && (c.__dirty = true, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
      }
      t(l), this.eachBuiltinLayer(function(h, d) {
        !h.__used && h.getElementCount() > 0 && (h.__dirty = true, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
      });
    }, n.prototype.clear = function() {
      return this.eachBuiltinLayer(this._clearLayer), this;
    }, n.prototype._clearLayer = function(e) {
      e.clear();
    }, n.prototype.setBackgroundColor = function(e) {
      this._backgroundColor = e, P(this._layers, function(t) {
        t.setUnpainted();
      });
    }, n.prototype.configLayer = function(e, t) {
      if (t) {
        var r = this._layerConfig;
        r[e] ? pt(r[e], t, true) : r[e] = t;
        for (var i = 0; i < this._zlevelList.length; i++) {
          var a = this._zlevelList[i];
          if (a === e || a === e + H1) {
            var s = this._layers[a];
            pt(s, r[e], true);
          }
        }
      }
    }, n.prototype.delLayer = function(e) {
      var t = this._layers, r = this._zlevelList, i = t[e];
      i && (i.dom.parentNode.removeChild(i.dom), delete t[e], r.splice(bt(r, e), 1));
    }, n.prototype.resize = function(e, t) {
      if (this._domRoot.style) {
        var r = this._domRoot;
        r.style.display = "none";
        var i = this._opts, a = this.root;
        if (e != null && (i.width = e), t != null && (i.height = t), e = vg(a, 0, i), t = vg(a, 1, i), r.style.display = "", this._width !== e || t !== this._height) {
          r.style.width = e + "px", r.style.height = t + "px";
          for (var s in this._layers) this._layers.hasOwnProperty(s) && this._layers[s].resize(e, t);
          this.refresh(true);
        }
        this._width = e, this._height = t;
      } else {
        if (e == null || t == null) return;
        this._width = e, this._height = t, this.getLayer(oh).resize(e, t);
      }
      return this;
    }, n.prototype.clearLayer = function(e) {
      var t = this._layers[e];
      t && t.clear();
    }, n.prototype.dispose = function() {
      this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
    }, n.prototype.getRenderedCanvas = function(e) {
      if (e = e || {}, this._singleCanvas && !this._compositeManually) return this._layers[oh].dom;
      var t = new Wk("image", this, e.pixelRatio || this.dpr);
      t.initContext(), t.clear(false, e.backgroundColor || this._backgroundColor);
      var r = t.ctx;
      if (e.pixelRatio <= this.dpr) {
        this.refresh();
        var i = t.dom.width, a = t.dom.height;
        this.eachLayer(function(h) {
          h.__builtin__ ? r.drawImage(h.dom, 0, 0, i, a) : h.renderToCanvas && (r.save(), h.renderToCanvas(r), r.restore());
        });
      } else for (var s = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      }, o = this.storage.getDisplayList(true), l = 0, u = o.length; l < u; l++) {
        var c = o[l];
        Vh(r, c, s, l === u - 1);
      }
      return t.dom;
    }, n.prototype.getWidth = function() {
      return this._width;
    }, n.prototype.getHeight = function() {
      return this._height;
    }, n;
  }();
  function Ege(n) {
    n.registerPainter("canvas", Nge);
  }
  var Mge = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.getInitialData = function(t) {
      return au(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getLegendIcon = function(t) {
      var r = new tt(), i = xr("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, false);
      r.add(i), i.setStyle(t.lineStyle);
      var a = this.getData().getVisual("symbol"), s = this.getData().getVisual("symbolRotate"), o = a === "none" ? "circle" : a, l = t.itemHeight * 0.8, u = xr(o, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill);
      r.add(u), u.setStyle(t.itemStyle);
      var c = t.iconRotate === "inherit" ? s : t.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([
        t.itemWidth / 2,
        t.itemHeight / 2
      ]), o.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), r;
    }, e.type = "series.line", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = {
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      clip: true,
      label: {
        position: "top"
      },
      endLabel: {
        show: false,
        valueAnimation: true,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: true
      },
      step: false,
      smooth: false,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: true,
      showAllSymbol: "auto",
      connectNulls: false,
      sampling: "none",
      animationEasing: "linear",
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: false
    }, e;
  }(En);
  function Og(n, e) {
    var t = n.mapDimensionsAll("defaultedLabel"), r = t.length;
    if (r === 1) {
      var i = Pg(n, e, t[0]);
      return i != null ? i + "" : null;
    } else if (r) {
      for (var a = [], s = 0; s < t.length; s++) a.push(Pg(n, e, t[s]));
      return a.join(" ");
    }
  }
  function vq(n, e) {
    var t = n.mapDimensionsAll("defaultedLabel");
    if (!de(e)) return e + "";
    for (var r = [], i = 0; i < t.length; i++) {
      var a = n.getDimensionIndex(t[i]);
      a >= 0 && r.push(e[a]);
    }
    return r.join(" ");
  }
  var Wx = function(n) {
    K(e, n);
    function e(t, r, i, a) {
      var s = n.call(this) || this;
      return s.updateData(t, r, i, a), s;
    }
    return e.prototype._createSymbol = function(t, r, i, a, s) {
      this.removeAll();
      var o = xr(t, -1, -1, 2, 2, null, s);
      o.attr({
        z2: 100,
        culling: true,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), o.drift = Pge, this._symbolType = t, this.add(o);
    }, e.prototype.stopSymbolAnimation = function(t) {
      this.childAt(0).stopAnimation(null, t);
    }, e.prototype.getSymbolType = function() {
      return this._symbolType;
    }, e.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, e.prototype.highlight = function() {
      Xl(this.childAt(0));
    }, e.prototype.downplay = function() {
      Yl(this.childAt(0));
    }, e.prototype.setZ = function(t, r) {
      var i = this.childAt(0);
      i.zlevel = t, i.z = r;
    }, e.prototype.setDraggable = function(t, r) {
      var i = this.childAt(0);
      i.draggable = t, i.cursor = !r && t ? "move" : i.cursor;
    }, e.prototype.updateData = function(t, r, i, a) {
      this.silent = false;
      var s = t.getItemVisual(r, "symbol") || "circle", o = t.hostModel, l = e.getSymbolSize(t, r), u = s !== this._symbolType, c = a && a.disableAnimation;
      if (u) {
        var h = t.getItemVisual(r, "symbolKeepAspect");
        this._createSymbol(s, t, r, l, h);
      } else {
        var d = this.childAt(0);
        d.silent = false;
        var f = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? d.attr(f) : Kt(d, f, o, r), ro(d);
      }
      if (this._updateCommon(t, r, l, i, a), u) {
        var d = this.childAt(0);
        if (!c) {
          var f = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              opacity: d.style.opacity
            }
          };
          d.scaleX = d.scaleY = 0, d.style.opacity = 0, Un(d, f, o, r);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, e.prototype._updateCommon = function(t, r, i, a, s) {
      var o = this.childAt(0), l = t.hostModel, u, c, h, d, f, p, g, m, v;
      if (a && (u = a.emphasisItemStyle, c = a.blurItemStyle, h = a.selectItemStyle, d = a.focus, f = a.blurScope, g = a.labelStatesModels, m = a.hoverScale, v = a.cursorStyle, p = a.emphasisDisabled), !a || t.hasItemOption) {
        var y = a && a.itemModel ? a.itemModel : t.getItemModel(r), x = y.getModel("emphasis");
        u = x.getModel("itemStyle").getItemStyle(), h = y.getModel([
          "select",
          "itemStyle"
        ]).getItemStyle(), c = y.getModel([
          "blur",
          "itemStyle"
        ]).getItemStyle(), d = x.get("focus"), f = x.get("blurScope"), p = x.get("disabled"), g = Hr(y), m = x.getShallow("scale"), v = y.getShallow("cursor");
      }
      var b = t.getItemVisual(r, "symbolRotate");
      o.attr("rotation", (b || 0) * Math.PI / 180 || 0);
      var w = Fd(t.getItemVisual(r, "symbolOffset"), i);
      w && (o.x = w[0], o.y = w[1]), v && o.attr("cursor", v);
      var _ = t.getItemVisual(r, "style"), S = _.fill;
      if (o instanceof oi) {
        var I = o.style;
        o.useStyle(oe({
          image: I.image,
          x: I.x,
          y: I.y,
          width: I.width,
          height: I.height
        }, _));
      } else o.__isEmptyBrush ? o.useStyle(oe({}, _)) : o.useStyle(_), o.style.decal = null, o.setColor(S, s && s.symbolInnerColor), o.style.strokeNoScale = true;
      var C = t.getItemVisual(r, "liftZ"), T = this._z2;
      C != null ? T == null && (this._z2 = o.z2, o.z2 += C) : T != null && (o.z2 = T, this._z2 = null);
      var k = s && s.useNameLabel;
      gi(o, g, {
        labelFetcher: l,
        labelDataIndex: r,
        defaultText: D,
        inheritColor: S,
        defaultOpacity: _.opacity
      });
      function D(E) {
        return k ? t.getName(E) : Og(t, E);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var R = o.ensureState("emphasis");
      R.style = u, o.ensureState("select").style = h, o.ensureState("blur").style = c;
      var N = m == null || m === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(m) && m > 0 ? +m : 1;
      R.scaleX = this._sizeX * N, R.scaleY = this._sizeY * N, this.setSymbolScale(1), Qn(this, d, f, p);
    }, e.prototype.setSymbolScale = function(t) {
      this.scaleX = this.scaleY = t;
    }, e.prototype.fadeOut = function(t, r, i) {
      var a = this.childAt(0), s = rt(this).dataIndex, o = i && i.animation;
      if (this.silent = a.silent = true, i && i.fadeLabel) {
        var l = a.getTextContent();
        l && nc(l, {
          style: {
            opacity: 0
          }
        }, r, {
          dataIndex: s,
          removeOpt: o,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else a.removeTextContent();
      nc(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, r, {
        dataIndex: s,
        cb: t,
        removeOpt: o
      });
    }, e.getSymbolSize = function(t, r) {
      return Cm(t.getItemVisual(r, "symbolSize"));
    }, e;
  }(tt);
  function Pge(n, e) {
    this.parent.drift(n, e);
  }
  function Gk(n, e, t, r) {
    return e && !isNaN(e[0]) && !isNaN(e[1]) && !(r.isIgnore && r.isIgnore(t)) && !(r.clipShape && !r.clipShape.contain(e[0], e[1])) && n.getItemVisual(t, "symbol") !== "none";
  }
  function BB(n) {
    return n != null && !Ze(n) && (n = {
      isIgnore: n
    }), n || {};
  }
  function zB(n) {
    var e = n.hostModel, t = e.getModel("emphasis");
    return {
      emphasisItemStyle: t.getModel("itemStyle").getItemStyle(),
      blurItemStyle: e.getModel([
        "blur",
        "itemStyle"
      ]).getItemStyle(),
      selectItemStyle: e.getModel([
        "select",
        "itemStyle"
      ]).getItemStyle(),
      focus: t.get("focus"),
      blurScope: t.get("blurScope"),
      emphasisDisabled: t.get("disabled"),
      hoverScale: t.get("scale"),
      labelStatesModels: Hr(e),
      cursorStyle: e.get("cursor")
    };
  }
  var Gx = function() {
    function n(e) {
      this.group = new tt(), this._SymbolCtor = e || Wx;
    }
    return n.prototype.updateData = function(e, t) {
      this._progressiveEls = null, t = BB(t);
      var r = this.group, i = e.hostModel, a = this._data, s = this._SymbolCtor, o = t.disableAnimation, l = zB(e), u = {
        disableAnimation: o
      }, c = t.getSymbolPoint || function(h) {
        return e.getItemLayout(h);
      };
      a || r.removeAll(), e.diff(a).add(function(h) {
        var d = c(h);
        if (Gk(e, d, h, t)) {
          var f = new s(e, h, l, u);
          f.setPosition(d), e.setItemGraphicEl(h, f), r.add(f);
        }
      }).update(function(h, d) {
        var f = a.getItemGraphicEl(d), p = c(h);
        if (!Gk(e, p, h, t)) {
          r.remove(f);
          return;
        }
        var g = e.getItemVisual(h, "symbol") || "circle", m = f && f.getSymbolType && f.getSymbolType();
        if (!f || m && m !== g) r.remove(f), f = new s(e, h, l, u), f.setPosition(p);
        else {
          f.updateData(e, h, l, u);
          var v = {
            x: p[0],
            y: p[1]
          };
          o ? f.attr(v) : Kt(f, v, i);
        }
        r.add(f), e.setItemGraphicEl(h, f);
      }).remove(function(h) {
        var d = a.getItemGraphicEl(h);
        d && d.fadeOut(function() {
          r.remove(d);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = e;
    }, n.prototype.updateLayout = function() {
      var e = this, t = this._data;
      t && t.eachItemGraphicEl(function(r, i) {
        var a = e._getSymbolPoint(i);
        r.setPosition(a), r.markRedraw();
      });
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = zB(e), this._data = null, this.group.removeAll();
    }, n.prototype.incrementalUpdate = function(e, t, r) {
      this._progressiveEls = [], r = BB(r);
      function i(l) {
        l.isGroup || (l.incremental = true, l.ensureState("emphasis").hoverLayer = true);
      }
      for (var a = e.start; a < e.end; a++) {
        var s = t.getItemLayout(a);
        if (Gk(t, s, a, r)) {
          var o = new this._SymbolCtor(t, a, this._seriesScope);
          o.traverse(i), o.setPosition(s), this.group.add(o), t.setItemGraphicEl(a, o), this._progressiveEls.push(o);
        }
      }
    }, n.prototype.eachRendered = function(e) {
      gc(this._progressiveEls || this.group, e);
    }, n.prototype.remove = function(e) {
      var t = this.group, r = this._data;
      r && e ? r.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          t.remove(i);
        }, r.hostModel);
      }) : t.removeAll();
    }, n;
  }();
  function yq(n, e, t) {
    var r = n.getBaseAxis(), i = n.getOtherAxis(r), a = Lge(i, t), s = r.dim, o = i.dim, l = e.mapDimension(o), u = e.mapDimension(s), c = o === "x" || o === "radius" ? 1 : 0, h = me(n.dimensions, function(p) {
      return e.mapDimension(p);
    }), d = false, f = e.getCalculationInfo("stackResultDimension");
    return ic(e, h[0]) && (d = true, h[0] = f), ic(e, h[1]) && (d = true, h[1] = f), {
      dataDimsForPoint: h,
      valueStart: a,
      valueAxisDim: o,
      baseAxisDim: s,
      stacked: !!d,
      valueDim: l,
      baseDim: u,
      baseDataOffset: c,
      stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
    };
  }
  function Lge(n, e) {
    var t = 0, r = n.scale.getExtent();
    return e === "start" ? t = r[0] : e === "end" ? t = r[1] : Yt(e) && !isNaN(e) ? t = e : r[0] > 0 ? t = r[0] : r[1] < 0 && (t = r[1]), t;
  }
  function xq(n, e, t, r) {
    var i = NaN;
    n.stacked && (i = t.get(t.getCalculationInfo("stackedOverDimension"), r)), isNaN(i) && (i = n.valueStart);
    var a = n.baseDataOffset, s = [];
    return s[a] = t.get(n.baseDim, r), s[1 - a] = i, e.dataToPoint(s);
  }
  function Fge(n, e) {
    var t = [];
    return e.diff(n).add(function(r) {
      t.push({
        cmd: "+",
        idx: r
      });
    }).update(function(r, i) {
      t.push({
        cmd: "=",
        idx: i,
        idx1: r
      });
    }).remove(function(r) {
      t.push({
        cmd: "-",
        idx: r
      });
    }).execute(), t;
  }
  function Oge(n, e, t, r, i, a, s, o) {
    for (var l = Fge(n, e), u = [], c = [], h = [], d = [], f = [], p = [], g = [], m = yq(i, e, s), v = n.getLayout("points") || [], y = e.getLayout("points") || [], x = 0; x < l.length; x++) {
      var b = l[x], w = true, _ = void 0, S = void 0;
      switch (b.cmd) {
        case "=":
          _ = b.idx * 2, S = b.idx1 * 2;
          var I = v[_], C = v[_ + 1], T = y[S], k = y[S + 1];
          (isNaN(I) || isNaN(C)) && (I = T, C = k), u.push(I, C), c.push(T, k), h.push(t[_], t[_ + 1]), d.push(r[S], r[S + 1]), g.push(e.getRawIndex(b.idx1));
          break;
        case "+":
          var D = b.idx, R = m.dataDimsForPoint, N = i.dataToPoint([
            e.get(R[0], D),
            e.get(R[1], D)
          ]);
          S = D * 2, u.push(N[0], N[1]), c.push(y[S], y[S + 1]);
          var E = xq(m, i, e, D);
          h.push(E[0], E[1]), d.push(r[S], r[S + 1]), g.push(e.getRawIndex(D));
          break;
        case "-":
          w = false;
      }
      w && (f.push(b), p.push(p.length));
    }
    p.sort(function(Y, le) {
      return g[Y] - g[le];
    });
    for (var A = u.length, M = zo(A), $ = zo(A), L = zo(A), F = zo(A), O = [], x = 0; x < p.length; x++) {
      var z = p[x], V = x * 2, H = z * 2;
      M[V] = u[H], M[V + 1] = u[H + 1], $[V] = c[H], $[V + 1] = c[H + 1], L[V] = h[H], L[V + 1] = h[H + 1], F[V] = d[H], F[V + 1] = d[H + 1], O[x] = f[z];
    }
    return {
      current: M,
      next: $,
      stackedOnCurrent: L,
      stackedOnNext: F,
      status: O
    };
  }
  var bu = Math.min, wu = Math.max;
  function td(n, e) {
    return isNaN(n) || isNaN(e);
  }
  function gR(n, e, t, r, i, a, s, o, l) {
    for (var u, c, h, d, f, p, g = t, m = 0; m < r; m++) {
      var v = e[g * 2], y = e[g * 2 + 1];
      if (g >= i || g < 0) break;
      if (td(v, y)) {
        if (l) {
          g += a;
          continue;
        }
        break;
      }
      if (g === t) n[a > 0 ? "moveTo" : "lineTo"](v, y), h = v, d = y;
      else {
        var x = v - u, b = y - c;
        if (x * x + b * b < 0.5) {
          g += a;
          continue;
        }
        if (s > 0) {
          for (var w = g + a, _ = e[w * 2], S = e[w * 2 + 1]; _ === v && S === y && m < r; ) m++, w += a, g += a, _ = e[w * 2], S = e[w * 2 + 1], v = e[g * 2], y = e[g * 2 + 1], x = v - u, b = y - c;
          var I = m + 1;
          if (l) for (; td(_, S) && I < r; ) I++, w += a, _ = e[w * 2], S = e[w * 2 + 1];
          var C = 0.5, T = 0, k = 0, D = void 0, R = void 0;
          if (I >= r || td(_, S)) f = v, p = y;
          else {
            T = _ - u, k = S - c;
            var N = v - u, E = _ - v, A = y - c, M = S - y, $ = void 0, L = void 0;
            if (o === "x") {
              $ = Math.abs(N), L = Math.abs(E);
              var F = T > 0 ? 1 : -1;
              f = v - F * $ * s, p = y, D = v + F * L * s, R = y;
            } else if (o === "y") {
              $ = Math.abs(A), L = Math.abs(M);
              var O = k > 0 ? 1 : -1;
              f = v, p = y - O * $ * s, D = v, R = y + O * L * s;
            } else $ = Math.sqrt(N * N + A * A), L = Math.sqrt(E * E + M * M), C = L / (L + $), f = v - T * s * (1 - C), p = y - k * s * (1 - C), D = v + T * s * C, R = y + k * s * C, D = bu(D, wu(_, v)), R = bu(R, wu(S, y)), D = wu(D, bu(_, v)), R = wu(R, bu(S, y)), T = D - v, k = R - y, f = v - T * $ / L, p = y - k * $ / L, f = bu(f, wu(u, v)), p = bu(p, wu(c, y)), f = wu(f, bu(u, v)), p = wu(p, bu(c, y)), T = v - f, k = y - p, D = v + T * L / $, R = y + k * L / $;
          }
          n.bezierCurveTo(h, d, f, p, v, y), h = D, d = R;
        } else n.lineTo(v, y);
      }
      u = v, c = y, g += a;
    }
    return m;
  }
  var bq = /* @__PURE__ */ function() {
    function n() {
      this.smooth = 0, this.smoothConstraint = true;
    }
    return n;
  }(), Bge = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-polyline", r;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new bq();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, a = 0, s = i.length / 2;
      if (r.connectNulls) {
        for (; s > 0 && td(i[s * 2 - 2], i[s * 2 - 1]); s--) ;
        for (; a < s && td(i[a * 2], i[a * 2 + 1]); a++) ;
      }
      for (; a < s; ) a += gR(t, i, a, s, s, 1, r.smooth, r.smoothMonotone, r.connectNulls) + 1;
    }, e.prototype.getPointOn = function(t, r) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, a = i.data, s = nl.CMD, o, l, u = r === "x", c = [], h = 0; h < a.length; ) {
        var d = a[h++], f = void 0, p = void 0, g = void 0, m = void 0, v = void 0, y = void 0, x = void 0;
        switch (d) {
          case s.M:
            o = a[h++], l = a[h++];
            break;
          case s.L:
            if (f = a[h++], p = a[h++], x = u ? (t - o) / (f - o) : (t - l) / (p - l), x <= 1 && x >= 0) {
              var b = u ? (p - l) * x + l : (f - o) * x + o;
              return u ? [
                t,
                b
              ] : [
                b,
                t
              ];
            }
            o = f, l = p;
            break;
          case s.C:
            f = a[h++], p = a[h++], g = a[h++], m = a[h++], v = a[h++], y = a[h++];
            var w = u ? N_(o, f, g, v, t, c) : N_(l, p, m, y, t, c);
            if (w > 0) for (var _ = 0; _ < w; _++) {
              var S = c[_];
              if (S <= 1 && S >= 0) {
                var b = u ? Fr(l, p, m, y, S) : Fr(o, f, g, v, S);
                return u ? [
                  t,
                  b
                ] : [
                  b,
                  t
                ];
              }
            }
            o = v, l = y;
            break;
        }
      }
    }, e;
  }(At), zge = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e;
  }(bq), wq = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-polygon", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new zge();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, a = r.stackedOnPoints, s = 0, o = i.length / 2, l = r.smoothMonotone;
      if (r.connectNulls) {
        for (; o > 0 && td(i[o * 2 - 2], i[o * 2 - 1]); o--) ;
        for (; s < o && td(i[s * 2], i[s * 2 + 1]); s++) ;
      }
      for (; s < o; ) {
        var u = gR(t, i, s, o, o, 1, r.smooth, l, r.connectNulls);
        gR(t, a, s + u - 1, u, o, -1, r.stackedOnSmooth, l, r.connectNulls), s += u + 1, t.closePath();
      }
    }, e;
  }(At);
  function _q(n, e, t, r, i) {
    var a = n.getArea(), s = a.x, o = a.y, l = a.width, u = a.height, c = t.get([
      "lineStyle",
      "width"
    ]) || 0;
    s -= c / 2, o -= c / 2, l += c, u += c, l = Math.ceil(l), s !== Math.floor(s) && (s = Math.floor(s), l++);
    var h = new Vt({
      shape: {
        x: s,
        y: o,
        width: l,
        height: u
      }
    });
    if (e) {
      var d = n.getBaseAxis(), f = d.isHorizontal(), p = d.inverse;
      f ? (p && (h.shape.x += l), h.shape.width = 0) : (p || (h.shape.y += u), h.shape.height = 0);
      var g = Xe(i) ? function(m) {
        i(m, h);
      } : null;
      Un(h, {
        shape: {
          width: l,
          height: u,
          x: s,
          y: o
        }
      }, t, null, r, g);
    }
    return h;
  }
  function Sq(n, e, t) {
    var r = n.getArea(), i = rr(r.r0, 1), a = rr(r.r, 1), s = new ra({
      shape: {
        cx: rr(n.cx, 1),
        cy: rr(n.cy, 1),
        r0: i,
        r: a,
        startAngle: r.startAngle,
        endAngle: r.endAngle,
        clockwise: r.clockwise
      }
    });
    if (e) {
      var o = n.getBaseAxis().dim === "angle";
      o ? s.shape.endAngle = r.startAngle : s.shape.r = i, Un(s, {
        shape: {
          endAngle: r.endAngle,
          r: a
        }
      }, t);
    }
    return s;
  }
  function Ux(n, e, t, r, i) {
    if (n) {
      if (n.type === "polar") return Sq(n, e, t);
      if (n.type === "cartesian2d") return _q(n, e, t, r, i);
    } else return null;
    return null;
  }
  function Bd(n, e) {
    return n.type === e;
  }
  function VB(n, e) {
    if (n.length === e.length) {
      for (var t = 0; t < n.length; t++) if (n[t] !== e[t]) return;
      return true;
    }
  }
  function WB(n) {
    for (var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, a = 0; a < n.length; ) {
      var s = n[a++], o = n[a++];
      isNaN(s) || (e = Math.min(s, e), r = Math.max(s, r)), isNaN(o) || (t = Math.min(o, t), i = Math.max(o, i));
    }
    return [
      [
        e,
        t
      ],
      [
        r,
        i
      ]
    ];
  }
  function GB(n, e) {
    var t = WB(n), r = t[0], i = t[1], a = WB(e), s = a[0], o = a[1];
    return Math.max(Math.abs(r[0] - s[0]), Math.abs(r[1] - s[1]), Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1]));
  }
  function UB(n) {
    return Yt(n) ? n : n ? 0.5 : 0;
  }
  function Vge(n, e, t) {
    if (!t.valueDim) return [];
    for (var r = e.count(), i = zo(r * 2), a = 0; a < r; a++) {
      var s = xq(t, n, e, a);
      i[a * 2] = s[0], i[a * 2 + 1] = s[1];
    }
    return i;
  }
  function _u(n, e, t, r, i) {
    var a = t.getBaseAxis(), s = a.dim === "x" || a.dim === "radius" ? 0 : 1, o = [], l = 0, u = [], c = [], h = [], d = [];
    if (i) {
      for (l = 0; l < n.length; l += 2) {
        var f = e || n;
        !isNaN(f[l]) && !isNaN(f[l + 1]) && d.push(n[l], n[l + 1]);
      }
      n = d;
    }
    for (l = 0; l < n.length - 2; l += 2) switch (h[0] = n[l + 2], h[1] = n[l + 3], c[0] = n[l], c[1] = n[l + 1], o.push(c[0], c[1]), r) {
      case "end":
        u[s] = h[s], u[1 - s] = c[1 - s], o.push(u[0], u[1]);
        break;
      case "middle":
        var p = (c[s] + h[s]) / 2, g = [];
        u[s] = g[s] = p, u[1 - s] = c[1 - s], g[1 - s] = h[1 - s], o.push(u[0], u[1]), o.push(g[0], g[1]);
        break;
      default:
        u[s] = c[s], u[1 - s] = h[1 - s], o.push(u[0], u[1]);
    }
    return o.push(n[l++], n[l++]), o;
  }
  function Wge(n, e) {
    var t = [], r = n.length, i, a;
    function s(c, h, d) {
      var f = c.coord, p = (d - f) / (h.coord - f), g = Toe(p, [
        c.color,
        h.color
      ]);
      return {
        coord: d,
        color: g
      };
    }
    for (var o = 0; o < r; o++) {
      var l = n[o], u = l.coord;
      if (u < 0) i = l;
      else if (u > e) {
        a ? t.push(s(a, l, e)) : i && t.push(s(i, l, 0), s(i, l, e));
        break;
      } else i && (t.push(s(i, l, 0)), i = null), t.push(l), a = l;
    }
    return t;
  }
  function Gge(n, e, t) {
    var r = n.getVisual("visualMeta");
    if (!(!r || !r.length || !n.count()) && e.type === "cartesian2d") {
      for (var i, a, s = r.length - 1; s >= 0; s--) {
        var o = n.getDimensionInfo(r[s].dimension);
        if (i = o && o.coordDim, i === "x" || i === "y") {
          a = r[s];
          break;
        }
      }
      if (a) {
        var l = e.getAxis(i), u = me(a.stops, function(x) {
          return {
            coord: l.toGlobalCoord(l.dataToCoord(x.value)),
            color: x.color
          };
        }), c = u.length, h = a.outerColors.slice();
        c && u[0].coord > u[c - 1].coord && (u.reverse(), h.reverse());
        var d = Wge(u, i === "x" ? t.getWidth() : t.getHeight()), f = d.length;
        if (!f && c) return u[0].coord < 0 ? h[1] ? h[1] : u[c - 1].color : h[0] ? h[0] : u[0].color;
        var p = 10, g = d[0].coord - p, m = d[f - 1].coord + p, v = m - g;
        if (v < 1e-3) return "transparent";
        P(d, function(x) {
          x.offset = (x.coord - g) / v;
        }), d.push({
          offset: f ? d[f - 1].offset : 0.5,
          color: h[1] || "transparent"
        }), d.unshift({
          offset: f ? d[0].offset : 0.5,
          color: h[0] || "transparent"
        });
        var y = new Px(0, 0, 0, 0, d, true);
        return y[i] = g, y[i + "2"] = m, y;
      }
    }
  }
  function Uge(n, e, t) {
    var r = n.get("showAllSymbol"), i = r === "auto";
    if (!(r && !i)) {
      var a = t.getAxesByScale("ordinal")[0];
      if (a && !(i && Hge(a, e))) {
        var s = e.mapDimension(a.dim), o = {};
        return P(a.getViewLabels(), function(l) {
          var u = a.scale.getRawOrdinalNumber(l.tickValue);
          o[u] = 1;
        }), function(l) {
          return !o.hasOwnProperty(e.get(s, l));
        };
      }
    }
  }
  function Hge(n, e) {
    var t = n.getExtent(), r = Math.abs(t[1] - t[0]) / n.scale.count();
    isNaN(r) && (r = 0);
    for (var i = e.count(), a = Math.max(1, Math.round(i / 5)), s = 0; s < i; s += a) if (Wx.getSymbolSize(e, s)[n.isHorizontal() ? 1 : 0] * 1.5 > r) return false;
    return true;
  }
  function Xge(n, e) {
    return isNaN(n) || isNaN(e);
  }
  function Yge(n) {
    for (var e = n.length / 2; e > 0 && Xge(n[e * 2 - 2], n[e * 2 - 1]); e--) ;
    return e - 1;
  }
  function HB(n, e) {
    return [
      n[e * 2],
      n[e * 2 + 1]
    ];
  }
  function qge(n, e, t) {
    for (var r = n.length / 2, i = t === "x" ? 0 : 1, a, s, o = 0, l = -1, u = 0; u < r; u++) if (s = n[u * 2 + i], !(isNaN(s) || isNaN(n[u * 2 + 1 - i]))) {
      if (u === 0) {
        a = s;
        continue;
      }
      if (a <= e && s >= e || a >= e && s <= e) {
        l = u;
        break;
      }
      o = u, a = s;
    }
    return {
      range: [
        o,
        l
      ],
      t: (e - a) / (s - a)
    };
  }
  function Cq(n) {
    if (n.get([
      "endLabel",
      "show"
    ])) return true;
    for (var e = 0; e < na.length; e++) if (n.get([
      na[e],
      "endLabel",
      "show"
    ])) return true;
    return false;
  }
  function Uk(n, e, t, r) {
    if (Bd(e, "cartesian2d")) {
      var i = r.getModel("endLabel"), a = i.get("valueAnimation"), s = r.getData(), o = {
        lastFrameIndex: 0
      }, l = Cq(r) ? function(f, p) {
        n._endLabelOnDuring(f, p, s, o, a, i, e);
      } : null, u = e.getBaseAxis().isHorizontal(), c = _q(e, t, r, function() {
        var f = n._endLabel;
        f && t && o.originalX != null && f.attr({
          x: o.originalX,
          y: o.originalY
        });
      }, l);
      if (!r.get("clip", true)) {
        var h = c.shape, d = Math.max(h.width, h.height);
        u ? (h.y -= d, h.height += d * 2) : (h.x -= d, h.width += d * 2);
      }
      return l && l(1, c), c;
    } else return Sq(e, t, r);
  }
  function jge(n, e) {
    var t = e.getBaseAxis(), r = t.isHorizontal(), i = t.inverse, a = r ? i ? "right" : "left" : "center", s = r ? "middle" : i ? "top" : "bottom";
    return {
      normal: {
        align: n.get("align") || a,
        verticalAlign: n.get("verticalAlign") || s
      }
    };
  }
  var Kge = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      var t = new tt(), r = new Gx();
      this.group.add(r.group), this._symbolDraw = r, this._lineGroup = t, this._changePolyState = Ae(this._changePolyState, this);
    }, e.prototype.render = function(t, r, i) {
      var a = t.coordinateSystem, s = this.group, o = t.getData(), l = t.getModel("lineStyle"), u = t.getModel("areaStyle"), c = o.getLayout("points") || [], h = a.type === "polar", d = this._coordSys, f = this._symbolDraw, p = this._polyline, g = this._polygon, m = this._lineGroup, v = !r.ssr && t.get("animation"), y = !u.isEmpty(), x = u.get("origin"), b = yq(a, o, x), w = y && Vge(a, o, b), _ = t.get("showSymbol"), S = t.get("connectNulls"), I = _ && !h && Uge(t, o, a), C = this._data;
      C && C.eachItemGraphicEl(function(Y, le) {
        Y.__temp && (s.remove(Y), C.setItemGraphicEl(le, null));
      }), _ || f.remove(), s.add(m);
      var T = h ? false : t.get("step"), k;
      a && a.getArea && t.get("clip", true) && (k = a.getArea(), k.width != null ? (k.x -= 0.1, k.y -= 0.1, k.width += 0.2, k.height += 0.2) : k.r0 && (k.r0 -= 0.5, k.r += 0.5)), this._clipShapeForSymbol = k;
      var D = Gge(o, a, i) || o.getVisual("style")[o.getVisual("drawType")];
      if (!(p && d.type === a.type && T === this._step)) _ && f.updateData(o, {
        isIgnore: I,
        clipShape: k,
        disableAnimation: true,
        getSymbolPoint: function(Y) {
          return [
            c[Y * 2],
            c[Y * 2 + 1]
          ];
        }
      }), v && this._initSymbolLabelAnimation(o, a, k), T && (w && (w = _u(w, c, a, T, S)), c = _u(c, null, a, T, S)), p = this._newPolyline(c), y ? g = this._newPolygon(c, w) : g && (m.remove(g), g = this._polygon = null), h || this._initOrUpdateEndLabel(t, a, fd(D)), m.setClipPath(Uk(this, a, true, t));
      else {
        y && !g ? g = this._newPolygon(c, w) : g && !y && (m.remove(g), g = this._polygon = null), h || this._initOrUpdateEndLabel(t, a, fd(D));
        var R = m.getClipPath();
        if (R) {
          var N = Uk(this, a, false, t);
          Un(R, {
            shape: N.shape
          }, t);
        } else m.setClipPath(Uk(this, a, true, t));
        _ && f.updateData(o, {
          isIgnore: I,
          clipShape: k,
          disableAnimation: true,
          getSymbolPoint: function(Y) {
            return [
              c[Y * 2],
              c[Y * 2 + 1]
            ];
          }
        }), (!VB(this._stackedOnPoints, w) || !VB(this._points, c)) && (v ? this._doUpdateAnimation(o, w, a, i, T, x, S) : (T && (w && (w = _u(w, c, a, T, S)), c = _u(c, null, a, T, S)), p.setShape({
          points: c
        }), g && g.setShape({
          points: c,
          stackedOnPoints: w
        })));
      }
      var E = t.getModel("emphasis"), A = E.get("focus"), M = E.get("blurScope"), $ = E.get("disabled");
      if (p.useStyle(je(l.getLineStyle(), {
        fill: "none",
        stroke: D,
        lineJoin: "bevel"
      })), pi(p, t, "lineStyle"), p.style.lineWidth > 0 && t.get([
        "emphasis",
        "lineStyle",
        "width"
      ]) === "bolder") {
        var L = p.getState("emphasis").style;
        L.lineWidth = +p.style.lineWidth + 1;
      }
      rt(p).seriesIndex = t.seriesIndex, Qn(p, A, M, $);
      var F = UB(t.get("smooth")), O = t.get("smoothMonotone");
      if (p.setShape({
        smooth: F,
        smoothMonotone: O,
        connectNulls: S
      }), g) {
        var z = o.getCalculationInfo("stackedOnSeries"), V = 0;
        g.useStyle(je(u.getAreaStyle(), {
          fill: D,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: o.getVisual("style").decal
        })), z && (V = UB(z.get("smooth"))), g.setShape({
          smooth: F,
          stackedOnSmooth: V,
          smoothMonotone: O,
          connectNulls: S
        }), pi(g, t, "areaStyle"), rt(g).seriesIndex = t.seriesIndex, Qn(g, A, M, $);
      }
      var H = this._changePolyState;
      o.eachItemGraphicEl(function(Y) {
        Y && (Y.onHoverStateChange = H);
      }), this._polyline.onHoverStateChange = H, this._data = o, this._coordSys = a, this._stackedOnPoints = w, this._points = c, this._step = T, this._valueOrigin = x, t.get("triggerLineEvent") && (this.packEventData(t, p), g && this.packEventData(t, g));
    }, e.prototype.packEventData = function(t, r) {
      rt(r).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: t.componentIndex,
        seriesIndex: t.seriesIndex,
        seriesName: t.name,
        seriesType: "line"
      };
    }, e.prototype.highlight = function(t, r, i, a) {
      var s = t.getData(), o = cd(s, a);
      if (this._changePolyState("emphasis"), !(o instanceof Array) && o != null && o >= 0) {
        var l = s.getLayout("points"), u = s.getItemGraphicEl(o);
        if (!u) {
          var c = l[o * 2], h = l[o * 2 + 1];
          if (isNaN(c) || isNaN(h) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, h)) return;
          var d = t.get("zlevel") || 0, f = t.get("z") || 0;
          u = new Wx(s, o), u.x = c, u.y = h, u.setZ(d, f);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = d, p.z = f, p.z2 = this._polyline.z2 + 1), u.__temp = true, s.setItemGraphicEl(o, u), u.stopSymbolAnimation(true), this.group.add(u);
        }
        u.highlight();
      } else _n.prototype.highlight.call(this, t, r, i, a);
    }, e.prototype.downplay = function(t, r, i, a) {
      var s = t.getData(), o = cd(s, a);
      if (this._changePolyState("normal"), o != null && o >= 0) {
        var l = s.getItemGraphicEl(o);
        l && (l.__temp ? (s.setItemGraphicEl(o, null), this.group.remove(l)) : l.downplay());
      } else _n.prototype.downplay.call(this, t, r, i, a);
    }, e.prototype._changePolyState = function(t) {
      var r = this._polygon;
      B_(this._polyline, t), r && B_(r, t);
    }, e.prototype._newPolyline = function(t) {
      var r = this._polyline;
      return r && this._lineGroup.remove(r), r = new Bge({
        shape: {
          points: t
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(r), this._polyline = r, r;
    }, e.prototype._newPolygon = function(t, r) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new wq({
        shape: {
          points: t,
          stackedOnPoints: r
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, e.prototype._initSymbolLabelAnimation = function(t, r, i) {
      var a, s, o = r.getBaseAxis(), l = o.inverse;
      r.type === "cartesian2d" ? (a = o.isHorizontal(), s = false) : r.type === "polar" && (a = o.dim === "angle", s = true);
      var u = t.hostModel, c = u.get("animationDuration");
      Xe(c) && (c = c(null));
      var h = u.get("animationDelay") || 0, d = Xe(h) ? h(null) : h;
      t.eachItemGraphicEl(function(f, p) {
        var g = f;
        if (g) {
          var m = [
            f.x,
            f.y
          ], v = void 0, y = void 0, x = void 0;
          if (i) if (s) {
            var b = i, w = r.pointToCoord(m);
            a ? (v = b.startAngle, y = b.endAngle, x = -w[1] / 180 * Math.PI) : (v = b.r0, y = b.r, x = w[0]);
          } else {
            var _ = i;
            a ? (v = _.x, y = _.x + _.width, x = f.x) : (v = _.y + _.height, y = _.y, x = f.y);
          }
          var S = y === v ? 0 : (x - v) / (y - v);
          l && (S = 1 - S);
          var I = Xe(h) ? h(p) : c * S + d, C = g.getSymbolPath(), T = C.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: true,
            delay: I
          }), T && T.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: I
          }), C.disableLabelAnimation = true;
        }
      });
    }, e.prototype._initOrUpdateEndLabel = function(t, r, i) {
      var a = t.getModel("endLabel");
      if (Cq(t)) {
        var s = t.getData(), o = this._polyline, l = s.getLayout("points");
        if (!l) {
          o.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new Gt({
          z2: 200
        }), u.ignoreClip = true, o.setTextContent(this._endLabel), o.disableLabelAnimation = true);
        var c = Yge(l);
        c >= 0 && (gi(o, Hr(t, "endLabel"), {
          inheritColor: i,
          labelFetcher: t,
          labelDataIndex: c,
          defaultText: function(h, d, f) {
            return f != null ? vq(s, f) : Og(s, h);
          },
          enableTextSetter: true
        }, jge(a, r)), o.textConfig.position = null);
      } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, e.prototype._endLabelOnDuring = function(t, r, i, a, s, o, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        t < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var h = i.getLayout("points"), d = i.hostModel, f = d.get("connectNulls"), p = o.get("precision"), g = o.get("distance") || 0, m = l.getBaseAxis(), v = m.isHorizontal(), y = m.inverse, x = r.shape, b = y ? v ? x.x : x.y + x.height : v ? x.x + x.width : x.y, w = (v ? g : 0) * (y ? -1 : 1), _ = (v ? 0 : -g) * (y ? -1 : 1), S = v ? "x" : "y", I = qge(h, b, S), C = I.range, T = C[1] - C[0], k = void 0;
        if (T >= 1) {
          if (T > 1 && !f) {
            var D = HB(h, C[0]);
            u.attr({
              x: D[0] + w,
              y: D[1] + _
            }), s && (k = d.getRawValue(C[0]));
          } else {
            var D = c.getPointOn(b, S);
            D && u.attr({
              x: D[0] + w,
              y: D[1] + _
            });
            var R = d.getRawValue(C[0]), N = d.getRawValue(C[1]);
            s && (k = l8(i, p, R, N, I.t));
          }
          a.lastFrameIndex = C[0];
        } else {
          var E = t === 1 || a.lastFrameIndex > 0 ? C[0] : 0, D = HB(h, E);
          s && (k = d.getRawValue(E)), u.attr({
            x: D[0] + w,
            y: D[1] + _
          });
        }
        if (s) {
          var A = vm(u);
          typeof A.setLabelText == "function" && A.setLabelText(k);
        }
      }
    }, e.prototype._doUpdateAnimation = function(t, r, i, a, s, o, l) {
      var u = this._polyline, c = this._polygon, h = t.hostModel, d = Oge(this._data, t, this._stackedOnPoints, r, this._coordSys, i, this._valueOrigin), f = d.current, p = d.stackedOnCurrent, g = d.next, m = d.stackedOnNext;
      if (s && (p = _u(d.stackedOnCurrent, d.current, i, s, l), f = _u(d.current, null, i, s, l), m = _u(d.stackedOnNext, d.next, i, s, l), g = _u(d.next, null, i, s, l)), GB(f, g) > 3e3 || c && GB(p, m) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), c && (c.stopAnimation(), c.setShape({
          points: g,
          stackedOnPoints: m
        }));
        return;
      }
      u.shape.__points = d.current, u.shape.points = f;
      var v = {
        shape: {
          points: g
        }
      };
      d.current !== f && (v.shape.__points = d.next), u.stopAnimation(), Kt(u, v, h), c && (c.setShape({
        points: f,
        stackedOnPoints: p
      }), c.stopAnimation(), Kt(c, {
        shape: {
          stackedOnPoints: m
        }
      }, h), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], x = d.status, b = 0; b < x.length; b++) {
        var w = x[b].cmd;
        if (w === "=") {
          var _ = t.getItemGraphicEl(x[b].idx1);
          _ && y.push({
            el: _,
            ptIdx: b
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var S = u.shape.__points, I = 0; I < y.length; I++) {
          var C = y[I].el, T = y[I].ptIdx * 2;
          C.x = S[T], C.y = S[T + 1], C.markRedraw();
        }
      });
    }, e.prototype.remove = function(t) {
      var r = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(true), i && i.eachItemGraphicEl(function(a, s) {
        a.__temp && (r.remove(a), i.setItemGraphicEl(s, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, e.type = "line", e;
  }(_n);
  function Hx(n, e) {
    return {
      seriesType: n,
      plan: _m(),
      reset: function(t) {
        var r = t.getData(), i = t.coordinateSystem, a = t.pipelineContext, s = e || a.large;
        if (i) {
          var o = me(i.dimensions, function(f) {
            return r.mapDimension(f);
          }).slice(0, 2), l = o.length, u = r.getCalculationInfo("stackResultDimension");
          ic(r, o[0]) && (o[0] = u), ic(r, o[1]) && (o[1] = u);
          var c = r.getStore(), h = r.getDimensionIndex(o[0]), d = r.getDimensionIndex(o[1]);
          return l && {
            progress: function(f, p) {
              for (var g = f.end - f.start, m = s && zo(g * l), v = [], y = [], x = f.start, b = 0; x < f.end; x++) {
                var w = void 0;
                if (l === 1) {
                  var _ = c.get(h, x);
                  w = i.dataToPoint(_, null, y);
                } else v[0] = c.get(h, x), v[1] = c.get(d, x), w = i.dataToPoint(v, null, y);
                s ? (m[b++] = w[0], m[b++] = w[1]) : p.setItemLayout(x, w.slice());
              }
              s && p.setLayout("points", m);
            }
          };
        }
      }
    };
  }
  var Zge = {
    average: function(n) {
      for (var e = 0, t = 0, r = 0; r < n.length; r++) isNaN(n[r]) || (e += n[r], t++);
      return t === 0 ? NaN : e / t;
    },
    sum: function(n) {
      for (var e = 0, t = 0; t < n.length; t++) e += n[t] || 0;
      return e;
    },
    max: function(n) {
      for (var e = -1 / 0, t = 0; t < n.length; t++) n[t] > e && (e = n[t]);
      return isFinite(e) ? e : NaN;
    },
    min: function(n) {
      for (var e = 1 / 0, t = 0; t < n.length; t++) n[t] < e && (e = n[t]);
      return isFinite(e) ? e : NaN;
    },
    nearest: function(n) {
      return n[0];
    }
  }, Qge = function(n) {
    return Math.round(n.length / 2);
  };
  function Iq(n) {
    return {
      seriesType: n,
      reset: function(e, t, r) {
        var i = e.getData(), a = e.get("sampling"), s = e.coordinateSystem, o = i.count();
        if (o > 10 && s.type === "cartesian2d" && a) {
          var l = s.getBaseAxis(), u = s.getOtherAxis(l), c = l.getExtent(), h = r.getDevicePixelRatio(), d = Math.abs(c[1] - c[0]) * (h || 1), f = Math.round(o / d);
          if (isFinite(f) && f > 1) {
            a === "lttb" ? e.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / f)) : a === "minmax" && e.setData(i.minmaxDownSample(i.mapDimension(u.dim), 1 / f));
            var p = void 0;
            Ie(a) ? p = Zge[a] : Xe(a) && (p = a), p && e.setData(i.downSample(i.mapDimension(u.dim), 1 / f, p, Qge));
          }
        }
      }
    };
  }
  function Jge(n) {
    n.registerChartView(Kge), n.registerSeriesModel(Mge), n.registerLayout(Hx("line", true)), n.registerVisual({
      seriesType: "line",
      reset: function(e) {
        var t = e.getData(), r = e.getModel("lineStyle").getLineStyle();
        r && !r.stroke && (r.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", r);
      }
    }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, Iq("line"));
  }
  var G0 = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return au(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getMarkerPosition = function(t, r, i) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var s = a.clampData(t), o = a.dataToPoint(s);
        if (i) P(a.getAxes(), function(d, f) {
          if (d.type === "category" && r != null) {
            var p = d.getTicksCoords(), g = d.getTickModel().get("alignWithLabel"), m = s[f], v = r[f] === "x1" || r[f] === "y1";
            if (v && !g && (m += 1), p.length < 2) return;
            if (p.length === 2) {
              o[f] = d.toGlobalCoord(d.getExtent()[v ? 1 : 0]);
              return;
            }
            for (var y = void 0, x = void 0, b = 1, w = 0; w < p.length; w++) {
              var _ = p[w].coord, S = w === p.length - 1 ? p[w - 1].tickValue + b : p[w].tickValue;
              if (S === m) {
                x = _;
                break;
              } else if (S < m) y = _;
              else if (y != null && S > m) {
                x = (_ + y) / 2;
                break;
              }
              w === 1 && (b = S - p[0].tickValue);
            }
            x == null && (y ? y && (x = p[p.length - 1].coord) : x = p[0].coord), o[f] = d.toGlobalCoord(x);
          }
        });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), h = a.getBaseAxis().isHorizontal() ? 0 : 1;
          o[h] += u + c / 2;
        }
        return o;
      }
      return [
        NaN,
        NaN
      ];
    }, e.type = "series.__base_bar__", e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      barMinHeight: 0,
      barMinAngle: 0,
      large: false,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, e;
  }(En);
  En.registerClass(G0);
  var eme = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function() {
      return au(null, this, {
        useEncodeDefaulter: true,
        createInvertedIndices: !!this.get("realtimeSort", true) || null
      });
    }, e.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : false;
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.get("progressiveThreshold"), r = this.get("largeThreshold");
      return r > t && (t = r), t;
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.rect(r.getItemLayout(t));
    }, e.type = "series.bar", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = mc(G0.defaultOption, {
      clip: true,
      roundCap: false,
      showBackground: false,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: false
    }), e;
  }(G0), tme = /* @__PURE__ */ function() {
    function n() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = true;
    }
    return n;
  }(), iS = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "sausage", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new tme();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.cx, a = r.cy, s = Math.max(r.r0 || 0, 0), o = Math.max(r.r, 0), l = (o - s) * 0.5, u = s + l, c = r.startAngle, h = r.endAngle, d = r.clockwise, f = Math.PI * 2, p = d ? h - c < f : c - h < f;
      p || (c = h - (d ? f : -f));
      var g = Math.cos(c), m = Math.sin(c), v = Math.cos(h), y = Math.sin(h);
      p ? (t.moveTo(g * s + i, m * s + a), t.arc(g * u + i, m * u + a, l, -Math.PI + c, c, !d)) : t.moveTo(g * o + i, m * o + a), t.arc(i, a, o, c, h, !d), t.arc(v * u + i, y * u + a, l, h - Math.PI * 2, h - Math.PI, !d), s !== 0 && t.arc(i, a, s, h, c, d);
    }, e;
  }(At);
  function nme(n, e) {
    e = e || {};
    var t = e.isRoundCap;
    return function(r, i, a) {
      var s = i.position;
      if (!s || s instanceof Array) return F_(r, i, a);
      var o = n(s), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, h = u.cy, d = u.r, f = u.r0, p = (d + f) / 2, g = u.startAngle, m = u.endAngle, v = (g + m) / 2, y = t ? Math.abs(d - f) / 2 : 0, x = Math.cos, b = Math.sin, w = c + d * x(g), _ = h + d * b(g), S = "left", I = "top";
      switch (o) {
        case "startArc":
          w = c + (f - l) * x(v), _ = h + (f - l) * b(v), S = "center", I = "top";
          break;
        case "insideStartArc":
          w = c + (f + l) * x(v), _ = h + (f + l) * b(v), S = "center", I = "bottom";
          break;
        case "startAngle":
          w = c + p * x(g) + X1(g, l + y, false), _ = h + p * b(g) + Y1(g, l + y, false), S = "right", I = "middle";
          break;
        case "insideStartAngle":
          w = c + p * x(g) + X1(g, -l + y, false), _ = h + p * b(g) + Y1(g, -l + y, false), S = "left", I = "middle";
          break;
        case "middle":
          w = c + p * x(v), _ = h + p * b(v), S = "center", I = "middle";
          break;
        case "endArc":
          w = c + (d + l) * x(v), _ = h + (d + l) * b(v), S = "center", I = "bottom";
          break;
        case "insideEndArc":
          w = c + (d - l) * x(v), _ = h + (d - l) * b(v), S = "center", I = "top";
          break;
        case "endAngle":
          w = c + p * x(m) + X1(m, l + y, true), _ = h + p * b(m) + Y1(m, l + y, true), S = "left", I = "middle";
          break;
        case "insideEndAngle":
          w = c + p * x(m) + X1(m, -l + y, true), _ = h + p * b(m) + Y1(m, -l + y, true), S = "right", I = "middle";
          break;
        default:
          return F_(r, i, a);
      }
      return r = r || {}, r.x = w, r.y = _, r.align = S, r.verticalAlign = I, r;
    };
  }
  function rme(n, e, t, r) {
    if (Yt(r)) {
      n.setTextConfig({
        rotation: r
      });
      return;
    } else if (de(e)) {
      n.setTextConfig({
        rotation: 0
      });
      return;
    }
    var i = n.shape, a = i.clockwise ? i.startAngle : i.endAngle, s = i.clockwise ? i.endAngle : i.startAngle, o = (a + s) / 2, l, u = t(e);
    switch (u) {
      case "startArc":
      case "insideStartArc":
      case "middle":
      case "insideEndArc":
      case "endArc":
        l = o;
        break;
      case "startAngle":
      case "insideStartAngle":
        l = a;
        break;
      case "endAngle":
      case "insideEndAngle":
        l = s;
        break;
      default:
        n.setTextConfig({
          rotation: 0
        });
        return;
    }
    var c = Math.PI * 1.5 - l;
    u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), n.setTextConfig({
      rotation: c
    });
  }
  function X1(n, e, t) {
    return e * Math.sin(n) * (t ? -1 : 1);
  }
  function Y1(n, e, t) {
    return e * Math.cos(n) * (t ? 1 : -1);
  }
  function Wh(n, e, t) {
    var r = n.get("borderRadius");
    if (r == null) return t ? {
      cornerRadius: 0
    } : null;
    de(r) || (r = [
      r,
      r,
      r,
      r
    ]);
    var i = Math.abs(e.r || 0 - e.r0 || 0);
    return {
      cornerRadius: me(r, function(a) {
        return no(a, i);
      })
    };
  }
  var Hk = Math.max, Xk = Math.min;
  function ime(n, e) {
    var t = n.getArea && n.getArea();
    if (Bd(n, "cartesian2d")) {
      var r = n.getBaseAxis();
      if (r.type !== "category" || !r.onBand) {
        var i = e.getLayout("bandWidth");
        r.isHorizontal() ? (t.x -= i, t.width += i * 2) : (t.y -= i, t.height += i * 2);
      }
    }
    return t;
  }
  var ame = function(n) {
    K(e, n);
    function e() {
      var t = n.call(this) || this;
      return t.type = e.type, t._isFirstFrame = true, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this._model = t, this._removeOnRenderedListener(i), this._updateDrawMode(t);
      var s = t.get("coordinateSystem");
      (s === "cartesian2d" || s === "polar") && (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, r, i) : this._renderNormal(t, r, i, a));
    }, e.prototype.incrementalPrepareRender = function(t) {
      this._clear(), this._updateDrawMode(t), this._updateLargeClip(t);
    }, e.prototype.incrementalRender = function(t, r) {
      this._progressiveEls = [], this._incrementalRenderLarge(t, r);
    }, e.prototype.eachRendered = function(t) {
      gc(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var r = t.pipelineContext.large;
      (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear());
    }, e.prototype._renderNormal = function(t, r, i, a) {
      var s = this.group, o = t.getData(), l = this._data, u = t.coordinateSystem, c = u.getBaseAxis(), h;
      u.type === "cartesian2d" ? h = c.isHorizontal() : u.type === "polar" && (h = c.dim === "angle");
      var d = t.isAnimationEnabled() ? t : null, f = sme(t, u);
      f && this._enableRealtimeSort(f, o, i);
      var p = t.get("clip", true) || f, g = ime(u, o);
      s.removeClipPath();
      var m = t.get("roundCap", true), v = t.get("showBackground", true), y = t.getModel("backgroundStyle"), x = y.get("borderRadius") || 0, b = [], w = this._backgroundEls, _ = a && a.isInitSort, S = a && a.type === "changeAxisOrder";
      function I(k) {
        var D = q1[u.type](o, k), R = fme(u, h, D);
        return R.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? R.setShape("r", x) : R.setShape("cornerRadius", x), b[k] = R, R;
      }
      o.diff(l).add(function(k) {
        var D = o.getItemModel(k), R = q1[u.type](o, k, D);
        if (v && I(k), !(!o.hasValue(k) || !KB[u.type](R))) {
          var N = false;
          p && (N = XB[u.type](g, R));
          var E = YB[u.type](t, o, k, R, h, d, c.model, false, m);
          f && (E.forceLabelAnimation = true), ZB(E, o, k, D, R, t, h, u.type === "polar"), _ ? E.attr({
            shape: R
          }) : f ? qB(f, d, E, R, k, h, false, false) : Un(E, {
            shape: R
          }, t, k), o.setItemGraphicEl(k, E), s.add(E), E.ignore = N;
        }
      }).update(function(k, D) {
        var R = o.getItemModel(k), N = q1[u.type](o, k, R);
        if (v) {
          var E = void 0;
          w.length === 0 ? E = I(D) : (E = w[D], E.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? E.setShape("r", x) : E.setShape("cornerRadius", x), b[k] = E);
          var A = q1[u.type](o, k), M = Tq(h, A, u);
          Kt(E, {
            shape: M
          }, d, k);
        }
        var $ = l.getItemGraphicEl(D);
        if (!o.hasValue(k) || !KB[u.type](N)) {
          s.remove($);
          return;
        }
        var L = false;
        if (p && (L = XB[u.type](g, N), L && s.remove($)), $ ? ro($) : $ = YB[u.type](t, o, k, N, h, d, c.model, !!$, m), f && ($.forceLabelAnimation = true), S) {
          var F = $.getTextContent();
          if (F) {
            var O = vm(F);
            O.prevValue != null && (O.prevValue = O.value);
          }
        } else ZB($, o, k, R, N, t, h, u.type === "polar");
        _ ? $.attr({
          shape: N
        }) : f ? qB(f, d, $, N, k, h, true, S) : Kt($, {
          shape: N
        }, t, k, null), o.setItemGraphicEl(k, $), $.ignore = L, s.add($);
      }).remove(function(k) {
        var D = l.getItemGraphicEl(k);
        D && E0(D, t, k);
      }).execute();
      var C = this._backgroundGroup || (this._backgroundGroup = new tt());
      C.removeAll();
      for (var T = 0; T < b.length; ++T) C.add(b[T]);
      s.add(C), this._backgroundEls = b, this._data = o;
    }, e.prototype._renderLarge = function(t, r, i) {
      this._clear(), JB(t, this.group), this._updateLargeClip(t);
    }, e.prototype._incrementalRenderLarge = function(t, r) {
      this._removeBackground(), JB(r, this.group, this._progressiveEls, true);
    }, e.prototype._updateLargeClip = function(t) {
      var r = t.get("clip", true) && Ux(t.coordinateSystem, false, t), i = this.group;
      r ? i.setClipPath(r) : i.removeClipPath();
    }, e.prototype._enableRealtimeSort = function(t, r, i) {
      var a = this;
      if (r.count()) {
        var s = t.baseAxis;
        if (this._isFirstFrame) this._dispatchInitSort(r, t, i), this._isFirstFrame = false;
        else {
          var o = function(l) {
            var u = r.getItemGraphicEl(l), c = u && u.shape;
            return c && Math.abs(s.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(r, o, s, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, e.prototype._dataSort = function(t, r, i) {
      var a = [];
      return t.each(t.mapDimension(r.dim), function(s, o) {
        var l = i(o);
        l = l ?? NaN, a.push({
          dataIndex: o,
          mappedValue: l,
          ordinalNumber: s
        });
      }), a.sort(function(s, o) {
        return o.mappedValue - s.mappedValue;
      }), {
        ordinalNumbers: me(a, function(s) {
          return s.ordinalNumber;
        })
      };
    }, e.prototype._isOrderChangedWithinSameData = function(t, r, i) {
      for (var a = i.scale, s = t.mapDimension(i.dim), o = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = t.rawIndexOf(s, a.getRawOrdinalNumber(l)), h = c < 0 ? Number.MIN_VALUE : r(t.indexOfRawIndex(c));
        if (h > o) return true;
        o = h;
      }
      return false;
    }, e.prototype._isOrderDifferentInView = function(t, r) {
      for (var i = r.scale, a = i.getExtent(), s = Math.max(0, a[0]), o = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); s <= o; ++s) if (t.ordinalNumbers[s] !== i.getRawOrdinalNumber(s)) return true;
    }, e.prototype._updateSortWithinSameData = function(t, r, i, a) {
      if (this._isOrderChangedWithinSameData(t, r, i)) {
        var s = this._dataSort(t, i, r);
        this._isOrderDifferentInView(s, i) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: s
        }));
      }
    }, e.prototype._dispatchInitSort = function(t, r, i) {
      var a = r.baseAxis, s = this._dataSort(t, a, function(o) {
        return t.get(t.mapDimension(r.otherAxis.dim), o);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: true,
        axisId: a.index,
        sortInfo: s
      });
    }, e.prototype.remove = function(t, r) {
      this._clear(this._model), this._removeOnRenderedListener(r);
    }, e.prototype.dispose = function(t, r) {
      this._removeOnRenderedListener(r);
    }, e.prototype._removeOnRenderedListener = function(t) {
      this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, e.prototype._clear = function(t) {
      var r = this.group, i = this._data;
      t && t.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(a) {
        E0(a, t, rt(a).dataIndex);
      })) : r.removeAll(), this._data = null, this._isFirstFrame = true;
    }, e.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, e.type = "bar", e;
  }(_n), XB = {
    cartesian2d: function(n, e) {
      var t = e.width < 0 ? -1 : 1, r = e.height < 0 ? -1 : 1;
      t < 0 && (e.x += e.width, e.width = -e.width), r < 0 && (e.y += e.height, e.height = -e.height);
      var i = n.x + n.width, a = n.y + n.height, s = Hk(e.x, n.x), o = Xk(e.x + e.width, i), l = Hk(e.y, n.y), u = Xk(e.y + e.height, a), c = o < s, h = u < l;
      return e.x = c && s > i ? o : s, e.y = h && l > a ? u : l, e.width = c ? 0 : o - s, e.height = h ? 0 : u - l, t < 0 && (e.x += e.width, e.width = -e.width), r < 0 && (e.y += e.height, e.height = -e.height), c || h;
    },
    polar: function(n, e) {
      var t = e.r0 <= e.r ? 1 : -1;
      if (t < 0) {
        var r = e.r;
        e.r = e.r0, e.r0 = r;
      }
      var i = Xk(e.r, n.r), a = Hk(e.r0, n.r0);
      e.r = i, e.r0 = a;
      var s = i - a < 0;
      if (t < 0) {
        var r = e.r;
        e.r = e.r0, e.r0 = r;
      }
      return s;
    }
  }, YB = {
    cartesian2d: function(n, e, t, r, i, a, s, o, l) {
      var u = new Vt({
        shape: oe({}, r),
        z2: 1
      });
      if (u.__dataIndex = t, u.name = "item", a) {
        var c = u.shape, h = i ? "height" : "width";
        c[h] = 0;
      }
      return u;
    },
    polar: function(n, e, t, r, i, a, s, o, l) {
      var u = !i && l ? iS : ra, c = new u({
        shape: r,
        z2: 1
      });
      c.name = "item";
      var h = kq(i);
      if (c.calculateTextPosition = nme(h, {
        isRoundCap: u === iS
      }), a) {
        var d = c.shape, f = i ? "r" : "endAngle", p = {};
        d[f] = i ? r.r0 : r.startAngle, p[f] = r[f], (o ? Kt : Un)(c, {
          shape: p
        }, a);
      }
      return c;
    }
  };
  function sme(n, e) {
    var t = n.get("realtimeSort", true), r = e.getBaseAxis();
    if (t && r.type === "category" && e.type === "cartesian2d") return {
      baseAxis: r,
      otherAxis: e.getOtherAxis(r)
    };
  }
  function qB(n, e, t, r, i, a, s, o) {
    var l, u;
    a ? (u = {
      x: r.x,
      width: r.width
    }, l = {
      y: r.y,
      height: r.height
    }) : (u = {
      y: r.y,
      height: r.height
    }, l = {
      x: r.x,
      width: r.width
    }), o || (s ? Kt : Un)(t, {
      shape: l
    }, e, i, null);
    var c = e ? n.baseAxis.model : null;
    (s ? Kt : Un)(t, {
      shape: u
    }, c, i);
  }
  function jB(n, e) {
    for (var t = 0; t < e.length; t++) if (!isFinite(n[e[t]])) return true;
    return false;
  }
  var ome = [
    "x",
    "y",
    "width",
    "height"
  ], lme = [
    "cx",
    "cy",
    "r",
    "startAngle",
    "endAngle"
  ], KB = {
    cartesian2d: function(n) {
      return !jB(n, ome);
    },
    polar: function(n) {
      return !jB(n, lme);
    }
  }, q1 = {
    cartesian2d: function(n, e, t) {
      var r = n.getItemLayout(e), i = t ? cme(t, r) : 0, a = r.width > 0 ? 1 : -1, s = r.height > 0 ? 1 : -1;
      return {
        x: r.x + a * i / 2,
        y: r.y + s * i / 2,
        width: r.width - a * i,
        height: r.height - s * i
      };
    },
    polar: function(n, e, t) {
      var r = n.getItemLayout(e);
      return {
        cx: r.cx,
        cy: r.cy,
        r0: r.r0,
        r: r.r,
        startAngle: r.startAngle,
        endAngle: r.endAngle,
        clockwise: r.clockwise
      };
    }
  };
  function ume(n) {
    return n.startAngle != null && n.endAngle != null && n.startAngle === n.endAngle;
  }
  function kq(n) {
    return /* @__PURE__ */ function(e) {
      var t = e ? "Arc" : "Angle";
      return function(r) {
        switch (r) {
          case "start":
          case "insideStart":
          case "end":
          case "insideEnd":
            return r + t;
          default:
            return r;
        }
      };
    }(n);
  }
  function ZB(n, e, t, r, i, a, s, o) {
    var l = e.getItemVisual(t, "style");
    if (o) {
      if (!a.get("roundCap")) {
        var c = n.shape, h = Wh(r.getModel("itemStyle"), c, true);
        oe(c, h), n.setShape(c);
      }
    } else {
      var u = r.get([
        "itemStyle",
        "borderRadius"
      ]) || 0;
      n.setShape("r", u);
    }
    n.useStyle(l);
    var d = r.getShallow("cursor");
    d && n.attr("cursor", d);
    var f = o ? s ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : s ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = Hr(r);
    gi(n, p, {
      labelFetcher: a,
      labelDataIndex: t,
      defaultText: Og(a.getData(), t),
      inheritColor: l.fill,
      defaultOpacity: l.opacity,
      defaultOutsidePosition: f
    });
    var g = n.getTextContent();
    if (o && g) {
      var m = r.get([
        "label",
        "position"
      ]);
      n.textConfig.inside = m === "middle" ? true : null, rme(n, m === "outside" ? f : m, kq(s), r.get([
        "label",
        "rotate"
      ]));
    }
    H8(g, p, a.getRawValue(t), function(y) {
      return vq(e, y);
    });
    var v = r.getModel([
      "emphasis"
    ]);
    Qn(n, v.get("focus"), v.get("blurScope"), v.get("disabled")), pi(n, r), ume(i) && (n.style.fill = "none", n.style.stroke = "none", P(n.states, function(y) {
      y.style && (y.style.fill = y.style.stroke = "none");
    }));
  }
  function cme(n, e) {
    var t = n.get([
      "itemStyle",
      "borderColor"
    ]);
    if (!t || t === "none") return 0;
    var r = n.get([
      "itemStyle",
      "borderWidth"
    ]) || 0, i = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), a = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
    return Math.min(r, i, a);
  }
  var hme = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), QB = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "largeBar", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new hme();
    }, e.prototype.buildPath = function(t, r) {
      for (var i = r.points, a = this.baseDimIdx, s = 1 - this.baseDimIdx, o = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3) l[a] = u, l[s] = i[c + 2], o[a] = i[c + a], o[s] = i[c + s], t.rect(o[0], o[1], l[0], l[1]);
    }, e;
  }(At);
  function JB(n, e, t, r) {
    var i = n.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, s = i.getLayout("largeDataIndices"), o = i.getLayout("size"), l = n.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
    if (u) {
      var c = new QB({
        shape: {
          points: u
        },
        incremental: !!r,
        silent: true,
        z2: 0
      });
      c.baseDimIdx = a, c.largeDataIndices = s, c.barWidth = o, c.useStyle(l.getItemStyle()), e.add(c), t && t.push(c);
    }
    var h = new QB({
      shape: {
        points: i.getLayout("largePoints")
      },
      incremental: !!r,
      ignoreCoarsePointer: true,
      z2: 1
    });
    h.baseDimIdx = a, h.largeDataIndices = s, h.barWidth = o, e.add(h), h.useStyle(i.getVisual("style")), h.style.stroke = null, rt(h).seriesIndex = n.seriesIndex, n.get("silent") || (h.on("mousedown", ez), h.on("mousemove", ez)), t && t.push(h);
  }
  var ez = vE(function(n) {
    var e = this, t = dme(e, n.offsetX, n.offsetY);
    rt(e).dataIndex = t >= 0 ? t : null;
  }, 30, false);
  function dme(n, e, t) {
    for (var r = n.baseDimIdx, i = 1 - r, a = n.shape.points, s = n.largeDataIndices, o = [], l = [], u = n.barWidth, c = 0, h = a.length / 3; c < h; c++) {
      var d = c * 3;
      if (l[r] = u, l[i] = a[d + 2], o[r] = a[d + r], o[i] = a[d + i], l[i] < 0 && (o[i] += l[i], l[i] = -l[i]), e >= o[0] && e <= o[0] + l[0] && t >= o[1] && t <= o[1] + l[1]) return s[c];
    }
    return -1;
  }
  function Tq(n, e, t) {
    if (Bd(t, "cartesian2d")) {
      var r = e, i = t.getArea();
      return {
        x: n ? r.x : i.x,
        y: n ? i.y : r.y,
        width: n ? r.width : i.width,
        height: n ? i.height : r.height
      };
    } else {
      var i = t.getArea(), a = e;
      return {
        cx: i.cx,
        cy: i.cy,
        r0: n ? i.r0 : a.r0,
        r: n ? i.r : a.r,
        startAngle: n ? a.startAngle : 0,
        endAngle: n ? a.endAngle : Math.PI * 2
      };
    }
  }
  function fme(n, e, t) {
    var r = n.type === "polar" ? ra : Vt;
    return new r({
      shape: Tq(e, t, n),
      silent: true,
      z2: 0
    });
  }
  function pme(n) {
    n.registerChartView(ame), n.registerSeriesModel(eme), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, lt(NY, "bar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, EY("bar")), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, Iq("bar")), n.registerAction({
      type: "changeAxisOrder",
      event: "changeAxisOrder",
      update: "update"
    }, function(e, t) {
      var r = e.componentType || "series";
      t.eachComponent({
        mainType: r,
        query: e
      }, function(i) {
        e.sortInfo && i.axis.setCategorySortInfo(e.sortInfo);
      });
    });
  }
  var tz = Math.PI * 2, j1 = Math.PI / 180;
  function Aq(n, e) {
    return Er(n.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function Dq(n, e) {
    var t = Aq(n, e), r = n.get("center"), i = n.get("radius");
    de(i) || (i = [
      0,
      i
    ]);
    var a = _e(t.width, e.getWidth()), s = _e(t.height, e.getHeight()), o = Math.min(a, s), l = _e(i[0], o / 2), u = _e(i[1], o / 2), c, h, d = n.coordinateSystem;
    if (d) {
      var f = d.dataToPoint(r);
      c = f[0] || 0, h = f[1] || 0;
    } else de(r) || (r = [
      r,
      r
    ]), c = _e(r[0], a) + t.x, h = _e(r[1], s) + t.y;
    return {
      cx: c,
      cy: h,
      r0: l,
      r: u
    };
  }
  function gme(n, e, t) {
    e.eachSeriesByType(n, function(r) {
      var i = r.getData(), a = i.mapDimension("value"), s = Aq(r, t), o = Dq(r, t), l = o.cx, u = o.cy, c = o.r, h = o.r0, d = -r.get("startAngle") * j1, f = r.get("endAngle"), p = r.get("padAngle") * j1;
      f = f === "auto" ? d - tz : -f * j1;
      var g = r.get("minAngle") * j1, m = g + p, v = 0;
      i.each(a, function(M) {
        !isNaN(M) && v++;
      });
      var y = i.getSum(a), x = Math.PI / (y || v) * 2, b = r.get("clockwise"), w = r.get("roseType"), _ = r.get("stillShowZeroSum"), S = i.getDataExtent(a);
      S[0] = 0;
      var I = b ? 1 : -1, C = [
        d,
        f
      ], T = I * p / 2;
      XN(C, !b), d = C[0], f = C[1];
      var k = Rq(r);
      k.startAngle = d, k.endAngle = f, k.clockwise = b;
      var D = Math.abs(f - d), R = D, N = 0, E = d;
      if (i.setLayout({
        viewRect: s,
        r: c
      }), i.each(a, function(M, $) {
        var L;
        if (isNaN(M)) {
          i.setItemLayout($, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: b,
            cx: l,
            cy: u,
            r0: h,
            r: w ? NaN : c
          });
          return;
        }
        w !== "area" ? L = y === 0 && _ ? x : M * x : L = D / v, L < m ? (L = m, R -= m) : N += M;
        var F = E + I * L, O = 0, z = 0;
        p > L ? (O = E + I * L / 2, z = O) : (O = E + T, z = F - T), i.setItemLayout($, {
          angle: L,
          startAngle: O,
          endAngle: z,
          clockwise: b,
          cx: l,
          cy: u,
          r0: h,
          r: w ? sn(M, S, [
            h,
            c
          ]) : c
        }), E = F;
      }), R < tz && v) if (R <= 1e-3) {
        var A = D / v;
        i.each(a, function(M, $) {
          if (!isNaN(M)) {
            var L = i.getItemLayout($);
            L.angle = A;
            var F = 0, O = 0;
            A < p ? (F = d + I * ($ + 1 / 2) * A, O = F) : (F = d + I * $ * A + T, O = d + I * ($ + 1) * A - T), L.startAngle = F, L.endAngle = O;
          }
        });
      } else x = R / N, E = d, i.each(a, function(M, $) {
        if (!isNaN(M)) {
          var L = i.getItemLayout($), F = L.angle === m ? m : M * x, O = 0, z = 0;
          F < p ? (O = E + I * F / 2, z = O) : (O = E + T, z = E + I * F - T), L.startAngle = O, L.endAngle = z, E += I * F;
        }
      });
    });
  }
  var Rq = Wt();
  function Xx(n) {
    return {
      seriesType: n,
      reset: function(e, t) {
        var r = t.findComponents({
          mainType: "legend"
        });
        if (!(!r || !r.length)) {
          var i = e.getData();
          i.filterSelf(function(a) {
            for (var s = i.getName(a), o = 0; o < r.length; o++) if (!r[o].isSelected(s)) return false;
            return true;
          });
        }
      }
    };
  }
  var mme = Math.PI / 180;
  function nz(n, e, t, r, i, a, s, o, l, u) {
    if (n.length < 2) return;
    function c(g) {
      for (var m = g.rB, v = m * m, y = 0; y < g.list.length; y++) {
        var x = g.list[y], b = Math.abs(x.label.y - t), w = r + x.len, _ = w * w, S = Math.sqrt(Math.abs((1 - b * b / v) * _)), I = e + (S + x.len2) * i, C = I - x.label.x, T = x.targetTextWidth - C * i;
        $q(x, T, true), x.label.x = I;
      }
    }
    function h(g) {
      for (var m = {
        list: [],
        maxY: 0
      }, v = {
        list: [],
        maxY: 0
      }, y = 0; y < g.length; y++) if (g[y].labelAlignTo === "none") {
        var x = g[y], b = x.label.y > t ? v : m, w = Math.abs(x.label.y - t);
        if (w >= b.maxY) {
          var _ = x.label.x - e - x.len2 * i, S = r + x.len, I = Math.abs(_) < S ? Math.sqrt(w * w / (1 - _ * _ / S / S)) : S;
          b.rB = I, b.maxY = w;
        }
        b.list.push(x);
      }
      c(m), c(v);
    }
    for (var d = n.length, f = 0; f < d; f++) if (n[f].position === "outer" && n[f].labelAlignTo === "labelLine") {
      var p = n[f].label.x - u;
      n[f].linePoints[1][0] += p, n[f].label.x = u;
    }
    eq(n, l, l + s) && h(n);
  }
  function vme(n, e, t, r, i, a, s, o) {
    for (var l = [], u = [], c = Number.MAX_VALUE, h = -Number.MAX_VALUE, d = 0; d < n.length; d++) {
      var f = n[d].label;
      Yk(n[d]) || (f.x < e ? (c = Math.min(c, f.x), l.push(n[d])) : (h = Math.max(h, f.x), u.push(n[d])));
    }
    for (var d = 0; d < n.length; d++) {
      var p = n[d];
      if (!Yk(p) && p.linePoints) {
        if (p.labelStyleWidth != null) continue;
        var f = p.label, g = p.linePoints, m = void 0;
        p.labelAlignTo === "edge" ? f.x < e ? m = g[2][0] - p.labelDistance - s - p.edgeDistance : m = s + i - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? f.x < e ? m = c - s - p.bleedMargin : m = s + i - h - p.bleedMargin : f.x < e ? m = f.x - s - p.bleedMargin : m = s + i - f.x - p.bleedMargin, p.targetTextWidth = m, $q(p, m);
      }
    }
    nz(u, e, t, r, 1, i, a, s, o, h), nz(l, e, t, r, -1, i, a, s, o, c);
    for (var d = 0; d < n.length; d++) {
      var p = n[d];
      if (!Yk(p) && p.linePoints) {
        var f = p.label, g = p.linePoints, v = p.labelAlignTo === "edge", y = f.style.padding, x = y ? y[1] + y[3] : 0, b = f.style.backgroundColor ? 0 : x, w = p.rect.width + b, _ = g[1][0] - g[2][0];
        v ? f.x < e ? g[2][0] = s + p.edgeDistance + w + p.labelDistance : g[2][0] = s + i - p.edgeDistance - w - p.labelDistance : (f.x < e ? g[2][0] = f.x + p.labelDistance : g[2][0] = f.x - p.labelDistance, g[1][0] = g[2][0] + _), g[1][1] = g[2][1] = f.y;
      }
    }
  }
  function $q(n, e, t) {
    if (t === void 0 && (t = false), n.labelStyleWidth == null) {
      var r = n.label, i = r.style, a = n.rect, s = i.backgroundColor, o = i.padding, l = o ? o[1] + o[3] : 0, u = i.overflow, c = a.width + (s ? 0 : l);
      if (e < c || t) {
        var h = a.height;
        if (u && u.match("break")) {
          r.setStyle("backgroundColor", null), r.setStyle("width", e - l);
          var d = r.getBoundingRect();
          r.setStyle("width", Math.ceil(d.width)), r.setStyle("backgroundColor", s);
        } else {
          var f = e - l, p = e < c ? f : t ? f > n.unconstrainedWidth ? null : f : null;
          r.setStyle("width", p);
        }
        var g = r.getBoundingRect();
        a.width = g.width;
        var m = (r.style.margin || 0) + 2.1;
        a.height = g.height + m, a.y -= (a.height - h) / 2;
      }
    }
  }
  function Yk(n) {
    return n.position === "center";
  }
  function yme(n) {
    var e = n.getData(), t = [], r, i, a = false, s = (n.get("minShowLabelAngle") || 0) * mme, o = e.getLayout("viewRect"), l = e.getLayout("r"), u = o.width, c = o.x, h = o.y, d = o.height;
    function f(_) {
      _.ignore = true;
    }
    function p(_) {
      if (!_.ignore) return true;
      for (var S in _.states) if (_.states[S].ignore === false) return true;
      return false;
    }
    e.each(function(_) {
      var S = e.getItemGraphicEl(_), I = S.shape, C = S.getTextContent(), T = S.getTextGuideLine(), k = e.getItemModel(_), D = k.getModel("label"), R = D.get("position") || k.get([
        "emphasis",
        "label",
        "position"
      ]), N = D.get("distanceToLabelLine"), E = D.get("alignTo"), A = _e(D.get("edgeDistance"), u), M = D.get("bleedMargin"), $ = k.getModel("labelLine"), L = $.get("length");
      L = _e(L, u);
      var F = $.get("length2");
      if (F = _e(F, u), Math.abs(I.endAngle - I.startAngle) < s) {
        P(C.states, f), C.ignore = true, T && (P(T.states, f), T.ignore = true);
        return;
      }
      if (p(C)) {
        var O = (I.startAngle + I.endAngle) / 2, z = Math.cos(O), V = Math.sin(O), H, Y, le, ve;
        r = I.cx, i = I.cy;
        var re = R === "inside" || R === "inner";
        if (R === "center") H = I.cx, Y = I.cy, ve = "center";
        else {
          var ae = (re ? (I.r + I.r0) / 2 * z : I.r * z) + r, fe = (re ? (I.r + I.r0) / 2 * V : I.r * V) + i;
          if (H = ae + z * 3, Y = fe + V * 3, !re) {
            var ce = ae + z * (L + l - I.r), ye = fe + V * (L + l - I.r), Le = ce + (z < 0 ? -1 : 1) * F, Re = ye;
            E === "edge" ? H = z < 0 ? c + A : c + u - A : H = Le + (z < 0 ? -N : N), Y = Re, le = [
              [
                ae,
                fe
              ],
              [
                ce,
                ye
              ],
              [
                Le,
                Re
              ]
            ];
          }
          ve = re ? "center" : E === "edge" ? z > 0 ? "right" : "left" : z > 0 ? "left" : "right";
        }
        var be = Math.PI, xe = 0, ot = D.get("rotate");
        if (Yt(ot)) xe = ot * (be / 180);
        else if (R === "center") xe = 0;
        else if (ot === "radial" || ot === true) {
          var G = z < 0 ? -O + be : -O;
          xe = G;
        } else if (ot === "tangential" && R !== "outside" && R !== "outer") {
          var q = Math.atan2(z, V);
          q < 0 && (q = be * 2 + q);
          var ge = V > 0;
          ge && (q = be + q), xe = q - be;
        }
        if (a = !!xe, C.x = H, C.y = Y, C.rotation = xe, C.setStyle({
          verticalAlign: "middle"
        }), re) {
          C.setStyle({
            align: ve
          });
          var dt = C.states.select;
          dt && (dt.x += C.x, dt.y += C.y);
        } else {
          var Fe = C.getBoundingRect().clone();
          Fe.applyTransform(C.getComputedTransform());
          var Lt = (C.style.margin || 0) + 2.1;
          Fe.y -= Lt / 2, Fe.height += Lt, t.push({
            label: C,
            labelLine: T,
            position: R,
            len: L,
            len2: F,
            minTurnAngle: $.get("minTurnAngle"),
            maxSurfaceAngle: $.get("maxSurfaceAngle"),
            surfaceNormal: new mt(z, V),
            linePoints: le,
            textAlign: ve,
            labelDistance: N,
            labelAlignTo: E,
            edgeDistance: A,
            bleedMargin: M,
            rect: Fe,
            unconstrainedWidth: Fe.width,
            labelStyleWidth: C.style.width
          });
        }
        S.setTextConfig({
          inside: re
        });
      }
    }), !a && n.get("avoidLabelOverlap") && vme(t, r, i, l, u, d, c, h);
    for (var g = 0; g < t.length; g++) {
      var m = t[g], v = m.label, y = m.labelLine, x = isNaN(v.x) || isNaN(v.y);
      if (v) {
        v.setStyle({
          align: m.textAlign
        }), x && (P(v.states, f), v.ignore = true);
        var b = v.states.select;
        b && (b.x += v.x, b.y += v.y);
      }
      if (y) {
        var w = m.linePoints;
        x || !w ? (P(y.states, f), y.ignore = true) : (ZY(w, m.minTurnAngle), Vpe(w, m.surfaceNormal, m.maxSurfaceAngle), y.setShape({
          points: w
        }), v.__hostTarget.textGuideLineConfig = {
          anchor: new mt(w[0][0], w[0][1])
        });
      }
    }
  }
  var xme = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      a.z2 = 2;
      var s = new Gt();
      return a.setTextContent(s), a.updateData(t, r, i, true), a;
    }
    return e.prototype.updateData = function(t, r, i, a) {
      var s = this, o = t.hostModel, l = t.getItemModel(r), u = l.getModel("emphasis"), c = t.getItemLayout(r), h = oe(Wh(l.getModel("itemStyle"), c, true), c);
      if (isNaN(h.startAngle)) {
        s.setShape(h);
        return;
      }
      if (a) {
        s.setShape(h);
        var d = o.getShallow("animationType");
        o.ecModel.ssr ? (Un(s, {
          scaleX: 0,
          scaleY: 0
        }, o, {
          dataIndex: r,
          isFrom: true
        }), s.originX = h.cx, s.originY = h.cy) : d === "scale" ? (s.shape.r = c.r0, Un(s, {
          shape: {
            r: c.r
          }
        }, o, r)) : i != null ? (s.setShape({
          startAngle: i,
          endAngle: i
        }), Un(s, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, o, r)) : (s.shape.endAngle = c.startAngle, Kt(s, {
          shape: {
            endAngle: c.endAngle
          }
        }, o, r));
      } else ro(s), Kt(s, {
        shape: h
      }, o, r);
      s.useStyle(t.getItemVisual(r, "style")), pi(s, l);
      var f = (c.startAngle + c.endAngle) / 2, p = o.get("selectedOffset"), g = Math.cos(f) * p, m = Math.sin(f) * p, v = l.getShallow("cursor");
      v && s.attr("cursor", v), this._updateLabel(o, t, r), s.ensureState("emphasis").shape = oe({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, Wh(u.getModel("itemStyle"), c)), oe(s.ensureState("select"), {
        x: g,
        y: m,
        shape: Wh(l.getModel([
          "select",
          "itemStyle"
        ]), c)
      }), oe(s.ensureState("blur"), {
        shape: Wh(l.getModel([
          "blur",
          "itemStyle"
        ]), c)
      });
      var y = s.getTextGuideLine(), x = s.getTextContent();
      y && oe(y.ensureState("select"), {
        x: g,
        y: m
      }), oe(x.ensureState("select"), {
        x: g,
        y: m
      }), Qn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, r, i) {
      var a = this, s = r.getItemModel(i), o = s.getModel("labelLine"), l = r.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      gi(a, Hr(s), {
        labelFetcher: r.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: t.getFormattedLabel(i, "normal") || r.getName(i)
      });
      var h = a.getTextContent();
      a.setTextConfig({
        position: null,
        rotation: null
      }), h.attr({
        z2: 10
      });
      var d = t.get([
        "label",
        "position"
      ]);
      if (d !== "outside" && d !== "outer") a.removeTextGuideLine();
      else {
        var f = this.getTextGuideLine();
        f || (f = new oa(), this.setTextGuideLine(f)), RE(this, $E(s), {
          stroke: u,
          opacity: Go(o.get([
            "lineStyle",
            "opacity"
          ]), c, 1)
        });
      }
    }, e;
  }(ra), bme = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.ignoreLabelLineUpdate = true, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      var s = t.getData(), o = this._data, l = this.group, u;
      if (!o && s.count() > 0) {
        for (var c = s.getItemLayout(0), h = 1; isNaN(c && c.startAngle) && h < s.count(); ++h) c = s.getItemLayout(h);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), s.count() === 0 && t.get("showEmptyCircle")) {
        var d = Rq(t), f = new ra({
          shape: oe(Dq(t, i), d)
        });
        f.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = f, l.add(f);
      }
      s.diff(o).add(function(p) {
        var g = new xme(s, p, u);
        s.setItemGraphicEl(p, g), l.add(g);
      }).update(function(p, g) {
        var m = o.getItemGraphicEl(g);
        m.updateData(s, p, u), m.off("click"), l.add(m), s.setItemGraphicEl(p, m);
      }).remove(function(p) {
        var g = o.getItemGraphicEl(p);
        E0(g, t, p);
      }).execute(), yme(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = s);
    }, e.prototype.dispose = function() {
    }, e.prototype.containPoint = function(t, r) {
      var i = r.getData(), a = i.getItemLayout(0);
      if (a) {
        var s = t[0] - a.cx, o = t[1] - a.cy, l = Math.sqrt(s * s + o * o);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "pie", e;
  }(_n);
  function km(n, e, t) {
    e = de(e) && {
      coordDimensions: e
    } || oe({
      encodeDefine: n.getEncode()
    }, e);
    var r = n.getSource(), i = zx(r, e).dimensions, a = new Ki(i, n);
    return a.initData(r, t), a;
  }
  var Yx = function() {
    function n(e, t) {
      this._getDataWithEncodedVisual = e, this._getRawData = t;
    }
    return n.prototype.getAllNames = function() {
      var e = this._getRawData();
      return e.mapArray(e.getName);
    }, n.prototype.containName = function(e) {
      var t = this._getRawData();
      return t.indexOfName(e) >= 0;
    }, n.prototype.indexOfName = function(e) {
      var t = this._getDataWithEncodedVisual();
      return t.indexOfName(e);
    }, n.prototype.getItemVisual = function(e, t) {
      var r = this._getDataWithEncodedVisual();
      return r.getItemVisual(e, t);
    }, n;
  }(), wme = Wt(), _me = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Yx(Ae(this.getData, this), Ae(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.mergeOption = function() {
      n.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.getInitialData = function() {
      return km(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: lt(uE, this)
      });
    }, e.prototype.getDataParams = function(t) {
      var r = this.getData(), i = wme(r), a = i.seats;
      if (!a) {
        var s = [];
        r.each(r.mapDimension("value"), function(l) {
          s.push(l);
        }), a = i.seats = dle(s, r.hostModel.get("percentPrecision"));
      }
      var o = n.prototype.getDataParams.call(this, t);
      return o.percent = a[t] || 0, o.$vars.push("percent"), o;
    }, e.prototype._defaultLabelLine = function(t) {
      ud(t, "labelLine", [
        "show"
      ]);
      var r = t.labelLine, i = t.emphasis.labelLine;
      r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.type = "series.pie", e.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      center: [
        "50%",
        "50%"
      ],
      radius: [
        0,
        "75%"
      ],
      clockwise: true,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      minAngle: 0,
      minShowLabelAngle: 0,
      selectedOffset: 10,
      percentPrecision: 2,
      stillShowZeroSum: true,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        rotate: 0,
        show: true,
        overflow: "truncate",
        position: "outer",
        alignTo: "none",
        edgeDistance: "25%",
        bleedMargin: 10,
        distanceToLabelLine: 5
      },
      labelLine: {
        show: true,
        length: 15,
        length2: 15,
        smooth: false,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: true,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        hideOverlap: true
      },
      emphasis: {
        scale: true,
        scaleSize: 5
      },
      avoidLabelOverlap: true,
      animationType: "expansion",
      animationDuration: 1e3,
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, e;
  }(En);
  function Sme(n) {
    return {
      seriesType: n,
      reset: function(e, t) {
        var r = e.getData();
        r.filterSelf(function(i) {
          var a = r.mapDimension("value"), s = r.get(a, i);
          return !(Yt(s) && !isNaN(s) && s < 0);
        });
      }
    };
  }
  function Cme(n) {
    n.registerChartView(bme), n.registerSeriesModel(_me), ZX("pie", n.registerAction), n.registerLayout(lt(gme, "pie")), n.registerProcessor(Xx("pie")), n.registerProcessor(Sme("pie"));
  }
  var Ime = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return au(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.point(r.getItemLayout(t));
    }, e.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, e.type = "series.scatter", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      symbolSize: 10,
      large: false,
      largeThreshold: 2e3,
      itemStyle: {
        opacity: 0.8
      },
      emphasis: {
        scale: true
      },
      clip: true,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
    }, e;
  }(En), Nq = 4, kme = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), Tme = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r._off = 0, r.hoverDataIdx = -1, r;
    }
    return e.prototype.getDefaultShape = function() {
      return new kme();
    }, e.prototype.reset = function() {
      this.notClear = false, this._off = 0;
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, a = r.size, s = this.symbolProxy, o = s.shape, l = t.getContext ? t.getContext() : t, u = l && a[0] < Nq, c = this.softClipShape, h;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, h = this._off; h < i.length; ) {
        var d = i[h++], f = i[h++];
        isNaN(d) || isNaN(f) || c && !c.contain(d, f) || (o.x = d - a[0] / 2, o.y = f - a[1] / 2, o.width = a[0], o.height = a[1], s.buildPath(t, o, true));
      }
      this.incremental && (this._off = h, this.notClear = true);
    }, e.prototype.afterBrush = function() {
      var t = this.shape, r = t.points, i = t.size, a = this._ctx, s = this.softClipShape, o;
      if (a) {
        for (o = this._off; o < r.length; ) {
          var l = r[o++], u = r[o++];
          isNaN(l) || isNaN(u) || s && !s.contain(l, u) || a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = o, this.notClear = true);
      }
    }, e.prototype.findDataIndex = function(t, r) {
      for (var i = this.shape, a = i.points, s = i.size, o = Math.max(s[0], 4), l = Math.max(s[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, h = a[c] - o / 2, d = a[c + 1] - l / 2;
        if (t >= h && r >= d && t <= h + o && r <= d + l) return u;
      }
      return -1;
    }, e.prototype.contain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect();
      if (t = i[0], r = i[1], a.contain(t, r)) {
        var s = this.hoverDataIdx = this.findDataIndex(t, r);
        return s >= 0;
      }
      return this.hoverDataIdx = -1, false;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var r = this.shape, i = r.points, a = r.size, s = a[0], o = a[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, h = -1 / 0, d = 0; d < i.length; ) {
          var f = i[d++], p = i[d++];
          l = Math.min(f, l), c = Math.max(f, c), u = Math.min(p, u), h = Math.max(p, h);
        }
        t = this._rect = new vt(l - s / 2, u - o / 2, c - l + s, h - u + o);
      }
      return t;
    }, e;
  }(At), Ame = function() {
    function n() {
      this.group = new tt();
    }
    return n.prototype.updateData = function(e, t) {
      this._clear();
      var r = this._create();
      r.setShape({
        points: e.getLayout("points")
      }), this._setCommon(r, e, t);
    }, n.prototype.updateLayout = function(e) {
      var t = e.getLayout("points");
      this.group.eachChild(function(r) {
        if (r.startIndex != null) {
          var i = (r.endIndex - r.startIndex) * 2, a = r.startIndex * 4 * 2;
          t = new Float32Array(t.buffer, a, i);
        }
        r.setShape("points", t), r.reset();
      });
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._clear();
    }, n.prototype.incrementalUpdate = function(e, t, r) {
      var i = this._newAdded[0], a = t.getLayout("points"), s = i && i.shape.points;
      if (s && s.length < 2e4) {
        var o = s.length, l = new Float32Array(o + a.length);
        l.set(s), l.set(a, o), i.endIndex = e.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = e.start, u.endIndex = e.end, u.incremental = true, u.setShape({
          points: a
        }), this._setCommon(u, t, r);
      }
    }, n.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, n.prototype._create = function() {
      var e = new Tme({
        cursor: "default"
      });
      return e.ignoreCoarsePointer = true, this.group.add(e), this._newAdded.push(e), e;
    }, n.prototype._setCommon = function(e, t, r) {
      var i = t.hostModel;
      r = r || {};
      var a = t.getVisual("symbolSize");
      e.setShape("size", a instanceof Array ? a : [
        a,
        a
      ]), e.softClipShape = r.clipShape || null, e.symbolProxy = xr(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor;
      var s = e.shape.size[0] < Nq;
      e.useStyle(i.getModel("itemStyle").getItemStyle(s ? [
        "color",
        "shadowBlur",
        "shadowColor"
      ] : [
        "color"
      ]));
      var o = t.getVisual("style"), l = o && o.fill;
      l && e.setColor(l);
      var u = rt(e);
      u.seriesIndex = i.seriesIndex, e.on("mousemove", function(c) {
        u.dataIndex = null;
        var h = e.hoverDataIdx;
        h >= 0 && (u.dataIndex = h + (e.startIndex || 0));
      });
    }, n.prototype.remove = function() {
      this._clear();
    }, n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, n;
  }(), Dme = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), s = this._updateSymbolDraw(a, t);
      s.updateData(a, {
        clipShape: this._getClipShape(t)
      }), this._finished = true;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      var a = t.getData(), s = this._updateSymbolDraw(a, t);
      s.incrementalPrepareUpdate(a), this._finished = false;
    }, e.prototype.incrementalRender = function(t, r, i) {
      this._symbolDraw.incrementalUpdate(t, r.getData(), {
        clipShape: this._getClipShape(r)
      }), this._finished = t.end === r.getData().count();
    }, e.prototype.updateTransform = function(t, r, i) {
      var a = t.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4) return {
        update: true
      };
      var s = Hx("").reset(t, r, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, e.prototype.eachRendered = function(t) {
      this._symbolDraw && this._symbolDraw.eachRendered(t);
    }, e.prototype._getClipShape = function(t) {
      if (t.get("clip", true)) {
        var r = t.coordinateSystem;
        return r && r.getArea && r.getArea(0.1);
      }
    }, e.prototype._updateSymbolDraw = function(t, r) {
      var i = this._symbolDraw, a = r.pipelineContext, s = a.large;
      return (!i || s !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = s ? new Ame() : new Gx(), this._isLargeDraw = s, this.group.removeAll()), this.group.add(i.group), i;
    }, e.prototype.remove = function(t, r) {
      this._symbolDraw && this._symbolDraw.remove(true), this._symbolDraw = null;
    }, e.prototype.dispose = function() {
    }, e.type = "scatter", e;
  }(_n), Rme = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.type = "grid", e.dependencies = [
      "xAxis",
      "yAxis"
    ], e.layoutMode = "box", e.defaultOption = {
      show: false,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      containLabel: false,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, e;
  }(Et), mR = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", yr).models[0];
    }, e.type = "cartesian2dAxis", e;
  }(Et);
  br(mR, Vx);
  var Eq = {
    show: true,
    z: 0,
    inverse: false,
    name: "",
    nameLocation: "end",
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: "...",
      placeholder: "."
    },
    nameTextStyle: {},
    nameGap: 15,
    silent: false,
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: "#6E7079",
        width: 1,
        type: "solid"
      },
      symbol: [
        "none",
        "none"
      ],
      symbolSize: [
        10,
        15
      ]
    },
    axisTick: {
      show: true,
      inside: false,
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      inside: false,
      rotate: 0,
      showMinLabel: null,
      showMaxLabel: null,
      margin: 8,
      fontSize: 12
    },
    splitLine: {
      show: true,
      showMinLine: true,
      showMaxLine: true,
      lineStyle: {
        color: [
          "#E0E6F1"
        ],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: [
          "rgba(250,250,250,0.2)",
          "rgba(210,219,238,0.2)"
        ]
      }
    }
  }, $me = pt({
    boundaryGap: true,
    deduplication: null,
    splitLine: {
      show: false
    },
    axisTick: {
      alignWithLabel: false,
      interval: "auto"
    },
    axisLabel: {
      interval: "auto"
    }
  }, Eq), OE = pt({
    boundaryGap: [
      0,
      0
    ],
    axisLine: {
      show: "auto"
    },
    axisTick: {
      show: "auto"
    },
    splitNumber: 5,
    minorTick: {
      show: false,
      splitNumber: 5,
      length: 3,
      lineStyle: {}
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: "#F4F7FD",
        width: 1
      }
    }
  }, Eq), Nme = pt({
    splitNumber: 6,
    axisLabel: {
      showMinLabel: false,
      showMaxLabel: false,
      rich: {
        primary: {
          fontWeight: "bold"
        }
      }
    },
    splitLine: {
      show: false
    }
  }, OE), Eme = je({
    logBase: 10
  }, OE);
  const Mq = {
    category: $me,
    value: OE,
    time: Nme,
    log: Eme
  };
  var Mme = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
  };
  function Bg(n, e, t, r) {
    P(Mme, function(i, a) {
      var s = pt(pt({}, Mq[a], true), r, true), o = function(l) {
        K(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = e + "Axis." + a, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, h) {
          var d = P0(this), f = d ? bm(c) : {}, p = h.getTheme();
          pt(c, p.get(a + "Axis")), pt(c, this.getDefaultOption()), c.type = rz(c), d && rc(c, f, d);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = uR.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var h = this.option;
          if (h.type === "category") return c ? h.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = e + "Axis." + a, u.defaultOption = s, u;
      }(t);
      n.registerComponentModel(o);
    }), n.registerSubTypeDefaulter(e + "Axis", rz);
  }
  function rz(n) {
    return n.type || (n.data ? "category" : "value");
  }
  var Pme = function() {
    function n(e) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "";
    }
    return n.prototype.getAxis = function(e) {
      return this._axes[e];
    }, n.prototype.getAxes = function() {
      return me(this._dimList, function(e) {
        return this._axes[e];
      }, this);
    }, n.prototype.getAxesByScale = function(e) {
      return e = e.toLowerCase(), rn(this.getAxes(), function(t) {
        return t.scale.type === e;
      });
    }, n.prototype.addAxis = function(e) {
      var t = e.dim;
      this._axes[t] = e, this._dimList.push(t);
    }, n;
  }(), vR = [
    "x",
    "y"
  ];
  function iz(n) {
    return n.type === "interval" || n.type === "time";
  }
  var Lme = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "cartesian2d", t.dimensions = vR, t;
    }
    return e.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var t = this.getAxis("x").scale, r = this.getAxis("y").scale;
      if (!(!iz(t) || !iz(r))) {
        var i = t.getExtent(), a = r.getExtent(), s = this.dataToPoint([
          i[0],
          a[0]
        ]), o = this.dataToPoint([
          i[1],
          a[1]
        ]), l = i[1] - i[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var c = (o[0] - s[0]) / l, h = (o[1] - s[1]) / u, d = s[0] - i[0] * c, f = s[1] - a[0] * h, p = this._transform = [
            c,
            0,
            0,
            h,
            d,
            f
          ];
          this._invTransform = fm([], p);
        }
      }
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, e.prototype.containPoint = function(t) {
      var r = this.getAxis("x"), i = this.getAxis("y");
      return r.contain(r.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]));
    }, e.prototype.containData = function(t) {
      return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
    }, e.prototype.containZone = function(t, r) {
      var i = this.dataToPoint(t), a = this.dataToPoint(r), s = this.getArea(), o = new vt(i[0], i[1], a[0] - i[0], a[1] - i[1]);
      return s.intersect(o);
    }, e.prototype.dataToPoint = function(t, r, i) {
      i = i || [];
      var a = t[0], s = t[1];
      if (this._transform && a != null && isFinite(a) && s != null && isFinite(s)) return di(i, t, this._transform);
      var o = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = o.toGlobalCoord(o.dataToCoord(a, r)), i[1] = l.toGlobalCoord(l.dataToCoord(s, r)), i;
    }, e.prototype.clampData = function(t, r) {
      var i = this.getAxis("x").scale, a = this.getAxis("y").scale, s = i.getExtent(), o = a.getExtent(), l = i.parse(t[0]), u = a.parse(t[1]);
      return r = r || [], r[0] = Math.min(Math.max(Math.min(s[0], s[1]), l), Math.max(s[0], s[1])), r[1] = Math.min(Math.max(Math.min(o[0], o[1]), u), Math.max(o[0], o[1])), r;
    }, e.prototype.pointToData = function(t, r) {
      var i = [];
      if (this._invTransform) return di(i, t, this._invTransform);
      var a = this.getAxis("x"), s = this.getAxis("y");
      return i[0] = a.coordToData(a.toLocalCoord(t[0]), r), i[1] = s.coordToData(s.toLocalCoord(t[1]), r), i;
    }, e.prototype.getOtherAxis = function(t) {
      return this.getAxis(t.dim === "x" ? "y" : "x");
    }, e.prototype.getArea = function(t) {
      t = t || 0;
      var r = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(r[0], r[1]) - t, s = Math.min(i[0], i[1]) - t, o = Math.max(r[0], r[1]) - a + t, l = Math.max(i[0], i[1]) - s + t;
      return new vt(a, s, o, l);
    }, e;
  }(Pme), Fme = function(n) {
    K(e, n);
    function e(t, r, i, a, s) {
      var o = n.call(this, t, r, i) || this;
      return o.index = 0, o.type = a || "value", o.position = s || "bottom", o;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.getGlobalExtent = function(t) {
      var r = this.getExtent();
      return r[0] = this.toGlobalCoord(r[0]), r[1] = this.toGlobalCoord(r[1]), t && r[0] > r[1] && r.reverse(), r;
    }, e.prototype.pointToData = function(t, r) {
      return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), r);
    }, e.prototype.setCategorySortInfo = function(t) {
      if (this.type !== "category") return false;
      this.model.option.categorySortInfo = t, this.scale.setSortInfo(t);
    }, e;
  }(fo);
  function yR(n, e, t) {
    t = t || {};
    var r = n.coordinateSystem, i = e.axis, a = {}, s = i.getAxesOnZeroOf()[0], o = i.position, l = s ? "onZero" : o, u = i.dim, c = r.getRect(), h = [
      c.x,
      c.x + c.width,
      c.y,
      c.y + c.height
    ], d = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    }, f = e.get("offset") || 0, p = u === "x" ? [
      h[2] - f,
      h[3] + f
    ] : [
      h[0] - f,
      h[1] + f
    ];
    if (s) {
      var g = s.toGlobalCoord(s.dataToCoord(0));
      p[d.onZero] = Math.max(Math.min(g, p[1]), p[0]);
    }
    a.position = [
      u === "y" ? p[d[l]] : h[0],
      u === "x" ? p[d[l]] : h[3]
    ], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
    var m = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    a.labelDirection = a.tickDirection = a.nameDirection = m[o], a.labelOffset = s ? p[d[o]] - p[d.onZero] : 0, e.get([
      "axisTick",
      "inside"
    ]) && (a.tickDirection = -a.tickDirection), ni(t.labelInside, e.get([
      "axisLabel",
      "inside"
    ])) && (a.labelDirection = -a.labelDirection);
    var v = e.get([
      "axisLabel",
      "rotate"
    ]);
    return a.labelRotate = l === "top" ? -v : v, a.z2 = 1, a;
  }
  function az(n) {
    return n.get("coordinateSystem") === "cartesian2d";
  }
  function sz(n) {
    var e = {
      xAxisModel: null,
      yAxisModel: null
    };
    return P(e, function(t, r) {
      var i = r.replace(/Model$/, ""), a = n.getReferringComponents(i, yr).models[0];
      e[r] = a;
    }), e;
  }
  var qk = Math.log;
  function Pq(n, e, t) {
    var r = jl.prototype, i = r.getTicks.call(t), a = r.getTicks.call(t, true), s = i.length - 1, o = r.getInterval.call(t), l = OY(n, e), u = l.extent, c = l.fixMin, h = l.fixMax;
    if (n.type === "log") {
      var d = qk(n.base);
      u = [
        qk(u[0]) / d,
        qk(u[1]) / d
      ];
    }
    n.setExtent(u[0], u[1]), n.calcNiceExtent({
      splitNumber: s,
      fixMin: c,
      fixMax: h
    });
    var f = r.getExtent.call(n);
    c && (u[0] = f[0]), h && (u[1] = f[1]);
    var p = r.getInterval.call(n), g = u[0], m = u[1];
    if (c && h) p = (m - g) / s;
    else if (c) for (m = u[0] + p * s; m < u[1] && isFinite(m) && isFinite(u[1]); ) p = Ek(p), m = u[0] + p * s;
    else if (h) for (g = u[1] - p * s; g > u[0] && isFinite(g) && isFinite(u[0]); ) p = Ek(p), g = u[1] - p * s;
    else {
      var v = n.getTicks().length - 1;
      v > s && (p = Ek(p));
      var y = p * s;
      m = Math.ceil(u[1] / p) * p, g = rr(m - y), g < 0 && u[0] >= 0 ? (g = 0, m = rr(y)) : m > 0 && u[1] <= 0 && (m = 0, g = -rr(y));
    }
    var x = (i[0].value - a[0].value) / o, b = (i[s].value - a[s].value) / o;
    r.setExtent.call(n, g + p * x, m + p * b), r.setInterval.call(n, p), (x || b) && r.setNiceExtent.call(n, g + p, m - p);
  }
  var Ome = function() {
    function n(e, t, r) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = true, this.dimensions = vR, this._initCartesian(e, t, r), this.model = e;
    }
    return n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype.update = function(e, t) {
      var r = this._axesMap;
      this._updateScale(e, this.model);
      function i(s) {
        var o, l = Mt(s), u = l.length;
        if (u) {
          for (var c = [], h = u - 1; h >= 0; h--) {
            var d = +l[h], f = s[d], p = f.model, g = f.scale;
            cR(g) && p.get("alignTicks") && p.get("interval") == null ? c.push(f) : (Fg(g, p), cR(g) && (o = f));
          }
          c.length && (o || (o = c.pop(), Fg(o.scale, o.model)), P(c, function(m) {
            Pq(m.scale, m.model, o.scale);
          }));
        }
      }
      i(r.x), i(r.y);
      var a = {};
      P(r.x, function(s) {
        oz(r, "y", s, a);
      }), P(r.y, function(s) {
        oz(r, "x", s, a);
      }), this.resize(this.model, t);
    }, n.prototype.resize = function(e, t, r) {
      var i = e.getBoxLayoutParams(), a = !r && e.get("containLabel"), s = Er(i, {
        width: t.getWidth(),
        height: t.getHeight()
      });
      this._rect = s;
      var o = this._axesList;
      l(), a && (P(o, function(u) {
        if (!u.model.get([
          "axisLabel",
          "inside"
        ])) {
          var c = ype(u);
          if (c) {
            var h = u.isHorizontal() ? "height" : "width", d = u.model.get([
              "axisLabel",
              "margin"
            ]);
            s[h] -= c[h] + d, u.position === "top" ? s.y += c.height + d : u.position === "left" && (s.x += c.width + d);
          }
        }
      }), l()), P(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        P(o, function(u) {
          var c = u.isHorizontal(), h = c ? [
            0,
            s.width
          ] : [
            0,
            s.height
          ], d = u.inverse ? 1 : 0;
          u.setExtent(h[d], h[1 - d]), Bme(u, c ? s.x : s.y);
        });
      }
    }, n.prototype.getAxis = function(e, t) {
      var r = this._axesMap[e];
      if (r != null) return r[t || 0];
    }, n.prototype.getAxes = function() {
      return this._axesList.slice();
    }, n.prototype.getCartesian = function(e, t) {
      if (e != null && t != null) {
        var r = "x" + e + "y" + t;
        return this._coordsMap[r];
      }
      Ze(e) && (t = e.yAxisIndex, e = e.xAxisIndex);
      for (var i = 0, a = this._coordsList; i < a.length; i++) if (a[i].getAxis("x").index === e || a[i].getAxis("y").index === t) return a[i];
    }, n.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.dataToPoint(r) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(r)) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = this._findConvertTarget(t);
      return i.cartesian ? i.cartesian.pointToData(r) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(r)) : null;
    }, n.prototype._findConvertTarget = function(e) {
      var t = e.seriesModel, r = e.xAxisModel || t && t.getReferringComponents("xAxis", yr).models[0], i = e.yAxisModel || t && t.getReferringComponents("yAxis", yr).models[0], a = e.gridModel, s = this._coordsList, o, l;
      if (t) o = t.coordinateSystem, bt(s, o) < 0 && (o = null);
      else if (r && i) o = this.getCartesian(r.componentIndex, i.componentIndex);
      else if (r) l = this.getAxis("x", r.componentIndex);
      else if (i) l = this.getAxis("y", i.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (o = this._coordsList[0]);
      }
      return {
        cartesian: o,
        axis: l
      };
    }, n.prototype.containPoint = function(e) {
      var t = this._coordsList[0];
      if (t) return t.containPoint(e);
    }, n.prototype._initCartesian = function(e, t, r) {
      var i = this, a = this, s = {
        left: false,
        right: false,
        top: false,
        bottom: false
      }, o = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (t.eachComponent("xAxis", u("x"), this), t.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = o, P(o.x, function(c, h) {
        P(o.y, function(d, f) {
          var p = "x" + h + "y" + f, g = new Lme(p);
          g.master = i, g.model = e, i._coordsMap[p] = g, i._coordsList.push(g), g.addAxis(c), g.addAxis(d);
        });
      });
      function u(c) {
        return function(h, d) {
          if (jk(h, e)) {
            var f = h.get("position");
            c === "x" ? f !== "top" && f !== "bottom" && (f = s.bottom ? "top" : "bottom") : f !== "left" && f !== "right" && (f = s.left ? "right" : "left"), s[f] = true;
            var p = new Fme(c, VC(h), [
              0,
              0
            ], h.get("type"), f), g = p.type === "category";
            p.onBand = g && h.get("boundaryGap"), p.inverse = h.get("inverse"), h.axis = p, p.model = h, p.grid = a, p.index = d, a._axesList.push(p), o[c][d] = p, l[c]++;
          }
        };
      }
    }, n.prototype._updateScale = function(e, t) {
      P(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var a = i.model.get("categorySortInfo");
          i.scale.setSortInfo(a);
        }
      }), e.eachSeries(function(i) {
        if (az(i)) {
          var a = sz(i), s = a.xAxisModel, o = a.yAxisModel;
          if (!jk(s, t) || !jk(o, t)) return;
          var l = this.getCartesian(s.componentIndex, o.componentIndex), u = i.getData(), c = l.getAxis("x"), h = l.getAxis("y");
          r(u, c), r(u, h);
        }
      }, this);
      function r(i, a) {
        P(eS(i, a.dim), function(s) {
          a.scale.unionExtentFromData(i, s);
        });
      }
    }, n.prototype.getTooltipAxes = function(e) {
      var t = [], r = [];
      return P(this.getCartesians(), function(i) {
        var a = e != null && e !== "auto" ? i.getAxis(e) : i.getBaseAxis(), s = i.getOtherAxis(a);
        bt(t, a) < 0 && t.push(a), bt(r, s) < 0 && r.push(s);
      }), {
        baseAxes: t,
        otherAxes: r
      };
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("grid", function(i, a) {
        var s = new n(i, e, t);
        s.name = "grid_" + a, s.resize(i, t, true), i.coordinateSystem = s, r.push(s);
      }), e.eachSeries(function(i) {
        if (az(i)) {
          var a = sz(i), s = a.xAxisModel, o = a.yAxisModel, l = s.getCoordSysModel(), u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(s.componentIndex, o.componentIndex);
        }
      }), r;
    }, n.dimensions = vR, n;
  }();
  function jk(n, e) {
    return n.getCoordSysModel() === e;
  }
  function oz(n, e, t, r) {
    t.getAxesOnZeroOf = function() {
      return a ? [
        a
      ] : [];
    };
    var i = n[e], a, s = t.model, o = s.get([
      "axisLine",
      "onZero"
    ]), l = s.get([
      "axisLine",
      "onZeroAxisIndex"
    ]);
    if (!o) return;
    if (l != null) lz(i[l]) && (a = i[l]);
    else for (var u in i) if (i.hasOwnProperty(u) && lz(i[u]) && !r[c(i[u])]) {
      a = i[u];
      break;
    }
    a && (r[c(a)] = true);
    function c(h) {
      return h.dim + "_" + h.index;
    }
  }
  function lz(n) {
    return n && n.type !== "category" && n.type !== "time" && vpe(n);
  }
  function Bme(n, e) {
    var t = n.getExtent(), r = t[0] + t[1];
    n.toGlobalCoord = n.dim === "x" ? function(i) {
      return i + e;
    } : function(i) {
      return r - i + e;
    }, n.toLocalCoord = n.dim === "x" ? function(i) {
      return i - e;
    } : function(i) {
      return r - i + e;
    };
  }
  var Ou = Math.PI, Zi = function() {
    function n(e, t) {
      this.group = new tt(), this.opt = t, this.axisModel = e, je(t, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true,
        handleAutoShown: function() {
          return true;
        }
      });
      var r = new tt({
        x: t.position[0],
        y: t.position[1],
        rotation: t.rotation
      });
      r.updateTransform(), this._transformGroup = r;
    }
    return n.prototype.hasBuilder = function(e) {
      return !!uz[e];
    }, n.prototype.add = function(e) {
      uz[e](this.opt, this.axisModel, this.group, this._transformGroup);
    }, n.prototype.getGroup = function() {
      return this.group;
    }, n.innerTextLayout = function(e, t, r) {
      var i = Q6(t - e), a, s;
      return D0(i) ? (s = r > 0 ? "top" : "bottom", a = "center") : D0(i - Ou) ? (s = r > 0 ? "bottom" : "top", a = "center") : (s = "middle", i > 0 && i < Ou ? a = r > 0 ? "right" : "left" : a = r > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: a,
        textVerticalAlign: s
      };
    }, n.makeAxisEventDataBase = function(e) {
      var t = {
        componentType: e.mainType,
        componentIndex: e.componentIndex
      };
      return t[e.mainType + "Index"] = e.componentIndex, t;
    }, n.isLabelSilent = function(e) {
      var t = e.get("tooltip");
      return e.get("silent") || !(e.get("triggerEvent") || t && t.show);
    }, n;
  }(), uz = {
    axisLine: function(n, e, t, r) {
      var i = e.get([
        "axisLine",
        "show"
      ]);
      if (i === "auto" && n.handleAutoShown && (i = n.handleAutoShown("axisLine")), !!i) {
        var a = e.axis.getExtent(), s = r.transform, o = [
          a[0],
          0
        ], l = [
          a[1],
          0
        ], u = o[0] > l[0];
        s && (di(o, o, s), di(l, l, s));
        var c = oe({
          lineCap: "round"
        }, e.getModel([
          "axisLine",
          "lineStyle"
        ]).getLineStyle()), h = new zr({
          shape: {
            x1: o[0],
            y1: o[1],
            x2: l[0],
            y2: l[1]
          },
          style: c,
          strokeContainThreshold: n.strokeContainThreshold || 5,
          silent: true,
          z2: 1
        });
        Mg(h.shape, h.style.lineWidth), h.anid = "line", t.add(h);
        var d = e.get([
          "axisLine",
          "symbol"
        ]);
        if (d != null) {
          var f = e.get([
            "axisLine",
            "symbolSize"
          ]);
          Ie(d) && (d = [
            d,
            d
          ]), (Ie(f) || Yt(f)) && (f = [
            f,
            f
          ]);
          var p = Fd(e.get([
            "axisLine",
            "symbolOffset"
          ]) || 0, f), g = f[0], m = f[1];
          P([
            {
              rotate: n.rotation + Math.PI / 2,
              offset: p[0],
              r: 0
            },
            {
              rotate: n.rotation - Math.PI / 2,
              offset: p[1],
              r: Math.sqrt((o[0] - l[0]) * (o[0] - l[0]) + (o[1] - l[1]) * (o[1] - l[1]))
            }
          ], function(v, y) {
            if (d[y] !== "none" && d[y] != null) {
              var x = xr(d[y], -g / 2, -m / 2, g, m, c.stroke, true), b = v.r + v.offset, w = u ? l : o;
              x.attr({
                rotation: v.rotate,
                x: w[0] + b * Math.cos(n.rotation),
                y: w[1] - b * Math.sin(n.rotation),
                silent: true,
                z2: 11
              }), t.add(x);
            }
          });
        }
      }
    },
    axisTickLabel: function(n, e, t, r) {
      var i = Wme(t, r, e, n), a = Ume(t, r, e, n);
      if (Vme(e, a, i), Gme(t, r, e, n.tickDirection), e.get([
        "axisLabel",
        "hideOverlap"
      ])) {
        var s = QY(me(a, function(o) {
          return {
            label: o,
            priority: o.z2,
            defaultAttr: {
              ignore: o.ignore
            }
          };
        }));
        tq(s);
      }
    },
    axisName: function(n, e, t, r) {
      var i = ni(n.axisName, e.get("name"));
      if (i) {
        var a = e.get("nameLocation"), s = n.nameDirection, o = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = e.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, h = [
          a === "start" ? u[0] - c * l : a === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
          hz(a) ? n.labelOffset + s * l : 0
        ], d, f = e.get("nameRotate");
        f != null && (f = f * Ou / 180);
        var p;
        hz(a) ? d = Zi.innerTextLayout(n.rotation, f ?? n.rotation, s) : (d = zme(n.rotation, a, f || 0, u), p = n.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(d.rotation)), !isFinite(p) && (p = null)));
        var g = o.getFont(), m = e.get("nameTruncate", true) || {}, v = m.ellipsis, y = ni(n.nameTruncateMaxWidth, m.maxWidth, p), x = new Gt({
          x: h[0],
          y: h[1],
          rotation: d.rotation,
          silent: Zi.isLabelSilent(e),
          style: $n(o, {
            text: i,
            font: g,
            overflow: "truncate",
            width: y,
            ellipsis: v,
            fill: o.getTextColor() || e.get([
              "axisLine",
              "lineStyle",
              "color"
            ]),
            align: o.get("align") || d.textAlign,
            verticalAlign: o.get("verticalAlign") || d.textVerticalAlign
          }),
          z2: 1
        });
        if (Pd({
          el: x,
          componentModel: e,
          itemName: i
        }), x.__fullText = i, x.anid = "name", e.get("triggerEvent")) {
          var b = Zi.makeAxisEventDataBase(e);
          b.targetType = "axisName", b.name = i, rt(x).eventData = b;
        }
        r.add(x), x.updateTransform(), t.add(x), x.decomposeTransform();
      }
    }
  };
  function zme(n, e, t, r) {
    var i = Q6(t - n), a, s, o = r[0] > r[1], l = e === "start" && !o || e !== "start" && o;
    return D0(i - Ou / 2) ? (s = l ? "bottom" : "top", a = "center") : D0(i - Ou * 1.5) ? (s = l ? "top" : "bottom", a = "center") : (s = "middle", i < Ou * 1.5 && i > Ou / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
      rotation: i,
      textAlign: a,
      textVerticalAlign: s
    };
  }
  function Vme(n, e, t) {
    if (!BY(n.axis)) {
      var r = n.get([
        "axisLabel",
        "showMinLabel"
      ]), i = n.get([
        "axisLabel",
        "showMaxLabel"
      ]);
      e = e || [], t = t || [];
      var a = e[0], s = e[1], o = e[e.length - 1], l = e[e.length - 2], u = t[0], c = t[1], h = t[t.length - 1], d = t[t.length - 2];
      r === false ? (es(a), es(u)) : cz(a, s) && (r ? (es(s), es(c)) : (es(a), es(u))), i === false ? (es(o), es(h)) : cz(l, o) && (i ? (es(l), es(d)) : (es(o), es(h)));
    }
  }
  function es(n) {
    n && (n.ignore = true);
  }
  function cz(n, e) {
    var t = n && n.getBoundingRect().clone(), r = e && e.getBoundingRect().clone();
    if (!(!t || !r)) {
      var i = dC([]);
      return Md(i, i, -n.rotation), t.applyTransform(Ml([], i, n.getLocalTransform())), r.applyTransform(Ml([], i, e.getLocalTransform())), t.intersect(r);
    }
  }
  function hz(n) {
    return n === "middle" || n === "center";
  }
  function Lq(n, e, t, r, i) {
    for (var a = [], s = [], o = [], l = 0; l < n.length; l++) {
      var u = n[l].coord;
      s[0] = u, s[1] = 0, o[0] = u, o[1] = t, e && (di(s, s, e), di(o, o, e));
      var c = new zr({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: o[0],
          y2: o[1]
        },
        style: r,
        z2: 2,
        autoBatch: true,
        silent: true
      });
      Mg(c.shape, c.style.lineWidth), c.anid = i + "_" + n[l].tickValue, a.push(c);
    }
    return a;
  }
  function Wme(n, e, t, r) {
    var i = t.axis, a = t.getModel("axisTick"), s = a.get("show");
    if (s === "auto" && r.handleAutoShown && (s = r.handleAutoShown("axisTick")), !(!s || i.scale.isBlank())) {
      for (var o = a.getModel("lineStyle"), l = r.tickDirection * a.get("length"), u = i.getTicksCoords(), c = Lq(u, e.transform, l, je(o.getLineStyle(), {
        stroke: t.get([
          "axisLine",
          "lineStyle",
          "color"
        ])
      }), "ticks"), h = 0; h < c.length; h++) n.add(c[h]);
      return c;
    }
  }
  function Gme(n, e, t, r) {
    var i = t.axis, a = t.getModel("minorTick");
    if (!(!a.get("show") || i.scale.isBlank())) {
      var s = i.getMinorTicksCoords();
      if (s.length) for (var o = a.getModel("lineStyle"), l = r * a.get("length"), u = je(o.getLineStyle(), je(t.getModel("axisTick").getLineStyle(), {
        stroke: t.get([
          "axisLine",
          "lineStyle",
          "color"
        ])
      })), c = 0; c < s.length; c++) for (var h = Lq(s[c], e.transform, l, u, "minorticks_" + c), d = 0; d < h.length; d++) n.add(h[d]);
    }
  }
  function Ume(n, e, t, r) {
    var i = t.axis, a = ni(r.axisLabelShow, t.get([
      "axisLabel",
      "show"
    ]));
    if (!(!a || i.scale.isBlank())) {
      var s = t.getModel("axisLabel"), o = s.get("margin"), l = i.getViewLabels(), u = (ni(r.labelRotate, s.get("rotate")) || 0) * Ou / 180, c = Zi.innerTextLayout(r.rotation, u, r.labelDirection), h = t.getCategories && t.getCategories(true), d = [], f = Zi.isLabelSilent(t), p = t.get("triggerEvent");
      return P(l, function(g, m) {
        var v = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(g.tickValue) : g.tickValue, y = g.formattedLabel, x = g.rawLabel, b = s;
        if (h && h[v]) {
          var w = h[v];
          Ze(w) && w.textStyle && (b = new on(w.textStyle, s, t.ecModel));
        }
        var _ = b.getTextColor() || t.get([
          "axisLine",
          "lineStyle",
          "color"
        ]), S = i.dataToCoord(v), I = b.getShallow("align", true) || c.textAlign, C = it(b.getShallow("alignMinLabel", true), I), T = it(b.getShallow("alignMaxLabel", true), I), k = b.getShallow("verticalAlign", true) || b.getShallow("baseline", true) || c.textVerticalAlign, D = it(b.getShallow("verticalAlignMinLabel", true), k), R = it(b.getShallow("verticalAlignMaxLabel", true), k), N = new Gt({
          x: S,
          y: r.labelOffset + r.labelDirection * o,
          rotation: c.rotation,
          silent: f,
          z2: 10 + (g.level || 0),
          style: $n(b, {
            text: y,
            align: m === 0 ? C : m === l.length - 1 ? T : I,
            verticalAlign: m === 0 ? D : m === l.length - 1 ? R : k,
            fill: Xe(_) ? _(i.type === "category" ? x : i.type === "value" ? v + "" : v, m) : _
          })
        });
        if (N.anid = "label_" + v, Pd({
          el: N,
          componentModel: t,
          itemName: y,
          formatterParamsExtra: {
            isTruncated: function() {
              return N.isTruncated;
            },
            value: x,
            tickIndex: m
          }
        }), p) {
          var E = Zi.makeAxisEventDataBase(t);
          E.targetType = "axisLabel", E.value = x, E.tickIndex = m, i.type === "category" && (E.dataIndex = v), rt(N).eventData = E;
        }
        e.add(N), N.updateTransform(), d.push(N), n.add(N), N.decomposeTransform();
      }), d;
    }
  }
  function Hme(n, e) {
    var t = {
      axesInfo: {},
      seriesInvolved: false,
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    return Xme(t, n, e), t.seriesInvolved && qme(t, n), t;
  }
  function Xme(n, e, t) {
    var r = e.getComponent("tooltip"), i = e.getComponent("axisPointer"), a = i.get("link", true) || [], s = [];
    P(t.getCoordinateSystems(), function(o) {
      if (!o.axisPointerEnabled) return;
      var l = U0(o.model), u = n.coordSysAxesInfo[l] = {};
      n.coordSysMap[l] = o;
      var c = o.model, h = c.getModel("tooltip", r);
      if (P(o.getAxes(), lt(g, false, null)), o.getTooltipAxes && r && h.get("show")) {
        var d = h.get("trigger") === "axis", f = h.get([
          "axisPointer",
          "type"
        ]) === "cross", p = o.getTooltipAxes(h.get([
          "axisPointer",
          "axis"
        ]));
        (d || f) && P(p.baseAxes, lt(g, f ? "cross" : true, d)), f && P(p.otherAxes, lt(g, "cross", false));
      }
      function g(m, v, y) {
        var x = y.model.getModel("axisPointer", i), b = x.get("show");
        if (!(!b || b === "auto" && !m && !xR(x))) {
          v == null && (v = x.get("triggerTooltip")), x = m ? Yme(y, h, i, e, m, v) : x;
          var w = x.get("snap"), _ = x.get("triggerEmphasis"), S = U0(y.model), I = v || w || y.type === "category", C = n.axesInfo[S] = {
            key: S,
            axis: y,
            coordSys: o,
            axisPointerModel: x,
            triggerTooltip: v,
            triggerEmphasis: _,
            involveSeries: I,
            snap: w,
            useHandle: xR(x),
            seriesModels: [],
            linkGroup: null
          };
          u[S] = C, n.seriesInvolved = n.seriesInvolved || I;
          var T = jme(a, y);
          if (T != null) {
            var k = s[T] || (s[T] = {
              axesInfo: {}
            });
            k.axesInfo[S] = C, k.mapper = a[T].mapper, C.linkGroup = k;
          }
        }
      }
    });
  }
  function Yme(n, e, t, r, i, a) {
    var s = e.getModel("axisPointer"), o = [
      "type",
      "snap",
      "lineStyle",
      "shadowStyle",
      "label",
      "animation",
      "animationDurationUpdate",
      "animationEasingUpdate",
      "z"
    ], l = {};
    P(o, function(d) {
      l[d] = Qe(s.get(d));
    }), l.snap = n.type !== "category" && !!a, s.get("type") === "cross" && (l.type = "line");
    var u = l.label || (l.label = {});
    if (u.show == null && (u.show = false), i === "cross") {
      var c = s.get([
        "label",
        "show"
      ]);
      if (u.show = c ?? true, !a) {
        var h = l.lineStyle = s.get("crossStyle");
        h && je(u, h.textStyle);
      }
    }
    return n.model.getModel("axisPointer", new on(l, t, r));
  }
  function qme(n, e) {
    e.eachSeries(function(t) {
      var r = t.coordinateSystem, i = t.get([
        "tooltip",
        "trigger"
      ], true), a = t.get([
        "tooltip",
        "show"
      ], true);
      !r || i === "none" || i === false || i === "item" || a === false || t.get([
        "axisPointer",
        "show"
      ], true) === false || P(n.coordSysAxesInfo[U0(r.model)], function(s) {
        var o = s.axis;
        r.getAxis(o.dim) === o && (s.seriesModels.push(t), s.seriesDataCount == null && (s.seriesDataCount = 0), s.seriesDataCount += t.getData().count());
      });
    });
  }
  function jme(n, e) {
    for (var t = e.model, r = e.dim, i = 0; i < n.length; i++) {
      var a = n[i] || {};
      if (Kk(a[r + "AxisId"], t.id) || Kk(a[r + "AxisIndex"], t.componentIndex) || Kk(a[r + "AxisName"], t.name)) return i;
    }
  }
  function Kk(n, e) {
    return n === "all" || de(n) && bt(n, e) >= 0 || n === e;
  }
  function Kme(n) {
    var e = BE(n);
    if (e) {
      var t = e.axisPointerModel, r = e.axis.scale, i = t.option, a = t.get("status"), s = t.get("value");
      s != null && (s = r.parse(s));
      var o = xR(t);
      a == null && (i.status = o ? "show" : "hide");
      var l = r.getExtent().slice();
      l[0] > l[1] && l.reverse(), (s == null || s > l[1]) && (s = l[1]), s < l[0] && (s = l[0]), i.value = s, o && (i.status = e.axis.scale.isBlank() ? "hide" : "show");
    }
  }
  function BE(n) {
    var e = (n.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return e && e.axesInfo[U0(n)];
  }
  function Zme(n) {
    var e = BE(n);
    return e && e.axisPointerModel;
  }
  function xR(n) {
    return !!n.get([
      "handle",
      "show"
    ]);
  }
  function U0(n) {
    return n.type + "||" + n.id;
  }
  var dz = {}, zd = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this.axisPointerClass && Kme(t), n.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, i, true);
    }, e.prototype.updateAxisPointer = function(t, r, i, a) {
      this._doUpdateAxisPointerClass(t, i, false);
    }, e.prototype.remove = function(t, r) {
      var i = this._axisPointer;
      i && i.remove(r);
    }, e.prototype.dispose = function(t, r) {
      this._disposeAxisPointer(r), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._doUpdateAxisPointerClass = function(t, r, i) {
      var a = e.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var s = Zme(t);
        s ? (this._axisPointer || (this._axisPointer = new a())).render(t, s, r, i) : this._disposeAxisPointer(r);
      }
    }, e.prototype._disposeAxisPointer = function(t) {
      this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null;
    }, e.registerAxisPointerClass = function(t, r) {
      dz[t] = r;
    }, e.getAxisPointerClass = function(t) {
      return t && dz[t];
    }, e.type = "axis", e;
  }(Yn), bR = Wt();
  function Fq(n, e, t, r) {
    var i = t.axis;
    if (!i.scale.isBlank()) {
      var a = t.getModel("splitArea"), s = a.getModel("areaStyle"), o = s.get("color"), l = r.coordinateSystem.getRect(), u = i.getTicksCoords({
        tickModel: a,
        clamp: true
      });
      if (u.length) {
        var c = o.length, h = bR(n).splitAreaColors, d = Pe(), f = 0;
        if (h) for (var p = 0; p < u.length; p++) {
          var g = h.get(u[p].tickValue);
          if (g != null) {
            f = (g + (c - 1) * p) % c;
            break;
          }
        }
        var m = i.toGlobalCoord(u[0].coord), v = s.getAreaStyle();
        o = de(o) ? o : [
          o
        ];
        for (var p = 1; p < u.length; p++) {
          var y = i.toGlobalCoord(u[p].coord), x = void 0, b = void 0, w = void 0, _ = void 0;
          i.isHorizontal() ? (x = m, b = l.y, w = y - x, _ = l.height, m = x + w) : (x = l.x, b = m, w = l.width, _ = y - b, m = b + _);
          var S = u[p - 1].tickValue;
          S != null && d.set(S, f), e.add(new Vt({
            anid: S != null ? "area_" + S : null,
            shape: {
              x,
              y: b,
              width: w,
              height: _
            },
            style: je({
              fill: o[f]
            }, v),
            autoBatch: true,
            silent: true
          })), f = (f + 1) % c;
        }
        bR(n).splitAreaColors = d;
      }
    }
  }
  function Oq(n) {
    bR(n).splitAreaColors = null;
  }
  var Qme = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], Jme = [
    "splitArea",
    "splitLine",
    "minorSplitLine"
  ], Bq = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this.group.removeAll();
      var s = this._axisGroup;
      if (this._axisGroup = new tt(), this.group.add(this._axisGroup), !!t.get("show")) {
        var o = t.getCoordSysModel(), l = yR(o, t), u = new Zi(t, oe({
          handleAutoShown: function(h) {
            for (var d = o.coordinateSystem.getCartesians(), f = 0; f < d.length; f++) if (cR(d[f].getOtherAxis(t.axis).scale)) return true;
            return false;
          }
        }, l));
        P(Qme, u.add, u), this._axisGroup.add(u.getGroup()), P(Jme, function(h) {
          t.get([
            h,
            "show"
          ]) && eve[h](this, this._axisGroup, t, o);
        }, this);
        var c = a && a.type === "changeAxisOrder" && a.isInitSort;
        c || Lx(s, this._axisGroup, t), n.prototype.render.call(this, t, r, i, a);
      }
    }, e.prototype.remove = function() {
      Oq(this);
    }, e.type = "cartesianAxis", e;
  }(zd), eve = {
    splitLine: function(n, e, t, r) {
      var i = t.axis;
      if (!i.scale.isBlank()) {
        var a = t.getModel("splitLine"), s = a.getModel("lineStyle"), o = s.get("color"), l = a.get("showMinLine") !== false, u = a.get("showMaxLine") !== false;
        o = de(o) ? o : [
          o
        ];
        for (var c = r.coordinateSystem.getRect(), h = i.isHorizontal(), d = 0, f = i.getTicksCoords({
          tickModel: a
        }), p = [], g = [], m = s.getLineStyle(), v = 0; v < f.length; v++) {
          var y = i.toGlobalCoord(f[v].coord);
          if (!(v === 0 && !l || v === f.length - 1 && !u)) {
            var x = f[v].tickValue;
            h ? (p[0] = y, p[1] = c.y, g[0] = y, g[1] = c.y + c.height) : (p[0] = c.x, p[1] = y, g[0] = c.x + c.width, g[1] = y);
            var b = d++ % o.length, w = new zr({
              anid: x != null ? "line_" + x : null,
              autoBatch: true,
              shape: {
                x1: p[0],
                y1: p[1],
                x2: g[0],
                y2: g[1]
              },
              style: je({
                stroke: o[b]
              }, m),
              silent: true
            });
            Mg(w.shape, m.lineWidth), e.add(w);
          }
        }
      }
    },
    minorSplitLine: function(n, e, t, r) {
      var i = t.axis, a = t.getModel("minorSplitLine"), s = a.getModel("lineStyle"), o = r.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
      if (u.length) for (var c = [], h = [], d = s.getLineStyle(), f = 0; f < u.length; f++) for (var p = 0; p < u[f].length; p++) {
        var g = i.toGlobalCoord(u[f][p].coord);
        l ? (c[0] = g, c[1] = o.y, h[0] = g, h[1] = o.y + o.height) : (c[0] = o.x, c[1] = g, h[0] = o.x + o.width, h[1] = g);
        var m = new zr({
          anid: "minor_line_" + u[f][p].tickValue,
          autoBatch: true,
          shape: {
            x1: c[0],
            y1: c[1],
            x2: h[0],
            y2: h[1]
          },
          style: d,
          silent: true
        });
        Mg(m.shape, d.lineWidth), e.add(m);
      }
    },
    splitArea: function(n, e, t, r) {
      Fq(n, e, t, r);
    }
  }, zq = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "xAxis", e;
  }(Bq), tve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = zq.type, t;
    }
    return e.type = "yAxis", e;
  }(Bq), nve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "grid", t;
    }
    return e.prototype.render = function(t, r) {
      this.group.removeAll(), t.get("show") && this.group.add(new Vt({
        shape: t.coordinateSystem.getRect(),
        style: je({
          fill: t.get("backgroundColor")
        }, t.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }, e.type = "grid", e;
  }(Yn), fz = {
    offset: 0
  };
  function Vq(n) {
    n.registerComponentView(nve), n.registerComponentModel(Rme), n.registerCoordinateSystem("cartesian2d", Ome), Bg(n, "x", mR, fz), Bg(n, "y", mR, fz), n.registerComponentView(zq), n.registerComponentView(tve), n.registerPreprocessor(function(e) {
      e.xAxis && e.yAxis && !e.grid && (e.grid = {});
    });
  }
  function rve(n) {
    Ct(Vq), n.registerSeriesModel(Ime), n.registerChartView(Dme), n.registerLayout(Hx("scatter"));
  }
  function ive(n) {
    n.eachSeriesByType("radar", function(e) {
      var t = e.getData(), r = [], i = e.coordinateSystem;
      if (i) {
        var a = i.getIndicatorAxes();
        P(a, function(s, o) {
          t.each(t.mapDimension(a[o].dim), function(l, u) {
            r[u] = r[u] || [];
            var c = i.dataToPoint(l, o);
            r[u][o] = pz(c) ? c : gz(i);
          });
        }), t.each(function(s) {
          var o = zse(r[s], function(l) {
            return pz(l);
          }) || gz(i);
          r[s].push(o.slice()), t.setItemLayout(s, r[s]);
        });
      }
    });
  }
  function pz(n) {
    return !isNaN(n[0]) && !isNaN(n[1]);
  }
  function gz(n) {
    return [
      n.cx,
      n.cy
    ];
  }
  function ave(n) {
    var e = n.polar;
    if (e) {
      de(e) || (e = [
        e
      ]);
      var t = [];
      P(e, function(r, i) {
        r.indicator ? (r.type && !r.shape && (r.shape = r.type), n.radar = n.radar || [], de(n.radar) || (n.radar = [
          n.radar
        ]), n.radar.push(r)) : t.push(r);
      }), n.polar = t;
    }
    P(n.series, function(r) {
      r && r.type === "radar" && r.polarIndex && (r.radarIndex = r.polarIndex);
    });
  }
  var sve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.coordinateSystem, s = this.group, o = t.getData(), l = this._data;
      function u(d, f) {
        var p = d.getItemVisual(f, "symbol") || "circle";
        if (p !== "none") {
          var g = Cm(d.getItemVisual(f, "symbolSize")), m = xr(p, -1, -1, 2, 2), v = d.getItemVisual(f, "symbolRotate") || 0;
          return m.attr({
            style: {
              strokeNoScale: true
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: v * Math.PI / 180 || 0
          }), m;
        }
      }
      function c(d, f, p, g, m, v) {
        p.removeAll();
        for (var y = 0; y < f.length - 1; y++) {
          var x = u(g, m);
          x && (x.__dimIdx = y, d[y] ? (x.setPosition(d[y]), Ld[v ? "initProps" : "updateProps"](x, {
            x: f[y][0],
            y: f[y][1]
          }, t, m)) : x.setPosition(f[y]), p.add(x));
        }
      }
      function h(d) {
        return me(d, function(f) {
          return [
            a.cx,
            a.cy
          ];
        });
      }
      o.diff(l).add(function(d) {
        var f = o.getItemLayout(d);
        if (f) {
          var p = new ia(), g = new oa(), m = {
            shape: {
              points: f
            }
          };
          p.shape.points = h(f), g.shape.points = h(f), Un(p, m, t, d), Un(g, m, t, d);
          var v = new tt(), y = new tt();
          v.add(g), v.add(p), v.add(y), c(g.shape.points, f, y, o, d, true), o.setItemGraphicEl(d, v);
        }
      }).update(function(d, f) {
        var p = l.getItemGraphicEl(f), g = p.childAt(0), m = p.childAt(1), v = p.childAt(2), y = {
          shape: {
            points: o.getItemLayout(d)
          }
        };
        y.shape.points && (c(g.shape.points, y.shape.points, v, o, d, false), ro(m), ro(g), Kt(g, y, t), Kt(m, y, t), o.setItemGraphicEl(d, p));
      }).remove(function(d) {
        s.remove(l.getItemGraphicEl(d));
      }).execute(), o.eachItemGraphicEl(function(d, f) {
        var p = o.getItemModel(f), g = d.childAt(0), m = d.childAt(1), v = d.childAt(2), y = o.getItemVisual(f, "style"), x = y.fill;
        s.add(d), g.useStyle(je(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: x
        })), pi(g, p, "lineStyle"), pi(m, p, "areaStyle");
        var b = p.getModel("areaStyle"), w = b.isEmpty() && b.parentModel.isEmpty();
        m.ignore = w, P([
          "emphasis",
          "select",
          "blur"
        ], function(I) {
          var C = p.getModel([
            I,
            "areaStyle"
          ]), T = C.isEmpty() && C.parentModel.isEmpty();
          m.ensureState(I).ignore = T && w;
        }), m.useStyle(je(b.getAreaStyle(), {
          fill: x,
          opacity: 0.7,
          decal: y.decal
        }));
        var _ = p.getModel("emphasis"), S = _.getModel("itemStyle").getItemStyle();
        v.eachChild(function(I) {
          if (I instanceof oi) {
            var C = I.style;
            I.useStyle(oe({
              image: C.image,
              x: C.x,
              y: C.y,
              width: C.width,
              height: C.height
            }, y));
          } else I.useStyle(y), I.setColor(x), I.style.strokeNoScale = true;
          var T = I.ensureState("emphasis");
          T.style = Qe(S);
          var k = o.getStore().get(o.getDimensionIndex(I.__dimIdx), f);
          (k == null || isNaN(k)) && (k = ""), gi(I, Hr(p), {
            labelFetcher: o.hostModel,
            labelDataIndex: f,
            labelDimIndex: I.__dimIdx,
            defaultText: k,
            inheritColor: x,
            defaultOpacity: y.opacity
          });
        }), Qn(d, _.get("focus"), _.get("blurScope"), _.get("disabled"));
      }), this._data = o;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "radar", e;
  }(_n), ove = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Yx(Ae(this.getData, this), Ae(this.getRawData, this));
    }, e.prototype.getInitialData = function(t, r) {
      return km(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), s = this.coordinateSystem, o = s.getIndicatorAxes(), l = this.getData().getName(t), u = l === "" ? this.name : l, c = BX(this, t);
      return Xr("section", {
        header: u,
        sortBlocks: true,
        blocks: me(o, function(h) {
          var d = a.get(a.mapDimension(h.dim), t);
          return Xr("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: h.name,
            value: d,
            sortParam: d
          });
        })
      });
    }, e.prototype.getTooltipPosition = function(t) {
      if (t != null) {
        for (var r = this.getData(), i = this.coordinateSystem, a = r.getValues(me(i.dimensions, function(u) {
          return r.mapDimension(u);
        }), t), s = 0, o = a.length; s < o; s++) if (!isNaN(a[s])) {
          var l = i.getIndicatorAxes();
          return i.coordToPoint(l[s].dataToCoord(a[s]), s);
        }
      }
    }, e.type = "series.radar", e.dependencies = [
      "radar"
    ], e.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: true,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      symbolSize: 8
    }, e;
  }(En), uy = Mq.value;
  function K1(n, e) {
    return je({
      show: e
    }, n);
  }
  var lve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      var t = this.get("boundaryGap"), r = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), s = this.get("axisTick"), o = this.get("axisLabel"), l = this.get("axisName"), u = this.get([
        "axisName",
        "show"
      ]), c = this.get([
        "axisName",
        "formatter"
      ]), h = this.get("axisNameGap"), d = this.get("triggerEvent"), f = me(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = je({
          color: p.color
        }, l));
        var m = pt(Qe(p), {
          boundaryGap: t,
          splitNumber: r,
          scale: i,
          axisLine: a,
          axisTick: s,
          axisLabel: o,
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: h,
          nameTextStyle: g,
          triggerEvent: d
        }, false);
        if (Ie(c)) {
          var v = m.name;
          m.name = c.replace("{value}", v ?? "");
        } else Xe(c) && (m.name = c(m.name, m));
        var y = new on(m, null, this.ecModel);
        return br(y, Vx.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = f;
    }, e.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, e.type = "radar", e.defaultOption = {
      z: 0,
      center: [
        "50%",
        "50%"
      ],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: true
      },
      boundaryGap: [
        0,
        0
      ],
      splitNumber: 5,
      axisNameGap: 15,
      scale: false,
      shape: "polygon",
      axisLine: pt({
        lineStyle: {
          color: "#bbb"
        }
      }, uy.axisLine),
      axisLabel: K1(uy.axisLabel, false),
      axisTick: K1(uy.axisTick, false),
      splitLine: K1(uy.splitLine, true),
      splitArea: K1(uy.splitArea, true),
      indicator: []
    }, e;
  }(Et), uve = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], cve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = this.group;
      a.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
    }, e.prototype._buildAxes = function(t) {
      var r = t.coordinateSystem, i = r.getIndicatorAxes(), a = me(i, function(s) {
        var o = s.model.get("showName") ? s.name : "", l = new Zi(s.model, {
          axisName: o,
          position: [
            r.cx,
            r.cy
          ],
          rotation: s.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      P(a, function(s) {
        P(uve, s.add, s), this.group.add(s.getGroup());
      }, this);
    }, e.prototype._buildSplitLineAndArea = function(t) {
      var r = t.coordinateSystem, i = r.getIndicatorAxes();
      if (!i.length) return;
      var a = t.get("shape"), s = t.getModel("splitLine"), o = t.getModel("splitArea"), l = s.getModel("lineStyle"), u = o.getModel("areaStyle"), c = s.get("show"), h = o.get("show"), d = l.get("color"), f = u.get("color"), p = de(d) ? d : [
        d
      ], g = de(f) ? f : [
        f
      ], m = [], v = [];
      function y(E, A, M) {
        var $ = M % A.length;
        return E[$] = E[$] || [], $;
      }
      if (a === "circle") for (var x = i[0].getTicksCoords(), b = r.cx, w = r.cy, _ = 0; _ < x.length; _++) {
        if (c) {
          var S = y(m, p, _);
          m[S].push(new iu({
            shape: {
              cx: b,
              cy: w,
              r: x[_].coord
            }
          }));
        }
        if (h && _ < x.length - 1) {
          var S = y(v, g, _);
          v[S].push(new Ex({
            shape: {
              cx: b,
              cy: w,
              r0: x[_].coord,
              r: x[_ + 1].coord
            }
          }));
        }
      }
      else for (var I, C = me(i, function(E, A) {
        var M = E.getTicksCoords();
        return I = I == null ? M.length - 1 : Math.min(M.length - 1, I), me(M, function($) {
          return r.coordToPoint($.coord, A);
        });
      }), T = [], _ = 0; _ <= I; _++) {
        for (var k = [], D = 0; D < i.length; D++) k.push(C[D][_]);
        if (k[0] && k.push(k[0].slice()), c) {
          var S = y(m, p, _);
          m[S].push(new oa({
            shape: {
              points: k
            }
          }));
        }
        if (h && T) {
          var S = y(v, g, _ - 1);
          v[S].push(new ia({
            shape: {
              points: k.concat(T)
            }
          }));
        }
        T = k.slice().reverse();
      }
      var R = l.getLineStyle(), N = u.getAreaStyle();
      P(v, function(E, A) {
        this.group.add(ps(E, {
          style: je({
            stroke: "none",
            fill: g[A % g.length]
          }, N),
          silent: true
        }));
      }, this), P(m, function(E, A) {
        this.group.add(ps(E, {
          style: je({
            fill: "none",
            stroke: p[A % p.length]
          }, R),
          silent: true
        }));
      }, this);
    }, e.type = "radar", e;
  }(Yn), hve = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this, t, r, i) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return e;
  }(fo), dve = function() {
    function n(e, t, r) {
      this.dimensions = [], this._model = e, this._indicatorAxes = me(e.getIndicatorModels(), function(i, a) {
        var s = "indicator_" + a, o = new hve(s, new jl());
        return o.name = i.get("name"), o.model = i, i.axis = o, this.dimensions.push(s), o;
      }, this), this.resize(e, r);
    }
    return n.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, n.prototype.dataToPoint = function(e, t) {
      var r = this._indicatorAxes[t];
      return this.coordToPoint(r.dataToCoord(e), t);
    }, n.prototype.coordToPoint = function(e, t) {
      var r = this._indicatorAxes[t], i = r.angle, a = this.cx + e * Math.cos(i), s = this.cy - e * Math.sin(i);
      return [
        a,
        s
      ];
    }, n.prototype.pointToData = function(e) {
      var t = e[0] - this.cx, r = e[1] - this.cy, i = Math.sqrt(t * t + r * r);
      t /= i, r /= i;
      for (var a = Math.atan2(-r, t), s = 1 / 0, o, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], h = Math.abs(a - c.angle);
        h < s && (o = c, l = u, s = h);
      }
      return [
        l,
        +(o && o.coordToData(i))
      ];
    }, n.prototype.resize = function(e, t) {
      var r = e.get("center"), i = t.getWidth(), a = t.getHeight(), s = Math.min(i, a) / 2;
      this.cx = _e(r[0], i), this.cy = _e(r[1], a), this.startAngle = e.get("startAngle") * Math.PI / 180;
      var o = e.get("radius");
      (Ie(o) || Yt(o)) && (o = [
        0,
        o
      ]), this.r0 = _e(o[0], s), this.r = _e(o[1], s), P(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, n.prototype.update = function(e, t) {
      var r = this._indicatorAxes, i = this._model;
      P(r, function(o) {
        o.scale.setExtent(1 / 0, -1 / 0);
      }), e.eachSeriesByType("radar", function(o, l) {
        if (!(o.get("coordinateSystem") !== "radar" || e.getComponent("radar", o.get("radarIndex")) !== i)) {
          var u = o.getData();
          P(r, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var a = i.get("splitNumber"), s = new jl();
      s.setExtent(0, a), s.setInterval(1), P(r, function(o, l) {
        Pq(o.scale, o.model, s);
      });
    }, n.prototype.convertToPixel = function(e, t, r) {
      return console.warn("Not implemented."), null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      return console.warn("Not implemented."), null;
    }, n.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), false;
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("radar", function(i) {
        var a = new n(i, e, t);
        r.push(a), i.coordinateSystem = a;
      }), e.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = r[i.get("radarIndex") || 0]);
      }), r;
    }, n.dimensions = [], n;
  }();
  function fve(n) {
    n.registerCoordinateSystem("radar", dve), n.registerComponentModel(lve), n.registerComponentView(cve), n.registerVisual({
      seriesType: "radar",
      reset: function(e) {
        var t = e.getData();
        t.each(function(r) {
          t.setItemVisual(r, "legendIcon", "roundRect");
        }), t.setVisual("legendIcon", "roundRect");
      }
    });
  }
  function pve(n) {
    Ct(fve), n.registerChartView(sve), n.registerSeriesModel(ove), n.registerLayout(ive), n.registerProcessor(Xx("radar")), n.registerPreprocessor(ave);
  }
  var mz = "\0_ec_interaction_mutex";
  function gve(n, e, t) {
    var r = zE(n);
    r[e] = t;
  }
  function mve(n, e, t) {
    var r = zE(n), i = r[e];
    i === t && (r[e] = null);
  }
  function vz(n, e) {
    return !!zE(n)[e];
  }
  function zE(n) {
    return n[mz] || (n[mz] = {});
  }
  cl({
    type: "takeGlobalCursor",
    event: "globalCursorTaken",
    update: "update"
  }, ur);
  var qx = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this) || this;
      r._zr = t;
      var i = Ae(r._mousedownHandler, r), a = Ae(r._mousemoveHandler, r), s = Ae(r._mouseupHandler, r), o = Ae(r._mousewheelHandler, r), l = Ae(r._pinchHandler, r);
      return r.enable = function(u, c) {
        this.disable(), this._opt = je(Qe(c) || {}, {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: false,
          preventDefaultMouseMove: true
        }), u == null && (u = true), (u === true || u === "move" || u === "pan") && (t.on("mousedown", i), t.on("mousemove", a), t.on("mouseup", s)), (u === true || u === "scale" || u === "zoom") && (t.on("mousewheel", o), t.on("pinch", l));
      }, r.disable = function() {
        t.off("mousedown", i), t.off("mousemove", a), t.off("mouseup", s), t.off("mousewheel", o), t.off("pinch", l);
      }, r;
    }
    return e.prototype.isDragging = function() {
      return this._dragging;
    }, e.prototype.isPinching = function() {
      return this._pinching;
    }, e.prototype.setPointerChecker = function(t) {
      this.pointerChecker = t;
    }, e.prototype.dispose = function() {
      this.disable();
    }, e.prototype._mousedownHandler = function(t) {
      if (!X3(t)) {
        for (var r = t.target; r; ) {
          if (r.draggable) return;
          r = r.__hostTarget || r.parent;
        }
        var i = t.offsetX, a = t.offsetY;
        this.pointerChecker && this.pointerChecker(t, i, a) && (this._x = i, this._y = a, this._dragging = true);
      }
    }, e.prototype._mousemoveHandler = function(t) {
      if (!(!this._dragging || !u_("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || vz(this._zr, "globalPan"))) {
        var r = t.offsetX, i = t.offsetY, a = this._x, s = this._y, o = r - a, l = i - s;
        this._x = r, this._y = i, this._opt.preventDefaultMouseMove && Ul(t.event), Wq(this, "pan", "moveOnMouseMove", t, {
          dx: o,
          dy: l,
          oldX: a,
          oldY: s,
          newX: r,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, e.prototype._mouseupHandler = function(t) {
      X3(t) || (this._dragging = false);
    }, e.prototype._mousewheelHandler = function(t) {
      var r = u_("zoomOnMouseWheel", t, this._opt), i = u_("moveOnMouseWheel", t, this._opt), a = t.wheelDelta, s = Math.abs(a), o = t.offsetX, l = t.offsetY;
      if (!(a === 0 || !r && !i)) {
        if (r) {
          var u = s > 3 ? 1.4 : s > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
          Zk(this, "zoom", "zoomOnMouseWheel", t, {
            scale: c,
            originX: o,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var h = Math.abs(a), d = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
          Zk(this, "scrollMove", "moveOnMouseWheel", t, {
            scrollDelta: d,
            originX: o,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, e.prototype._pinchHandler = function(t) {
      if (!vz(this._zr, "globalPan")) {
        var r = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
        Zk(this, "zoom", null, t, {
          scale: r,
          originX: t.pinchX,
          originY: t.pinchY,
          isAvailableBehavior: null
        });
      }
    }, e;
  }(Is);
  function Zk(n, e, t, r, i) {
    n.pointerChecker && n.pointerChecker(r, i.originX, i.originY) && (Ul(r.event), Wq(n, e, t, r, i));
  }
  function Wq(n, e, t, r, i) {
    i.isAvailableBehavior = Ae(u_, null, t, r), n.trigger(e, i);
  }
  function u_(n, e, t) {
    var r = t[n];
    return !n || r && (!Ie(r) || e.event[r + "Key"]);
  }
  function VE(n, e, t) {
    var r = n.target;
    r.x += e, r.y += t, r.dirty();
  }
  function WE(n, e, t, r) {
    var i = n.target, a = n.zoomLimit, s = n.zoom = n.zoom || 1;
    if (s *= e, a) {
      var o = a.min || 0, l = a.max || 1 / 0;
      s = Math.max(Math.min(l, s), o);
    }
    var u = s / n.zoom;
    n.zoom = s, i.x -= (t - i.x) * (u - 1), i.y -= (r - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
  }
  var vve = {
    axisPointer: 1,
    tooltip: 1,
    brush: 1
  };
  function GC(n, e, t) {
    var r = e.getComponentByElement(n.topTarget), i = r && r.coordinateSystem;
    return r && r !== t && !vve.hasOwnProperty(r.mainType) && i && i.model !== t;
  }
  function Gq(n) {
    if (Ie(n)) {
      var e = new DOMParser();
      n = e.parseFromString(n, "text/xml");
    }
    var t = n;
    for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1; ) t = t.nextSibling;
    return t;
  }
  var Qk, aS = {
    fill: "fill",
    stroke: "stroke",
    "stroke-width": "lineWidth",
    opacity: "opacity",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-miterlimit": "miterLimit",
    "font-family": "fontFamily",
    "font-size": "fontSize",
    "font-style": "fontStyle",
    "font-weight": "fontWeight",
    "text-anchor": "textAlign",
    visibility: "visibility",
    display: "display"
  }, yz = Mt(aS), sS = {
    "alignment-baseline": "textBaseline",
    "stop-color": "stopColor"
  }, xz = Mt(sS), yve = function() {
    function n() {
      this._defs = {}, this._root = null;
    }
    return n.prototype.parse = function(e, t) {
      t = t || {};
      var r = Gq(e);
      this._defsUsePending = [];
      var i = new tt();
      this._root = i;
      var a = [], s = r.getAttribute("viewBox") || "", o = parseFloat(r.getAttribute("width") || t.width), l = parseFloat(r.getAttribute("height") || t.height);
      isNaN(o) && (o = null), isNaN(l) && (l = null), Pa(r, i, null, true, false);
      for (var u = r.firstChild; u; ) this._parseNode(u, i, a, null, false, false), u = u.nextSibling;
      wve(this._defs, this._defsUsePending), this._defsUsePending = [];
      var c, h;
      if (s) {
        var d = UC(s);
        d.length >= 4 && (c = {
          x: parseFloat(d[0] || 0),
          y: parseFloat(d[1] || 0),
          width: parseFloat(d[2]),
          height: parseFloat(d[3])
        });
      }
      if (c && o != null && l != null && (h = Hq(c, {
        x: 0,
        y: 0,
        width: o,
        height: l
      }), !t.ignoreViewBox)) {
        var f = i;
        i = new tt(), i.add(f), f.scaleX = f.scaleY = h.scale, f.x = h.x, f.y = h.y;
      }
      return !t.ignoreRootClip && o != null && l != null && i.setClipPath(new Vt({
        shape: {
          x: 0,
          y: 0,
          width: o,
          height: l
        }
      })), {
        root: i,
        width: o,
        height: l,
        viewBoxRect: c,
        viewBoxTransform: h,
        named: a
      };
    }, n.prototype._parseNode = function(e, t, r, i, a, s) {
      var o = e.nodeName.toLowerCase(), l, u = i;
      if (o === "defs" && (a = true), o === "text" && (s = true), o === "defs" || o === "switch") l = t;
      else {
        if (!a) {
          var c = Qk[o];
          if (c && $e(Qk, o)) {
            l = c.call(this, e, t);
            var h = e.getAttribute("name");
            if (h) {
              var d = {
                name: h,
                namedFrom: null,
                svgNodeTagLower: o,
                el: l
              };
              r.push(d), o === "g" && (u = d);
            } else i && r.push({
              name: i.name,
              namedFrom: i,
              svgNodeTagLower: o,
              el: l
            });
            t.add(l);
          }
        }
        var f = bz[o];
        if (f && $e(bz, o)) {
          var p = f.call(this, e), g = e.getAttribute("id");
          g && (this._defs[g] = p);
        }
      }
      if (l && l.isGroup) for (var m = e.firstChild; m; ) m.nodeType === 1 ? this._parseNode(m, l, r, u, a, s) : m.nodeType === 3 && s && this._parseText(m, l), m = m.nextSibling;
    }, n.prototype._parseText = function(e, t) {
      var r = new Eg({
        style: {
          text: e.textContent
        },
        silent: true,
        x: this._textX || 0,
        y: this._textY || 0
      });
      ts(t, r), Pa(e, r, this._defsUsePending, false, false), xve(r, t);
      var i = r.style, a = i.fontSize;
      a && a < 9 && (i.fontSize = 9, r.scaleX *= a / 9, r.scaleY *= a / 9);
      var s = (i.fontSize || i.fontFamily) && [
        i.fontStyle,
        i.fontWeight,
        (i.fontSize || 12) + "px",
        i.fontFamily || "sans-serif"
      ].join(" ");
      i.font = s;
      var o = r.getBoundingRect();
      return this._textX += o.width, t.add(r), r;
    }, n.internalField = function() {
      Qk = {
        g: function(e, t) {
          var r = new tt();
          return ts(t, r), Pa(e, r, this._defsUsePending, false, false), r;
        },
        rect: function(e, t) {
          var r = new Vt();
          return ts(t, r), Pa(e, r, this._defsUsePending, false, false), r.setShape({
            x: parseFloat(e.getAttribute("x") || "0"),
            y: parseFloat(e.getAttribute("y") || "0"),
            width: parseFloat(e.getAttribute("width") || "0"),
            height: parseFloat(e.getAttribute("height") || "0")
          }), r.silent = true, r;
        },
        circle: function(e, t) {
          var r = new iu();
          return ts(t, r), Pa(e, r, this._defsUsePending, false, false), r.setShape({
            cx: parseFloat(e.getAttribute("cx") || "0"),
            cy: parseFloat(e.getAttribute("cy") || "0"),
            r: parseFloat(e.getAttribute("r") || "0")
          }), r.silent = true, r;
        },
        line: function(e, t) {
          var r = new zr();
          return ts(t, r), Pa(e, r, this._defsUsePending, false, false), r.setShape({
            x1: parseFloat(e.getAttribute("x1") || "0"),
            y1: parseFloat(e.getAttribute("y1") || "0"),
            x2: parseFloat(e.getAttribute("x2") || "0"),
            y2: parseFloat(e.getAttribute("y2") || "0")
          }), r.silent = true, r;
        },
        ellipse: function(e, t) {
          var r = new _C();
          return ts(t, r), Pa(e, r, this._defsUsePending, false, false), r.setShape({
            cx: parseFloat(e.getAttribute("cx") || "0"),
            cy: parseFloat(e.getAttribute("cy") || "0"),
            rx: parseFloat(e.getAttribute("rx") || "0"),
            ry: parseFloat(e.getAttribute("ry") || "0")
          }), r.silent = true, r;
        },
        polygon: function(e, t) {
          var r = e.getAttribute("points"), i;
          r && (i = Sz(r));
          var a = new ia({
            shape: {
              points: i || []
            },
            silent: true
          });
          return ts(t, a), Pa(e, a, this._defsUsePending, false, false), a;
        },
        polyline: function(e, t) {
          var r = e.getAttribute("points"), i;
          r && (i = Sz(r));
          var a = new oa({
            shape: {
              points: i || []
            },
            silent: true
          });
          return ts(t, a), Pa(e, a, this._defsUsePending, false, false), a;
        },
        image: function(e, t) {
          var r = new oi();
          return ts(t, r), Pa(e, r, this._defsUsePending, false, false), r.setStyle({
            image: e.getAttribute("xlink:href") || e.getAttribute("href"),
            x: +e.getAttribute("x"),
            y: +e.getAttribute("y"),
            width: +e.getAttribute("width"),
            height: +e.getAttribute("height")
          }), r.silent = true, r;
        },
        text: function(e, t) {
          var r = e.getAttribute("x") || "0", i = e.getAttribute("y") || "0", a = e.getAttribute("dx") || "0", s = e.getAttribute("dy") || "0";
          this._textX = parseFloat(r) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(s);
          var o = new tt();
          return ts(t, o), Pa(e, o, this._defsUsePending, false, true), o;
        },
        tspan: function(e, t) {
          var r = e.getAttribute("x"), i = e.getAttribute("y");
          r != null && (this._textX = parseFloat(r)), i != null && (this._textY = parseFloat(i));
          var a = e.getAttribute("dx") || "0", s = e.getAttribute("dy") || "0", o = new tt();
          return ts(t, o), Pa(e, o, this._defsUsePending, false, true), this._textX += parseFloat(a), this._textY += parseFloat(s), o;
        },
        path: function(e, t) {
          var r = e.getAttribute("d") || "", i = E8(r);
          return ts(t, i), Pa(e, i, this._defsUsePending, false, false), i.silent = true, i;
        }
      };
    }(), n;
  }(), bz = {
    lineargradient: function(n) {
      var e = parseInt(n.getAttribute("x1") || "0", 10), t = parseInt(n.getAttribute("y1") || "0", 10), r = parseInt(n.getAttribute("x2") || "10", 10), i = parseInt(n.getAttribute("y2") || "0", 10), a = new Px(e, t, r, i);
      return wz(n, a), _z(n, a), a;
    },
    radialgradient: function(n) {
      var e = parseInt(n.getAttribute("cx") || "0", 10), t = parseInt(n.getAttribute("cy") || "0", 10), r = parseInt(n.getAttribute("r") || "0", 10), i = new F8(e, t, r);
      return wz(n, i), _z(n, i), i;
    }
  };
  function wz(n, e) {
    var t = n.getAttribute("gradientUnits");
    t === "userSpaceOnUse" && (e.global = true);
  }
  function _z(n, e) {
    for (var t = n.firstChild; t; ) {
      if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") {
        var r = t.getAttribute("offset"), i = void 0;
        r && r.indexOf("%") > 0 ? i = parseInt(r, 10) / 100 : r ? i = parseFloat(r) : i = 0;
        var a = {};
        Uq(t, a, a);
        var s = a.stopColor || t.getAttribute("stop-color") || "#000000";
        e.colorStops.push({
          offset: i,
          color: s
        });
      }
      t = t.nextSibling;
    }
  }
  function ts(n, e) {
    n && n.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), je(e.__inheritedStyle, n.__inheritedStyle));
  }
  function Sz(n) {
    for (var e = UC(n), t = [], r = 0; r < e.length; r += 2) {
      var i = parseFloat(e[r]), a = parseFloat(e[r + 1]);
      t.push([
        i,
        a
      ]);
    }
    return t;
  }
  function Pa(n, e, t, r, i) {
    var a = e, s = a.__inheritedStyle = a.__inheritedStyle || {}, o = {};
    n.nodeType === 1 && (Cve(n, e), Uq(n, s, o), r || Ive(n, s, o)), a.style = a.style || {}, s.fill != null && (a.style.fill = Cz(a, "fill", s.fill, t)), s.stroke != null && (a.style.stroke = Cz(a, "stroke", s.stroke, t)), P([
      "lineWidth",
      "opacity",
      "fillOpacity",
      "strokeOpacity",
      "miterLimit",
      "fontSize"
    ], function(l) {
      s[l] != null && (a.style[l] = parseFloat(s[l]));
    }), P([
      "lineDashOffset",
      "lineCap",
      "lineJoin",
      "fontWeight",
      "fontFamily",
      "fontStyle",
      "textAlign"
    ], function(l) {
      s[l] != null && (a.style[l] = s[l]);
    }), i && (a.__selfStyle = o), s.lineDash && (a.style.lineDash = me(UC(s.lineDash), function(l) {
      return parseFloat(l);
    })), (s.visibility === "hidden" || s.visibility === "collapse") && (a.invisible = true), s.display === "none" && (a.ignore = true);
  }
  function xve(n, e) {
    var t = e.__selfStyle;
    if (t) {
      var r = t.textBaseline, i = r;
      !r || r === "auto" || r === "baseline" ? i = "alphabetic" : r === "before-edge" || r === "text-before-edge" ? i = "top" : r === "after-edge" || r === "text-after-edge" ? i = "bottom" : (r === "central" || r === "mathematical") && (i = "middle"), n.style.textBaseline = i;
    }
    var a = e.__inheritedStyle;
    if (a) {
      var s = a.textAlign, o = s;
      s && (s === "middle" && (o = "center"), n.style.textAlign = o);
    }
  }
  var bve = /^url\(\s*#(.*?)\)/;
  function Cz(n, e, t, r) {
    var i = t && t.match(bve);
    if (i) {
      var a = Hs(i[1]);
      r.push([
        n,
        e,
        a
      ]);
      return;
    }
    return t === "none" && (t = null), t;
  }
  function wve(n, e) {
    for (var t = 0; t < e.length; t++) {
      var r = e[t];
      r[0].style[r[1]] = n[r[2]];
    }
  }
  var _ve = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
  function UC(n) {
    return n.match(_ve) || [];
  }
  var Sve = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, Jk = Math.PI / 180;
  function Cve(n, e) {
    var t = n.getAttribute("transform");
    if (t) {
      t = t.replace(/,/g, " ");
      var r = [], i = null;
      t.replace(Sve, function(h, d, f) {
        return r.push(d, f), "";
      });
      for (var a = r.length - 1; a > 0; a -= 2) {
        var s = r[a], o = r[a - 1], l = UC(s);
        switch (i = i || za(), o) {
          case "translate":
            Jo(i, i, [
              parseFloat(l[0]),
              parseFloat(l[1] || "0")
            ]);
            break;
          case "scale":
            FN(i, i, [
              parseFloat(l[0]),
              parseFloat(l[1] || l[0])
            ]);
            break;
          case "rotate":
            Md(i, i, -parseFloat(l[0]) * Jk, [
              parseFloat(l[1] || "0"),
              parseFloat(l[2] || "0")
            ]);
            break;
          case "skewX":
            var u = Math.tan(parseFloat(l[0]) * Jk);
            Ml(i, [
              1,
              0,
              u,
              1,
              0,
              0
            ], i);
            break;
          case "skewY":
            var c = Math.tan(parseFloat(l[0]) * Jk);
            Ml(i, [
              1,
              c,
              0,
              1,
              0,
              0
            ], i);
            break;
          case "matrix":
            i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
            break;
        }
      }
      e.setLocalTransform(i);
    }
  }
  var Iz = /([^\s:;]+)\s*:\s*([^:;]+)/g;
  function Uq(n, e, t) {
    var r = n.getAttribute("style");
    if (r) {
      Iz.lastIndex = 0;
      for (var i; (i = Iz.exec(r)) != null; ) {
        var a = i[1], s = $e(aS, a) ? aS[a] : null;
        s && (e[s] = i[2]);
        var o = $e(sS, a) ? sS[a] : null;
        o && (t[o] = i[2]);
      }
    }
  }
  function Ive(n, e, t) {
    for (var r = 0; r < yz.length; r++) {
      var i = yz[r], a = n.getAttribute(i);
      a != null && (e[aS[i]] = a);
    }
    for (var r = 0; r < xz.length; r++) {
      var i = xz[r], a = n.getAttribute(i);
      a != null && (t[sS[i]] = a);
    }
  }
  function Hq(n, e) {
    var t = e.width / n.width, r = e.height / n.height, i = Math.min(t, r);
    return {
      scale: i,
      x: -(n.x + n.width / 2) * i + (e.x + e.width / 2),
      y: -(n.y + n.height / 2) * i + (e.y + e.height / 2)
    };
  }
  function kve(n, e) {
    var t = new yve();
    return t.parse(n, e);
  }
  var Tve = Pe([
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path",
    "text",
    "tspan",
    "g"
  ]), Ave = function() {
    function n(e, t) {
      this.type = "geoSVG", this._usedGraphicMap = Pe(), this._freedGraphics = [], this._mapName = e, this._parsedXML = Gq(t);
    }
    return n.prototype.load = function() {
      var e = this._firstGraphic;
      if (!e) {
        e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var t = Rve(e.named), r = t.regions, i = t.regionsMap;
        this._regions = r, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, n.prototype._buildGraphic = function(e) {
      var t, r;
      try {
        t = e && kve(e, {
          ignoreViewBox: true,
          ignoreRootClip: true
        }) || {}, r = t.root, ta(r != null);
      } catch (m) {
        throw new Error(`Invalid svg format
` + m.message);
      }
      var i = new tt();
      i.add(r), i.isGeoSVGGraphicRoot = true;
      var a = t.width, s = t.height, o = t.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, h = void 0, d = void 0;
        if (a != null ? (u = 0, h = a) : o && (u = o.x, h = o.width), s != null ? (c = 0, d = s) : o && (c = o.y, d = o.height), u == null || c == null) {
          var f = r.getBoundingRect();
          u == null && (u = f.x, h = f.width), c == null && (c = f.y, d = f.height);
        }
        l = this._boundingRect = new vt(u, c, h, d);
      }
      if (o) {
        var p = Hq(o, l);
        r.scaleX = r.scaleY = p.scale, r.x = p.x, r.y = p.y;
      }
      i.setClipPath(new Vt({
        shape: l.plain()
      }));
      var g = [];
      return P(t.named, function(m) {
        Tve.get(m.svgNodeTagLower) != null && (g.push(m), Dve(m.el));
      }), {
        root: i,
        boundingRect: l,
        named: g
      };
    }, n.prototype.useGraphic = function(e) {
      var t = this._usedGraphicMap, r = t.get(e);
      return r || (r = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, r), r);
    }, n.prototype.freeGraphic = function(e) {
      var t = this._usedGraphicMap, r = t.get(e);
      r && (t.removeKey(e), this._freedGraphics.push(r));
    }, n;
  }();
  function Dve(n) {
    n.silent = false, n.isGroup && n.traverse(function(e) {
      e.silent = false;
    });
  }
  function Rve(n) {
    var e = [], t = Pe();
    return P(n, function(r) {
      if (r.namedFrom == null) {
        var i = new Cpe(r.name, r.el);
        e.push(i), t.set(r.name, i);
      }
    }), {
      regions: e,
      regionsMap: t
    };
  }
  var wR = [
    126,
    25
  ], kz = "\u5357\u6D77\u8BF8\u5C9B", mh = [
    [
      [
        0,
        3.5
      ],
      [
        7,
        11.2
      ],
      [
        15,
        11.9
      ],
      [
        30,
        7
      ],
      [
        42,
        0.7
      ],
      [
        52,
        0.7
      ],
      [
        56,
        7.7
      ],
      [
        59,
        0.7
      ],
      [
        64,
        0.7
      ],
      [
        64,
        0
      ],
      [
        5,
        0
      ],
      [
        0,
        3.5
      ]
    ],
    [
      [
        13,
        16.1
      ],
      [
        19,
        14.7
      ],
      [
        16,
        21.7
      ],
      [
        11,
        23.1
      ],
      [
        13,
        16.1
      ]
    ],
    [
      [
        12,
        32.2
      ],
      [
        14,
        38.5
      ],
      [
        15,
        38.5
      ],
      [
        13,
        32.2
      ],
      [
        12,
        32.2
      ]
    ],
    [
      [
        16,
        47.6
      ],
      [
        12,
        53.2
      ],
      [
        13,
        53.2
      ],
      [
        18,
        47.6
      ],
      [
        16,
        47.6
      ]
    ],
    [
      [
        6,
        64.4
      ],
      [
        8,
        70
      ],
      [
        9,
        70
      ],
      [
        8,
        64.4
      ],
      [
        6,
        64.4
      ]
    ],
    [
      [
        23,
        82.6
      ],
      [
        29,
        79.8
      ],
      [
        30,
        79.8
      ],
      [
        25,
        82.6
      ],
      [
        23,
        82.6
      ]
    ],
    [
      [
        37,
        70.7
      ],
      [
        43,
        62.3
      ],
      [
        44,
        62.3
      ],
      [
        39,
        70.7
      ],
      [
        37,
        70.7
      ]
    ],
    [
      [
        48,
        51.1
      ],
      [
        51,
        45.5
      ],
      [
        53,
        45.5
      ],
      [
        50,
        51.1
      ],
      [
        48,
        51.1
      ]
    ],
    [
      [
        51,
        35
      ],
      [
        51,
        28.7
      ],
      [
        53,
        28.7
      ],
      [
        53,
        35
      ],
      [
        51,
        35
      ]
    ],
    [
      [
        52,
        22.4
      ],
      [
        55,
        17.5
      ],
      [
        56,
        17.5
      ],
      [
        53,
        22.4
      ],
      [
        52,
        22.4
      ]
    ],
    [
      [
        58,
        12.6
      ],
      [
        62,
        7
      ],
      [
        63,
        7
      ],
      [
        60,
        12.6
      ],
      [
        58,
        12.6
      ]
    ],
    [
      [
        0,
        3.5
      ],
      [
        0,
        93.1
      ],
      [
        64,
        93.1
      ],
      [
        64,
        0
      ],
      [
        63,
        0
      ],
      [
        63,
        92.4
      ],
      [
        1,
        92.4
      ],
      [
        1,
        3.5
      ],
      [
        0,
        3.5
      ]
    ]
  ];
  for (var lh = 0; lh < mh.length; lh++) for (var Fp = 0; Fp < mh[lh].length; Fp++) mh[lh][Fp][0] /= 10.5, mh[lh][Fp][1] /= -10.5 / 0.75, mh[lh][Fp][0] += wR[0], mh[lh][Fp][1] += wR[1];
  function $ve(n, e) {
    if (n === "china") {
      for (var t = 0; t < e.length; t++) if (e[t].name === kz) return;
      e.push(new VY(kz, me(mh, function(r) {
        return {
          type: "polygon",
          exterior: r
        };
      }), wR));
    }
  }
  var Nve = {
    \u5357\u6D77\u8BF8\u5C9B: [
      32,
      80
    ],
    \u5E7F\u4E1C: [
      0,
      -10
    ],
    \u9999\u6E2F: [
      10,
      5
    ],
    \u6FB3\u95E8: [
      -10,
      10
    ],
    \u5929\u6D25: [
      5,
      5
    ]
  };
  function Eve(n, e) {
    if (n === "china") {
      var t = Nve[e.name];
      if (t) {
        var r = e.getCenter();
        r[0] += t[0] / 10.5, r[1] += -t[1] / (10.5 / 0.75), e.setCenter(r);
      }
    }
  }
  var Mve = [
    [
      [
        123.45165252685547,
        25.73527164402261
      ],
      [
        123.49731445312499,
        25.73527164402261
      ],
      [
        123.49731445312499,
        25.750734064600884
      ],
      [
        123.45165252685547,
        25.750734064600884
      ],
      [
        123.45165252685547,
        25.73527164402261
      ]
    ]
  ];
  function Pve(n, e) {
    n === "china" && e.name === "\u53F0\u6E7E" && e.geometries.push({
      type: "polygon",
      exterior: Mve[0]
    });
  }
  var Lve = "name", Fve = function() {
    function n(e, t, r) {
      this.type = "geoJSON", this._parsedMap = Pe(), this._mapName = e, this._specialAreas = r, this._geoJSON = Bve(t);
    }
    return n.prototype.load = function(e, t) {
      t = t || Lve;
      var r = this._parsedMap.get(t);
      if (!r) {
        var i = this._parseToRegions(t);
        r = this._parsedMap.set(t, {
          regions: i,
          boundingRect: Ove(i)
        });
      }
      var a = Pe(), s = [];
      return P(r.regions, function(o) {
        var l = o.name;
        e && $e(e, l) && (o = o.cloneShallow(l = e[l])), s.push(o), a.set(l, o);
      }), {
        regions: s,
        boundingRect: r.boundingRect || new vt(0, 0, 0, 0),
        regionsMap: a
      };
    }, n.prototype._parseToRegions = function(e) {
      var t = this._mapName, r = this._geoJSON, i;
      try {
        i = r ? kpe(r, e) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return $ve(t, i), P(i, function(a) {
        var s = a.name;
        Eve(t, a), Pve(t, a);
        var o = this._specialAreas && this._specialAreas[s];
        o && a.transformTo(o.left, o.top, o.width, o.height);
      }, this), i;
    }, n.prototype.getMapForUser = function() {
      return {
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, n;
  }();
  function Ove(n) {
    for (var e, t = 0; t < n.length; t++) {
      var r = n[t].getBoundingRect();
      e = e || r.clone(), e.union(r);
    }
    return e;
  }
  function Bve(n) {
    return Ie(n) ? typeof JSON < "u" && JSON.parse ? JSON.parse(n) : new Function("return (" + n + ");")() : n;
  }
  var cy = Pe();
  const Kl = {
    registerMap: function(n, e, t) {
      if (e.svg) {
        var r = new Ave(n, e.svg);
        cy.set(n, r);
      } else {
        var i = e.geoJson || e.geoJSON;
        i && !e.features ? t = e.specialAreas : i = e;
        var r = new Fve(n, i, t);
        cy.set(n, r);
      }
    },
    getGeoResource: function(n) {
      return cy.get(n);
    },
    getMapForUser: function(n) {
      var e = cy.get(n);
      return e && e.type === "geoJSON" && e.getMapForUser();
    },
    load: function(n, e, t) {
      var r = cy.get(n);
      if (r) return r.load(e, t);
    }
  };
  var GE = [
    "rect",
    "circle",
    "line",
    "ellipse",
    "polygon",
    "polyline",
    "path"
  ], zve = Pe(GE), Vve = Pe(GE.concat([
    "g"
  ])), Wve = Pe(GE.concat([
    "g"
  ])), Xq = Wt();
  function Z1(n) {
    var e = n.getItemStyle(), t = n.get("areaColor");
    return t != null && (e.fill = t), e;
  }
  function Tz(n) {
    var e = n.style;
    e && (e.stroke = e.stroke || e.fill, e.fill = null);
  }
  var Yq = function() {
    function n(e) {
      var t = new tt();
      this.uid = ym("ec_map_draw"), this._controller = new qx(e.getZr()), this._controllerHost = {
        target: t
      }, this.group = t, t.add(this._regionsGroup = new tt()), t.add(this._svgGroup = new tt());
    }
    return n.prototype.draw = function(e, t, r, i, a) {
      var s = e.mainType === "geo", o = e.getData && e.getData();
      s && t.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(v) {
        !o && v.getHostGeoModel() === e && (o = v.getData());
      });
      var l = e.coordinateSystem, u = this._regionsGroup, c = this.group, h = l.getTransformInfo(), d = h.raw, f = h.roam, p = !u.childAt(0) || a;
      p ? (c.x = f.x, c.y = f.y, c.scaleX = f.scaleX, c.scaleY = f.scaleY, c.dirty()) : Kt(c, f, e);
      var g = o && o.getVisual("visualMeta") && o.getVisual("visualMeta").length > 0, m = {
        api: r,
        geo: l,
        mapOrGeoModel: e,
        data: o,
        isVisualEncodedByVisualMap: g,
        isGeo: s,
        transformInfoRaw: d
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(m) : l.resourceType === "geoSVG" && this._buildSVG(m), this._updateController(e, t, r), this._updateMapSelectHandler(e, u, r, i);
    }, n.prototype._buildGeoJSON = function(e) {
      var t = this._regionsGroupByName = Pe(), r = Pe(), i = this._regionsGroup, a = e.transformInfoRaw, s = e.mapOrGeoModel, o = e.data, l = e.geo.projection, u = l && l.stream;
      function c(f, p) {
        return p && (f = p(f)), f && [
          f[0] * a.scaleX + a.x,
          f[1] * a.scaleY + a.y
        ];
      }
      function h(f) {
        for (var p = [], g = !u && l && l.project, m = 0; m < f.length; ++m) {
          var v = c(f[m], g);
          v && p.push(v);
        }
        return p;
      }
      function d(f) {
        return {
          shape: {
            points: h(f)
          }
        };
      }
      i.removeAll(), P(e.geo.regions, function(f) {
        var p = f.name, g = t.get(p), m = r.get(p) || {}, v = m.dataIdx, y = m.regionModel;
        if (!g) {
          g = t.set(p, new tt()), i.add(g), v = o ? o.indexOfName(p) : null, y = e.isGeo ? s.getRegionModel(p) : o ? o.getItemModel(v) : null;
          var x = y.get("silent", true);
          x != null && (g.silent = x), r.set(p, {
            dataIdx: v,
            regionModel: y
          });
        }
        var b = [], w = [];
        P(f.geometries, function(I) {
          if (I.type === "polygon") {
            var C = [
              I.exterior
            ].concat(I.interiors || []);
            u && (C = Ez(C, u)), P(C, function(k) {
              b.push(new ia(d(k)));
            });
          } else {
            var T = I.points;
            u && (T = Ez(T, u, true)), P(T, function(k) {
              w.push(new oa(d(k)));
            });
          }
        });
        var _ = c(f.getCenter(), l && l.project);
        function S(I, C) {
          if (I.length) {
            var T = new JN({
              culling: true,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: I
              }
            });
            g.add(T), Az(e, T, v, y), Dz(e, T, p, y, s, v, _), C && (Tz(T), P(T.states, Tz));
          }
        }
        S(b), S(w, true);
      }), t.each(function(f, p) {
        var g = r.get(p), m = g.dataIdx, v = g.regionModel;
        Rz(e, f, p, v, s, m), $z(e, f, p, v, s), Nz(e, f, p, v, s);
      }, this);
    }, n.prototype._buildSVG = function(e) {
      var t = e.geo.map, r = e.transformInfoRaw;
      this._svgGroup.x = r.x, this._svgGroup.y = r.y, this._svgGroup.scaleX = r.scaleX, this._svgGroup.scaleY = r.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t));
      var i = this._svgDispatcherMap = Pe(), a = false;
      P(this._svgGraphicRecord.named, function(s) {
        var o = s.name, l = e.mapOrGeoModel, u = e.data, c = s.svgNodeTagLower, h = s.el, d = u ? u.indexOfName(o) : null, f = l.getRegionModel(o);
        zve.get(c) != null && h instanceof _s && Az(e, h, d, f), h instanceof _s && (h.culling = true);
        var p = f.get("silent", true);
        if (p != null && (h.silent = p), h.z2EmphasisLift = 0, !s.namedFrom && (Wve.get(c) != null && Dz(e, h, o, f, l, d, null), Rz(e, h, o, f, l, d), $z(e, h, o, f, l), Vve.get(c) != null)) {
          var g = Nz(e, h, o, f, l);
          g === "self" && (a = true);
          var m = i.get(o) || i.set(o, []);
          m.push(h);
        }
      }, this), this._enableBlurEntireSVG(a, e);
    }, n.prototype._enableBlurEntireSVG = function(e, t) {
      if (e && t.isGeo) {
        var r = t.mapOrGeoModel.getModel([
          "blur",
          "itemStyle"
        ]).getItemStyle(), i = r.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            dd(a);
            var s = a.ensureState("blur").style || {};
            s.opacity == null && i != null && (s.opacity = i), a.ensureState("emphasis");
          }
        });
      }
    }, n.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, n.prototype.findHighDownDispatchers = function(e, t) {
      if (e == null) return [];
      var r = t.coordinateSystem;
      if (r.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var a = i.get(e);
          return a ? [
            a
          ] : [];
        }
      } else if (r.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [];
    }, n.prototype._svgResourceChanged = function(e) {
      return this._svgMapName !== e;
    }, n.prototype._useSVG = function(e) {
      var t = Kl.getGeoResource(e);
      if (t && t.type === "geoSVG") {
        var r = t.useGraphic(this.uid);
        this._svgGroup.add(r.root), this._svgGraphicRecord = r, this._svgMapName = e;
      }
    }, n.prototype._freeSVG = function() {
      var e = this._svgMapName;
      if (e != null) {
        var t = Kl.getGeoResource(e);
        t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, n.prototype._updateController = function(e, t, r) {
      var i = e.coordinateSystem, a = this._controller, s = this._controllerHost;
      s.zoomLimit = e.get("scaleLimit"), s.zoom = i.getZoom(), a.enable(e.get("roam") || false);
      var o = e.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: o
        };
        return u[o + "Id"] = e.id, u;
      }
      a.off("pan").on("pan", function(u) {
        this._mouseDownFlag = false, VE(s, u.dx, u.dy), r.dispatchAction(oe(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), a.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = false, WE(s, u.scale, u.originX, u.originY), r.dispatchAction(oe(l(), {
          totalZoom: s.zoom,
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), a.setPointerChecker(function(u, c, h) {
        return i.containPoint([
          c,
          h
        ]) && !GC(u, r, e);
      });
    }, n.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(e) {
        var t = e.getTextContent();
        t && (t.ignore = Xq(t).ignore);
      });
    }, n.prototype._updateMapSelectHandler = function(e, t, r, i) {
      var a = this;
      t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function() {
        a._mouseDownFlag = true;
      }), t.on("click", function(s) {
        a._mouseDownFlag && (a._mouseDownFlag = false);
      }));
    }, n;
  }();
  function Az(n, e, t, r) {
    var i = r.getModel("itemStyle"), a = r.getModel([
      "emphasis",
      "itemStyle"
    ]), s = r.getModel([
      "blur",
      "itemStyle"
    ]), o = r.getModel([
      "select",
      "itemStyle"
    ]), l = Z1(i), u = Z1(a), c = Z1(o), h = Z1(s), d = n.data;
    if (d) {
      var f = d.getItemVisual(t, "style"), p = d.getItemVisual(t, "decal");
      n.isVisualEncodedByVisualMap && f.fill && (l.fill = f.fill), p && (l.decal = Lg(p, n.api));
    }
    e.setStyle(l), e.style.strokeNoScale = true, e.ensureState("emphasis").style = u, e.ensureState("select").style = c, e.ensureState("blur").style = h, dd(e);
  }
  function Dz(n, e, t, r, i, a, s) {
    var o = n.data, l = n.isGeo, u = o && isNaN(o.get(o.mapDimension("value"), a)), c = o && o.getItemLayout(a);
    if (l || u || c && c.showLabel) {
      var h = l ? t : a, d = void 0;
      (!o || a >= 0) && (d = i);
      var f = s ? {
        normal: {
          align: "center",
          verticalAlign: "middle"
        }
      } : null;
      gi(e, Hr(r), {
        labelFetcher: d,
        labelDataIndex: h,
        defaultText: t
      }, f);
      var p = e.getTextContent();
      if (p && (Xq(p).ignore = p.ignore, e.textConfig && s)) {
        var g = e.getBoundingRect().clone();
        e.textConfig.layoutRect = g, e.textConfig.position = [
          (s[0] - g.x) / g.width * 100 + "%",
          (s[1] - g.y) / g.height * 100 + "%"
        ];
      }
      e.disableLabelAnimation = true;
    } else e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null;
  }
  function Rz(n, e, t, r, i, a) {
    n.data ? n.data.setItemGraphicEl(a, e) : rt(e).eventData = {
      componentType: "geo",
      componentIndex: i.componentIndex,
      geoIndex: i.componentIndex,
      name: t,
      region: r && r.option || {}
    };
  }
  function $z(n, e, t, r, i) {
    n.data || Pd({
      el: e,
      componentModel: i,
      itemName: t,
      itemTooltipOption: r.get("tooltip")
    });
  }
  function Nz(n, e, t, r, i) {
    e.highDownSilentOnTouch = !!i.get("selectedMode");
    var a = r.getModel("emphasis"), s = a.get("focus");
    return Qn(e, s, a.get("blurScope"), a.get("disabled")), n.isGeo && Bue(e, i, t), s;
  }
  function Ez(n, e, t) {
    var r = [], i;
    function a() {
      i = [];
    }
    function s() {
      i.length && (r.push(i), i = []);
    }
    var o = e({
      polygonStart: a,
      polygonEnd: s,
      lineStart: a,
      lineEnd: s,
      point: function(l, u) {
        isFinite(l) && isFinite(u) && i.push([
          l,
          u
        ]);
      },
      sphere: function() {
      }
    });
    return !t && o.polygonStart(), P(n, function(l) {
      o.lineStart();
      for (var u = 0; u < l.length; u++) o.point(l[u][0], l[u][1]);
      o.lineEnd();
    }), !t && o.polygonEnd(), r;
  }
  var Gve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var s = this.group;
        if (s.removeAll(), !t.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === t.id) {
            var o = this._mapDraw;
            o && s.add(o.group);
          } else if (t.needsDrawMap) {
            var o = this._mapDraw || new Yq(i);
            s.add(o.group), o.draw(t, r, i, this, a), this._mapDraw = o;
          } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          t.get("showLegendSymbol") && r.getComponent("legend") && this._renderSymbols(t, r, i);
        }
      }
    }, e.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, e.prototype._renderSymbols = function(t, r, i) {
      var a = t.originalData, s = this.group;
      a.each(a.mapDimension("value"), function(o, l) {
        if (!isNaN(o)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, h = u.offset, d = new iu({
              style: {
                fill: t.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + h * 9,
                cy: c[1],
                r: 3
              },
              silent: true,
              z2: 8 + (h ? 0 : gm + 1)
            });
            if (!h) {
              var f = t.mainSeries.getData(), p = a.getName(l), g = f.indexOfName(p), m = a.getItemModel(l), v = m.getModel("label"), y = f.getItemGraphicEl(g);
              gi(d, Hr(m), {
                labelFetcher: {
                  getFormattedLabel: function(x, b) {
                    return t.getFormattedLabel(g, b);
                  }
                },
                defaultText: p
              }), d.disableLabelAnimation = true, v.get("position") || d.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(x) {
                B_(d, x);
              };
            }
            s.add(d);
          }
        }
      });
    }, e.type = "map", e;
  }(_n), Uve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.needsDrawMap = false, t.seriesGroup = [], t.getTooltipPosition = function(r) {
        if (r != null) {
          var i = this.getData().getName(r), a = this.coordinateSystem, s = a.getRegion(i);
          return s && a.dataToPoint(s.getCenter());
        }
      }, t;
    }
    return e.prototype.getInitialData = function(t) {
      for (var r = km(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: lt(uE, this)
      }), i = Pe(), a = [], s = 0, o = r.count(); s < o; s++) {
        var l = r.getName(s);
        i.set(l, s);
      }
      var u = Kl.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return P(u.regions, function(c) {
        var h = c.name, d = i.get(h), f = c.properties && c.properties.echartsStyle, p;
        d == null ? (p = {
          name: h
        }, a.push(p)) : p = r.getRawDataItem(d), f && pt(p, f);
      }), r.appendData(a), r;
    }, e.prototype.getHostGeoModel = function() {
      var t = this.option.geoIndex;
      return t != null ? this.ecModel.getComponent("geo", t) : null;
    }, e.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, e.prototype.getRawValue = function(t) {
      var r = this.getData();
      return r.get(r.mapDimension("value"), t);
    }, e.prototype.getRegionModel = function(t) {
      var r = this.getData();
      return r.getItemModel(r.indexOfName(t));
    }, e.prototype.formatTooltip = function(t, r, i) {
      for (var a = this.getData(), s = this.getRawValue(t), o = a.getName(t), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var h = l[c].originalData.indexOfName(o), d = a.mapDimension("value");
        isNaN(l[c].originalData.get(d, h)) || u.push(l[c].name);
      }
      return Xr("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [
          Xr("nameValue", {
            name: o,
            value: s
          })
        ]
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.getLegendIcon = function(t) {
      var r = t.icon || "roundRect", i = xr(r, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
      return i.setStyle(t.itemStyle), i.style.stroke = "none", r.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, e.type = "series.map", e.dependencies = [
      "geo"
    ], e.layoutMode = "box", e.defaultOption = {
      z: 2,
      coordinateSystem: "geo",
      map: "",
      left: "center",
      top: "center",
      aspectScale: null,
      showLegendSymbol: true,
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: true,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, e;
  }(En);
  function Hve(n, e) {
    var t = {};
    return P(n, function(r) {
      r.each(r.mapDimension("value"), function(i, a) {
        var s = "ec-" + r.getName(a);
        t[s] = t[s] || [], isNaN(i) || t[s].push(i);
      });
    }), n[0].map(n[0].mapDimension("value"), function(r, i) {
      for (var a = "ec-" + n[0].getName(i), s = 0, o = 1 / 0, l = -1 / 0, u = t[a].length, c = 0; c < u; c++) o = Math.min(o, t[a][c]), l = Math.max(l, t[a][c]), s += t[a][c];
      var h;
      return e === "min" ? h = o : e === "max" ? h = l : e === "average" ? h = s / u : h = s, u === 0 ? NaN : h;
    });
  }
  function Xve(n) {
    var e = {};
    n.eachSeriesByType("map", function(t) {
      var r = t.getHostGeoModel(), i = r ? "o" + r.id : "i" + t.getMapType();
      (e[i] = e[i] || []).push(t);
    }), P(e, function(t, r) {
      for (var i = Hve(me(t, function(s) {
        return s.getData();
      }), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++) t[a].originalData = t[a].getData();
      for (var a = 0; a < t.length; a++) t[a].seriesGroup = t, t[a].needsDrawMap = a === 0 && !t[a].getHostGeoModel(), t[a].setData(i.cloneShallow()), t[a].mainSeries = t[0];
    });
  }
  function Yve(n) {
    var e = {};
    n.eachSeriesByType("map", function(t) {
      var r = t.getMapType();
      if (!(t.getHostGeoModel() || e[r])) {
        var i = {};
        P(t.seriesGroup, function(s) {
          var o = s.coordinateSystem, l = s.originalData;
          s.get("showLegendSymbol") && n.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
            var h = l.getName(c), d = o.getRegion(h);
            if (!(!d || isNaN(u))) {
              var f = i[h] || 0, p = o.dataToPoint(d.getCenter());
              i[h] = f + 1, l.setItemLayout(c, {
                point: p,
                offset: f
              });
            }
          });
        });
        var a = t.getData();
        a.each(function(s) {
          var o = a.getName(s), l = a.getItemLayout(s) || {};
          l.showLabel = !i[o], a.setItemLayout(s, l);
        }), e[r] = true;
      }
    });
  }
  var Mz = di, jx = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r.type = "view", r.dimensions = [
        "x",
        "y"
      ], r._roamTransformable = new Tl(), r._rawTransformable = new Tl(), r.name = t, r;
    }
    return e.prototype.setBoundingRect = function(t, r, i, a) {
      return this._rect = new vt(t, r, i, a), this._rect;
    }, e.prototype.getBoundingRect = function() {
      return this._rect;
    }, e.prototype.setViewRect = function(t, r, i, a) {
      this._transformTo(t, r, i, a), this._viewRect = new vt(t, r, i, a);
    }, e.prototype._transformTo = function(t, r, i, a) {
      var s = this.getBoundingRect(), o = this._rawTransformable;
      o.transform = s.calculateTransform(new vt(t, r, i, a));
      var l = o.parent;
      o.parent = null, o.decomposeTransform(), o.parent = l, this._updateTransform();
    }, e.prototype.setCenter = function(t, r) {
      t && (this._center = [
        _e(t[0], r.getWidth()),
        _e(t[1], r.getHeight())
      ], this._updateCenterAndZoom());
    }, e.prototype.setZoom = function(t) {
      t = t || 1;
      var r = this.zoomLimit;
      r && (r.max != null && (t = Math.min(r.max, t)), r.min != null && (t = Math.max(r.min, t))), this._zoom = t, this._updateCenterAndZoom();
    }, e.prototype.getDefaultCenter = function() {
      var t = this.getBoundingRect(), r = t.x + t.width / 2, i = t.y + t.height / 2;
      return [
        r,
        i
      ];
    }, e.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, e.prototype.getZoom = function() {
      return this._zoom || 1;
    }, e.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, e.prototype._updateCenterAndZoom = function() {
      var t = this._rawTransformable.getLocalTransform(), r = this._roamTransformable, i = this.getDefaultCenter(), a = this.getCenter(), s = this.getZoom();
      a = di([], a, t), i = di([], i, t), r.originX = a[0], r.originY = a[1], r.x = i[0] - a[0], r.y = i[1] - a[1], r.scaleX = r.scaleY = s, this._updateTransform();
    }, e.prototype._updateTransform = function() {
      var t = this._roamTransformable, r = this._rawTransformable;
      r.parent = t, t.updateTransform(), r.updateTransform(), LN(this.transform || (this.transform = []), r.transform || za()), this._rawTransform = r.getLocalTransform(), this.invTransform = this.invTransform || [], fm(this.invTransform, this.transform), this.decomposeTransform();
    }, e.prototype.getTransformInfo = function() {
      var t = this._rawTransformable, r = this._roamTransformable, i = new Tl();
      return i.transform = r.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: t.x,
          y: t.y,
          scaleX: t.scaleX,
          scaleY: t.scaleY
        }
      };
    }, e.prototype.getViewRect = function() {
      return this._viewRect;
    }, e.prototype.getViewRectAfterRoam = function() {
      var t = this.getBoundingRect().clone();
      return t.applyTransform(this.transform), t;
    }, e.prototype.dataToPoint = function(t, r, i) {
      var a = r ? this._rawTransform : this.transform;
      return i = i || [], a ? Mz(i, t, a) : Wi(i, t);
    }, e.prototype.pointToData = function(t) {
      var r = this.invTransform;
      return r ? Mz([], t, r) : [
        t[0],
        t[1]
      ];
    }, e.prototype.convertToPixel = function(t, r, i) {
      var a = Pz(r);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, r, i) {
      var a = Pz(r);
      return a === this ? a.pointToData(i) : null;
    }, e.prototype.containPoint = function(t) {
      return this.getViewRectAfterRoam().contain(t[0], t[1]);
    }, e.dimensions = [
      "x",
      "y"
    ], e;
  }(Tl);
  function Pz(n) {
    var e = n.seriesModel;
    return e ? e.coordinateSystem : null;
  }
  var qve = {
    geoJSON: {
      aspectScale: 0.75,
      invertLongitute: true
    },
    geoSVG: {
      aspectScale: 1,
      invertLongitute: false
    }
  }, qq = [
    "lng",
    "lat"
  ], _R = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this, t) || this;
      a.dimensions = qq, a.type = "geo", a._nameCoordMap = Pe(), a.map = r;
      var s = i.projection, o = Kl.load(r, i.nameMap, i.nameProperty), l = Kl.getGeoResource(r);
      a.resourceType = l ? l.type : null;
      var u = a.regions = o.regions, c = qve[l.type];
      a._regionsMap = o.regionsMap, a.regions = o.regions, a.projection = s;
      var h;
      if (s) for (var d = 0; d < u.length; d++) {
        var f = u[d].getBoundingRect(s);
        h = h || f.clone(), h.union(f);
      }
      else h = o.boundingRect;
      return a.setBoundingRect(h.x, h.y, h.width, h.height), a.aspectScale = s ? 1 : it(i.aspectScale, c.aspectScale), a._invertLongitute = s ? false : c.invertLongitute, a;
    }
    return e.prototype._transformTo = function(t, r, i, a) {
      var s = this.getBoundingRect(), o = this._invertLongitute;
      s = s.clone(), o && (s.y = -s.y - s.height);
      var l = this._rawTransformable;
      l.transform = s.calculateTransform(new vt(t, r, i, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, o && (l.scaleY = -l.scaleY), this._updateTransform();
    }, e.prototype.getRegion = function(t) {
      return this._regionsMap.get(t);
    }, e.prototype.getRegionByCoord = function(t) {
      for (var r = this.regions, i = 0; i < r.length; i++) {
        var a = r[i];
        if (a.type === "geoJSON" && a.contain(t)) return r[i];
      }
    }, e.prototype.addGeoCoord = function(t, r) {
      this._nameCoordMap.set(t, r);
    }, e.prototype.getGeoCoord = function(t) {
      var r = this._regionsMap.get(t);
      return this._nameCoordMap.get(t) || r && r.getCenter();
    }, e.prototype.dataToPoint = function(t, r, i) {
      if (Ie(t) && (t = this.getGeoCoord(t)), t) {
        var a = this.projection;
        return a && (t = a.project(t)), t && this.projectedToPoint(t, r, i);
      }
    }, e.prototype.pointToData = function(t) {
      var r = this.projection;
      return r && (t = r.unproject(t)), t && this.pointToProjected(t);
    }, e.prototype.pointToProjected = function(t) {
      return n.prototype.pointToData.call(this, t);
    }, e.prototype.projectedToPoint = function(t, r, i) {
      return n.prototype.dataToPoint.call(this, t, r, i);
    }, e.prototype.convertToPixel = function(t, r, i) {
      var a = Lz(r);
      return a === this ? a.dataToPoint(i) : null;
    }, e.prototype.convertFromPixel = function(t, r, i) {
      var a = Lz(r);
      return a === this ? a.pointToData(i) : null;
    }, e;
  }(jx);
  br(_R, jx);
  function Lz(n) {
    var e = n.geoModel, t = n.seriesModel;
    return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", yr).models[0] || {}).coordinateSystem : null;
  }
  function Fz(n, e) {
    var t = n.get("boundingCoords");
    if (t != null) {
      var r = t[0], i = t[1];
      if (isFinite(r[0]) && isFinite(r[1]) && isFinite(i[0]) && isFinite(i[1])) {
        var a = this.projection;
        if (a) {
          var s = r[0], o = r[1], l = i[0], u = i[1];
          r = [
            1 / 0,
            1 / 0
          ], i = [
            -1 / 0,
            -1 / 0
          ];
          var c = function(_, S, I, C) {
            for (var T = I - _, k = C - S, D = 0; D <= 100; D++) {
              var R = D / 100, N = a.project([
                _ + T * R,
                S + k * R
              ]);
              Eu(r, r, N), Mu(i, i, N);
            }
          };
          c(s, o, l, o), c(l, o, l, u), c(l, u, s, u), c(s, u, l, o);
        }
        this.setBoundingRect(r[0], r[1], i[0] - r[0], i[1] - r[1]);
      }
    }
    var h = this.getBoundingRect(), d = n.get("layoutCenter"), f = n.get("layoutSize"), p = e.getWidth(), g = e.getHeight(), m = h.width / h.height * this.aspectScale, v = false, y, x;
    d && f && (y = [
      _e(d[0], p),
      _e(d[1], g)
    ], x = _e(f, Math.min(p, g)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(x) && (v = true));
    var b;
    if (v) b = {}, m > 1 ? (b.width = x, b.height = x / m) : (b.height = x, b.width = x * m), b.y = y[1] - b.height / 2, b.x = y[0] - b.width / 2;
    else {
      var w = n.getBoxLayoutParams();
      w.aspect = m, b = Er(w, {
        width: p,
        height: g
      });
    }
    this.setViewRect(b.x, b.y, b.width, b.height), this.setCenter(n.get("center"), e), this.setZoom(n.get("zoom"));
  }
  function jve(n, e) {
    P(e.get("geoCoord"), function(t, r) {
      n.addGeoCoord(r, t);
    });
  }
  var Kve = function() {
    function n() {
      this.dimensions = qq;
    }
    return n.prototype.create = function(e, t) {
      var r = [];
      function i(s) {
        return {
          nameProperty: s.get("nameProperty"),
          aspectScale: s.get("aspectScale"),
          projection: s.get("projection")
        };
      }
      e.eachComponent("geo", function(s, o) {
        var l = s.get("map"), u = new _R(l + o, l, oe({
          nameMap: s.get("nameMap")
        }, i(s)));
        u.zoomLimit = s.get("scaleLimit"), r.push(u), s.coordinateSystem = u, u.model = s, u.resize = Fz, u.resize(s, t);
      }), e.eachSeries(function(s) {
        var o = s.get("coordinateSystem");
        if (o === "geo") {
          var l = s.get("geoIndex") || 0;
          s.coordinateSystem = r[l];
        }
      });
      var a = {};
      return e.eachSeriesByType("map", function(s) {
        if (!s.getHostGeoModel()) {
          var o = s.getMapType();
          a[o] = a[o] || [], a[o].push(s);
        }
      }), P(a, function(s, o) {
        var l = me(s, function(c) {
          return c.get("nameMap");
        }), u = new _R(o, o, oe({
          nameMap: NN(l)
        }, i(s[0])));
        u.zoomLimit = ni.apply(null, me(s, function(c) {
          return c.get("scaleLimit");
        })), r.push(u), u.resize = Fz, u.resize(s[0], t), P(s, function(c) {
          c.coordinateSystem = u, jve(u, c);
        });
      }), r;
    }, n.prototype.getFilledRegions = function(e, t, r, i) {
      for (var a = (e || []).slice(), s = Pe(), o = 0; o < a.length; o++) s.set(a[o].name, a[o]);
      var l = Kl.load(t, r, i);
      return P(l.regions, function(u) {
        var c = u.name, h = s.get(c), d = u.properties && u.properties.echartsStyle;
        h || (h = {
          name: c
        }, a.push(h)), d && pt(h, d);
      }), a;
    }, n;
  }(), jq = new Kve(), Zve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r, i) {
      var a = Kl.getGeoResource(t.map);
      if (a && a.type === "geoJSON") {
        var s = t.itemStyle = t.itemStyle || {};
        "color" in s || (s.color = "#eee");
      }
      this.mergeDefaultAndTheme(t, i), ud(t, "label", [
        "show"
      ]);
    }, e.prototype.optionUpdated = function() {
      var t = this, r = this.option;
      r.regions = jq.getFilledRegions(r.regions, r.map, r.nameMap, r.nameProperty);
      var i = {};
      this._optionModelMap = Qo(r.regions || [], function(a, s) {
        var o = s.name;
        return o && (a.set(o, new on(s, t, t.ecModel)), s.selected && (i[o] = true)), a;
      }, Pe()), r.selectedMap || (r.selectedMap = i);
    }, e.prototype.getRegionModel = function(t) {
      return this._optionModelMap.get(t) || new on(null, this, this.ecModel);
    }, e.prototype.getFormattedLabel = function(t, r) {
      var i = this.getRegionModel(t), a = r === "normal" ? i.get([
        "label",
        "formatter"
      ]) : i.get([
        "emphasis",
        "label",
        "formatter"
      ]), s = {
        name: t
      };
      if (Xe(a)) return s.status = r, a(s);
      if (Ie(a)) return a.replace("{a}", t ?? "");
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.select = function(t) {
      var r = this.option, i = r.selectedMode;
      if (i) {
        i !== "multiple" && (r.selectedMap = null);
        var a = r.selectedMap || (r.selectedMap = {});
        a[t] = true;
      }
    }, e.prototype.unSelect = function(t) {
      var r = this.option.selectedMap;
      r && (r[t] = false);
    }, e.prototype.toggleSelected = function(t) {
      this[this.isSelected(t) ? "unSelect" : "select"](t);
    }, e.prototype.isSelected = function(t) {
      var r = this.option.selectedMap;
      return !!(r && r[t]);
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
      z: 0,
      show: true,
      left: "center",
      top: "center",
      aspectScale: null,
      silent: false,
      map: "",
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
    }, e;
  }(Et);
  function Oz(n, e) {
    return n.pointToProjected ? n.pointToProjected(e) : n.pointToData(e);
  }
  function UE(n, e, t, r) {
    var i = n.getZoom(), a = n.getCenter(), s = e.zoom, o = n.projectedToPoint ? n.projectedToPoint(a) : n.dataToPoint(a);
    if (e.dx != null && e.dy != null && (o[0] -= e.dx, o[1] -= e.dy, n.setCenter(Oz(n, o), r)), s != null) {
      if (t) {
        var l = t.min || 0, u = t.max || 1 / 0;
        s = Math.max(Math.min(i * s, u), l) / i;
      }
      n.scaleX *= s, n.scaleY *= s;
      var c = (e.originX - n.x) * (s - 1), h = (e.originY - n.y) * (s - 1);
      n.x -= c, n.y -= h, n.updateTransform(), n.setCenter(Oz(n, o), r), n.setZoom(s * i);
    }
    return {
      center: n.getCenter(),
      zoom: n.getZoom()
    };
  }
  var Qve = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.focusBlurEnabled = true, t;
    }
    return e.prototype.init = function(t, r) {
      this._api = r;
    }, e.prototype.render = function(t, r, i, a) {
      if (this._model = t, !t.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new Yq(i));
      var s = this._mapDraw;
      s.draw(t, r, i, this, a), s.group.on("click", this._handleRegionClick, this), s.group.silent = t.get("silent"), this.group.add(s.group), this.updateSelectStatus(t, r, i);
    }, e.prototype._handleRegionClick = function(t) {
      var r;
      Bh(t.target, function(i) {
        return (r = rt(i).eventData) != null;
      }, true), r && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: r.name
      });
    }, e.prototype.updateSelectStatus = function(t, r, i) {
      var a = this;
      this._mapDraw.group.traverse(function(s) {
        var o = rt(s).eventData;
        if (o) return a._model.isSelected(o.name) ? i.enterSelect(s) : i.leaveSelect(s), true;
      });
    }, e.prototype.findHighDownDispatchers = function(t) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model);
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, e.type = "geo", e;
  }(Yn);
  function Jve(n, e, t) {
    Kl.registerMap(n, e, t);
  }
  function Kq(n) {
    n.registerCoordinateSystem("geo", jq), n.registerComponentModel(Zve), n.registerComponentView(Qve), n.registerImpl("registerMap", Jve), n.registerImpl("getMap", function(t) {
      return Kl.getMapForUser(t);
    });
    function e(t, r) {
      r.update = "geo:updateSelectStatus", n.registerAction(r, function(i, a) {
        var s = {}, o = [];
        return a.eachComponent({
          mainType: "geo",
          query: i
        }, function(l) {
          l[t](i.name);
          var u = l.coordinateSystem;
          P(u.regions, function(h) {
            s[h.name] = l.isSelected(h.name) || false;
          });
          var c = [];
          P(s, function(h, d) {
            s[d] && c.push(d);
          }), o.push({
            geoIndex: l.componentIndex,
            name: c
          });
        }), {
          selected: s,
          allSelected: o,
          name: i.name
        };
      });
    }
    e("toggleSelected", {
      type: "geoToggleSelect",
      event: "geoselectchanged"
    }), e("select", {
      type: "geoSelect",
      event: "geoselected"
    }), e("unSelect", {
      type: "geoUnSelect",
      event: "geounselected"
    }), n.registerAction({
      type: "geoRoam",
      event: "geoRoam",
      update: "updateTransform"
    }, function(t, r, i) {
      var a = t.componentType || "series";
      r.eachComponent({
        mainType: a,
        query: t
      }, function(s) {
        var o = s.coordinateSystem;
        if (o.type === "geo") {
          var l = UE(o, t, s.get("scaleLimit"), i);
          s.setCenter && s.setCenter(l.center), s.setZoom && s.setZoom(l.zoom), a === "series" && P(s.seriesGroup, function(u) {
            u.setCenter(l.center), u.setZoom(l.zoom);
          });
        }
      });
    });
  }
  function eye(n) {
    Ct(Kq), n.registerChartView(Gve), n.registerSeriesModel(Uve), n.registerLayout(Yve), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, Xve), ZX("map", n.registerAction);
  }
  function tye(n) {
    var e = n;
    e.hierNode = {
      defaultAncestor: null,
      ancestor: e,
      prelim: 0,
      modifier: 0,
      change: 0,
      shift: 0,
      i: 0,
      thread: null
    };
    for (var t = [
      e
    ], r, i; r = t.pop(); ) if (i = r.children, r.isExpand && i.length) for (var a = i.length, s = a - 1; s >= 0; s--) {
      var o = i[s];
      o.hierNode = {
        defaultAncestor: null,
        ancestor: o,
        prelim: 0,
        modifier: 0,
        change: 0,
        shift: 0,
        i: s,
        thread: null
      }, t.push(o);
    }
  }
  function nye(n, e) {
    var t = n.isExpand ? n.children : [], r = n.parentNode.children, i = n.hierNode.i ? r[n.hierNode.i - 1] : null;
    if (t.length) {
      aye(n);
      var a = (t[0].hierNode.prelim + t[t.length - 1].hierNode.prelim) / 2;
      i ? (n.hierNode.prelim = i.hierNode.prelim + e(n, i), n.hierNode.modifier = n.hierNode.prelim - a) : n.hierNode.prelim = a;
    } else i && (n.hierNode.prelim = i.hierNode.prelim + e(n, i));
    n.parentNode.hierNode.defaultAncestor = sye(n, i, n.parentNode.hierNode.defaultAncestor || r[0], e);
  }
  function rye(n) {
    var e = n.hierNode.prelim + n.parentNode.hierNode.modifier;
    n.setLayout({
      x: e
    }, true), n.hierNode.modifier += n.parentNode.hierNode.modifier;
  }
  function Bz(n) {
    return arguments.length ? n : uye;
  }
  function Fy(n, e) {
    return n -= Math.PI / 2, {
      x: e * Math.cos(n),
      y: e * Math.sin(n)
    };
  }
  function iye(n, e) {
    return Er(n.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function aye(n) {
    for (var e = n.children, t = e.length, r = 0, i = 0; --t >= 0; ) {
      var a = e[t];
      a.hierNode.prelim += r, a.hierNode.modifier += r, i += a.hierNode.change, r += a.hierNode.shift + i;
    }
  }
  function sye(n, e, t, r) {
    if (e) {
      for (var i = n, a = n, s = a.parentNode.children[0], o = e, l = i.hierNode.modifier, u = a.hierNode.modifier, c = s.hierNode.modifier, h = o.hierNode.modifier; o = eT(o), a = tT(a), o && a; ) {
        i = eT(i), s = tT(s), i.hierNode.ancestor = n;
        var d = o.hierNode.prelim + h - a.hierNode.prelim - u + r(o, a);
        d > 0 && (lye(oye(o, n, t), n, d), u += d, l += d), h += o.hierNode.modifier, u += a.hierNode.modifier, l += i.hierNode.modifier, c += s.hierNode.modifier;
      }
      o && !eT(i) && (i.hierNode.thread = o, i.hierNode.modifier += h - l), a && !tT(s) && (s.hierNode.thread = a, s.hierNode.modifier += u - c, t = n);
    }
    return t;
  }
  function eT(n) {
    var e = n.children;
    return e.length && n.isExpand ? e[e.length - 1] : n.hierNode.thread;
  }
  function tT(n) {
    var e = n.children;
    return e.length && n.isExpand ? e[0] : n.hierNode.thread;
  }
  function oye(n, e, t) {
    return n.hierNode.ancestor.parentNode === e.parentNode ? n.hierNode.ancestor : t;
  }
  function lye(n, e, t) {
    var r = t / (e.hierNode.i - n.hierNode.i);
    e.hierNode.change -= r, e.hierNode.shift += t, e.hierNode.modifier += t, e.hierNode.prelim += t, n.hierNode.change += r;
  }
  function uye(n, e) {
    return n.parentNode === e.parentNode ? 1 : 2;
  }
  var cye = /* @__PURE__ */ function() {
    function n() {
      this.parentPoint = [], this.childPoints = [];
    }
    return n;
  }(), hye = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new cye();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.childPoints, a = i.length, s = r.parentPoint, o = i[0], l = i[a - 1];
      if (a === 1) {
        t.moveTo(s[0], s[1]), t.lineTo(o[0], o[1]);
        return;
      }
      var u = r.orient, c = u === "TB" || u === "BT" ? 0 : 1, h = 1 - c, d = _e(r.forkPosition, 1), f = [];
      f[c] = s[c], f[h] = s[h] + (l[h] - s[h]) * d, t.moveTo(s[0], s[1]), t.lineTo(f[0], f[1]), t.moveTo(o[0], o[1]), f[c] = o[c], t.lineTo(f[0], f[1]), f[c] = l[c], t.lineTo(f[0], f[1]), t.lineTo(l[0], l[1]);
      for (var p = 1; p < a - 1; p++) {
        var g = i[p];
        t.moveTo(g[0], g[1]), f[c] = g[c], t.lineTo(f[0], f[1]);
      }
    }, e;
  }(At), dye = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._mainGroup = new tt(), t;
    }
    return e.prototype.init = function(t, r) {
      this._controller = new qx(r.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, e.prototype.render = function(t, r, i) {
      var a = t.getData(), s = t.layoutInfo, o = this._mainGroup, l = t.get("layout");
      l === "radial" ? (o.x = s.x + s.width / 2, o.y = s.y + s.height / 2) : (o.x = s.x, o.y = s.y), this._updateViewCoordSys(t, i), this._updateController(t, r, i);
      var u = this._data;
      a.diff(u).add(function(c) {
        zz(a, c) && Vz(a, c, null, o, t);
      }).update(function(c, h) {
        var d = u.getItemGraphicEl(h);
        if (!zz(a, c)) {
          d && Gz(u, h, d, o, t);
          return;
        }
        Vz(a, c, d, o, t);
      }).remove(function(c) {
        var h = u.getItemGraphicEl(c);
        h && Gz(u, c, h, o, t);
      }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === true && a.eachItemGraphicEl(function(c, h) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: t.id,
            dataIndex: h
          });
        });
      }), this._data = a;
    }, e.prototype._updateViewCoordSys = function(t, r) {
      var i = t.getData(), a = [];
      i.each(function(h) {
        var d = i.getItemLayout(h);
        d && !isNaN(d.x) && !isNaN(d.y) && a.push([
          +d.x,
          +d.y
        ]);
      });
      var s = [], o = [];
      xC(a, s, o);
      var l = this._min, u = this._max;
      o[0] - s[0] === 0 && (s[0] = l ? l[0] : s[0] - 1, o[0] = u ? u[0] : o[0] + 1), o[1] - s[1] === 0 && (s[1] = l ? l[1] : s[1] - 1, o[1] = u ? u[1] : o[1] + 1);
      var c = t.coordinateSystem = new jx();
      c.zoomLimit = t.get("scaleLimit"), c.setBoundingRect(s[0], s[1], o[0] - s[0], o[1] - s[1]), c.setCenter(t.get("center"), r), c.setZoom(t.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = s, this._max = o;
    }, e.prototype._updateController = function(t, r, i) {
      var a = this, s = this._controller, o = this._controllerHost, l = this.group;
      s.setPointerChecker(function(u, c, h) {
        var d = l.getBoundingRect();
        return d.applyTransform(l.transform), d.contain(c, h) && !GC(u, i, t);
      }), s.enable(t.get("roam")), o.zoomLimit = t.get("scaleLimit"), o.zoom = t.coordinateSystem.getZoom(), s.off("pan").off("zoom").on("pan", function(u) {
        VE(o, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        WE(o, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(t), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function(t) {
      var r = t.getData(), i = this._getNodeGlobalScale(t);
      r.eachItemGraphicEl(function(a, s) {
        a.setSymbolScale(i);
      });
    }, e.prototype._getNodeGlobalScale = function(t) {
      var r = t.coordinateSystem;
      if (r.type !== "view") return 1;
      var i = this._nodeScaleRatio, a = r.scaleX || 1, s = r.getZoom(), o = (s - 1) * i + 1;
      return o / a;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, e.type = "tree", e;
  }(_n);
  function zz(n, e) {
    var t = n.getItemLayout(e);
    return t && !isNaN(t.x) && !isNaN(t.y);
  }
  function Vz(n, e, t, r, i) {
    var a = !t, s = n.tree.getNodeByDataIndex(e), o = s.getModel(), l = s.getVisual("style").fill, u = s.isExpand === false && s.children.length !== 0 ? l : "#fff", c = n.tree.root, h = s.parentNode === c ? s : s.parentNode || s, d = n.getItemGraphicEl(h.dataIndex), f = h.getLayout(), p = d ? {
      x: d.__oldX,
      y: d.__oldY,
      rawX: d.__radialOldRawX,
      rawY: d.__radialOldRawY
    } : f, g = s.getLayout();
    a ? (t = new Wx(n, e, null, {
      symbolInnerColor: u,
      useNameLabel: true
    }), t.x = p.x, t.y = p.y) : t.updateData(n, e, null, {
      symbolInnerColor: u,
      useNameLabel: true
    }), t.__radialOldRawX = t.__radialRawX, t.__radialOldRawY = t.__radialRawY, t.__radialRawX = g.rawX, t.__radialRawY = g.rawY, r.add(t), n.setItemGraphicEl(e, t), t.__oldX = t.x, t.__oldY = t.y, Kt(t, {
      x: g.x,
      y: g.y
    }, i);
    var m = t.getSymbolPath();
    if (i.get("layout") === "radial") {
      var v = c.children[0], y = v.getLayout(), x = v.children.length, b = void 0, w = void 0;
      if (g.x === y.x && s.isExpand === true && v.children.length) {
        var _ = {
          x: (v.children[0].getLayout().x + v.children[x - 1].getLayout().x) / 2,
          y: (v.children[0].getLayout().y + v.children[x - 1].getLayout().y) / 2
        };
        b = Math.atan2(_.y - y.y, _.x - y.x), b < 0 && (b = Math.PI * 2 + b), w = _.x < y.x, w && (b = b - Math.PI);
      } else b = Math.atan2(g.y - y.y, g.x - y.x), b < 0 && (b = Math.PI * 2 + b), s.children.length === 0 || s.children.length !== 0 && s.isExpand === false ? (w = g.x < y.x, w && (b = b - Math.PI)) : (w = g.x > y.x, w || (b = b - Math.PI));
      var S = w ? "left" : "right", I = o.getModel("label"), C = I.get("rotate"), T = C * (Math.PI / 180), k = m.getTextContent();
      k && (m.setTextConfig({
        position: I.get("position") || S,
        rotation: C == null ? -b : T,
        origin: "center"
      }), k.setStyle("verticalAlign", "middle"));
    }
    var D = o.get([
      "emphasis",
      "focus"
    ]), R = D === "relative" ? I0(s.getAncestorsIndices(), s.getDescendantIndices()) : D === "ancestor" ? s.getAncestorsIndices() : D === "descendant" ? s.getDescendantIndices() : null;
    R && (rt(t).focus = R), fye(i, s, c, t, p, f, g, r), t.__edge && (t.onHoverStateChange = function(N) {
      if (N !== "blur") {
        var E = s.parentNode && n.getItemGraphicEl(s.parentNode.dataIndex);
        E && E.hoverState === Nx || B_(t.__edge, N);
      }
    });
  }
  function fye(n, e, t, r, i, a, s, o) {
    var l = e.getModel(), u = n.get("edgeShape"), c = n.get("layout"), h = n.getOrient(), d = n.get([
      "lineStyle",
      "curveness"
    ]), f = n.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = r.__edge;
    if (u === "curve") e.parentNode && e.parentNode !== t && (g || (g = r.__edge = new Mx({
      shape: SR(c, h, d, i, i)
    })), Kt(g, {
      shape: SR(c, h, d, a, s)
    }, n));
    else if (u === "polyline" && c === "orthogonal" && e !== t && e.children && e.children.length !== 0 && e.isExpand === true) {
      for (var m = e.children, v = [], y = 0; y < m.length; y++) {
        var x = m[y].getLayout();
        v.push([
          x.x,
          x.y
        ]);
      }
      g || (g = r.__edge = new hye({
        shape: {
          parentPoint: [
            s.x,
            s.y
          ],
          childPoints: [
            [
              s.x,
              s.y
            ]
          ],
          orient: h,
          forkPosition: f
        }
      })), Kt(g, {
        shape: {
          parentPoint: [
            s.x,
            s.y
          ],
          childPoints: v
        }
      }, n);
    }
    g && !(u === "polyline" && !e.isExpand) && (g.useStyle(je({
      strokeNoScale: true,
      fill: null
    }, p)), pi(g, l, "lineStyle"), dd(g), o.add(g));
  }
  function Wz(n, e, t, r, i) {
    var a = e.tree.root, s = Zq(a, n), o = s.source, l = s.sourceLayout, u = e.getItemGraphicEl(n.dataIndex);
    if (u) {
      var c = e.getItemGraphicEl(o.dataIndex), h = c.__edge, d = u.__edge || (o.isExpand === false || o.children.length === 1 ? h : void 0), f = r.get("edgeShape"), p = r.get("layout"), g = r.get("orient"), m = r.get([
        "lineStyle",
        "curveness"
      ]);
      d && (f === "curve" ? nc(d, {
        shape: SR(p, g, m, l, l),
        style: {
          opacity: 0
        }
      }, r, {
        cb: function() {
          t.remove(d);
        },
        removeOpt: i
      }) : f === "polyline" && r.get("layout") === "orthogonal" && nc(d, {
        shape: {
          parentPoint: [
            l.x,
            l.y
          ],
          childPoints: [
            [
              l.x,
              l.y
            ]
          ]
        },
        style: {
          opacity: 0
        }
      }, r, {
        cb: function() {
          t.remove(d);
        },
        removeOpt: i
      }));
    }
  }
  function Zq(n, e) {
    for (var t = e.parentNode === n ? e : e.parentNode || e, r; r = t.getLayout(), r == null; ) t = t.parentNode === n ? t : t.parentNode || t;
    return {
      source: t,
      sourceLayout: r
    };
  }
  function Gz(n, e, t, r, i) {
    var a = n.tree.getNodeByDataIndex(e), s = n.tree.root, o = Zq(s, a).sourceLayout, l = {
      duration: i.get("animationDurationUpdate"),
      easing: i.get("animationEasingUpdate")
    };
    nc(t, {
      x: o.x + 1,
      y: o.y + 1
    }, i, {
      cb: function() {
        r.remove(t), n.setItemGraphicEl(e, null);
      },
      removeOpt: l
    }), t.fadeOut(null, n.hostModel, {
      fadeLabel: true,
      animation: l
    }), a.children.forEach(function(u) {
      Wz(u, n, r, i, l);
    }), Wz(a, n, r, i, l);
  }
  function SR(n, e, t, r, i) {
    var a, s, o, l, u, c, h, d;
    if (n === "radial") {
      u = r.rawX, h = r.rawY, c = i.rawX, d = i.rawY;
      var f = Fy(u, h), p = Fy(u, h + (d - h) * t), g = Fy(c, d + (h - d) * t), m = Fy(c, d);
      return {
        x1: f.x || 0,
        y1: f.y || 0,
        x2: m.x || 0,
        y2: m.y || 0,
        cpx1: p.x || 0,
        cpy1: p.y || 0,
        cpx2: g.x || 0,
        cpy2: g.y || 0
      };
    } else u = r.x, h = r.y, c = i.x, d = i.y, (e === "LR" || e === "RL") && (a = u + (c - u) * t, s = h, o = c + (u - c) * t, l = d), (e === "TB" || e === "BT") && (a = u, s = h + (d - h) * t, o = c, l = d + (h - d) * t);
    return {
      x1: u,
      y1: h,
      x2: c,
      y2: d,
      cpx1: a,
      cpy1: s,
      cpx2: o,
      cpy2: l
    };
  }
  var ws = Wt();
  function Qq(n) {
    var e = n.mainData, t = n.datas;
    t || (t = {
      main: e
    }, n.datasAttr = {
      main: "data"
    }), n.datas = n.mainData = null, Jq(e, t, n), P(t, function(r) {
      P(e.TRANSFERABLE_METHODS, function(i) {
        r.wrapMethod(i, lt(pye, n));
      });
    }), e.wrapMethod("cloneShallow", lt(mye, n)), P(e.CHANGABLE_METHODS, function(r) {
      e.wrapMethod(r, lt(gye, n));
    }), ta(t[e.dataType] === e);
  }
  function pye(n, e) {
    if (xye(this)) {
      var t = oe({}, ws(this).datas);
      t[this.dataType] = e, Jq(e, t, n);
    } else HE(e, this.dataType, ws(this).mainData, n);
    return e;
  }
  function gye(n, e) {
    return n.struct && n.struct.update(), e;
  }
  function mye(n, e) {
    return P(ws(e).datas, function(t, r) {
      t !== e && HE(t.cloneShallow(), r, e, n);
    }), e;
  }
  function vye(n) {
    var e = ws(this).mainData;
    return n == null || e == null ? e : ws(e).datas[n];
  }
  function yye() {
    var n = ws(this).mainData;
    return n == null ? [
      {
        data: n
      }
    ] : me(Mt(ws(n).datas), function(e) {
      return {
        type: e,
        data: ws(n).datas[e]
      };
    });
  }
  function xye(n) {
    return ws(n).mainData === n;
  }
  function Jq(n, e, t) {
    ws(n).datas = {}, P(e, function(r, i) {
      HE(r, i, n, t);
    });
  }
  function HE(n, e, t, r) {
    ws(t).datas[e] = n, ws(n).mainData = t, n.dataType = e, r.struct && (n[r.structAttr] = r.struct, r.struct[r.datasAttr[e]] = n), n.getLinkedData = vye, n.getLinkedDataAll = yye;
  }
  var bye = function() {
    function n(e, t) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = false, this.name = e || "", this.hostTree = t;
    }
    return n.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, n.prototype.eachNode = function(e, t, r) {
      Xe(e) && (r = t, t = e, e = null), e = e || {}, Ie(e) && (e = {
        order: e
      });
      var i = e.order || "preorder", a = this[e.attr || "children"], s;
      i === "preorder" && (s = t.call(r, this));
      for (var o = 0; !s && o < a.length; o++) a[o].eachNode(e, t, r);
      i === "postorder" && t.call(r, this);
    }, n.prototype.updateDepthAndHeight = function(e) {
      var t = 0;
      this.depth = e;
      for (var r = 0; r < this.children.length; r++) {
        var i = this.children[r];
        i.updateDepthAndHeight(e + 1), i.height > t && (t = i.height);
      }
      this.height = t + 1;
    }, n.prototype.getNodeById = function(e) {
      if (this.getId() === e) return this;
      for (var t = 0, r = this.children, i = r.length; t < i; t++) {
        var a = r[t].getNodeById(e);
        if (a) return a;
      }
    }, n.prototype.contains = function(e) {
      if (e === this) return true;
      for (var t = 0, r = this.children, i = r.length; t < i; t++) {
        var a = r[t].contains(e);
        if (a) return a;
      }
    }, n.prototype.getAncestors = function(e) {
      for (var t = [], r = e ? this : this.parentNode; r; ) t.push(r), r = r.parentNode;
      return t.reverse(), t;
    }, n.prototype.getAncestorsIndices = function() {
      for (var e = [], t = this; t; ) e.push(t.dataIndex), t = t.parentNode;
      return e.reverse(), e;
    }, n.prototype.getDescendantIndices = function() {
      var e = [];
      return this.eachNode(function(t) {
        e.push(t.dataIndex);
      }), e;
    }, n.prototype.getValue = function(e) {
      var t = this.hostTree.data;
      return t.getStore().get(t.getDimensionIndex(e || "value"), this.dataIndex);
    }, n.prototype.setLayout = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t);
    }, n.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostTree, r = t.data.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, n.prototype.setVisual = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t);
    }, n.prototype.getVisual = function(e) {
      return this.hostTree.data.getItemVisual(this.dataIndex, e);
    }, n.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, n.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, n.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var e = this.parentNode.children, t = 0; t < e.length; ++t) if (e[t] === this) return t;
        return -1;
      }
      return -1;
    }, n.prototype.isAncestorOf = function(e) {
      for (var t = e.parentNode; t; ) {
        if (t === this) return true;
        t = t.parentNode;
      }
      return false;
    }, n.prototype.isDescendantOf = function(e) {
      return e !== this && e.isAncestorOf(this);
    }, n;
  }(), XE = function() {
    function n(e) {
      this.type = "tree", this._nodes = [], this.hostModel = e;
    }
    return n.prototype.eachNode = function(e, t, r) {
      this.root.eachNode(e, t, r);
    }, n.prototype.getNodeByDataIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this._nodes[t];
    }, n.prototype.getNodeById = function(e) {
      return this.root.getNodeById(e);
    }, n.prototype.update = function() {
      for (var e = this.data, t = this._nodes, r = 0, i = t.length; r < i; r++) t[r].dataIndex = -1;
      for (var r = 0, i = e.count(); r < i; r++) t[e.getRawIndex(r)].dataIndex = r;
    }, n.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, n.createTree = function(e, t, r) {
      var i = new n(t), a = [], s = 1;
      o(e);
      function o(c, h) {
        var d = c.value;
        s = Math.max(s, de(d) ? d.length : 1), a.push(c);
        var f = new bye(kr(c.name, ""), i);
        h ? wye(f, h) : i.root = f, i._nodes.push(f);
        var p = c.children;
        if (p) for (var g = 0; g < p.length; g++) o(p[g], f);
      }
      i.root.updateDepthAndHeight(0);
      var l = zx(a, {
        coordDimensions: [
          "value"
        ],
        dimensionsCount: s
      }).dimensions, u = new Ki(l, t);
      return u.initData(a), r && r(u), Qq({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, n;
  }();
  function wye(n, e) {
    var t = e.children;
    n.parentNode !== e && (t.push(n), n.parentNode = e);
  }
  function H0(n, e, t) {
    if (n && bt(e, n.type) >= 0) {
      var r = t.getData().tree.root, i = n.targetNode;
      if (Ie(i) && (i = r.getNodeById(i)), i && r.contains(i)) return {
        node: i
      };
      var a = n.targetNodeId;
      if (a != null && (i = r.getNodeById(a))) return {
        node: i
      };
    }
  }
  function ej(n) {
    for (var e = []; n; ) n = n.parentNode, n && e.push(n);
    return e.reverse();
  }
  function YE(n, e) {
    var t = ej(n);
    return bt(t, e) >= 0;
  }
  function HC(n, e) {
    for (var t = []; n; ) {
      var r = n.dataIndex;
      t.push({
        name: n.name,
        dataIndex: r,
        value: e.getRawValue(r)
      }), n = n.parentNode;
    }
    return t.reverse(), t;
  }
  var _ye = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.hasSymbolVisual = true, t.ignoreStyleOnData = true, t;
    }
    return e.prototype.getInitialData = function(t) {
      var r = {
        name: t.name,
        children: t.data
      }, i = t.leaves || {}, a = new on(i, this, this.ecModel), s = XE.createTree(r, this, o);
      function o(h) {
        h.wrapMethod("getItemModel", function(d, f) {
          var p = s.getNodeByDataIndex(f);
          return p && p.children.length && p.isExpand || (d.parentModel = a), d;
        });
      }
      var l = 0;
      s.eachNode("preorder", function(h) {
        h.depth > l && (l = h.depth);
      });
      var u = t.expandAndCollapse, c = u && t.initialTreeDepth >= 0 ? t.initialTreeDepth : l;
      return s.root.eachNode("preorder", function(h) {
        var d = h.hostTree.data.getRawDataItem(h.dataIndex);
        h.isExpand = d && d.collapsed != null ? !d.collapsed : h.depth <= c;
      }), s.data;
    }, e.prototype.getOrient = function() {
      var t = this.get("orient");
      return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t;
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.formatTooltip = function(t, r, i) {
      for (var a = this.getData().tree, s = a.root.children[0], o = a.getNodeByDataIndex(t), l = o.getValue(), u = o.name; o && o !== s; ) u = o.parentNode.name + "." + u, o = o.parentNode;
      return Xr("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treeAncestors = HC(i, this), r.collapsed = !i.isExpand, r;
    }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      layout: "orthogonal",
      edgeShape: "curve",
      edgeForkPosition: "50%",
      roam: false,
      nodeScaleRatio: 0.4,
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: true,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        borderWidth: 1.5
      },
      label: {
        show: true
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, e;
  }(En);
  function Sye(n, e, t) {
    for (var r = [
      n
    ], i = [], a; a = r.pop(); ) if (i.push(a), a.isExpand) {
      var s = a.children;
      if (s.length) for (var o = 0; o < s.length; o++) r.push(s[o]);
    }
    for (; a = i.pop(); ) e(a, t);
  }
  function hy(n, e) {
    for (var t = [
      n
    ], r; r = t.pop(); ) if (e(r), r.isExpand) {
      var i = r.children;
      if (i.length) for (var a = i.length - 1; a >= 0; a--) t.push(i[a]);
    }
  }
  function Cye(n, e) {
    n.eachSeriesByType("tree", function(t) {
      Iye(t, e);
    });
  }
  function Iye(n, e) {
    var t = iye(n, e);
    n.layoutInfo = t;
    var r = n.get("layout"), i = 0, a = 0, s = null;
    r === "radial" ? (i = 2 * Math.PI, a = Math.min(t.height, t.width) / 2, s = Bz(function(x, b) {
      return (x.parentNode === b.parentNode ? 1 : 2) / x.depth;
    })) : (i = t.width, a = t.height, s = Bz());
    var o = n.getData().tree.root, l = o.children[0];
    if (l) {
      tye(o), Sye(l, nye, s), o.hierNode.modifier = -l.hierNode.prelim, hy(l, rye);
      var u = l, c = l, h = l;
      hy(l, function(x) {
        var b = x.getLayout().x;
        b < u.getLayout().x && (u = x), b > c.getLayout().x && (c = x), x.depth > h.depth && (h = x);
      });
      var d = u === c ? 1 : s(u, c) / 2, f = d - u.getLayout().x, p = 0, g = 0, m = 0, v = 0;
      if (r === "radial") p = i / (c.getLayout().x + d + f), g = a / (h.depth - 1 || 1), hy(l, function(x) {
        m = (x.getLayout().x + f) * p, v = (x.depth - 1) * g;
        var b = Fy(m, v);
        x.setLayout({
          x: b.x,
          y: b.y,
          rawX: m,
          rawY: v
        }, true);
      });
      else {
        var y = n.getOrient();
        y === "RL" || y === "LR" ? (g = a / (c.getLayout().x + d + f), p = i / (h.depth - 1 || 1), hy(l, function(x) {
          v = (x.getLayout().x + f) * g, m = y === "LR" ? (x.depth - 1) * p : i - (x.depth - 1) * p, x.setLayout({
            x: m,
            y: v
          }, true);
        })) : (y === "TB" || y === "BT") && (p = i / (c.getLayout().x + d + f), g = a / (h.depth - 1 || 1), hy(l, function(x) {
          m = (x.getLayout().x + f) * p, v = y === "TB" ? (x.depth - 1) * g : a - (x.depth - 1) * g, x.setLayout({
            x: m,
            y: v
          }, true);
        }));
      }
    }
  }
  function kye(n) {
    n.eachSeriesByType("tree", function(e) {
      var t = e.getData(), r = t.tree;
      r.eachNode(function(i) {
        var a = i.getModel(), s = a.getModel("itemStyle").getItemStyle(), o = t.ensureUniqueItemVisual(i.dataIndex, "style");
        oe(o, s);
      });
    });
  }
  function Tye(n) {
    n.registerAction({
      type: "treeExpandAndCollapse",
      event: "treeExpandAndCollapse",
      update: "update"
    }, function(e, t) {
      t.eachComponent({
        mainType: "series",
        subType: "tree",
        query: e
      }, function(r) {
        var i = e.dataIndex, a = r.getData().tree, s = a.getNodeByDataIndex(i);
        s.isExpand = !s.isExpand;
      });
    }), n.registerAction({
      type: "treeRoam",
      event: "treeRoam",
      update: "none"
    }, function(e, t, r) {
      t.eachComponent({
        mainType: "series",
        subType: "tree",
        query: e
      }, function(i) {
        var a = i.coordinateSystem, s = UE(a, e, void 0, r);
        i.setCenter && i.setCenter(s.center), i.setZoom && i.setZoom(s.zoom);
      });
    });
  }
  function Aye(n) {
    n.registerChartView(dye), n.registerSeriesModel(_ye), n.registerLayout(Cye), n.registerVisual(kye), Tye(n);
  }
  var Uz = [
    "treemapZoomToNode",
    "treemapRender",
    "treemapMove"
  ];
  function Dye(n) {
    for (var e = 0; e < Uz.length; e++) n.registerAction({
      type: Uz[e],
      update: "updateView"
    }, ur);
    n.registerAction({
      type: "treemapRootToNode",
      update: "updateView"
    }, function(t, r) {
      r.eachComponent({
        mainType: "series",
        subType: "treemap",
        query: t
      }, i);
      function i(a, s) {
        var o = [
          "treemapZoomToNode",
          "treemapRootToNode"
        ], l = H0(t, o, a);
        if (l) {
          var u = a.getViewRoot();
          u && (t.direction = YE(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
        }
      }
    });
  }
  function tj(n) {
    var e = n.getData(), t = e.tree, r = {};
    t.eachNode(function(i) {
      for (var a = i; a && a.depth > 1; ) a = a.parentNode;
      var s = ZD(n.ecModel, a.name || a.dataIndex + "", r);
      i.setVisual("decal", s);
    });
  }
  var Rye = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.preventUsingHoverLayer = true, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = {
        name: t.name,
        children: t.data
      };
      nj(i);
      var a = t.levels || [], s = this.designatedVisualItemStyle = {}, o = new on({
        itemStyle: s
      }, this, r);
      a = t.levels = $ye(a, r);
      var l = me(a || [], function(h) {
        return new on(h, o, r);
      }, this), u = XE.createTree(i, this, c);
      function c(h) {
        h.wrapMethod("getItemModel", function(d, f) {
          var p = u.getNodeByDataIndex(f), g = p ? l[p.depth] : null;
          return d.parentModel = g || o, d;
        });
      }
      return u.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), s = this.getRawValue(t), o = a.getName(t);
      return Xr("nameValue", {
        name: o,
        value: s
      });
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treeAncestors = HC(i, this), r.treePathInfo = r.treeAncestors, r;
    }, e.prototype.setLayoutInfo = function(t) {
      this.layoutInfo = this.layoutInfo || {}, oe(this.layoutInfo, t);
    }, e.prototype.mapIdToIndex = function(t) {
      var r = this._idIndexMap;
      r || (r = this._idIndexMap = Pe(), this._idIndexMapCount = 0);
      var i = r.get(t);
      return i == null && r.set(t, i = this._idIndexMapCount++), i;
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var r = this.getRawData().tree.root;
      (!t || t !== r && !r.contains(t)) && (this._viewRoot = r);
    }, e.prototype.enableAriaDecal = function() {
      tj(this);
    }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = {
      progressive: 0,
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: true,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "\u25B6",
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: true,
      nodeClick: "zoomToNode",
      animation: true,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: true,
        height: 22,
        left: "center",
        top: "bottom",
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
          }
        }
      },
      label: {
        show: true,
        distance: 0,
        padding: 5,
        position: "inside",
        color: "#fff",
        overflow: "truncate"
      },
      upperLabel: {
        show: false,
        position: [
          0,
          "50%"
        ],
        height: 20,
        overflow: "truncate",
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
      },
      emphasis: {
        upperLabel: {
          show: true,
          position: [
            0,
            "50%"
          ],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: []
    }, e;
  }(En);
  function nj(n) {
    var e = 0;
    P(n.children, function(r) {
      nj(r);
      var i = r.value;
      de(i) && (i = i[0]), e += i;
    });
    var t = n.value;
    de(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), de(n.value) ? n.value[0] = t : n.value = t;
  }
  function $ye(n, e) {
    var t = xn(e.get("color")), r = xn(e.get([
      "aria",
      "decal",
      "decals"
    ]));
    if (t) {
      n = n || [];
      var i, a;
      P(n, function(o) {
        var l = new on(o), u = l.get("color"), c = l.get("decal");
        (l.get([
          "itemStyle",
          "color"
        ]) || u && u !== "none") && (i = true), (l.get([
          "itemStyle",
          "decal"
        ]) || c && c !== "none") && (a = true);
      });
      var s = n[0] || (n[0] = {});
      return i || (s.color = t.slice()), !a && r && (s.decal = r.slice()), n;
    }
  }
  var Nye = 8, Hz = 8, nT = 5, Eye = function() {
    function n(e) {
      this.group = new tt(), e.add(this.group);
    }
    return n.prototype.render = function(e, t, r, i) {
      var a = e.getModel("breadcrumb"), s = this.group;
      if (s.removeAll(), !(!a.get("show") || !r)) {
        var o = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = o.getModel("textStyle"), c = l.getModel([
          "itemStyle",
          "textStyle"
        ]), h = {
          pos: {
            left: a.get("left"),
            right: a.get("right"),
            top: a.get("top"),
            bottom: a.get("bottom")
          },
          box: {
            width: t.getWidth(),
            height: t.getHeight()
          },
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(r, h, u), this._renderContent(e, h, o, l, u, c, i), NC(s, h.pos, h.box);
      }
    }, n.prototype._prepare = function(e, t, r) {
      for (var i = e; i; i = i.parentNode) {
        var a = kr(i.getModel().get("name"), ""), s = r.getTextRect(a), o = Math.max(s.width + Nye * 2, t.emptyItemWidth);
        t.totalWidth += o + Hz, t.renderList.push({
          node: i,
          text: a,
          width: o
        });
      }
    }, n.prototype._renderContent = function(e, t, r, i, a, s, o) {
      for (var l = 0, u = t.emptyItemWidth, c = e.get([
        "breadcrumb",
        "height"
      ]), h = Vce(t.pos, t.box), d = t.totalWidth, f = t.renderList, p = i.getModel("itemStyle").getItemStyle(), g = f.length - 1; g >= 0; g--) {
        var m = f[g], v = m.node, y = m.width, x = m.text;
        d > h.width && (d -= y - u, y = u, x = null);
        var b = new ia({
          shape: {
            points: Mye(l, 0, y, c, g === f.length - 1, g === 0)
          },
          style: je(r.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new Gt({
            style: $n(a, {
              text: x
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: gm * 1e4,
          onclick: lt(o, v)
        });
        b.disableLabelAnimation = true, b.getTextContent().ensureState("emphasis").style = $n(s, {
          text: x
        }), b.ensureState("emphasis").style = p, Qn(b, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(b), Pye(b, e, v), l += y + Hz;
      }
    }, n.prototype.remove = function() {
      this.group.removeAll();
    }, n;
  }();
  function Mye(n, e, t, r, i, a) {
    var s = [
      [
        i ? n : n - nT,
        e
      ],
      [
        n + t,
        e
      ],
      [
        n + t,
        e + r
      ],
      [
        i ? n : n - nT,
        e + r
      ]
    ];
    return !a && s.splice(2, 0, [
      n + t + nT,
      e + r / 2
    ]), !i && s.push([
      n,
      e + r / 2
    ]), s;
  }
  function Pye(n, e, t) {
    rt(n).eventData = {
      componentType: "series",
      componentSubType: "treemap",
      componentIndex: e.componentIndex,
      seriesIndex: e.seriesIndex,
      seriesName: e.name,
      seriesType: "treemap",
      selfType: "breadcrumb",
      nodeData: {
        dataIndex: t && t.dataIndex,
        name: t && t.name
      },
      treePathInfo: t && HC(t, e)
    };
  }
  var Lye = function() {
    function n() {
      this._storage = [], this._elExistsMap = {};
    }
    return n.prototype.add = function(e, t, r, i, a) {
      return this._elExistsMap[e.id] ? false : (this._elExistsMap[e.id] = true, this._storage.push({
        el: e,
        target: t,
        duration: r,
        delay: i,
        easing: a
      }), true);
    }, n.prototype.finished = function(e) {
      return this._finishedCallback = e, this;
    }, n.prototype.start = function() {
      for (var e = this, t = this._storage.length, r = function() {
        t--, t <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback());
      }, i = 0, a = this._storage.length; i < a; i++) {
        var s = this._storage[i];
        s.el.animateTo(s.target, {
          duration: s.duration,
          delay: s.delay,
          easing: s.easing,
          setToFinal: true,
          done: r,
          aborted: r
        });
      }
      return this;
    }, n;
  }();
  function Fye() {
    return new Lye();
  }
  var CR = tt, Xz = Vt, Yz = 3, qz = "label", jz = "upperLabel", Oye = gm * 10, Bye = gm * 2, zye = gm * 3, vh = hd([
    [
      "fill",
      "color"
    ],
    [
      "stroke",
      "strokeColor"
    ],
    [
      "lineWidth",
      "strokeWidth"
    ],
    [
      "shadowBlur"
    ],
    [
      "shadowOffsetX"
    ],
    [
      "shadowOffsetY"
    ],
    [
      "shadowColor"
    ]
  ]), Kz = function(n) {
    var e = vh(n);
    return e.stroke = e.fill = e.lineWidth = null, e;
  }, oS = Wt(), Vye = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._state = "ready", t._storage = dy(), t;
    }
    return e.prototype.render = function(t, r, i, a) {
      var s = r.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(bt(s, t) < 0)) {
        this.seriesModel = t, this.api = i, this.ecModel = r;
        var o = [
          "treemapZoomToNode",
          "treemapRootToNode"
        ], l = H0(a, o, t), u = a && a.type, c = t.layoutInfo, h = !this._oldTree, d = this._storage, f = u === "treemapRootToNode" && l && d ? {
          rootNodeGroup: d.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, p = this._giveContainerGroup(c), g = t.get("animation"), m = this._doRender(p, t, f);
        g && !h && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, m, t, f) : m.renderFinally(), this._resetController(i), this._renderBreadcrumb(t, i, l);
      }
    }, e.prototype._giveContainerGroup = function(t) {
      var r = this._containerGroup;
      return r || (r = this._containerGroup = new CR(), this._initEvents(r), this.group.add(r)), r.x = t.x, r.y = t.y, r;
    }, e.prototype._doRender = function(t, r, i) {
      var a = r.getData().tree, s = this._oldTree, o = dy(), l = dy(), u = this._storage, c = [];
      function h(y, x, b, w) {
        return Wye(r, l, u, i, o, c, y, x, b, w);
      }
      g(a.root ? [
        a.root
      ] : [], s && s.root ? [
        s.root
      ] : [], t, a === s || !s, 0);
      var d = m(u);
      if (this._oldTree = a, this._storage = l, this._controllerHost) {
        var f = this.seriesModel.layoutInfo, p = a.root.getLayout();
        p.width === f.width && p.height === f.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: o,
        willDeleteEls: d,
        renderFinally: v
      };
      function g(y, x, b, w, _) {
        w ? (x = y, P(y, function(C, T) {
          !C.isRemoved() && I(T, T);
        })) : new ql(x, y, S, S).add(I).update(I).remove(lt(I, null)).execute();
        function S(C) {
          return C.getId();
        }
        function I(C, T) {
          var k = C != null ? y[C] : null, D = T != null ? x[T] : null, R = h(k, D, b, _);
          R && g(k && k.viewChildren || [], D && D.viewChildren || [], R, w, _ + 1);
        }
      }
      function m(y) {
        var x = dy();
        return y && P(y, function(b, w) {
          var _ = x[w];
          P(b, function(S) {
            S && (_.push(S), oS(S).willDelete = true);
          });
        }), x;
      }
      function v() {
        P(d, function(y) {
          P(y, function(x) {
            x.parent && x.parent.remove(x);
          });
        }), P(c, function(y) {
          y.invisible = true, y.dirty();
        });
      }
    }, e.prototype._doAnimation = function(t, r, i, a) {
      var s = i.get("animationDurationUpdate"), o = i.get("animationEasing"), l = (Xe(s) ? 0 : s) || 0, u = (Xe(o) ? null : o) || "cubicOut", c = Fye();
      P(r.willDeleteEls, function(h, d) {
        P(h, function(f, p) {
          if (!f.invisible) {
            var g = f.parent, m, v = oS(g);
            if (a && a.direction === "drillDown") m = g === a.rootNodeGroup ? {
              shape: {
                x: 0,
                y: 0,
                width: v.nodeWidth,
                height: v.nodeHeight
              },
              style: {
                opacity: 0
              }
            } : {
              style: {
                opacity: 0
              }
            };
            else {
              var y = 0, x = 0;
              v.willDelete || (y = v.nodeWidth / 2, x = v.nodeHeight / 2), m = d === "nodeGroup" ? {
                x: y,
                y: x,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: x,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            m && c.add(f, m, l, 0, u);
          }
        });
      }), P(this._storage, function(h, d) {
        P(h, function(f, p) {
          var g = r.lastsForAnimation[d][p], m = {};
          g && (f instanceof tt ? g.oldX != null && (m.x = f.x, m.y = f.y, f.x = g.oldX, f.y = g.oldY) : (g.oldShape && (m.shape = oe({}, f.shape), f.setShape(g.oldShape)), g.fadein ? (f.setStyle("opacity", 0), m.style = {
            opacity: 1
          }) : f.style.opacity !== 1 && (m.style = {
            opacity: 1
          })), c.add(f, m, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(Ae(function() {
        this._state = "ready", r.renderFinally();
      }, this)).start();
    }, e.prototype._resetController = function(t) {
      var r = this._controller, i = this._controllerHost;
      i || (this._controllerHost = {
        target: this.group
      }, i = this._controllerHost), r || (r = this._controller = new qx(t.getZr()), r.enable(this.seriesModel.get("roam")), i.zoomLimit = this.seriesModel.get("scaleLimit"), i.zoom = this.seriesModel.get("zoom"), r.on("pan", Ae(this._onPan, this)), r.on("zoom", Ae(this._onZoom, this)));
      var a = new vt(0, 0, t.getWidth(), t.getHeight());
      r.setPointerChecker(function(s, o, l) {
        return a.contain(o, l);
      });
    }, e.prototype._clearController = function() {
      var t = this._controller;
      this._controllerHost = null, t && (t.dispose(), t = null);
    }, e.prototype._onPan = function(t) {
      if (this._state !== "animating" && (Math.abs(t.dx) > Yz || Math.abs(t.dy) > Yz)) {
        var r = this.seriesModel.getData().tree.root;
        if (!r) return;
        var i = r.getLayout();
        if (!i) return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + t.dx,
            y: i.y + t.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, e.prototype._onZoom = function(t) {
      var r = t.originX, i = t.originY, a = t.scale;
      if (this._state !== "animating") {
        var s = this.seriesModel.getData().tree.root;
        if (!s) return;
        var o = s.getLayout();
        if (!o) return;
        var l = new vt(o.x, o.y, o.width, o.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var h = c.zoom = c.zoom || 1;
        if (h *= a, u) {
          var d = u.min || 0, f = u.max || 1 / 0;
          h = Math.max(Math.min(f, h), d);
        }
        var p = h / c.zoom;
        c.zoom = h;
        var g = this.seriesModel.layoutInfo;
        r -= g.x, i -= g.y;
        var m = za();
        Jo(m, m, [
          -r,
          -i
        ]), FN(m, m, [
          p,
          p
        ]), Jo(m, m, [
          r,
          i
        ]), l.applyTransform(m), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, e.prototype._initEvents = function(t) {
      var r = this;
      t.on("click", function(i) {
        if (r._state === "ready") {
          var a = r.seriesModel.get("nodeClick", true);
          if (a) {
            var s = r.findTarget(i.offsetX, i.offsetY);
            if (s) {
              var o = s.node;
              if (o.getLayout().isLeafRoot) r._rootToNode(s);
              else if (a === "zoomToNode") r._zoomToNode(s);
              else if (a === "link") {
                var l = o.hostTree.data.getItemModel(o.dataIndex), u = l.get("link", true), c = l.get("target", true) || "blank";
                u && H_(u, c);
              }
            }
          }
        }
      }, this);
    }, e.prototype._renderBreadcrumb = function(t, r, i) {
      var a = this;
      i || (i = t.get("leafDepth", true) != null ? {
        node: t.getViewRoot()
      } : this.findTarget(r.getWidth() / 2, r.getHeight() / 2), i || (i = {
        node: t.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new Eye(this.group))).render(t, r, i.node, function(s) {
        a._state !== "animating" && (YE(t.getViewRoot(), s) ? a._rootToNode({
          node: s
        }) : a._zoomToNode({
          node: s
        }));
      });
    }, e.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = dy(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, e.prototype.dispose = function() {
      this._clearController();
    }, e.prototype._zoomToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype._rootToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype.findTarget = function(t, r) {
      var i, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(s) {
        var o = this._storage.background[s.getRawIndex()];
        if (o) {
          var l = o.transformCoordToLocal(t, r), u = o.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height) i = {
            node: s,
            offsetX: l[0],
            offsetY: l[1]
          };
          else return false;
        }
      }, this), i;
    }, e.type = "treemap", e;
  }(_n);
  function dy() {
    return {
      nodeGroup: [],
      background: [],
      content: []
    };
  }
  function Wye(n, e, t, r, i, a, s, o, l, u) {
    if (!s) return;
    var c = s.getLayout(), h = n.getData(), d = s.getModel();
    if (h.setItemGraphicEl(s.dataIndex, null), !c || !c.isInView) return;
    var f = c.width, p = c.height, g = c.borderWidth, m = c.invisible, v = s.getRawIndex(), y = o && o.getRawIndex(), x = s.viewChildren, b = c.upperHeight, w = x && x.length, _ = d.getModel("itemStyle"), S = d.getModel([
      "emphasis",
      "itemStyle"
    ]), I = d.getModel([
      "blur",
      "itemStyle"
    ]), C = d.getModel([
      "select",
      "itemStyle"
    ]), T = _.get("borderRadius") || 0, k = Y("nodeGroup", CR);
    if (!k) return;
    if (l.add(k), k.x = c.x || 0, k.y = c.y || 0, k.markRedraw(), oS(k).nodeWidth = f, oS(k).nodeHeight = p, c.isAboveViewRoot) return k;
    var D = Y("background", Xz, u, Bye);
    D && F(k, D, w && c.upperLabelHeight);
    var R = d.getModel("emphasis"), N = R.get("focus"), E = R.get("blurScope"), A = R.get("disabled"), M = N === "ancestor" ? s.getAncestorsIndices() : N === "descendant" ? s.getDescendantIndices() : N;
    if (w) N0(k) && Fh(k, false), D && (Fh(D, !A), h.setItemGraphicEl(s.dataIndex, D), GD(D, M, E));
    else {
      var $ = Y("content", Xz, u, zye);
      $ && O(k, $), D.disableMorphing = true, D && N0(D) && Fh(D, false), Fh(k, !A), h.setItemGraphicEl(s.dataIndex, k);
      var L = d.getShallow("cursor");
      L && $.attr("cursor", L), GD(k, M, E);
    }
    return k;
    function F(re, ae, fe) {
      var ce = rt(ae);
      if (ce.dataIndex = s.dataIndex, ce.seriesIndex = n.seriesIndex, ae.setShape({
        x: 0,
        y: 0,
        width: f,
        height: p,
        r: T
      }), m) z(ae);
      else {
        ae.invisible = false;
        var ye = s.getVisual("style"), Le = ye.stroke, Re = Kz(_);
        Re.fill = Le;
        var be = vh(S);
        be.fill = S.get("borderColor");
        var xe = vh(I);
        xe.fill = I.get("borderColor");
        var ot = vh(C);
        if (ot.fill = C.get("borderColor"), fe) {
          var G = f - 2 * g;
          V(ae, Le, ye.opacity, {
            x: g,
            y: 0,
            width: G,
            height: b
          });
        } else ae.removeTextContent();
        ae.setStyle(Re), ae.ensureState("emphasis").style = be, ae.ensureState("blur").style = xe, ae.ensureState("select").style = ot, dd(ae);
      }
      re.add(ae);
    }
    function O(re, ae) {
      var fe = rt(ae);
      fe.dataIndex = s.dataIndex, fe.seriesIndex = n.seriesIndex;
      var ce = Math.max(f - 2 * g, 0), ye = Math.max(p - 2 * g, 0);
      if (ae.culling = true, ae.setShape({
        x: g,
        y: g,
        width: ce,
        height: ye,
        r: T
      }), m) z(ae);
      else {
        ae.invisible = false;
        var Le = s.getVisual("style"), Re = Le.fill, be = Kz(_);
        be.fill = Re, be.decal = Le.decal;
        var xe = vh(S), ot = vh(I), G = vh(C);
        V(ae, Re, Le.opacity, null), ae.setStyle(be), ae.ensureState("emphasis").style = xe, ae.ensureState("blur").style = ot, ae.ensureState("select").style = G, dd(ae);
      }
      re.add(ae);
    }
    function z(re) {
      !re.invisible && a.push(re);
    }
    function V(re, ae, fe, ce) {
      var ye = d.getModel(ce ? jz : qz), Le = kr(d.get("name"), null), Re = ye.getShallow("show");
      gi(re, Hr(d, ce ? jz : qz), {
        defaultText: Re ? Le : null,
        inheritColor: ae,
        defaultOpacity: fe,
        labelFetcher: n,
        labelDataIndex: s.dataIndex
      });
      var be = re.getTextContent();
      if (be) {
        var xe = be.style, ot = MN(xe.padding || 0);
        ce && (re.setTextConfig({
          layoutRect: ce
        }), be.disableLabelLayout = true), be.beforeUpdate = function() {
          var q = Math.max((ce ? ce.width : re.shape.width) - ot[1] - ot[3], 0), ge = Math.max((ce ? ce.height : re.shape.height) - ot[0] - ot[2], 0);
          (xe.width !== q || xe.height !== ge) && be.setStyle({
            width: q,
            height: ge
          });
        }, xe.truncateMinChar = 2, xe.lineOverflow = "truncate", H(xe, ce, c);
        var G = be.getState("emphasis");
        H(G ? G.style : null, ce, c);
      }
    }
    function H(re, ae, fe) {
      var ce = re ? re.text : null;
      if (!ae && fe.isLeafRoot && ce != null) {
        var ye = n.get("drillDownIcon", true);
        re.text = ye ? ye + " " + ce : ce;
      }
    }
    function Y(re, ae, fe, ce) {
      var ye = y != null && t[re][y], Le = i[re];
      return ye ? (t[re][y] = null, le(Le, ye)) : m || (ye = new ae(), ye instanceof _s && (ye.z2 = Gye(fe, ce)), ve(Le, ye)), e[re][v] = ye;
    }
    function le(re, ae) {
      var fe = re[v] = {};
      ae instanceof CR ? (fe.oldX = ae.x, fe.oldY = ae.y) : fe.oldShape = oe({}, ae.shape);
    }
    function ve(re, ae) {
      var fe = re[v] = {}, ce = s.parentNode, ye = ae instanceof tt;
      if (ce && (!r || r.direction === "drillDown")) {
        var Le = 0, Re = 0, be = i.background[ce.getRawIndex()];
        !r && be && be.oldShape && (Le = be.oldShape.width, Re = be.oldShape.height), ye ? (fe.oldX = 0, fe.oldY = Re) : fe.oldShape = {
          x: Le,
          y: Re,
          width: 0,
          height: 0
        };
      }
      fe.fadein = !ye;
    }
  }
  function Gye(n, e) {
    return n * Oye + e;
  }
  var X0 = P, Uye = Ze, lS = -1, Gr = function() {
    function n(e) {
      var t = e.mappingMethod, r = e.type, i = this.option = Qe(e);
      this.type = r, this.mappingMethod = t, this._normalizeData = Yye[t];
      var a = n.visualHandlers[r];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[t], t === "piecewise" ? (rT(i), Hye(i)) : t === "category" ? i.categories ? Xye(i) : rT(i, true) : (ta(t !== "linear" || i.dataExtent), rT(i));
    }
    return n.prototype.mapValueToVisual = function(e) {
      var t = this._normalizeData(e);
      return this._normalizedToVisual(t, e);
    }, n.prototype.getNormalizer = function() {
      return Ae(this._normalizeData, this);
    }, n.listVisualTypes = function() {
      return Mt(n.visualHandlers);
    }, n.isValidType = function(e) {
      return n.visualHandlers.hasOwnProperty(e);
    }, n.eachVisual = function(e, t, r) {
      Ze(e) ? P(e, t, r) : t.call(r, e);
    }, n.mapVisual = function(e, t, r) {
      var i, a = de(e) ? [] : Ze(e) ? {} : (i = true, null);
      return n.eachVisual(e, function(s, o) {
        var l = t.call(r, s, o);
        i ? a = l : a[o] = l;
      }), a;
    }, n.retrieveVisuals = function(e) {
      var t = {}, r;
      return e && X0(n.visualHandlers, function(i, a) {
        e.hasOwnProperty(a) && (t[a] = e[a], r = true);
      }), r ? t : null;
    }, n.prepareVisualTypes = function(e) {
      if (de(e)) e = e.slice();
      else if (Uye(e)) {
        var t = [];
        X0(e, function(r, i) {
          t.push(i);
        }), e = t;
      } else return [];
      return e.sort(function(r, i) {
        return i === "color" && r !== "color" && r.indexOf("color") === 0 ? 1 : -1;
      }), e;
    }, n.dependsOn = function(e, t) {
      return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t;
    }, n.findPieceIndex = function(e, t, r) {
      for (var i, a = 1 / 0, s = 0, o = t.length; s < o; s++) {
        var l = t[s].value;
        if (l != null) {
          if (l === e || Ie(l) && l === e + "") return s;
          r && d(l, s);
        }
      }
      for (var s = 0, o = t.length; s < o; s++) {
        var u = t[s], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (J1(h[1], e, c[1])) return s;
          } else if (c[1] === 1 / 0) {
            if (J1(h[0], c[0], e)) return s;
          } else if (J1(h[0], c[0], e) && J1(h[1], e, c[1])) return s;
          r && d(c[0], s), r && d(c[1], s);
        }
      }
      if (r) return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : i;
      function d(f, p) {
        var g = Math.abs(f - e);
        g < a && (a = g, i = p);
      }
    }, n.visualHandlers = {
      color: {
        applyVisual: fy("color"),
        getColorMapper: function() {
          var e = this.option;
          return Ae(e.mappingMethod === "category" ? function(t, r) {
            return !r && (t = this._normalizeData(t)), Oy.call(this, t);
          } : function(t, r, i) {
            var a = !!i;
            return !r && (t = this._normalizeData(t)), i = F2(t, e.parsedVisual, i), a ? i : Pl(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(e) {
            return Pl(F2(e, this.option.parsedVisual), "rgba");
          },
          category: Oy,
          piecewise: function(e, t) {
            var r = kR.call(this, t);
            return r == null && (r = Pl(F2(e, this.option.parsedVisual), "rgba")), r;
          },
          fixed: yh
        }
      },
      colorHue: Q1(function(e, t) {
        return t0(e, t);
      }),
      colorSaturation: Q1(function(e, t) {
        return t0(e, null, t);
      }),
      colorLightness: Q1(function(e, t) {
        return t0(e, null, null, t);
      }),
      colorAlpha: Q1(function(e, t) {
        return E_(e, t);
      }),
      decal: {
        applyVisual: fy("decal"),
        _normalizedToVisual: {
          linear: null,
          category: Oy,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: fy("opacity"),
        _normalizedToVisual: IR([
          0,
          1
        ])
      },
      liftZ: {
        applyVisual: fy("liftZ"),
        _normalizedToVisual: {
          linear: yh,
          category: yh,
          piecewise: yh,
          fixed: yh
        }
      },
      symbol: {
        applyVisual: function(e, t, r) {
          var i = this.mapValueToVisual(e);
          r("symbol", i);
        },
        _normalizedToVisual: {
          linear: Zz,
          category: Oy,
          piecewise: function(e, t) {
            var r = kR.call(this, t);
            return r == null && (r = Zz.call(this, e)), r;
          },
          fixed: yh
        }
      },
      symbolSize: {
        applyVisual: fy("symbolSize"),
        _normalizedToVisual: IR([
          0,
          1
        ])
      }
    }, n;
  }();
  function Hye(n) {
    var e = n.pieceList;
    n.hasSpecialVisual = false, P(e, function(t, r) {
      t.originIndex = r, t.visual != null && (n.hasSpecialVisual = true);
    });
  }
  function Xye(n) {
    var e = n.categories, t = n.categoryMap = {}, r = n.visual;
    if (X0(e, function(s, o) {
      t[s] = o;
    }), !de(r)) {
      var i = [];
      Ze(r) ? X0(r, function(s, o) {
        var l = t[o];
        i[l ?? lS] = s;
      }) : i[lS] = r, r = rj(n, i);
    }
    for (var a = e.length - 1; a >= 0; a--) r[a] == null && (delete t[e[a]], e.pop());
  }
  function rT(n, e) {
    var t = n.visual, r = [];
    Ze(t) ? X0(t, function(a) {
      r.push(a);
    }) : t != null && r.push(t);
    var i = {
      color: 1,
      symbol: 1
    };
    !e && r.length === 1 && !i.hasOwnProperty(n.type) && (r[1] = r[0]), rj(n, r);
  }
  function Q1(n) {
    return {
      applyVisual: function(e, t, r) {
        var i = this.mapValueToVisual(e);
        r("color", n(t("color"), i));
      },
      _normalizedToVisual: IR([
        0,
        1
      ])
    };
  }
  function Zz(n) {
    var e = this.option.visual;
    return e[Math.round(sn(n, [
      0,
      1
    ], [
      0,
      e.length - 1
    ], true))] || {};
  }
  function fy(n) {
    return function(e, t, r) {
      r(n, this.mapValueToVisual(e));
    };
  }
  function Oy(n) {
    var e = this.option.visual;
    return e[this.option.loop && n !== lS ? n % e.length : n];
  }
  function yh() {
    return this.option.visual[0];
  }
  function IR(n) {
    return {
      linear: function(e) {
        return sn(e, n, this.option.visual, true);
      },
      category: Oy,
      piecewise: function(e, t) {
        var r = kR.call(this, t);
        return r == null && (r = sn(e, n, this.option.visual, true)), r;
      },
      fixed: yh
    };
  }
  function kR(n) {
    var e = this.option, t = e.pieceList;
    if (e.hasSpecialVisual) {
      var r = Gr.findPieceIndex(n, t), i = t[r];
      if (i && i.visual) return i.visual[this.type];
    }
  }
  function rj(n, e) {
    return n.visual = e, n.type === "color" && (n.parsedVisual = me(e, function(t) {
      var r = Va(t);
      return r || [
        0,
        0,
        0,
        1
      ];
    })), e;
  }
  var Yye = {
    linear: function(n) {
      return sn(n, this.option.dataExtent, [
        0,
        1
      ], true);
    },
    piecewise: function(n) {
      var e = this.option.pieceList, t = Gr.findPieceIndex(n, e, true);
      if (t != null) return sn(t, [
        0,
        e.length - 1
      ], [
        0,
        1
      ], true);
    },
    category: function(n) {
      var e = this.option.categories ? this.option.categoryMap[n] : n;
      return e ?? lS;
    },
    fixed: ur
  };
  function J1(n, e, t) {
    return n ? e <= t : e < t;
  }
  var qye = "itemStyle", ij = Wt();
  const jye = {
    seriesType: "treemap",
    reset: function(n) {
      var e = n.getData().tree, t = e.root;
      t.isRemoved() || aj(t, {}, n.getViewRoot().getAncestors(), n);
    }
  };
  function aj(n, e, t, r) {
    var i = n.getModel(), a = n.getLayout(), s = n.hostTree.data;
    if (!(!a || a.invisible || !a.isInView)) {
      var o = i.getModel(qye), l = Kye(o, e, r), u = s.ensureUniqueItemVisual(n.dataIndex, "style"), c = o.get("borderColor"), h = o.get("borderColorSaturation"), d;
      h != null && (d = Qz(l), c = Zye(h, d)), u.stroke = c;
      var f = n.viewChildren;
      if (!f || !f.length) d = Qz(l), u.fill = d;
      else {
        var p = Qye(n, i, a, o, l, f);
        P(f, function(g, m) {
          if (g.depth >= t.length || g === t[g.depth]) {
            var v = Jye(i, l, g, m, p, r);
            aj(g, v, t, r);
          }
        });
      }
    }
  }
  function Kye(n, e, t) {
    var r = oe({}, e), i = t.designatedVisualItemStyle;
    return P([
      "color",
      "colorAlpha",
      "colorSaturation"
    ], function(a) {
      i[a] = e[a];
      var s = n.get(a);
      i[a] = null, s != null && (r[a] = s);
    }), r;
  }
  function Qz(n) {
    var e = iT(n, "color");
    if (e) {
      var t = iT(n, "colorAlpha"), r = iT(n, "colorSaturation");
      return r && (e = t0(e, null, null, r)), t && (e = E_(e, t)), e;
    }
  }
  function Zye(n, e) {
    return e != null ? t0(e, null, null, n) : null;
  }
  function iT(n, e) {
    var t = n[e];
    if (t != null && t !== "none") return t;
  }
  function Qye(n, e, t, r, i, a) {
    if (!(!a || !a.length)) {
      var s = aT(e, "color") || i.color != null && i.color !== "none" && (aT(e, "colorAlpha") || aT(e, "colorSaturation"));
      if (s) {
        var o = e.get("visualMin"), l = e.get("visualMax"), u = t.dataExtent.slice();
        o != null && o < u[0] && (u[0] = o), l != null && l > u[1] && (u[1] = l);
        var c = e.get("colorMappingBy"), h = {
          type: s.name,
          dataExtent: u,
          visual: s.range
        };
        h.type === "color" && (c === "index" || c === "id") ? (h.mappingMethod = "category", h.loop = true) : h.mappingMethod = "linear";
        var d = new Gr(h);
        return ij(d).drColorMappingBy = c, d;
      }
    }
  }
  function aT(n, e) {
    var t = n.get(e);
    return de(t) && t.length ? {
      name: e,
      range: t
    } : null;
  }
  function Jye(n, e, t, r, i, a) {
    var s = oe({}, e);
    if (i) {
      var o = i.type, l = o === "color" && ij(i).drColorMappingBy, u = l === "index" ? r : l === "id" ? a.mapIdToIndex(t.getId()) : t.getValue(n.get("visualDimension"));
      s[o] = i.mapValueToVisual(u);
    }
    return s;
  }
  var Y0 = Math.max, uS = Math.min, Jz = ni, qE = P, sj = [
    "itemStyle",
    "borderWidth"
  ], e0e = [
    "itemStyle",
    "gapWidth"
  ], t0e = [
    "upperLabel",
    "show"
  ], n0e = [
    "upperLabel",
    "height"
  ];
  const r0e = {
    seriesType: "treemap",
    reset: function(n, e, t, r) {
      var i = t.getWidth(), a = t.getHeight(), s = n.option, o = Er(n.getBoxLayoutParams(), {
        width: t.getWidth(),
        height: t.getHeight()
      }), l = s.size || [], u = _e(Jz(o.width, l[0]), i), c = _e(Jz(o.height, l[1]), a), h = r && r.type, d = [
        "treemapZoomToNode",
        "treemapRootToNode"
      ], f = H0(r, d, n), p = h === "treemapRender" || h === "treemapMove" ? r.rootRect : null, g = n.getViewRoot(), m = ej(g);
      if (h !== "treemapMove") {
        var v = h === "treemapZoomToNode" ? u0e(n, f, g, u, c) : p ? [
          p.width,
          p.height
        ] : [
          u,
          c
        ], y = s.sort;
        y && y !== "asc" && y !== "desc" && (y = "desc");
        var x = {
          squareRatio: s.squareRatio,
          sort: y,
          leafDepth: s.leafDepth
        };
        g.hostTree.clearLayouts();
        var b = {
          x: 0,
          y: 0,
          width: v[0],
          height: v[1],
          area: v[0] * v[1]
        };
        g.setLayout(b), oj(g, x, false, 0), b = g.getLayout(), qE(m, function(_, S) {
          var I = (m[S + 1] || g).getValue();
          _.setLayout(oe({
            dataExtent: [
              I,
              I
            ],
            borderWidth: 0,
            upperHeight: 0
          }, b));
        });
      }
      var w = n.getData().tree.root;
      w.setLayout(c0e(o, p, f), true), n.setLayoutInfo(o), lj(w, new vt(-o.x, -o.y, i, a), m, g, 0);
    }
  };
  function oj(n, e, t, r) {
    var i, a;
    if (!n.isRemoved()) {
      var s = n.getLayout();
      i = s.width, a = s.height;
      var o = n.getModel(), l = o.get(sj), u = o.get(e0e) / 2, c = uj(o), h = Math.max(l, c), d = l - u, f = h - u;
      n.setLayout({
        borderWidth: l,
        upperHeight: h,
        upperLabelHeight: c
      }, true), i = Y0(i - 2 * d, 0), a = Y0(a - d - f, 0);
      var p = i * a, g = i0e(n, o, p, e, t, r);
      if (g.length) {
        var m = {
          x: d,
          y: f,
          width: i,
          height: a
        }, v = uS(i, a), y = 1 / 0, x = [];
        x.area = 0;
        for (var b = 0, w = g.length; b < w; ) {
          var _ = g[b];
          x.push(_), x.area += _.getLayout().area;
          var S = l0e(x, v, e.squareRatio);
          S <= y ? (b++, y = S) : (x.area -= x.pop().getLayout().area, eV(x, v, m, u, false), v = uS(m.width, m.height), x.length = x.area = 0, y = 1 / 0);
        }
        if (x.length && eV(x, v, m, u, true), !t) {
          var I = o.get("childrenVisibleMin");
          I != null && p < I && (t = true);
        }
        for (var b = 0, w = g.length; b < w; b++) oj(g[b], e, t, r + 1);
      }
    }
  }
  function i0e(n, e, t, r, i, a) {
    var s = n.children || [], o = r.sort;
    o !== "asc" && o !== "desc" && (o = null);
    var l = r.leafDepth != null && r.leafDepth <= a;
    if (i && !l) return n.viewChildren = [];
    s = rn(s, function(f) {
      return !f.isRemoved();
    }), s0e(s, o);
    var u = o0e(e, s, o);
    if (u.sum === 0) return n.viewChildren = [];
    if (u.sum = a0e(e, t, u.sum, o, s), u.sum === 0) return n.viewChildren = [];
    for (var c = 0, h = s.length; c < h; c++) {
      var d = s[c].getValue() / u.sum * t;
      s[c].setLayout({
        area: d
      });
    }
    return l && (s.length && n.setLayout({
      isLeafRoot: true
    }, true), s.length = 0), n.viewChildren = s, n.setLayout({
      dataExtent: u.dataExtent
    }, true), s;
  }
  function a0e(n, e, t, r, i) {
    if (!r) return t;
    for (var a = n.get("visibleMin"), s = i.length, o = s, l = s - 1; l >= 0; l--) {
      var u = i[r === "asc" ? s - l - 1 : l].getValue();
      u / t * e < a && (o = l, t -= u);
    }
    return r === "asc" ? i.splice(0, s - o) : i.splice(o, s - o), t;
  }
  function s0e(n, e) {
    return e && n.sort(function(t, r) {
      var i = e === "asc" ? t.getValue() - r.getValue() : r.getValue() - t.getValue();
      return i === 0 ? e === "asc" ? t.dataIndex - r.dataIndex : r.dataIndex - t.dataIndex : i;
    }), n;
  }
  function o0e(n, e, t) {
    for (var r = 0, i = 0, a = e.length; i < a; i++) r += e[i].getValue();
    var s = n.get("visualDimension"), o;
    return !e || !e.length ? o = [
      NaN,
      NaN
    ] : s === "value" && t ? (o = [
      e[e.length - 1].getValue(),
      e[0].getValue()
    ], t === "asc" && o.reverse()) : (o = [
      1 / 0,
      -1 / 0
    ], qE(e, function(l) {
      var u = l.getValue(s);
      u < o[0] && (o[0] = u), u > o[1] && (o[1] = u);
    })), {
      sum: r,
      dataExtent: o
    };
  }
  function l0e(n, e, t) {
    for (var r = 0, i = 1 / 0, a = 0, s = void 0, o = n.length; a < o; a++) s = n[a].getLayout().area, s && (s < i && (i = s), s > r && (r = s));
    var l = n.area * n.area, u = e * e * t;
    return l ? Y0(u * r / l, l / (u * i)) : 1 / 0;
  }
  function eV(n, e, t, r, i) {
    var a = e === t.width ? 0 : 1, s = 1 - a, o = [
      "x",
      "y"
    ], l = [
      "width",
      "height"
    ], u = t[o[a]], c = e ? n.area / e : 0;
    (i || c > t[l[s]]) && (c = t[l[s]]);
    for (var h = 0, d = n.length; h < d; h++) {
      var f = n[h], p = {}, g = c ? f.getLayout().area / c : 0, m = p[l[s]] = Y0(c - 2 * r, 0), v = t[o[a]] + t[l[a]] - u, y = h === d - 1 || v < g ? v : g, x = p[l[a]] = Y0(y - 2 * r, 0);
      p[o[s]] = t[o[s]] + uS(r, m / 2), p[o[a]] = u + uS(r, x / 2), u += y, f.setLayout(p, true);
    }
    t[o[s]] += c, t[l[s]] -= c;
  }
  function u0e(n, e, t, r, i) {
    var a = (e || {}).node, s = [
      r,
      i
    ];
    if (!a || a === t) return s;
    for (var o, l = r * i, u = l * n.option.zoomToNodeRatio; o = a.parentNode; ) {
      for (var c = 0, h = o.children, d = 0, f = h.length; d < f; d++) c += h[d].getValue();
      var p = a.getValue();
      if (p === 0) return s;
      u *= c / p;
      var g = o.getModel(), m = g.get(sj), v = Math.max(m, uj(g));
      u += 4 * m * m + (3 * m + v) * Math.pow(u, 0.5), u > fF && (u = fF), a = o;
    }
    u < l && (u = l);
    var y = Math.pow(u / l, 0.5);
    return [
      r * y,
      i * y
    ];
  }
  function c0e(n, e, t) {
    if (e) return {
      x: e.x,
      y: e.y
    };
    var r = {
      x: 0,
      y: 0
    };
    if (!t) return r;
    var i = t.node, a = i.getLayout();
    if (!a) return r;
    for (var s = [
      a.width / 2,
      a.height / 2
    ], o = i; o; ) {
      var l = o.getLayout();
      s[0] += l.x, s[1] += l.y, o = o.parentNode;
    }
    return {
      x: n.width / 2 - s[0],
      y: n.height / 2 - s[1]
    };
  }
  function lj(n, e, t, r, i) {
    var a = n.getLayout(), s = t[i], o = s && s === n;
    if (!(s && !o || i === t.length && n !== r)) {
      n.setLayout({
        isInView: true,
        invisible: !o && !e.intersect(a),
        isAboveViewRoot: o
      }, true);
      var l = new vt(e.x - a.x, e.y - a.y, e.width, e.height);
      qE(n.viewChildren || [], function(u) {
        lj(u, l, t, r, i + 1);
      });
    }
  }
  function uj(n) {
    return n.get(t0e) ? n.get(n0e) : 0;
  }
  function h0e(n) {
    n.registerSeriesModel(Rye), n.registerChartView(Vye), n.registerVisual(jye), n.registerLayout(r0e), Dye(n);
  }
  function d0e(n) {
    var e = n.findComponents({
      mainType: "legend"
    });
    !e || !e.length || n.eachSeriesByType("graph", function(t) {
      var r = t.getCategoriesData(), i = t.getGraph(), a = i.data, s = r.mapArray(r.getName);
      a.filterSelf(function(o) {
        var l = a.getItemModel(o), u = l.getShallow("category");
        if (u != null) {
          Yt(u) && (u = s[u]);
          for (var c = 0; c < e.length; c++) if (!e[c].isSelected(u)) return false;
        }
        return true;
      });
    });
  }
  function f0e(n) {
    var e = {};
    n.eachSeriesByType("graph", function(t) {
      var r = t.getCategoriesData(), i = t.getData(), a = {};
      r.each(function(s) {
        var o = r.getName(s);
        a["ec-" + o] = s;
        var l = r.getItemModel(s), u = l.getModel("itemStyle").getItemStyle();
        u.fill || (u.fill = t.getColorFromPalette(o, e)), r.setItemVisual(s, "style", u);
        for (var c = [
          "symbol",
          "symbolSize",
          "symbolKeepAspect"
        ], h = 0; h < c.length; h++) {
          var d = l.getShallow(c[h], true);
          d != null && r.setItemVisual(s, c[h], d);
        }
      }), r.count() && i.each(function(s) {
        var o = i.getItemModel(s), l = o.getShallow("category");
        if (l != null) {
          Ie(l) && (l = a["ec-" + l]);
          var u = r.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(s, "style");
          oe(c, u);
          for (var h = [
            "symbol",
            "symbolSize",
            "symbolKeepAspect"
          ], d = 0; d < h.length; d++) i.setItemVisual(s, h[d], r.getItemVisual(l, h[d]));
        }
      });
    });
  }
  function ew(n) {
    return n instanceof Array || (n = [
      n,
      n
    ]), n;
  }
  function p0e(n) {
    n.eachSeriesByType("graph", function(e) {
      var t = e.getGraph(), r = e.getEdgeData(), i = ew(e.get("edgeSymbol")), a = ew(e.get("edgeSymbolSize"));
      r.setVisual("fromSymbol", i && i[0]), r.setVisual("toSymbol", i && i[1]), r.setVisual("fromSymbolSize", a && a[0]), r.setVisual("toSymbolSize", a && a[1]), r.setVisual("style", e.getModel("lineStyle").getLineStyle()), r.each(function(s) {
        var o = r.getItemModel(s), l = t.getEdgeByIndex(s), u = ew(o.getShallow("symbol", true)), c = ew(o.getShallow("symbolSize", true)), h = o.getModel("lineStyle").getLineStyle(), d = r.ensureUniqueItemVisual(s, "style");
        switch (oe(d, h), d.stroke) {
          case "source": {
            var f = l.node1.getVisual("style");
            d.stroke = f && f.fill;
            break;
          }
          case "target": {
            var f = l.node2.getVisual("style");
            d.stroke = f && f.fill;
            break;
          }
        }
        u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
      });
    });
  }
  var TR = "-->", XC = function(n) {
    return n.get("autoCurveness") || null;
  }, cj = function(n, e) {
    var t = XC(n), r = 20, i = [];
    if (Yt(t)) r = t;
    else if (de(t)) {
      n.__curvenessList = t;
      return;
    }
    e > r && (r = e);
    var a = r % 2 ? r + 2 : r + 3;
    i = [];
    for (var s = 0; s < a; s++) i.push((s % 2 ? s + 1 : s) / 10 * (s % 2 ? -1 : 1));
    n.__curvenessList = i;
  }, q0 = function(n, e, t) {
    var r = [
      n.id,
      n.dataIndex
    ].join("."), i = [
      e.id,
      e.dataIndex
    ].join(".");
    return [
      t.uid,
      r,
      i
    ].join(TR);
  }, hj = function(n) {
    var e = n.split(TR);
    return [
      e[0],
      e[2],
      e[1]
    ].join(TR);
  }, g0e = function(n, e) {
    var t = q0(n.node1, n.node2, e);
    return e.__edgeMap[t];
  }, m0e = function(n, e) {
    var t = AR(q0(n.node1, n.node2, e), e), r = AR(q0(n.node2, n.node1, e), e);
    return t + r;
  }, AR = function(n, e) {
    var t = e.__edgeMap;
    return t[n] ? t[n].length : 0;
  };
  function v0e(n) {
    XC(n) && (n.__curvenessList = [], n.__edgeMap = {}, cj(n));
  }
  function y0e(n, e, t, r) {
    if (XC(t)) {
      var i = q0(n, e, t), a = t.__edgeMap, s = a[hj(i)];
      a[i] && !s ? a[i].isForward = true : s && a[i] && (s.isForward = true, a[i].isForward = false), a[i] = a[i] || [], a[i].push(r);
    }
  }
  function jE(n, e, t, r) {
    var i = XC(e), a = de(i);
    if (!i) return null;
    var s = g0e(n, e);
    if (!s) return null;
    for (var o = -1, l = 0; l < s.length; l++) if (s[l] === t) {
      o = l;
      break;
    }
    var u = m0e(n, e);
    cj(e, u), n.lineStyle = n.lineStyle || {};
    var c = q0(n.node1, n.node2, e), h = e.__curvenessList, d = a || u % 2 ? 0 : 1;
    if (s.isForward) return h[d + o];
    var f = hj(c), p = AR(f, e), g = h[o + p + d];
    return r ? a ? i && i[0] === 0 ? (p + d) % 2 ? g : -g : ((p % 2 ? 0 : 1) + d) % 2 ? g : -g : (p + d) % 2 ? g : -g : h[o + p + d];
  }
  function dj(n) {
    var e = n.coordinateSystem;
    if (!(e && e.type !== "view")) {
      var t = n.getGraph();
      t.eachNode(function(r) {
        var i = r.getModel();
        r.setLayout([
          +i.get("x"),
          +i.get("y")
        ]);
      }), KE(t, n);
    }
  }
  function KE(n, e) {
    n.eachEdge(function(t, r) {
      var i = Go(t.getModel().get([
        "lineStyle",
        "curveness"
      ]), -jE(t, e, r, true), 0), a = El(t.node1.getLayout()), s = El(t.node2.getLayout()), o = [
        a,
        s
      ];
      +i && o.push([
        (a[0] + s[0]) / 2 - (a[1] - s[1]) * i,
        (a[1] + s[1]) / 2 - (s[0] - a[0]) * i
      ]), t.setLayout(o);
    });
  }
  function x0e(n, e) {
    n.eachSeriesByType("graph", function(t) {
      var r = t.get("layout"), i = t.coordinateSystem;
      if (i && i.type !== "view") {
        var a = t.getData(), s = [];
        P(i.dimensions, function(d) {
          s = s.concat(a.mapDimensionsAll(d));
        });
        for (var o = 0; o < a.count(); o++) {
          for (var l = [], u = false, c = 0; c < s.length; c++) {
            var h = a.get(s[c], o);
            isNaN(h) || (u = true), l.push(h);
          }
          u ? a.setItemLayout(o, i.dataToPoint(l)) : a.setItemLayout(o, [
            NaN,
            NaN
          ]);
        }
        KE(a.graph, t);
      } else (!r || r === "none") && dj(t);
    });
  }
  function By(n) {
    var e = n.coordinateSystem;
    if (e.type !== "view") return 1;
    var t = n.option.nodeScaleRatio, r = e.scaleX, i = e.getZoom(), a = (i - 1) * t + 1;
    return a / r;
  }
  function zy(n) {
    var e = n.getVisual("symbolSize");
    return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
  }
  var tV = Math.PI, sT = [];
  function ZE(n, e, t, r) {
    var i = n.coordinateSystem;
    if (!(i && i.type !== "view")) {
      var a = i.getBoundingRect(), s = n.getData(), o = s.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, c = Math.min(a.width, a.height) / 2, h = s.count();
      if (s.setLayout({
        cx: l,
        cy: u
      }), !!h) {
        if (t) {
          var d = i.pointToData(r), f = d[0], p = d[1], g = [
            f - l,
            p - u
          ];
          dm(g, g), qw(g, g, c), t.setLayout([
            l + g[0],
            u + g[1]
          ], true);
          var m = n.get([
            "circular",
            "rotateLabel"
          ]);
          fj(t, m, l, u);
        }
        b0e[e](n, o, s, c, l, u, h), o.eachEdge(function(v, y) {
          var x = Go(v.getModel().get([
            "lineStyle",
            "curveness"
          ]), jE(v, n, y), 0), b = El(v.node1.getLayout()), w = El(v.node2.getLayout()), _, S = (b[0] + w[0]) / 2, I = (b[1] + w[1]) / 2;
          +x && (x *= 3, _ = [
            l * x + S * (1 - x),
            u * x + I * (1 - x)
          ]), v.setLayout([
            b,
            w,
            _
          ]);
        });
      }
    }
  }
  var b0e = {
    value: function(n, e, t, r, i, a, s) {
      var o = 0, l = t.getSum("value"), u = Math.PI * 2 / (l || s);
      e.eachNode(function(c) {
        var h = c.getValue("value"), d = u * (l ? h : 1) / 2;
        o += d, c.setLayout([
          r * Math.cos(o) + i,
          r * Math.sin(o) + a
        ]), o += d;
      });
    },
    symbolSize: function(n, e, t, r, i, a, s) {
      var o = 0;
      sT.length = s;
      var l = By(n);
      e.eachNode(function(h) {
        var d = zy(h);
        isNaN(d) && (d = 2), d < 0 && (d = 0), d *= l;
        var f = Math.asin(d / 2 / r);
        isNaN(f) && (f = tV / 2), sT[h.dataIndex] = f, o += f * 2;
      });
      var u = (2 * tV - o) / s / 2, c = 0;
      e.eachNode(function(h) {
        var d = u + sT[h.dataIndex];
        c += d, (!h.getLayout() || !h.getLayout().fixed) && h.setLayout([
          r * Math.cos(c) + i,
          r * Math.sin(c) + a
        ]), c += d;
      });
    }
  };
  function fj(n, e, t, r) {
    var i = n.getGraphicEl();
    if (i) {
      var a = n.getModel(), s = a.get([
        "label",
        "rotate"
      ]) || 0, o = i.getSymbolPath();
      if (e) {
        var l = n.getLayout(), u = Math.atan2(l[1] - r, l[0] - t);
        u < 0 && (u = Math.PI * 2 + u);
        var c = l[0] < t;
        c && (u = u - Math.PI);
        var h = c ? "left" : "right";
        o.setTextConfig({
          rotation: -u,
          position: h,
          origin: "center"
        });
        var d = o.ensureState("emphasis");
        oe(d.textConfig || (d.textConfig = {}), {
          position: h
        });
      } else o.setTextConfig({
        rotation: s *= Math.PI / 180
      });
    }
  }
  function w0e(n) {
    n.eachSeriesByType("graph", function(e) {
      e.get("layout") === "circular" && ZE(e, "symbolSize");
    });
  }
  var Op = pD;
  function _0e(n, e, t) {
    for (var r = n, i = e, a = t.rect, s = a.width, o = a.height, l = [
      a.x + s / 2,
      a.y + o / 2
    ], u = t.gravity == null ? 0.1 : t.gravity, c = 0; c < r.length; c++) {
      var h = r[c];
      h.p || (h.p = Ed(s * (Math.random() - 0.5) + l[0], o * (Math.random() - 0.5) + l[1])), h.pp = El(h.p), h.edges = null;
    }
    var d = t.friction == null ? 0.6 : t.friction, f = d, p, g;
    return {
      warmUp: function() {
        f = d * 0.8;
      },
      setFixed: function(m) {
        r[m].fixed = true;
      },
      setUnfixed: function(m) {
        r[m].fixed = false;
      },
      beforeStep: function(m) {
        p = m;
      },
      afterStep: function(m) {
        g = m;
      },
      step: function(m) {
        p && p(r, i);
        for (var v = [], y = r.length, x = 0; x < i.length; x++) {
          var b = i[x];
          if (!b.ignoreForceLayout) {
            var w = b.n1, _ = b.n2;
            Ph(v, _.p, w.p);
            var S = gD(v) - b.d, I = _.w / (w.w + _.w);
            isNaN(I) && (I = 0), dm(v, v), !w.fixed && Op(w.p, w.p, v, I * S * f), !_.fixed && Op(_.p, _.p, v, -(1 - I) * S * f);
          }
        }
        for (var x = 0; x < y; x++) {
          var C = r[x];
          C.fixed || (Ph(v, l, C.p), Op(C.p, C.p, v, u * f));
        }
        for (var x = 0; x < y; x++) for (var w = r[x], T = x + 1; T < y; T++) {
          var _ = r[T];
          Ph(v, _.p, w.p);
          var S = gD(v);
          S === 0 && (Yse(v, Math.random() - 0.5, Math.random() - 0.5), S = 1);
          var k = (w.rep + _.rep) / S / S;
          !w.fixed && Op(w.pp, w.pp, v, k), !_.fixed && Op(_.pp, _.pp, v, -k);
        }
        for (var D = [], x = 0; x < y; x++) {
          var C = r[x];
          C.fixed || (Ph(D, C.p, C.pp), Op(C.p, C.p, D, f), Wi(C.pp, C.p));
        }
        f = f * 0.992;
        var R = f < 0.01;
        g && g(r, i, R), m && m(R);
      }
    };
  }
  function S0e(n) {
    n.eachSeriesByType("graph", function(e) {
      var t = e.coordinateSystem;
      if (!(t && t.type !== "view")) if (e.get("layout") === "force") {
        var r = e.preservedPoints || {}, i = e.getGraph(), a = i.data, s = i.edgeData, o = e.getModel("force"), l = o.get("initLayout");
        e.preservedPoints ? a.each(function(x) {
          var b = a.getId(x);
          a.setItemLayout(x, r[b] || [
            NaN,
            NaN
          ]);
        }) : !l || l === "none" ? dj(e) : l === "circular" && ZE(e, "value");
        var u = a.getDataExtent("value"), c = s.getDataExtent("value"), h = o.get("repulsion"), d = o.get("edgeLength"), f = de(h) ? h : [
          h,
          h
        ], p = de(d) ? d : [
          d,
          d
        ];
        p = [
          p[1],
          p[0]
        ];
        var g = a.mapArray("value", function(x, b) {
          var w = a.getItemLayout(b), _ = sn(x, u, f);
          return isNaN(_) && (_ = (f[0] + f[1]) / 2), {
            w: _,
            rep: _,
            fixed: a.getItemModel(b).get("fixed"),
            p: !w || isNaN(w[0]) || isNaN(w[1]) ? null : w
          };
        }), m = s.mapArray("value", function(x, b) {
          var w = i.getEdgeByIndex(b), _ = sn(x, c, p);
          isNaN(_) && (_ = (p[0] + p[1]) / 2);
          var S = w.getModel(), I = Go(w.getModel().get([
            "lineStyle",
            "curveness"
          ]), -jE(w, e, b, true), 0);
          return {
            n1: g[w.node1.dataIndex],
            n2: g[w.node2.dataIndex],
            d: _,
            curveness: I,
            ignoreForceLayout: S.get("ignoreForceLayout")
          };
        }), v = t.getBoundingRect(), y = _0e(g, m, {
          rect: v,
          gravity: o.get("gravity"),
          friction: o.get("friction")
        });
        y.beforeStep(function(x, b) {
          for (var w = 0, _ = x.length; w < _; w++) x[w].fixed && Wi(x[w].p, i.getNodeByIndex(w).getLayout());
        }), y.afterStep(function(x, b, w) {
          for (var _ = 0, S = x.length; _ < S; _++) x[_].fixed || i.getNodeByIndex(_).setLayout(x[_].p), r[a.getId(_)] = x[_].p;
          for (var _ = 0, S = b.length; _ < S; _++) {
            var I = b[_], C = i.getEdgeByIndex(_), T = I.n1.p, k = I.n2.p, D = C.getLayout();
            D = D ? D.slice() : [], D[0] = D[0] || [], D[1] = D[1] || [], Wi(D[0], T), Wi(D[1], k), +I.curveness && (D[2] = [
              (T[0] + k[0]) / 2 - (T[1] - k[1]) * I.curveness,
              (T[1] + k[1]) / 2 - (k[0] - T[0]) * I.curveness
            ]), C.setLayout(D);
          }
        }), e.forceLayout = y, e.preservedPoints = r, y.step();
      } else e.forceLayout = null;
    });
  }
  function C0e(n, e, t) {
    var r = oe(n.getBoxLayoutParams(), {
      aspect: t
    });
    return Er(r, {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function I0e(n, e) {
    var t = [];
    return n.eachSeriesByType("graph", function(r) {
      var i = r.get("coordinateSystem");
      if (!i || i === "view") {
        var a = r.getData(), s = a.mapArray(function(m) {
          var v = a.getItemModel(m);
          return [
            +v.get("x"),
            +v.get("y")
          ];
        }), o = [], l = [];
        xC(s, o, l), l[0] - o[0] === 0 && (l[0] += 1, o[0] -= 1), l[1] - o[1] === 0 && (l[1] += 1, o[1] -= 1);
        var u = (l[0] - o[0]) / (l[1] - o[1]), c = C0e(r, e, u);
        isNaN(u) && (o = [
          c.x,
          c.y
        ], l = [
          c.x + c.width,
          c.y + c.height
        ]);
        var h = l[0] - o[0], d = l[1] - o[1], f = c.width, p = c.height, g = r.coordinateSystem = new jx();
        g.zoomLimit = r.get("scaleLimit"), g.setBoundingRect(o[0], o[1], h, d), g.setViewRect(c.x, c.y, f, p), g.setCenter(r.get("center"), e), g.setZoom(r.get("zoom")), t.push(g);
      }
    }), t;
  }
  var nV = zr.prototype, oT = Mx.prototype, pj = /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return n;
  }();
  (function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e;
  })(pj);
  function lT(n) {
    return isNaN(+n.cpx1) || isNaN(+n.cpy1);
  }
  var k0e = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "ec-line", r;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new pj();
    }, e.prototype.buildPath = function(t, r) {
      lT(r) ? nV.buildPath.call(this, t, r) : oT.buildPath.call(this, t, r);
    }, e.prototype.pointAt = function(t) {
      return lT(this.shape) ? nV.pointAt.call(this, t) : oT.pointAt.call(this, t);
    }, e.prototype.tangentAt = function(t) {
      var r = this.shape, i = lT(r) ? [
        r.x2 - r.x1,
        r.y2 - r.y1
      ] : oT.tangentAt.call(this, t);
      return dm(i, i);
    }, e;
  }(At), uT = [
    "fromSymbol",
    "toSymbol"
  ];
  function rV(n) {
    return "_" + n + "Type";
  }
  function iV(n, e, t) {
    var r = e.getItemVisual(t, n);
    if (!r || r === "none") return r;
    var i = e.getItemVisual(t, n + "Size"), a = e.getItemVisual(t, n + "Rotate"), s = e.getItemVisual(t, n + "Offset"), o = e.getItemVisual(t, n + "KeepAspect"), l = Cm(i), u = Fd(s || 0, l);
    return r + l + u + (a || "") + (o || "");
  }
  function aV(n, e, t) {
    var r = e.getItemVisual(t, n);
    if (!(!r || r === "none")) {
      var i = e.getItemVisual(t, n + "Size"), a = e.getItemVisual(t, n + "Rotate"), s = e.getItemVisual(t, n + "Offset"), o = e.getItemVisual(t, n + "KeepAspect"), l = Cm(i), u = Fd(s || 0, l), c = xr(r, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, o);
      return c.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, c.name = n, c;
    }
  }
  function T0e(n) {
    var e = new k0e({
      name: "line",
      subPixelOptimize: true
    });
    return DR(e.shape, n), e;
  }
  function DR(n, e) {
    n.x1 = e[0][0], n.y1 = e[0][1], n.x2 = e[1][0], n.y2 = e[1][1], n.percent = 1;
    var t = e[2];
    t ? (n.cpx1 = t[0], n.cpy1 = t[1]) : (n.cpx1 = NaN, n.cpy1 = NaN);
  }
  var QE = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      return a._createLine(t, r, i), a;
    }
    return e.prototype._createLine = function(t, r, i) {
      var a = t.hostModel, s = t.getItemLayout(r), o = T0e(s);
      o.shape.percent = 0, Un(o, {
        shape: {
          percent: 1
        }
      }, a, r), this.add(o), P(uT, function(l) {
        var u = aV(l, t, r);
        this.add(u), this[rV(l)] = iV(l, t, r);
      }, this), this._updateCommonStl(t, r, i);
    }, e.prototype.updateData = function(t, r, i) {
      var a = t.hostModel, s = this.childOfName("line"), o = t.getItemLayout(r), l = {
        shape: {}
      };
      DR(l.shape, o), Kt(s, l, a, r), P(uT, function(u) {
        var c = iV(u, t, r), h = rV(u);
        if (this[h] !== c) {
          this.remove(this.childOfName(u));
          var d = aV(u, t, r);
          this.add(d);
        }
        this[h] = c;
      }, this), this._updateCommonStl(t, r, i);
    }, e.prototype.getLinePath = function() {
      return this.childAt(0);
    }, e.prototype._updateCommonStl = function(t, r, i) {
      var a = t.hostModel, s = this.childOfName("line"), o = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, h = i && i.emphasisDisabled, d = i && i.focus, f = i && i.blurScope;
      if (!i || t.hasItemOption) {
        var p = t.getItemModel(r), g = p.getModel("emphasis");
        o = g.getModel("lineStyle").getLineStyle(), l = p.getModel([
          "blur",
          "lineStyle"
        ]).getLineStyle(), u = p.getModel([
          "select",
          "lineStyle"
        ]).getLineStyle(), h = g.get("disabled"), d = g.get("focus"), f = g.get("blurScope"), c = Hr(p);
      }
      var m = t.getItemVisual(r, "style"), v = m.stroke;
      s.useStyle(m), s.style.fill = null, s.style.strokeNoScale = true, s.ensureState("emphasis").style = o, s.ensureState("blur").style = l, s.ensureState("select").style = u, P(uT, function(_) {
        var S = this.childOfName(_);
        if (S) {
          S.setColor(v), S.style.opacity = m.opacity;
          for (var I = 0; I < na.length; I++) {
            var C = na[I], T = s.getState(C);
            if (T) {
              var k = T.style || {}, D = S.ensureState(C), R = D.style || (D.style = {});
              k.stroke != null && (R[S.__isEmptyBrush ? "stroke" : "fill"] = k.stroke), k.opacity != null && (R.opacity = k.opacity);
            }
          }
          S.markRedraw();
        }
      }, this);
      var y = a.getRawValue(r);
      gi(this, c, {
        labelDataIndex: r,
        labelFetcher: {
          getFormattedLabel: function(_, S) {
            return a.getFormattedLabel(_, S, t.dataType);
          }
        },
        inheritColor: v || "#000",
        defaultOpacity: m.opacity,
        defaultText: (y == null ? t.getName(r) : isFinite(y) ? rr(y) : y) + ""
      });
      var x = this.getTextContent();
      if (x) {
        var b = c.normal;
        x.__align = x.style.align, x.__verticalAlign = x.style.verticalAlign, x.__position = b.get("position") || "middle";
        var w = b.get("distance");
        de(w) || (w = [
          w,
          w
        ]), x.__labelDistance = w;
      }
      this.setTextConfig({
        position: null,
        local: true,
        inside: false
      }), Qn(this, d, f, h);
    }, e.prototype.highlight = function() {
      Xl(this);
    }, e.prototype.downplay = function() {
      Yl(this);
    }, e.prototype.updateLayout = function(t, r) {
      this.setLinePoints(t.getItemLayout(r));
    }, e.prototype.setLinePoints = function(t) {
      var r = this.childOfName("line");
      DR(r.shape, t), r.dirty();
    }, e.prototype.beforeUpdate = function() {
      var t = this, r = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), a = t.getTextContent();
      if (!r && !i && (!a || a.ignore)) return;
      for (var s = 1, o = this.parent; o; ) o.scaleX && (s /= o.scaleX), o = o.parent;
      var l = t.childOfName("line");
      if (!this.__dirty && !l.__dirty) return;
      var u = l.shape.percent, c = l.pointAt(0), h = l.pointAt(u), d = Ph([], h, c);
      dm(d, d);
      function f(T, k) {
        var D = T.__specifiedRotation;
        if (D == null) {
          var R = l.tangentAt(k);
          T.attr("rotation", (k === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(R[1], R[0]));
        } else T.attr("rotation", D);
      }
      if (r && (r.setPosition(c), f(r, 0), r.scaleX = r.scaleY = s * u, r.markRedraw()), i && (i.setPosition(h), f(i, 1), i.scaleX = i.scaleY = s * u, i.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var p = void 0, g = void 0, m = a.__labelDistance, v = m[0] * s, y = m[1] * s, x = u / 2, b = l.tangentAt(x), w = [
          b[1],
          -b[0]
        ], _ = l.pointAt(x);
        w[1] > 0 && (w[0] = -w[0], w[1] = -w[1]);
        var S = b[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var I = -Math.atan2(b[1], b[0]);
          h[0] < c[0] && (I = Math.PI + I), a.rotation = I;
        }
        var C = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            C = -y, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            C = y, g = "top";
            break;
          default:
            C = 0, g = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = d[0] * v + h[0], a.y = d[1] * y + h[1], p = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center", g = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -d[0] * v + c[0], a.y = -d[1] * y + c[1], p = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center", g = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = v * S + c[0], a.y = c[1] + C, p = b[0] < 0 ? "right" : "left", a.originX = -v * S, a.originY = -C;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = _[0], a.y = _[1] + C, p = "center", a.originY = -C;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -v * S + h[0], a.y = h[1] + C, p = b[0] >= 0 ? "right" : "left", a.originX = v * S, a.originY = -C;
            break;
        }
        a.scaleX = a.scaleY = s, a.setStyle({
          verticalAlign: a.__verticalAlign || g,
          align: a.__align || p
        });
      }
    }, e;
  }(tt), JE = function() {
    function n(e) {
      this.group = new tt(), this._LineCtor = e || QE;
    }
    return n.prototype.updateData = function(e) {
      var t = this;
      this._progressiveEls = null;
      var r = this, i = r.group, a = r._lineData;
      r._lineData = e, a || i.removeAll();
      var s = sV(e);
      e.diff(a).add(function(o) {
        t._doAdd(e, o, s);
      }).update(function(o, l) {
        t._doUpdate(a, e, l, o, s);
      }).remove(function(o) {
        i.remove(a.getItemGraphicEl(o));
      }).execute();
    }, n.prototype.updateLayout = function() {
      var e = this._lineData;
      e && e.eachItemGraphicEl(function(t, r) {
        t.updateLayout(e, r);
      }, this);
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = sV(e), this._lineData = null, this.group.removeAll();
    }, n.prototype.incrementalUpdate = function(e, t) {
      this._progressiveEls = [];
      function r(o) {
        !o.isGroup && !A0e(o) && (o.incremental = true, o.ensureState("emphasis").hoverLayer = true);
      }
      for (var i = e.start; i < e.end; i++) {
        var a = t.getItemLayout(i);
        if (cT(a)) {
          var s = new this._LineCtor(t, i, this._seriesScope);
          s.traverse(r), this.group.add(s), t.setItemGraphicEl(i, s), this._progressiveEls.push(s);
        }
      }
    }, n.prototype.remove = function() {
      this.group.removeAll();
    }, n.prototype.eachRendered = function(e) {
      gc(this._progressiveEls || this.group, e);
    }, n.prototype._doAdd = function(e, t, r) {
      var i = e.getItemLayout(t);
      if (cT(i)) {
        var a = new this._LineCtor(e, t, r);
        e.setItemGraphicEl(t, a), this.group.add(a);
      }
    }, n.prototype._doUpdate = function(e, t, r, i, a) {
      var s = e.getItemGraphicEl(r);
      if (!cT(t.getItemLayout(i))) {
        this.group.remove(s);
        return;
      }
      s ? s.updateData(t, i, a) : s = new this._LineCtor(t, i, a), t.setItemGraphicEl(i, s), this.group.add(s);
    }, n;
  }();
  function A0e(n) {
    return n.animators && n.animators.length > 0;
  }
  function sV(n) {
    var e = n.hostModel, t = e.getModel("emphasis");
    return {
      lineStyle: e.getModel("lineStyle").getLineStyle(),
      emphasisLineStyle: t.getModel([
        "lineStyle"
      ]).getLineStyle(),
      blurLineStyle: e.getModel([
        "blur",
        "lineStyle"
      ]).getLineStyle(),
      selectLineStyle: e.getModel([
        "select",
        "lineStyle"
      ]).getLineStyle(),
      emphasisDisabled: t.get("disabled"),
      blurScope: t.get("blurScope"),
      focus: t.get("focus"),
      labelStatesModels: Hr(e)
    };
  }
  function oV(n) {
    return isNaN(n[0]) || isNaN(n[1]);
  }
  function cT(n) {
    return n && !oV(n[0]) && !oV(n[1]);
  }
  var hT = [], dT = [], fT = [], Bp = Jr, pT = qh, lV = Math.abs;
  function uV(n, e, t) {
    for (var r = n[0], i = n[1], a = n[2], s = 1 / 0, o, l = t * t, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
      hT[0] = Bp(r[0], i[0], a[0], c), hT[1] = Bp(r[1], i[1], a[1], c);
      var h = lV(pT(hT, e) - l);
      h < s && (s = h, o = c);
    }
    for (var d = 0; d < 32; d++) {
      var f = o + u;
      dT[0] = Bp(r[0], i[0], a[0], o), dT[1] = Bp(r[1], i[1], a[1], o), fT[0] = Bp(r[0], i[0], a[0], f), fT[1] = Bp(r[1], i[1], a[1], f);
      var h = pT(dT, e) - l;
      if (lV(h) < 0.01) break;
      var p = pT(fT, e) - l;
      u /= 2, h < 0 ? p >= 0 ? o = o + u : o = o - u : p >= 0 ? o = o - u : o = o + u;
    }
    return o;
  }
  function gT(n, e) {
    var t = [], r = k0, i = [
      [],
      [],
      []
    ], a = [
      [],
      []
    ], s = [];
    e /= 2, n.eachEdge(function(o, l) {
      var u = o.getLayout(), c = o.getVisual("fromSymbol"), h = o.getVisual("toSymbol");
      u.__original || (u.__original = [
        El(u[0]),
        El(u[1])
      ], u[2] && u.__original.push(El(u[2])));
      var d = u.__original;
      if (u[2] != null) {
        if (Wi(i[0], d[0]), Wi(i[1], d[2]), Wi(i[2], d[1]), c && c !== "none") {
          var f = zy(o.node1), p = uV(i, d[0], f * e);
          r(i[0][0], i[1][0], i[2][0], p, t), i[0][0] = t[3], i[1][0] = t[4], r(i[0][1], i[1][1], i[2][1], p, t), i[0][1] = t[3], i[1][1] = t[4];
        }
        if (h && h !== "none") {
          var f = zy(o.node2), p = uV(i, d[1], f * e);
          r(i[0][0], i[1][0], i[2][0], p, t), i[1][0] = t[1], i[2][0] = t[2], r(i[0][1], i[1][1], i[2][1], p, t), i[1][1] = t[1], i[2][1] = t[2];
        }
        Wi(u[0], i[0]), Wi(u[1], i[2]), Wi(u[2], i[1]);
      } else {
        if (Wi(a[0], d[0]), Wi(a[1], d[1]), Ph(s, a[1], a[0]), dm(s, s), c && c !== "none") {
          var f = zy(o.node1);
          pD(a[0], a[0], s, f * e);
        }
        if (h && h !== "none") {
          var f = zy(o.node2);
          pD(a[1], a[1], s, -f * e);
        }
        Wi(u[0], a[0]), Wi(u[1], a[1]);
      }
    });
  }
  function cV(n) {
    return n.type === "view";
  }
  var D0e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      var i = new Gx(), a = new JE(), s = this.group;
      this._controller = new qx(r.getZr()), this._controllerHost = {
        target: s
      }, s.add(i.group), s.add(a.group), this._symbolDraw = i, this._lineDraw = a, this._firstRender = true;
    }, e.prototype.render = function(t, r, i) {
      var a = this, s = t.coordinateSystem;
      this._model = t;
      var o = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (cV(s)) {
        var c = {
          x: s.x,
          y: s.y,
          scaleX: s.scaleX,
          scaleY: s.scaleY
        };
        this._firstRender ? u.attr(c) : Kt(u, c, t);
      }
      gT(t.getGraph(), By(t));
      var h = t.getData();
      o.updateData(h);
      var d = t.getEdgeData();
      l.updateData(d), this._updateNodeAndLinkScale(), this._updateController(t, r, i), clearTimeout(this._layoutTimeout);
      var f = t.forceLayout, p = t.get([
        "force",
        "layoutAnimation"
      ]);
      f && this._startForceLayoutIteration(f, p);
      var g = t.get("layout");
      h.graph.eachNode(function(x) {
        var b = x.dataIndex, w = x.getGraphicEl(), _ = x.getModel();
        if (w) {
          w.off("drag").off("dragend");
          var S = _.get("draggable");
          S && w.on("drag", function(C) {
            switch (g) {
              case "force":
                f.warmUp(), !a._layouting && a._startForceLayoutIteration(f, p), f.setFixed(b), h.setItemLayout(b, [
                  w.x,
                  w.y
                ]);
                break;
              case "circular":
                h.setItemLayout(b, [
                  w.x,
                  w.y
                ]), x.setLayout({
                  fixed: true
                }, true), ZE(t, "symbolSize", x, [
                  C.offsetX,
                  C.offsetY
                ]), a.updateLayout(t);
                break;
              case "none":
              default:
                h.setItemLayout(b, [
                  w.x,
                  w.y
                ]), KE(t.getGraph(), t), a.updateLayout(t);
                break;
            }
          }).on("dragend", function() {
            f && f.setUnfixed(b);
          }), w.setDraggable(S, !!_.get("cursor"));
          var I = _.get([
            "emphasis",
            "focus"
          ]);
          I === "adjacency" && (rt(w).focus = x.getAdjacentDataIndices());
        }
      }), h.graph.eachEdge(function(x) {
        var b = x.getGraphicEl(), w = x.getModel().get([
          "emphasis",
          "focus"
        ]);
        b && w === "adjacency" && (rt(b).focus = {
          edge: [
            x.dataIndex
          ],
          node: [
            x.node1.dataIndex,
            x.node2.dataIndex
          ]
        });
      });
      var m = t.get("layout") === "circular" && t.get([
        "circular",
        "rotateLabel"
      ]), v = h.getLayout("cx"), y = h.getLayout("cy");
      h.graph.eachNode(function(x) {
        fj(x, m, v, y);
      }), this._firstRender = false;
    }, e.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype._startForceLayoutIteration = function(t, r) {
      var i = this;
      (function a() {
        t.step(function(s) {
          i.updateLayout(i._model), (i._layouting = !s) && (r ? i._layoutTimeout = setTimeout(a, 16) : a());
        });
      })();
    }, e.prototype._updateController = function(t, r, i) {
      var a = this, s = this._controller, o = this._controllerHost, l = this.group;
      if (s.setPointerChecker(function(u, c, h) {
        var d = l.getBoundingRect();
        return d.applyTransform(l.transform), d.contain(c, h) && !GC(u, i, t);
      }), !cV(t.coordinateSystem)) {
        s.disable();
        return;
      }
      s.enable(t.get("roam")), o.zoomLimit = t.get("scaleLimit"), o.zoom = t.coordinateSystem.getZoom(), s.off("pan").off("zoom").on("pan", function(u) {
        VE(o, u.dx, u.dy), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        WE(o, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(), gT(t.getGraph(), By(t)), a._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function() {
      var t = this._model, r = t.getData(), i = By(t);
      r.eachItemGraphicEl(function(a, s) {
        a && a.setSymbolScale(i);
      });
    }, e.prototype.updateLayout = function(t) {
      gT(t.getGraph(), By(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, e.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = false, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, e.type = "graph", e;
  }(_n);
  function zp(n) {
    return "_EC_" + n;
  }
  var R0e = function() {
    function n(e) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || false;
    }
    return n.prototype.isDirected = function() {
      return this._directed;
    }, n.prototype.addNode = function(e, t) {
      e = e == null ? "" + t : "" + e;
      var r = this._nodesMap;
      if (!r[zp(e)]) {
        var i = new xh(e, t);
        return i.hostGraph = this, this.nodes.push(i), r[zp(e)] = i, i;
      }
    }, n.prototype.getNodeByIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this.nodes[t];
    }, n.prototype.getNodeById = function(e) {
      return this._nodesMap[zp(e)];
    }, n.prototype.addEdge = function(e, t, r) {
      var i = this._nodesMap, a = this._edgesMap;
      if (Yt(e) && (e = this.nodes[e]), Yt(t) && (t = this.nodes[t]), e instanceof xh || (e = i[zp(e)]), t instanceof xh || (t = i[zp(t)]), !(!e || !t)) {
        var s = e.id + "-" + t.id, o = new gj(e, t, r);
        return o.hostGraph = this, this._directed && (e.outEdges.push(o), t.inEdges.push(o)), e.edges.push(o), e !== t && t.edges.push(o), this.edges.push(o), a[s] = o, o;
      }
    }, n.prototype.getEdgeByIndex = function(e) {
      var t = this.edgeData.getRawIndex(e);
      return this.edges[t];
    }, n.prototype.getEdge = function(e, t) {
      e instanceof xh && (e = e.id), t instanceof xh && (t = t.id);
      var r = this._edgesMap;
      return this._directed ? r[e + "-" + t] : r[e + "-" + t] || r[t + "-" + e];
    }, n.prototype.eachNode = function(e, t) {
      for (var r = this.nodes, i = r.length, a = 0; a < i; a++) r[a].dataIndex >= 0 && e.call(t, r[a], a);
    }, n.prototype.eachEdge = function(e, t) {
      for (var r = this.edges, i = r.length, a = 0; a < i; a++) r[a].dataIndex >= 0 && r[a].node1.dataIndex >= 0 && r[a].node2.dataIndex >= 0 && e.call(t, r[a], a);
    }, n.prototype.breadthFirstTraverse = function(e, t, r, i) {
      if (t instanceof xh || (t = this._nodesMap[zp(t)]), !!t) {
        for (var a = r === "out" ? "outEdges" : r === "in" ? "inEdges" : "edges", s = 0; s < this.nodes.length; s++) this.nodes[s].__visited = false;
        if (!e.call(i, t, null)) for (var o = [
          t
        ]; o.length; ) for (var l = o.shift(), u = l[a], s = 0; s < u.length; s++) {
          var c = u[s], h = c.node1 === l ? c.node2 : c.node1;
          if (!h.__visited) {
            if (e.call(i, h, l)) return;
            o.push(h), h.__visited = true;
          }
        }
      }
    }, n.prototype.update = function() {
      for (var e = this.data, t = this.edgeData, r = this.nodes, i = this.edges, a = 0, s = r.length; a < s; a++) r[a].dataIndex = -1;
      for (var a = 0, s = e.count(); a < s; a++) r[e.getRawIndex(a)].dataIndex = a;
      t.filterSelf(function(o) {
        var l = i[t.getRawIndex(o)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, s = i.length; a < s; a++) i[a].dataIndex = -1;
      for (var a = 0, s = t.count(); a < s; a++) i[t.getRawIndex(a)].dataIndex = a;
    }, n.prototype.clone = function() {
      for (var e = new n(this._directed), t = this.nodes, r = this.edges, i = 0; i < t.length; i++) e.addNode(t[i].id, t[i].dataIndex);
      for (var i = 0; i < r.length; i++) {
        var a = r[i];
        e.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return e;
    }, n;
  }(), xh = function() {
    function n(e, t) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = t ?? -1;
    }
    return n.prototype.degree = function() {
      return this.edges.length;
    }, n.prototype.inDegree = function() {
      return this.inEdges.length;
    }, n.prototype.outDegree = function() {
      return this.outEdges.length;
    }, n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, r = t.data.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getAdjacentDataIndices = function() {
      for (var e = {
        edge: [],
        node: []
      }, t = 0; t < this.edges.length; t++) {
        var r = this.edges[t];
        r.dataIndex < 0 || (e.edge.push(r.dataIndex), e.node.push(r.node1.dataIndex, r.node2.dataIndex));
      }
      return e;
    }, n.prototype.getTrajectoryDataIndices = function() {
      for (var e = Pe(), t = Pe(), r = 0; r < this.edges.length; r++) {
        var i = this.edges[r];
        if (!(i.dataIndex < 0)) {
          e.set(i.dataIndex, true);
          for (var a = [
            i.node1
          ], s = [
            i.node2
          ], o = 0; o < a.length; ) {
            var l = a[o];
            o++, t.set(l.dataIndex, true);
            for (var u = 0; u < l.inEdges.length; u++) e.set(l.inEdges[u].dataIndex, true), a.push(l.inEdges[u].node1);
          }
          for (o = 0; o < s.length; ) {
            var c = s[o];
            o++, t.set(c.dataIndex, true);
            for (var u = 0; u < c.outEdges.length; u++) e.set(c.outEdges[u].dataIndex, true), s.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, n;
  }(), gj = function() {
    function n(e, t, r) {
      this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = r ?? -1;
    }
    return n.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, r = t.edgeData.getItemModel(this.dataIndex);
        return r.getModel(e);
      }
    }, n.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [
          this.dataIndex
        ],
        node: [
          this.node1.dataIndex,
          this.node2.dataIndex
        ]
      };
    }, n.prototype.getTrajectoryDataIndices = function() {
      var e = Pe(), t = Pe();
      e.set(this.dataIndex, true);
      for (var r = [
        this.node1
      ], i = [
        this.node2
      ], a = 0; a < r.length; ) {
        var s = r[a];
        a++, t.set(s.dataIndex, true);
        for (var o = 0; o < s.inEdges.length; o++) e.set(s.inEdges[o].dataIndex, true), r.push(s.inEdges[o].node1);
      }
      for (a = 0; a < i.length; ) {
        var l = i[a];
        a++, t.set(l.dataIndex, true);
        for (var o = 0; o < l.outEdges.length; o++) e.set(l.outEdges[o].dataIndex, true), i.push(l.outEdges[o].node2);
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, n;
  }();
  function mj(n, e) {
    return {
      getValue: function(t) {
        var r = this[n][e];
        return r.getStore().get(r.getDimensionIndex(t || "value"), this.dataIndex);
      },
      setVisual: function(t, r) {
        this.dataIndex >= 0 && this[n][e].setItemVisual(this.dataIndex, t, r);
      },
      getVisual: function(t) {
        return this[n][e].getItemVisual(this.dataIndex, t);
      },
      setLayout: function(t, r) {
        this.dataIndex >= 0 && this[n][e].setItemLayout(this.dataIndex, t, r);
      },
      getLayout: function() {
        return this[n][e].getItemLayout(this.dataIndex);
      },
      getGraphicEl: function() {
        return this[n][e].getItemGraphicEl(this.dataIndex);
      },
      getRawIndex: function() {
        return this[n][e].getRawIndex(this.dataIndex);
      }
    };
  }
  br(xh, mj("hostGraph", "data"));
  br(gj, mj("hostGraph", "edgeData"));
  function vj(n, e, t, r, i) {
    for (var a = new R0e(r), s = 0; s < n.length; s++) a.addNode(ni(n[s].id, n[s].name, s), s);
    for (var o = [], l = [], u = 0, s = 0; s < e.length; s++) {
      var c = e[s], h = c.source, d = c.target;
      a.addEdge(h, d, u) && (l.push(c), o.push(ni(kr(c.id, null), h + " > " + d)), u++);
    }
    var f = t.get("coordinateSystem"), p;
    if (f === "cartesian2d" || f === "polar") p = au(n, t);
    else {
      var g = Ox.get(f), m = g ? g.dimensions || [] : [];
      bt(m, "value") < 0 && m.concat([
        "value"
      ]);
      var v = zx(n, {
        coordDimensions: m,
        encodeDefine: t.getEncode()
      }).dimensions;
      p = new Ki(v, t), p.initData(n);
    }
    var y = new Ki([
      "value"
    ], t);
    return y.initData(l, o), i && i(p, y), Qq({
      mainData: p,
      struct: a,
      structAttr: "graph",
      datas: {
        node: p,
        edge: y
      },
      datasAttr: {
        node: "data",
        edge: "edgeData"
      }
    }), a.update(), a;
  }
  var $0e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments);
      var r = this;
      function i() {
        return r._categoriesData;
      }
      this.legendVisualProvider = new Yx(i, i), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeDefaultAndTheme = function(t) {
      n.prototype.mergeDefaultAndTheme.apply(this, arguments), ud(t, "edgeLabel", [
        "show"
      ]);
    }, e.prototype.getInitialData = function(t, r) {
      var i = t.edges || t.links || [], a = t.data || t.nodes || [], s = this;
      if (a && i) {
        v0e(this);
        var o = vj(a, i, this, true, l);
        return P(o.edges, function(u) {
          y0e(u.node1, u.node2, this, u.dataIndex);
        }, this), o.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var g = s._categoriesModels, m = p.getShallow("category"), v = g[m];
          return v && (v.parentModel = p.parentModel, p.parentModel = v), p;
        });
        var h = on.prototype.getModel;
        function d(p, g) {
          var m = h.call(this, p, g);
          return m.resolveParentPath = f, m;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = f, p.getModel = d, p;
        });
        function f(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, e.prototype.formatTooltip = function(t, r, i) {
      if (i === "edge") {
        var a = this.getData(), s = this.getDataParams(t, i), o = a.graph.getEdgeByIndex(t), l = a.getName(o.node1.dataIndex), u = a.getName(o.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), Xr("nameValue", {
          name: c.join(" > "),
          value: s.value,
          noValue: s.value == null
        });
      }
      var h = VX({
        series: this,
        dataIndex: t,
        multipleSeries: r
      });
      return h;
    }, e.prototype._updateCategoriesData = function() {
      var t = me(this.option.categories || [], function(i) {
        return i.value != null ? i : oe({
          value: 0
        }, i);
      }), r = new Ki([
        "value"
      ], this);
      r.initData(t), this._categoriesData = r, this._categoriesModels = r.mapArray(function(i) {
        return r.getItemModel(i);
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.isAnimationEnabled = function() {
      return n.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get([
        "force",
        "layoutAnimation"
      ]));
    }, e.type = "series.graph", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      legendHoverLink: true,
      layout: null,
      circular: {
        rotateLabel: false
      },
      force: {
        initLayout: null,
        repulsion: [
          0,
          50
        ],
        gravity: 0.1,
        friction: 0.6,
        edgeLength: 30,
        layoutAnimation: true
      },
      left: "center",
      top: "center",
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: [
        "none",
        "none"
      ],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: false,
      roam: false,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: {
        show: false,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: true,
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(En), N0e = {
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  };
  function E0e(n) {
    n.registerChartView(D0e), n.registerSeriesModel($0e), n.registerProcessor(d0e), n.registerVisual(f0e), n.registerVisual(p0e), n.registerLayout(x0e), n.registerLayout(n.PRIORITY.VISUAL.POST_CHART_LAYOUT, w0e), n.registerLayout(S0e), n.registerCoordinateSystem("graphView", {
      dimensions: jx.dimensions,
      create: I0e
    }), n.registerAction({
      type: "focusNodeAdjacency",
      event: "focusNodeAdjacency",
      update: "series:focusNodeAdjacency"
    }, ur), n.registerAction({
      type: "unfocusNodeAdjacency",
      event: "unfocusNodeAdjacency",
      update: "series:unfocusNodeAdjacency"
    }, ur), n.registerAction(N0e, function(e, t, r) {
      t.eachComponent({
        mainType: "series",
        query: e
      }, function(i) {
        var a = i.coordinateSystem, s = UE(a, e, void 0, r);
        i.setCenter && i.setCenter(s.center), i.setZoom && i.setZoom(s.zoom);
      });
    });
  }
  var M0e = /* @__PURE__ */ function() {
    function n() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return n;
  }(), P0e = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "pointer", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new M0e();
    }, e.prototype.buildPath = function(t, r) {
      var i = Math.cos, a = Math.sin, s = r.r, o = r.width, l = r.angle, u = r.x - i(l) * o * (o >= s / 3 ? 1 : 2), c = r.y - a(l) * o * (o >= s / 3 ? 1 : 2);
      l = r.angle - Math.PI / 2, t.moveTo(u, c), t.lineTo(r.x + i(l) * o, r.y + a(l) * o), t.lineTo(r.x + i(r.angle) * s, r.y + a(r.angle) * s), t.lineTo(r.x - i(l) * o, r.y - a(l) * o), t.lineTo(u, c);
    }, e;
  }(At);
  function L0e(n, e) {
    var t = n.get("center"), r = e.getWidth(), i = e.getHeight(), a = Math.min(r, i), s = _e(t[0], e.getWidth()), o = _e(t[1], e.getHeight()), l = _e(n.get("radius"), a / 2);
    return {
      cx: s,
      cy: o,
      r: l
    };
  }
  function tw(n, e) {
    var t = n == null ? "" : n + "";
    return e && (Ie(e) ? t = e.replace("{value}", t) : Xe(e) && (t = e(n))), t;
  }
  var F0e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this.group.removeAll();
      var a = t.get([
        "axisLine",
        "lineStyle",
        "color"
      ]), s = L0e(t, i);
      this._renderMain(t, r, i, a, s), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.prototype._renderMain = function(t, r, i, a, s) {
      var o = this.group, l = t.get("clockwise"), u = -t.get("startAngle") / 180 * Math.PI, c = -t.get("endAngle") / 180 * Math.PI, h = t.getModel("axisLine"), d = h.get("roundCap"), f = d ? iS : ra, p = h.get("show"), g = h.getModel("lineStyle"), m = g.get("width"), v = [
        u,
        c
      ];
      XN(v, !l), u = v[0], c = v[1];
      for (var y = c - u, x = u, b = [], w = 0; p && w < a.length; w++) {
        var _ = Math.min(Math.max(a[w][0], 0), 1);
        c = u + y * _;
        var S = new f({
          shape: {
            startAngle: x,
            endAngle: c,
            cx: s.cx,
            cy: s.cy,
            clockwise: l,
            r0: s.r - m,
            r: s.r
          },
          silent: true
        });
        S.setStyle({
          fill: a[w][1]
        }), S.setStyle(g.getLineStyle([
          "color",
          "width"
        ])), b.push(S), x = c;
      }
      b.reverse(), P(b, function(C) {
        return o.add(C);
      });
      var I = function(C) {
        if (C <= 0) return a[0][1];
        var T;
        for (T = 0; T < a.length; T++) if (a[T][0] >= C && (T === 0 ? 0 : a[T - 1][0]) < C) return a[T][1];
        return a[T - 1][1];
      };
      this._renderTicks(t, r, i, I, s, u, c, l, m), this._renderTitleAndDetail(t, r, i, I, s), this._renderAnchor(t, s), this._renderPointer(t, r, i, I, s, u, c, l, m);
    }, e.prototype._renderTicks = function(t, r, i, a, s, o, l, u, c) {
      for (var h = this.group, d = s.cx, f = s.cy, p = s.r, g = +t.get("min"), m = +t.get("max"), v = t.getModel("splitLine"), y = t.getModel("axisTick"), x = t.getModel("axisLabel"), b = t.get("splitNumber"), w = y.get("splitNumber"), _ = _e(v.get("length"), p), S = _e(y.get("length"), p), I = o, C = (l - o) / b, T = C / w, k = v.getModel("lineStyle").getLineStyle(), D = y.getModel("lineStyle").getLineStyle(), R = v.get("distance"), N, E, A = 0; A <= b; A++) {
        if (N = Math.cos(I), E = Math.sin(I), v.get("show")) {
          var M = R ? R + c : c, $ = new zr({
            shape: {
              x1: N * (p - M) + d,
              y1: E * (p - M) + f,
              x2: N * (p - _ - M) + d,
              y2: E * (p - _ - M) + f
            },
            style: k,
            silent: true
          });
          k.stroke === "auto" && $.setStyle({
            stroke: a(A / b)
          }), h.add($);
        }
        if (x.get("show")) {
          var M = x.get("distance") + R, L = tw(rr(A / b * (m - g) + g), x.get("formatter")), F = a(A / b), O = N * (p - _ - M) + d, z = E * (p - _ - M) + f, V = x.get("rotate"), H = 0;
          V === "radial" ? (H = -I + 2 * Math.PI, H > Math.PI / 2 && (H += Math.PI)) : V === "tangential" ? H = -I - Math.PI / 2 : Yt(V) && (H = V * Math.PI / 180), H === 0 ? h.add(new Gt({
            style: $n(x, {
              text: L,
              x: O,
              y: z,
              verticalAlign: E < -0.8 ? "top" : E > 0.8 ? "bottom" : "middle",
              align: N < -0.4 ? "left" : N > 0.4 ? "right" : "center"
            }, {
              inheritColor: F
            }),
            silent: true
          })) : h.add(new Gt({
            style: $n(x, {
              text: L,
              x: O,
              y: z,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: F
            }),
            silent: true,
            originX: O,
            originY: z,
            rotation: H
          }));
        }
        if (y.get("show") && A !== b) {
          var M = y.get("distance");
          M = M ? M + c : c;
          for (var Y = 0; Y <= w; Y++) {
            N = Math.cos(I), E = Math.sin(I);
            var le = new zr({
              shape: {
                x1: N * (p - M) + d,
                y1: E * (p - M) + f,
                x2: N * (p - S - M) + d,
                y2: E * (p - S - M) + f
              },
              silent: true,
              style: D
            });
            D.stroke === "auto" && le.setStyle({
              stroke: a((A + Y / w) / b)
            }), h.add(le), I += T;
          }
          I -= T;
        } else I += C;
      }
    }, e.prototype._renderPointer = function(t, r, i, a, s, o, l, u, c) {
      var h = this.group, d = this._data, f = this._progressEls, p = [], g = t.get([
        "pointer",
        "show"
      ]), m = t.getModel("progress"), v = m.get("show"), y = t.getData(), x = y.mapDimension("value"), b = +t.get("min"), w = +t.get("max"), _ = [
        b,
        w
      ], S = [
        o,
        l
      ];
      function I(T, k) {
        var D = y.getItemModel(T), R = D.getModel("pointer"), N = _e(R.get("width"), s.r), E = _e(R.get("length"), s.r), A = t.get([
          "pointer",
          "icon"
        ]), M = R.get("offsetCenter"), $ = _e(M[0], s.r), L = _e(M[1], s.r), F = R.get("keepAspect"), O;
        return A ? O = xr(A, $ - N / 2, L - E, N, E, null, F) : O = new P0e({
          shape: {
            angle: -Math.PI / 2,
            width: N,
            r: E,
            x: $,
            y: L
          }
        }), O.rotation = -(k + Math.PI / 2), O.x = s.cx, O.y = s.cy, O;
      }
      function C(T, k) {
        var D = m.get("roundCap"), R = D ? iS : ra, N = m.get("overlap"), E = N ? m.get("width") : c / y.count(), A = N ? s.r - E : s.r - (T + 1) * E, M = N ? s.r : s.r - T * E, $ = new R({
          shape: {
            startAngle: o,
            endAngle: k,
            cx: s.cx,
            cy: s.cy,
            clockwise: u,
            r0: A,
            r: M
          }
        });
        return N && ($.z2 = sn(y.get(x, T), [
          b,
          w
        ], [
          100,
          0
        ], true)), $;
      }
      (v || g) && (y.diff(d).add(function(T) {
        var k = y.get(x, T);
        if (g) {
          var D = I(T, o);
          Un(D, {
            rotation: -((isNaN(+k) ? S[0] : sn(k, _, S, true)) + Math.PI / 2)
          }, t), h.add(D), y.setItemGraphicEl(T, D);
        }
        if (v) {
          var R = C(T, o), N = m.get("clip");
          Un(R, {
            shape: {
              endAngle: sn(k, _, S, N)
            }
          }, t), h.add(R), zD(t.seriesIndex, y.dataType, T, R), p[T] = R;
        }
      }).update(function(T, k) {
        var D = y.get(x, T);
        if (g) {
          var R = d.getItemGraphicEl(k), N = R ? R.rotation : o, E = I(T, N);
          E.rotation = N, Kt(E, {
            rotation: -((isNaN(+D) ? S[0] : sn(D, _, S, true)) + Math.PI / 2)
          }, t), h.add(E), y.setItemGraphicEl(T, E);
        }
        if (v) {
          var A = f[k], M = A ? A.shape.endAngle : o, $ = C(T, M), L = m.get("clip");
          Kt($, {
            shape: {
              endAngle: sn(D, _, S, L)
            }
          }, t), h.add($), zD(t.seriesIndex, y.dataType, T, $), p[T] = $;
        }
      }).execute(), y.each(function(T) {
        var k = y.getItemModel(T), D = k.getModel("emphasis"), R = D.get("focus"), N = D.get("blurScope"), E = D.get("disabled");
        if (g) {
          var A = y.getItemGraphicEl(T), M = y.getItemVisual(T, "style"), $ = M.fill;
          if (A instanceof oi) {
            var L = A.style;
            A.useStyle(oe({
              image: L.image,
              x: L.x,
              y: L.y,
              width: L.width,
              height: L.height
            }, M));
          } else A.useStyle(M), A.type !== "pointer" && A.setColor($);
          A.setStyle(k.getModel([
            "pointer",
            "itemStyle"
          ]).getItemStyle()), A.style.fill === "auto" && A.setStyle("fill", a(sn(y.get(x, T), _, [
            0,
            1
          ], true))), A.z2EmphasisLift = 0, pi(A, k), Qn(A, R, N, E);
        }
        if (v) {
          var F = p[T];
          F.useStyle(y.getItemVisual(T, "style")), F.setStyle(k.getModel([
            "progress",
            "itemStyle"
          ]).getItemStyle()), F.z2EmphasisLift = 0, pi(F, k), Qn(F, R, N, E);
        }
      }), this._progressEls = p);
    }, e.prototype._renderAnchor = function(t, r) {
      var i = t.getModel("anchor"), a = i.get("show");
      if (a) {
        var s = i.get("size"), o = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = xr(o, r.cx - s / 2 + _e(l[0], r.r), r.cy - s / 2 + _e(l[1], r.r), s, s, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, e.prototype._renderTitleAndDetail = function(t, r, i, a, s) {
      var o = this, l = t.getData(), u = l.mapDimension("value"), c = +t.get("min"), h = +t.get("max"), d = new tt(), f = [], p = [], g = t.isAnimationEnabled(), m = t.get([
        "pointer",
        "showAbove"
      ]);
      l.diff(this._data).add(function(v) {
        f[v] = new Gt({
          silent: true
        }), p[v] = new Gt({
          silent: true
        });
      }).update(function(v, y) {
        f[v] = o._titleEls[y], p[v] = o._detailEls[y];
      }).execute(), l.each(function(v) {
        var y = l.getItemModel(v), x = l.get(u, v), b = new tt(), w = a(sn(x, [
          c,
          h
        ], [
          0,
          1
        ], true)), _ = y.getModel("title");
        if (_.get("show")) {
          var S = _.get("offsetCenter"), I = s.cx + _e(S[0], s.r), C = s.cy + _e(S[1], s.r), T = f[v];
          T.attr({
            z2: m ? 0 : 2,
            style: $n(_, {
              x: I,
              y: C,
              text: l.getName(v),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: w
            })
          }), b.add(T);
        }
        var k = y.getModel("detail");
        if (k.get("show")) {
          var D = k.get("offsetCenter"), R = s.cx + _e(D[0], s.r), N = s.cy + _e(D[1], s.r), E = _e(k.get("width"), s.r), A = _e(k.get("height"), s.r), M = t.get([
            "progress",
            "show"
          ]) ? l.getItemVisual(v, "style").fill : w, T = p[v], $ = k.get("formatter");
          T.attr({
            z2: m ? 0 : 2,
            style: $n(k, {
              x: R,
              y: N,
              text: tw(x, $),
              width: isNaN(E) ? null : E,
              height: isNaN(A) ? null : A,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: M
            })
          }), H8(T, {
            normal: k
          }, x, function(F) {
            return tw(F, $);
          }), g && X8(T, v, l, t, {
            getFormattedLabel: function(F, O, z, V, H, Y) {
              return tw(Y ? Y.interpolatedValue : x, $);
            }
          }), b.add(T);
        }
        d.add(b);
      }), this.group.add(d), this._titleEls = f, this._detailEls = p;
    }, e.type = "gauge", e;
  }(_n), O0e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "itemStyle", t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return km(this, [
        "value"
      ]);
    }, e.type = "series.gauge", e.defaultOption = {
      z: 2,
      colorBy: "data",
      center: [
        "50%",
        "50%"
      ],
      legendHoverLink: true,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: true,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        show: true,
        roundCap: false,
        lineStyle: {
          color: [
            [
              1,
              "#E6EBF8"
            ]
          ],
          width: 10
        }
      },
      progress: {
        show: false,
        overlap: true,
        width: 10,
        roundCap: false,
        clip: true
      },
      splitLine: {
        show: true,
        length: 10,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      axisTick: {
        show: true,
        splitNumber: 5,
        length: 6,
        distance: 10,
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: true,
        distance: 15,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [
          0,
          0
        ],
        show: true,
        showAbove: true,
        length: "60%",
        width: 6,
        keepAspect: false
      },
      anchor: {
        show: false,
        showAbove: false,
        size: 6,
        icon: "circle",
        offsetCenter: [
          0,
          0
        ],
        keepAspect: false,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: true,
        offsetCenter: [
          0,
          "20%"
        ],
        color: "#464646",
        fontSize: 16,
        valueAnimation: false
      },
      detail: {
        show: true,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [
          5,
          10
        ],
        offsetCenter: [
          0,
          "40%"
        ],
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: false
      }
    }, e;
  }(En);
  function B0e(n) {
    n.registerChartView(F0e), n.registerSeriesModel(O0e);
  }
  var z0e = [
    "itemStyle",
    "opacity"
  ], V0e = function(n) {
    K(e, n);
    function e(t, r) {
      var i = n.call(this) || this, a = i, s = new oa(), o = new Gt();
      return a.setTextContent(o), i.setTextGuideLine(s), i.updateData(t, r, true), i;
    }
    return e.prototype.updateData = function(t, r, i) {
      var a = this, s = t.hostModel, o = t.getItemModel(r), l = t.getItemLayout(r), u = o.getModel("emphasis"), c = o.get(z0e);
      c = c ?? 1, i || ro(a), a.useStyle(t.getItemVisual(r, "style")), a.style.lineJoin = "round", i ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, Un(a, {
        style: {
          opacity: c
        }
      }, s, r)) : Kt(a, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, s, r), pi(a, o), this._updateLabel(t, r), Qn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, r) {
      var i = this, a = this.getTextGuideLine(), s = i.getTextContent(), o = t.hostModel, l = t.getItemModel(r), u = t.getItemLayout(r), c = u.label, h = t.getItemVisual(r, "style"), d = h.fill;
      gi(s, Hr(l), {
        labelFetcher: t.hostModel,
        labelDataIndex: r,
        defaultOpacity: h.opacity,
        defaultText: t.getName(r)
      }, {
        normal: {
          align: c.textAlign,
          verticalAlign: c.verticalAlign
        }
      }), i.setTextConfig({
        local: true,
        inside: !!c.inside,
        insideStroke: d,
        outsideFill: d
      });
      var f = c.linePoints;
      a.setShape({
        points: f
      }), i.textGuideLineConfig = {
        anchor: f ? new mt(f[0][0], f[0][1]) : null
      }, Kt(s, {
        style: {
          x: c.x,
          y: c.y
        }
      }, o, r), s.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), RE(i, $E(l), {
        stroke: d
      });
    }, e;
  }(ia), W0e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreLabelLineUpdate = true, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), s = this._data, o = this.group;
      a.diff(s).add(function(l) {
        var u = new V0e(a, l);
        a.setItemGraphicEl(l, u), o.add(u);
      }).update(function(l, u) {
        var c = s.getItemGraphicEl(u);
        c.updateData(a, l), o.add(c), a.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = s.getItemGraphicEl(l);
        E0(u, t, l);
      }).execute(), this._data = a;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.prototype.dispose = function() {
    }, e.type = "funnel", e;
  }(_n), G0e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Yx(Ae(this.getData, this), Ae(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.getInitialData = function(t, r) {
      return km(this, {
        coordDimensions: [
          "value"
        ],
        encodeDefaulter: lt(uE, this)
      });
    }, e.prototype._defaultLabelLine = function(t) {
      ud(t, "labelLine", [
        "show"
      ]);
      var r = t.labelLine, i = t.emphasis.labelLine;
      r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show;
    }, e.prototype.getDataParams = function(t) {
      var r = this.getData(), i = n.prototype.getDataParams.call(this, t), a = r.mapDimension("value"), s = r.getSum(a);
      return i.percent = s ? +(r.get(a, t) / s * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, e.type = "series.funnel", e.defaultOption = {
      z: 2,
      legendHoverLink: true,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: true,
        position: "outer"
      },
      labelLine: {
        show: true,
        length: 20,
        lineStyle: {
          width: 1
        }
      },
      itemStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(En);
  function U0e(n, e) {
    return Er(n.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function H0e(n, e) {
    for (var t = n.mapDimension("value"), r = n.mapArray(t, function(l) {
      return l;
    }), i = [], a = e === "ascending", s = 0, o = n.count(); s < o; s++) i[s] = s;
    return Xe(e) ? i.sort(e) : e !== "none" && i.sort(function(l, u) {
      return a ? r[l] - r[u] : r[u] - r[l];
    }), i;
  }
  function X0e(n) {
    var e = n.hostModel, t = e.get("orient");
    n.each(function(r) {
      var i = n.getItemModel(r), a = i.getModel("label"), s = a.get("position"), o = i.getModel("labelLine"), l = n.getItemLayout(r), u = l.points, c = s === "inner" || s === "inside" || s === "center" || s === "insideLeft" || s === "insideRight", h, d, f, p;
      if (c) s === "insideLeft" ? (d = (u[0][0] + u[3][0]) / 2 + 5, f = (u[0][1] + u[3][1]) / 2, h = "left") : s === "insideRight" ? (d = (u[1][0] + u[2][0]) / 2 - 5, f = (u[1][1] + u[2][1]) / 2, h = "right") : (d = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, f = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, h = "center"), p = [
        [
          d,
          f
        ],
        [
          d,
          f
        ]
      ];
      else {
        var g = void 0, m = void 0, v = void 0, y = void 0, x = o.get("length");
        s === "left" ? (g = (u[3][0] + u[0][0]) / 2, m = (u[3][1] + u[0][1]) / 2, v = g - x, d = v - 5, h = "right") : s === "right" ? (g = (u[1][0] + u[2][0]) / 2, m = (u[1][1] + u[2][1]) / 2, v = g + x, d = v + 5, h = "left") : s === "top" ? (g = (u[3][0] + u[0][0]) / 2, m = (u[3][1] + u[0][1]) / 2, y = m - x, f = y - 5, h = "center") : s === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, m = (u[1][1] + u[2][1]) / 2, y = m + x, f = y + 5, h = "center") : s === "rightTop" ? (g = t === "horizontal" ? u[3][0] : u[1][0], m = t === "horizontal" ? u[3][1] : u[1][1], t === "horizontal" ? (y = m - x, f = y - 5, h = "center") : (v = g + x, d = v + 5, h = "top")) : s === "rightBottom" ? (g = u[2][0], m = u[2][1], t === "horizontal" ? (y = m + x, f = y + 5, h = "center") : (v = g + x, d = v + 5, h = "bottom")) : s === "leftTop" ? (g = u[0][0], m = t === "horizontal" ? u[0][1] : u[1][1], t === "horizontal" ? (y = m - x, f = y - 5, h = "center") : (v = g - x, d = v - 5, h = "right")) : s === "leftBottom" ? (g = t === "horizontal" ? u[1][0] : u[3][0], m = t === "horizontal" ? u[1][1] : u[2][1], t === "horizontal" ? (y = m + x, f = y + 5, h = "center") : (v = g - x, d = v - 5, h = "right")) : (g = (u[1][0] + u[2][0]) / 2, m = (u[1][1] + u[2][1]) / 2, t === "horizontal" ? (y = m + x, f = y + 5, h = "center") : (v = g + x, d = v + 5, h = "left")), t === "horizontal" ? (v = g, d = v) : (y = m, f = y), p = [
          [
            g,
            m
          ],
          [
            v,
            y
          ]
        ];
      }
      l.label = {
        linePoints: p,
        x: d,
        y: f,
        verticalAlign: "middle",
        textAlign: h,
        inside: c
      };
    });
  }
  function Y0e(n, e) {
    n.eachSeriesByType("funnel", function(t) {
      var r = t.getData(), i = r.mapDimension("value"), a = t.get("sort"), s = U0e(t, e), o = t.get("orient"), l = s.width, u = s.height, c = H0e(r, a), h = s.x, d = s.y, f = o === "horizontal" ? [
        _e(t.get("minSize"), u),
        _e(t.get("maxSize"), u)
      ] : [
        _e(t.get("minSize"), l),
        _e(t.get("maxSize"), l)
      ], p = r.getDataExtent(i), g = t.get("min"), m = t.get("max");
      g == null && (g = Math.min(p[0], 0)), m == null && (m = p[1]);
      var v = t.get("funnelAlign"), y = t.get("gap"), x = o === "horizontal" ? l : u, b = (x - y * (r.count() - 1)) / r.count(), w = function(N, E) {
        if (o === "horizontal") {
          var A = r.get(i, N) || 0, M = sn(A, [
            g,
            m
          ], f, true), $ = void 0;
          switch (v) {
            case "top":
              $ = d;
              break;
            case "center":
              $ = d + (u - M) / 2;
              break;
            case "bottom":
              $ = d + (u - M);
              break;
          }
          return [
            [
              E,
              $
            ],
            [
              E,
              $ + M
            ]
          ];
        }
        var L = r.get(i, N) || 0, F = sn(L, [
          g,
          m
        ], f, true), O;
        switch (v) {
          case "left":
            O = h;
            break;
          case "center":
            O = h + (l - F) / 2;
            break;
          case "right":
            O = h + l - F;
            break;
        }
        return [
          [
            O,
            E
          ],
          [
            O + F,
            E
          ]
        ];
      };
      a === "ascending" && (b = -b, y = -y, o === "horizontal" ? h += l : d += u, c = c.reverse());
      for (var _ = 0; _ < c.length; _++) {
        var S = c[_], I = c[_ + 1], C = r.getItemModel(S);
        if (o === "horizontal") {
          var T = C.get([
            "itemStyle",
            "width"
          ]);
          T == null ? T = b : (T = _e(T, l), a === "ascending" && (T = -T));
          var k = w(S, h), D = w(I, h + T);
          h += T + y, r.setItemLayout(S, {
            points: k.concat(D.slice().reverse())
          });
        } else {
          var R = C.get([
            "itemStyle",
            "height"
          ]);
          R == null ? R = b : (R = _e(R, u), a === "ascending" && (R = -R));
          var k = w(S, d), D = w(I, d + R);
          d += R + y, r.setItemLayout(S, {
            points: k.concat(D.slice().reverse())
          });
        }
      }
      X0e(r);
    });
  }
  function q0e(n) {
    n.registerChartView(W0e), n.registerSeriesModel(G0e), n.registerLayout(Y0e), n.registerProcessor(Xx("funnel"));
  }
  var j0e = 0.3, K0e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._dataGroup = new tt(), t._initialized = false, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, e.prototype.render = function(t, r, i, a) {
      this._progressiveEls = null;
      var s = this._dataGroup, o = t.getData(), l = this._data, u = t.coordinateSystem, c = u.dimensions, h = dV(t);
      o.diff(l).add(d).update(f).remove(p).execute();
      function d(m) {
        var v = hV(o, s, m, c, u);
        mT(v, o, m, h);
      }
      function f(m, v) {
        var y = l.getItemGraphicEl(v), x = yj(o, m, c, u);
        o.setItemGraphicEl(m, y), Kt(y, {
          shape: {
            points: x
          }
        }, t, m), ro(y), mT(y, o, m, h);
      }
      function p(m) {
        var v = l.getItemGraphicEl(m);
        s.remove(v);
      }
      if (!this._initialized) {
        this._initialized = true;
        var g = Z0e(u, t, function() {
          setTimeout(function() {
            s.removeClipPath();
          });
        });
        s.setClipPath(g);
      }
      this._data = o;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this._initialized = true, this._data = null, this._dataGroup.removeAll();
    }, e.prototype.incrementalRender = function(t, r, i) {
      for (var a = r.getData(), s = r.coordinateSystem, o = s.dimensions, l = dV(r), u = this._progressiveEls = [], c = t.start; c < t.end; c++) {
        var h = hV(a, this._dataGroup, c, o, s);
        h.incremental = true, mT(h, a, c, l), u.push(h);
      }
    }, e.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, e.type = "parallel", e;
  }(_n);
  function Z0e(n, e, t) {
    var r = n.model, i = n.getRect(), a = new Vt({
      shape: {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      }
    }), s = r.get("layout") === "horizontal" ? "width" : "height";
    return a.setShape(s, 0), Un(a, {
      shape: {
        width: i.width,
        height: i.height
      }
    }, e, t), a;
  }
  function yj(n, e, t, r) {
    for (var i = [], a = 0; a < t.length; a++) {
      var s = t[a], o = n.get(n.mapDimension(s), e);
      Q0e(o, r.getAxis(s).type) || i.push(r.dataToPoint(o, s));
    }
    return i;
  }
  function hV(n, e, t, r, i) {
    var a = yj(n, t, r, i), s = new oa({
      shape: {
        points: a
      },
      z2: 10
    });
    return e.add(s), n.setItemGraphicEl(t, s), s;
  }
  function dV(n) {
    var e = n.get("smooth", true);
    return e === true && (e = j0e), e = Hl(e), C0(e) && (e = 0), {
      smooth: e
    };
  }
  function mT(n, e, t, r) {
    n.useStyle(e.getItemVisual(t, "style")), n.style.fill = null, n.setShape("smooth", r.smooth);
    var i = e.getItemModel(t), a = i.getModel("emphasis");
    pi(n, i, "lineStyle"), Qn(n, a.get("focus"), a.get("blurScope"), a.get("disabled"));
  }
  function Q0e(n, e) {
    return e === "category" ? n == null : n == null || isNaN(n);
  }
  var J0e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return au(null, this, {
        useEncodeDefaulter: Ae(exe, null, this)
      });
    }, e.prototype.getRawIndicesByActiveState = function(t) {
      var r = this.coordinateSystem, i = this.getData(), a = [];
      return r.eachActiveState(i, function(s, o) {
        t === s && a.push(i.getRawIndex(o));
      }), a;
    }, e.type = "series.parallel", e.dependencies = [
      "parallel"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: false
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: false
        }
      },
      progressive: 500,
      smooth: false,
      animationEasing: "linear"
    }, e;
  }(En);
  function exe(n) {
    var e = n.ecModel.getComponent("parallel", n.get("parallelIndex"));
    if (e) {
      var t = {};
      return P(e.dimensions, function(r) {
        var i = txe(r);
        t[r] = i;
      }), t;
    }
  }
  function txe(n) {
    return +n.replace("dim", "");
  }
  var nxe = [
    "lineStyle",
    "opacity"
  ], rxe = {
    seriesType: "parallel",
    reset: function(n, e) {
      var t = n.coordinateSystem, r = {
        normal: n.get([
          "lineStyle",
          "opacity"
        ]),
        active: n.get("activeOpacity"),
        inactive: n.get("inactiveOpacity")
      };
      return {
        progress: function(i, a) {
          t.eachActiveState(a, function(s, o) {
            var l = r[s];
            if (s === "normal" && a.hasItemOption) {
              var u = a.getItemModel(o).get(nxe, true);
              u != null && (l = u);
            }
            var c = a.ensureUniqueItemVisual(o, "style");
            c.opacity = l;
          }, i.start, i.end);
        }
      };
    }
  };
  function ixe(n) {
    axe(n), sxe(n);
  }
  function axe(n) {
    if (!n.parallel) {
      var e = false;
      P(n.series, function(t) {
        t && t.type === "parallel" && (e = true);
      }), e && (n.parallel = [
        {}
      ]);
    }
  }
  function sxe(n) {
    var e = xn(n.parallelAxis);
    P(e, function(t) {
      if (Ze(t)) {
        var r = t.parallelIndex || 0, i = xn(n.parallel)[r];
        i && i.parallelAxisDefault && pt(t, i.parallelAxisDefault, false);
      }
    });
  }
  var oxe = 5, lxe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this._model = t, this._api = i, this._handlers || (this._handlers = {}, P(uxe, function(a, s) {
        i.getZr().on(s, this._handlers[s] = Ae(a, this));
      }, this)), Sm(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
    }, e.prototype.dispose = function(t, r) {
      F0(this, "_throttledDispatchExpand"), P(this._handlers, function(i, a) {
        r.getZr().off(a, i);
      }), this._handlers = null;
    }, e.prototype._throttledDispatchExpand = function(t) {
      this._dispatchExpand(t);
    }, e.prototype._dispatchExpand = function(t) {
      t && this._api.dispatchAction(oe({
        type: "parallelAxisExpand"
      }, t));
    }, e.type = "parallel", e;
  }(Yn), uxe = {
    mousedown: function(n) {
      vT(this, "click") && (this._mouseDownPoint = [
        n.offsetX,
        n.offsetY
      ]);
    },
    mouseup: function(n) {
      var e = this._mouseDownPoint;
      if (vT(this, "click") && e) {
        var t = [
          n.offsetX,
          n.offsetY
        ], r = Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
        if (r > oxe) return;
        var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([
          n.offsetX,
          n.offsetY
        ]);
        i.behavior !== "none" && this._dispatchExpand({
          axisExpandWindow: i.axisExpandWindow
        });
      }
      this._mouseDownPoint = null;
    },
    mousemove: function(n) {
      if (!(this._mouseDownPoint || !vT(this, "mousemove"))) {
        var e = this._model, t = e.coordinateSystem.getSlidedAxisExpandWindow([
          n.offsetX,
          n.offsetY
        ]), r = t.behavior;
        r === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(r === "none" ? null : {
          axisExpandWindow: t.axisExpandWindow,
          animation: r === "jump" ? null : {
            duration: 0
          }
        });
      }
    }
  };
  function vT(n, e) {
    var t = n._model;
    return t.get("axisExpandable") && t.get("axisExpandTriggerOn") === e;
  }
  var cxe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      n.prototype.init.apply(this, arguments), this.mergeOption({});
    }, e.prototype.mergeOption = function(t) {
      var r = this.option;
      t && pt(r, t, true), this._initDimensions();
    }, e.prototype.contains = function(t, r) {
      var i = t.get("parallelIndex");
      return i != null && r.getComponent("parallel", i) === this;
    }, e.prototype.setAxisExpand = function(t) {
      P([
        "axisExpandable",
        "axisExpandCenter",
        "axisExpandCount",
        "axisExpandWidth",
        "axisExpandWindow"
      ], function(r) {
        t.hasOwnProperty(r) && (this.option[r] = t[r]);
      }, this);
    }, e.prototype._initDimensions = function() {
      var t = this.dimensions = [], r = this.parallelAxisIndex = [], i = rn(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      P(i, function(a) {
        t.push("dim" + a.get("dim")), r.push(a.componentIndex);
      });
    }, e.type = "parallel", e.dependencies = [
      "parallelAxis"
    ], e.layoutMode = "box", e.defaultOption = {
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      layout: "horizontal",
      axisExpandable: false,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      axisExpandSlideTriggerArea: [
        -0.15,
        0.05,
        0.4
      ],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, e;
  }(Et), hxe = function(n) {
    K(e, n);
    function e(t, r, i, a, s) {
      var o = n.call(this, t, r, i) || this;
      return o.type = a || "value", o.axisIndex = s, o;
    }
    return e.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, e;
  }(fo);
  function Vd(n, e, t, r, i, a) {
    n = n || 0;
    var s = t[1] - t[0];
    if (i != null && (i = Vp(i, [
      0,
      s
    ])), a != null && (a = Math.max(a, i ?? 0)), r === "all") {
      var o = Math.abs(e[1] - e[0]);
      o = Vp(o, [
        0,
        s
      ]), i = a = Vp(o, [
        i,
        a
      ]), r = 0;
    }
    e[0] = Vp(e[0], t), e[1] = Vp(e[1], t);
    var l = yT(e, r);
    e[r] += n;
    var u = i || 0, c = t.slice();
    l.sign < 0 ? c[0] += u : c[1] -= u, e[r] = Vp(e[r], c);
    var h;
    return h = yT(e, r), i != null && (h.sign !== l.sign || h.span < i) && (e[1 - r] = e[r] + l.sign * i), h = yT(e, r), a != null && h.span > a && (e[1 - r] = e[r] + h.sign * a), e;
  }
  function yT(n, e) {
    var t = n[e] - n[1 - e];
    return {
      span: Math.abs(t),
      sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1
    };
  }
  function Vp(n, e) {
    return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, n));
  }
  var xT = P, xj = Math.min, bj = Math.max, fV = Math.floor, dxe = Math.ceil, pV = rr, fxe = Math.PI, pxe = function() {
    function n(e, t, r) {
      this.type = "parallel", this._axesMap = Pe(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, t, r);
    }
    return n.prototype._init = function(e, t, r) {
      var i = e.dimensions, a = e.parallelAxisIndex;
      xT(i, function(s, o) {
        var l = a[o], u = t.getComponent("parallelAxis", l), c = this._axesMap.set(s, new hxe(s, VC(u), [
          0,
          0
        ], u.get("type"), l)), h = c.type === "category";
        c.onBand = h && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, n.prototype.update = function(e, t) {
      this._updateAxesFromSeries(this._model, e);
    }, n.prototype.containPoint = function(e) {
      var t = this._makeLayoutInfo(), r = t.axisBase, i = t.layoutBase, a = t.pixelDimIndex, s = e[1 - a], o = e[a];
      return s >= r && s <= r + t.axisLength && o >= i && o <= i + t.layoutLength;
    }, n.prototype.getModel = function() {
      return this._model;
    }, n.prototype._updateAxesFromSeries = function(e, t) {
      t.eachSeries(function(r) {
        if (e.contains(r, t)) {
          var i = r.getData();
          xT(this.dimensions, function(a) {
            var s = this._axesMap.get(a);
            s.scale.unionExtentFromData(i, i.mapDimension(a)), Fg(s.scale, s.model);
          }, this);
        }
      }, this);
    }, n.prototype.resize = function(e, t) {
      this._rect = Er(e.getBoxLayoutParams(), {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._layoutAxes();
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype._makeLayoutInfo = function() {
      var e = this._model, t = this._rect, r = [
        "x",
        "y"
      ], i = [
        "width",
        "height"
      ], a = e.get("layout"), s = a === "horizontal" ? 0 : 1, o = t[i[s]], l = [
        0,
        o
      ], u = this.dimensions.length, c = nw(e.get("axisExpandWidth"), l), h = nw(e.get("axisExpandCount") || 0, [
        0,
        u
      ]), d = e.get("axisExpandable") && u > 3 && u > h && h > 1 && c > 0 && o > 0, f = e.get("axisExpandWindow"), p;
      if (f) p = nw(f[1] - f[0], l), f[1] = f[0] + p;
      else {
        p = nw(c * (h - 1), l);
        var g = e.get("axisExpandCenter") || fV(u / 2);
        f = [
          c * g - p / 2
        ], f[1] = f[0] + p;
      }
      var m = (o - p) / (u - h);
      m < 3 && (m = 0);
      var v = [
        fV(pV(f[0] / c, 1)) + 1,
        dxe(pV(f[1] / c, 1)) - 1
      ], y = m / c * f[0];
      return {
        layout: a,
        pixelDimIndex: s,
        layoutBase: t[r[s]],
        layoutLength: o,
        axisBase: t[r[1 - s]],
        axisLength: t[i[1 - s]],
        axisExpandable: d,
        axisExpandWidth: c,
        axisCollapseWidth: m,
        axisExpandWindow: f,
        axisCount: u,
        winInnerIndices: v,
        axisExpandWindow0Pos: y
      };
    }, n.prototype._layoutAxes = function() {
      var e = this._rect, t = this._axesMap, r = this.dimensions, i = this._makeLayoutInfo(), a = i.layout;
      t.each(function(s) {
        var o = [
          0,
          i.axisLength
        ], l = s.inverse ? 1 : 0;
        s.setExtent(o[l], o[1 - l]);
      }), xT(r, function(s, o) {
        var l = (i.axisExpandable ? mxe : gxe)(o, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: fxe / 2,
          vertical: 0
        }, h = [
          u[a].x + e.x,
          u[a].y + e.y
        ], d = c[a], f = za();
        Md(f, f, d), Jo(f, f, h), this._axesLayout[s] = {
          position: h,
          rotation: d,
          transform: f,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, n.prototype.getAxis = function(e) {
      return this._axesMap.get(e);
    }, n.prototype.dataToPoint = function(e, t) {
      return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t);
    }, n.prototype.eachActiveState = function(e, t, r, i) {
      r == null && (r = 0), i == null && (i = e.count());
      var a = this._axesMap, s = this.dimensions, o = [], l = [];
      P(s, function(m) {
        o.push(e.mapDimension(m)), l.push(a.get(m).model);
      });
      for (var u = this.hasAxisBrushed(), c = r; c < i; c++) {
        var h = void 0;
        if (!u) h = "normal";
        else {
          h = "active";
          for (var d = e.getValues(o, c), f = 0, p = s.length; f < p; f++) {
            var g = l[f].getActiveState(d[f]);
            if (g === "inactive") {
              h = "inactive";
              break;
            }
          }
        }
        t(h, c);
      }
    }, n.prototype.hasAxisBrushed = function() {
      for (var e = this.dimensions, t = this._axesMap, r = false, i = 0, a = e.length; i < a; i++) t.get(e[i]).model.getActiveState() !== "normal" && (r = true);
      return r;
    }, n.prototype.axisCoordToPoint = function(e, t) {
      var r = this._axesLayout[t];
      return Zs([
        e,
        0
      ], r.transform);
    }, n.prototype.getAxisLayout = function(e) {
      return Qe(this._axesLayout[e]);
    }, n.prototype.getSlidedAxisExpandWindow = function(e) {
      var t = this._makeLayoutInfo(), r = t.pixelDimIndex, i = t.axisExpandWindow.slice(), a = i[1] - i[0], s = [
        0,
        t.axisExpandWidth * (t.axisCount - 1)
      ];
      if (!this.containPoint(e)) return {
        behavior: "none",
        axisExpandWindow: i
      };
      var o = e[r] - t.layoutBase - t.axisExpandWindow0Pos, l, u = "slide", c = t.axisCollapseWidth, h = this._model.get("axisExpandSlideTriggerArea"), d = h[0] != null;
      if (c) d && c && o < a * h[0] ? (u = "jump", l = o - a * h[2]) : d && c && o > a * (1 - h[0]) ? (u = "jump", l = o - a * (1 - h[2])) : (l = o - a * h[1]) >= 0 && (l = o - a * (1 - h[1])) <= 0 && (l = 0), l *= t.axisExpandWidth / c, l ? Vd(l, i, s, "all") : u = "none";
      else {
        var f = i[1] - i[0], p = s[1] * o / f;
        i = [
          bj(0, p - f / 2)
        ], i[1] = xj(s[1], i[0] + f), i[0] = i[1] - f;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, n;
  }();
  function nw(n, e) {
    return xj(bj(n, e[0]), e[1]);
  }
  function gxe(n, e) {
    var t = e.layoutLength / (e.axisCount - 1);
    return {
      position: t * n,
      axisNameAvailableWidth: t,
      axisLabelShow: true
    };
  }
  function mxe(n, e) {
    var t = e.layoutLength, r = e.axisExpandWidth, i = e.axisCount, a = e.axisCollapseWidth, s = e.winInnerIndices, o, l = a, u = false, c;
    return n < s[0] ? (o = n * a, c = a) : n <= s[1] ? (o = e.axisExpandWindow0Pos + n * r - e.axisExpandWindow[0], l = r, u = true) : (o = t - (i - 1 - n) * a, c = a), {
      position: o,
      axisNameAvailableWidth: l,
      axisLabelShow: u,
      nameTruncateMaxWidth: c
    };
  }
  function vxe(n, e) {
    var t = [];
    return n.eachComponent("parallel", function(r, i) {
      var a = new pxe(r, n, e);
      a.name = "parallel_" + i, a.resize(r, e), r.coordinateSystem = a, a.model = r, t.push(a);
    }), n.eachSeries(function(r) {
      if (r.get("coordinateSystem") === "parallel") {
        var i = r.getReferringComponents("parallel", yr).models[0];
        r.coordinateSystem = i.coordinateSystem;
      }
    }), t;
  }
  var yxe = {
    create: vxe
  }, RR = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.activeIntervals = [], t;
    }
    return e.prototype.getAreaSelectStyle = function() {
      return hd([
        [
          "fill",
          "color"
        ],
        [
          "lineWidth",
          "borderWidth"
        ],
        [
          "stroke",
          "borderColor"
        ],
        [
          "width",
          "width"
        ],
        [
          "opacity",
          "opacity"
        ]
      ])(this.getModel("areaSelectStyle"));
    }, e.prototype.setActiveIntervals = function(t) {
      var r = this.activeIntervals = Qe(t);
      if (r) for (var i = r.length - 1; i >= 0; i--) vs(r[i]);
    }, e.prototype.getActiveState = function(t) {
      var r = this.activeIntervals;
      if (!r.length) return "normal";
      if (t == null || isNaN(+t)) return "inactive";
      if (r.length === 1) {
        var i = r[0];
        if (i[0] <= t && t <= i[1]) return "active";
      } else for (var a = 0, s = r.length; a < s; a++) if (r[a][0] <= t && t <= r[a][1]) return "active";
      return "inactive";
    }, e;
  }(Et);
  br(RR, Vx);
  var pd = true, j0 = Math.min, zg = Math.max, xxe = Math.pow, bxe = 1e4, wxe = 6, _xe = 6, gV = "globalPan", Sxe = {
    w: [
      0,
      0
    ],
    e: [
      0,
      1
    ],
    n: [
      1,
      0
    ],
    s: [
      1,
      1
    ]
  }, Cxe = {
    w: "ew",
    e: "ew",
    n: "ns",
    s: "ns",
    ne: "nesw",
    sw: "nesw",
    nw: "nwse",
    se: "nwse"
  }, mV = {
    brushStyle: {
      lineWidth: 2,
      stroke: "rgba(210,219,238,0.3)",
      fill: "#D2DBEE"
    },
    transformable: true,
    brushMode: "single",
    removeOnClick: false
  }, Ixe = 0, eM = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this) || this;
      return r._track = [], r._covers = [], r._handlers = {}, r._zr = t, r.group = new tt(), r._uid = "brushController_" + Ixe++, P(Nxe, function(i, a) {
        this._handlers[a] = Ae(i, this);
      }, r), r;
    }
    return e.prototype.enableBrush = function(t) {
      return this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this;
    }, e.prototype._doEnableBrush = function(t) {
      var r = this._zr;
      this._enableGlobalPan || gve(r, gV, this._uid), P(this._handlers, function(i, a) {
        r.on(a, i);
      }), this._brushType = t.brushType, this._brushOption = pt(Qe(mV), t, true);
    }, e.prototype._doDisableBrush = function() {
      var t = this._zr;
      mve(t, gV, this._uid), P(this._handlers, function(r, i) {
        t.off(i, r);
      }), this._brushType = this._brushOption = null;
    }, e.prototype.setPanels = function(t) {
      if (t && t.length) {
        var r = this._panels = {};
        P(t, function(i) {
          r[i.panelId] = Qe(i);
        });
      } else this._panels = null;
      return this;
    }, e.prototype.mount = function(t) {
      t = t || {}, this._enableGlobalPan = t.enableGlobalPan;
      var r = this.group;
      return this._zr.add(r), r.attr({
        x: t.x || 0,
        y: t.y || 0,
        rotation: t.rotation || 0,
        scaleX: t.scaleX || 1,
        scaleY: t.scaleY || 1
      }), this._transform = r.getLocalTransform(), this;
    }, e.prototype.updateCovers = function(t) {
      t = me(t, function(d) {
        return pt(Qe(mV), d, true);
      });
      var r = "\0-brush-index-", i = this._covers, a = this._covers = [], s = this, o = this._creatingCover;
      return new ql(i, t, u, l).add(c).update(c).remove(h).execute(), this;
      function l(d, f) {
        return (d.id != null ? d.id : r + f) + "-" + d.brushType;
      }
      function u(d, f) {
        return l(d.__brushOption, f);
      }
      function c(d, f) {
        var p = t[d];
        if (f != null && i[f] === o) a[d] = i[f];
        else {
          var g = a[d] = f != null ? (i[f].__brushOption = p, i[f]) : _j(s, wj(s, p));
          tM(s, g);
        }
      }
      function h(d) {
        i[d] !== o && s.group.remove(i[d]);
      }
    }, e.prototype.unmount = function() {
      return this.enableBrush(false), $R(this), this._zr.remove(this.group), this;
    }, e.prototype.dispose = function() {
      this.unmount(), this.off();
    }, e;
  }(Is);
  function wj(n, e) {
    var t = YC[e.brushType].createCover(n, e);
    return t.__brushOption = e, Cj(t, e), n.group.add(t), t;
  }
  function _j(n, e) {
    var t = nM(e);
    return t.endCreating && (t.endCreating(n, e), Cj(e, e.__brushOption)), e;
  }
  function Sj(n, e) {
    var t = e.__brushOption;
    nM(e).updateCoverShape(n, e, t.range, t);
  }
  function Cj(n, e) {
    var t = e.z;
    t == null && (t = bxe), n.traverse(function(r) {
      r.z = t, r.z2 = t;
    });
  }
  function tM(n, e) {
    nM(e).updateCommon(n, e), Sj(n, e);
  }
  function nM(n) {
    return YC[n.__brushOption.brushType];
  }
  function rM(n, e, t) {
    var r = n._panels;
    if (!r) return pd;
    var i, a = n._transform;
    return P(r, function(s) {
      s.isTargetByCursor(e, t, a) && (i = s);
    }), i;
  }
  function Ij(n, e) {
    var t = n._panels;
    if (!t) return pd;
    var r = e.__brushOption.panelId;
    return r != null ? t[r] : pd;
  }
  function $R(n) {
    var e = n._covers, t = e.length;
    return P(e, function(r) {
      n.group.remove(r);
    }, n), e.length = 0, !!t;
  }
  function gd(n, e) {
    var t = me(n._covers, function(r) {
      var i = r.__brushOption, a = Qe(i.range);
      return {
        brushType: i.brushType,
        panelId: i.panelId,
        range: a
      };
    });
    n.trigger("brush", {
      areas: t,
      isEnd: !!e.isEnd,
      removeOnClick: !!e.removeOnClick
    });
  }
  function kxe(n) {
    var e = n._track;
    if (!e.length) return false;
    var t = e[e.length - 1], r = e[0], i = t[0] - r[0], a = t[1] - r[1], s = xxe(i * i + a * a, 0.5);
    return s > wxe;
  }
  function kj(n) {
    var e = n.length - 1;
    return e < 0 && (e = 0), [
      n[0],
      n[e]
    ];
  }
  function Tj(n, e, t, r) {
    var i = new tt();
    return i.add(new Vt({
      name: "main",
      style: iM(t),
      silent: true,
      draggable: true,
      cursor: "move",
      drift: lt(vV, n, e, i, [
        "n",
        "s",
        "w",
        "e"
      ]),
      ondragend: lt(gd, e, {
        isEnd: true
      })
    })), P(r, function(a) {
      i.add(new Vt({
        name: a.join(""),
        style: {
          opacity: 0
        },
        draggable: true,
        silent: true,
        invisible: true,
        drift: lt(vV, n, e, i, a),
        ondragend: lt(gd, e, {
          isEnd: true
        })
      }));
    }), i;
  }
  function Aj(n, e, t, r) {
    var i = r.brushStyle.lineWidth || 0, a = zg(i, _xe), s = t[0][0], o = t[1][0], l = s - i / 2, u = o - i / 2, c = t[0][1], h = t[1][1], d = c - a + i / 2, f = h - a + i / 2, p = c - s, g = h - o, m = p + i, v = g + i;
    xl(n, e, "main", s, o, p, g), r.transformable && (xl(n, e, "w", l, u, a, v), xl(n, e, "e", d, u, a, v), xl(n, e, "n", l, u, m, a), xl(n, e, "s", l, f, m, a), xl(n, e, "nw", l, u, a, a), xl(n, e, "ne", d, u, a, a), xl(n, e, "sw", l, f, a, a), xl(n, e, "se", d, f, a, a));
  }
  function NR(n, e) {
    var t = e.__brushOption, r = t.transformable, i = e.childAt(0);
    i.useStyle(iM(t)), i.attr({
      silent: !r,
      cursor: r ? "move" : "default"
    }), P([
      [
        "w"
      ],
      [
        "e"
      ],
      [
        "n"
      ],
      [
        "s"
      ],
      [
        "s",
        "e"
      ],
      [
        "s",
        "w"
      ],
      [
        "n",
        "e"
      ],
      [
        "n",
        "w"
      ]
    ], function(a) {
      var s = e.childOfName(a.join("")), o = a.length === 1 ? ER(n, a[0]) : Axe(n, a);
      s && s.attr({
        silent: !r,
        invisible: !r,
        cursor: r ? Cxe[o] + "-resize" : null
      });
    });
  }
  function xl(n, e, t, r, i, a, s) {
    var o = e.childOfName(t);
    o && o.setShape(Rxe(aM(n, e, [
      [
        r,
        i
      ],
      [
        r + a,
        i + s
      ]
    ])));
  }
  function iM(n) {
    return je({
      strokeNoScale: true
    }, n.brushStyle);
  }
  function Dj(n, e, t, r) {
    var i = [
      j0(n, t),
      j0(e, r)
    ], a = [
      zg(n, t),
      zg(e, r)
    ];
    return [
      [
        i[0],
        a[0]
      ],
      [
        i[1],
        a[1]
      ]
    ];
  }
  function Txe(n) {
    return Jh(n.group);
  }
  function ER(n, e) {
    var t = {
      w: "left",
      e: "right",
      n: "top",
      s: "bottom"
    }, r = {
      left: "w",
      right: "e",
      top: "n",
      bottom: "s"
    }, i = IC(t[e], Txe(n));
    return r[i];
  }
  function Axe(n, e) {
    var t = [
      ER(n, e[0]),
      ER(n, e[1])
    ];
    return (t[0] === "e" || t[0] === "w") && t.reverse(), t.join("");
  }
  function vV(n, e, t, r, i, a) {
    var s = t.__brushOption, o = n.toRectRange(s.range), l = Rj(e, i, a);
    P(r, function(u) {
      var c = Sxe[u];
      o[c[0]][c[1]] += l[c[0]];
    }), s.range = n.fromRectRange(Dj(o[0][0], o[1][0], o[0][1], o[1][1])), tM(e, t), gd(e, {
      isEnd: false
    });
  }
  function Dxe(n, e, t, r) {
    var i = e.__brushOption.range, a = Rj(n, t, r);
    P(i, function(s) {
      s[0] += a[0], s[1] += a[1];
    }), tM(n, e), gd(n, {
      isEnd: false
    });
  }
  function Rj(n, e, t) {
    var r = n.group, i = r.transformCoordToLocal(e, t), a = r.transformCoordToLocal(0, 0);
    return [
      i[0] - a[0],
      i[1] - a[1]
    ];
  }
  function aM(n, e, t) {
    var r = Ij(n, e);
    return r && r !== pd ? r.clipPath(t, n._transform) : Qe(t);
  }
  function Rxe(n) {
    var e = j0(n[0][0], n[1][0]), t = j0(n[0][1], n[1][1]), r = zg(n[0][0], n[1][0]), i = zg(n[0][1], n[1][1]);
    return {
      x: e,
      y: t,
      width: r - e,
      height: i - t
    };
  }
  function $xe(n, e, t) {
    if (!(!n._brushType || Exe(n, e.offsetX, e.offsetY))) {
      var r = n._zr, i = n._covers, a = rM(n, e, t);
      if (!n._dragging) for (var s = 0; s < i.length; s++) {
        var o = i[s].__brushOption;
        if (a && (a === pd || o.panelId === a.panelId) && YC[o.brushType].contain(i[s], t[0], t[1])) return;
      }
      a && r.setCursorStyle("crosshair");
    }
  }
  function MR(n) {
    var e = n.event;
    e.preventDefault && e.preventDefault();
  }
  function PR(n, e, t) {
    return n.childOfName("main").contain(e, t);
  }
  function $j(n, e, t, r) {
    var i = n._creatingCover, a = n._creatingPanel, s = n._brushOption, o;
    if (n._track.push(t.slice()), kxe(n) || i) {
      if (a && !i) {
        s.brushMode === "single" && $R(n);
        var l = Qe(s);
        l.brushType = yV(l.brushType, a), l.panelId = a === pd ? null : a.panelId, i = n._creatingCover = wj(n, l), n._covers.push(i);
      }
      if (i) {
        var u = YC[yV(n._brushType, a)], c = i.__brushOption;
        c.range = u.getCreatingRange(aM(n, i, n._track)), r && (_j(n, i), u.updateCommon(n, i)), Sj(n, i), o = {
          isEnd: r
        };
      }
    } else r && s.brushMode === "single" && s.removeOnClick && rM(n, e, t) && $R(n) && (o = {
      isEnd: r,
      removeOnClick: true
    });
    return o;
  }
  function yV(n, e) {
    return n === "auto" ? e.defaultBrushType : n;
  }
  var Nxe = {
    mousedown: function(n) {
      if (this._dragging) xV(this, n);
      else if (!n.target || !n.target.draggable) {
        MR(n);
        var e = this.group.transformCoordToLocal(n.offsetX, n.offsetY);
        this._creatingCover = null;
        var t = this._creatingPanel = rM(this, n, e);
        t && (this._dragging = true, this._track = [
          e.slice()
        ]);
      }
    },
    mousemove: function(n) {
      var e = n.offsetX, t = n.offsetY, r = this.group.transformCoordToLocal(e, t);
      if ($xe(this, n, r), this._dragging) {
        MR(n);
        var i = $j(this, n, r, false);
        i && gd(this, i);
      }
    },
    mouseup: function(n) {
      xV(this, n);
    }
  };
  function xV(n, e) {
    if (n._dragging) {
      MR(e);
      var t = e.offsetX, r = e.offsetY, i = n.group.transformCoordToLocal(t, r), a = $j(n, e, i, true);
      n._dragging = false, n._track = [], n._creatingCover = null, a && gd(n, a);
    }
  }
  function Exe(n, e, t) {
    var r = n._zr;
    return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight();
  }
  var YC = {
    lineX: bV(0),
    lineY: bV(1),
    rect: {
      createCover: function(n, e) {
        function t(r) {
          return r;
        }
        return Tj({
          toRectRange: t,
          fromRectRange: t
        }, n, e, [
          [
            "w"
          ],
          [
            "e"
          ],
          [
            "n"
          ],
          [
            "s"
          ],
          [
            "s",
            "e"
          ],
          [
            "s",
            "w"
          ],
          [
            "n",
            "e"
          ],
          [
            "n",
            "w"
          ]
        ]);
      },
      getCreatingRange: function(n) {
        var e = kj(n);
        return Dj(e[1][0], e[1][1], e[0][0], e[0][1]);
      },
      updateCoverShape: function(n, e, t, r) {
        Aj(n, e, t, r);
      },
      updateCommon: NR,
      contain: PR
    },
    polygon: {
      createCover: function(n, e) {
        var t = new tt();
        return t.add(new oa({
          name: "main",
          style: iM(e),
          silent: true
        })), t;
      },
      getCreatingRange: function(n) {
        return n;
      },
      endCreating: function(n, e) {
        e.remove(e.childAt(0)), e.add(new ia({
          name: "main",
          draggable: true,
          drift: lt(Dxe, n, e),
          ondragend: lt(gd, n, {
            isEnd: true
          })
        }));
      },
      updateCoverShape: function(n, e, t, r) {
        e.childAt(0).setShape({
          points: aM(n, e, t)
        });
      },
      updateCommon: NR,
      contain: PR
    }
  };
  function bV(n) {
    return {
      createCover: function(e, t) {
        return Tj({
          toRectRange: function(r) {
            var i = [
              r,
              [
                0,
                100
              ]
            ];
            return n && i.reverse(), i;
          },
          fromRectRange: function(r) {
            return r[n];
          }
        }, e, t, [
          [
            [
              "w"
            ],
            [
              "e"
            ]
          ],
          [
            [
              "n"
            ],
            [
              "s"
            ]
          ]
        ][n]);
      },
      getCreatingRange: function(e) {
        var t = kj(e), r = j0(t[0][n], t[1][n]), i = zg(t[0][n], t[1][n]);
        return [
          r,
          i
        ];
      },
      updateCoverShape: function(e, t, r, i) {
        var a, s = Ij(e, t);
        if (s !== pd && s.getLinearBrushOtherExtent) a = s.getLinearBrushOtherExtent(n);
        else {
          var o = e._zr;
          a = [
            0,
            [
              o.getWidth(),
              o.getHeight()
            ][1 - n]
          ];
        }
        var l = [
          r,
          a
        ];
        n && l.reverse(), Aj(e, t, l, i);
      },
      updateCommon: NR,
      contain: PR
    };
  }
  function Nj(n) {
    return n = sM(n), function(e) {
      return W8(e, n);
    };
  }
  function Ej(n, e) {
    return n = sM(n), function(t) {
      var r = e ?? t, i = r ? n.width : n.height, a = r ? n.x : n.y;
      return [
        a,
        a + (i || 0)
      ];
    };
  }
  function Mj(n, e, t) {
    var r = sM(n);
    return function(i, a) {
      return r.contain(a[0], a[1]) && !GC(i, e, t);
    };
  }
  function sM(n) {
    return vt.create(n);
  }
  var Mxe = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], Pxe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      n.prototype.init.apply(this, arguments), (this._brushController = new eM(r.getZr())).on("brush", Ae(this._onBrush, this));
    }, e.prototype.render = function(t, r, i, a) {
      if (!Lxe(t, r, a)) {
        this.axisModel = t, this.api = i, this.group.removeAll();
        var s = this._axisGroup;
        if (this._axisGroup = new tt(), this.group.add(this._axisGroup), !!t.get("show")) {
          var o = Oxe(t, r), l = o.coordinateSystem, u = t.getAreaSelectStyle(), c = u.width, h = t.axis.dim, d = l.getAxisLayout(h), f = oe({
            strokeContainThreshold: c
          }, d), p = new Zi(t, f);
          P(Mxe, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(f, u, t, o, c, i), Lx(s, this._axisGroup, t);
        }
      }
    }, e.prototype._refreshBrushController = function(t, r, i, a, s, o) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), h = vt.create({
        x: l[0],
        y: -s / 2,
        width: u,
        height: s
      });
      h.x -= c, h.width += 2 * c, this._brushController.mount({
        enableGlobalPan: true,
        rotation: t.rotation,
        x: t.position[0],
        y: t.position[1]
      }).setPanels([
        {
          panelId: "pl",
          clipPath: Nj(h),
          isTargetByCursor: Mj(h, o, a),
          getLinearBrushOtherExtent: Ej(h, 0)
        }
      ]).enableBrush({
        brushType: "lineX",
        brushStyle: r,
        removeOnClick: true
      }).updateCovers(Fxe(i));
    }, e.prototype._onBrush = function(t) {
      var r = t.areas, i = this.axisModel, a = i.axis, s = me(r, function(o) {
        return [
          a.coordToData(o.range[0], true),
          a.coordToData(o.range[1], true)
        ];
      });
      (!i.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: s
      });
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.type = "parallelAxis", e;
  }(Yn);
  function Lxe(n, e, t) {
    return t && t.type === "axisAreaSelect" && e.findComponents({
      mainType: "parallelAxis",
      query: t
    })[0] === n;
  }
  function Fxe(n) {
    var e = n.axis;
    return me(n.activeIntervals, function(t) {
      return {
        brushType: "lineX",
        panelId: "pl",
        range: [
          e.dataToCoord(t[0], true),
          e.dataToCoord(t[1], true)
        ]
      };
    });
  }
  function Oxe(n, e) {
    return e.getComponent("parallel", n.get("parallelIndex"));
  }
  var Bxe = {
    type: "axisAreaSelect",
    event: "axisAreaSelected"
  };
  function zxe(n) {
    n.registerAction(Bxe, function(e, t) {
      t.eachComponent({
        mainType: "parallelAxis",
        query: e
      }, function(r) {
        r.axis.model.setActiveIntervals(e.intervals);
      });
    }), n.registerAction("parallelAxisExpand", function(e, t) {
      t.eachComponent({
        mainType: "parallel",
        query: e
      }, function(r) {
        r.setAxisExpand(e);
      });
    });
  }
  var Vxe = {
    type: "value",
    areaSelectStyle: {
      width: 20,
      borderWidth: 1,
      borderColor: "rgba(160,197,232)",
      color: "rgba(160,197,232)",
      opacity: 0.3
    },
    realtime: true,
    z: 10
  };
  function Pj(n) {
    n.registerComponentView(lxe), n.registerComponentModel(cxe), n.registerCoordinateSystem("parallel", yxe), n.registerPreprocessor(ixe), n.registerComponentModel(RR), n.registerComponentView(Pxe), Bg(n, "parallel", RR, Vxe), zxe(n);
  }
  function Wxe(n) {
    Ct(Pj), n.registerChartView(K0e), n.registerSeriesModel(J0e), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, rxe);
  }
  var Gxe = /* @__PURE__ */ function() {
    function n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return n;
  }(), Uxe = function(n) {
    K(e, n);
    function e(t) {
      return n.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new Gxe();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.extent;
      t.moveTo(r.x1, r.y1), t.bezierCurveTo(r.cpx1, r.cpy1, r.cpx2, r.cpy2, r.x2, r.y2), r.orient === "vertical" ? (t.lineTo(r.x2 + i, r.y2), t.bezierCurveTo(r.cpx2 + i, r.cpy2, r.cpx1 + i, r.cpy1, r.x1 + i, r.y1)) : (t.lineTo(r.x2, r.y2 + i), t.bezierCurveTo(r.cpx2, r.cpy2 + i, r.cpx1, r.cpy1 + i, r.x1, r.y1 + i)), t.closePath();
    }, e.prototype.highlight = function() {
      Xl(this);
    }, e.prototype.downplay = function() {
      Yl(this);
    }, e;
  }(At), Hxe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._focusAdjacencyDisabled = false, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = this, s = t.getGraph(), o = this.group, l = t.layoutInfo, u = l.width, c = l.height, h = t.getData(), d = t.getData("edge"), f = t.get("orient");
      this._model = t, o.removeAll(), o.x = l.x, o.y = l.y, s.eachEdge(function(p) {
        var g = new Uxe(), m = rt(g);
        m.dataIndex = p.dataIndex, m.seriesIndex = t.seriesIndex, m.dataType = "edge";
        var v = p.getModel(), y = v.getModel("lineStyle"), x = y.get("curveness"), b = p.node1.getLayout(), w = p.node1.getModel(), _ = w.get("localX"), S = w.get("localY"), I = p.node2.getLayout(), C = p.node2.getModel(), T = C.get("localX"), k = C.get("localY"), D = p.getLayout(), R, N, E, A, M, $, L, F;
        g.shape.extent = Math.max(1, D.dy), g.shape.orient = f, f === "vertical" ? (R = (_ != null ? _ * u : b.x) + D.sy, N = (S != null ? S * c : b.y) + b.dy, E = (T != null ? T * u : I.x) + D.ty, A = k != null ? k * c : I.y, M = R, $ = N * (1 - x) + A * x, L = E, F = N * x + A * (1 - x)) : (R = (_ != null ? _ * u : b.x) + b.dx, N = (S != null ? S * c : b.y) + D.sy, E = T != null ? T * u : I.x, A = (k != null ? k * c : I.y) + D.ty, M = R * (1 - x) + E * x, $ = N, L = R * x + E * (1 - x), F = A), g.setShape({
          x1: R,
          y1: N,
          x2: E,
          y2: A,
          cpx1: M,
          cpy1: $,
          cpx2: L,
          cpy2: F
        }), g.useStyle(y.getItemStyle()), wV(g.style, f, p);
        var O = "" + v.get("value"), z = Hr(v, "edgeLabel");
        gi(g, z, {
          labelFetcher: {
            getFormattedLabel: function(Y, le, ve, re, ae, fe) {
              return t.getFormattedLabel(Y, le, "edge", re, Go(ae, z.normal && z.normal.get("formatter"), O), fe);
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: O
        }), g.setTextConfig({
          position: "inside"
        });
        var V = v.getModel("emphasis");
        pi(g, v, "lineStyle", function(Y) {
          var le = Y.getItemStyle();
          return wV(le, f, p), le;
        }), o.add(g), d.setItemGraphicEl(p.dataIndex, g);
        var H = V.get("focus");
        Qn(g, H === "adjacency" ? p.getAdjacentDataIndices() : H === "trajectory" ? p.getTrajectoryDataIndices() : H, V.get("blurScope"), V.get("disabled"));
      }), s.eachNode(function(p) {
        var g = p.getLayout(), m = p.getModel(), v = m.get("localX"), y = m.get("localY"), x = m.getModel("emphasis"), b = m.get([
          "itemStyle",
          "borderRadius"
        ]) || 0, w = new Vt({
          shape: {
            x: v != null ? v * u : g.x,
            y: y != null ? y * c : g.y,
            width: g.dx,
            height: g.dy,
            r: b
          },
          style: m.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        gi(w, Hr(m), {
          labelFetcher: {
            getFormattedLabel: function(S, I) {
              return t.getFormattedLabel(S, I, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), w.disableLabelAnimation = true, w.setStyle("fill", p.getVisual("color")), w.setStyle("decal", p.getVisual("style").decal), pi(w, m), o.add(w), h.setItemGraphicEl(p.dataIndex, w), rt(w).dataType = "node";
        var _ = x.get("focus");
        Qn(w, _ === "adjacency" ? p.getAdjacentDataIndices() : _ === "trajectory" ? p.getTrajectoryDataIndices() : _, x.get("blurScope"), x.get("disabled"));
      }), h.eachItemGraphicEl(function(p, g) {
        var m = h.getItemModel(g);
        m.get("draggable") && (p.drift = function(v, y) {
          a._focusAdjacencyDisabled = true, this.shape.x += v, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: t.id,
            dataIndex: h.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          a._focusAdjacencyDisabled = false;
        }, p.draggable = true, p.cursor = "move");
      }), !this._data && t.isAnimationEnabled() && o.setClipPath(Xxe(o.getBoundingRect(), t, function() {
        o.removeClipPath();
      })), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.type = "sankey", e;
  }(_n);
  function wV(n, e, t) {
    switch (n.fill) {
      case "source":
        n.fill = t.node1.getVisual("color"), n.decal = t.node1.getVisual("style").decal;
        break;
      case "target":
        n.fill = t.node2.getVisual("color"), n.decal = t.node2.getVisual("style").decal;
        break;
      case "gradient":
        var r = t.node1.getVisual("color"), i = t.node2.getVisual("color");
        Ie(r) && Ie(i) && (n.fill = new Px(0, 0, +(e === "horizontal"), +(e === "vertical"), [
          {
            color: r,
            offset: 0
          },
          {
            color: i,
            offset: 1
          }
        ]));
    }
  }
  function Xxe(n, e, t) {
    var r = new Vt({
      shape: {
        x: n.x - 10,
        y: n.y - 10,
        width: 0,
        height: n.height + 20
      }
    });
    return Un(r, {
      shape: {
        width: n.width + 20
      }
    }, e, t), r;
  }
  var Yxe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = t.edges || t.links || [], a = t.data || t.nodes || [], s = t.levels || [];
      this.levelModels = [];
      for (var o = this.levelModels, l = 0; l < s.length; l++) s[l].depth != null && s[l].depth >= 0 && (o[s[l].depth] = new on(s[l], this, r));
      var u = vj(a, i, this, true, c);
      return u.data;
      function c(h, d) {
        h.wrapMethod("getItemModel", function(f, p) {
          var g = f.parentModel, m = g.getData().getItemLayout(p);
          if (m) {
            var v = m.depth, y = g.levelModels[v];
            y && (f.parentModel = y);
          }
          return f;
        }), d.wrapMethod("getItemModel", function(f, p) {
          var g = f.parentModel, m = g.getGraph().getEdgeByIndex(p), v = m.node1.getLayout();
          if (v) {
            var y = v.depth, x = g.levelModels[y];
            x && (f.parentModel = x);
          }
          return f;
        });
      }
    }, e.prototype.setNodePosition = function(t, r) {
      var i = this.option.data || this.option.nodes, a = i[t];
      a.localX = r[0], a.localY = r[1];
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.formatTooltip = function(t, r, i) {
      function a(f) {
        return isNaN(f) || f == null;
      }
      if (i === "edge") {
        var s = this.getDataParams(t, i), o = s.data, l = s.value, u = o.source + " -- " + o.target;
        return Xr("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(t), h = c.getLayout().value, d = this.getDataParams(t, i).data.name;
        return Xr("nameValue", {
          name: d != null ? d + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, e.prototype.optionUpdated = function() {
    }, e.prototype.getDataParams = function(t, r) {
      var i = n.prototype.getDataParams.call(this, t, r);
      if (i.value == null && r === "node") {
        var a = this.getGraph().getNodeByIndex(t), s = a.getLayout().value;
        i.value = s;
      }
      return i;
    }, e.type = "series.sankey", e.defaultOption = {
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: true,
      layoutIterations: 32,
      label: {
        show: true,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: false,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, e;
  }(En);
  function qxe(n, e) {
    n.eachSeriesByType("sankey", function(t) {
      var r = t.get("nodeWidth"), i = t.get("nodeGap"), a = jxe(t, e);
      t.layoutInfo = a;
      var s = a.width, o = a.height, l = t.getGraph(), u = l.nodes, c = l.edges;
      Zxe(u);
      var h = rn(u, function(g) {
        return g.getLayout().value === 0;
      }), d = h.length !== 0 ? 0 : t.get("layoutIterations"), f = t.get("orient"), p = t.get("nodeAlign");
      Kxe(u, c, r, i, s, o, d, f, p);
    });
  }
  function jxe(n, e) {
    return Er(n.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    });
  }
  function Kxe(n, e, t, r, i, a, s, o, l) {
    Qxe(n, e, t, i, a, o, l), nbe(n, e, a, i, r, s, o), hbe(n, o);
  }
  function Zxe(n) {
    P(n, function(e) {
      var t = qu(e.outEdges, cS), r = qu(e.inEdges, cS), i = e.getValue() || 0, a = Math.max(t, r, i);
      e.setLayout({
        value: a
      }, true);
    });
  }
  function Qxe(n, e, t, r, i, a, s) {
    for (var o = [], l = [], u = [], c = [], h = 0, d = 0; d < e.length; d++) o[d] = 1;
    for (var d = 0; d < n.length; d++) l[d] = n[d].inEdges.length, l[d] === 0 && u.push(n[d]);
    for (var f = -1; u.length; ) {
      for (var p = 0; p < u.length; p++) {
        var g = u[p], m = g.hostGraph.data.getRawDataItem(g.dataIndex), v = m.depth != null && m.depth >= 0;
        v && m.depth > f && (f = m.depth), g.setLayout({
          depth: v ? m.depth : h
        }, true), a === "vertical" ? g.setLayout({
          dy: t
        }, true) : g.setLayout({
          dx: t
        }, true);
        for (var y = 0; y < g.outEdges.length; y++) {
          var x = g.outEdges[y], b = e.indexOf(x);
          o[b] = 0;
          var w = x.node2, _ = n.indexOf(w);
          --l[_] === 0 && c.indexOf(w) < 0 && c.push(w);
        }
      }
      ++h, u = c, c = [];
    }
    for (var d = 0; d < o.length; d++) if (o[d] === 1) throw new Error("Sankey is a DAG, the original data has cycle!");
    var S = f > h - 1 ? f : h - 1;
    s && s !== "left" && Jxe(n, s, a, S);
    var I = a === "vertical" ? (i - t) / S : (r - t) / S;
    tbe(n, I, a);
  }
  function Lj(n) {
    var e = n.hostGraph.data.getRawDataItem(n.dataIndex);
    return e.depth != null && e.depth >= 0;
  }
  function Jxe(n, e, t, r) {
    if (e === "right") {
      for (var i = [], a = n, s = 0; a.length; ) {
        for (var o = 0; o < a.length; o++) {
          var l = a[o];
          l.setLayout({
            skNodeHeight: s
          }, true);
          for (var u = 0; u < l.inEdges.length; u++) {
            var c = l.inEdges[u];
            i.indexOf(c.node1) < 0 && i.push(c.node1);
          }
        }
        a = i, i = [], ++s;
      }
      P(n, function(h) {
        Lj(h) || h.setLayout({
          depth: Math.max(0, r - h.getLayout().skNodeHeight)
        }, true);
      });
    } else e === "justify" && ebe(n, r);
  }
  function ebe(n, e) {
    P(n, function(t) {
      !Lj(t) && !t.outEdges.length && t.setLayout({
        depth: e
      }, true);
    });
  }
  function tbe(n, e, t) {
    P(n, function(r) {
      var i = r.getLayout().depth * e;
      t === "vertical" ? r.setLayout({
        y: i
      }, true) : r.setLayout({
        x: i
      }, true);
    });
  }
  function nbe(n, e, t, r, i, a, s) {
    var o = rbe(n, s);
    ibe(o, e, t, r, i, s), bT(o, i, t, r, s);
    for (var l = 1; a > 0; a--) l *= 0.99, abe(o, l, s), bT(o, i, t, r, s), cbe(o, l, s), bT(o, i, t, r, s);
  }
  function rbe(n, e) {
    var t = [], r = e === "vertical" ? "y" : "x", i = LD(n, function(a) {
      return a.getLayout()[r];
    });
    return i.keys.sort(function(a, s) {
      return a - s;
    }), P(i.keys, function(a) {
      t.push(i.buckets.get(a));
    }), t;
  }
  function ibe(n, e, t, r, i, a) {
    var s = 1 / 0;
    P(n, function(o) {
      var l = o.length, u = 0;
      P(o, function(h) {
        u += h.getLayout().value;
      });
      var c = a === "vertical" ? (r - (l - 1) * i) / u : (t - (l - 1) * i) / u;
      c < s && (s = c);
    }), P(n, function(o) {
      P(o, function(l, u) {
        var c = l.getLayout().value * s;
        a === "vertical" ? (l.setLayout({
          x: u
        }, true), l.setLayout({
          dx: c
        }, true)) : (l.setLayout({
          y: u
        }, true), l.setLayout({
          dy: c
        }, true));
      });
    }), P(e, function(o) {
      var l = +o.getValue() * s;
      o.setLayout({
        dy: l
      }, true);
    });
  }
  function bT(n, e, t, r, i) {
    var a = i === "vertical" ? "x" : "y";
    P(n, function(s) {
      s.sort(function(g, m) {
        return g.getLayout()[a] - m.getLayout()[a];
      });
      for (var o, l, u, c = 0, h = s.length, d = i === "vertical" ? "dx" : "dy", f = 0; f < h; f++) l = s[f], u = c - l.getLayout()[a], u > 0 && (o = l.getLayout()[a] + u, i === "vertical" ? l.setLayout({
        x: o
      }, true) : l.setLayout({
        y: o
      }, true)), c = l.getLayout()[a] + l.getLayout()[d] + e;
      var p = i === "vertical" ? r : t;
      if (u = c - e - p, u > 0) {
        o = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: o
        }, true) : l.setLayout({
          y: o
        }, true), c = o;
        for (var f = h - 2; f >= 0; --f) l = s[f], u = l.getLayout()[a] + l.getLayout()[d] + e - c, u > 0 && (o = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: o
        }, true) : l.setLayout({
          y: o
        }, true)), c = l.getLayout()[a];
      }
    });
  }
  function abe(n, e, t) {
    P(n.slice().reverse(), function(r) {
      P(r, function(i) {
        if (i.outEdges.length) {
          var a = qu(i.outEdges, sbe, t) / qu(i.outEdges, cS);
          if (isNaN(a)) {
            var s = i.outEdges.length;
            a = s ? qu(i.outEdges, obe, t) / s : 0;
          }
          if (t === "vertical") {
            var o = i.getLayout().x + (a - ac(i, t)) * e;
            i.setLayout({
              x: o
            }, true);
          } else {
            var l = i.getLayout().y + (a - ac(i, t)) * e;
            i.setLayout({
              y: l
            }, true);
          }
        }
      });
    });
  }
  function sbe(n, e) {
    return ac(n.node2, e) * n.getValue();
  }
  function obe(n, e) {
    return ac(n.node2, e);
  }
  function lbe(n, e) {
    return ac(n.node1, e) * n.getValue();
  }
  function ube(n, e) {
    return ac(n.node1, e);
  }
  function ac(n, e) {
    return e === "vertical" ? n.getLayout().x + n.getLayout().dx / 2 : n.getLayout().y + n.getLayout().dy / 2;
  }
  function cS(n) {
    return n.getValue();
  }
  function qu(n, e, t) {
    for (var r = 0, i = n.length, a = -1; ++a < i; ) {
      var s = +e(n[a], t);
      isNaN(s) || (r += s);
    }
    return r;
  }
  function cbe(n, e, t) {
    P(n, function(r) {
      P(r, function(i) {
        if (i.inEdges.length) {
          var a = qu(i.inEdges, lbe, t) / qu(i.inEdges, cS);
          if (isNaN(a)) {
            var s = i.inEdges.length;
            a = s ? qu(i.inEdges, ube, t) / s : 0;
          }
          if (t === "vertical") {
            var o = i.getLayout().x + (a - ac(i, t)) * e;
            i.setLayout({
              x: o
            }, true);
          } else {
            var l = i.getLayout().y + (a - ac(i, t)) * e;
            i.setLayout({
              y: l
            }, true);
          }
        }
      });
    });
  }
  function hbe(n, e) {
    var t = e === "vertical" ? "x" : "y";
    P(n, function(r) {
      r.outEdges.sort(function(i, a) {
        return i.node2.getLayout()[t] - a.node2.getLayout()[t];
      }), r.inEdges.sort(function(i, a) {
        return i.node1.getLayout()[t] - a.node1.getLayout()[t];
      });
    }), P(n, function(r) {
      var i = 0, a = 0;
      P(r.outEdges, function(s) {
        s.setLayout({
          sy: i
        }, true), i += s.getLayout().dy;
      }), P(r.inEdges, function(s) {
        s.setLayout({
          ty: a
        }, true), a += s.getLayout().dy;
      });
    });
  }
  function dbe(n) {
    n.eachSeriesByType("sankey", function(e) {
      var t = e.getGraph(), r = t.nodes, i = t.edges;
      if (r.length) {
        var a = 1 / 0, s = -1 / 0;
        P(r, function(o) {
          var l = o.getLayout().value;
          l < a && (a = l), l > s && (s = l);
        }), P(r, function(o) {
          var l = new Gr({
            type: "color",
            mappingMethod: "linear",
            dataExtent: [
              a,
              s
            ],
            visual: e.get("color")
          }), u = l.mapValueToVisual(o.getLayout().value), c = o.getModel().get([
            "itemStyle",
            "color"
          ]);
          c != null ? (o.setVisual("color", c), o.setVisual("style", {
            fill: c
          })) : (o.setVisual("color", u), o.setVisual("style", {
            fill: u
          }));
        });
      }
      i.length && P(i, function(o) {
        var l = o.getModel().get("lineStyle");
        o.setVisual("style", l);
      });
    });
  }
  function fbe(n) {
    n.registerChartView(Hxe), n.registerSeriesModel(Yxe), n.registerLayout(qxe), n.registerVisual(dbe), n.registerAction({
      type: "dragNode",
      event: "dragnode",
      update: "update"
    }, function(e, t) {
      t.eachComponent({
        mainType: "series",
        subType: "sankey",
        query: e
      }, function(r) {
        r.setNodePosition(e.dataIndex, [
          e.localX,
          e.localY
        ]);
      });
    });
  }
  var Fj = function() {
    function n() {
    }
    return n.prototype._hasEncodeRule = function(e) {
      var t = this.getEncode();
      return t && t.get(e) != null;
    }, n.prototype.getInitialData = function(e, t) {
      var r, i = t.getComponent("xAxis", this.get("xAxisIndex")), a = t.getComponent("yAxis", this.get("yAxisIndex")), s = i.get("type"), o = a.get("type"), l;
      s === "category" ? (e.layout = "horizontal", r = i.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : o === "category" ? (e.layout = "vertical", r = a.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : e.layout = e.layout || "horizontal";
      var u = [
        "x",
        "y"
      ], c = e.layout === "horizontal" ? 0 : 1, h = this._baseAxisDim = u[c], d = u[1 - c], f = [
        i,
        a
      ], p = f[c].get("type"), g = f[1 - c].get("type"), m = e.data;
      if (m && l) {
        var v = [];
        P(m, function(b, w) {
          var _;
          de(b) ? (_ = b.slice(), b.unshift(w)) : de(b.value) ? (_ = oe({}, b), _.value = _.value.slice(), b.value.unshift(w)) : _ = b, v.push(_);
        }), e.data = v;
      }
      var y = this.defaultValueDimensions, x = [
        {
          name: h,
          type: J_(p),
          ordinalMeta: r,
          otherDims: {
            tooltip: false,
            itemName: 0
          },
          dimsDef: [
            "base"
          ]
        },
        {
          name: d,
          type: J_(g),
          dimsDef: y.slice()
        }
      ];
      return km(this, {
        coordDimensions: x,
        dimensionsCount: y.length + 1,
        encodeDefaulter: lt(pX, x, this)
      });
    }, n.prototype.getBaseAxis = function() {
      var e = this._baseAxisDim;
      return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis;
    }, n;
  }(), Oj = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [
        {
          name: "min",
          defaultTooltip: true
        },
        {
          name: "Q1",
          defaultTooltip: true
        },
        {
          name: "median",
          defaultTooltip: true
        },
        {
          name: "Q3",
          defaultTooltip: true
        },
        {
          name: "max",
          defaultTooltip: true
        }
      ], t.visualDrawType = "stroke", t;
    }
    return e.type = "series.boxplot", e.dependencies = [
      "xAxis",
      "yAxis",
      "grid"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      boxWidth: [
        7,
        50
      ],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: true,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, e;
  }(En);
  br(Oj, Fj, true);
  var pbe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), s = this.group, o = this._data;
      this._data || s.removeAll();
      var l = t.get("layout") === "horizontal" ? 1 : 0;
      a.diff(o).add(function(u) {
        if (a.hasValue(u)) {
          var c = a.getItemLayout(u), h = _V(c, a, u, l, true);
          a.setItemGraphicEl(u, h), s.add(h);
        }
      }).update(function(u, c) {
        var h = o.getItemGraphicEl(c);
        if (!a.hasValue(u)) {
          s.remove(h);
          return;
        }
        var d = a.getItemLayout(u);
        h ? (ro(h), Bj(d, h, a, u)) : h = _V(d, a, u, l), s.add(h), a.setItemGraphicEl(u, h);
      }).remove(function(u) {
        var c = o.getItemGraphicEl(u);
        c && s.remove(c);
      }).execute(), this._data = a;
    }, e.prototype.remove = function(t) {
      var r = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(a) {
        a && r.remove(a);
      });
    }, e.type = "boxplot", e;
  }(_n), gbe = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), mbe = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "boxplotBoxPath", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new gbe();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points, a = 0;
      for (t.moveTo(i[a][0], i[a][1]), a++; a < 4; a++) t.lineTo(i[a][0], i[a][1]);
      for (t.closePath(); a < i.length; a++) t.moveTo(i[a][0], i[a][1]), a++, t.lineTo(i[a][0], i[a][1]);
    }, e;
  }(At);
  function _V(n, e, t, r, i) {
    var a = n.ends, s = new mbe({
      shape: {
        points: i ? vbe(a, r, n) : a
      }
    });
    return Bj(n, s, e, t, i), s;
  }
  function Bj(n, e, t, r, i) {
    var a = t.hostModel, s = Ld[i ? "initProps" : "updateProps"];
    s(e, {
      shape: {
        points: n.ends
      }
    }, a, r), e.useStyle(t.getItemVisual(r, "style")), e.style.strokeNoScale = true, e.z2 = 100;
    var o = t.getItemModel(r), l = o.getModel("emphasis");
    pi(e, o), Qn(e, l.get("focus"), l.get("blurScope"), l.get("disabled"));
  }
  function vbe(n, e, t) {
    return me(n, function(r) {
      return r = r.slice(), r[e] = t.initBaseline, r;
    });
  }
  var f0 = P;
  function ybe(n) {
    var e = xbe(n);
    f0(e, function(t) {
      var r = t.seriesModels;
      r.length && (bbe(t), f0(r, function(i, a) {
        wbe(i, t.boxOffsetList[a], t.boxWidthList[a]);
      }));
    });
  }
  function xbe(n) {
    var e = [], t = [];
    return n.eachSeriesByType("boxplot", function(r) {
      var i = r.getBaseAxis(), a = bt(t, i);
      a < 0 && (a = t.length, t[a] = i, e[a] = {
        axis: i,
        seriesModels: []
      }), e[a].seriesModels.push(r);
    }), e;
  }
  function bbe(n) {
    var e = n.axis, t = n.seriesModels, r = t.length, i = n.boxWidthList = [], a = n.boxOffsetList = [], s = [], o;
    if (e.type === "category") o = e.getBandWidth();
    else {
      var l = 0;
      f0(t, function(p) {
        l = Math.max(l, p.getData().count());
      });
      var u = e.getExtent();
      o = Math.abs(u[1] - u[0]) / l;
    }
    f0(t, function(p) {
      var g = p.get("boxWidth");
      de(g) || (g = [
        g,
        g
      ]), s.push([
        _e(g[0], o) || 0,
        _e(g[1], o) || 0
      ]);
    });
    var c = o * 0.8 - 2, h = c / r * 0.3, d = (c - h * (r - 1)) / r, f = d / 2 - c / 2;
    f0(t, function(p, g) {
      a.push(f), f += h + d, i.push(Math.min(Math.max(d, s[g][0]), s[g][1]));
    });
  }
  function wbe(n, e, t) {
    var r = n.coordinateSystem, i = n.getData(), a = t / 2, s = n.get("layout") === "horizontal" ? 0 : 1, o = 1 - s, l = [
      "x",
      "y"
    ], u = i.mapDimension(l[s]), c = i.mapDimensionsAll(l[o]);
    if (u == null || c.length < 5) return;
    for (var h = 0; h < i.count(); h++) {
      var d = i.get(u, h), f = x(d, c[2], h), p = x(d, c[0], h), g = x(d, c[1], h), m = x(d, c[3], h), v = x(d, c[4], h), y = [];
      b(y, g, false), b(y, m, true), y.push(p, g, v, m), w(y, p), w(y, v), w(y, f), i.setItemLayout(h, {
        initBaseline: f[o],
        ends: y
      });
    }
    function x(_, S, I) {
      var C = i.get(S, I), T = [];
      T[s] = _, T[o] = C;
      var k;
      return isNaN(_) || isNaN(C) ? k = [
        NaN,
        NaN
      ] : (k = r.dataToPoint(T), k[s] += e), k;
    }
    function b(_, S, I) {
      var C = S.slice(), T = S.slice();
      C[s] += a, T[s] -= a, I ? _.push(C, T) : _.push(T, C);
    }
    function w(_, S) {
      var I = S.slice(), C = S.slice();
      I[s] -= a, C[s] += a, _.push(I, C);
    }
  }
  function _be(n, e) {
    e = e || {};
    for (var t = [], r = [], i = e.boundIQR, a = i === "none" || i === 0, s = 0; s < n.length; s++) {
      var o = vs(n[s].slice()), l = j2(o, 0.25), u = j2(o, 0.5), c = j2(o, 0.75), h = o[0], d = o[o.length - 1], f = (i ?? 1.5) * (c - l), p = a ? h : Math.max(h, l - f), g = a ? d : Math.min(d, c + f), m = e.itemNameFormatter, v = Xe(m) ? m({
        value: s
      }) : Ie(m) ? m.replace("{value}", s + "") : s + "";
      t.push([
        v,
        p,
        l,
        u,
        c,
        g
      ]);
      for (var y = 0; y < o.length; y++) {
        var x = o[y];
        if (x < p || x > g) {
          var b = [
            v,
            x
          ];
          r.push(b);
        }
      }
    }
    return {
      boxData: t,
      outliers: r
    };
  }
  var Sbe = {
    type: "echarts:boxplot",
    transform: function(e) {
      var t = e.upstream;
      if (t.sourceFormat !== Pi) {
        var r = "";
        nn(r);
      }
      var i = _be(t.getRawData(), e.config);
      return [
        {
          dimensions: [
            "ItemName",
            "Low",
            "Q1",
            "Q2",
            "Q3",
            "High"
          ],
          data: i.boxData
        },
        {
          data: i.outliers
        }
      ];
    }
  };
  function Cbe(n) {
    n.registerSeriesModel(Oj), n.registerChartView(pbe), n.registerLayout(ybe), n.registerTransform(Sbe);
  }
  var Ibe = [
    "itemStyle",
    "borderColor"
  ], kbe = [
    "itemStyle",
    "borderColor0"
  ], Tbe = [
    "itemStyle",
    "borderColorDoji"
  ], Abe = [
    "itemStyle",
    "color"
  ], Dbe = [
    "itemStyle",
    "color0"
  ];
  function oM(n, e) {
    return e.get(n > 0 ? Abe : Dbe);
  }
  function lM(n, e) {
    return e.get(n === 0 ? Tbe : n > 0 ? Ibe : kbe);
  }
  var Rbe = {
    seriesType: "candlestick",
    plan: _m(),
    performRawSeries: true,
    reset: function(n, e) {
      if (!e.isSeriesFiltered(n)) {
        var t = n.pipelineContext.large;
        return !t && {
          progress: function(r, i) {
            for (var a; (a = r.next()) != null; ) {
              var s = i.getItemModel(a), o = i.getItemLayout(a).sign, l = s.getItemStyle();
              l.fill = oM(o, s), l.stroke = lM(o, s) || l.fill;
              var u = i.ensureUniqueItemVisual(a, "style");
              oe(u, l);
            }
          }
        };
      }
    }
  }, $be = [
    "color",
    "borderColor"
  ], Nbe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t);
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this._clear(), this._updateDrawMode(t);
    }, e.prototype.incrementalRender = function(t, r, i, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, r) : this._incrementalRenderNormal(t, r);
    }, e.prototype.eachRendered = function(t) {
      gc(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var r = t.pipelineContext.large;
      (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear());
    }, e.prototype._renderNormal = function(t) {
      var r = t.getData(), i = this._data, a = this.group, s = r.getLayout("isSimpleBox"), o = t.get("clip", true), l = t.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), r.diff(i).add(function(c) {
        if (r.hasValue(c)) {
          var h = r.getItemLayout(c);
          if (o && SV(u, h)) return;
          var d = wT(h, c, true);
          Un(d, {
            shape: {
              points: h.ends
            }
          }, t, c), _T(d, r, c, s), a.add(d), r.setItemGraphicEl(c, d);
        }
      }).update(function(c, h) {
        var d = i.getItemGraphicEl(h);
        if (!r.hasValue(c)) {
          a.remove(d);
          return;
        }
        var f = r.getItemLayout(c);
        if (o && SV(u, f)) {
          a.remove(d);
          return;
        }
        d ? (Kt(d, {
          shape: {
            points: f.ends
          }
        }, t, c), ro(d)) : d = wT(f), _T(d, r, c, s), a.add(d), r.setItemGraphicEl(c, d);
      }).remove(function(c) {
        var h = i.getItemGraphicEl(c);
        h && a.remove(h);
      }).execute(), this._data = r;
    }, e.prototype._renderLarge = function(t) {
      this._clear(), CV(t, this.group);
      var r = t.get("clip", true) ? Ux(t.coordinateSystem, false, t) : null;
      r ? this.group.setClipPath(r) : this.group.removeClipPath();
    }, e.prototype._incrementalRenderNormal = function(t, r) {
      for (var i = r.getData(), a = i.getLayout("isSimpleBox"), s; (s = t.next()) != null; ) {
        var o = i.getItemLayout(s), l = wT(o);
        _T(l, i, s, a), l.incremental = true, this.group.add(l), this._progressiveEls.push(l);
      }
    }, e.prototype._incrementalRenderLarge = function(t, r) {
      CV(r, this.group, this._progressiveEls, true);
    }, e.prototype.remove = function(t) {
      this._clear();
    }, e.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "candlestick", e;
  }(_n), Ebe = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), Mbe = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "normalCandlestickBox", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new Ebe();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.points;
      this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1]));
    }, e;
  }(At);
  function wT(n, e, t) {
    var r = n.ends;
    return new Mbe({
      shape: {
        points: t ? Pbe(r, n) : r
      },
      z2: 100
    });
  }
  function SV(n, e) {
    for (var t = true, r = 0; r < e.ends.length; r++) if (n.contain(e.ends[r][0], e.ends[r][1])) {
      t = false;
      break;
    }
    return t;
  }
  function _T(n, e, t, r) {
    var i = e.getItemModel(t);
    n.useStyle(e.getItemVisual(t, "style")), n.style.strokeNoScale = true, n.__simpleBox = r, pi(n, i);
    var a = e.getItemLayout(t).sign;
    P(n.states, function(o, l) {
      var u = i.getModel(l), c = oM(a, u), h = lM(a, u) || c, d = o.style || (o.style = {});
      c && (d.fill = c), h && (d.stroke = h);
    });
    var s = i.getModel("emphasis");
    Qn(n, s.get("focus"), s.get("blurScope"), s.get("disabled"));
  }
  function Pbe(n, e) {
    return me(n, function(t) {
      return t = t.slice(), t[1] = e.initBaseline, t;
    });
  }
  var Lbe = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), ST = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r.type = "largeCandlestickBox", r;
    }
    return e.prototype.getDefaultShape = function() {
      return new Lbe();
    }, e.prototype.buildPath = function(t, r) {
      for (var i = r.points, a = 0; a < i.length; ) if (this.__sign === i[a++]) {
        var s = i[a++];
        t.moveTo(s, i[a++]), t.lineTo(s, i[a++]);
      } else a += 3;
    }, e;
  }(At);
  function CV(n, e, t, r) {
    var i = n.getData(), a = i.getLayout("largePoints"), s = new ST({
      shape: {
        points: a
      },
      __sign: 1,
      ignoreCoarsePointer: true
    });
    e.add(s);
    var o = new ST({
      shape: {
        points: a
      },
      __sign: -1,
      ignoreCoarsePointer: true
    });
    e.add(o);
    var l = new ST({
      shape: {
        points: a
      },
      __sign: 0,
      ignoreCoarsePointer: true
    });
    e.add(l), CT(1, s, n), CT(-1, o, n), CT(0, l, n), r && (s.incremental = true, o.incremental = true), t && t.push(s, o);
  }
  function CT(n, e, t, r) {
    var i = lM(n, t) || oM(n, t), a = t.getModel("itemStyle").getItemStyle($be);
    e.useStyle(a), e.style.fill = null, e.style.stroke = i;
  }
  var zj = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [
        {
          name: "open",
          defaultTooltip: true
        },
        {
          name: "close",
          defaultTooltip: true
        },
        {
          name: "lowest",
          defaultTooltip: true
        },
        {
          name: "highest",
          defaultTooltip: true
        }
      ], t;
    }
    return e.prototype.getShadowDim = function() {
      return "open";
    }, e.prototype.brushSelector = function(t, r, i) {
      var a = r.getItemLayout(t);
      return a && i.rect(a.brushRect);
    }, e.type = "series.candlestick", e.dependencies = [
      "xAxis",
      "yAxis",
      "grid"
    ], e.defaultOption = {
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      layout: null,
      clip: true,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: true,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, e;
  }(En);
  br(zj, Fj, true);
  function Fbe(n) {
    !n || !de(n.series) || P(n.series, function(e) {
      Ze(e) && e.type === "k" && (e.type = "candlestick");
    });
  }
  var Obe = {
    seriesType: "candlestick",
    plan: _m(),
    reset: function(n) {
      var e = n.coordinateSystem, t = n.getData(), r = Bbe(n, t), i = 0, a = 1, s = [
        "x",
        "y"
      ], o = t.getDimensionIndex(t.mapDimension(s[i])), l = me(t.mapDimensionsAll(s[a]), t.getDimensionIndex, t), u = l[0], c = l[1], h = l[2], d = l[3];
      if (t.setLayout({
        candleWidth: r,
        isSimpleBox: r <= 1.3
      }), o < 0 || l.length < 4) return;
      return {
        progress: n.pipelineContext.large ? p : f
      };
      function f(g, m) {
        for (var v, y = m.getStore(); (v = g.next()) != null; ) {
          var x = y.get(o, v), b = y.get(u, v), w = y.get(c, v), _ = y.get(h, v), S = y.get(d, v), I = Math.min(b, w), C = Math.max(b, w), T = M(I, x), k = M(C, x), D = M(_, x), R = M(S, x), N = [];
          $(N, k, 0), $(N, T, 1), N.push(F(R), F(k), F(D), F(T));
          var E = m.getItemModel(v), A = !!E.get([
            "itemStyle",
            "borderColorDoji"
          ]);
          m.setItemLayout(v, {
            sign: IV(y, v, b, w, c, A),
            initBaseline: b > w ? k[a] : T[a],
            ends: N,
            brushRect: L(_, S, x)
          });
        }
        function M(O, z) {
          var V = [];
          return V[i] = z, V[a] = O, isNaN(z) || isNaN(O) ? [
            NaN,
            NaN
          ] : e.dataToPoint(V);
        }
        function $(O, z, V) {
          var H = z.slice(), Y = z.slice();
          H[i] = i_(H[i] + r / 2, 1, false), Y[i] = i_(Y[i] - r / 2, 1, true), V ? O.push(H, Y) : O.push(Y, H);
        }
        function L(O, z, V) {
          var H = M(O, V), Y = M(z, V);
          return H[i] -= r / 2, Y[i] -= r / 2, {
            x: H[0],
            y: H[1],
            width: r,
            height: Y[1] - H[1]
          };
        }
        function F(O) {
          return O[i] = i_(O[i], 1), O;
        }
      }
      function p(g, m) {
        for (var v = zo(g.count * 4), y = 0, x, b = [], w = [], _, S = m.getStore(), I = !!n.get([
          "itemStyle",
          "borderColorDoji"
        ]); (_ = g.next()) != null; ) {
          var C = S.get(o, _), T = S.get(u, _), k = S.get(c, _), D = S.get(h, _), R = S.get(d, _);
          if (isNaN(C) || isNaN(D) || isNaN(R)) {
            v[y++] = NaN, y += 3;
            continue;
          }
          v[y++] = IV(S, _, T, k, c, I), b[i] = C, b[a] = D, x = e.dataToPoint(b, null, w), v[y++] = x ? x[0] : NaN, v[y++] = x ? x[1] : NaN, b[a] = R, x = e.dataToPoint(b, null, w), v[y++] = x ? x[1] : NaN;
        }
        m.setLayout("largePoints", v);
      }
    }
  };
  function IV(n, e, t, r, i, a) {
    var s;
    return t > r ? s = -1 : t < r ? s = 1 : s = a ? 0 : e > 0 ? n.get(i, e - 1) <= r ? 1 : -1 : 1, s;
  }
  function Bbe(n, e) {
    var t = n.getBaseAxis(), r, i = t.type === "category" ? t.getBandWidth() : (r = t.getExtent(), Math.abs(r[1] - r[0]) / e.count()), a = _e(it(n.get("barMaxWidth"), i), i), s = _e(it(n.get("barMinWidth"), 1), i), o = n.get("barWidth");
    return o != null ? _e(o, i) : Math.max(Math.min(i / 2, a), s);
  }
  function zbe(n) {
    n.registerChartView(Nbe), n.registerSeriesModel(zj), n.registerPreprocessor(Fbe), n.registerVisual(Rbe), n.registerLayout(Obe);
  }
  function kV(n, e) {
    var t = e.rippleEffectColor || e.color;
    n.eachChild(function(r) {
      r.attr({
        z: e.z,
        zlevel: e.zlevel,
        style: {
          stroke: e.brushType === "stroke" ? t : null,
          fill: e.brushType === "fill" ? t : null
        }
      });
    });
  }
  var Vbe = function(n) {
    K(e, n);
    function e(t, r) {
      var i = n.call(this) || this, a = new Wx(t, r), s = new tt();
      return i.add(a), i.add(s), i.updateData(t, r), i;
    }
    return e.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, e.prototype.startEffectAnimation = function(t) {
      for (var r = t.symbolType, i = t.color, a = t.rippleNumber, s = this.childAt(1), o = 0; o < a; o++) {
        var l = xr(r, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: true
          },
          z2: 99,
          silent: true,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -o / a * t.period + t.effectOffset;
        l.animate("", true).when(t.period, {
          scaleX: t.rippleScale / 2,
          scaleY: t.rippleScale / 2
        }).delay(u).start(), l.animateStyle(true).when(t.period, {
          opacity: 0
        }).delay(u).start(), s.add(l);
      }
      kV(s, t);
    }, e.prototype.updateEffectAnimation = function(t) {
      for (var r = this._effectCfg, i = this.childAt(1), a = [
        "symbolType",
        "period",
        "rippleScale",
        "rippleNumber"
      ], s = 0; s < a.length; s++) {
        var o = a[s];
        if (r[o] !== t[o]) {
          this.stopEffectAnimation(), this.startEffectAnimation(t);
          return;
        }
      }
      kV(i, t);
    }, e.prototype.highlight = function() {
      Xl(this);
    }, e.prototype.downplay = function() {
      Yl(this);
    }, e.prototype.getSymbolType = function() {
      var t = this.childAt(0);
      return t && t.getSymbolType();
    }, e.prototype.updateData = function(t, r) {
      var i = this, a = t.hostModel;
      this.childAt(0).updateData(t, r);
      var s = this.childAt(1), o = t.getItemModel(r), l = t.getItemVisual(r, "symbol"), u = Cm(t.getItemVisual(r, "symbolSize")), c = t.getItemVisual(r, "style"), h = c && c.fill, d = o.getModel("emphasis");
      s.setScale(u), s.traverse(function(m) {
        m.setStyle("fill", h);
      });
      var f = Fd(t.getItemVisual(r, "symbolOffset"), u);
      f && (s.x = f[0], s.y = f[1]);
      var p = t.getItemVisual(r, "symbolRotate");
      s.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = a.get("showEffectOn"), g.rippleScale = o.get([
        "rippleEffect",
        "scale"
      ]), g.brushType = o.get([
        "rippleEffect",
        "brushType"
      ]), g.period = o.get([
        "rippleEffect",
        "period"
      ]) * 1e3, g.effectOffset = r / t.count(), g.z = a.getShallow("z") || 0, g.zlevel = a.getShallow("zlevel") || 0, g.symbolType = l, g.color = h, g.rippleEffectColor = o.get([
        "rippleEffect",
        "color"
      ]), g.rippleNumber = o.get([
        "rippleEffect",
        "number"
      ]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(m) {
        m === "emphasis" ? g.showEffectOn !== "render" && i.startEffectAnimation(g) : m === "normal" && g.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = g, Qn(this, d.get("focus"), d.get("blurScope"), d.get("disabled"));
    }, e.prototype.fadeOut = function(t) {
      t && t();
    }, e;
  }(tt), Wbe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._symbolDraw = new Gx(Vbe);
    }, e.prototype.render = function(t, r, i) {
      var a = t.getData(), s = this._symbolDraw;
      s.updateData(a, {
        clipShape: this._getClipShape(t)
      }), this.group.add(s.group);
    }, e.prototype._getClipShape = function(t) {
      var r = t.coordinateSystem, i = r && r.getArea && r.getArea();
      return t.get("clip", true) ? i : null;
    }, e.prototype.updateTransform = function(t, r, i) {
      var a = t.getData();
      this.group.dirty();
      var s = Hx("").reset(t, r, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, e.prototype._updateGroupTransform = function(t) {
      var r = t.coordinateSystem;
      r && r.getRoamTransform && (this.group.transform = uoe(r.getRoamTransform()), this.group.decomposeTransform());
    }, e.prototype.remove = function(t, r) {
      this._symbolDraw && this._symbolDraw.remove(true);
    }, e.type = "effectScatter", e;
  }(_n), Gbe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return au(null, this, {
        useEncodeDefaulter: true
      });
    }, e.prototype.brushSelector = function(t, r, i) {
      return i.point(r.getItemLayout(t));
    }, e.type = "series.effectScatter", e.dependencies = [
      "grid",
      "polar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      effectType: "ripple",
      progressive: 0,
      showEffectOn: "render",
      clip: true,
      rippleEffect: {
        period: 4,
        scale: 2.5,
        brushType: "fill",
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      symbolSize: 10
    }, e;
  }(En);
  function Ube(n) {
    n.registerChartView(Wbe), n.registerSeriesModel(Gbe), n.registerLayout(Hx("effectScatter"));
  }
  var Vj = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      return a.add(a.createLine(t, r, i)), a._updateEffectSymbol(t, r), a;
    }
    return e.prototype.createLine = function(t, r, i) {
      return new QE(t, r, i);
    }, e.prototype._updateEffectSymbol = function(t, r) {
      var i = t.getItemModel(r), a = i.getModel("effect"), s = a.get("symbolSize"), o = a.get("symbol");
      de(s) || (s = [
        s,
        s
      ]);
      var l = t.getItemVisual(r, "style"), u = a.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== o && (this.remove(c), c = xr(o, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = true, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(a.getItemStyle([
        "color"
      ])), c.scaleX = s[0], c.scaleY = s[1], c.setColor(u), this._symbolType = o, this._symbolScale = s, this._updateEffectAnimation(t, a, r));
    }, e.prototype._updateEffectAnimation = function(t, r, i) {
      var a = this.childAt(1);
      if (a) {
        var s = t.getItemLayout(i), o = r.get("period") * 1e3, l = r.get("loop"), u = r.get("roundTrip"), c = r.get("constantSpeed"), h = ni(r.get("delay"), function(f) {
          return f / t.count() * o / 3;
        });
        if (a.ignore = true, this._updateAnimationPoints(a, s), c > 0 && (o = this._getLineLength(a) / c * 1e3), o !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var d = void 0;
          Xe(h) ? d = h(i) : d = h, a.__t > 0 && (d = -o * a.__t), this._animateSymbol(a, o, d, l, u);
        }
        this._period = o, this._loop = l, this._roundTrip = u;
      }
    }, e.prototype._animateSymbol = function(t, r, i, a, s) {
      if (r > 0) {
        t.__t = 0;
        var o = this, l = t.animate("", a).when(s ? r * 2 : r, {
          __t: s ? 2 : 1
        }).delay(i).during(function() {
          o._updateSymbolPosition(t);
        });
        a || l.done(function() {
          o.remove(t);
        }), l.start();
      }
    }, e.prototype._getLineLength = function(t) {
      return Nu(t.__p1, t.__cp1) + Nu(t.__cp1, t.__p2);
    }, e.prototype._updateAnimationPoints = function(t, r) {
      t.__p1 = r[0], t.__p2 = r[1], t.__cp1 = r[2] || [
        (r[0][0] + r[1][0]) / 2,
        (r[0][1] + r[1][1]) / 2
      ];
    }, e.prototype.updateData = function(t, r, i) {
      this.childAt(0).updateData(t, r, i), this._updateEffectSymbol(t, r);
    }, e.prototype._updateSymbolPosition = function(t) {
      var r = t.__p1, i = t.__p2, a = t.__cp1, s = t.__t < 1 ? t.__t : 2 - t.__t, o = [
        t.x,
        t.y
      ], l = o.slice(), u = Jr, c = wD;
      o[0] = u(r[0], a[0], i[0], s), o[1] = u(r[1], a[1], i[1], s);
      var h = t.__t < 1 ? c(r[0], a[0], i[0], s) : c(i[0], a[0], r[0], 1 - s), d = t.__t < 1 ? c(r[1], a[1], i[1], s) : c(i[1], a[1], r[1], 1 - s);
      t.rotation = -Math.atan2(d, h) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = Nu(l, o) * 1.05, s === 1 && (o[0] = l[0] + (o[0] - l[0]) / 2, o[1] = l[1] + (o[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * Nu(r, o) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = false, t.x = o[0], t.y = o[1];
    }, e.prototype.updateLayout = function(t, r) {
      this.childAt(0).updateLayout(t, r);
      var i = t.getItemModel(r).getModel("effect");
      this._updateEffectAnimation(t, i, r);
    }, e;
  }(tt), Wj = function(n) {
    K(e, n);
    function e(t, r, i) {
      var a = n.call(this) || this;
      return a._createPolyline(t, r, i), a;
    }
    return e.prototype._createPolyline = function(t, r, i) {
      var a = t.getItemLayout(r), s = new oa({
        shape: {
          points: a
        }
      });
      this.add(s), this._updateCommonStl(t, r, i);
    }, e.prototype.updateData = function(t, r, i) {
      var a = t.hostModel, s = this.childAt(0), o = {
        shape: {
          points: t.getItemLayout(r)
        }
      };
      Kt(s, o, a, r), this._updateCommonStl(t, r, i);
    }, e.prototype._updateCommonStl = function(t, r, i) {
      var a = this.childAt(0), s = t.getItemModel(r), o = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || t.hasItemOption) {
        var h = s.getModel("emphasis");
        o = h.getModel("lineStyle").getLineStyle(), c = h.get("disabled"), l = h.get("focus"), u = h.get("blurScope");
      }
      a.useStyle(t.getItemVisual(r, "style")), a.style.fill = null, a.style.strokeNoScale = true;
      var d = a.ensureState("emphasis");
      d.style = o, Qn(this, l, u, c);
    }, e.prototype.updateLayout = function(t, r) {
      var i = this.childAt(0);
      i.setShape("points", t.getItemLayout(r));
    }, e;
  }(tt), Hbe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t._lastFrame = 0, t._lastFramePercent = 0, t;
    }
    return e.prototype.createLine = function(t, r, i) {
      return new Wj(t, r, i);
    }, e.prototype._updateAnimationPoints = function(t, r) {
      this._points = r;
      for (var i = [
        0
      ], a = 0, s = 1; s < r.length; s++) {
        var o = r[s - 1], l = r[s];
        a += Nu(o, l), i.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var s = 0; s < i.length; s++) i[s] /= a;
      this._offsets = i, this._length = a;
    }, e.prototype._getLineLength = function() {
      return this._length;
    }, e.prototype._updateSymbolPosition = function(t) {
      var r = t.__t < 1 ? t.__t : 2 - t.__t, i = this._points, a = this._offsets, s = i.length;
      if (a) {
        var o = this._lastFrame, l;
        if (r < this._lastFramePercent) {
          var u = Math.min(o + 1, s - 1);
          for (l = u; l >= 0 && !(a[l] <= r); l--) ;
          l = Math.min(l, s - 2);
        } else {
          for (l = o; l < s && !(a[l] > r); l++) ;
          l = Math.min(l - 1, s - 2);
        }
        var c = (r - a[l]) / (a[l + 1] - a[l]), h = i[l], d = i[l + 1];
        t.x = h[0] * (1 - c) + c * d[0], t.y = h[1] * (1 - c) + c * d[1];
        var f = t.__t < 1 ? d[0] - h[0] : h[0] - d[0], p = t.__t < 1 ? d[1] - h[1] : h[1] - d[1];
        t.rotation = -Math.atan2(p, f) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = r, t.ignore = false;
      }
    }, e;
  }(Vj), Xbe = /* @__PURE__ */ function() {
    function n() {
      this.polyline = false, this.curveness = 0, this.segs = [];
    }
    return n;
  }(), Ybe = function(n) {
    K(e, n);
    function e(t) {
      var r = n.call(this, t) || this;
      return r._off = 0, r.hoverDataIdx = -1, r;
    }
    return e.prototype.reset = function() {
      this.notClear = false, this._off = 0;
    }, e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new Xbe();
    }, e.prototype.buildPath = function(t, r) {
      var i = r.segs, a = r.curveness, s;
      if (r.polyline) for (s = this._off; s < i.length; ) {
        var o = i[s++];
        if (o > 0) {
          t.moveTo(i[s++], i[s++]);
          for (var l = 1; l < o; l++) t.lineTo(i[s++], i[s++]);
        }
      }
      else for (s = this._off; s < i.length; ) {
        var u = i[s++], c = i[s++], h = i[s++], d = i[s++];
        if (t.moveTo(u, c), a > 0) {
          var f = (u + h) / 2 - (c - d) * a, p = (c + d) / 2 - (h - u) * a;
          t.quadraticCurveTo(f, p, h, d);
        } else t.lineTo(h, d);
      }
      this.incremental && (this._off = s, this.notClear = true);
    }, e.prototype.findDataIndex = function(t, r) {
      var i = this.shape, a = i.segs, s = i.curveness, o = this.style.lineWidth;
      if (i.polyline) for (var l = 0, u = 0; u < a.length; ) {
        var c = a[u++];
        if (c > 0) for (var h = a[u++], d = a[u++], f = 1; f < c; f++) {
          var p = a[u++], g = a[u++];
          if (Au(h, d, p, g, o, t, r)) return l;
        }
        l++;
      }
      else for (var l = 0, u = 0; u < a.length; ) {
        var h = a[u++], d = a[u++], p = a[u++], g = a[u++];
        if (s > 0) {
          var m = (h + p) / 2 - (d - g) * s, v = (d + g) / 2 - (p - h) * s;
          if (p8(h, d, m, v, p, g, o, t, r)) return l;
        } else if (Au(h, d, p, g, o, t, r)) return l;
        l++;
      }
      return -1;
    }, e.prototype.contain = function(t, r) {
      var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect();
      if (t = i[0], r = i[1], a.contain(t, r)) {
        var s = this.hoverDataIdx = this.findDataIndex(t, r);
        return s >= 0;
      }
      return this.hoverDataIdx = -1, false;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var r = this.shape, i = r.segs, a = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], h = i[u++];
          a = Math.min(c, a), o = Math.max(c, o), s = Math.min(h, s), l = Math.max(h, l);
        }
        t = this._rect = new vt(a, s, o, l);
      }
      return t;
    }, e;
  }(At), qbe = function() {
    function n() {
      this.group = new tt();
    }
    return n.prototype.updateData = function(e) {
      this._clear();
      var t = this._create();
      t.setShape({
        segs: e.getLayout("linesPoints")
      }), this._setCommon(t, e);
    }, n.prototype.incrementalPrepareUpdate = function(e) {
      this.group.removeAll(), this._clear();
    }, n.prototype.incrementalUpdate = function(e, t) {
      var r = this._newAdded[0], i = t.getLayout("linesPoints"), a = r && r.shape.segs;
      if (a && a.length < 2e4) {
        var s = a.length, o = new Float32Array(s + i.length);
        o.set(a), o.set(i, s), r.setShape({
          segs: o
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = true, l.setShape({
          segs: i
        }), this._setCommon(l, t), l.__startIndex = e.start;
      }
    }, n.prototype.remove = function() {
      this._clear();
    }, n.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, n.prototype._create = function() {
      var e = new Ybe({
        cursor: "default",
        ignoreCoarsePointer: true
      });
      return this._newAdded.push(e), this.group.add(e), e;
    }, n.prototype._setCommon = function(e, t, r) {
      var i = t.hostModel;
      e.setShape({
        polyline: i.get("polyline"),
        curveness: i.get([
          "lineStyle",
          "curveness"
        ])
      }), e.useStyle(i.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = true;
      var a = t.getVisual("style");
      a && a.stroke && e.setStyle("stroke", a.stroke), e.setStyle("fill", null);
      var s = rt(e);
      s.seriesIndex = i.seriesIndex, e.on("mousemove", function(o) {
        s.dataIndex = null;
        var l = e.hoverDataIdx;
        l > 0 && (s.dataIndex = l + e.__startIndex);
      });
    }, n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, n;
  }(), Gj = {
    seriesType: "lines",
    plan: _m(),
    reset: function(n) {
      var e = n.coordinateSystem;
      if (e) {
        var t = n.get("polyline"), r = n.pipelineContext.large;
        return {
          progress: function(i, a) {
            var s = [];
            if (r) {
              var o = void 0, l = i.end - i.start;
              if (t) {
                for (var u = 0, c = i.start; c < i.end; c++) u += n.getLineCoordsCount(c);
                o = new Float32Array(l + u * 2);
              } else o = new Float32Array(l * 4);
              for (var h = 0, d = [], c = i.start; c < i.end; c++) {
                var f = n.getLineCoords(c, s);
                t && (o[h++] = f);
                for (var p = 0; p < f; p++) d = e.dataToPoint(s[p], false, d), o[h++] = d[0], o[h++] = d[1];
              }
              a.setLayout("linesPoints", o);
            } else for (var c = i.start; c < i.end; c++) {
              var g = a.getItemModel(c), f = n.getLineCoords(c, s), m = [];
              if (t) for (var v = 0; v < f; v++) m.push(e.dataToPoint(s[v]));
              else {
                m[0] = e.dataToPoint(s[0]), m[1] = e.dataToPoint(s[1]);
                var y = g.get([
                  "lineStyle",
                  "curveness"
                ]);
                +y && (m[2] = [
                  (m[0][0] + m[1][0]) / 2 - (m[0][1] - m[1][1]) * y,
                  (m[0][1] + m[1][1]) / 2 - (m[1][0] - m[0][0]) * y
                ]);
              }
              a.setItemLayout(c, m);
            }
          }
        };
      }
    }
  }, jbe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), s = this._updateLineDraw(a, t), o = t.get("zlevel"), l = t.get([
        "effect",
        "trailLength"
      ]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(o).clear(true), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: false
      }), this._showEffect(t) && l > 0 && (c || u.configLayer(o, {
        motionBlur: true,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), s.updateData(a);
      var h = t.get("clip", true) && Ux(t.coordinateSystem, false, t);
      h ? this.group.setClipPath(h) : this.group.removeClipPath(), this._lastZlevel = o, this._finished = true;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      var a = t.getData(), s = this._updateLineDraw(a, t);
      s.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = false;
    }, e.prototype.incrementalRender = function(t, r, i) {
      this._lineDraw.incrementalUpdate(t, r.getData()), this._finished = t.end === r.getData().count();
    }, e.prototype.eachRendered = function(t) {
      this._lineDraw && this._lineDraw.eachRendered(t);
    }, e.prototype.updateTransform = function(t, r, i) {
      var a = t.getData(), s = t.pipelineContext;
      if (!this._finished || s.large || s.progressiveRender) return {
        update: true
      };
      var o = Gj.reset(t, r, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, e.prototype._updateLineDraw = function(t, r) {
      var i = this._lineDraw, a = this._showEffect(r), s = !!r.get("polyline"), o = r.pipelineContext, l = o.large;
      return (!i || a !== this._hasEffet || s !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new qbe() : new JE(s ? a ? Hbe : Wj : a ? Vj : QE), this._hasEffet = a, this._isPolyline = s, this._isLargeDraw = l), this.group.add(i.group), i;
    }, e.prototype._showEffect = function(t) {
      return !!t.get([
        "effect",
        "show"
      ]);
    }, e.prototype._clearLayer = function(t) {
      var r = t.getZr(), i = r.painter.getType() === "svg";
      !i && this._lastZlevel != null && r.painter.getLayer(this._lastZlevel).clear(true);
    }, e.prototype.remove = function(t, r) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(r);
    }, e.prototype.dispose = function(t, r) {
      this.remove(t, r);
    }, e.type = "lines", e;
  }(_n), Kbe = typeof Uint32Array > "u" ? Array : Uint32Array, Zbe = typeof Float64Array > "u" ? Array : Float64Array;
  function TV(n) {
    var e = n.data;
    e && e[0] && e[0][0] && e[0][0].coord && (n.data = me(e, function(t) {
      var r = [
        t[0].coord,
        t[1].coord
      ], i = {
        coords: r
      };
      return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), NN([
        i,
        t[0],
        t[1]
      ]);
    }));
  }
  var Qbe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.init = function(t) {
      t.data = t.data || [], TV(t);
      var r = this._processFlatCoordsArray(t.data);
      this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count)), n.prototype.init.apply(this, arguments);
    }, e.prototype.mergeOption = function(t) {
      if (TV(t), t.data) {
        var r = this._processFlatCoordsArray(t.data);
        this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count));
      }
      n.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.appendData = function(t) {
      var r = this._processFlatCoordsArray(t.data);
      r.flatCoords && (this._flatCoords ? (this._flatCoords = I0(this._flatCoords, r.flatCoords), this._flatCoordsOffset = I0(this._flatCoordsOffset, r.flatCoordsOffset)) : (this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset), t.data = new Float32Array(r.count)), this.getRawData().appendData(t.data);
    }, e.prototype._getCoordsFromItemModel = function(t) {
      var r = this.getData().getItemModel(t), i = r.option instanceof Array ? r.option : r.getShallow("coords");
      return i;
    }, e.prototype.getLineCoordsCount = function(t) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length;
    }, e.prototype.getLineCoords = function(t, r) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[t * 2], a = this._flatCoordsOffset[t * 2 + 1], s = 0; s < a; s++) r[s] = r[s] || [], r[s][0] = this._flatCoords[i + s * 2], r[s][1] = this._flatCoords[i + s * 2 + 1];
        return a;
      } else {
        for (var o = this._getCoordsFromItemModel(t), s = 0; s < o.length; s++) r[s] = r[s] || [], r[s][0] = o[s][0], r[s][1] = o[s][1];
        return o.length;
      }
    }, e.prototype._processFlatCoordsArray = function(t) {
      var r = 0;
      if (this._flatCoords && (r = this._flatCoords.length), Yt(t[0])) {
        for (var i = t.length, a = new Kbe(i), s = new Zbe(i), o = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var h = t[c++];
          a[l++] = o + r, a[l++] = h;
          for (var d = 0; d < h; d++) {
            var f = t[c++], p = t[c++];
            s[o++] = f, s[o++] = p;
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: s,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: t.length
      };
    }, e.prototype.getInitialData = function(t, r) {
      var i = new Ki([
        "value"
      ], this);
      return i.hasItemOption = false, i.initData(t.data, [], function(a, s, o, l) {
        if (a instanceof Array) return NaN;
        i.hasItemOption = true;
        var u = a.value;
        if (u != null) return u instanceof Array ? u[l] : u;
      }), i;
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), s = a.getItemModel(t), o = s.get("name");
      if (o) return o;
      var l = s.get("fromName"), u = s.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), Xr("nameValue", {
        name: c.join(" > ")
      });
    }, e.prototype.preventIncremental = function() {
      return !!this.get([
        "effect",
        "show"
      ]);
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, e.prototype.getZLevelKey = function() {
      var t = this.getModel("effect"), r = t.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && r > 0 ? r + "" : "";
    }, e.type = "series.lines", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "geo",
      z: 2,
      legendHoverLink: true,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: [
        "none",
        "none"
      ],
      symbolSize: [
        10,
        10
      ],
      geoIndex: 0,
      effect: {
        show: false,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: true,
        trailLength: 0.2
      },
      large: false,
      largeThreshold: 2e3,
      polyline: false,
      clip: true,
      label: {
        show: false,
        position: "end"
      },
      lineStyle: {
        opacity: 0.5
      }
    }, e;
  }(En);
  function rw(n) {
    return n instanceof Array || (n = [
      n,
      n
    ]), n;
  }
  var Jbe = {
    seriesType: "lines",
    reset: function(n) {
      var e = rw(n.get("symbol")), t = rw(n.get("symbolSize")), r = n.getData();
      r.setVisual("fromSymbol", e && e[0]), r.setVisual("toSymbol", e && e[1]), r.setVisual("fromSymbolSize", t && t[0]), r.setVisual("toSymbolSize", t && t[1]);
      function i(a, s) {
        var o = a.getItemModel(s), l = rw(o.getShallow("symbol", true)), u = rw(o.getShallow("symbolSize", true));
        l[0] && a.setItemVisual(s, "fromSymbol", l[0]), l[1] && a.setItemVisual(s, "toSymbol", l[1]), u[0] && a.setItemVisual(s, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(s, "toSymbolSize", u[1]);
      }
      return {
        dataEach: r.hasItemOption ? i : null
      };
    }
  };
  function e1e(n) {
    n.registerChartView(jbe), n.registerSeriesModel(Qbe), n.registerLayout(Gj), n.registerVisual(Jbe);
  }
  var t1e = 256, n1e = function() {
    function n() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var e = ec.createCanvas();
      this.canvas = e;
    }
    return n.prototype.update = function(e, t, r, i, a, s) {
      var o = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), c = this.pointSize + this.blurSize, h = this.canvas, d = h.getContext("2d"), f = e.length;
      h.width = t, h.height = r;
      for (var p = 0; p < f; ++p) {
        var g = e[p], m = g[0], v = g[1], y = g[2], x = i(y);
        d.globalAlpha = x, d.drawImage(o, m - c, v - c);
      }
      if (!h.width || !h.height) return h;
      for (var b = d.getImageData(0, 0, h.width, h.height), w = b.data, _ = 0, S = w.length, I = this.minOpacity, C = this.maxOpacity, T = C - I; _ < S; ) {
        var x = w[_ + 3] / 256, k = Math.floor(x * (t1e - 1)) * 4;
        if (x > 0) {
          var D = s(x) ? l : u;
          x > 0 && (x = x * T + I), w[_++] = D[k], w[_++] = D[k + 1], w[_++] = D[k + 2], w[_++] = D[k + 3] * x * 256;
        } else _ += 4;
      }
      return d.putImageData(b, 0, 0), h;
    }, n.prototype._getBrush = function() {
      var e = this._brushCanvas || (this._brushCanvas = ec.createCanvas()), t = this.pointSize + this.blurSize, r = t * 2;
      e.width = r, e.height = r;
      var i = e.getContext("2d");
      return i.clearRect(0, 0, r, r), i.shadowOffsetX = r, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-t, t, this.pointSize, 0, Math.PI * 2, true), i.closePath(), i.fill(), e;
    }, n.prototype._getGradient = function(e, t) {
      for (var r = this._gradientPixels, i = r[t] || (r[t] = new Uint8ClampedArray(256 * 4)), a = [
        0,
        0,
        0,
        0
      ], s = 0, o = 0; o < 256; o++) e[t](o / 255, true, a), i[s++] = a[0], i[s++] = a[1], i[s++] = a[2], i[s++] = a[3];
      return i;
    }, n;
  }();
  function r1e(n, e, t) {
    var r = n[1] - n[0];
    e = me(e, function(s) {
      return {
        interval: [
          (s.interval[0] - n[0]) / r,
          (s.interval[1] - n[0]) / r
        ]
      };
    });
    var i = e.length, a = 0;
    return function(s) {
      var o;
      for (o = a; o < i; o++) {
        var l = e[o].interval;
        if (l[0] <= s && s <= l[1]) {
          a = o;
          break;
        }
      }
      if (o === i) for (o = a - 1; o >= 0; o--) {
        var l = e[o].interval;
        if (l[0] <= s && s <= l[1]) {
          a = o;
          break;
        }
      }
      return o >= 0 && o < i && t[o];
    };
  }
  function i1e(n, e) {
    var t = n[1] - n[0];
    return e = [
      (e[0] - n[0]) / t,
      (e[1] - n[0]) / t
    ], function(r) {
      return r >= e[0] && r <= e[1];
    };
  }
  function AV(n) {
    var e = n.dimensions;
    return e[0] === "lng" && e[1] === "lat";
  }
  var a1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a;
      r.eachComponent("visualMap", function(o) {
        o.eachTargetSeries(function(l) {
          l === t && (a = o);
        });
      }), this._progressiveEls = null, this.group.removeAll();
      var s = t.coordinateSystem;
      s.type === "cartesian2d" || s.type === "calendar" ? this._renderOnCartesianAndCalendar(t, i, 0, t.getData().count()) : AV(s) && this._renderOnGeo(s, t, a, i);
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this.group.removeAll();
    }, e.prototype.incrementalRender = function(t, r, i, a) {
      var s = r.coordinateSystem;
      s && (AV(s) ? this.render(r, i, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(r, a, t.start, t.end, true)));
    }, e.prototype.eachRendered = function(t) {
      gc(this._progressiveEls || this.group, t);
    }, e.prototype._renderOnCartesianAndCalendar = function(t, r, i, a, s) {
      var o = t.coordinateSystem, l = Bd(o, "cartesian2d"), u, c, h, d;
      if (l) {
        var f = o.getAxis("x"), p = o.getAxis("y");
        u = f.getBandWidth() + 0.5, c = p.getBandWidth() + 0.5, h = f.scale.getExtent(), d = p.scale.getExtent();
      }
      for (var g = this.group, m = t.getData(), v = t.getModel([
        "emphasis",
        "itemStyle"
      ]).getItemStyle(), y = t.getModel([
        "blur",
        "itemStyle"
      ]).getItemStyle(), x = t.getModel([
        "select",
        "itemStyle"
      ]).getItemStyle(), b = t.get([
        "itemStyle",
        "borderRadius"
      ]), w = Hr(t), _ = t.getModel("emphasis"), S = _.get("focus"), I = _.get("blurScope"), C = _.get("disabled"), T = l ? [
        m.mapDimension("x"),
        m.mapDimension("y"),
        m.mapDimension("value")
      ] : [
        m.mapDimension("time"),
        m.mapDimension("value")
      ], k = i; k < a; k++) {
        var D = void 0, R = m.getItemVisual(k, "style");
        if (l) {
          var N = m.get(T[0], k), E = m.get(T[1], k);
          if (isNaN(m.get(T[2], k)) || isNaN(N) || isNaN(E) || N < h[0] || N > h[1] || E < d[0] || E > d[1]) continue;
          var A = o.dataToPoint([
            N,
            E
          ]);
          D = new Vt({
            shape: {
              x: A[0] - u / 2,
              y: A[1] - c / 2,
              width: u,
              height: c
            },
            style: R
          });
        } else {
          if (isNaN(m.get(T[1], k))) continue;
          D = new Vt({
            z2: 1,
            shape: o.dataToRect([
              m.get(T[0], k)
            ]).contentShape,
            style: R
          });
        }
        if (m.hasItemOption) {
          var M = m.getItemModel(k), $ = M.getModel("emphasis");
          v = $.getModel("itemStyle").getItemStyle(), y = M.getModel([
            "blur",
            "itemStyle"
          ]).getItemStyle(), x = M.getModel([
            "select",
            "itemStyle"
          ]).getItemStyle(), b = M.get([
            "itemStyle",
            "borderRadius"
          ]), S = $.get("focus"), I = $.get("blurScope"), C = $.get("disabled"), w = Hr(M);
        }
        D.shape.r = b;
        var L = t.getRawValue(k), F = "-";
        L && L[2] != null && (F = L[2] + ""), gi(D, w, {
          labelFetcher: t,
          labelDataIndex: k,
          defaultOpacity: R.opacity,
          defaultText: F
        }), D.ensureState("emphasis").style = v, D.ensureState("blur").style = y, D.ensureState("select").style = x, Qn(D, S, I, C), D.incremental = s, s && (D.states.emphasis.hoverLayer = true), g.add(D), m.setItemGraphicEl(k, D), this._progressiveEls && this._progressiveEls.push(D);
      }
    }, e.prototype._renderOnGeo = function(t, r, i, a) {
      var s = i.targetVisuals.inRange, o = i.targetVisuals.outOfRange, l = r.getData(), u = this._hmLayer || this._hmLayer || new n1e();
      u.blurSize = r.get("blurSize"), u.pointSize = r.get("pointSize"), u.minOpacity = r.get("minOpacity"), u.maxOpacity = r.get("maxOpacity");
      var c = t.getViewRect().clone(), h = t.getRoamTransform();
      c.applyTransform(h);
      var d = Math.max(c.x, 0), f = Math.max(c.y, 0), p = Math.min(c.width + c.x, a.getWidth()), g = Math.min(c.height + c.y, a.getHeight()), m = p - d, v = g - f, y = [
        l.mapDimension("lng"),
        l.mapDimension("lat"),
        l.mapDimension("value")
      ], x = l.mapArray(y, function(S, I, C) {
        var T = t.dataToPoint([
          S,
          I
        ]);
        return T[0] -= d, T[1] -= f, T.push(C), T;
      }), b = i.getExtent(), w = i.type === "visualMap.continuous" ? i1e(b, i.option.range) : r1e(b, i.getPieceList(), i.option.selected);
      u.update(x, m, v, s.color.getNormalizer(), {
        inRange: s.color.getColorMapper(),
        outOfRange: o.color.getColorMapper()
      }, w);
      var _ = new oi({
        style: {
          width: m,
          height: v,
          x: d,
          y: f,
          image: u.canvas
        },
        silent: true
      });
      this.group.add(_);
    }, e.type = "heatmap", e;
  }(_n), s1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      return au(null, this, {
        generateCoord: "value"
      });
    }, e.prototype.preventIncremental = function() {
      var t = Ox.get(this.get("coordinateSystem"));
      if (t && t.dimensions) return t.dimensions[0] === "lng" && t.dimensions[1] === "lat";
    }, e.type = "series.heatmap", e.dependencies = [
      "grid",
      "geo",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(En);
  function o1e(n) {
    n.registerChartView(a1e), n.registerSeriesModel(s1e);
  }
  var l1e = [
    "itemStyle",
    "borderWidth"
  ], DV = [
    {
      xy: "x",
      wh: "width",
      index: 0,
      posDesc: [
        "left",
        "right"
      ]
    },
    {
      xy: "y",
      wh: "height",
      index: 1,
      posDesc: [
        "top",
        "bottom"
      ]
    }
  ], IT = new iu(), u1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = this.group, s = t.getData(), o = this._data, l = t.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), h = l.master.getRect(), d = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: t,
        coordSys: l,
        coordSysExtent: [
          [
            h.x,
            h.x + h.width
          ],
          [
            h.y,
            h.y + h.height
          ]
        ],
        isHorizontal: c,
        valueDim: DV[+c],
        categoryDim: DV[1 - +c]
      };
      s.diff(o).add(function(p) {
        if (s.hasValue(p)) {
          var g = $V(s, p), m = RV(s, p, g, d), v = NV(s, d, m);
          s.setItemGraphicEl(p, v), a.add(v), MV(v, d, m);
        }
      }).update(function(p, g) {
        var m = o.getItemGraphicEl(g);
        if (!s.hasValue(p)) {
          a.remove(m);
          return;
        }
        var v = $V(s, p), y = RV(s, p, v, d), x = jj(s, y);
        m && x !== m.__pictorialShapeStr && (a.remove(m), s.setItemGraphicEl(p, null), m = null), m ? m1e(m, d, y) : m = NV(s, d, y, true), s.setItemGraphicEl(p, m), m.__pictorialSymbolMeta = y, a.add(m), MV(m, d, y);
      }).remove(function(p) {
        var g = o.getItemGraphicEl(p);
        g && EV(o, p, g.__pictorialSymbolMeta.animationModel, g);
      }).execute();
      var f = t.get("clip", true) ? Ux(t.coordinateSystem, false, t) : null;
      return f ? a.setClipPath(f) : a.removeClipPath(), this._data = s, this.group;
    }, e.prototype.remove = function(t, r) {
      var i = this.group, a = this._data;
      t.get("animation") ? a && a.eachItemGraphicEl(function(s) {
        EV(a, rt(s).dataIndex, t, s);
      }) : i.removeAll();
    }, e.type = "pictorialBar", e;
  }(_n);
  function RV(n, e, t, r) {
    var i = n.getItemLayout(e), a = t.get("symbolRepeat"), s = t.get("symbolClip"), o = t.get("symbolPosition") || "start", l = t.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = t.get("symbolPatternSize") || 2, h = t.isAnimationEnabled(), d = {
      dataIndex: e,
      layout: i,
      itemModel: t,
      symbolType: n.getItemVisual(e, "symbol") || "circle",
      style: n.getItemVisual(e, "style"),
      symbolClip: s,
      symbolRepeat: a,
      symbolRepeatDirection: t.get("symbolRepeatDirection"),
      symbolPatternSize: c,
      rotation: u,
      animationModel: h ? t : null,
      hoverScale: h && t.get([
        "emphasis",
        "scale"
      ]),
      z2: t.getShallow("z", true) || 0
    };
    c1e(t, a, i, r, d), h1e(n, e, i, a, s, d.boundingLength, d.pxSign, c, r, d), d1e(t, d.symbolScale, u, r, d);
    var f = d.symbolSize, p = Fd(t.get("symbolOffset"), f);
    return f1e(t, f, i, a, s, p, o, d.valueLineWidth, d.boundingLength, d.repeatCutLength, r, d), d;
  }
  function c1e(n, e, t, r, i) {
    var a = r.valueDim, s = n.get("symbolBoundingData"), o = r.coordSys.getOtherAxis(r.coordSys.getBaseAxis()), l = o.toGlobalCoord(o.dataToCoord(0)), u = 1 - +(t[a.wh] <= 0), c;
    if (de(s)) {
      var h = [
        kT(o, s[0]) - l,
        kT(o, s[1]) - l
      ];
      h[1] < h[0] && h.reverse(), c = h[u];
    } else s != null ? c = kT(o, s) - l : e ? c = r.coordSysExtent[a.index][u] - l : c = t[a.wh];
    i.boundingLength = c, e && (i.repeatCutLength = t[a.wh]);
    var d = a.xy === "x", f = o.inverse;
    i.pxSign = d && !f || !d && f ? c >= 0 ? 1 : -1 : c > 0 ? 1 : -1;
  }
  function kT(n, e) {
    return n.toGlobalCoord(n.dataToCoord(n.scale.parse(e)));
  }
  function h1e(n, e, t, r, i, a, s, o, l, u) {
    var c = l.valueDim, h = l.categoryDim, d = Math.abs(t[h.wh]), f = n.getItemVisual(e, "symbolSize"), p;
    de(f) ? p = f.slice() : f == null ? p = [
      "100%",
      "100%"
    ] : p = [
      f,
      f
    ], p[h.index] = _e(p[h.index], d), p[c.index] = _e(p[c.index], r ? d : Math.abs(a)), u.symbolSize = p;
    var g = u.symbolScale = [
      p[0] / o,
      p[1] / o
    ];
    g[c.index] *= (l.isHorizontal ? -1 : 1) * s;
  }
  function d1e(n, e, t, r, i) {
    var a = n.get(l1e) || 0;
    a && (IT.attr({
      scaleX: e[0],
      scaleY: e[1],
      rotation: t
    }), IT.updateTransform(), a /= IT.getLineScale(), a *= e[r.valueDim.index]), i.valueLineWidth = a || 0;
  }
  function f1e(n, e, t, r, i, a, s, o, l, u, c, h) {
    var d = c.categoryDim, f = c.valueDim, p = h.pxSign, g = Math.max(e[f.index] + o, 0), m = g;
    if (r) {
      var v = Math.abs(l), y = ni(n.get("symbolMargin"), "15%") + "", x = false;
      y.lastIndexOf("!") === y.length - 1 && (x = true, y = y.slice(0, y.length - 1));
      var b = _e(y, e[f.index]), w = Math.max(g + b * 2, 0), _ = x ? 0 : b * 2, S = e8(r), I = S ? r : PV((v + _) / w), C = v - I * g;
      b = C / 2 / (x ? I : Math.max(I - 1, 1)), w = g + b * 2, _ = x ? 0 : b * 2, !S && r !== "fixed" && (I = u ? PV((Math.abs(u) + _) / w) : 0), m = I * w - _, h.repeatTimes = I, h.symbolMargin = b;
    }
    var T = p * (m / 2), k = h.pathPosition = [];
    k[d.index] = t[d.wh] / 2, k[f.index] = s === "start" ? T : s === "end" ? l - T : l / 2, a && (k[0] += a[0], k[1] += a[1]);
    var D = h.bundlePosition = [];
    D[d.index] = t[d.xy], D[f.index] = t[f.xy];
    var R = h.barRectShape = oe({}, t);
    R[f.wh] = p * Math.max(Math.abs(t[f.wh]), Math.abs(k[f.index] + T)), R[d.wh] = t[d.wh];
    var N = h.clipShape = {};
    N[d.xy] = -t[d.xy], N[d.wh] = c.ecSize[d.wh], N[f.xy] = 0, N[f.wh] = t[f.wh];
  }
  function Uj(n) {
    var e = n.symbolPatternSize, t = xr(n.symbolType, -e / 2, -e / 2, e, e);
    return t.attr({
      culling: true
    }), t.type !== "image" && t.setStyle({
      strokeNoScale: true
    }), t;
  }
  function Hj(n, e, t, r) {
    var i = n.__pictorialBundle, a = t.symbolSize, s = t.valueLineWidth, o = t.pathPosition, l = e.valueDim, u = t.repeatTimes || 0, c = 0, h = a[e.valueDim.index] + s + t.symbolMargin * 2;
    for (uM(n, function(g) {
      g.__pictorialAnimationIndex = c, g.__pictorialRepeatTimes = u, c < u ? kg(g, null, p(c), t, r) : kg(g, null, {
        scaleX: 0,
        scaleY: 0
      }, t, r, function() {
        i.remove(g);
      }), c++;
    }); c < u; c++) {
      var d = Uj(t);
      d.__pictorialAnimationIndex = c, d.__pictorialRepeatTimes = u, i.add(d);
      var f = p(c);
      kg(d, {
        x: f.x,
        y: f.y,
        scaleX: 0,
        scaleY: 0
      }, {
        scaleX: f.scaleX,
        scaleY: f.scaleY,
        rotation: f.rotation
      }, t, r);
    }
    function p(g) {
      var m = o.slice(), v = t.pxSign, y = g;
      return (t.symbolRepeatDirection === "start" ? v > 0 : v < 0) && (y = u - 1 - g), m[l.index] = h * (y - u / 2 + 0.5) + o[l.index], {
        x: m[0],
        y: m[1],
        scaleX: t.symbolScale[0],
        scaleY: t.symbolScale[1],
        rotation: t.rotation
      };
    }
  }
  function Xj(n, e, t, r) {
    var i = n.__pictorialBundle, a = n.__pictorialMainPath;
    a ? kg(a, null, {
      x: t.pathPosition[0],
      y: t.pathPosition[1],
      scaleX: t.symbolScale[0],
      scaleY: t.symbolScale[1],
      rotation: t.rotation
    }, t, r) : (a = n.__pictorialMainPath = Uj(t), i.add(a), kg(a, {
      x: t.pathPosition[0],
      y: t.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: t.rotation
    }, {
      scaleX: t.symbolScale[0],
      scaleY: t.symbolScale[1]
    }, t, r));
  }
  function Yj(n, e, t) {
    var r = oe({}, e.barRectShape), i = n.__pictorialBarRect;
    i ? kg(i, null, {
      shape: r
    }, e, t) : (i = n.__pictorialBarRect = new Vt({
      z2: 2,
      shape: r,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    }), i.disableMorphing = true, n.add(i));
  }
  function qj(n, e, t, r) {
    if (t.symbolClip) {
      var i = n.__pictorialClipPath, a = oe({}, t.clipShape), s = e.valueDim, o = t.animationModel, l = t.dataIndex;
      if (i) Kt(i, {
        shape: a
      }, o, l);
      else {
        a[s.wh] = 0, i = new Vt({
          shape: a
        }), n.__pictorialBundle.setClipPath(i), n.__pictorialClipPath = i;
        var u = {};
        u[s.wh] = t.clipShape[s.wh], Ld[r ? "updateProps" : "initProps"](i, {
          shape: u
        }, o, l);
      }
    }
  }
  function $V(n, e) {
    var t = n.getItemModel(e);
    return t.getAnimationDelayParams = p1e, t.isAnimationEnabled = g1e, t;
  }
  function p1e(n) {
    return {
      index: n.__pictorialAnimationIndex,
      count: n.__pictorialRepeatTimes
    };
  }
  function g1e() {
    return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
  }
  function NV(n, e, t, r) {
    var i = new tt(), a = new tt();
    return i.add(a), i.__pictorialBundle = a, a.x = t.bundlePosition[0], a.y = t.bundlePosition[1], t.symbolRepeat ? Hj(i, e, t) : Xj(i, e, t), Yj(i, t, r), qj(i, e, t, r), i.__pictorialShapeStr = jj(n, t), i.__pictorialSymbolMeta = t, i;
  }
  function m1e(n, e, t) {
    var r = t.animationModel, i = t.dataIndex, a = n.__pictorialBundle;
    Kt(a, {
      x: t.bundlePosition[0],
      y: t.bundlePosition[1]
    }, r, i), t.symbolRepeat ? Hj(n, e, t, true) : Xj(n, e, t, true), Yj(n, t, true), qj(n, e, t, true);
  }
  function EV(n, e, t, r) {
    var i = r.__pictorialBarRect;
    i && i.removeTextContent();
    var a = [];
    uM(r, function(s) {
      a.push(s);
    }), r.__pictorialMainPath && a.push(r.__pictorialMainPath), r.__pictorialClipPath && (t = null), P(a, function(s) {
      nc(s, {
        scaleX: 0,
        scaleY: 0
      }, t, e, function() {
        r.parent && r.parent.remove(r);
      });
    }), n.setItemGraphicEl(e, null);
  }
  function jj(n, e) {
    return [
      n.getItemVisual(e.dataIndex, "symbol") || "none",
      !!e.symbolRepeat,
      !!e.symbolClip
    ].join(":");
  }
  function uM(n, e, t) {
    P(n.__pictorialBundle.children(), function(r) {
      r !== n.__pictorialBarRect && e.call(t, r);
    });
  }
  function kg(n, e, t, r, i, a) {
    e && n.attr(e), r.symbolClip && !i ? t && n.attr(t) : t && Ld[i ? "updateProps" : "initProps"](n, t, r.animationModel, r.dataIndex, a);
  }
  function MV(n, e, t) {
    var r = t.dataIndex, i = t.itemModel, a = i.getModel("emphasis"), s = a.getModel("itemStyle").getItemStyle(), o = i.getModel([
      "blur",
      "itemStyle"
    ]).getItemStyle(), l = i.getModel([
      "select",
      "itemStyle"
    ]).getItemStyle(), u = i.getShallow("cursor"), c = a.get("focus"), h = a.get("blurScope"), d = a.get("scale");
    uM(n, function(g) {
      if (g instanceof oi) {
        var m = g.style;
        g.useStyle(oe({
          image: m.image,
          x: m.x,
          y: m.y,
          width: m.width,
          height: m.height
        }, t.style));
      } else g.useStyle(t.style);
      var v = g.ensureState("emphasis");
      v.style = s, d && (v.scaleX = g.scaleX * 1.1, v.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = o, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = t.z2;
    });
    var f = e.valueDim.posDesc[+(t.boundingLength > 0)], p = n.__pictorialBarRect;
    p.ignoreClip = true, gi(p, Hr(i), {
      labelFetcher: e.seriesModel,
      labelDataIndex: r,
      defaultText: Og(e.seriesModel.getData(), r),
      inheritColor: t.style.fill,
      defaultOpacity: t.style.opacity,
      defaultOutsidePosition: f
    }), Qn(n, c, h, a.get("disabled"));
  }
  function PV(n) {
    var e = Math.round(n);
    return Math.abs(n - e) < 1e-4 ? e : Math.ceil(n);
  }
  var v1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = true, t.defaultSymbol = "roundRect", t;
    }
    return e.prototype.getInitialData = function(t) {
      return t.stack = null, n.prototype.getInitialData.apply(this, arguments);
    }, e.type = "series.pictorialBar", e.dependencies = [
      "grid"
    ], e.defaultOption = mc(G0.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: false,
      symbolRepeatDirection: "end",
      symbolClip: false,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      clip: false,
      progressive: 0,
      emphasis: {
        scale: false
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), e;
  }(G0);
  function y1e(n) {
    n.registerChartView(u1e), n.registerSeriesModel(v1e), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, lt(NY, "pictorialBar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, EY("pictorialBar"));
  }
  var x1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._layers = [], t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = t.getData(), s = this, o = this.group, l = t.getLayerSeries(), u = a.getLayout("layoutInfo"), c = u.rect, h = u.boundaryGap;
      o.x = 0, o.y = c.y + h[0];
      function d(m) {
        return m.name;
      }
      var f = new ql(this._layersSeries || [], l, d, d), p = [];
      f.add(Ae(g, this, "add")).update(Ae(g, this, "update")).remove(Ae(g, this, "remove")).execute();
      function g(m, v, y) {
        var x = s._layers;
        if (m === "remove") {
          o.remove(x[v]);
          return;
        }
        for (var b = [], w = [], _, S = l[v].indices, I = 0; I < S.length; I++) {
          var C = a.getItemLayout(S[I]), T = C.x, k = C.y0, D = C.y;
          b.push(T, k), w.push(T, k + D), _ = a.getItemVisual(S[I], "style");
        }
        var R, N = a.getItemLayout(S[0]), E = t.getModel("label"), A = E.get("margin"), M = t.getModel("emphasis");
        if (m === "add") {
          var $ = p[v] = new tt();
          R = new wq({
            shape: {
              points: b,
              stackedOnPoints: w,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: false
            },
            z2: 0
          }), $.add(R), o.add($), t.isAnimationEnabled() && R.setClipPath(b1e(R.getBoundingRect(), t, function() {
            R.removeClipPath();
          }));
        } else {
          var $ = x[y];
          R = $.childAt(0), o.add($), p[v] = $, Kt(R, {
            shape: {
              points: b,
              stackedOnPoints: w
            }
          }, t), ro(R);
        }
        gi(R, Hr(t), {
          labelDataIndex: S[I - 1],
          defaultText: a.getName(S[I - 1]),
          inheritColor: _.fill
        }, {
          normal: {
            verticalAlign: "middle"
          }
        }), R.setTextConfig({
          position: null,
          local: true
        });
        var L = R.getTextContent();
        L && (L.x = N.x - A, L.y = N.y0 + N.y / 2), R.useStyle(_), a.setItemGraphicEl(v, R), pi(R, t), Qn(R, M.get("focus"), M.get("blurScope"), M.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, e.type = "themeRiver", e;
  }(_n);
  function b1e(n, e, t) {
    var r = new Vt({
      shape: {
        x: n.x - 10,
        y: n.y - 10,
        width: 0,
        height: n.height + 20
      }
    });
    return Un(r, {
      shape: {
        x: n.x - 50,
        width: n.width + 100,
        height: n.height + 20
      }
    }, e, t), r;
  }
  var TT = 2, w1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Yx(Ae(this.getData, this), Ae(this.getRawData, this));
    }, e.prototype.fixData = function(t) {
      var r = t.length, i = {}, a = LD(t, function(d) {
        return i.hasOwnProperty(d[0] + "") || (i[d[0] + ""] = -1), d[2];
      }), s = [];
      a.buckets.each(function(d, f) {
        s.push({
          name: f,
          dataList: d
        });
      });
      for (var o = s.length, l = 0; l < o; ++l) {
        for (var u = s[l].name, c = 0; c < s[l].dataList.length; ++c) {
          var h = s[l].dataList[c][0] + "";
          i[h] = l;
        }
        for (var h in i) i.hasOwnProperty(h) && i[h] !== l && (i[h] = l, t[r] = [
          h,
          0,
          u
        ], r++);
      }
      return t;
    }, e.prototype.getInitialData = function(t, r) {
      for (var i = this.getReferringComponents("singleAxis", yr).models[0], a = i.get("type"), s = rn(t.data, function(p) {
        return p[2] !== void 0;
      }), o = this.fixData(s || []), l = [], u = this.nameMap = Pe(), c = 0, h = 0; h < o.length; ++h) l.push(o[h][TT]), u.get(o[h][TT]) || (u.set(o[h][TT], c), c++);
      var d = zx(o, {
        coordDimensions: [
          "single"
        ],
        dimensionsDefine: [
          {
            name: "time",
            type: J_(a)
          },
          {
            name: "value",
            type: "float"
          },
          {
            name: "name",
            type: "ordinal"
          }
        ],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, f = new Ki(d, this);
      return f.initData(o), f;
    }, e.prototype.getLayerSeries = function() {
      for (var t = this.getData(), r = t.count(), i = [], a = 0; a < r; ++a) i[a] = a;
      var s = t.mapDimension("single"), o = LD(i, function(u) {
        return t.get("name", u);
      }), l = [];
      return o.buckets.each(function(u, c) {
        u.sort(function(h, d) {
          return t.get(s, h) - t.get(s, d);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, e.prototype.getAxisTooltipData = function(t, r, i) {
      de(t) || (t = t ? [
        t
      ] : []);
      for (var a = this.getData(), s = this.getLayerSeries(), o = [], l = s.length, u, c = 0; c < l; ++c) {
        for (var h = Number.MAX_VALUE, d = -1, f = s[c].indices.length, p = 0; p < f; ++p) {
          var g = a.get(t[0], s[c].indices[p]), m = Math.abs(g - r);
          m <= h && (u = g, h = m, d = s[c].indices[p]);
        }
        o.push(d);
      }
      return {
        dataIndices: o,
        nestestValue: u
      };
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), s = a.getName(t), o = a.get(a.mapDimension("value"), t);
      return Xr("nameValue", {
        name: s,
        value: o
      });
    }, e.type = "series.themeRiver", e.dependencies = [
      "singleAxis"
    ], e.defaultOption = {
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      boundaryGap: [
        "10%",
        "10%"
      ],
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: true,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }, e;
  }(En);
  function _1e(n, e) {
    n.eachSeriesByType("themeRiver", function(t) {
      var r = t.getData(), i = t.coordinateSystem, a = {}, s = i.getRect();
      a.rect = s;
      var o = t.get("boundaryGap"), l = i.getAxis();
      if (a.boundaryGap = o, l.orient === "horizontal") {
        o[0] = _e(o[0], s.height), o[1] = _e(o[1], s.height);
        var u = s.height - o[0] - o[1];
        LV(r, t, u);
      } else {
        o[0] = _e(o[0], s.width), o[1] = _e(o[1], s.width);
        var c = s.width - o[0] - o[1];
        LV(r, t, c);
      }
      r.setLayout("layoutInfo", a);
    });
  }
  function LV(n, e, t) {
    if (n.count()) for (var r = e.coordinateSystem, i = e.getLayerSeries(), a = n.mapDimension("single"), s = n.mapDimension("value"), o = me(i, function(m) {
      return me(m.indices, function(v) {
        var y = r.dataToPoint(n.get(a, v));
        return y[1] = n.get(s, v), y;
      });
    }), l = S1e(o), u = l.y0, c = t / l.max, h = i.length, d = i[0].indices.length, f, p = 0; p < d; ++p) {
      f = u[p] * c, n.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: o[0][p][0],
        y0: f,
        y: o[0][p][1] * c
      });
      for (var g = 1; g < h; ++g) f += o[g - 1][p][1] * c, n.setItemLayout(i[g].indices[p], {
        layerIndex: g,
        x: o[g][p][0],
        y0: f,
        y: o[g][p][1] * c
      });
    }
  }
  function S1e(n) {
    for (var e = n.length, t = n[0].length, r = [], i = [], a = 0, s = 0; s < t; ++s) {
      for (var o = 0, l = 0; l < e; ++l) o += n[l][s][1];
      o > a && (a = o), r.push(o);
    }
    for (var u = 0; u < t; ++u) i[u] = (a - r[u]) / 2;
    a = 0;
    for (var c = 0; c < t; ++c) {
      var h = r[c] + i[c];
      h > a && (a = h);
    }
    return {
      y0: i,
      max: a
    };
  }
  function C1e(n) {
    n.registerChartView(x1e), n.registerSeriesModel(w1e), n.registerLayout(_1e), n.registerProcessor(Xx("themeRiver"));
  }
  var I1e = 2, k1e = 4, FV = function(n) {
    K(e, n);
    function e(t, r, i, a) {
      var s = n.call(this) || this;
      s.z2 = I1e, s.textConfig = {
        inside: true
      }, rt(s).seriesIndex = r.seriesIndex;
      var o = new Gt({
        z2: k1e,
        silent: t.getModel().get([
          "label",
          "silent"
        ])
      });
      return s.setTextContent(o), s.updateData(true, t, r, i, a), s;
    }
    return e.prototype.updateData = function(t, r, i, a, s) {
      this.node = r, r.piece = this, i = i || this._seriesModel, a = a || this._ecModel;
      var o = this;
      rt(o).dataIndex = r.dataIndex;
      var l = r.getModel(), u = l.getModel("emphasis"), c = r.getLayout(), h = oe({}, c);
      h.label = null;
      var d = r.getVisual("style");
      d.lineJoin = "bevel";
      var f = r.getVisual("decal");
      f && (d.decal = Lg(f, s));
      var p = Wh(l.getModel("itemStyle"), h, true);
      oe(h, p), P(na, function(y) {
        var x = o.ensureState(y), b = l.getModel([
          y,
          "itemStyle"
        ]);
        x.style = b.getItemStyle();
        var w = Wh(b, h);
        w && (x.shape = w);
      }), t ? (o.setShape(h), o.shape.r = c.r0, Un(o, {
        shape: {
          r: c.r
        }
      }, i, r.dataIndex)) : (Kt(o, {
        shape: h
      }, i), ro(o)), o.useStyle(d), this._updateLabel(i);
      var g = l.getShallow("cursor");
      g && o.attr("cursor", g), this._seriesModel = i || this._seriesModel, this._ecModel = a || this._ecModel;
      var m = u.get("focus"), v = m === "relative" ? I0(r.getAncestorsIndices(), r.getDescendantIndices()) : m === "ancestor" ? r.getAncestorsIndices() : m === "descendant" ? r.getDescendantIndices() : m;
      Qn(this, v, u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t) {
      var r = this, i = this.node.getModel(), a = i.getModel("label"), s = this.node.getLayout(), o = s.endAngle - s.startAngle, l = (s.startAngle + s.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), h = this, d = h.getTextContent(), f = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, g = a.get("show") && !(p != null && Math.abs(o) < p);
      d.ignore = !g, P($0, function(v) {
        var y = v === "normal" ? i.getModel("label") : i.getModel([
          v,
          "label"
        ]), x = v === "normal", b = x ? d : d.ensureState(v), w = t.getFormattedLabel(f, v);
        x && (w = w || r.node.name), b.style = $n(y, {}, null, v !== "normal", true), w && (b.style.text = w);
        var _ = y.get("show");
        _ != null && !x && (b.ignore = !_);
        var S = m(y, "position"), I = x ? h : h.states[v], C = I.style.fill;
        I.textConfig = {
          outsideFill: y.get("color") === "inherit" ? C : null,
          inside: S !== "outside"
        };
        var T, k = m(y, "distance") || 0, D = m(y, "align"), R = m(y, "rotate"), N = Math.PI * 0.5, E = Math.PI * 1.5, A = Oa(R === "tangential" ? Math.PI / 2 - l : l), M = A > N && !D0(A - N) && A < E;
        S === "outside" ? (T = s.r + k, D = M ? "right" : "left") : !D || D === "center" ? (o === 2 * Math.PI && s.r0 === 0 ? T = 0 : T = (s.r + s.r0) / 2, D = "center") : D === "left" ? (T = s.r0 + k, D = M ? "right" : "left") : D === "right" && (T = s.r - k, D = M ? "left" : "right"), b.style.align = D, b.style.verticalAlign = m(y, "verticalAlign") || "middle", b.x = T * u + s.cx, b.y = T * c + s.cy;
        var $ = 0;
        R === "radial" ? $ = Oa(-l) + (M ? Math.PI : 0) : R === "tangential" ? $ = Oa(Math.PI / 2 - l) + (M ? Math.PI : 0) : Yt(R) && ($ = R * Math.PI / 180), b.rotation = Oa($);
      });
      function m(v, y) {
        var x = v.get(y);
        return x ?? a.get(y);
      }
      d.dirtyStyle();
    }, e;
  }(ra), LR = "sunburstRootToNode", OV = "sunburstHighlight", T1e = "sunburstUnhighlight";
  function A1e(n) {
    n.registerAction({
      type: LR,
      update: "updateView"
    }, function(e, t) {
      t.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: e
      }, r);
      function r(i, a) {
        var s = H0(e, [
          LR
        ], i);
        if (s) {
          var o = i.getViewRoot();
          o && (e.direction = YE(o, s.node) ? "rollUp" : "drillDown"), i.resetViewRoot(s.node);
        }
      }
    }), n.registerAction({
      type: OV,
      update: "none"
    }, function(e, t, r) {
      e = oe({}, e), t.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: e
      }, i);
      function i(a) {
        var s = H0(e, [
          OV
        ], a);
        s && (e.dataIndex = s.node.dataIndex);
      }
      r.dispatchAction(oe(e, {
        type: "highlight"
      }));
    }), n.registerAction({
      type: T1e,
      update: "updateView"
    }, function(e, t, r) {
      e = oe({}, e), r.dispatchAction(oe(e, {
        type: "downplay"
      }));
    });
  }
  var D1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      var s = this;
      this.seriesModel = t, this.api = i, this.ecModel = r;
      var o = t.getData(), l = o.tree.root, u = t.getViewRoot(), c = this.group, h = t.get("renderLabelForZeroData"), d = [];
      u.eachNode(function(y) {
        d.push(y);
      });
      var f = this._oldChildren || [];
      p(d, f), v(l, u), this._initEvents(), this._oldChildren = d;
      function p(y, x) {
        if (y.length === 0 && x.length === 0) return;
        new ql(x, y, b, b).add(w).update(w).remove(lt(w, null)).execute();
        function b(_) {
          return _.getId();
        }
        function w(_, S) {
          var I = _ == null ? null : y[_], C = S == null ? null : x[S];
          g(I, C);
        }
      }
      function g(y, x) {
        if (!h && y && !y.getValue() && (y = null), y !== l && x !== l) {
          if (x && x.piece) y ? (x.piece.updateData(false, y, t, r, i), o.setItemGraphicEl(y.dataIndex, x.piece)) : m(x);
          else if (y) {
            var b = new FV(y, t, r, i);
            c.add(b), o.setItemGraphicEl(y.dataIndex, b);
          }
        }
      }
      function m(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function v(y, x) {
        x.depth > 0 ? (s.virtualPiece ? s.virtualPiece.updateData(false, y, t, r, i) : (s.virtualPiece = new FV(y, t, r, i), c.add(s.virtualPiece)), x.piece.off("click"), s.virtualPiece.on("click", function(b) {
          s._rootToNode(x.parentNode);
        })) : s.virtualPiece && (c.remove(s.virtualPiece), s.virtualPiece = null);
      }
    }, e.prototype._initEvents = function() {
      var t = this;
      this.group.off("click"), this.group.on("click", function(r) {
        var i = false, a = t.seriesModel.getViewRoot();
        a.eachNode(function(s) {
          if (!i && s.piece && s.piece === r.target) {
            var o = s.getModel().get("nodeClick");
            if (o === "rootToNode") t._rootToNode(s);
            else if (o === "link") {
              var l = s.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", true) || "_blank";
                H_(u, c);
              }
            }
            i = true;
          }
        });
      });
    }, e.prototype._rootToNode = function(t) {
      t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: LR,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t
      });
    }, e.prototype.containPoint = function(t, r) {
      var i = r.getData(), a = i.getItemLayout(0);
      if (a) {
        var s = t[0] - a.cx, o = t[1] - a.cy, l = Math.sqrt(s * s + o * o);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "sunburst", e;
  }(_n), R1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreStyleOnData = true, t;
    }
    return e.prototype.getInitialData = function(t, r) {
      var i = {
        name: t.name,
        children: t.data
      };
      Kj(i);
      var a = this._levelModels = me(t.levels || [], function(l) {
        return new on(l, this, r);
      }, this), s = XE.createTree(i, this, o);
      function o(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var h = s.getNodeByDataIndex(c), d = a[h.depth];
          return d && (u.parentModel = d), u;
        });
      }
      return s.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.getDataParams = function(t) {
      var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t);
      return r.treePathInfo = HC(i, this), r;
    }, e.prototype.getLevelModel = function(t) {
      return this._levelModels && this._levelModels[t.depth];
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var r = this.getRawData().tree.root;
      (!t || t !== r && !r.contains(t)) && (this._viewRoot = r);
    }, e.prototype.enableAriaDecal = function() {
      tj(this);
    }, e.type = "series.sunburst", e.defaultOption = {
      z: 2,
      center: [
        "50%",
        "50%"
      ],
      radius: [
        0,
        "75%"
      ],
      clockwise: true,
      startAngle: 90,
      minAngle: 0,
      stillShowZeroSum: true,
      nodeClick: "rootToNode",
      renderLabelForZeroData: false,
      label: {
        rotate: "radial",
        show: true,
        opacity: 1,
        align: "center",
        position: "inside",
        distance: 5,
        silent: true
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      sort: "desc"
    }, e;
  }(En);
  function Kj(n) {
    var e = 0;
    P(n.children, function(r) {
      Kj(r);
      var i = r.value;
      de(i) && (i = i[0]), e += i;
    });
    var t = n.value;
    de(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), de(n.value) ? n.value[0] = t : n.value = t;
  }
  var BV = Math.PI / 180;
  function $1e(n, e, t) {
    e.eachSeriesByType(n, function(r) {
      var i = r.get("center"), a = r.get("radius");
      de(a) || (a = [
        0,
        a
      ]), de(i) || (i = [
        i,
        i
      ]);
      var s = t.getWidth(), o = t.getHeight(), l = Math.min(s, o), u = _e(i[0], s), c = _e(i[1], o), h = _e(a[0], l / 2), d = _e(a[1], l / 2), f = -r.get("startAngle") * BV, p = r.get("minAngle") * BV, g = r.getData().tree.root, m = r.getViewRoot(), v = m.depth, y = r.get("sort");
      y != null && Zj(m, y);
      var x = 0;
      P(m.children, function(A) {
        !isNaN(A.getValue()) && x++;
      });
      var b = m.getValue(), w = Math.PI / (b || x) * 2, _ = m.depth > 0, S = m.height - (_ ? -1 : 1), I = (d - h) / (S || 1), C = r.get("clockwise"), T = r.get("stillShowZeroSum"), k = C ? 1 : -1, D = function(A, M) {
        if (A) {
          var $ = M;
          if (A !== g) {
            var L = A.getValue(), F = b === 0 && T ? w : L * w;
            F < p && (F = p), $ = M + k * F;
            var O = A.depth - v - (_ ? -1 : 1), z = h + I * O, V = h + I * (O + 1), H = r.getLevelModel(A);
            if (H) {
              var Y = H.get("r0", true), le = H.get("r", true), ve = H.get("radius", true);
              ve != null && (Y = ve[0], le = ve[1]), Y != null && (z = _e(Y, l / 2)), le != null && (V = _e(le, l / 2));
            }
            A.setLayout({
              angle: F,
              startAngle: M,
              endAngle: $,
              clockwise: C,
              cx: u,
              cy: c,
              r0: z,
              r: V
            });
          }
          if (A.children && A.children.length) {
            var re = 0;
            P(A.children, function(ae) {
              re += D(ae, M + re);
            });
          }
          return $ - M;
        }
      };
      if (_) {
        var R = h, N = h + I, E = Math.PI * 2;
        g.setLayout({
          angle: E,
          startAngle: f,
          endAngle: f + E,
          clockwise: C,
          cx: u,
          cy: c,
          r0: R,
          r: N
        });
      }
      D(m, f);
    });
  }
  function Zj(n, e) {
    var t = n.children || [];
    n.children = N1e(t, e), t.length && P(n.children, function(r) {
      Zj(r, e);
    });
  }
  function N1e(n, e) {
    if (Xe(e)) {
      var t = me(n, function(i, a) {
        var s = i.getValue();
        return {
          params: {
            depth: i.depth,
            height: i.height,
            dataIndex: i.dataIndex,
            getValue: function() {
              return s;
            }
          },
          index: a
        };
      });
      return t.sort(function(i, a) {
        return e(i.params, a.params);
      }), me(t, function(i) {
        return n[i.index];
      });
    } else {
      var r = e === "asc";
      return n.sort(function(i, a) {
        var s = (i.getValue() - a.getValue()) * (r ? 1 : -1);
        return s === 0 ? (i.dataIndex - a.dataIndex) * (r ? -1 : 1) : s;
      });
    }
  }
  function E1e(n) {
    var e = {};
    function t(r, i, a) {
      for (var s = r; s && s.depth > 1; ) s = s.parentNode;
      var o = i.getColorFromPalette(s.name || s.dataIndex + "", e);
      return r.depth > 1 && Ie(o) && (o = CD(o, (r.depth - 1) / (a - 1) * 0.5)), o;
    }
    n.eachSeriesByType("sunburst", function(r) {
      var i = r.getData(), a = i.tree;
      a.eachNode(function(s) {
        var o = s.getModel(), l = o.getModel("itemStyle").getItemStyle();
        l.fill || (l.fill = t(s, r, a.root.height));
        var u = i.ensureUniqueItemVisual(s.dataIndex, "style");
        oe(u, l);
      });
    });
  }
  function M1e(n) {
    n.registerChartView(D1e), n.registerSeriesModel(R1e), n.registerLayout(lt($1e, "sunburst")), n.registerProcessor(lt(Xx, "sunburst")), n.registerVisual(E1e), A1e(n);
  }
  var zV = {
    color: "fill",
    borderColor: "stroke"
  }, P1e = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1
  }, Ll = Wt(), L1e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", true), this.currentZ = this.get("z", true);
    }, e.prototype.getInitialData = function(t, r) {
      return au(null, this);
    }, e.prototype.getDataParams = function(t, r, i) {
      var a = n.prototype.getDataParams.call(this, t, r);
      return i && (a.info = Ll(i).info), a;
    }, e.type = "series.custom", e.dependencies = [
      "grid",
      "polar",
      "geo",
      "singleAxis",
      "calendar"
    ], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      z: 2,
      legendHoverLink: true,
      clip: false
    }, e;
  }(En);
  function F1e(n, e) {
    return e = e || [
      0,
      0
    ], me([
      "x",
      "y"
    ], function(t, r) {
      var i = this.getAxis(t), a = e[r], s = n[r] / 2;
      return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(a - s) - i.dataToCoord(a + s));
    }, this);
  }
  function O1e(n) {
    var e = n.master.getRect();
    return {
      coordSys: {
        type: "cartesian2d",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      api: {
        coord: function(t) {
          return n.dataToPoint(t);
        },
        size: Ae(F1e, n)
      }
    };
  }
  function B1e(n, e) {
    return e = e || [
      0,
      0
    ], me([
      0,
      1
    ], function(t) {
      var r = e[t], i = n[t] / 2, a = [], s = [];
      return a[t] = r - i, s[t] = r + i, a[1 - t] = s[1 - t] = e[1 - t], Math.abs(this.dataToPoint(a)[t] - this.dataToPoint(s)[t]);
    }, this);
  }
  function z1e(n) {
    var e = n.getBoundingRect();
    return {
      coordSys: {
        type: "geo",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height,
        zoom: n.getZoom()
      },
      api: {
        coord: function(t) {
          return n.dataToPoint(t);
        },
        size: Ae(B1e, n)
      }
    };
  }
  function V1e(n, e) {
    var t = this.getAxis(), r = e instanceof Array ? e[0] : e, i = (n instanceof Array ? n[0] : n) / 2;
    return t.type === "category" ? t.getBandWidth() : Math.abs(t.dataToCoord(r - i) - t.dataToCoord(r + i));
  }
  function W1e(n) {
    var e = n.getRect();
    return {
      coordSys: {
        type: "singleAxis",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      },
      api: {
        coord: function(t) {
          return n.dataToPoint(t);
        },
        size: Ae(V1e, n)
      }
    };
  }
  function G1e(n, e) {
    return e = e || [
      0,
      0
    ], me([
      "Radius",
      "Angle"
    ], function(t, r) {
      var i = "get" + t + "Axis", a = this[i](), s = e[r], o = n[r] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(s - o) - a.dataToCoord(s + o));
      return t === "Angle" && (l = l * Math.PI / 180), l;
    }, this);
  }
  function U1e(n) {
    var e = n.getRadiusAxis(), t = n.getAngleAxis(), r = e.getExtent();
    return r[0] > r[1] && r.reverse(), {
      coordSys: {
        type: "polar",
        cx: n.cx,
        cy: n.cy,
        r: r[1],
        r0: r[0]
      },
      api: {
        coord: function(i) {
          var a = e.dataToRadius(i[0]), s = t.dataToAngle(i[1]), o = n.coordToPoint([
            a,
            s
          ]);
          return o.push(a, s * Math.PI / 180), o;
        },
        size: Ae(G1e, n)
      }
    };
  }
  function H1e(n) {
    var e = n.getRect(), t = n.getRangeInfo();
    return {
      coordSys: {
        type: "calendar",
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height,
        cellWidth: n.getCellWidth(),
        cellHeight: n.getCellHeight(),
        rangeInfo: {
          start: t.start,
          end: t.end,
          weeks: t.weeks,
          dayCount: t.allDay
        }
      },
      api: {
        coord: function(r, i) {
          return n.dataToPoint(r, i);
        }
      }
    };
  }
  function Qj(n, e, t, r) {
    return n && (n.legacy || n.legacy !== false && !t && !r && e !== "tspan" && (e === "text" || $e(n, "text")));
  }
  function Jj(n, e, t) {
    var r = n, i, a, s;
    if (e === "text") s = r;
    else {
      s = {}, $e(r, "text") && (s.text = r.text), $e(r, "rich") && (s.rich = r.rich), $e(r, "textFill") && (s.fill = r.textFill), $e(r, "textStroke") && (s.stroke = r.textStroke), $e(r, "fontFamily") && (s.fontFamily = r.fontFamily), $e(r, "fontSize") && (s.fontSize = r.fontSize), $e(r, "fontStyle") && (s.fontStyle = r.fontStyle), $e(r, "fontWeight") && (s.fontWeight = r.fontWeight), a = {
        type: "text",
        style: s,
        silent: true
      }, i = {};
      var o = $e(r, "textPosition");
      t ? i.position = o ? r.textPosition : "inside" : o && (i.position = r.textPosition), $e(r, "textPosition") && (i.position = r.textPosition), $e(r, "textOffset") && (i.offset = r.textOffset), $e(r, "textRotation") && (i.rotation = r.textRotation), $e(r, "textDistance") && (i.distance = r.textDistance);
    }
    return VV(s, n), P(s.rich, function(l) {
      VV(l, l);
    }), {
      textConfig: i,
      textContent: a
    };
  }
  function VV(n, e) {
    e && (e.font = e.textFont || e.font, $e(e, "textStrokeWidth") && (n.lineWidth = e.textStrokeWidth), $e(e, "textAlign") && (n.align = e.textAlign), $e(e, "textVerticalAlign") && (n.verticalAlign = e.textVerticalAlign), $e(e, "textLineHeight") && (n.lineHeight = e.textLineHeight), $e(e, "textWidth") && (n.width = e.textWidth), $e(e, "textHeight") && (n.height = e.textHeight), $e(e, "textBackgroundColor") && (n.backgroundColor = e.textBackgroundColor), $e(e, "textPadding") && (n.padding = e.textPadding), $e(e, "textBorderColor") && (n.borderColor = e.textBorderColor), $e(e, "textBorderWidth") && (n.borderWidth = e.textBorderWidth), $e(e, "textBorderRadius") && (n.borderRadius = e.textBorderRadius), $e(e, "textBoxShadowColor") && (n.shadowColor = e.textBoxShadowColor), $e(e, "textBoxShadowBlur") && (n.shadowBlur = e.textBoxShadowBlur), $e(e, "textBoxShadowOffsetX") && (n.shadowOffsetX = e.textBoxShadowOffsetX), $e(e, "textBoxShadowOffsetY") && (n.shadowOffsetY = e.textBoxShadowOffsetY));
  }
  function WV(n, e, t) {
    var r = n;
    r.textPosition = r.textPosition || t.position || "inside", t.offset != null && (r.textOffset = t.offset), t.rotation != null && (r.textRotation = t.rotation), t.distance != null && (r.textDistance = t.distance);
    var i = r.textPosition.indexOf("inside") >= 0, a = n.fill || "#000";
    GV(r, e);
    var s = r.textFill == null;
    return i ? s && (r.textFill = t.insideFill || "#fff", !r.textStroke && t.insideStroke && (r.textStroke = t.insideStroke), !r.textStroke && (r.textStroke = a), r.textStrokeWidth == null && (r.textStrokeWidth = 2)) : (s && (r.textFill = n.fill || t.outsideFill || "#000"), !r.textStroke && t.outsideStroke && (r.textStroke = t.outsideStroke)), r.text = e.text, r.rich = e.rich, P(e.rich, function(o) {
      GV(o, o);
    }), r;
  }
  function GV(n, e) {
    e && ($e(e, "fill") && (n.textFill = e.fill), $e(e, "stroke") && (n.textStroke = e.fill), $e(e, "lineWidth") && (n.textStrokeWidth = e.lineWidth), $e(e, "font") && (n.font = e.font), $e(e, "fontStyle") && (n.fontStyle = e.fontStyle), $e(e, "fontWeight") && (n.fontWeight = e.fontWeight), $e(e, "fontSize") && (n.fontSize = e.fontSize), $e(e, "fontFamily") && (n.fontFamily = e.fontFamily), $e(e, "align") && (n.textAlign = e.align), $e(e, "verticalAlign") && (n.textVerticalAlign = e.verticalAlign), $e(e, "lineHeight") && (n.textLineHeight = e.lineHeight), $e(e, "width") && (n.textWidth = e.width), $e(e, "height") && (n.textHeight = e.height), $e(e, "backgroundColor") && (n.textBackgroundColor = e.backgroundColor), $e(e, "padding") && (n.textPadding = e.padding), $e(e, "borderColor") && (n.textBorderColor = e.borderColor), $e(e, "borderWidth") && (n.textBorderWidth = e.borderWidth), $e(e, "borderRadius") && (n.textBorderRadius = e.borderRadius), $e(e, "shadowColor") && (n.textBoxShadowColor = e.shadowColor), $e(e, "shadowBlur") && (n.textBoxShadowBlur = e.shadowBlur), $e(e, "shadowOffsetX") && (n.textBoxShadowOffsetX = e.shadowOffsetX), $e(e, "shadowOffsetY") && (n.textBoxShadowOffsetY = e.shadowOffsetY), $e(e, "textShadowColor") && (n.textShadowColor = e.textShadowColor), $e(e, "textShadowBlur") && (n.textShadowBlur = e.textShadowBlur), $e(e, "textShadowOffsetX") && (n.textShadowOffsetX = e.textShadowOffsetX), $e(e, "textShadowOffsetY") && (n.textShadowOffsetY = e.textShadowOffsetY));
  }
  var eK = {
    position: [
      "x",
      "y"
    ],
    scale: [
      "scaleX",
      "scaleY"
    ],
    origin: [
      "originX",
      "originY"
    ]
  }, UV = Mt(eK);
  Qo(el, function(n, e) {
    return n[e] = 1, n;
  }, {});
  el.join(", ");
  var hS = [
    "",
    "style",
    "shape",
    "extra"
  ], Vg = Wt();
  function cM(n, e, t, r, i) {
    var a = n + "Animation", s = mm(n, r, i) || {}, o = Vg(e).userDuring;
    return s.duration > 0 && (s.during = o ? Ae(K1e, {
      el: e,
      userDuring: o
    }) : null, s.setToFinal = true, s.scope = n), oe(s, t[a]), s;
  }
  function c_(n, e, t, r) {
    r = r || {};
    var i = r.dataIndex, a = r.isInit, s = r.clearStyle, o = t.isAnimationEnabled(), l = Vg(n), u = e.style;
    l.userDuring = e.during;
    var c = {}, h = {};
    if (Q1e(n, e, h), XV("shape", e, h), XV("extra", e, h), !a && o && (Z1e(n, e, c), HV("shape", n, e, c), HV("extra", n, e, c), J1e(n, e, u, c)), h.style = u, X1e(n, h, s), q1e(n, e), o) if (a) {
      var d = {};
      P(hS, function(p) {
        var g = p ? e[p] : e;
        g && g.enterFrom && (p && (d[p] = d[p] || {}), oe(p ? d[p] : d, g.enterFrom));
      });
      var f = cM("enter", n, e, t, i);
      f.duration > 0 && n.animateFrom(d, f);
    } else Y1e(n, e, i || 0, t, c);
    tK(n, e), u ? n.dirty() : n.markRedraw();
  }
  function tK(n, e) {
    for (var t = Vg(n).leaveToProps, r = 0; r < hS.length; r++) {
      var i = hS[r], a = i ? e[i] : e;
      a && a.leaveTo && (t || (t = Vg(n).leaveToProps = {}), i && (t[i] = t[i] || {}), oe(i ? t[i] : t, a.leaveTo));
    }
  }
  function qC(n, e, t, r) {
    if (n) {
      var i = n.parent, a = Vg(n).leaveToProps;
      if (a) {
        var s = cM("update", n, e, t, 0);
        s.done = function() {
          i.remove(n);
        }, n.animateTo(a, s);
      } else i.remove(n);
    }
  }
  function nd(n) {
    return n === "all";
  }
  function X1e(n, e, t) {
    var r = e.style;
    if (!n.isGroup && r) {
      if (t) {
        n.useStyle({});
        for (var i = n.animators, a = 0; a < i.length; a++) {
          var s = i[a];
          s.targetName === "style" && s.changeTarget(n.style);
        }
      }
      n.setStyle(r);
    }
    e && (e.style = null, e && n.attr(e), e.style = r);
  }
  function Y1e(n, e, t, r, i) {
    if (i) {
      var a = cM("update", n, e, r, t);
      a.duration > 0 && n.animateFrom(i, a);
    }
  }
  function q1e(n, e) {
    $e(e, "silent") && (n.silent = e.silent), $e(e, "ignore") && (n.ignore = e.ignore), n instanceof _s && $e(e, "invisible") && (n.invisible = e.invisible), n instanceof At && $e(e, "autoBatch") && (n.autoBatch = e.autoBatch);
  }
  var Io = {}, j1e = {
    setTransform: function(n, e) {
      return Io.el[n] = e, this;
    },
    getTransform: function(n) {
      return Io.el[n];
    },
    setShape: function(n, e) {
      var t = Io.el, r = t.shape || (t.shape = {});
      return r[n] = e, t.dirtyShape && t.dirtyShape(), this;
    },
    getShape: function(n) {
      var e = Io.el.shape;
      if (e) return e[n];
    },
    setStyle: function(n, e) {
      var t = Io.el, r = t.style;
      return r && (r[n] = e, t.dirtyStyle && t.dirtyStyle()), this;
    },
    getStyle: function(n) {
      var e = Io.el.style;
      if (e) return e[n];
    },
    setExtra: function(n, e) {
      var t = Io.el.extra || (Io.el.extra = {});
      return t[n] = e, this;
    },
    getExtra: function(n) {
      var e = Io.el.extra;
      if (e) return e[n];
    }
  };
  function K1e() {
    var n = this, e = n.el;
    if (e) {
      var t = Vg(e).userDuring, r = n.userDuring;
      if (t !== r) {
        n.el = n.userDuring = null;
        return;
      }
      Io.el = e, r(j1e);
    }
  }
  function HV(n, e, t, r) {
    var i = t[n];
    if (i) {
      var a = e[n], s;
      if (a) {
        var o = t.transition, l = i.transition;
        if (l) if (!s && (s = r[n] = {}), nd(l)) oe(s, a);
        else for (var u = xn(l), c = 0; c < u.length; c++) {
          var h = u[c], d = a[h];
          s[h] = d;
        }
        else if (nd(o) || bt(o, n) >= 0) {
          !s && (s = r[n] = {});
          for (var f = Mt(a), c = 0; c < f.length; c++) {
            var h = f[c], d = a[h];
            ewe(i[h], d) && (s[h] = d);
          }
        }
      }
    }
  }
  function XV(n, e, t) {
    var r = e[n];
    if (r) for (var i = t[n] = {}, a = Mt(r), s = 0; s < a.length; s++) {
      var o = a[s];
      i[o] = n0(r[o]);
    }
  }
  function Z1e(n, e, t) {
    for (var r = e.transition, i = nd(r) ? el : xn(r || []), a = 0; a < i.length; a++) {
      var s = i[a];
      if (!(s === "style" || s === "shape" || s === "extra")) {
        var o = n[s];
        t[s] = o;
      }
    }
  }
  function Q1e(n, e, t) {
    for (var r = 0; r < UV.length; r++) {
      var i = UV[r], a = eK[i], s = e[i];
      s && (t[a[0]] = s[0], t[a[1]] = s[1]);
    }
    for (var r = 0; r < el.length; r++) {
      var o = el[r];
      e[o] != null && (t[o] = e[o]);
    }
  }
  function J1e(n, e, t, r) {
    if (t) {
      var i = n.style, a;
      if (i) {
        var s = t.transition, o = e.transition;
        if (s && !nd(s)) {
          var l = xn(s);
          !a && (a = r.style = {});
          for (var u = 0; u < l.length; u++) {
            var c = l[u], h = i[c];
            a[c] = h;
          }
        } else if (n.getAnimationStyleProps && (nd(o) || nd(s) || bt(o, "style") >= 0)) {
          var d = n.getAnimationStyleProps(), f = d ? d.style : null;
          if (f) {
            !a && (a = r.style = {});
            for (var p = Mt(t), u = 0; u < p.length; u++) {
              var c = p[u];
              if (f[c]) {
                var h = i[c];
                a[c] = h;
              }
            }
          }
        }
      }
    }
  }
  function ewe(n, e) {
    return Mi(n) ? n !== e : n != null && isFinite(n);
  }
  var nK = Wt(), twe = [
    "percent",
    "easing",
    "shape",
    "style",
    "extra"
  ];
  function rK(n) {
    n.stopAnimation("keyframe"), n.attr(nK(n));
  }
  function dS(n, e, t) {
    if (!(!t.isAnimationEnabled() || !e)) {
      if (de(e)) {
        P(e, function(o) {
          dS(n, o, t);
        });
        return;
      }
      var r = e.keyframes, i = e.duration;
      if (t && i == null) {
        var a = mm("enter", t, 0);
        i = a && a.duration;
      }
      if (!(!r || !i)) {
        var s = nK(n);
        P(hS, function(o) {
          if (!(o && !n[o])) {
            var l;
            r.sort(function(u, c) {
              return u.percent - c.percent;
            }), P(r, function(u) {
              var c = n.animators, h = o ? u[o] : u;
              if (h) {
                var d = Mt(h);
                if (o || (d = rn(d, function(g) {
                  return bt(twe, g) < 0;
                })), !!d.length) {
                  l || (l = n.animate(o, e.loop, true), l.scope = "keyframe");
                  for (var f = 0; f < c.length; f++) c[f] !== l && c[f].targetName === l.targetName && c[f].stopTracks(d);
                  o && (s[o] = s[o] || {});
                  var p = o ? s[o] : s;
                  P(d, function(g) {
                    p[g] = ((o ? n[o] : n) || {})[g];
                  }), l.whenWithKeys(i * u.percent, h, d, u.easing);
                }
              }
            }), l && l.delay(e.delay || 0).duration(i).start(e.easing);
          }
        });
      }
    }
  }
  var Fl = "emphasis", Bu = "normal", hM = "blur", dM = "select", sc = [
    Bu,
    Fl,
    hM,
    dM
  ], AT = {
    normal: [
      "itemStyle"
    ],
    emphasis: [
      Fl,
      "itemStyle"
    ],
    blur: [
      hM,
      "itemStyle"
    ],
    select: [
      dM,
      "itemStyle"
    ]
  }, DT = {
    normal: [
      "label"
    ],
    emphasis: [
      Fl,
      "label"
    ],
    blur: [
      hM,
      "label"
    ],
    select: [
      dM,
      "label"
    ]
  }, nwe = [
    "x",
    "y"
  ], rwe = "e\0\0", ns = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {}
  }, iwe = {
    cartesian2d: O1e,
    geo: z1e,
    single: W1e,
    polar: U1e,
    calendar: H1e
  };
  function FR(n) {
    return n instanceof At;
  }
  function OR(n) {
    return n instanceof _s;
  }
  function awe(n, e) {
    e.copyTransform(n), OR(e) && OR(n) && (e.setStyle(n.style), e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel, e.invisible = n.invisible, e.ignore = n.ignore, FR(e) && FR(n) && e.setShape(n.shape));
  }
  var swe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this._progressiveEls = null;
      var s = this._data, o = t.getData(), l = this.group, u = YV(t, o, r, i);
      s || l.removeAll(), o.diff(s).add(function(h) {
        RT(i, null, h, u(h, a), t, l, o);
      }).remove(function(h) {
        var d = s.getItemGraphicEl(h);
        d && qC(d, Ll(d).option, t);
      }).update(function(h, d) {
        var f = s.getItemGraphicEl(d);
        RT(i, f, h, u(h, a), t, l, o);
      }).execute();
      var c = t.get("clip", true) ? Ux(t.coordinateSystem, false, t) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = o;
    }, e.prototype.incrementalPrepareRender = function(t, r, i) {
      this.group.removeAll(), this._data = null;
    }, e.prototype.incrementalRender = function(t, r, i, a, s) {
      var o = r.getData(), l = YV(r, o, i, a), u = this._progressiveEls = [];
      function c(f) {
        f.isGroup || (f.incremental = true, f.ensureState("emphasis").hoverLayer = true);
      }
      for (var h = t.start; h < t.end; h++) {
        var d = RT(null, null, h, l(h, s), r, this.group, o);
        d && (d.traverse(c), u.push(d));
      }
    }, e.prototype.eachRendered = function(t) {
      gc(this._progressiveEls || this.group, t);
    }, e.prototype.filterForExposedEvent = function(t, r, i, a) {
      var s = r.element;
      if (s == null || i.name === s) return true;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; ) if (i.name === s) return true;
      return false;
    }, e.type = "custom", e;
  }(_n);
  function fM(n) {
    var e = n.type, t;
    if (e === "path") {
      var r = n.shape, i = r.width != null && r.height != null ? {
        x: r.x || 0,
        y: r.y || 0,
        width: r.width,
        height: r.height
      } : null, a = sK(r);
      t = CC(a, null, i, r.layout || "center"), Ll(t).customPathData = a;
    } else if (e === "image") t = new oi({}), Ll(t).customImagePath = n.style.image;
    else if (e === "text") t = new Gt({});
    else if (e === "group") t = new tt();
    else {
      if (e === "compoundPath") throw new Error('"compoundPath" is not supported yet.');
      var s = tE(e);
      if (!s) {
        var o = "";
        nn(o);
      }
      t = new s();
    }
    return Ll(t).customGraphicType = e, t.name = n.name, t.z2EmphasisLift = 1, t.z2SelectLift = 1, t;
  }
  function pM(n, e, t, r, i, a, s) {
    rK(e);
    var o = i && i.normal.cfg;
    o && e.setTextConfig(o), r && r.transition == null && (r.transition = nwe);
    var l = r && r.style;
    if (l) {
      if (e.type === "text") {
        var u = l;
        $e(u, "textFill") && (u.fill = u.textFill), $e(u, "textStroke") && (u.stroke = u.textStroke);
      }
      var c = void 0, h = FR(e) ? l.decal : null;
      n && h && (h.dirty = true, c = Lg(h, n)), l.__decalPattern = c;
    }
    if (OR(e) && l) {
      var c = l.__decalPattern;
      c && (l.decal = c);
    }
    c_(e, r, a, {
      dataIndex: t,
      isInit: s,
      clearStyle: true
    }), dS(e, r.keyframeAnimation, a);
  }
  function iK(n, e, t, r, i) {
    var a = e.isGroup ? null : e, s = i && i[n].cfg;
    if (a) {
      var o = a.ensureState(n);
      if (r === false) {
        var l = a.getState(n);
        l && (l.style = null);
      } else o.style = r || null;
      s && (o.textConfig = s), dd(a);
    }
  }
  function owe(n, e, t) {
    if (!n.isGroup) {
      var r = n, i = t.currentZ, a = t.currentZLevel;
      r.z = i, r.zlevel = a;
      var s = e.z2;
      s != null && (r.z2 = s || 0);
      for (var o = 0; o < sc.length; o++) lwe(r, e, sc[o]);
    }
  }
  function lwe(n, e, t) {
    var r = t === Bu, i = r ? e : fS(e, t), a = i ? i.z2 : null, s;
    a != null && (s = r ? n : n.ensureState(t), s.z2 = a || 0);
  }
  function YV(n, e, t, r) {
    var i = n.get("renderItem"), a = n.coordinateSystem, s = {};
    a && (s = a.prepareCustoms ? a.prepareCustoms(a) : iwe[a.type](a));
    for (var o = je({
      getWidth: r.getWidth,
      getHeight: r.getHeight,
      getZr: r.getZr,
      getDevicePixelRatio: r.getDevicePixelRatio,
      value: b,
      style: _,
      ordinalRawValue: w,
      styleEmphasis: S,
      visual: T,
      barLayout: k,
      currentSeriesIndices: D,
      font: R
    }, s.api || {}), l = {
      context: {},
      seriesId: n.id,
      seriesName: n.name,
      seriesIndex: n.seriesIndex,
      coordSys: s.coordSys,
      dataInsideLength: e.count(),
      encode: uwe(n.getData())
    }, u, c, h = {}, d = {}, f = {}, p = {}, g = 0; g < sc.length; g++) {
      var m = sc[g];
      f[m] = n.getModel(AT[m]), p[m] = n.getModel(DT[m]);
    }
    function v(N) {
      return N === u ? c || (c = e.getItemModel(N)) : e.getItemModel(N);
    }
    function y(N, E) {
      return e.hasItemOption ? N === u ? h[E] || (h[E] = v(N).getModel(AT[E])) : v(N).getModel(AT[E]) : f[E];
    }
    function x(N, E) {
      return e.hasItemOption ? N === u ? d[E] || (d[E] = v(N).getModel(DT[E])) : v(N).getModel(DT[E]) : p[E];
    }
    return function(N, E) {
      return u = N, c = null, h = {}, d = {}, i && i(je({
        dataIndexInside: N,
        dataIndex: e.getRawIndex(N),
        actionType: E ? E.type : null
      }, l), o);
    };
    function b(N, E) {
      return E == null && (E = u), e.getStore().get(e.getDimensionIndex(N || 0), E);
    }
    function w(N, E) {
      E == null && (E = u), N = N || 0;
      var A = e.getDimensionInfo(N);
      if (!A) {
        var M = e.getDimensionIndex(N);
        return M >= 0 ? e.getStore().get(M, E) : void 0;
      }
      var $ = e.get(A.name, E), L = A && A.ordinalMeta;
      return L ? L.categories[$] : $;
    }
    function _(N, E) {
      E == null && (E = u);
      var A = e.getItemVisual(E, "style"), M = A && A.fill, $ = A && A.opacity, L = y(E, Bu).getItemStyle();
      M != null && (L.fill = M), $ != null && (L.opacity = $);
      var F = {
        inheritColor: Ie(M) ? M : "#000"
      }, O = x(E, Bu), z = $n(O, null, F, false, true);
      z.text = O.getShallow("show") ? it(n.getFormattedLabel(E, Bu), Og(e, E)) : null;
      var V = G_(O, F, false);
      return C(N, L), L = WV(L, z, V), N && I(L, N), L.legacy = true, L;
    }
    function S(N, E) {
      E == null && (E = u);
      var A = y(E, Fl).getItemStyle(), M = x(E, Fl), $ = $n(M, null, null, true, true);
      $.text = M.getShallow("show") ? Go(n.getFormattedLabel(E, Fl), n.getFormattedLabel(E, Bu), Og(e, E)) : null;
      var L = G_(M, null, true);
      return C(N, A), A = WV(A, $, L), N && I(A, N), A.legacy = true, A;
    }
    function I(N, E) {
      for (var A in E) $e(E, A) && (N[A] = E[A]);
    }
    function C(N, E) {
      N && (N.textFill && (E.textFill = N.textFill), N.textPosition && (E.textPosition = N.textPosition));
    }
    function T(N, E) {
      if (E == null && (E = u), $e(zV, N)) {
        var A = e.getItemVisual(E, "style");
        return A ? A[zV[N]] : null;
      }
      if ($e(P1e, N)) return e.getItemVisual(E, N);
    }
    function k(N) {
      if (a.type === "cartesian2d") {
        var E = a.getBaseAxis();
        return Qfe(je({
          axis: E
        }, N));
      }
    }
    function D() {
      return t.getCurrentSeriesIndices();
    }
    function R(N) {
      return nE(N, t);
    }
  }
  function uwe(n) {
    var e = {};
    return P(n.dimensions, function(t) {
      var r = n.getDimensionInfo(t);
      if (!r.isExtraCoord) {
        var i = r.coordDim, a = e[i] = e[i] || [];
        a[r.coordDimIndex] = n.getDimensionIndex(t);
      }
    }), e;
  }
  function RT(n, e, t, r, i, a, s) {
    if (!r) {
      a.remove(e);
      return;
    }
    var o = gM(n, e, t, r, i, a);
    return o && s.setItemGraphicEl(t, o), o && Qn(o, r.focus, r.blurScope, r.emphasisDisabled), o;
  }
  function gM(n, e, t, r, i, a) {
    var s = -1, o = e;
    e && aK(e, r, i) && (s = bt(a.childrenRef(), e), e = null);
    var l = !e, u = e;
    u ? u.clearStates() : (u = fM(r), o && awe(o, u)), r.morph === false ? u.disableMorphing = true : u.disableMorphing && (u.disableMorphing = false), ns.normal.cfg = ns.normal.conOpt = ns.emphasis.cfg = ns.emphasis.conOpt = ns.blur.cfg = ns.blur.conOpt = ns.select.cfg = ns.select.conOpt = null, ns.isLegacy = false, hwe(u, t, r, i, l, ns), cwe(u, t, r, i, l), pM(n, u, t, r, ns, i, l), $e(r, "info") && (Ll(u).info = r.info);
    for (var c = 0; c < sc.length; c++) {
      var h = sc[c];
      if (h !== Bu) {
        var d = fS(r, h), f = mM(r, d, h);
        iK(h, u, d, f, ns);
      }
    }
    return owe(u, r, i), r.type === "group" && dwe(n, u, t, r, i), s >= 0 ? a.replaceAt(u, s) : a.add(u), u;
  }
  function aK(n, e, t) {
    var r = Ll(n), i = e.type, a = e.shape, s = e.style;
    return t.isUniversalTransitionEnabled() || i != null && i !== r.customGraphicType || i === "path" && mwe(a) && sK(a) !== r.customPathData || i === "image" && $e(s, "image") && s.image !== r.customImagePath;
  }
  function cwe(n, e, t, r, i) {
    var a = t.clipPath;
    if (a === false) n && n.getClipPath() && n.removeClipPath();
    else if (a) {
      var s = n.getClipPath();
      s && aK(s, a, r) && (s = null), s || (s = fM(a), n.setClipPath(s)), pM(null, s, e, a, null, r, i);
    }
  }
  function hwe(n, e, t, r, i, a) {
    if (!n.isGroup) {
      qV(t, null, a), qV(t, Fl, a);
      var s = a.normal.conOpt, o = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
      if (s != null || o != null || u != null || l != null) {
        var c = n.getTextContent();
        if (s === false) c && n.removeTextContent();
        else {
          s = a.normal.conOpt = s || {
            type: "text"
          }, c ? c.clearStates() : (c = fM(s), n.setTextContent(c)), pM(null, c, e, s, null, r, i);
          for (var h = s && s.style, d = 0; d < sc.length; d++) {
            var f = sc[d];
            if (f !== Bu) {
              var p = a[f].conOpt;
              iK(f, c, p, mM(s, p, f), null);
            }
          }
          h ? c.dirty() : c.markRedraw();
        }
      }
    }
  }
  function qV(n, e, t) {
    var r = e ? fS(n, e) : n, i = e ? mM(n, r, Fl) : n.style, a = n.type, s = r ? r.textConfig : null, o = n.textContent, l = o ? e ? fS(o, e) : o : null;
    if (i && (t.isLegacy || Qj(i, a, !!s, !!l))) {
      t.isLegacy = true;
      var u = Jj(i, a, !e);
      !s && u.textConfig && (s = u.textConfig), !l && u.textContent && (l = u.textContent);
    }
    if (!e && l) {
      var c = l;
      !c.type && (c.type = "text");
    }
    var h = e ? t[e] : t.normal;
    h.cfg = s, h.conOpt = l;
  }
  function fS(n, e) {
    return e ? n ? n[e] : null : n;
  }
  function mM(n, e, t) {
    var r = e && e.style;
    return r == null && t === Fl && n && (r = n.styleEmphasis), r;
  }
  function dwe(n, e, t, r, i) {
    var a = r.children, s = a ? a.length : 0, o = r.$mergeChildren, l = o === "byName" || r.diffChildrenByName, u = o === false;
    if (!(!s && !l && !u)) {
      if (l) {
        pwe({
          api: n,
          oldChildren: e.children() || [],
          newChildren: a || [],
          dataIndex: t,
          seriesModel: i,
          group: e
        });
        return;
      }
      u && e.removeAll();
      for (var c = 0; c < s; c++) {
        var h = a[c], d = e.childAt(c);
        h ? (h.ignore == null && (h.ignore = false), gM(n, d, t, h, i, e)) : d.ignore = true;
      }
      for (var f = e.childCount() - 1; f >= c; f--) {
        var p = e.childAt(f);
        fwe(e, p, i);
      }
    }
  }
  function fwe(n, e, t) {
    e && qC(e, Ll(n).option, t);
  }
  function pwe(n) {
    new ql(n.oldChildren, n.newChildren, jV, jV, n).add(KV).update(KV).remove(gwe).execute();
  }
  function jV(n, e) {
    var t = n && n.name;
    return t ?? rwe + e;
  }
  function KV(n, e) {
    var t = this.context, r = n != null ? t.newChildren[n] : null, i = e != null ? t.oldChildren[e] : null;
    gM(t.api, i, t.dataIndex, r, t.seriesModel, t.group);
  }
  function gwe(n) {
    var e = this.context, t = e.oldChildren[n];
    t && qC(t, Ll(t).option, e.seriesModel);
  }
  function sK(n) {
    return n && (n.pathData || n.d);
  }
  function mwe(n) {
    return n && ($e(n, "pathData") || $e(n, "d"));
  }
  function vwe(n) {
    n.registerChartView(swe), n.registerSeriesModel(L1e);
  }
  var Dh = Wt(), ZV = Qe, $T = Ae, vM = function() {
    function n() {
      this._dragging = false, this.animationThreshold = 15;
    }
    return n.prototype.render = function(e, t, r, i) {
      var a = t.get("value"), s = t.get("status");
      if (this._axisModel = e, this._axisPointerModel = t, this._api = r, !(!i && this._lastValue === a && this._lastStatus === s)) {
        this._lastValue = a, this._lastStatus = s;
        var o = this._group, l = this._handle;
        if (!s || s === "hide") {
          o && o.hide(), l && l.hide();
          return;
        }
        o && o.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, e, t, r);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(r), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(e, t);
        if (!o) o = this._group = new tt(), this.createPointerEl(o, u, e, t), this.createLabelEl(o, u, e, t), r.getZr().add(o);
        else {
          var d = lt(QV, t, h);
          this.updatePointerEl(o, u, d), this.updateLabelEl(o, u, d, t);
        }
        eW(o, t, true), this._renderHandle(a);
      }
    }, n.prototype.remove = function(e) {
      this.clear(e);
    }, n.prototype.dispose = function(e) {
      this.clear(e);
    }, n.prototype.determineAnimation = function(e, t) {
      var r = t.get("animation"), i = e.axis, a = i.type === "category", s = t.get("snap");
      if (!s && !a) return false;
      if (r === "auto" || r == null) {
        var o = this.animationThreshold;
        if (a && i.getBandWidth() > o) return true;
        if (s) {
          var l = BE(e).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > o;
        }
        return false;
      }
      return r === true;
    }, n.prototype.makeElOption = function(e, t, r, i, a) {
    }, n.prototype.createPointerEl = function(e, t, r, i) {
      var a = t.pointer;
      if (a) {
        var s = Dh(e).pointerEl = new Ld[a.type](ZV(t.pointer));
        e.add(s);
      }
    }, n.prototype.createLabelEl = function(e, t, r, i) {
      if (t.label) {
        var a = Dh(e).labelEl = new Gt(ZV(t.label));
        e.add(a), JV(a, i);
      }
    }, n.prototype.updatePointerEl = function(e, t, r) {
      var i = Dh(e).pointerEl;
      i && t.pointer && (i.setStyle(t.pointer.style), r(i, {
        shape: t.pointer.shape
      }));
    }, n.prototype.updateLabelEl = function(e, t, r, i) {
      var a = Dh(e).labelEl;
      a && (a.setStyle(t.label.style), r(a, {
        x: t.label.x,
        y: t.label.y
      }), JV(a, i));
    }, n.prototype._renderHandle = function(e) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var t = this._axisPointerModel, r = this._api.getZr(), i = this._handle, a = t.getModel("handle"), s = t.get("status");
        if (!a.get("show") || !s || s === "hide") {
          i && r.remove(i), this._handle = null;
          return;
        }
        var o;
        this._handle || (o = true, i = this._handle = Fx(a.get("icon"), {
          cursor: "move",
          draggable: true,
          onmousemove: function(u) {
            Ul(u.event);
          },
          onmousedown: $T(this._onHandleDragMove, this, 0, 0),
          drift: $T(this._onHandleDragMove, this),
          ondragend: $T(this._onHandleDragEnd, this)
        }), r.add(i)), eW(i, t, false), i.setStyle(a.getItemStyle(null, [
          "color",
          "borderColor",
          "borderWidth",
          "opacity",
          "shadowColor",
          "shadowBlur",
          "shadowOffsetX",
          "shadowOffsetY"
        ]));
        var l = a.get("size");
        de(l) || (l = [
          l,
          l
        ]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, Sm(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, o);
      }
    }, n.prototype._moveHandleToValue = function(e, t) {
      QV(this._axisPointerModel, !t && this._moveAnimation, this._handle, NT(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)));
    }, n.prototype._onHandleDragMove = function(e, t) {
      var r = this._handle;
      if (r) {
        this._dragging = true;
        var i = this.updateHandleTransform(NT(r), [
          e,
          t
        ], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, r.stopAnimation(), r.attr(NT(i)), Dh(r).lastProp = null, this._doDispatchAxisPointer();
      }
    }, n.prototype._doDispatchAxisPointer = function() {
      var e = this._handle;
      if (e) {
        var t = this._payloadInfo, r = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: t.cursorPoint[0],
          y: t.cursorPoint[1],
          tooltipOption: t.tooltipOption,
          axesInfo: [
            {
              axisDim: r.axis.dim,
              axisIndex: r.componentIndex
            }
          ]
        });
      }
    }, n.prototype._onHandleDragEnd = function() {
      this._dragging = false;
      var e = this._handle;
      if (e) {
        var t = this._axisPointerModel.get("value");
        this._moveHandleToValue(t), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, n.prototype.clear = function(e) {
      this._lastValue = null, this._lastStatus = null;
      var t = e.getZr(), r = this._group, i = this._handle;
      t && r && (this._lastGraphicKey = null, r && t.remove(r), i && t.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), F0(this, "_doDispatchAxisPointer");
    }, n.prototype.doClear = function() {
    }, n.prototype.buildLabel = function(e, t, r) {
      return r = r || 0, {
        x: e[r],
        y: e[1 - r],
        width: t[r],
        height: t[1 - r]
      };
    }, n;
  }();
  function QV(n, e, t, r) {
    oK(Dh(t).lastProp, r) || (Dh(t).lastProp = r, e ? Kt(t, r, n) : (t.stopAnimation(), t.attr(r)));
  }
  function oK(n, e) {
    if (Ze(n) && Ze(e)) {
      var t = true;
      return P(e, function(r, i) {
        t = t && oK(n[i], r);
      }), !!t;
    } else return n === e;
  }
  function JV(n, e) {
    n[e.get([
      "label",
      "show"
    ]) ? "show" : "hide"]();
  }
  function NT(n) {
    return {
      x: n.x || 0,
      y: n.y || 0,
      rotation: n.rotation || 0
    };
  }
  function eW(n, e, t) {
    var r = e.get("z"), i = e.get("zlevel");
    n && n.traverse(function(a) {
      a.type !== "group" && (r != null && (a.z = r), i != null && (a.zlevel = i), a.silent = t);
    });
  }
  function yM(n) {
    var e = n.get("type"), t = n.getModel(e + "Style"), r;
    return e === "line" ? (r = t.getLineStyle(), r.fill = null) : e === "shadow" && (r = t.getAreaStyle(), r.stroke = null), r;
  }
  function lK(n, e, t, r, i) {
    var a = t.get("value"), s = uK(a, e.axis, e.ecModel, t.get("seriesDataIndices"), {
      precision: t.get([
        "label",
        "precision"
      ]),
      formatter: t.get([
        "label",
        "formatter"
      ])
    }), o = t.getModel("label"), l = xm(o.get("padding") || 0), u = o.getFont(), c = Rx(s, u), h = i.position, d = c.width + l[1] + l[3], f = c.height + l[0] + l[2], p = i.align;
    p === "right" && (h[0] -= d), p === "center" && (h[0] -= d / 2);
    var g = i.verticalAlign;
    g === "bottom" && (h[1] -= f), g === "middle" && (h[1] -= f / 2), ywe(h, d, f, r);
    var m = o.get("backgroundColor");
    (!m || m === "auto") && (m = e.get([
      "axisLine",
      "lineStyle",
      "color"
    ])), n.label = {
      x: h[0],
      y: h[1],
      style: $n(o, {
        text: s,
        font: u,
        fill: o.getTextColor(),
        padding: l,
        backgroundColor: m
      }),
      z2: 10
    };
  }
  function ywe(n, e, t, r) {
    var i = r.getWidth(), a = r.getHeight();
    n[0] = Math.min(n[0] + e, i) - e, n[1] = Math.min(n[1] + t, a) - t, n[0] = Math.max(n[0], 0), n[1] = Math.max(n[1], 0);
  }
  function uK(n, e, t, r, i) {
    n = e.scale.parse(n);
    var a = e.scale.getLabel({
      value: n
    }, {
      precision: i.precision
    }), s = i.formatter;
    if (s) {
      var o = {
        value: AE(e, {
          value: n
        }),
        axisDimension: e.dim,
        axisIndex: e.index,
        seriesData: []
      };
      P(r, function(l) {
        var u = t.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
        h && o.seriesData.push(h);
      }), Ie(s) ? a = s.replace("{value}", a) : Xe(s) && (a = s(o));
    }
    return a;
  }
  function xM(n, e, t) {
    var r = za();
    return Md(r, r, t.rotation), Jo(r, r, t.position), Zs([
      n.dataToCoord(e),
      (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)
    ], r);
  }
  function cK(n, e, t, r, i, a) {
    var s = Zi.innerTextLayout(t.rotation, 0, t.labelDirection);
    t.labelMargin = i.get([
      "label",
      "margin"
    ]), lK(e, r, i, a, {
      position: xM(r.axis, n, t),
      align: s.textAlign,
      verticalAlign: s.textVerticalAlign
    });
  }
  function bM(n, e, t) {
    return t = t || 0, {
      x1: n[t],
      y1: n[1 - t],
      x2: e[t],
      y2: e[1 - t]
    };
  }
  function hK(n, e, t) {
    return t = t || 0, {
      x: n[t],
      y: n[1 - t],
      width: e[t],
      height: e[1 - t]
    };
  }
  function tW(n, e, t, r, i, a) {
    return {
      cx: n,
      cy: e,
      r0: t,
      r,
      startAngle: i,
      endAngle: a,
      clockwise: true
    };
  }
  var xwe = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, a, s) {
      var o = i.axis, l = o.grid, u = a.get("type"), c = nW(l, o).getOtherAxis(o).getGlobalExtent(), h = o.toGlobalCoord(o.dataToCoord(r, true));
      if (u && u !== "none") {
        var d = yM(a), f = bwe[u](o, h, c);
        f.style = d, t.graphicKey = f.type, t.pointer = f;
      }
      var p = yR(l.model, i);
      cK(r, t, p, i, a, s);
    }, e.prototype.getHandleTransform = function(t, r, i) {
      var a = yR(r.axis.grid.model, r, {
        labelInside: false
      });
      a.labelMargin = i.get([
        "handle",
        "margin"
      ]);
      var s = xM(r.axis, t, a);
      return {
        x: s[0],
        y: s[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, r, i, a) {
      var s = i.axis, o = s.grid, l = s.getGlobalExtent(true), u = nW(o, s).getOtherAxis(s).getGlobalExtent(), c = s.dim === "x" ? 0 : 1, h = [
        t.x,
        t.y
      ];
      h[c] += r[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var d = (u[1] + u[0]) / 2, f = [
        d,
        d
      ];
      f[c] = h[c];
      var p = [
        {
          verticalAlign: "middle"
        },
        {
          align: "center"
        }
      ];
      return {
        x: h[0],
        y: h[1],
        rotation: t.rotation,
        cursorPoint: f,
        tooltipOption: p[c]
      };
    }, e;
  }(vM);
  function nW(n, e) {
    var t = {};
    return t[e.dim + "AxisIndex"] = e.index, n.getCartesian(t);
  }
  var bwe = {
    line: function(n, e, t) {
      var r = bM([
        e,
        t[0]
      ], [
        e,
        t[1]
      ], rW(n));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: r
      };
    },
    shadow: function(n, e, t) {
      var r = Math.max(1, n.getBandWidth()), i = t[1] - t[0];
      return {
        type: "Rect",
        shape: hK([
          e - r / 2,
          t[0]
        ], [
          r,
          i
        ], rW(n))
      };
    }
  };
  function rW(n) {
    return n.dim === "x" ? 0 : 1;
  }
  var wwe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "axisPointer", e.defaultOption = {
      show: "auto",
      z: 50,
      type: "line",
      snap: false,
      triggerTooltip: true,
      triggerEmphasis: true,
      value: null,
      status: null,
      link: [],
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: true,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [
          5,
          7,
          5,
          7
        ],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: false,
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        margin: 50,
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        throttle: 40
      }
    }, e;
  }(Et), Al = Wt(), _we = P;
  function dK(n, e, t) {
    if (!Dt.node) {
      var r = e.getZr();
      Al(r).records || (Al(r).records = {}), Swe(r, e);
      var i = Al(r).records[n] || (Al(r).records[n] = {});
      i.handler = t;
    }
  }
  function Swe(n, e) {
    if (Al(n).initialized) return;
    Al(n).initialized = true, t("click", lt(iW, "click")), t("mousemove", lt(iW, "mousemove")), t("globalout", Iwe);
    function t(r, i) {
      n.on(r, function(a) {
        var s = kwe(e);
        _we(Al(n).records, function(o) {
          o && i(o, a, s.dispatchAction);
        }), Cwe(s.pendings, e);
      });
    }
  }
  function Cwe(n, e) {
    var t = n.showTip.length, r = n.hideTip.length, i;
    t ? i = n.showTip[t - 1] : r && (i = n.hideTip[r - 1]), i && (i.dispatchAction = null, e.dispatchAction(i));
  }
  function Iwe(n, e, t) {
    n.handler("leave", null, t);
  }
  function iW(n, e, t, r) {
    e.handler(n, t, r);
  }
  function kwe(n) {
    var e = {
      showTip: [],
      hideTip: []
    }, t = function(r) {
      var i = e[r.type];
      i ? i.push(r) : (r.dispatchAction = t, n.dispatchAction(r));
    };
    return {
      dispatchAction: t,
      pendings: e
    };
  }
  function BR(n, e) {
    if (!Dt.node) {
      var t = e.getZr(), r = (Al(t).records || {})[n];
      r && (Al(t).records[n] = null);
    }
  }
  var Twe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = r.getComponent("tooltip"), s = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      dK("axisPointer", i, function(o, l, u) {
        s !== "none" && (o === "leave" || s.indexOf(o) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: o,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, e.prototype.remove = function(t, r) {
      BR("axisPointer", r);
    }, e.prototype.dispose = function(t, r) {
      BR("axisPointer", r);
    }, e.type = "axisPointer", e;
  }(Yn);
  function fK(n, e) {
    var t = [], r = n.seriesIndex, i;
    if (r == null || !(i = e.getSeriesByIndex(r))) return {
      point: []
    };
    var a = i.getData(), s = cd(a, n);
    if (s == null || s < 0 || de(s)) return {
      point: []
    };
    var o = a.getItemGraphicEl(s), l = i.coordinateSystem;
    if (i.getTooltipPosition) t = i.getTooltipPosition(s) || [];
    else if (l && l.dataToPoint) if (n.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, d = u.dim, f = h === "x" || h === "radius" ? 1 : 0, p = a.mapDimension(d), g = [];
      g[f] = a.get(p, s), g[1 - f] = a.get(a.getCalculationInfo("stackResultDimension"), s), t = l.dataToPoint(g) || [];
    } else t = l.dataToPoint(a.getValues(me(l.dimensions, function(v) {
      return a.mapDimension(v);
    }), s)) || [];
    else if (o) {
      var m = o.getBoundingRect().clone();
      m.applyTransform(o.transform), t = [
        m.x + m.width / 2,
        m.y + m.height / 2
      ];
    }
    return {
      point: t,
      el: o
    };
  }
  var aW = Wt();
  function Awe(n, e, t) {
    var r = n.currTrigger, i = [
      n.x,
      n.y
    ], a = n, s = n.dispatchAction || Ae(t.dispatchAction, t), o = e.getComponent("axisPointer").coordSysAxesInfo;
    if (o) {
      h_(i) && (i = fK({
        seriesIndex: a.seriesIndex,
        dataIndex: a.dataIndex
      }, e).point);
      var l = h_(i), u = a.axesInfo, c = o.axesInfo, h = r === "leave" || h_(i), d = {}, f = {}, p = {
        list: [],
        map: {}
      }, g = {
        showPointer: lt(Rwe, f),
        showTooltip: lt($we, p)
      };
      P(o.coordSysMap, function(v, y) {
        var x = l || v.containPoint(i);
        P(o.coordSysAxesInfo[y], function(b, w) {
          var _ = b.axis, S = Pwe(u, b);
          if (!h && x && (!u || S)) {
            var I = S && S.value;
            I == null && !l && (I = _.pointToData(i)), I != null && sW(b, I, g, false, d);
          }
        });
      });
      var m = {};
      return P(c, function(v, y) {
        var x = v.linkGroup;
        x && !f[y] && P(x.axesInfo, function(b, w) {
          var _ = f[w];
          if (b !== v && _) {
            var S = _.value;
            x.mapper && (S = v.axis.scale.parse(x.mapper(S, oW(b), oW(v)))), m[v.key] = S;
          }
        });
      }), P(m, function(v, y) {
        sW(c[y], v, g, true, d);
      }), Nwe(f, c, d), Ewe(p, i, n, s), Mwe(c, s, t), d;
    }
  }
  function sW(n, e, t, r, i) {
    var a = n.axis;
    if (!(a.scale.isBlank() || !a.containData(e))) {
      if (!n.involveSeries) {
        t.showPointer(n, e);
        return;
      }
      var s = Dwe(e, n), o = s.payloadBatch, l = s.snapToValue;
      o[0] && i.seriesIndex == null && oe(i, o[0]), !r && n.snap && a.containData(l) && l != null && (e = l), t.showPointer(n, e, o), t.showTooltip(n, s, l);
    }
  }
  function Dwe(n, e) {
    var t = e.axis, r = t.dim, i = n, a = [], s = Number.MAX_VALUE, o = -1;
    return P(e.seriesModels, function(l, u) {
      var c = l.getData().mapDimensionsAll(r), h, d;
      if (l.getAxisTooltipData) {
        var f = l.getAxisTooltipData(c, n, t);
        d = f.dataIndices, h = f.nestestValue;
      } else {
        if (d = l.getData().indicesOfNearest(c[0], n, t.type === "category" ? 0.5 : null), !d.length) return;
        h = l.getData().get(c[0], d[0]);
      }
      if (!(h == null || !isFinite(h))) {
        var p = n - h, g = Math.abs(p);
        g <= s && ((g < s || p >= 0 && o < 0) && (s = g, o = p, i = h, a.length = 0), P(d, function(m) {
          a.push({
            seriesIndex: l.seriesIndex,
            dataIndexInside: m,
            dataIndex: l.getData().getRawIndex(m)
          });
        }));
      }
    }), {
      payloadBatch: a,
      snapToValue: i
    };
  }
  function Rwe(n, e, t, r) {
    n[e.key] = {
      value: t,
      payloadBatch: r
    };
  }
  function $we(n, e, t, r) {
    var i = t.payloadBatch, a = e.axis, s = a.model, o = e.axisPointerModel;
    if (!(!e.triggerTooltip || !i.length)) {
      var l = e.coordSys.model, u = U0(l), c = n.map[u];
      c || (c = n.map[u] = {
        coordSysId: l.id,
        coordSysIndex: l.componentIndex,
        coordSysType: l.type,
        coordSysMainType: l.mainType,
        dataByAxis: []
      }, n.list.push(c)), c.dataByAxis.push({
        axisDim: a.dim,
        axisIndex: s.componentIndex,
        axisType: s.type,
        axisId: s.id,
        value: r,
        valueLabelOpt: {
          precision: o.get([
            "label",
            "precision"
          ]),
          formatter: o.get([
            "label",
            "formatter"
          ])
        },
        seriesDataIndices: i.slice()
      });
    }
  }
  function Nwe(n, e, t) {
    var r = t.axesInfo = [];
    P(e, function(i, a) {
      var s = i.axisPointerModel.option, o = n[a];
      o ? (!i.useHandle && (s.status = "show"), s.value = o.value, s.seriesDataIndices = (o.payloadBatch || []).slice()) : !i.useHandle && (s.status = "hide"), s.status === "show" && r.push({
        axisDim: i.axis.dim,
        axisIndex: i.axis.model.componentIndex,
        value: s.value
      });
    });
  }
  function Ewe(n, e, t, r) {
    if (h_(e) || !n.list.length) {
      r({
        type: "hideTip"
      });
      return;
    }
    var i = ((n.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    r({
      type: "showTip",
      escapeConnect: true,
      x: e[0],
      y: e[1],
      tooltipOption: t.tooltipOption,
      position: t.position,
      dataIndexInside: i.dataIndexInside,
      dataIndex: i.dataIndex,
      seriesIndex: i.seriesIndex,
      dataByCoordSys: n.list
    });
  }
  function Mwe(n, e, t) {
    var r = t.getZr(), i = "axisPointerLastHighlights", a = aW(r)[i] || {}, s = aW(r)[i] = {};
    P(n, function(u, c) {
      var h = u.axisPointerModel.option;
      h.status === "show" && u.triggerEmphasis && P(h.seriesDataIndices, function(d) {
        var f = d.seriesIndex + " | " + d.dataIndex;
        s[f] = d;
      });
    });
    var o = [], l = [];
    P(a, function(u, c) {
      !s[c] && l.push(u);
    }), P(s, function(u, c) {
      !a[c] && o.push(u);
    }), l.length && t.dispatchAction({
      type: "downplay",
      escapeConnect: true,
      notBlur: true,
      batch: l
    }), o.length && t.dispatchAction({
      type: "highlight",
      escapeConnect: true,
      notBlur: true,
      batch: o
    });
  }
  function Pwe(n, e) {
    for (var t = 0; t < (n || []).length; t++) {
      var r = n[t];
      if (e.axis.dim === r.axisDim && e.axis.model.componentIndex === r.axisIndex) return r;
    }
  }
  function oW(n) {
    var e = n.axis.model, t = {}, r = t.axisDim = n.axis.dim;
    return t.axisIndex = t[r + "AxisIndex"] = e.componentIndex, t.axisName = t[r + "AxisName"] = e.name, t.axisId = t[r + "AxisId"] = e.id, t;
  }
  function h_(n) {
    return !n || n[0] == null || isNaN(n[0]) || n[1] == null || isNaN(n[1]);
  }
  function Kx(n) {
    zd.registerAxisPointerClass("CartesianAxisPointer", xwe), n.registerComponentModel(wwe), n.registerComponentView(Twe), n.registerPreprocessor(function(e) {
      if (e) {
        (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
        var t = e.axisPointer.link;
        t && !de(t) && (e.axisPointer.link = [
          t
        ]);
      }
    }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function(e, t) {
      e.getComponent("axisPointer").coordSysAxesInfo = Hme(e, t);
    }), n.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, Awe);
  }
  function Lwe(n) {
    Ct(Vq), Ct(Kx);
  }
  var Fwe = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, a, s) {
      var o = i.axis;
      o.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = o.polar, u = l.getOtherAxis(o), c = u.getExtent(), h = o.dataToCoord(r), d = a.get("type");
      if (d && d !== "none") {
        var f = yM(a), p = Bwe[d](o, l, h, c);
        p.style = f, t.graphicKey = p.type, t.pointer = p;
      }
      var g = a.get([
        "label",
        "margin"
      ]), m = Owe(r, i, a, l, g);
      lK(t, i, a, s, m);
    }, e;
  }(vM);
  function Owe(n, e, t, r, i) {
    var a = e.axis, s = a.dataToCoord(n), o = r.getAngleAxis().getExtent()[0];
    o = o / 180 * Math.PI;
    var l = r.getRadiusAxis().getExtent(), u, c, h;
    if (a.dim === "radius") {
      var d = za();
      Md(d, d, o), Jo(d, d, [
        r.cx,
        r.cy
      ]), u = Zs([
        s,
        -i
      ], d);
      var f = e.getModel("axisLabel").get("rotate") || 0, p = Zi.innerTextLayout(o, f * Math.PI / 180, -1);
      c = p.textAlign, h = p.textVerticalAlign;
    } else {
      var g = l[1];
      u = r.coordToPoint([
        g + i,
        s
      ]);
      var m = r.cx, v = r.cy;
      c = Math.abs(u[0] - m) / g < 0.3 ? "center" : u[0] > m ? "left" : "right", h = Math.abs(u[1] - v) / g < 0.3 ? "middle" : u[1] > v ? "top" : "bottom";
    }
    return {
      position: u,
      align: c,
      verticalAlign: h
    };
  }
  var Bwe = {
    line: function(n, e, t, r) {
      return n.dim === "angle" ? {
        type: "Line",
        shape: bM(e.coordToPoint([
          r[0],
          t
        ]), e.coordToPoint([
          r[1],
          t
        ]))
      } : {
        type: "Circle",
        shape: {
          cx: e.cx,
          cy: e.cy,
          r: t
        }
      };
    },
    shadow: function(n, e, t, r) {
      var i = Math.max(1, n.getBandWidth()), a = Math.PI / 180;
      return n.dim === "angle" ? {
        type: "Sector",
        shape: tW(e.cx, e.cy, r[0], r[1], (-t - i / 2) * a, (-t + i / 2) * a)
      } : {
        type: "Sector",
        shape: tW(e.cx, e.cy, t - i / 2, t + i / 2, 0, Math.PI * 2)
      };
    }
  }, zwe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.findAxisModel = function(t) {
      var r, i = this.ecModel;
      return i.eachComponent(t, function(a) {
        a.getCoordSysModel() === this && (r = a);
      }, this), r;
    }, e.type = "polar", e.dependencies = [
      "radiusAxis",
      "angleAxis"
    ], e.defaultOption = {
      z: 0,
      center: [
        "50%",
        "50%"
      ],
      radius: "80%"
    }, e;
  }(Et), wM = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", yr).models[0];
    }, e.type = "polarAxis", e;
  }(Et);
  br(wM, Vx);
  var Vwe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "angleAxis", e;
  }(wM), Wwe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "radiusAxis", e;
  }(wM), _M = function(n) {
    K(e, n);
    function e(t, r) {
      return n.call(this, "radius", t, r) || this;
    }
    return e.prototype.pointToData = function(t, r) {
      return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1];
    }, e;
  }(fo);
  _M.prototype.dataToRadius = fo.prototype.dataToCoord;
  _M.prototype.radiusToData = fo.prototype.coordToData;
  var Gwe = Wt(), SM = function(n) {
    K(e, n);
    function e(t, r) {
      return n.call(this, "angle", t, r || [
        0,
        360
      ]) || this;
    }
    return e.prototype.pointToData = function(t, r) {
      return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1];
    }, e.prototype.calculateCategoryInterval = function() {
      var t = this, r = t.getLabelModel(), i = t.scale, a = i.getExtent(), s = i.count();
      if (a[1] - a[0] < 1) return 0;
      var o = a[0], l = t.dataToCoord(o + 1) - t.dataToCoord(o), u = Math.abs(l), c = Rx(o == null ? "" : o + "", r.getFont(), "center", "top"), h = Math.max(c.height, 7), d = h / u;
      isNaN(d) && (d = 1 / 0);
      var f = Math.max(0, Math.floor(d)), p = Gwe(t.model), g = p.lastAutoInterval, m = p.lastTickCount;
      return g != null && m != null && Math.abs(g - f) <= 1 && Math.abs(m - s) <= 1 && g > f ? f = g : (p.lastTickCount = s, p.lastAutoInterval = f), f;
    }, e;
  }(fo);
  SM.prototype.dataToAngle = fo.prototype.dataToCoord;
  SM.prototype.angleToData = fo.prototype.coordToData;
  var pK = [
    "radius",
    "angle"
  ], Uwe = function() {
    function n(e) {
      this.dimensions = pK, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new _M(), this._angleAxis = new SM(), this.axisPointerEnabled = true, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return n.prototype.containPoint = function(e) {
      var t = this.pointToCoord(e);
      return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1]);
    }, n.prototype.containData = function(e) {
      return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]);
    }, n.prototype.getAxis = function(e) {
      var t = "_" + e + "Axis";
      return this[t];
    }, n.prototype.getAxes = function() {
      return [
        this._radiusAxis,
        this._angleAxis
      ];
    }, n.prototype.getAxesByScale = function(e) {
      var t = [], r = this._angleAxis, i = this._radiusAxis;
      return r.scale.type === e && t.push(r), i.scale.type === e && t.push(i), t;
    }, n.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, n.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, n.prototype.getOtherAxis = function(e) {
      var t = this._angleAxis;
      return e === t ? this._radiusAxis : t;
    }, n.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, n.prototype.getTooltipAxes = function(e) {
      var t = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis();
      return {
        baseAxes: [
          t
        ],
        otherAxes: [
          this.getOtherAxis(t)
        ]
      };
    }, n.prototype.dataToPoint = function(e, t) {
      return this.coordToPoint([
        this._radiusAxis.dataToRadius(e[0], t),
        this._angleAxis.dataToAngle(e[1], t)
      ]);
    }, n.prototype.pointToData = function(e, t) {
      var r = this.pointToCoord(e);
      return [
        this._radiusAxis.radiusToData(r[0], t),
        this._angleAxis.angleToData(r[1], t)
      ];
    }, n.prototype.pointToCoord = function(e) {
      var t = e[0] - this.cx, r = e[1] - this.cy, i = this.getAngleAxis(), a = i.getExtent(), s = Math.min(a[0], a[1]), o = Math.max(a[0], a[1]);
      i.inverse ? s = o - 360 : o = s + 360;
      var l = Math.sqrt(t * t + r * r);
      t /= l, r /= l;
      for (var u = Math.atan2(-r, t) / Math.PI * 180, c = u < s ? 1 : -1; u < s || u > o; ) u += c * 360;
      return [
        l,
        u
      ];
    }, n.prototype.coordToPoint = function(e) {
      var t = e[0], r = e[1] / 180 * Math.PI, i = Math.cos(r) * t + this.cx, a = -Math.sin(r) * t + this.cy;
      return [
        i,
        a
      ];
    }, n.prototype.getArea = function() {
      var e = this.getAngleAxis(), t = this.getRadiusAxis(), r = t.getExtent().slice();
      r[0] > r[1] && r.reverse();
      var i = e.getExtent(), a = Math.PI / 180, s = 1e-4;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: r[0],
        r: r[1],
        startAngle: -i[0] * a,
        endAngle: -i[1] * a,
        clockwise: e.inverse,
        contain: function(o, l) {
          var u = o - this.cx, c = l - this.cy, h = u * u + c * c, d = this.r, f = this.r0;
          return d !== f && h - s <= d * d && h + s >= f * f;
        }
      };
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = lW(t);
      return i === this ? this.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = lW(t);
      return i === this ? this.pointToData(r) : null;
    }, n;
  }();
  function lW(n) {
    var e = n.seriesModel, t = n.polarModel;
    return t && t.coordinateSystem || e && e.coordinateSystem;
  }
  function Hwe(n, e, t) {
    var r = e.get("center"), i = t.getWidth(), a = t.getHeight();
    n.cx = _e(r[0], i), n.cy = _e(r[1], a);
    var s = n.getRadiusAxis(), o = Math.min(i, a) / 2, l = e.get("radius");
    l == null ? l = [
      0,
      "100%"
    ] : de(l) || (l = [
      0,
      l
    ]);
    var u = [
      _e(l[0], o),
      _e(l[1], o)
    ];
    s.inverse ? s.setExtent(u[1], u[0]) : s.setExtent(u[0], u[1]);
  }
  function Xwe(n, e) {
    var t = this, r = t.getAngleAxis(), i = t.getRadiusAxis();
    if (r.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), n.eachSeries(function(o) {
      if (o.coordinateSystem === t) {
        var l = o.getData();
        P(eS(l, "radius"), function(u) {
          i.scale.unionExtentFromData(l, u);
        }), P(eS(l, "angle"), function(u) {
          r.scale.unionExtentFromData(l, u);
        });
      }
    }), Fg(r.scale, r.model), Fg(i.scale, i.model), r.type === "category" && !r.onBand) {
      var a = r.getExtent(), s = 360 / r.scale.count();
      r.inverse ? a[1] += s : a[1] -= s, r.setExtent(a[0], a[1]);
    }
  }
  function Ywe(n) {
    return n.mainType === "angleAxis";
  }
  function uW(n, e) {
    var t;
    if (n.type = e.get("type"), n.scale = VC(e), n.onBand = e.get("boundaryGap") && n.type === "category", n.inverse = e.get("inverse"), Ywe(e)) {
      n.inverse = n.inverse !== e.get("clockwise");
      var r = e.get("startAngle"), i = (t = e.get("endAngle")) !== null && t !== void 0 ? t : r + (n.inverse ? -360 : 360);
      n.setExtent(r, i);
    }
    e.axis = n, n.model = e;
  }
  var qwe = {
    dimensions: pK,
    create: function(n, e) {
      var t = [];
      return n.eachComponent("polar", function(r, i) {
        var a = new Uwe(i + "");
        a.update = Xwe;
        var s = a.getRadiusAxis(), o = a.getAngleAxis(), l = r.findAxisModel("radiusAxis"), u = r.findAxisModel("angleAxis");
        uW(s, l), uW(o, u), Hwe(a, r, e), t.push(a), r.coordinateSystem = a, a.model = r;
      }), n.eachSeries(function(r) {
        if (r.get("coordinateSystem") === "polar") {
          var i = r.getReferringComponents("polar", yr).models[0];
          r.coordinateSystem = i.coordinateSystem;
        }
      }), t;
    }
  }, jwe = [
    "axisLine",
    "axisLabel",
    "axisTick",
    "minorTick",
    "splitLine",
    "minorSplitLine",
    "splitArea"
  ];
  function iw(n, e, t) {
    e[1] > e[0] && (e = e.slice().reverse());
    var r = n.coordToPoint([
      e[0],
      t
    ]), i = n.coordToPoint([
      e[1],
      t
    ]);
    return {
      x1: r[0],
      y1: r[1],
      x2: i[0],
      y2: i[1]
    };
  }
  function aw(n) {
    var e = n.getRadiusAxis();
    return e.inverse ? 0 : 1;
  }
  function cW(n) {
    var e = n[0], t = n[n.length - 1];
    e && t && Math.abs(Math.abs(e.coord - t.coord) - 360) < 1e-4 && n.pop();
  }
  var Kwe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, r) {
      if (this.group.removeAll(), !!t.get("show")) {
        var i = t.axis, a = i.polar, s = a.getRadiusAxis().getExtent(), o = i.getTicksCoords(), l = i.getMinorTicksCoords(), u = me(i.getViewLabels(), function(c) {
          c = Qe(c);
          var h = i.scale, d = h.type === "ordinal" ? h.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(d), c;
        });
        cW(u), cW(o), P(jwe, function(c) {
          t.get([
            c,
            "show"
          ]) && (!i.scale.isBlank() || c === "axisLine") && Zwe[c](this.group, t, a, o, l, s, u);
        }, this);
      }
    }, e.type = "angleAxis", e;
  }(zd), Zwe = {
    axisLine: function(n, e, t, r, i, a) {
      var s = e.getModel([
        "axisLine",
        "lineStyle"
      ]), o = t.getAngleAxis(), l = Math.PI / 180, u = o.getExtent(), c = aw(t), h = c ? 0 : 1, d, f = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
      a[h] === 0 ? d = new Ld[f]({
        shape: {
          cx: t.cx,
          cy: t.cy,
          r: a[c],
          startAngle: -u[0] * l,
          endAngle: -u[1] * l,
          clockwise: o.inverse
        },
        style: s.getLineStyle(),
        z2: 1,
        silent: true
      }) : d = new Ex({
        shape: {
          cx: t.cx,
          cy: t.cy,
          r: a[c],
          r0: a[h]
        },
        style: s.getLineStyle(),
        z2: 1,
        silent: true
      }), d.style.fill = null, n.add(d);
    },
    axisTick: function(n, e, t, r, i, a) {
      var s = e.getModel("axisTick"), o = (s.get("inside") ? -1 : 1) * s.get("length"), l = a[aw(t)], u = me(r, function(c) {
        return new zr({
          shape: iw(t, [
            l,
            l + o
          ], c.coord)
        });
      });
      n.add(ps(u, {
        style: je(s.getModel("lineStyle").getLineStyle(), {
          stroke: e.get([
            "axisLine",
            "lineStyle",
            "color"
          ])
        })
      }));
    },
    minorTick: function(n, e, t, r, i, a) {
      if (i.length) {
        for (var s = e.getModel("axisTick"), o = e.getModel("minorTick"), l = (s.get("inside") ? -1 : 1) * o.get("length"), u = a[aw(t)], c = [], h = 0; h < i.length; h++) for (var d = 0; d < i[h].length; d++) c.push(new zr({
          shape: iw(t, [
            u,
            u + l
          ], i[h][d].coord)
        }));
        n.add(ps(c, {
          style: je(o.getModel("lineStyle").getLineStyle(), je(s.getLineStyle(), {
            stroke: e.get([
              "axisLine",
              "lineStyle",
              "color"
            ])
          }))
        }));
      }
    },
    axisLabel: function(n, e, t, r, i, a, s) {
      var o = e.getCategories(true), l = e.getModel("axisLabel"), u = l.get("margin"), c = e.get("triggerEvent");
      P(s, function(h, d) {
        var f = l, p = h.tickValue, g = a[aw(t)], m = t.coordToPoint([
          g + u,
          h.coord
        ]), v = t.cx, y = t.cy, x = Math.abs(m[0] - v) / g < 0.3 ? "center" : m[0] > v ? "left" : "right", b = Math.abs(m[1] - y) / g < 0.3 ? "middle" : m[1] > y ? "top" : "bottom";
        if (o && o[p]) {
          var w = o[p];
          Ze(w) && w.textStyle && (f = new on(w.textStyle, l, l.ecModel));
        }
        var _ = new Gt({
          silent: Zi.isLabelSilent(e),
          style: $n(f, {
            x: m[0],
            y: m[1],
            fill: f.getTextColor() || e.get([
              "axisLine",
              "lineStyle",
              "color"
            ]),
            text: h.formattedLabel,
            align: x,
            verticalAlign: b
          })
        });
        if (n.add(_), c) {
          var S = Zi.makeAxisEventDataBase(e);
          S.targetType = "axisLabel", S.value = h.rawLabel, rt(_).eventData = S;
        }
      }, this);
    },
    splitLine: function(n, e, t, r, i, a) {
      var s = e.getModel("splitLine"), o = s.getModel("lineStyle"), l = o.get("color"), u = 0;
      l = l instanceof Array ? l : [
        l
      ];
      for (var c = [], h = 0; h < r.length; h++) {
        var d = u++ % l.length;
        c[d] = c[d] || [], c[d].push(new zr({
          shape: iw(t, a, r[h].coord)
        }));
      }
      for (var h = 0; h < c.length; h++) n.add(ps(c[h], {
        style: je({
          stroke: l[h % l.length]
        }, o.getLineStyle()),
        silent: true,
        z: e.get("z")
      }));
    },
    minorSplitLine: function(n, e, t, r, i, a) {
      if (i.length) {
        for (var s = e.getModel("minorSplitLine"), o = s.getModel("lineStyle"), l = [], u = 0; u < i.length; u++) for (var c = 0; c < i[u].length; c++) l.push(new zr({
          shape: iw(t, a, i[u][c].coord)
        }));
        n.add(ps(l, {
          style: o.getLineStyle(),
          silent: true,
          z: e.get("z")
        }));
      }
    },
    splitArea: function(n, e, t, r, i, a) {
      if (r.length) {
        var s = e.getModel("splitArea"), o = s.getModel("areaStyle"), l = o.get("color"), u = 0;
        l = l instanceof Array ? l : [
          l
        ];
        for (var c = [], h = Math.PI / 180, d = -r[0].coord * h, f = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), g = e.get("clockwise"), m = 1, v = r.length; m <= v; m++) {
          var y = m === v ? r[0].coord : r[m].coord, x = u++ % l.length;
          c[x] = c[x] || [], c[x].push(new ra({
            shape: {
              cx: t.cx,
              cy: t.cy,
              r0: f,
              r: p,
              startAngle: d,
              endAngle: -y * h,
              clockwise: g
            },
            silent: true
          })), d = -y * h;
        }
        for (var m = 0; m < c.length; m++) n.add(ps(c[m], {
          style: je({
            fill: l[m % l.length]
          }, o.getAreaStyle()),
          silent: true
        }));
      }
    }
  }, Qwe = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], Jwe = [
    "splitLine",
    "splitArea",
    "minorSplitLine"
  ], e_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, r) {
      if (this.group.removeAll(), !!t.get("show")) {
        var i = this._axisGroup, a = this._axisGroup = new tt();
        this.group.add(a);
        var s = t.axis, o = s.polar, l = o.getAngleAxis(), u = s.getTicksCoords(), c = s.getMinorTicksCoords(), h = l.getExtent()[0], d = s.getExtent(), f = n_e(o, t, h), p = new Zi(t, f);
        P(Qwe, p.add, p), a.add(p.getGroup()), Lx(i, a, t), P(Jwe, function(g) {
          t.get([
            g,
            "show"
          ]) && !s.scale.isBlank() && t_e[g](this.group, t, o, h, d, u, c);
        }, this);
      }
    }, e.type = "radiusAxis", e;
  }(zd), t_e = {
    splitLine: function(n, e, t, r, i, a) {
      var s = e.getModel("splitLine"), o = s.getModel("lineStyle"), l = o.get("color"), u = 0, c = t.getAngleAxis(), h = Math.PI / 180, d = c.getExtent(), f = Math.abs(d[1] - d[0]) === 360 ? "Circle" : "Arc";
      l = l instanceof Array ? l : [
        l
      ];
      for (var p = [], g = 0; g < a.length; g++) {
        var m = u++ % l.length;
        p[m] = p[m] || [], p[m].push(new Ld[f]({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r: Math.max(a[g].coord, 0),
            startAngle: -d[0] * h,
            endAngle: -d[1] * h,
            clockwise: c.inverse
          }
        }));
      }
      for (var g = 0; g < p.length; g++) n.add(ps(p[g], {
        style: je({
          stroke: l[g % l.length],
          fill: null
        }, o.getLineStyle()),
        silent: true
      }));
    },
    minorSplitLine: function(n, e, t, r, i, a, s) {
      if (s.length) {
        for (var o = e.getModel("minorSplitLine"), l = o.getModel("lineStyle"), u = [], c = 0; c < s.length; c++) for (var h = 0; h < s[c].length; h++) u.push(new iu({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r: s[c][h].coord
          }
        }));
        n.add(ps(u, {
          style: je({
            fill: null
          }, l.getLineStyle()),
          silent: true
        }));
      }
    },
    splitArea: function(n, e, t, r, i, a) {
      if (a.length) {
        var s = e.getModel("splitArea"), o = s.getModel("areaStyle"), l = o.get("color"), u = 0;
        l = l instanceof Array ? l : [
          l
        ];
        for (var c = [], h = a[0].coord, d = 1; d < a.length; d++) {
          var f = u++ % l.length;
          c[f] = c[f] || [], c[f].push(new ra({
            shape: {
              cx: t.cx,
              cy: t.cy,
              r0: h,
              r: a[d].coord,
              startAngle: 0,
              endAngle: Math.PI * 2
            },
            silent: true
          })), h = a[d].coord;
        }
        for (var d = 0; d < c.length; d++) n.add(ps(c[d], {
          style: je({
            fill: l[d % l.length]
          }, o.getAreaStyle()),
          silent: true
        }));
      }
    }
  };
  function n_e(n, e, t) {
    return {
      position: [
        n.cx,
        n.cy
      ],
      rotation: t / 180 * Math.PI,
      labelDirection: -1,
      tickDirection: -1,
      nameDirection: 1,
      labelRotate: e.getModel("axisLabel").get("rotate"),
      z2: 1
    };
  }
  function gK(n) {
    return n.get("stack") || "__ec_stack_" + n.seriesIndex;
  }
  function mK(n, e) {
    return e.dim + n.model.componentIndex;
  }
  function r_e(n, e, t) {
    var r = {}, i = i_e(rn(e.getSeriesByType(n), function(a) {
      return !e.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
    }));
    e.eachSeriesByType(n, function(a) {
      if (a.coordinateSystem.type === "polar") {
        var s = a.getData(), o = a.coordinateSystem, l = o.getBaseAxis(), u = mK(o, l), c = gK(a), h = i[u][c], d = h.offset, f = h.width, p = o.getOtherAxis(l), g = a.coordinateSystem.cx, m = a.coordinateSystem.cy, v = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
        r[c] = r[c] || [];
        for (var x = s.mapDimension(p.dim), b = s.mapDimension(l.dim), w = ic(s, x), _ = l.dim !== "radius" || !a.get("roundCap", true), S = p.model, I = S.get("startValue"), C = p.dataToCoord(I || 0), T = 0, k = s.count(); T < k; T++) {
          var D = s.get(x, T), R = s.get(b, T), N = D >= 0 ? "p" : "n", E = C;
          w && (r[c][R] || (r[c][R] = {
            p: C,
            n: C
          }), E = r[c][R][N]);
          var A = void 0, M = void 0, $ = void 0, L = void 0;
          if (p.dim === "radius") {
            var F = p.dataToCoord(D) - C, O = l.dataToCoord(R);
            Math.abs(F) < v && (F = (F < 0 ? -1 : 1) * v), A = E, M = E + F, $ = O - d, L = $ - f, w && (r[c][R][N] = M);
          } else {
            var z = p.dataToCoord(D, _) - C, V = l.dataToCoord(R);
            Math.abs(z) < y && (z = (z < 0 ? -1 : 1) * y), A = V + d, M = A + f, $ = E, L = E + z, w && (r[c][R][N] = L);
          }
          s.setItemLayout(T, {
            cx: g,
            cy: m,
            r0: A,
            r: M,
            startAngle: -$ * Math.PI / 180,
            endAngle: -L * Math.PI / 180,
            clockwise: $ >= L
          });
        }
      }
    });
  }
  function i_e(n) {
    var e = {};
    P(n, function(r, i) {
      var a = r.getData(), s = r.coordinateSystem, o = s.getBaseAxis(), l = mK(s, o), u = o.getExtent(), c = o.type === "category" ? o.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), h = e[l] || {
        bandWidth: c,
        remainedWidth: c,
        autoWidthCount: 0,
        categoryGap: "20%",
        gap: "30%",
        stacks: {}
      }, d = h.stacks;
      e[l] = h;
      var f = gK(r);
      d[f] || h.autoWidthCount++, d[f] = d[f] || {
        width: 0,
        maxWidth: 0
      };
      var p = _e(r.get("barWidth"), c), g = _e(r.get("barMaxWidth"), c), m = r.get("barGap"), v = r.get("barCategoryGap");
      p && !d[f].width && (p = Math.min(h.remainedWidth, p), d[f].width = p, h.remainedWidth -= p), g && (d[f].maxWidth = g), m != null && (h.gap = m), v != null && (h.categoryGap = v);
    });
    var t = {};
    return P(e, function(r, i) {
      t[i] = {};
      var a = r.stacks, s = r.bandWidth, o = _e(r.categoryGap, s), l = _e(r.gap, 1), u = r.remainedWidth, c = r.autoWidthCount, h = (u - o) / (c + (c - 1) * l);
      h = Math.max(h, 0), P(a, function(g, m) {
        var v = g.maxWidth;
        v && v < h && (v = Math.min(v, u), g.width && (v = Math.min(v, g.width)), u -= v, g.width = v, c--);
      }), h = (u - o) / (c + (c - 1) * l), h = Math.max(h, 0);
      var d = 0, f;
      P(a, function(g, m) {
        g.width || (g.width = h), f = g, d += g.width * (1 + l);
      }), f && (d -= f.width * l);
      var p = -d / 2;
      P(a, function(g, m) {
        t[i][m] = t[i][m] || {
          offset: p,
          width: g.width
        }, p += g.width * (1 + l);
      });
    }), t;
  }
  var a_e = {
    startAngle: 90,
    clockwise: true,
    splitNumber: 12,
    axisLabel: {
      rotate: 0
    }
  }, s_e = {
    splitNumber: 5
  }, o_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "polar", e;
  }(Yn);
  function l_e(n) {
    Ct(Kx), zd.registerAxisPointerClass("PolarAxisPointer", Fwe), n.registerCoordinateSystem("polar", qwe), n.registerComponentModel(zwe), n.registerComponentView(o_e), Bg(n, "angle", Vwe, a_e), Bg(n, "radius", Wwe, s_e), n.registerComponentView(Kwe), n.registerComponentView(e_e), n.registerLayout(lt(r_e, "bar"));
  }
  function zR(n, e) {
    e = e || {};
    var t = n.coordinateSystem, r = n.axis, i = {}, a = r.position, s = r.orient, o = t.getRect(), l = [
      o.x,
      o.x + o.width,
      o.y,
      o.y + o.height
    ], u = {
      horizontal: {
        top: l[2],
        bottom: l[3]
      },
      vertical: {
        left: l[0],
        right: l[1]
      }
    };
    i.position = [
      s === "vertical" ? u.vertical[a] : l[0],
      s === "horizontal" ? u.horizontal[a] : l[3]
    ];
    var c = {
      horizontal: 0,
      vertical: 1
    };
    i.rotation = Math.PI / 2 * c[s];
    var h = {
      top: -1,
      bottom: 1,
      right: 1,
      left: -1
    };
    i.labelDirection = i.tickDirection = i.nameDirection = h[a], n.get([
      "axisTick",
      "inside"
    ]) && (i.tickDirection = -i.tickDirection), ni(e.labelInside, n.get([
      "axisLabel",
      "inside"
    ])) && (i.labelDirection = -i.labelDirection);
    var d = e.rotate;
    return d == null && (d = n.get([
      "axisLabel",
      "rotate"
    ])), i.labelRotation = a === "top" ? -d : d, i.z2 = 1, i;
  }
  var u_e = [
    "axisLine",
    "axisTickLabel",
    "axisName"
  ], c_e = [
    "splitArea",
    "splitLine"
  ], h_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "SingleAxisPointer", t;
    }
    return e.prototype.render = function(t, r, i, a) {
      var s = this.group;
      s.removeAll();
      var o = this._axisGroup;
      this._axisGroup = new tt();
      var l = zR(t), u = new Zi(t, l);
      P(u_e, u.add, u), s.add(this._axisGroup), s.add(u.getGroup()), P(c_e, function(c) {
        t.get([
          c,
          "show"
        ]) && d_e[c](this, this.group, this._axisGroup, t);
      }, this), Lx(o, this._axisGroup, t), n.prototype.render.call(this, t, r, i, a);
    }, e.prototype.remove = function() {
      Oq(this);
    }, e.type = "singleAxis", e;
  }(zd), d_e = {
    splitLine: function(n, e, t, r) {
      var i = r.axis;
      if (!i.scale.isBlank()) {
        var a = r.getModel("splitLine"), s = a.getModel("lineStyle"), o = s.get("color");
        o = o instanceof Array ? o : [
          o
        ];
        for (var l = s.get("width"), u = r.coordinateSystem.getRect(), c = i.isHorizontal(), h = [], d = 0, f = i.getTicksCoords({
          tickModel: a
        }), p = [], g = [], m = 0; m < f.length; ++m) {
          var v = i.toGlobalCoord(f[m].coord);
          c ? (p[0] = v, p[1] = u.y, g[0] = v, g[1] = u.y + u.height) : (p[0] = u.x, p[1] = v, g[0] = u.x + u.width, g[1] = v);
          var y = new zr({
            shape: {
              x1: p[0],
              y1: p[1],
              x2: g[0],
              y2: g[1]
            },
            silent: true
          });
          Mg(y.shape, l);
          var x = d++ % o.length;
          h[x] = h[x] || [], h[x].push(y);
        }
        for (var b = s.getLineStyle([
          "color"
        ]), m = 0; m < h.length; ++m) e.add(ps(h[m], {
          style: je({
            stroke: o[m % o.length]
          }, b),
          silent: true
        }));
      }
    },
    splitArea: function(n, e, t, r) {
      Fq(n, t, r, r);
    }
  }, d_ = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getCoordSysModel = function() {
      return this;
    }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: true,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      tooltip: {
        show: true
      },
      axisTick: {
        show: true,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        interval: "auto"
      },
      splitLine: {
        show: true,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, e;
  }(Et);
  br(d_, Vx.prototype);
  var f_e = function(n) {
    K(e, n);
    function e(t, r, i, a, s) {
      var o = n.call(this, t, r, i) || this;
      return o.type = a || "value", o.position = s || "bottom", o;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.pointToData = function(t, r) {
      return this.coordinateSystem.pointToData(t)[0];
    }, e;
  }(fo), vK = [
    "single"
  ], p_e = function() {
    function n(e, t, r) {
      this.type = "single", this.dimension = "single", this.dimensions = vK, this.axisPointerEnabled = true, this.model = e, this._init(e, t, r);
    }
    return n.prototype._init = function(e, t, r) {
      var i = this.dimension, a = new f_e(i, VC(e), [
        0,
        0
      ], e.get("type"), e.get("position")), s = a.type === "category";
      a.onBand = s && e.get("boundaryGap"), a.inverse = e.get("inverse"), a.orient = e.get("orient"), e.axis = a, a.model = e, a.coordinateSystem = this, this._axis = a;
    }, n.prototype.update = function(e, t) {
      e.eachSeries(function(r) {
        if (r.coordinateSystem === this) {
          var i = r.getData();
          P(i.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(i, a);
          }, this), Fg(this._axis.scale, this._axis.model);
        }
      }, this);
    }, n.prototype.resize = function(e, t) {
      this._rect = Er({
        left: e.get("left"),
        top: e.get("top"),
        right: e.get("right"),
        bottom: e.get("bottom"),
        width: e.get("width"),
        height: e.get("height")
      }, {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._adjustAxis();
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype._adjustAxis = function() {
      var e = this._rect, t = this._axis, r = t.isHorizontal(), i = r ? [
        0,
        e.width
      ] : [
        0,
        e.height
      ], a = t.inverse ? 1 : 0;
      t.setExtent(i[a], i[1 - a]), this._updateAxisTransform(t, r ? e.x : e.y);
    }, n.prototype._updateAxisTransform = function(e, t) {
      var r = e.getExtent(), i = r[0] + r[1], a = e.isHorizontal();
      e.toGlobalCoord = a ? function(s) {
        return s + t;
      } : function(s) {
        return i - s + t;
      }, e.toLocalCoord = a ? function(s) {
        return s - t;
      } : function(s) {
        return i - s + t;
      };
    }, n.prototype.getAxis = function() {
      return this._axis;
    }, n.prototype.getBaseAxis = function() {
      return this._axis;
    }, n.prototype.getAxes = function() {
      return [
        this._axis
      ];
    }, n.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [
          this.getAxis()
        ],
        otherAxes: []
      };
    }, n.prototype.containPoint = function(e) {
      var t = this.getRect(), r = this.getAxis(), i = r.orient;
      return i === "horizontal" ? r.contain(r.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height : r.contain(r.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height;
    }, n.prototype.pointToData = function(e) {
      var t = this.getAxis();
      return [
        t.coordToData(t.toLocalCoord(e[t.orient === "horizontal" ? 0 : 1]))
      ];
    }, n.prototype.dataToPoint = function(e) {
      var t = this.getAxis(), r = this.getRect(), i = [], a = t.orient === "horizontal" ? 0 : 1;
      return e instanceof Array && (e = e[0]), i[a] = t.toGlobalCoord(t.dataToCoord(+e)), i[1 - a] = a === 0 ? r.y + r.height / 2 : r.x + r.width / 2, i;
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = hW(t);
      return i === this ? this.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = hW(t);
      return i === this ? this.pointToData(r) : null;
    }, n;
  }();
  function hW(n) {
    var e = n.seriesModel, t = n.singleAxisModel;
    return t && t.coordinateSystem || e && e.coordinateSystem;
  }
  function g_e(n, e) {
    var t = [];
    return n.eachComponent("singleAxis", function(r, i) {
      var a = new p_e(r, n, e);
      a.name = "single_" + i, a.resize(r, e), r.coordinateSystem = a, t.push(a);
    }), n.eachSeries(function(r) {
      if (r.get("coordinateSystem") === "singleAxis") {
        var i = r.getReferringComponents("singleAxis", yr).models[0];
        r.coordinateSystem = i && i.coordinateSystem;
      }
    }), t;
  }
  var m_e = {
    create: g_e,
    dimensions: vK
  }, dW = [
    "x",
    "y"
  ], v_e = [
    "width",
    "height"
  ], y_e = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, r, i, a, s) {
      var o = i.axis, l = o.coordinateSystem, u = ET(l, 1 - pS(o)), c = l.dataToPoint(r)[0], h = a.get("type");
      if (h && h !== "none") {
        var d = yM(a), f = x_e[h](o, c, u);
        f.style = d, t.graphicKey = f.type, t.pointer = f;
      }
      var p = zR(i);
      cK(r, t, p, i, a, s);
    }, e.prototype.getHandleTransform = function(t, r, i) {
      var a = zR(r, {
        labelInside: false
      });
      a.labelMargin = i.get([
        "handle",
        "margin"
      ]);
      var s = xM(r.axis, t, a);
      return {
        x: s[0],
        y: s[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, r, i, a) {
      var s = i.axis, o = s.coordinateSystem, l = pS(s), u = ET(o, l), c = [
        t.x,
        t.y
      ];
      c[l] += r[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var h = ET(o, 1 - l), d = (h[1] + h[0]) / 2, f = [
        d,
        d
      ];
      return f[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: t.rotation,
        cursorPoint: f,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, e;
  }(vM), x_e = {
    line: function(n, e, t) {
      var r = bM([
        e,
        t[0]
      ], [
        e,
        t[1]
      ], pS(n));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: r
      };
    },
    shadow: function(n, e, t) {
      var r = n.getBandWidth(), i = t[1] - t[0];
      return {
        type: "Rect",
        shape: hK([
          e - r / 2,
          t[0]
        ], [
          r,
          i
        ], pS(n))
      };
    }
  };
  function pS(n) {
    return n.isHorizontal() ? 0 : 1;
  }
  function ET(n, e) {
    var t = n.getRect();
    return [
      t[dW[e]],
      t[dW[e]] + t[v_e[e]]
    ];
  }
  var b_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "single", e;
  }(Yn);
  function w_e(n) {
    Ct(Kx), zd.registerAxisPointerClass("SingleAxisPointer", y_e), n.registerComponentView(b_e), n.registerComponentView(h_e), n.registerComponentModel(d_), Bg(n, "single", d_, d_.defaultOption), n.registerCoordinateSystem("single", m_e);
  }
  var __e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r, i) {
      var a = bm(t);
      n.prototype.init.apply(this, arguments), fW(t, a);
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), fW(this.option, t);
    }, e.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, e.type = "calendar", e.defaultOption = {
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: "horizontal",
      splitLine: {
        show: true,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      dayLabel: {
        show: true,
        firstDay: 0,
        position: "start",
        margin: "50%",
        color: "#000"
      },
      monthLabel: {
        show: true,
        position: "start",
        margin: 5,
        align: "center",
        formatter: null,
        color: "#000"
      },
      yearLabel: {
        show: true,
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, e;
  }(Et);
  function fW(n, e) {
    var t = n.cellSize, r;
    de(t) ? r = t : r = n.cellSize = [
      t,
      t
    ], r.length === 1 && (r[1] = r[0]);
    var i = me([
      0,
      1
    ], function(a) {
      return Wce(e, a) && (r[a] = "auto"), r[a] != null && r[a] !== "auto";
    });
    rc(n, e, {
      type: "box",
      ignoreSize: i
    });
  }
  var S_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      var a = this.group;
      a.removeAll();
      var s = t.coordinateSystem, o = s.getRangeInfo(), l = s.getOrient(), u = r.getLocaleModel();
      this._renderDayRect(t, o, a), this._renderLines(t, o, l, a), this._renderYearText(t, o, l, a), this._renderMonthText(t, u, l, a), this._renderWeekText(t, u, o, l, a);
    }, e.prototype._renderDayRect = function(t, r, i) {
      for (var a = t.coordinateSystem, s = t.getModel("itemStyle").getItemStyle(), o = a.getCellWidth(), l = a.getCellHeight(), u = r.start.time; u <= r.end.time; u = a.getNextNDay(u, 1).time) {
        var c = a.dataToRect([
          u
        ], false).tl, h = new Vt({
          shape: {
            x: c[0],
            y: c[1],
            width: o,
            height: l
          },
          cursor: "default",
          style: s
        });
        i.add(h);
      }
    }, e.prototype._renderLines = function(t, r, i, a) {
      var s = this, o = t.coordinateSystem, l = t.getModel([
        "splitLine",
        "lineStyle"
      ]).getLineStyle(), u = t.get([
        "splitLine",
        "show"
      ]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var h = r.start, d = 0; h.time <= r.end.time; d++) {
        p(h.formatedDate), d === 0 && (h = o.getDateInfo(r.start.y + "-" + r.start.m));
        var f = h.date;
        f.setMonth(f.getMonth() + 1), h = o.getDateInfo(f);
      }
      p(o.getNextNDay(r.end.time, 1).formatedDate);
      function p(g) {
        s._firstDayOfMonth.push(o.getDateInfo(g)), s._firstDayPoints.push(o.dataToRect([
          g
        ], false).tl);
        var m = s._getLinePointsOfOneWeek(t, g, i);
        s._tlpoints.push(m[0]), s._blpoints.push(m[m.length - 1]), u && s._drawSplitline(m, l, a);
      }
      u && this._drawSplitline(s._getEdgesPoints(s._tlpoints, c, i), l, a), u && this._drawSplitline(s._getEdgesPoints(s._blpoints, c, i), l, a);
    }, e.prototype._getEdgesPoints = function(t, r, i) {
      var a = [
        t[0].slice(),
        t[t.length - 1].slice()
      ], s = i === "horizontal" ? 0 : 1;
      return a[0][s] = a[0][s] - r / 2, a[1][s] = a[1][s] + r / 2, a;
    }, e.prototype._drawSplitline = function(t, r, i) {
      var a = new oa({
        z2: 20,
        shape: {
          points: t
        },
        style: r
      });
      i.add(a);
    }, e.prototype._getLinePointsOfOneWeek = function(t, r, i) {
      for (var a = t.coordinateSystem, s = a.getDateInfo(r), o = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(s.time, l), c = a.dataToRect([
          u.time
        ], false);
        o[2 * u.day] = c.tl, o[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return o;
    }, e.prototype._formatterLabel = function(t, r) {
      return Ie(t) && t ? Bce(t, r) : Xe(t) ? t(r) : r.nameMap;
    }, e.prototype._yearTextPositionControl = function(t, r, i, a, s) {
      var o = r[0], l = r[1], u = [
        "center",
        "bottom"
      ];
      a === "bottom" ? (l += s, u = [
        "center",
        "top"
      ]) : a === "left" ? o -= s : a === "right" ? (o += s, u = [
        "center",
        "top"
      ]) : l -= s;
      var c = 0;
      return (a === "left" || a === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: o,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, e.prototype._renderYearText = function(t, r, i, a) {
      var s = t.getModel("yearLabel");
      if (s.get("show")) {
        var o = s.get("margin"), l = s.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [
          this._tlpoints[this._tlpoints.length - 1],
          this._blpoints[0]
        ], c = (u[0][0] + u[1][0]) / 2, h = (u[0][1] + u[1][1]) / 2, d = i === "horizontal" ? 0 : 1, f = {
          top: [
            c,
            u[d][1]
          ],
          bottom: [
            c,
            u[1 - d][1]
          ],
          left: [
            u[1 - d][0],
            h
          ],
          right: [
            u[d][0],
            h
          ]
        }, p = r.start.y;
        +r.end.y > +r.start.y && (p = p + "-" + r.end.y);
        var g = s.get("formatter"), m = {
          start: r.start.y,
          end: r.end.y,
          nameMap: p
        }, v = this._formatterLabel(g, m), y = new Gt({
          z2: 30,
          style: $n(s, {
            text: v
          }),
          silent: s.get("silent")
        });
        y.attr(this._yearTextPositionControl(y, f[l], i, l, o)), a.add(y);
      }
    }, e.prototype._monthTextPositionControl = function(t, r, i, a, s) {
      var o = "left", l = "top", u = t[0], c = t[1];
      return i === "horizontal" ? (c = c + s, r && (o = "center"), a === "start" && (l = "bottom")) : (u = u + s, r && (l = "middle"), a === "start" && (o = "right")), {
        x: u,
        y: c,
        align: o,
        verticalAlign: l
      };
    }, e.prototype._renderMonthText = function(t, r, i, a) {
      var s = t.getModel("monthLabel");
      if (s.get("show")) {
        var o = s.get("nameMap"), l = s.get("margin"), u = s.get("position"), c = s.get("align"), h = [
          this._tlpoints,
          this._blpoints
        ];
        (!o || Ie(o)) && (o && (r = qD(o) || r), o = r.get([
          "time",
          "monthAbbr"
        ]) || []);
        var d = u === "start" ? 0 : 1, f = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", g = s.get("silent"), m = 0; m < h[d].length - 1; m++) {
          var v = h[d][m].slice(), y = this._firstDayOfMonth[m];
          if (p) {
            var x = this._firstDayPoints[m];
            v[f] = (x[f] + h[0][m + 1][f]) / 2;
          }
          var b = s.get("formatter"), w = o[+y.m - 1], _ = {
            yyyy: y.y,
            yy: (y.y + "").slice(2),
            MM: y.m,
            M: +y.m,
            nameMap: w
          }, S = this._formatterLabel(b, _), I = new Gt({
            z2: 30,
            style: oe($n(s, {
              text: S
            }), this._monthTextPositionControl(v, p, i, u, l)),
            silent: g
          });
          a.add(I);
        }
      }
    }, e.prototype._weekTextPositionControl = function(t, r, i, a, s) {
      var o = "center", l = "middle", u = t[0], c = t[1], h = i === "start";
      return r === "horizontal" ? (u = u + a + (h ? 1 : -1) * s[0] / 2, o = h ? "right" : "left") : (c = c + a + (h ? 1 : -1) * s[1] / 2, l = h ? "bottom" : "top"), {
        x: u,
        y: c,
        align: o,
        verticalAlign: l
      };
    }, e.prototype._renderWeekText = function(t, r, i, a, s) {
      var o = t.getModel("dayLabel");
      if (o.get("show")) {
        var l = t.coordinateSystem, u = o.get("position"), c = o.get("nameMap"), h = o.get("margin"), d = l.getFirstDayOfWeek();
        if (!c || Ie(c)) {
          c && (r = qD(c) || r);
          var f = r.get([
            "time",
            "dayOfWeekShort"
          ]);
          c = f || me(r.get([
            "time",
            "dayOfWeekAbbr"
          ]), function(_) {
            return _[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, g = [
          l.getCellWidth(),
          l.getCellHeight()
        ];
        h = _e(h, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, h = -h);
        for (var m = o.get("silent"), v = 0; v < 7; v++) {
          var y = l.getNextNDay(p, v), x = l.dataToRect([
            y.time
          ], false).center, b = v;
          b = Math.abs((v + d) % 7);
          var w = new Gt({
            z2: 30,
            style: oe($n(o, {
              text: c[b]
            }), this._weekTextPositionControl(x, a, u, h, g)),
            silent: m
          });
          s.add(w);
        }
      }
    }, e.type = "calendar", e;
  }(Yn), MT = 864e5, C_e = function() {
    function n(e, t, r) {
      this.type = "calendar", this.dimensions = n.dimensions, this.getDimensionsInfo = n.getDimensionsInfo, this._model = e;
    }
    return n.getDimensionsInfo = function() {
      return [
        {
          name: "time",
          type: "time"
        },
        "value"
      ];
    }, n.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, n.prototype.getModel = function() {
      return this._model;
    }, n.prototype.getRect = function() {
      return this._rect;
    }, n.prototype.getCellWidth = function() {
      return this._sw;
    }, n.prototype.getCellHeight = function() {
      return this._sh;
    }, n.prototype.getOrient = function() {
      return this._orient;
    }, n.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, n.prototype.getDateInfo = function(e) {
      e = tl(e);
      var t = e.getFullYear(), r = e.getMonth() + 1, i = r < 10 ? "0" + r : "" + r, a = e.getDate(), s = a < 10 ? "0" + a : "" + a, o = e.getDay();
      return o = Math.abs((o + 7 - this.getFirstDayOfWeek()) % 7), {
        y: t + "",
        m: i,
        d: s,
        day: o,
        time: e.getTime(),
        formatedDate: t + "-" + i + "-" + s,
        date: e
      };
    }, n.prototype.getNextNDay = function(e, t) {
      return t = t || 0, t === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + t), this.getDateInfo(e));
    }, n.prototype.update = function(e, t) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var r = this._rangeInfo.weeks || 1, i = [
        "width",
        "height"
      ], a = this._model.getCellSize().slice(), s = this._model.getBoxLayoutParams(), o = this._orient === "horizontal" ? [
        r,
        7
      ] : [
        7,
        r
      ];
      P([
        0,
        1
      ], function(h) {
        c(a, h) && (s[i[h]] = a[h] * o[h]);
      });
      var l = {
        width: t.getWidth(),
        height: t.getHeight()
      }, u = this._rect = Er(s, l);
      P([
        0,
        1
      ], function(h) {
        c(a, h) || (a[h] = u[i[h]] / o[h]);
      });
      function c(h, d) {
        return h[d] != null && h[d] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, n.prototype.dataToPoint = function(e, t) {
      de(e) && (e = e[0]), t == null && (t = true);
      var r = this.getDateInfo(e), i = this._rangeInfo, a = r.formatedDate;
      if (t && !(r.time >= i.start.time && r.time < i.end.time + MT)) return [
        NaN,
        NaN
      ];
      var s = r.day, o = this._getRangeInfo([
        i.start.time,
        a
      ]).nthWeek;
      return this._orient === "vertical" ? [
        this._rect.x + s * this._sw + this._sw / 2,
        this._rect.y + o * this._sh + this._sh / 2
      ] : [
        this._rect.x + o * this._sw + this._sw / 2,
        this._rect.y + s * this._sh + this._sh / 2
      ];
    }, n.prototype.pointToData = function(e) {
      var t = this.pointToDate(e);
      return t && t.time;
    }, n.prototype.dataToRect = function(e, t) {
      var r = this.dataToPoint(e, t);
      return {
        contentShape: {
          x: r[0] - (this._sw - this._lineWidth) / 2,
          y: r[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: r,
        tl: [
          r[0] - this._sw / 2,
          r[1] - this._sh / 2
        ],
        tr: [
          r[0] + this._sw / 2,
          r[1] - this._sh / 2
        ],
        br: [
          r[0] + this._sw / 2,
          r[1] + this._sh / 2
        ],
        bl: [
          r[0] - this._sw / 2,
          r[1] + this._sh / 2
        ]
      };
    }, n.prototype.pointToDate = function(e) {
      var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1, r = Math.floor((e[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(r, t - 1, i) : this._getDateByWeeksAndDay(t, r - 1, i);
    }, n.prototype.convertToPixel = function(e, t, r) {
      var i = pW(t);
      return i === this ? i.dataToPoint(r) : null;
    }, n.prototype.convertFromPixel = function(e, t, r) {
      var i = pW(t);
      return i === this ? i.pointToData(r) : null;
    }, n.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), false;
    }, n.prototype._initRangeOption = function() {
      var e = this._model.get("range"), t;
      if (de(e) && e.length === 1 && (e = e[0]), de(e)) t = e;
      else {
        var r = e.toString();
        if (/^\d{4}$/.test(r) && (t = [
          r + "-01-01",
          r + "-12-31"
        ]), /^\d{4}[\/|-]\d{1,2}$/.test(r)) {
          var i = this.getDateInfo(r), a = i.date;
          a.setMonth(a.getMonth() + 1);
          var s = this.getNextNDay(a, -1);
          t = [
            i.formatedDate,
            s.formatedDate
          ];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(r) && (t = [
          r,
          r
        ]);
      }
      if (!t) return e;
      var o = this._getRangeInfo(t);
      return o.start.time > o.end.time && t.reverse(), t;
    }, n.prototype._getRangeInfo = function(e) {
      var t = [
        this.getDateInfo(e[0]),
        this.getDateInfo(e[1])
      ], r;
      t[0].time > t[1].time && (r = true, t.reverse());
      var i = Math.floor(t[1].time / MT) - Math.floor(t[0].time / MT) + 1, a = new Date(t[0].time), s = a.getDate(), o = t[1].date.getDate();
      a.setDate(s + i - 1);
      var l = a.getDate();
      if (l !== o) for (var u = a.getTime() - t[1].time > 0 ? 1 : -1; (l = a.getDate()) !== o && (a.getTime() - t[1].time) * u > 0; ) i -= u, a.setDate(l - u);
      var c = Math.floor((i + t[0].day + 6) / 7), h = r ? -c + 1 : c - 1;
      return r && t.reverse(), {
        range: [
          t[0].formatedDate,
          t[1].formatedDate
        ],
        start: t[0],
        end: t[1],
        allDay: i,
        weeks: c,
        nthWeek: h,
        fweek: t[0].day,
        lweek: t[1].day
      };
    }, n.prototype._getDateByWeeksAndDay = function(e, t, r) {
      var i = this._getRangeInfo(r);
      if (e > i.weeks || e === 0 && t < i.fweek || e === i.weeks && t > i.lweek) return null;
      var a = (e - 1) * 7 - i.fweek + t, s = new Date(i.start.time);
      return s.setDate(+i.start.d + a), this.getDateInfo(s);
    }, n.create = function(e, t) {
      var r = [];
      return e.eachComponent("calendar", function(i) {
        var a = new n(i);
        r.push(a), i.coordinateSystem = a;
      }), e.eachSeries(function(i) {
        i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = r[i.get("calendarIndex") || 0]);
      }), r;
    }, n.dimensions = [
      "time",
      "value"
    ], n;
  }();
  function pW(n) {
    var e = n.calendarModel, t = n.seriesModel, r = e ? e.coordinateSystem : t ? t.coordinateSystem : null;
    return r;
  }
  function I_e(n) {
    n.registerComponentModel(__e), n.registerComponentView(S_e), n.registerCoordinateSystem("calendar", C_e);
  }
  function k_e(n, e) {
    var t = n.existing;
    if (e.id = n.keyInfo.id, !e.type && t && (e.type = t.type), e.parentId == null) {
      var r = e.parentOption;
      r ? e.parentId = r.id : t && (e.parentId = t.parentId);
    }
    e.parentOption = null;
  }
  function gW(n, e) {
    var t;
    return P(e, function(r) {
      n[r] != null && n[r] !== "auto" && (t = true);
    }), t;
  }
  function T_e(n, e, t) {
    var r = oe({}, t), i = n[e], a = t.$action || "merge";
    a === "merge" ? i ? (pt(i, r, true), rc(i, r, {
      ignoreSize: true
    }), uX(t, i), sw(t, i), sw(t, i, "shape"), sw(t, i, "style"), sw(t, i, "extra"), t.clipPath = i.clipPath) : n[e] = r : a === "replace" ? n[e] = r : a === "remove" && i && (n[e] = null);
  }
  var yK = [
    "transition",
    "enterFrom",
    "leaveTo"
  ], A_e = yK.concat([
    "enterAnimation",
    "updateAnimation",
    "leaveAnimation"
  ]);
  function sw(n, e, t) {
    if (t && (!n[t] && e[t] && (n[t] = {}), n = n[t], e = e[t]), !(!n || !e)) for (var r = t ? yK : A_e, i = 0; i < r.length; i++) {
      var a = r[i];
      n[a] == null && e[a] != null && (n[a] = e[a]);
    }
  }
  function D_e(n, e) {
    if (n && (n.hv = e.hv = [
      gW(e, [
        "left",
        "right"
      ]),
      gW(e, [
        "top",
        "bottom"
      ])
    ], n.type === "group")) {
      var t = n, r = e;
      t.width == null && (t.width = r.width = 0), t.height == null && (t.height = r.height = 0);
    }
  }
  var R_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.preventAutoZ = true, t;
    }
    return e.prototype.mergeOption = function(t, r) {
      var i = this.option.elements;
      this.option.elements = null, n.prototype.mergeOption.call(this, t, r), this.option.elements = i;
    }, e.prototype.optionUpdated = function(t, r) {
      var i = this.option, a = (r ? i : t).elements, s = i.elements = r ? [] : i.elements, o = [];
      this._flatten(a, o, null);
      var l = a8(s, o, "normalMerge"), u = this._elOptionsToUpdate = [];
      P(l, function(c, h) {
        var d = c.newOption;
        d && (u.push(d), k_e(c, d), T_e(s, h, d), D_e(s[h], d));
      }, this), i.elements = rn(s, function(c) {
        return c && delete c.$action, c != null;
      });
    }, e.prototype._flatten = function(t, r, i) {
      P(t, function(a) {
        if (a) {
          i && (a.parentOption = i), r.push(a);
          var s = a.children;
          s && s.length && this._flatten(s, r, a), delete a.children;
        }
      }, this);
    }, e.prototype.useElOptionsToUpdate = function() {
      var t = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, t;
    }, e.type = "graphic", e.defaultOption = {
      elements: []
    }, e;
  }(Et), mW = {
    path: null,
    compoundPath: null,
    group: tt,
    image: oi,
    text: Gt
  }, cs = Wt(), $_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._elMap = Pe();
    }, e.prototype.render = function(t, r, i) {
      t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i);
    }, e.prototype._updateElements = function(t) {
      var r = t.useElOptionsToUpdate();
      if (r) {
        var i = this._elMap, a = this.group, s = t.get("z"), o = t.get("zlevel");
        P(r, function(l) {
          var u = kr(l.id, null), c = u != null ? i.get(u) : null, h = kr(l.parentId, null), d = h != null ? i.get(h) : a, f = l.type, p = l.style;
          f === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, m = l.textConfig;
          if (p && Qj(p, f, !!m, !!g)) {
            var v = Jj(p, f, true);
            !m && v.textConfig && (m = l.textConfig = v.textConfig), !g && v.textContent && (g = v.textContent);
          }
          var y = N_e(l), x = l.$action || "merge", b = x === "merge", w = x === "replace";
          if (b) {
            var _ = !c, S = c;
            _ ? S = vW(u, d, l.type, i) : (S && (cs(S).isNew = false), rK(S)), S && (c_(S, y, t, {
              isInit: _
            }), yW(S, l, s, o));
          } else if (w) {
            f_(c, l, i, t);
            var I = vW(u, d, l.type, i);
            I && (c_(I, y, t, {
              isInit: true
            }), yW(I, l, s, o));
          } else x === "remove" && (tK(c, l), f_(c, l, i, t));
          var C = i.get(u);
          if (C && g) if (b) {
            var T = C.getTextContent();
            T ? T.attr(g) : C.setTextContent(new Gt(g));
          } else w && C.setTextContent(new Gt(g));
          if (C) {
            var k = l.clipPath;
            if (k) {
              var D = k.type, R = void 0, _ = false;
              if (b) {
                var N = C.getClipPath();
                _ = !N || cs(N).type !== D, R = _ ? VR(D) : N;
              } else w && (_ = true, R = VR(D));
              C.setClipPath(R), c_(R, k, t, {
                isInit: _
              }), dS(R, k.keyframeAnimation, t);
            }
            var E = cs(C);
            C.setTextConfig(m), E.option = l, E_e(C, t, l), Pd({
              el: C,
              componentModel: t,
              itemName: C.name,
              itemTooltipOption: l.tooltip
            }), dS(C, l.keyframeAnimation, t);
          }
        });
      }
    }, e.prototype._relocate = function(t, r) {
      for (var i = t.option.elements, a = this.group, s = this._elMap, o = r.getWidth(), l = r.getHeight(), u = [
        "x",
        "y"
      ], c = 0; c < i.length; c++) {
        var h = i[c], d = kr(h.id, null), f = d != null ? s.get(d) : null;
        if (!(!f || !f.isGroup)) {
          var p = f.parent, g = p === a, m = cs(f), v = cs(p);
          m.width = _e(m.option.width, g ? o : v.width) || 0, m.height = _e(m.option.height, g ? l : v.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var h = i[c], d = kr(h.id, null), f = d != null ? s.get(d) : null;
        if (f) {
          var p = f.parent, v = cs(p), y = p === a ? {
            width: o,
            height: l
          } : {
            width: v.width,
            height: v.height
          }, x = {}, b = NC(f, h, y, null, {
            hv: h.hv,
            boundingMode: h.bounding
          }, x);
          if (!cs(f).isNew && b) {
            for (var w = h.transition, _ = {}, S = 0; S < u.length; S++) {
              var I = u[S], C = x[I];
              w && (nd(w) || bt(w, I) >= 0) ? _[I] = C : f[I] = C;
            }
            Kt(f, _, t, 0);
          } else f.attr(x);
        }
      }
    }, e.prototype._clear = function() {
      var t = this, r = this._elMap;
      r.each(function(i) {
        f_(i, cs(i).option, r, t._lastGraphicModel);
      }), this._elMap = Pe();
    }, e.prototype.dispose = function() {
      this._clear();
    }, e.type = "graphic", e;
  }(Yn);
  function VR(n) {
    var e = $e(mW, n) ? mW[n] : tE(n), t = new e({});
    return cs(t).type = n, t;
  }
  function vW(n, e, t, r) {
    var i = VR(t);
    return e.add(i), r.set(n, i), cs(i).id = n, cs(i).isNew = true, i;
  }
  function f_(n, e, t, r) {
    var i = n && n.parent;
    i && (n.type === "group" && n.traverse(function(a) {
      f_(a, e, t, r);
    }), qC(n, e, r), t.removeKey(cs(n).id));
  }
  function yW(n, e, t, r) {
    n.isGroup || P([
      [
        "cursor",
        _s.prototype.cursor
      ],
      [
        "zlevel",
        r || 0
      ],
      [
        "z",
        t || 0
      ],
      [
        "z2",
        0
      ]
    ], function(i) {
      var a = i[0];
      $e(e, a) ? n[a] = it(e[a], i[1]) : n[a] == null && (n[a] = i[1]);
    }), P(Mt(e), function(i) {
      if (i.indexOf("on") === 0) {
        var a = e[i];
        n[i] = Xe(a) ? a : null;
      }
    }), $e(e, "draggable") && (n.draggable = e.draggable), e.name != null && (n.name = e.name), e.id != null && (n.id = e.id);
  }
  function N_e(n) {
    return n = oe({}, n), P([
      "id",
      "parentId",
      "$action",
      "hv",
      "bounding",
      "textContent",
      "clipPath"
    ].concat(lX), function(e) {
      delete n[e];
    }), n;
  }
  function E_e(n, e, t) {
    var r = rt(n).eventData;
    !n.silent && !n.ignore && !r && (r = rt(n).eventData = {
      componentType: "graphic",
      componentIndex: e.componentIndex,
      name: n.name
    }), r && (r.info = t.info);
  }
  function M_e(n) {
    n.registerComponentModel(R_e), n.registerComponentView($_e), n.registerPreprocessor(function(e) {
      var t = e.graphic;
      de(t) ? !t[0] || !t[0].elements ? e.graphic = [
        {
          elements: t
        }
      ] : e.graphic = [
        e.graphic[0]
      ] : t && !t.elements && (e.graphic = [
        {
          elements: [
            t
          ]
        }
      ]);
    });
  }
  var xW = [
    "x",
    "y",
    "radius",
    "angle",
    "single"
  ], P_e = [
    "cartesian2d",
    "polar",
    "singleAxis"
  ];
  function L_e(n) {
    var e = n.get("coordinateSystem");
    return bt(P_e, e) >= 0;
  }
  function zu(n) {
    return n + "Axis";
  }
  function F_e(n, e) {
    var t = Pe(), r = [], i = Pe();
    n.eachComponent({
      mainType: "dataZoom",
      query: e
    }, function(c) {
      i.get(c.uid) || o(c);
    });
    var a;
    do
      a = false, n.eachComponent("dataZoom", s);
    while (a);
    function s(c) {
      !i.get(c.uid) && l(c) && (o(c), a = true);
    }
    function o(c) {
      i.set(c.uid, true), r.push(c), u(c);
    }
    function l(c) {
      var h = false;
      return c.eachTargetAxis(function(d, f) {
        var p = t.get(d);
        p && p[f] && (h = true);
      }), h;
    }
    function u(c) {
      c.eachTargetAxis(function(h, d) {
        (t.get(h) || t.set(h, []))[d] = true;
      });
    }
    return r;
  }
  function xK(n) {
    var e = n.ecModel, t = {
      infoList: [],
      infoMap: Pe()
    };
    return n.eachTargetAxis(function(r, i) {
      var a = e.getComponent(zu(r), i);
      if (a) {
        var s = a.getCoordSysModel();
        if (s) {
          var o = s.uid, l = t.infoMap.get(o);
          l || (l = {
            model: s,
            axisModels: []
          }, t.infoList.push(l), t.infoMap.set(o, l)), l.axisModels.push(a);
        }
      }
    }), t;
  }
  var PT = function() {
    function n() {
      this.indexList = [], this.indexMap = [];
    }
    return n.prototype.add = function(e) {
      this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = true);
    }, n;
  }(), K0 = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._autoThrottle = true, t._noTarget = true, t._rangePropMode = [
        "percent",
        "percent"
      ], t;
    }
    return e.prototype.init = function(t, r, i) {
      var a = bW(t);
      this.settledOption = a, this.mergeDefaultAndTheme(t, i), this._doInit(a);
    }, e.prototype.mergeOption = function(t) {
      var r = bW(t);
      pt(this.option, t, true), pt(this.settledOption, r, true), this._doInit(r);
    }, e.prototype._doInit = function(t) {
      var r = this.option;
      this._setDefaultThrottle(t), this._updateRangeUse(t);
      var i = this.settledOption;
      P([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a, s) {
        this._rangePropMode[s] === "value" && (r[a[0]] = i[a[0]] = null);
      }, this), this._resetTarget();
    }, e.prototype._resetTarget = function() {
      var t = this.get("orient", true), r = this._targetAxisInfoMap = Pe(), i = this._fillSpecifiedTargetAxis(r);
      i ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(r, this._orient)), this._noTarget = true, r.each(function(a) {
        a.indexList.length && (this._noTarget = false);
      }, this);
    }, e.prototype._fillSpecifiedTargetAxis = function(t) {
      var r = false;
      return P(xW, function(i) {
        var a = this.getReferringComponents(zu(i), Ale);
        if (a.specified) {
          r = true;
          var s = new PT();
          P(a.models, function(o) {
            s.add(o.componentIndex);
          }), t.set(i, s);
        }
      }, this), r;
    }, e.prototype._fillAutoTargetAxisByOrient = function(t, r) {
      var i = this.ecModel, a = true;
      if (a) {
        var s = r === "vertical" ? "y" : "x", o = i.findComponents({
          mainType: s + "Axis"
        });
        l(o, s);
      }
      if (a) {
        var o = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", true) === r;
          }
        });
        l(o, "single");
      }
      function l(u, c) {
        var h = u[0];
        if (h) {
          var d = new PT();
          if (d.add(h.componentIndex), t.set(c, d), a = false, c === "x" || c === "y") {
            var f = h.getReferringComponents("grid", yr).models[0];
            f && P(u, function(p) {
              h.componentIndex !== p.componentIndex && f === p.getReferringComponents("grid", yr).models[0] && d.add(p.componentIndex);
            });
          }
        }
      }
      a && P(xW, function(u) {
        if (a) {
          var c = i.findComponents({
            mainType: zu(u),
            filter: function(d) {
              return d.get("type", true) === "category";
            }
          });
          if (c[0]) {
            var h = new PT();
            h.add(c[0].componentIndex), t.set(u, h), a = false;
          }
        }
      }, this);
    }, e.prototype._makeAutoOrientByTargetAxis = function() {
      var t;
      return this.eachTargetAxis(function(r) {
        !t && (t = r);
      }, this), t === "y" ? "vertical" : "horizontal";
    }, e.prototype._setDefaultThrottle = function(t) {
      if (t.hasOwnProperty("throttle") && (this._autoThrottle = false), this._autoThrottle) {
        var r = this.ecModel.option;
        this.option.throttle = r.animation && r.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, e.prototype._updateRangeUse = function(t) {
      var r = this._rangePropMode, i = this.get("rangeMode");
      P([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a, s) {
        var o = t[a[0]] != null, l = t[a[1]] != null;
        o && !l ? r[s] = "percent" : !o && l ? r[s] = "value" : i ? r[s] = i[s] : o && (r[s] = "percent");
      });
    }, e.prototype.noTarget = function() {
      return this._noTarget;
    }, e.prototype.getFirstTargetAxisModel = function() {
      var t;
      return this.eachTargetAxis(function(r, i) {
        t == null && (t = this.ecModel.getComponent(zu(r), i));
      }, this), t;
    }, e.prototype.eachTargetAxis = function(t, r) {
      this._targetAxisInfoMap.each(function(i, a) {
        P(i.indexList, function(s) {
          t.call(r, a, s);
        });
      });
    }, e.prototype.getAxisProxy = function(t, r) {
      var i = this.getAxisModel(t, r);
      if (i) return i.__dzAxisProxy;
    }, e.prototype.getAxisModel = function(t, r) {
      var i = this._targetAxisInfoMap.get(t);
      if (i && i.indexMap[r]) return this.ecModel.getComponent(zu(t), r);
    }, e.prototype.setRawRange = function(t) {
      var r = this.option, i = this.settledOption;
      P([
        [
          "start",
          "startValue"
        ],
        [
          "end",
          "endValue"
        ]
      ], function(a) {
        (t[a[0]] != null || t[a[1]] != null) && (r[a[0]] = i[a[0]] = t[a[0]], r[a[1]] = i[a[1]] = t[a[1]]);
      }, this), this._updateRangeUse(t);
    }, e.prototype.setCalculatedRange = function(t) {
      var r = this.option;
      P([
        "start",
        "startValue",
        "end",
        "endValue"
      ], function(i) {
        r[i] = t[i];
      });
    }, e.prototype.getPercentRange = function() {
      var t = this.findRepresentativeAxisProxy();
      if (t) return t.getDataPercentWindow();
    }, e.prototype.getValueRange = function(t, r) {
      if (t == null && r == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i) return i.getDataValueWindow();
      } else return this.getAxisProxy(t, r).getDataValueWindow();
    }, e.prototype.findRepresentativeAxisProxy = function(t) {
      if (t) return t.__dzAxisProxy;
      for (var r, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++) for (var s = i[a], o = this._targetAxisInfoMap.get(s), l = 0; l < o.indexList.length; l++) {
        var u = this.getAxisProxy(s, o.indexList[l]);
        if (u.hostedBy(this)) return u;
        r || (r = u);
      }
      return r;
    }, e.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, e.prototype.getOrient = function() {
      return this._orient;
    }, e.type = "dataZoom", e.dependencies = [
      "xAxis",
      "yAxis",
      "radiusAxis",
      "angleAxis",
      "singleAxis",
      "series",
      "toolbox"
    ], e.defaultOption = {
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, e;
  }(Et);
  function bW(n) {
    var e = {};
    return P([
      "start",
      "end",
      "startValue",
      "endValue",
      "throttle"
    ], function(t) {
      n.hasOwnProperty(t) && (e[t] = n[t]);
    }), e;
  }
  var O_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(K0), CM = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i, a) {
      this.dataZoomModel = t, this.ecModel = r, this.api = i;
    }, e.type = "dataZoom", e;
  }(Yn), B_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(CM), ag = P, wW = vs, z_e = function() {
    function n(e, t, r, i) {
      this._dimName = e, this._axisIndex = t, this.ecModel = i, this._dataZoomModel = r;
    }
    return n.prototype.hostedBy = function(e) {
      return this._dataZoomModel === e;
    }, n.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, n.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, n.prototype.getTargetSeriesModels = function() {
      var e = [];
      return this.ecModel.eachSeries(function(t) {
        if (L_e(t)) {
          var r = zu(this._dimName), i = t.getReferringComponents(r, yr).models[0];
          i && this._axisIndex === i.componentIndex && e.push(t);
        }
      }, this), e;
    }, n.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, n.prototype.getMinMaxSpan = function() {
      return Qe(this._minMaxSpan);
    }, n.prototype.calculateDataWindow = function(e) {
      var t = this._dataExtent, r = this.getAxisModel(), i = r.axis.scale, a = this._dataZoomModel.getRangePropMode(), s = [
        0,
        100
      ], o = [], l = [], u;
      ag([
        "start",
        "end"
      ], function(d, f) {
        var p = e[d], g = e[d + "Value"];
        a[f] === "percent" ? (p == null && (p = s[f]), g = i.parse(sn(p, s, t))) : (u = true, g = g == null ? t[f] : i.parse(g), p = sn(g, t, s)), l[f] = g == null || isNaN(g) ? t[f] : g, o[f] = p == null || isNaN(p) ? s[f] : p;
      }), wW(l), wW(o);
      var c = this._minMaxSpan;
      u ? h(l, o, t, s, false) : h(o, l, s, t, true);
      function h(d, f, p, g, m) {
        var v = m ? "Span" : "ValueSpan";
        Vd(0, d, p, "all", c["min" + v], c["max" + v]);
        for (var y = 0; y < 2; y++) f[y] = sn(d[y], p, g, true), m && (f[y] = i.parse(f[y]));
      }
      return {
        valueWindow: l,
        percentWindow: o
      };
    }, n.prototype.reset = function(e) {
      if (e === this._dataZoomModel) {
        var t = this.getTargetSeriesModels();
        this._dataExtent = V_e(this, this._dimName, t), this._updateMinMaxSpan();
        var r = this.calculateDataWindow(e.settledOption);
        this._valueWindow = r.valueWindow, this._percentWindow = r.percentWindow, this._setAxisModel();
      }
    }, n.prototype.filterData = function(e, t) {
      if (e !== this._dataZoomModel) return;
      var r = this._dimName, i = this.getTargetSeriesModels(), a = e.get("filterMode"), s = this._valueWindow;
      if (a === "none") return;
      ag(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(r);
        if (c.length) {
          if (a === "weakFilter") {
            var h = u.getStore(), d = me(c, function(f) {
              return u.getDimensionIndex(f);
            }, u);
            u.filterSelf(function(f) {
              for (var p, g, m, v = 0; v < c.length; v++) {
                var y = h.get(d[v], f), x = !isNaN(y), b = y < s[0], w = y > s[1];
                if (x && !b && !w) return true;
                x && (m = true), b && (p = true), w && (g = true);
              }
              return m && p && g;
            });
          } else ag(c, function(f) {
            if (a === "empty") l.setData(u = u.map(f, function(g) {
              return o(g) ? g : NaN;
            }));
            else {
              var p = {};
              p[f] = s, u.selectRange(p);
            }
          });
          ag(c, function(f) {
            u.setApproximateExtent(s, f);
          });
        }
      });
      function o(l) {
        return l >= s[0] && l <= s[1];
      }
    }, n.prototype._updateMinMaxSpan = function() {
      var e = this._minMaxSpan = {}, t = this._dataZoomModel, r = this._dataExtent;
      ag([
        "min",
        "max"
      ], function(i) {
        var a = t.get(i + "Span"), s = t.get(i + "ValueSpan");
        s != null && (s = this.getAxisModel().axis.scale.parse(s)), s != null ? a = sn(r[0] + s, r, [
          0,
          100
        ], true) : a != null && (s = sn(a, [
          0,
          100
        ], r, true) - r[0]), e[i + "Span"] = a, e[i + "ValueSpan"] = s;
      }, this);
    }, n.prototype._setAxisModel = function() {
      var e = this.getAxisModel(), t = this._percentWindow, r = this._valueWindow;
      if (t) {
        var i = Z6(r, [
          0,
          500
        ]);
        i = Math.min(i, 20);
        var a = e.axis.scale.rawExtentInfo;
        t[0] !== 0 && a.setDeterminedMinMax("min", +r[0].toFixed(i)), t[1] !== 100 && a.setDeterminedMinMax("max", +r[1].toFixed(i)), a.freeze();
      }
    }, n;
  }();
  function V_e(n, e, t) {
    var r = [
      1 / 0,
      -1 / 0
    ];
    ag(t, function(s) {
      bpe(r, s.getData(), e);
    });
    var i = n.getAxisModel(), a = FY(i.axis.scale, i, r).calculate();
    return [
      a.min,
      a.max
    ];
  }
  var W_e = {
    getTargetSeries: function(n) {
      function e(i) {
        n.eachComponent("dataZoom", function(a) {
          a.eachTargetAxis(function(s, o) {
            var l = n.getComponent(zu(s), o);
            i(s, o, l, a);
          });
        });
      }
      e(function(i, a, s, o) {
        s.__dzAxisProxy = null;
      });
      var t = [];
      e(function(i, a, s, o) {
        s.__dzAxisProxy || (s.__dzAxisProxy = new z_e(i, a, o, n), t.push(s.__dzAxisProxy));
      });
      var r = Pe();
      return P(t, function(i) {
        P(i.getTargetSeriesModels(), function(a) {
          r.set(a.uid, a);
        });
      }), r;
    },
    overallReset: function(n, e) {
      n.eachComponent("dataZoom", function(t) {
        t.eachTargetAxis(function(r, i) {
          t.getAxisProxy(r, i).reset(t);
        }), t.eachTargetAxis(function(r, i) {
          t.getAxisProxy(r, i).filterData(t, e);
        });
      }), n.eachComponent("dataZoom", function(t) {
        var r = t.findRepresentativeAxisProxy();
        if (r) {
          var i = r.getDataPercentWindow(), a = r.getDataValueWindow();
          t.setCalculatedRange({
            start: i[0],
            end: i[1],
            startValue: a[0],
            endValue: a[1]
          });
        }
      });
    }
  };
  function G_e(n) {
    n.registerAction("dataZoom", function(e, t) {
      var r = F_e(t, e);
      P(r, function(i) {
        i.setRawRange({
          start: e.start,
          end: e.end,
          startValue: e.startValue,
          endValue: e.endValue
        });
      });
    });
  }
  var _W = false;
  function IM(n) {
    _W || (_W = true, n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, W_e), G_e(n), n.registerSubTypeDefaulter("dataZoom", function() {
      return "slider";
    }));
  }
  function U_e(n) {
    n.registerComponentModel(O_e), n.registerComponentView(B_e), IM(n);
  }
  var ds = /* @__PURE__ */ function() {
    function n() {
    }
    return n;
  }(), bK = {};
  function sg(n, e) {
    bK[n] = e;
  }
  function wK(n) {
    return bK[n];
  }
  var H_e = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      n.prototype.optionUpdated.apply(this, arguments);
      var t = this.ecModel;
      P(this.option.feature, function(r, i) {
        var a = wK(i);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(t)), pt(r, a.defaultOption));
      });
    }, e.type = "toolbox", e.layoutMode = {
      type: "box",
      ignoreSize: true
    }, e.defaultOption = {
      show: true,
      z: 6,
      orient: "horizontal",
      left: "right",
      top: "top",
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: true,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      tooltip: {
        show: false,
        position: "bottom"
      }
    }, e;
  }(Et);
  function X_e(n, e, t) {
    var r = e.getBoxLayoutParams(), i = e.get("padding"), a = {
      width: t.getWidth(),
      height: t.getHeight()
    }, s = Er(r, a, i);
    ed(e.get("orient"), n, e.get("itemGap"), s.width, s.height), NC(n, r, a, i);
  }
  function _K(n, e) {
    var t = xm(e.get("padding")), r = e.getItemStyle([
      "color",
      "opacity"
    ]);
    return r.fill = e.get("backgroundColor"), n = new Vt({
      shape: {
        x: n.x - t[3],
        y: n.y - t[0],
        width: n.width + t[1] + t[3],
        height: n.height + t[0] + t[2],
        r: e.get("borderRadius")
      },
      style: r,
      silent: true,
      z2: -1
    }), n;
  }
  var Y_e = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i, a) {
      var s = this.group;
      if (s.removeAll(), !t.get("show")) return;
      var o = +t.get("itemSize"), l = t.get("orient") === "vertical", u = t.get("feature") || {}, c = this._features || (this._features = {}), h = [];
      P(u, function(p, g) {
        h.push(g);
      }), new ql(this._featureNames || [], h).add(d).update(d).remove(lt(d, null)).execute(), this._featureNames = h;
      function d(p, g) {
        var m = h[p], v = h[g], y = u[m], x = new on(y, t, t.ecModel), b;
        if (a && a.newTitle != null && a.featureName === m && (y.title = a.newTitle), m && !v) {
          if (q_e(m)) b = {
            onclick: x.option.onclick,
            featureName: m
          };
          else {
            var w = wK(m);
            if (!w) return;
            b = new w();
          }
          c[m] = b;
        } else if (b = c[v], !b) return;
        b.uid = ym("toolbox-feature"), b.model = x, b.ecModel = r, b.api = i;
        var _ = b instanceof ds;
        if (!m && v) {
          _ && b.dispose && b.dispose(r, i);
          return;
        }
        if (!x.get("show") || _ && b.unusable) {
          _ && b.remove && b.remove(r, i);
          return;
        }
        f(x, b, m), x.setIconStatus = function(S, I) {
          var C = this.option, T = this.iconPaths;
          C.iconStatus = C.iconStatus || {}, C.iconStatus[S] = I, T[S] && (I === "emphasis" ? Xl : Yl)(T[S]);
        }, b instanceof ds && b.render && b.render(x, r, i, a);
      }
      function f(p, g, m) {
        var v = p.getModel("iconStyle"), y = p.getModel([
          "emphasis",
          "iconStyle"
        ]), x = g instanceof ds && g.getIcons ? g.getIcons() : p.get("icon"), b = p.get("title") || {}, w, _;
        Ie(x) ? (w = {}, w[m] = x) : w = x, Ie(b) ? (_ = {}, _[m] = b) : _ = b;
        var S = p.iconPaths = {};
        P(w, function(I, C) {
          var T = Fx(I, {}, {
            x: -o / 2,
            y: -o / 2,
            width: o,
            height: o
          });
          T.setStyle(v.getItemStyle());
          var k = T.ensureState("emphasis");
          k.style = y.getItemStyle();
          var D = new Gt({
            style: {
              text: _[C],
              align: y.get("textAlign"),
              borderRadius: y.get("textBorderRadius"),
              padding: y.get("textPadding"),
              fill: null,
              font: nE({
                fontStyle: y.get("textFontStyle"),
                fontFamily: y.get("textFontFamily"),
                fontSize: y.get("textFontSize"),
                fontWeight: y.get("textFontWeight")
              }, r)
            },
            ignore: true
          });
          T.setTextContent(D), Pd({
            el: T,
            componentModel: t,
            itemName: C,
            formatterParamsExtra: {
              title: _[C]
            }
          }), T.__title = _[C], T.on("mouseover", function() {
            var R = y.getItemStyle(), N = l ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top";
            D.setStyle({
              fill: y.get("textFill") || R.fill || R.stroke || "#000",
              backgroundColor: y.get("textBackgroundColor")
            }), T.setTextConfig({
              position: y.get("textPosition") || N
            }), D.ignore = !t.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get([
              "iconStatus",
              C
            ]) !== "emphasis" && i.leaveEmphasis(this), D.hide();
          }), (p.get([
            "iconStatus",
            C
          ]) === "emphasis" ? Xl : Yl)(T), s.add(T), T.on("click", Ae(g.onclick, g, r, i, C)), S[C] = T;
        });
      }
      X_e(s, t, i), s.add(_K(s.getBoundingRect(), t)), l || s.eachChild(function(p) {
        var g = p.__title, m = p.ensureState("emphasis"), v = m.textConfig || (m.textConfig = {}), y = p.getTextContent(), x = y && y.ensureState("emphasis");
        if (x && !Xe(x) && g) {
          var b = x.style || (x.style = {}), w = Rx(g, Gt.makeFont(b)), _ = p.x + s.x, S = p.y + s.y + o, I = false;
          S + w.height > i.getHeight() && (v.position = "top", I = true);
          var C = I ? -5 - w.height : o + 10;
          _ + w.width / 2 > i.getWidth() ? (v.position = [
            "100%",
            C
          ], b.align = "right") : _ - w.width / 2 < 0 && (v.position = [
            0,
            C
          ], b.align = "left");
        }
      });
    }, e.prototype.updateView = function(t, r, i, a) {
      P(this._features, function(s) {
        s instanceof ds && s.updateView && s.updateView(s.model, r, i, a);
      });
    }, e.prototype.remove = function(t, r) {
      P(this._features, function(i) {
        i instanceof ds && i.remove && i.remove(t, r);
      }), this.group.removeAll();
    }, e.prototype.dispose = function(t, r) {
      P(this._features, function(i) {
        i instanceof ds && i.dispose && i.dispose(t, r);
      });
    }, e.type = "toolbox", e;
  }(Yn);
  function q_e(n) {
    return n.indexOf("my") === 0;
  }
  var j_e = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      var i = this.model, a = i.get("name") || t.get("title.0.text") || "echarts", s = r.getZr().painter.getType() === "svg", o = s ? "svg" : i.get("type", true) || "png", l = r.getConnectedDataURL({
        type: o,
        backgroundColor: i.get("backgroundColor", true) || t.get("backgroundColor") || "#fff",
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = Dt.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = a + "." + o, c.target = "_blank", c.href = l;
        var h = new MouseEvent("click", {
          view: document.defaultView,
          bubbles: true,
          cancelable: false
        });
        c.dispatchEvent(h);
      } else if (window.navigator.msSaveOrOpenBlob || s) {
        var d = l.split(","), f = d[0].indexOf("base64") > -1, p = s ? decodeURIComponent(d[1]) : d[1];
        f && (p = window.atob(p));
        var g = a + "." + o;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var m = p.length, v = new Uint8Array(m); m--; ) v[m] = p.charCodeAt(m);
          var y = new Blob([
            v
          ]);
          window.navigator.msSaveOrOpenBlob(y, g);
        } else {
          var x = document.createElement("iframe");
          document.body.appendChild(x);
          var b = x.contentWindow, w = b.document;
          w.open("image/svg+xml", "replace"), w.write(p), w.close(), b.focus(), w.execCommand("SaveAs", true, g), document.body.removeChild(x);
        }
      } else {
        var _ = i.get("lang"), S = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (_ && _[0] || "") + '" /></body>', I = window.open();
        I.document.write(S), I.document.title = a;
      }
    }, e.getDefaultOption = function(t) {
      var r = {
        show: true,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: t.getLocaleModel().get([
          "toolbox",
          "saveAsImage",
          "title"
        ]),
        type: "png",
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: [
          "toolbox"
        ],
        lang: t.getLocaleModel().get([
          "toolbox",
          "saveAsImage",
          "lang"
        ])
      };
      return r;
    }, e;
  }(ds), SW = "__ec_magicType_stack__", K_e = [
    [
      "line",
      "bar"
    ],
    [
      "stack"
    ]
  ], Z_e = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.getIcons = function() {
      var t = this.model, r = t.get("icon"), i = {};
      return P(t.get("type"), function(a) {
        r[a] && (i[a] = r[a]);
      }), i;
    }, e.getDefaultOption = function(t) {
      var r = {
        show: true,
        type: [],
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
        },
        title: t.getLocaleModel().get([
          "toolbox",
          "magicType",
          "title"
        ]),
        option: {},
        seriesIndex: {}
      };
      return r;
    }, e.prototype.onclick = function(t, r, i) {
      var a = this.model, s = a.get([
        "seriesIndex",
        i
      ]);
      if (CW[i]) {
        var o = {
          series: []
        }, l = function(h) {
          var d = h.subType, f = h.id, p = CW[i](d, f, h, a);
          p && (je(p, h.option), o.series.push(p));
          var g = h.coordinateSystem;
          if (g && g.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var m = g.getAxesByScale("ordinal")[0];
            if (m) {
              var v = m.dim, y = v + "Axis", x = h.getReferringComponents(y, yr).models[0], b = x.componentIndex;
              o[y] = o[y] || [];
              for (var w = 0; w <= b; w++) o[y][b] = o[y][b] || {};
              o[y][b].boundaryGap = i === "bar";
            }
          }
        };
        P(K_e, function(h) {
          bt(h, i) >= 0 && P(h, function(d) {
            a.setIconStatus(d, "normal");
          });
        }), a.setIconStatus(i, "emphasis"), t.eachComponent({
          mainType: "series",
          query: s == null ? null : {
            seriesIndex: s
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = pt({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get([
          "iconStatus",
          i
        ]) !== "emphasis" && (c = "tiled")), r.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: o,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, e;
  }(ds), CW = {
    line: function(n, e, t, r) {
      if (n === "bar") return pt({
        id: e,
        type: "line",
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, r.get([
        "option",
        "line"
      ]) || {}, true);
    },
    bar: function(n, e, t, r) {
      if (n === "line") return pt({
        id: e,
        type: "bar",
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, r.get([
        "option",
        "bar"
      ]) || {}, true);
    },
    stack: function(n, e, t, r) {
      var i = t.get("stack") === SW;
      if (n === "line" || n === "bar") return r.setIconStatus("stack", i ? "normal" : "emphasis"), pt({
        id: e,
        stack: i ? "" : SW
      }, r.get([
        "option",
        "stack"
      ]) || {}, true);
    }
  };
  cl({
    type: "changeMagicType",
    event: "magicTypeChanged",
    update: "prepareAndUpdate"
  }, function(n, e) {
    e.mergeOption(n.newOption);
  });
  var jC = new Array(60).join("-"), Wg = "	";
  function Q_e(n) {
    var e = {}, t = [], r = [];
    return n.eachRawSeries(function(i) {
      var a = i.coordinateSystem;
      if (a && (a.type === "cartesian2d" || a.type === "polar")) {
        var s = a.getBaseAxis();
        if (s.type === "category") {
          var o = s.dim + "_" + s.index;
          e[o] || (e[o] = {
            categoryAxis: s,
            valueAxis: a.getOtherAxis(s),
            series: []
          }, r.push({
            axisDim: s.dim,
            axisIndex: s.index
          })), e[o].series.push(i);
        } else t.push(i);
      } else t.push(i);
    }), {
      seriesGroupByCategoryAxis: e,
      other: t,
      meta: r
    };
  }
  function J_e(n) {
    var e = [];
    return P(n, function(t, r) {
      var i = t.categoryAxis, a = t.valueAxis, s = a.dim, o = [
        " "
      ].concat(me(t.series, function(f) {
        return f.name;
      })), l = [
        i.model.getCategories()
      ];
      P(t.series, function(f) {
        var p = f.getRawData();
        l.push(f.getRawData().mapArray(p.mapDimension(s), function(g) {
          return g;
        }));
      });
      for (var u = [
        o.join(Wg)
      ], c = 0; c < l[0].length; c++) {
        for (var h = [], d = 0; d < l.length; d++) h.push(l[d][c]);
        u.push(h.join(Wg));
      }
      e.push(u.join(`
`));
    }), e.join(`

` + jC + `

`);
  }
  function eSe(n) {
    return me(n, function(e) {
      var t = e.getRawData(), r = [
        e.name
      ], i = [];
      return t.each(t.dimensions, function() {
        for (var a = arguments.length, s = arguments[a - 1], o = t.getName(s), l = 0; l < a - 1; l++) i[l] = arguments[l];
        r.push((o ? o + Wg : "") + i.join(Wg));
      }), r.join(`
`);
    }).join(`

` + jC + `

`);
  }
  function tSe(n) {
    var e = Q_e(n);
    return {
      value: rn([
        J_e(e.seriesGroupByCategoryAxis),
        eSe(e.other)
      ], function(t) {
        return !!t.replace(/[\n\t\s]/g, "");
      }).join(`

` + jC + `

`),
      meta: e.meta
    };
  }
  function gS(n) {
    return n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function nSe(n) {
    var e = n.slice(0, n.indexOf(`
`));
    if (e.indexOf(Wg) >= 0) return true;
  }
  var WR = new RegExp("[" + Wg + "]+", "g");
  function rSe(n) {
    for (var e = n.split(/\n+/g), t = gS(e.shift()).split(WR), r = [], i = me(t, function(l) {
      return {
        name: l,
        data: []
      };
    }), a = 0; a < e.length; a++) {
      var s = gS(e[a]).split(WR);
      r.push(s.shift());
      for (var o = 0; o < s.length; o++) i[o] && (i[o].data[a] = s[o]);
    }
    return {
      series: i,
      categories: r
    };
  }
  function iSe(n) {
    for (var e = n.split(/\n+/g), t = gS(e.shift()), r = [], i = 0; i < e.length; i++) {
      var a = gS(e[i]);
      if (a) {
        var s = a.split(WR), o = "", l = void 0, u = false;
        isNaN(s[0]) ? (u = true, o = s[0], s = s.slice(1), r[i] = {
          name: o,
          value: []
        }, l = r[i].value) : l = r[i] = [];
        for (var c = 0; c < s.length; c++) l.push(+s[c]);
        l.length === 1 && (u ? r[i].value = l[0] : r[i] = l[0]);
      }
    }
    return {
      name: t,
      data: r
    };
  }
  function aSe(n, e) {
    var t = n.split(new RegExp(`
*` + jC + `
*`, "g")), r = {
      series: []
    };
    return P(t, function(i, a) {
      if (nSe(i)) {
        var s = rSe(i), o = e[a], l = o.axisDim + "Axis";
        o && (r[l] = r[l] || [], r[l][o.axisIndex] = {
          data: s.categories
        }, r.series = r.series.concat(s.series));
      } else {
        var s = iSe(i);
        r.series.push(s);
      }
    }), r;
  }
  var sSe = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      setTimeout(function() {
        r.dispatchAction({
          type: "hideTip"
        });
      });
      var i = r.getDom(), a = this.model;
      this._dom && i.removeChild(this._dom);
      var s = document.createElement("div");
      s.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", s.style.backgroundColor = a.get("backgroundColor") || "#fff";
      var o = document.createElement("h4"), l = a.get("lang") || [];
      o.innerHTML = l[0] || a.get("title"), o.style.cssText = "margin:10px 20px", o.style.color = a.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var h = a.get("optionToContent"), d = a.get("contentToOption"), f = tSe(t);
      if (Xe(h)) {
        var p = h(r.getOption());
        Ie(p) ? u.innerHTML = p : Ng(p) && u.appendChild(p);
      } else {
        c.readOnly = a.get("readOnly");
        var g = c.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = a.get("textColor"), g.borderColor = a.get("textareaBorderColor"), g.backgroundColor = a.get("textareaColor"), c.value = f.value, u.appendChild(c);
      }
      var m = f.meta, v = document.createElement("div");
      v.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", x = document.createElement("div"), b = document.createElement("div");
      y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
      var w = this;
      function _() {
        i.removeChild(s), w._dom = null;
      }
      bD(x, "click", _), bD(b, "click", function() {
        if (d == null && h != null || d != null && h == null) {
          _();
          return;
        }
        var S;
        try {
          Xe(d) ? S = d(u, r.getOption()) : S = aSe(c.value, m);
        } catch (I) {
          throw _(), new Error("Data view format error " + I);
        }
        S && r.dispatchAction({
          type: "changeDataView",
          newOption: S
        }), _();
      }), x.innerHTML = l[1], b.innerHTML = l[2], b.style.cssText = x.style.cssText = y, !a.get("readOnly") && v.appendChild(b), v.appendChild(x), s.appendChild(o), s.appendChild(u), s.appendChild(v), u.style.height = i.clientHeight - 80 + "px", i.appendChild(s), this._dom = s;
    }, e.prototype.remove = function(t, r) {
      this._dom && r.getDom().removeChild(this._dom);
    }, e.prototype.dispose = function(t, r) {
      this.remove(t, r);
    }, e.getDefaultOption = function(t) {
      var r = {
        show: true,
        readOnly: false,
        optionToContent: null,
        contentToOption: null,
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: t.getLocaleModel().get([
          "toolbox",
          "dataView",
          "title"
        ]),
        lang: t.getLocaleModel().get([
          "toolbox",
          "dataView",
          "lang"
        ]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return r;
    }, e;
  }(ds);
  function oSe(n, e) {
    return me(n, function(t, r) {
      var i = e && e[r];
      if (Ze(i) && !de(i)) {
        var a = Ze(t) && !de(t);
        a || (t = {
          value: t
        });
        var s = i.name != null && t.name == null;
        return t = je(t, i), s && delete t.name, t;
      } else return t;
    });
  }
  cl({
    type: "changeDataView",
    event: "dataViewChanged",
    update: "prepareAndUpdate"
  }, function(n, e) {
    var t = [];
    P(n.newOption.series, function(r) {
      var i = e.getSeriesByName(r.name)[0];
      if (!i) t.push(oe({
        type: "scatter"
      }, r));
      else {
        var a = i.get("data");
        t.push({
          name: r.name,
          data: oSe(r.data, a)
        });
      }
    }), e.mergeOption(je({
      series: t
    }, n.newOption));
  });
  var SK = P, CK = Wt();
  function lSe(n, e) {
    var t = kM(n);
    SK(e, function(r, i) {
      for (var a = t.length - 1; a >= 0; a--) {
        var s = t[a];
        if (s[i]) break;
      }
      if (a < 0) {
        var o = n.queryComponents({
          mainType: "dataZoom",
          subType: "select",
          id: i
        })[0];
        if (o) {
          var l = o.getPercentRange();
          t[0][i] = {
            dataZoomId: i,
            start: l[0],
            end: l[1]
          };
        }
      }
    }), t.push(e);
  }
  function uSe(n) {
    var e = kM(n), t = e[e.length - 1];
    e.length > 1 && e.pop();
    var r = {};
    return SK(t, function(i, a) {
      for (var s = e.length - 1; s >= 0; s--) if (i = e[s][a], i) {
        r[a] = i;
        break;
      }
    }), r;
  }
  function cSe(n) {
    CK(n).snapshots = null;
  }
  function hSe(n) {
    return kM(n).length;
  }
  function kM(n) {
    var e = CK(n);
    return e.snapshots || (e.snapshots = [
      {}
    ]), e.snapshots;
  }
  var dSe = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, r) {
      cSe(t), r.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: true,
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: t.getLocaleModel().get([
          "toolbox",
          "restore",
          "title"
        ])
      };
      return r;
    }, e;
  }(ds);
  cl({
    type: "restore",
    event: "restore",
    update: "prepareAndUpdate"
  }, function(n, e) {
    e.resetOption("recreate");
  });
  var fSe = [
    "grid",
    "xAxis",
    "yAxis",
    "geo",
    "graph",
    "polar",
    "radiusAxis",
    "angleAxis",
    "bmap"
  ], TM = function() {
    function n(e, t, r) {
      var i = this;
      this._targetInfoList = [];
      var a = IW(t, e);
      P(pSe, function(s, o) {
        (!r || !r.include || bt(r.include, o) >= 0) && s(a, i._targetInfoList);
      });
    }
    return n.prototype.setOutputRanges = function(e, t) {
      return this.matchOutputRanges(e, t, function(r, i, a) {
        if ((r.coordRanges || (r.coordRanges = [])).push(i), !r.coordRange) {
          r.coordRange = i;
          var s = LT[r.brushType](0, a, i);
          r.__rangeOffset = {
            offset: DW[r.brushType](s.values, r.range, [
              1,
              1
            ]),
            xyMinMax: s.xyMinMax
          };
        }
      }), e;
    }, n.prototype.matchOutputRanges = function(e, t, r) {
      P(e, function(i) {
        var a = this.findTargetInfo(i, t);
        a && a !== true && P(a.coordSyses, function(s) {
          var o = LT[i.brushType](1, s, i.range, true);
          r(i, o.values, s, t);
        });
      }, this);
    }, n.prototype.setInputRanges = function(e, t) {
      P(e, function(r) {
        var i = this.findTargetInfo(r, t);
        if (r.range = r.range || [], i && i !== true) {
          r.panelId = i.panelId;
          var a = LT[r.brushType](0, i.coordSys, r.coordRange), s = r.__rangeOffset;
          r.range = s ? DW[r.brushType](a.values, s.offset, gSe(a.xyMinMax, s.xyMinMax)) : a.values;
        }
      }, this);
    }, n.prototype.makePanelOpts = function(e, t) {
      return me(this._targetInfoList, function(r) {
        var i = r.getPanelRect();
        return {
          panelId: r.panelId,
          defaultBrushType: t ? t(r) : null,
          clipPath: Nj(i),
          isTargetByCursor: Mj(i, e, r.coordSysModel),
          getLinearBrushOtherExtent: Ej(i)
        };
      });
    }, n.prototype.controlSeries = function(e, t, r) {
      var i = this.findTargetInfo(e, r);
      return i === true || i && bt(i.coordSyses, t.coordinateSystem) >= 0;
    }, n.prototype.findTargetInfo = function(e, t) {
      for (var r = this._targetInfoList, i = IW(t, e), a = 0; a < r.length; a++) {
        var s = r[a], o = e.panelId;
        if (o) {
          if (s.panelId === o) return s;
        } else for (var l = 0; l < kW.length; l++) if (kW[l](i, s)) return s;
      }
      return true;
    }, n;
  }();
  function GR(n) {
    return n[0] > n[1] && n.reverse(), n;
  }
  function IW(n, e) {
    return i0(n, e, {
      includeMainTypes: fSe
    });
  }
  var pSe = {
    grid: function(n, e) {
      var t = n.xAxisModels, r = n.yAxisModels, i = n.gridModels, a = Pe(), s = {}, o = {};
      !t && !r && !i || (P(t, function(l) {
        var u = l.axis.grid.model;
        a.set(u.id, u), s[u.id] = true;
      }), P(r, function(l) {
        var u = l.axis.grid.model;
        a.set(u.id, u), o[u.id] = true;
      }), P(i, function(l) {
        a.set(l.id, l), s[l.id] = true, o[l.id] = true;
      }), a.each(function(l) {
        var u = l.coordinateSystem, c = [];
        P(u.getCartesians(), function(h, d) {
          (bt(t, h.getAxis("x").model) >= 0 || bt(r, h.getAxis("y").model) >= 0) && c.push(h);
        }), e.push({
          panelId: "grid--" + l.id,
          gridModel: l,
          coordSysModel: l,
          coordSys: c[0],
          coordSyses: c,
          getPanelRect: TW.grid,
          xAxisDeclared: s[l.id],
          yAxisDeclared: o[l.id]
        });
      }));
    },
    geo: function(n, e) {
      P(n.geoModels, function(t) {
        var r = t.coordinateSystem;
        e.push({
          panelId: "geo--" + t.id,
          geoModel: t,
          coordSysModel: t,
          coordSys: r,
          coordSyses: [
            r
          ],
          getPanelRect: TW.geo
        });
      });
    }
  }, kW = [
    function(n, e) {
      var t = n.xAxisModel, r = n.yAxisModel, i = n.gridModel;
      return !i && t && (i = t.axis.grid.model), !i && r && (i = r.axis.grid.model), i && i === e.gridModel;
    },
    function(n, e) {
      var t = n.geoModel;
      return t && t === e.geoModel;
    }
  ], TW = {
    grid: function() {
      return this.coordSys.master.getRect().clone();
    },
    geo: function() {
      var n = this.coordSys, e = n.getBoundingRect().clone();
      return e.applyTransform(Jh(n)), e;
    }
  }, LT = {
    lineX: lt(AW, 0),
    lineY: lt(AW, 1),
    rect: function(n, e, t, r) {
      var i = n ? e.pointToData([
        t[0][0],
        t[1][0]
      ], r) : e.dataToPoint([
        t[0][0],
        t[1][0]
      ], r), a = n ? e.pointToData([
        t[0][1],
        t[1][1]
      ], r) : e.dataToPoint([
        t[0][1],
        t[1][1]
      ], r), s = [
        GR([
          i[0],
          a[0]
        ]),
        GR([
          i[1],
          a[1]
        ])
      ];
      return {
        values: s,
        xyMinMax: s
      };
    },
    polygon: function(n, e, t, r) {
      var i = [
        [
          1 / 0,
          -1 / 0
        ],
        [
          1 / 0,
          -1 / 0
        ]
      ], a = me(t, function(s) {
        var o = n ? e.pointToData(s, r) : e.dataToPoint(s, r);
        return i[0][0] = Math.min(i[0][0], o[0]), i[1][0] = Math.min(i[1][0], o[1]), i[0][1] = Math.max(i[0][1], o[0]), i[1][1] = Math.max(i[1][1], o[1]), o;
      });
      return {
        values: a,
        xyMinMax: i
      };
    }
  };
  function AW(n, e, t, r) {
    var i = t.getAxis([
      "x",
      "y"
    ][n]), a = GR(me([
      0,
      1
    ], function(o) {
      return e ? i.coordToData(i.toLocalCoord(r[o]), true) : i.toGlobalCoord(i.dataToCoord(r[o]));
    })), s = [];
    return s[n] = a, s[1 - n] = [
      NaN,
      NaN
    ], {
      values: a,
      xyMinMax: s
    };
  }
  var DW = {
    lineX: lt(RW, 0),
    lineY: lt(RW, 1),
    rect: function(n, e, t) {
      return [
        [
          n[0][0] - t[0] * e[0][0],
          n[0][1] - t[0] * e[0][1]
        ],
        [
          n[1][0] - t[1] * e[1][0],
          n[1][1] - t[1] * e[1][1]
        ]
      ];
    },
    polygon: function(n, e, t) {
      return me(n, function(r, i) {
        return [
          r[0] - t[0] * e[i][0],
          r[1] - t[1] * e[i][1]
        ];
      });
    }
  };
  function RW(n, e, t, r) {
    return [
      e[0] - r[n] * t[0],
      e[1] - r[n] * t[1]
    ];
  }
  function gSe(n, e) {
    var t = $W(n), r = $W(e), i = [
      t[0] / r[0],
      t[1] / r[1]
    ];
    return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
  }
  function $W(n) {
    return n ? [
      n[0][1] - n[0][0],
      n[1][1] - n[1][0]
    ] : [
      NaN,
      NaN
    ];
  }
  var UR = P, mSe = Sle("toolbox-dataZoom_"), vSe = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i, a) {
      this._brushController || (this._brushController = new eM(i.getZr()), this._brushController.on("brush", Ae(this._onBrush, this)).mount()), bSe(t, r, this, a, i), xSe(t, r);
    }, e.prototype.onclick = function(t, r, i) {
      ySe[i].call(this);
    }, e.prototype.remove = function(t, r) {
      this._brushController && this._brushController.unmount();
    }, e.prototype.dispose = function(t, r) {
      this._brushController && this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var r = t.areas;
      if (!t.isEnd || !r.length) return;
      var i = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var s = new TM(AM(this.model), a, {
        include: [
          "grid"
        ]
      });
      s.matchOutputRanges(r, a, function(u, c, h) {
        if (h.type === "cartesian2d") {
          var d = u.brushType;
          d === "rect" ? (o("x", h, c[0]), o("y", h, c[1])) : o({
            lineX: "x",
            lineY: "y"
          }[d], h, c);
        }
      }), lSe(a, i), this._dispatchZoomAction(i);
      function o(u, c, h) {
        var d = c.getAxis(u), f = d.model, p = l(u, f, a), g = p.findRepresentativeAxisProxy(f).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (h = Vd(0, h.slice(), d.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: h[0],
          endValue: h[1]
        });
      }
      function l(u, c, h) {
        var d;
        return h.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(f) {
          var p = f.getAxisModel(u, c.componentIndex);
          p && (d = f);
        }), d;
      }
    }, e.prototype._dispatchZoomAction = function(t) {
      var r = [];
      UR(t, function(i, a) {
        r.push(Qe(i));
      }), r.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: r
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: true,
        filterMode: "filter",
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        title: t.getLocaleModel().get([
          "toolbox",
          "dataZoom",
          "title"
        ]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return r;
    }, e;
  }(ds), ySe = {
    zoom: function() {
      var n = !this._isZoomActive;
      this.api.dispatchAction({
        type: "takeGlobalCursor",
        key: "dataZoomSelect",
        dataZoomSelectActive: n
      });
    },
    back: function() {
      this._dispatchZoomAction(uSe(this.ecModel));
    }
  };
  function AM(n) {
    var e = {
      xAxisIndex: n.get("xAxisIndex", true),
      yAxisIndex: n.get("yAxisIndex", true),
      xAxisId: n.get("xAxisId", true),
      yAxisId: n.get("yAxisId", true)
    };
    return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e;
  }
  function xSe(n, e) {
    n.setIconStatus("back", hSe(e) > 1 ? "emphasis" : "normal");
  }
  function bSe(n, e, t, r, i) {
    var a = t._isZoomActive;
    r && r.type === "takeGlobalCursor" && (a = r.key === "dataZoomSelect" ? r.dataZoomSelectActive : false), t._isZoomActive = a, n.setIconStatus("zoom", a ? "emphasis" : "normal");
    var s = new TM(AM(n), e, {
      include: [
        "grid"
      ]
    }), o = s.makePanelOpts(i, function(l) {
      return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
    });
    t._brushController.setPanels(o).enableBrush(a && o.length ? {
      brushType: "auto",
      brushStyle: n.getModel("brushStyle").getItemStyle()
    } : false);
  }
  qce("dataZoom", function(n) {
    var e = n.getComponent("toolbox", 0), t = [
      "feature",
      "dataZoom"
    ];
    if (!e || e.get(t) == null) return;
    var r = e.getModel(t), i = [], a = AM(r), s = i0(n, a);
    UR(s.xAxisModels, function(l) {
      return o(l, "xAxis", "xAxisIndex");
    }), UR(s.yAxisModels, function(l) {
      return o(l, "yAxis", "yAxisIndex");
    });
    function o(l, u, c) {
      var h = l.componentIndex, d = {
        type: "select",
        $fromToolbox: true,
        filterMode: r.get("filterMode", true) || "filter",
        id: mSe + u + h
      };
      d[c] = h, i.push(d);
    }
    return i;
  });
  function wSe(n) {
    n.registerComponentModel(H_e), n.registerComponentView(Y_e), sg("saveAsImage", j_e), sg("magicType", Z_e), sg("dataView", sSe), sg("dataZoom", vSe), sg("restore", dSe), Ct(U_e);
  }
  var _Se = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "tooltip", e.dependencies = [
      "axisPointer"
    ], e.defaultOption = {
      z: 60,
      show: true,
      showContent: true,
      trigger: "item",
      triggerOn: "mousemove|click",
      alwaysShowContent: false,
      displayMode: "single",
      renderMode: "auto",
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: false,
      backgroundColor: "#fff",
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      borderRadius: 4,
      borderWidth: 1,
      padding: null,
      extraCssText: "",
      axisPointer: {
        type: "line",
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          textStyle: {}
        }
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, e;
  }(Et);
  function IK(n) {
    var e = n.get("confine");
    return e != null ? !!e : n.get("renderMode") === "richText";
  }
  function kK(n) {
    if (Dt.domSupported) {
      for (var e = document.documentElement.style, t = 0, r = n.length; t < r; t++) if (n[t] in e) return n[t];
    }
  }
  var TK = kK([
    "transform",
    "webkitTransform",
    "OTransform",
    "MozTransform",
    "msTransform"
  ]), SSe = kK([
    "webkitTransition",
    "transition",
    "OTransition",
    "MozTransition",
    "msTransition"
  ]);
  function AK(n, e) {
    if (!n) return e;
    e = sX(e, true);
    var t = n.indexOf(e);
    return n = t === -1 ? e : "-" + n.slice(0, t) + "-" + e, n.toLowerCase();
  }
  function CSe(n, e) {
    var t = n.currentStyle || document.defaultView && document.defaultView.getComputedStyle(n);
    return t ? t[e] : null;
  }
  var ISe = AK(SSe, "transition"), DM = AK(TK, "transform"), kSe = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (Dt.transform3dSupported ? "will-change:transform;" : "");
  function TSe(n) {
    return n = n === "left" ? "right" : n === "right" ? "left" : n === "top" ? "bottom" : "top", n;
  }
  function ASe(n, e, t) {
    if (!Ie(t) || t === "inside") return "";
    var r = n.get("backgroundColor"), i = n.get("borderWidth");
    e = fd(e);
    var a = TSe(t), s = Math.max(Math.round(i) * 1.5, 6), o = "", l = DM + ":", u;
    bt([
      "left",
      "right"
    ], a) > -1 ? (o += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (o += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
    var c = u * Math.PI / 180, h = s + i, d = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), f = Math.round(((d - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (d - h) / 2) * 100) / 100;
    o += ";" + a + ":-" + f + "px";
    var p = e + " solid " + i + "px;", g = [
      "position:absolute;width:" + s + "px;height:" + s + "px;z-index:-1;",
      o + ";" + l + ";",
      "border-bottom:" + p,
      "border-right:" + p,
      "background-color:" + r + ";"
    ];
    return '<div style="' + g.join("") + '"></div>';
  }
  function DSe(n, e) {
    var t = "cubic-bezier(0.23,1,0.32,1)", r = " " + n / 2 + "s " + t, i = "opacity" + r + ",visibility" + r;
    return e || (r = " " + n + "s " + t, i += Dt.transformSupported ? "," + DM + r : ",left" + r + ",top" + r), ISe + ":" + i;
  }
  function NW(n, e, t) {
    var r = n.toFixed(0) + "px", i = e.toFixed(0) + "px";
    if (!Dt.transformSupported) return t ? "top:" + i + ";left:" + r + ";" : [
      [
        "top",
        i
      ],
      [
        "left",
        r
      ]
    ];
    var a = Dt.transform3dSupported, s = "translate" + (a ? "3d" : "") + "(" + r + "," + i + (a ? ",0" : "") + ")";
    return t ? "top:0;left:0;" + DM + ":" + s + ";" : [
      [
        "top",
        0
      ],
      [
        "left",
        0
      ],
      [
        TK,
        s
      ]
    ];
  }
  function RSe(n) {
    var e = [], t = n.get("fontSize"), r = n.getTextColor();
    r && e.push("color:" + r), e.push("font:" + n.getFont());
    var i = it(n.get("lineHeight"), Math.round(t * 3 / 2));
    t && e.push("line-height:" + i + "px");
    var a = n.get("textShadowColor"), s = n.get("textShadowBlur") || 0, o = n.get("textShadowOffsetX") || 0, l = n.get("textShadowOffsetY") || 0;
    return a && s && e.push("text-shadow:" + o + "px " + l + "px " + s + "px " + a), P([
      "decoration",
      "align"
    ], function(u) {
      var c = n.get(u);
      c && e.push("text-" + u + ":" + c);
    }), e.join(";");
  }
  function $Se(n, e, t) {
    var r = [], i = n.get("transitionDuration"), a = n.get("backgroundColor"), s = n.get("shadowBlur"), o = n.get("shadowColor"), l = n.get("shadowOffsetX"), u = n.get("shadowOffsetY"), c = n.getModel("textStyle"), h = zX(n, "html"), d = l + "px " + u + "px " + s + "px " + o;
    return r.push("box-shadow:" + d), e && i && r.push(DSe(i, t)), a && r.push("background-color:" + a), P([
      "width",
      "color",
      "radius"
    ], function(f) {
      var p = "border-" + f, g = sX(p), m = n.get(g);
      m != null && r.push(p + ":" + m + (f === "color" ? "" : "px"));
    }), r.push(RSe(c)), h != null && r.push("padding:" + xm(h).join("px ") + "px"), r.join(";") + ";";
  }
  function EW(n, e, t, r, i) {
    var a = e && e.painter;
    if (t) {
      var s = a && a.getViewportRoot();
      s && Qse(n, s, t, r, i);
    } else {
      n[0] = r, n[1] = i;
      var o = a && a.getViewportRootOffset();
      o && (n[0] += o.offsetLeft, n[1] += o.offsetTop);
    }
    n[2] = n[0] / e.getWidth(), n[3] = n[1] / e.getHeight();
  }
  var NSe = function() {
    function n(e, t) {
      if (this._show = false, this._styleCoord = [
        0,
        0,
        0,
        0
      ], this._enterable = true, this._alwaysShowContent = false, this._firstShow = true, this._longHide = true, Dt.wxa) return null;
      var r = document.createElement("div");
      r.domBelongToZr = true, this.el = r;
      var i = this._zr = e.getZr(), a = t.appendTo, s = a && (Ie(a) ? document.querySelector(a) : Ng(a) ? a : Xe(a) && a(e.getDom()));
      EW(this._styleCoord, i, s, e.getWidth() / 2, e.getHeight() / 2), (s || e.getDom()).appendChild(r), this._api = e, this._container = s;
      var o = this;
      r.onmouseenter = function() {
        o._enterable && (clearTimeout(o._hideTimeout), o._show = true), o._inContent = true;
      }, r.onmousemove = function(l) {
        if (l = l || window.event, !o._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          ss(c, l, true), u.dispatch("mousemove", l);
        }
      }, r.onmouseleave = function() {
        o._inContent = false, o._enterable && o._show && o.hideLater(o._hideDelay);
      };
    }
    return n.prototype.update = function(e) {
      if (!this._container) {
        var t = this._api.getDom(), r = CSe(t, "position"), i = t.style;
        i.position !== "absolute" && r !== "absolute" && (i.position = "relative");
      }
      var a = e.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = e.get("className") || "";
    }, n.prototype.show = function(e, t) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var r = this.el, i = r.style, a = this._styleCoord;
      r.innerHTML ? i.cssText = kSe + $Se(e, !this._firstShow, this._longHide) + NW(a[0], a[1], true) + ("border-color:" + fd(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = true, this._firstShow = false, this._longHide = false;
    }, n.prototype.setContent = function(e, t, r, i, a) {
      var s = this.el;
      if (e == null) {
        s.innerHTML = "";
        return;
      }
      var o = "";
      if (Ie(a) && r.get("trigger") === "item" && !IK(r) && (o = ASe(r, i, a)), Ie(e)) s.innerHTML = e + o;
      else if (e) {
        s.innerHTML = "", de(e) || (e = [
          e
        ]);
        for (var l = 0; l < e.length; l++) Ng(e[l]) && e[l].parentNode !== s && s.appendChild(e[l]);
        if (o && s.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = o, s.appendChild(u);
        }
      }
    }, n.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, n.prototype.getSize = function() {
      var e = this.el;
      return e ? [
        e.offsetWidth,
        e.offsetHeight
      ] : [
        0,
        0
      ];
    }, n.prototype.moveTo = function(e, t) {
      if (this.el) {
        var r = this._styleCoord;
        if (EW(r, this._zr, this._container, e, t), r[0] != null && r[1] != null) {
          var i = this.el.style, a = NW(r[0], r[1]);
          P(a, function(s) {
            i[s[0]] = s[1];
          });
        }
      }
    }, n.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, n.prototype.hide = function() {
      var e = this, t = this.el.style;
      t.visibility = "hidden", t.opacity = "0", Dt.transform3dSupported && (t.willChange = ""), this._show = false, this._longHideTimeout = setTimeout(function() {
        return e._longHide = true;
      }, 500);
    }, n.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = false, this._hideTimeout = setTimeout(Ae(this.hide, this), e)) : this.hide());
    }, n.prototype.isShow = function() {
      return this._show;
    }, n.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var e = this.el.parentNode;
      e && e.removeChild(this.el), this.el = this._container = null;
    }, n;
  }(), ESe = function() {
    function n(e) {
      this._show = false, this._styleCoord = [
        0,
        0,
        0,
        0
      ], this._alwaysShowContent = false, this._enterable = true, this._zr = e.getZr(), PW(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2);
    }
    return n.prototype.update = function(e) {
      var t = e.get("alwaysShowContent");
      t && this._moveIfResized(), this._alwaysShowContent = t;
    }, n.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = true;
    }, n.prototype.setContent = function(e, t, r, i, a) {
      var s = this;
      Ze(e) && nn(""), this.el && this._zr.remove(this.el);
      var o = r.getModel("textStyle");
      this.el = new Gt({
        style: {
          rich: t.richTextStyles,
          text: e,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: o.get("textShadowColor"),
          fill: r.get([
            "textStyle",
            "color"
          ]),
          padding: zX(r, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: r.get("z")
      }), P([
        "backgroundColor",
        "borderRadius",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY"
      ], function(u) {
        s.el.style[u] = r.get(u);
      }), P([
        "textShadowBlur",
        "textShadowOffsetX",
        "textShadowOffsetY"
      ], function(u) {
        s.el.style[u] = o.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = true), l._inContent = true;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = false;
      });
    }, n.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, n.prototype.getSize = function() {
      var e = this.el, t = this.el.getBoundingRect(), r = MW(e.style);
      return [
        t.width + r.left + r.right,
        t.height + r.top + r.bottom
      ];
    }, n.prototype.moveTo = function(e, t) {
      var r = this.el;
      if (r) {
        var i = this._styleCoord;
        PW(i, this._zr, e, t), e = i[0], t = i[1];
        var a = r.style, s = ku(a.borderWidth || 0), o = MW(a);
        r.x = e + s + o.left, r.y = t + s + o.top, r.markRedraw();
      }
    }, n.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, n.prototype.hide = function() {
      this.el && this.el.hide(), this._show = false;
    }, n.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = false, this._hideTimeout = setTimeout(Ae(this.hide, this), e)) : this.hide());
    }, n.prototype.isShow = function() {
      return this._show;
    }, n.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, n;
  }();
  function ku(n) {
    return Math.max(0, n);
  }
  function MW(n) {
    var e = ku(n.shadowBlur || 0), t = ku(n.shadowOffsetX || 0), r = ku(n.shadowOffsetY || 0);
    return {
      left: ku(e - t),
      right: ku(e + t),
      top: ku(e - r),
      bottom: ku(e + r)
    };
  }
  function PW(n, e, t, r) {
    n[0] = t, n[1] = r, n[2] = n[0] / e.getWidth(), n[3] = n[1] / e.getHeight();
  }
  var MSe = new Vt({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  }), PSe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      if (!(Dt.node || !r.getDom())) {
        var i = t.getComponent("tooltip"), a = this._renderMode = Rle(i.get("renderMode"));
        this._tooltipContent = a === "richText" ? new ESe(r) : new NSe(r, {
          appendTo: i.get("appendToBody", true) ? "body" : i.get("appendTo", true)
        });
      }
    }, e.prototype.render = function(t, r, i) {
      if (!(Dt.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = t, this._ecModel = r, this._api = i;
        var a = this._tooltipContent;
        a.update(t), a.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? Sm(this, "_updatePosition", 50, "fixRate") : F0(this, "_updatePosition");
      }
    }, e.prototype._initGlobalListener = function() {
      var t = this._tooltipModel, r = t.get("triggerOn");
      dK("itemTooltip", this._api, Ae(function(i, a, s) {
        r !== "none" && (r.indexOf(i) >= 0 ? this._tryShow(a, s) : i === "leave" && this._hide(s));
      }, this));
    }, e.prototype._keepShow = function() {
      var t = this._tooltipModel, r = this._ecModel, i = this._api, a = t.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var s = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && s.manuallyShowTip(t, r, i, {
            x: s._lastX,
            y: s._lastY,
            dataByCoordSys: s._lastDataByCoordSys
          });
        });
      }
    }, e.prototype.manuallyShowTip = function(t, r, i, a) {
      if (!(a.from === this.uid || Dt.node || !i.getDom())) {
        var s = LW(a, i);
        this._ticket = "";
        var o = a.dataByCoordSys, l = BSe(a, r, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            positionDefault: "bottom"
          }, s);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = MSe;
          c.x = a.x, c.y = a.y, c.update(), rt(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, s);
        } else if (o) this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          dataByCoordSys: o,
          tooltipOption: a.tooltipOption
        }, s);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(t, r, i, a)) return;
          var h = fK(a, r), d = h.point[0], f = h.point[1];
          d != null && f != null && this._tryShow({
            offsetX: d,
            offsetY: f,
            target: h.el,
            position: a.position,
            positionDefault: "bottom"
          }, s);
        } else a.x != null && a.y != null && (i.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: i.getZr().findHover(a.x, a.y).target
        }, s));
      }
    }, e.prototype.manuallyHideTip = function(t, r, i, a) {
      var s = this._tooltipContent;
      this._tooltipModel && s.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(LW(a, i));
    }, e.prototype._manuallyAxisShowTip = function(t, r, i, a) {
      var s = a.seriesIndex, o = a.dataIndex, l = r.getComponent("axisPointer").coordSysAxesInfo;
      if (!(s == null || o == null || l == null)) {
        var u = r.getSeriesByIndex(s);
        if (u) {
          var c = u.getData(), h = py([
            c.getItemModel(o),
            u,
            (u.coordinateSystem || {}).model
          ], this._tooltipModel);
          if (h.get("trigger") === "axis") return i.dispatchAction({
            type: "updateAxisPointer",
            seriesIndex: s,
            dataIndex: o,
            position: a.position
          }), true;
        }
      }
    }, e.prototype._tryShow = function(t, r) {
      var i = t.target, a = this._tooltipModel;
      if (a) {
        this._lastX = t.offsetX, this._lastY = t.offsetY;
        var s = t.dataByCoordSys;
        if (s && s.length) this._showAxisTooltip(s, t);
        else if (i) {
          var o = rt(i);
          if (o.ssrType === "legend") return;
          this._lastDataByCoordSys = null;
          var l, u;
          Bh(i, function(c) {
            if (rt(c).dataIndex != null) return l = c, true;
            if (rt(c).tooltipConfig != null) return u = c, true;
          }, true), l ? this._showSeriesItemTooltip(t, l, r) : u ? this._showComponentItemTooltip(t, u, r) : this._hide(r);
        } else this._lastDataByCoordSys = null, this._hide(r);
      }
    }, e.prototype._showOrMove = function(t, r) {
      var i = t.get("showDelay");
      r = Ae(r, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(r, i) : r();
    }, e.prototype._showAxisTooltip = function(t, r) {
      var i = this._ecModel, a = this._tooltipModel, s = [
        r.offsetX,
        r.offsetY
      ], o = py([
        r.tooltipOption
      ], a), l = this._renderMode, u = [], c = Xr("section", {
        blocks: [],
        noHeader: true
      }), h = [], d = new wk();
      P(t, function(y) {
        P(y.dataByAxis, function(x) {
          var b = i.getComponent(x.axisDim + "Axis", x.axisIndex), w = x.value;
          if (!(!b || w == null)) {
            var _ = uK(w, b.axis, i, x.seriesDataIndices, x.valueLabelOpt), S = Xr("section", {
              header: _,
              noHeader: !Hs(_),
              sortBlocks: true,
              blocks: []
            });
            c.blocks.push(S), P(x.seriesDataIndices, function(I) {
              var C = i.getSeriesByIndex(I.seriesIndex), T = I.dataIndexInside, k = C.getDataParams(T);
              if (!(k.dataIndex < 0)) {
                k.axisDim = x.axisDim, k.axisIndex = x.axisIndex, k.axisType = x.axisType, k.axisId = x.axisId, k.axisValue = AE(b.axis, {
                  value: w
                }), k.axisValueLabel = _, k.marker = d.makeTooltipMarker("item", fd(k.color), l);
                var D = _O(C.formatTooltip(T, true, null)), R = D.frag;
                if (R) {
                  var N = py([
                    C
                  ], a).get("valueFormatter");
                  S.blocks.push(N ? oe({
                    valueFormatter: N
                  }, R) : R);
                }
                D.text && h.push(D.text), u.push(k);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var f = r.position, p = o.get("order"), g = AO(c, d, l, p, i.get("useUTC"), o.get("textStyle"));
      g && h.unshift(g);
      var m = l === "richText" ? `

` : "<br/>", v = h.join(m);
      this._showOrMove(o, function() {
        this._updateContentNotChangedOnAxis(t, u) ? this._updatePosition(o, f, s[0], s[1], this._tooltipContent, u) : this._showTooltipContent(o, v, u, Math.random() + "", s[0], s[1], f, null, d);
      });
    }, e.prototype._showSeriesItemTooltip = function(t, r, i) {
      var a = this._ecModel, s = rt(r), o = s.seriesIndex, l = a.getSeriesByIndex(o), u = s.dataModel || l, c = s.dataIndex, h = s.dataType, d = u.getData(h), f = this._renderMode, p = t.positionDefault, g = py([
        d.getItemModel(c),
        u,
        l && (l.coordinateSystem || {}).model
      ], this._tooltipModel, p ? {
        position: p
      } : null), m = g.get("trigger");
      if (!(m != null && m !== "item")) {
        var v = u.getDataParams(c, h), y = new wk();
        v.marker = y.makeTooltipMarker("item", fd(v.color), f);
        var x = _O(u.formatTooltip(c, false, h)), b = g.get("order"), w = g.get("valueFormatter"), _ = x.frag, S = _ ? AO(w ? oe({
          valueFormatter: w
        }, _) : _, y, f, b, a.get("useUTC"), g.get("textStyle")) : x.text, I = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, S, v, I, t.offsetX, t.offsetY, t.position, t.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: d.getRawIndex(c),
          seriesIndex: o,
          from: this.uid
        });
      }
    }, e.prototype._showComponentItemTooltip = function(t, r, i) {
      var a = this._renderMode === "html", s = rt(r), o = s.tooltipConfig, l = o.option || {}, u = l.encodeHTMLContent;
      if (Ie(l)) {
        var c = l;
        l = {
          content: c,
          formatter: c
        }, u = true;
      }
      u && a && l.content && (l = Qe(l), l.content = Hi(l.content));
      var h = [
        l
      ], d = this._ecModel.getComponent(s.componentMainType, s.componentIndex);
      d && h.push(d), h.push({
        formatter: l.content
      });
      var f = t.positionDefault, p = py(h, this._tooltipModel, f ? {
        position: f
      } : null), g = p.get("content"), m = Math.random() + "", v = new wk();
      this._showOrMove(p, function() {
        var y = Qe(p.get("formatterParams") || {});
        this._showTooltipContent(p, g, y, m, t.offsetX, t.offsetY, t.position, r, v);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, e.prototype._showTooltipContent = function(t, r, i, a, s, o, l, u, c) {
      if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(t.get("enterable"));
        var d = t.get("formatter");
        l = l || t.get("position");
        var f = r, p = this._getNearestPoint([
          s,
          o
        ], i, t.get("trigger"), t.get("borderColor")), g = p.color;
        if (d) if (Ie(d)) {
          var m = t.ecModel.get("useUTC"), v = de(i) ? i[0] : i, y = v && v.axisType && v.axisType.indexOf("time") >= 0;
          f = d, y && (f = TC(v.axisValue, f, m)), f = oX(f, i, true);
        } else if (Xe(d)) {
          var x = Ae(function(b, w) {
            b === this._ticket && (h.setContent(w, c, t, g, l), this._updatePosition(t, l, s, o, h, i, u));
          }, this);
          this._ticket = a, f = d(i, a, x);
        } else f = d;
        h.setContent(f, c, t, g, l), h.show(t, g), this._updatePosition(t, l, s, o, h, i, u);
      }
    }, e.prototype._getNearestPoint = function(t, r, i, a) {
      if (i === "axis" || de(r)) return {
        color: a || (this._renderMode === "html" ? "#fff" : "none")
      };
      if (!de(r)) return {
        color: a || r.color || r.borderColor
      };
    }, e.prototype._updatePosition = function(t, r, i, a, s, o, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      r = r || t.get("position");
      var h = s.getSize(), d = t.get("align"), f = t.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), Xe(r) && (r = r([
        i,
        a
      ], o, s.el, p, {
        viewSize: [
          u,
          c
        ],
        contentSize: h.slice()
      })), de(r)) i = _e(r[0], u), a = _e(r[1], c);
      else if (Ze(r)) {
        var g = r;
        g.width = h[0], g.height = h[1];
        var m = Er(g, {
          width: u,
          height: c
        });
        i = m.x, a = m.y, d = null, f = null;
      } else if (Ie(r) && l) {
        var v = OSe(r, p, h, t.get("borderWidth"));
        i = v[0], a = v[1];
      } else {
        var v = LSe(i, a, s, u, c, d ? null : 20, f ? null : 20);
        i = v[0], a = v[1];
      }
      if (d && (i -= FW(d) ? h[0] / 2 : d === "right" ? h[0] : 0), f && (a -= FW(f) ? h[1] / 2 : f === "bottom" ? h[1] : 0), IK(t)) {
        var v = FSe(i, a, s, u, c);
        i = v[0], a = v[1];
      }
      s.moveTo(i, a);
    }, e.prototype._updateContentNotChangedOnAxis = function(t, r) {
      var i = this._lastDataByCoordSys, a = this._cbParamsList, s = !!i && i.length === t.length;
      return s && P(i, function(o, l) {
        var u = o.dataByAxis || [], c = t[l] || {}, h = c.dataByAxis || [];
        s = s && u.length === h.length, s && P(u, function(d, f) {
          var p = h[f] || {}, g = d.seriesDataIndices || [], m = p.seriesDataIndices || [];
          s = s && d.value === p.value && d.axisType === p.axisType && d.axisId === p.axisId && g.length === m.length, s && P(g, function(v, y) {
            var x = m[y];
            s = s && v.seriesIndex === x.seriesIndex && v.dataIndex === x.dataIndex;
          }), a && P(d.seriesDataIndices, function(v) {
            var y = v.seriesIndex, x = r[y], b = a[y];
            x && b && b.data !== x.data && (s = false);
          });
        });
      }), this._lastDataByCoordSys = t, this._cbParamsList = r, !!s;
    }, e.prototype._hide = function(t) {
      this._lastDataByCoordSys = null, t({
        type: "hideTip",
        from: this.uid
      });
    }, e.prototype.dispose = function(t, r) {
      Dt.node || !r.getDom() || (F0(this, "_updatePosition"), this._tooltipContent.dispose(), BR("itemTooltip", r));
    }, e.type = "tooltip", e;
  }(Yn);
  function py(n, e, t) {
    var r = e.ecModel, i;
    t ? (i = new on(t, r, r), i = new on(e.option, i, r)) : i = e;
    for (var a = n.length - 1; a >= 0; a--) {
      var s = n[a];
      s && (s instanceof on && (s = s.get("tooltip", true)), Ie(s) && (s = {
        formatter: s
      }), s && (i = new on(s, i, r)));
    }
    return i;
  }
  function LW(n, e) {
    return n.dispatchAction || Ae(e.dispatchAction, e);
  }
  function LSe(n, e, t, r, i, a, s) {
    var o = t.getSize(), l = o[0], u = o[1];
    return a != null && (n + l + a + 2 > r ? n -= l + a : n += a), s != null && (e + u + s > i ? e -= u + s : e += s), [
      n,
      e
    ];
  }
  function FSe(n, e, t, r, i) {
    var a = t.getSize(), s = a[0], o = a[1];
    return n = Math.min(n + s, r) - s, e = Math.min(e + o, i) - o, n = Math.max(n, 0), e = Math.max(e, 0), [
      n,
      e
    ];
  }
  function OSe(n, e, t, r) {
    var i = t[0], a = t[1], s = Math.ceil(Math.SQRT2 * r) + 8, o = 0, l = 0, u = e.width, c = e.height;
    switch (n) {
      case "inside":
        o = e.x + u / 2 - i / 2, l = e.y + c / 2 - a / 2;
        break;
      case "top":
        o = e.x + u / 2 - i / 2, l = e.y - a - s;
        break;
      case "bottom":
        o = e.x + u / 2 - i / 2, l = e.y + c + s;
        break;
      case "left":
        o = e.x - i - s, l = e.y + c / 2 - a / 2;
        break;
      case "right":
        o = e.x + u + s, l = e.y + c / 2 - a / 2;
    }
    return [
      o,
      l
    ];
  }
  function FW(n) {
    return n === "center" || n === "middle";
  }
  function BSe(n, e, t) {
    var r = GN(n).queryOptionMap, i = r.keys()[0];
    if (!(!i || i === "series")) {
      var a = $x(e, i, r.get(i), {
        useDefault: false,
        enableAll: false,
        enableNone: false
      }), s = a.models[0];
      if (s) {
        var o = t.getViewOfComponentModel(s), l;
        if (o.group.traverse(function(u) {
          var c = rt(u).tooltipConfig;
          if (c && c.name === n.name) return l = u, true;
        }), l) return {
          componentMainType: i,
          componentIndex: s.componentIndex,
          el: l
        };
      }
    }
  }
  function zSe(n) {
    Ct(Kx), n.registerComponentModel(_Se), n.registerComponentView(PSe), n.registerAction({
      type: "showTip",
      event: "showTip",
      update: "tooltip:manuallyShowTip"
    }, ur), n.registerAction({
      type: "hideTip",
      event: "hideTip",
      update: "tooltip:manuallyHideTip"
    }, ur);
  }
  var VSe = [
    "rect",
    "polygon",
    "keep",
    "clear"
  ];
  function WSe(n, e) {
    var t = xn(n ? n.brush : []);
    if (t.length) {
      var r = [];
      P(t, function(l) {
        var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
        u instanceof Array && (r = r.concat(u));
      });
      var i = n && n.toolbox;
      de(i) && (i = i[0]), i || (i = {
        feature: {}
      }, n.toolbox = [
        i
      ]);
      var a = i.feature || (i.feature = {}), s = a.brush || (a.brush = {}), o = s.type || (s.type = []);
      o.push.apply(o, r), GSe(o), e && !o.length && o.push.apply(o, VSe);
    }
  }
  function GSe(n) {
    var e = {};
    P(n, function(t) {
      e[t] = 1;
    }), n.length = 0, P(e, function(t, r) {
      n.push(r);
    });
  }
  var OW = P;
  function BW(n) {
    if (n) {
      for (var e in n) if (n.hasOwnProperty(e)) return true;
    }
  }
  function HR(n, e, t) {
    var r = {};
    return OW(e, function(a) {
      var s = r[a] = i();
      OW(n[a], function(o, l) {
        if (Gr.isValidType(l)) {
          var u = {
            type: l,
            visual: o
          };
          t && t(u, a), s[l] = new Gr(u), l === "opacity" && (u = Qe(u), u.type = "colorAlpha", s.__hidden.__alphaForOpacity = new Gr(u));
        }
      });
    }), r;
    function i() {
      var a = function() {
      };
      a.prototype.__hidden = a.prototype;
      var s = new a();
      return s;
    }
  }
  function DK(n, e, t) {
    var r;
    P(t, function(i) {
      e.hasOwnProperty(i) && BW(e[i]) && (r = true);
    }), r && P(t, function(i) {
      e.hasOwnProperty(i) && BW(e[i]) ? n[i] = Qe(e[i]) : delete n[i];
    });
  }
  function USe(n, e, t, r, i, a) {
    var s = {};
    P(n, function(h) {
      var d = Gr.prepareVisualTypes(e[h]);
      s[h] = d;
    });
    var o;
    function l(h) {
      return yE(t, o, h);
    }
    function u(h, d) {
      KX(t, o, h, d);
    }
    t.each(c);
    function c(h, d) {
      o = h;
      var f = t.getRawDataItem(o);
      if (!(f && f.visualMap === false)) for (var p = r.call(i, h), g = e[p], m = s[p], v = 0, y = m.length; v < y; v++) {
        var x = m[v];
        g[x] && g[x].applyVisual(h, l, u);
      }
    }
  }
  function HSe(n, e, t, r) {
    var i = {};
    return P(n, function(a) {
      var s = Gr.prepareVisualTypes(e[a]);
      i[a] = s;
    }), {
      progress: function(s, o) {
        var l;
        r != null && (l = o.getDimensionIndex(r));
        function u(w) {
          return yE(o, h, w);
        }
        function c(w, _) {
          KX(o, h, w, _);
        }
        for (var h, d = o.getStore(); (h = s.next()) != null; ) {
          var f = o.getRawDataItem(h);
          if (!(f && f.visualMap === false)) for (var p = r != null ? d.get(l, h) : h, g = t(p), m = e[g], v = i[g], y = 0, x = v.length; y < x; y++) {
            var b = v[y];
            m[b] && m[b].applyVisual(p, u, c);
          }
        }
      }
    };
  }
  function XSe(n) {
    var e = n.brushType, t = {
      point: function(r) {
        return zW[e].point(r, t, n);
      },
      rect: function(r) {
        return zW[e].rect(r, t, n);
      }
    };
    return t;
  }
  var zW = {
    lineX: VW(0),
    lineY: VW(1),
    rect: {
      point: function(n, e, t) {
        return n && t.boundingRect.contain(n[0], n[1]);
      },
      rect: function(n, e, t) {
        return n && t.boundingRect.intersect(n);
      }
    },
    polygon: {
      point: function(n, e, t) {
        return n && t.boundingRect.contain(n[0], n[1]) && Th(t.range, n[0], n[1]);
      },
      rect: function(n, e, t) {
        var r = t.range;
        if (!n || r.length <= 1) return false;
        var i = n.x, a = n.y, s = n.width, o = n.height, l = r[0];
        if (Th(r, i, a) || Th(r, i + s, a) || Th(r, i, a + o) || Th(r, i + s, a + o) || vt.create(n).contain(l[0], l[1]) || Ey(i, a, i + s, a, r) || Ey(i, a, i, a + o, r) || Ey(i + s, a, i + s, a + o, r) || Ey(i, a + o, i + s, a + o, r)) return true;
      }
    }
  };
  function VW(n) {
    var e = [
      "x",
      "y"
    ], t = [
      "width",
      "height"
    ];
    return {
      point: function(r, i, a) {
        if (r) {
          var s = a.range, o = r[n];
          return gy(o, s);
        }
      },
      rect: function(r, i, a) {
        if (r) {
          var s = a.range, o = [
            r[e[n]],
            r[e[n]] + r[t[n]]
          ];
          return o[1] < o[0] && o.reverse(), gy(o[0], s) || gy(o[1], s) || gy(s[0], o) || gy(s[1], o);
        }
      }
    };
  }
  function gy(n, e) {
    return e[0] <= n && n <= e[1];
  }
  var WW = [
    "inBrush",
    "outOfBrush"
  ], FT = "__ecBrushSelect", XR = "__ecInBrushSelectEvent";
  function RK(n) {
    n.eachComponent({
      mainType: "brush"
    }, function(e) {
      var t = e.brushTargetManager = new TM(e.option, n);
      t.setInputRanges(e.areas, n);
    });
  }
  function YSe(n, e, t) {
    var r = [], i, a;
    n.eachComponent({
      mainType: "brush"
    }, function(s) {
      t && t.type === "takeGlobalCursor" && s.setBrushOption(t.key === "brush" ? t.brushOption : {
        brushType: false
      });
    }), RK(n), n.eachComponent({
      mainType: "brush"
    }, function(s, o) {
      var l = {
        brushId: s.id,
        brushIndex: o,
        brushName: s.name,
        areas: Qe(s.areas),
        selected: []
      };
      r.push(l);
      var u = s.option, c = u.brushLink, h = [], d = [], f = [], p = false;
      o || (i = u.throttleType, a = u.throttleDelay);
      var g = me(s.areas, function(w) {
        var _ = ZSe[w.brushType], S = je({
          boundingRect: _ ? _(w) : void 0
        }, w);
        return S.selectors = XSe(S), S;
      }), m = HR(s.option, WW, function(w) {
        w.mappingMethod = "fixed";
      });
      de(c) && P(c, function(w) {
        h[w] = 1;
      });
      function v(w) {
        return c === "all" || !!h[w];
      }
      function y(w) {
        return !!w.length;
      }
      n.eachSeries(function(w, _) {
        var S = f[_] = [];
        w.subType === "parallel" ? x(w, _) : b(w, _, S);
      });
      function x(w, _) {
        var S = w.coordinateSystem;
        p = p || S.hasAxisBrushed(), v(_) && S.eachActiveState(w.getData(), function(I, C) {
          I === "active" && (d[C] = 1);
        });
      }
      function b(w, _, S) {
        if (!(!w.brushSelector || KSe(s, _)) && (P(g, function(C) {
          s.brushTargetManager.controlSeries(C, w, n) && S.push(C), p = p || y(S);
        }), v(_) && y(S))) {
          var I = w.getData();
          I.each(function(C) {
            GW(w, S, I, C) && (d[C] = 1);
          });
        }
      }
      n.eachSeries(function(w, _) {
        var S = {
          seriesId: w.id,
          seriesIndex: _,
          seriesName: w.name,
          dataIndex: []
        };
        l.selected.push(S);
        var I = f[_], C = w.getData(), T = v(_) ? function(k) {
          return d[k] ? (S.dataIndex.push(C.getRawIndex(k)), "inBrush") : "outOfBrush";
        } : function(k) {
          return GW(w, I, C, k) ? (S.dataIndex.push(C.getRawIndex(k)), "inBrush") : "outOfBrush";
        };
        (v(_) ? p : y(I)) && USe(WW, m, C, T);
      });
    }), qSe(e, i, a, r, t);
  }
  function qSe(n, e, t, r, i) {
    if (i) {
      var a = n.getZr();
      if (!a[XR]) {
        a[FT] || (a[FT] = jSe);
        var s = Sm(a, FT, t, e);
        s(n, r);
      }
    }
  }
  function jSe(n, e) {
    if (!n.isDisposed()) {
      var t = n.getZr();
      t[XR] = true, n.dispatchAction({
        type: "brushSelect",
        batch: e
      }), t[XR] = false;
    }
  }
  function GW(n, e, t, r) {
    for (var i = 0, a = e.length; i < a; i++) {
      var s = e[i];
      if (n.brushSelector(r, t, s.selectors, s)) return true;
    }
  }
  function KSe(n, e) {
    var t = n.option.seriesIndex;
    return t != null && t !== "all" && (de(t) ? bt(t, e) < 0 : e !== t);
  }
  var ZSe = {
    rect: function(n) {
      return UW(n.range);
    },
    polygon: function(n) {
      for (var e, t = n.range, r = 0, i = t.length; r < i; r++) {
        e = e || [
          [
            1 / 0,
            -1 / 0
          ],
          [
            1 / 0,
            -1 / 0
          ]
        ];
        var a = t[r];
        a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]);
      }
      return e && UW(e);
    }
  };
  function UW(n) {
    return new vt(n[0][0], n[1][0], n[0][1] - n[0][0], n[1][1] - n[1][0]);
  }
  var QSe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      this.ecModel = t, this.api = r, this.model, (this._brushController = new eM(r.getZr())).on("brush", Ae(this._onBrush, this)).mount();
    }, e.prototype.render = function(t, r, i, a) {
      this.model = t, this._updateController(t, r, i, a);
    }, e.prototype.updateTransform = function(t, r, i, a) {
      RK(r), this._updateController(t, r, i, a);
    }, e.prototype.updateVisual = function(t, r, i, a) {
      this.updateTransform(t, r, i, a);
    }, e.prototype.updateView = function(t, r, i, a) {
      this._updateController(t, r, i, a);
    }, e.prototype._updateController = function(t, r, i, a) {
      (!a || a.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var r = this.model.id, i = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel);
      (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: r,
        areas: Qe(i),
        $from: r
      }), t.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: r,
        areas: Qe(i),
        $from: r
      });
    }, e.type = "brush", e;
  }(Yn), JSe = "#ddd", eCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.areas = [], t.brushOption = {}, t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      var i = this.option;
      !r && DK(i, t, [
        "inBrush",
        "outOfBrush"
      ]);
      var a = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: JSe
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, e.prototype.setAreas = function(t) {
      t && (this.areas = me(t, function(r) {
        return HW(this.option, r);
      }, this));
    }, e.prototype.setBrushOption = function(t) {
      this.brushOption = HW(this.option, t), this.brushType = this.brushOption.brushType;
    }, e.type = "brush", e.dependencies = [
      "geo",
      "grid",
      "xAxis",
      "yAxis",
      "parallel",
      "series"
    ], e.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: true,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: true,
      z: 1e4
    }, e;
  }(Et);
  function HW(n, e) {
    return pt({
      brushType: n.brushType,
      brushMode: n.brushMode,
      transformable: n.transformable,
      brushStyle: new on(n.brushStyle).getItemStyle(),
      removeOnClick: n.removeOnClick,
      z: n.z
    }, e, true);
  }
  var tCe = [
    "rect",
    "polygon",
    "lineX",
    "lineY",
    "keep",
    "clear"
  ], nCe = function(n) {
    K(e, n);
    function e() {
      return n !== null && n.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, r, i) {
      var a, s, o;
      r.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, s = l.brushOption.brushMode || "single", o = o || !!l.areas.length;
      }), this._brushType = a, this._brushMode = s, P(t.get("type", true), function(l) {
        t.setIconStatus(l, (l === "keep" ? s === "multiple" : l === "clear" ? o : l === a) ? "emphasis" : "normal");
      });
    }, e.prototype.updateView = function(t, r, i) {
      this.render(t, r, i);
    }, e.prototype.getIcons = function() {
      var t = this.model, r = t.get("icon", true), i = {};
      return P(t.get("type", true), function(a) {
        r[a] && (i[a] = r[a]);
      }), i;
    }, e.prototype.onclick = function(t, r, i) {
      var a = this._brushType, s = this._brushMode;
      i === "clear" ? (r.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), r.dispatchAction({
        type: "brush",
        command: "clear",
        areas: []
      })) : r.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? a : a === i ? false : i,
          brushMode: i === "keep" ? s === "multiple" ? "single" : "multiple" : s
        }
      });
    }, e.getDefaultOption = function(t) {
      var r = {
        show: true,
        type: tCe.slice(),
        icon: {
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        },
        title: t.getLocaleModel().get([
          "toolbox",
          "brush",
          "title"
        ])
      };
      return r;
    }, e;
  }(ds);
  function rCe(n) {
    n.registerComponentView(QSe), n.registerComponentModel(eCe), n.registerPreprocessor(WSe), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, YSe), n.registerAction({
      type: "brush",
      event: "brush",
      update: "updateVisual"
    }, function(e, t) {
      t.eachComponent({
        mainType: "brush",
        query: e
      }, function(r) {
        r.setAreas(e.areas);
      });
    }), n.registerAction({
      type: "brushSelect",
      event: "brushSelected",
      update: "none"
    }, ur), n.registerAction({
      type: "brushEnd",
      event: "brushEnd",
      update: "none"
    }, ur), sg("brush", nCe);
  }
  var iCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: true
      }, t;
    }
    return e.type = "title", e.defaultOption = {
      z: 6,
      show: true,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, e;
  }(Et), aCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, r, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var a = this.group, s = t.getModel("textStyle"), o = t.getModel("subtextStyle"), l = t.get("textAlign"), u = it(t.get("textBaseline"), t.get("textVerticalAlign")), c = new Gt({
          style: $n(s, {
            text: t.get("text"),
            fill: s.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        }), h = c.getBoundingRect(), d = t.get("subtext"), f = new Gt({
          style: $n(o, {
            text: d,
            fill: o.getTextColor(),
            y: h.height + t.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: true
          }),
          z2: 10
        }), p = t.get("link"), g = t.get("sublink"), m = t.get("triggerEvent", true);
        c.silent = !p && !m, f.silent = !g && !m, p && c.on("click", function() {
          H_(p, "_" + t.get("target"));
        }), g && f.on("click", function() {
          H_(g, "_" + t.get("subtarget"));
        }), rt(c).eventData = rt(f).eventData = m ? {
          componentType: "title",
          componentIndex: t.componentIndex
        } : null, a.add(c), d && a.add(f);
        var v = a.getBoundingRect(), y = t.getBoxLayoutParams();
        y.width = v.width, y.height = v.height;
        var x = Er(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, t.get("padding"));
        l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? x.x += x.width : l === "center" && (x.x += x.width / 2)), u || (u = t.get("top") || t.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? x.y += x.height : u === "middle" && (x.y += x.height / 2), u = u || "top"), a.x = x.x, a.y = x.y, a.markRedraw();
        var b = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(b), f.setStyle(b), v = a.getBoundingRect();
        var w = x.margin, _ = t.getItemStyle([
          "color",
          "opacity"
        ]);
        _.fill = t.get("backgroundColor");
        var S = new Vt({
          shape: {
            x: v.x - w[3],
            y: v.y - w[0],
            width: v.width + w[1] + w[3],
            height: v.height + w[0] + w[2],
            r: t.get("borderRadius")
          },
          style: _,
          subPixelOptimize: true,
          silent: true
        });
        a.add(S);
      }
    }, e.type = "title", e;
  }(Yn);
  function sCe(n) {
    n.registerComponentModel(iCe), n.registerComponentView(aCe);
  }
  var XW = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = "box", t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i), this._initData();
    }, e.prototype.mergeOption = function(t) {
      n.prototype.mergeOption.apply(this, arguments), this._initData();
    }, e.prototype.setCurrentIndex = function(t) {
      t == null && (t = this.option.currentIndex);
      var r = this._data.count();
      this.option.loop ? t = (t % r + r) % r : (t >= r && (t = r - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
    }, e.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, e.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, e.prototype.setPlayState = function(t) {
      this.option.autoPlay = !!t;
    }, e.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, e.prototype._initData = function() {
      var t = this.option, r = t.data || [], i = t.axisType, a = this._names = [], s;
      i === "category" ? (s = [], P(r, function(u, c) {
        var h = kr(pm(u), ""), d;
        Ze(u) ? (d = Qe(u), d.value = c) : d = c, s.push(d), a.push(h);
      })) : s = r;
      var o = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new Ki([
        {
          name: "value",
          type: o
        }
      ], this);
      l.initData(s, a);
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.getCategories = function() {
      if (this.get("axisType") === "category") return this._names.slice();
    }, e.type = "timeline", e.defaultOption = {
      z: 4,
      show: true,
      axisType: "time",
      realtime: true,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: false,
      rewind: false,
      loop: true,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, e;
  }(Et), $K = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline.slider", e.defaultOption = mc(XW.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: false,
      tooltip: {
        trigger: "item"
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: true,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        show: true,
        interval: "auto",
        rotate: 0,
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        animation: true,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: true,
        showPlayBtn: true,
        showPrevBtn: true,
        showNextBtn: true,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true,
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), e;
  }(XW);
  br($K, MC.prototype);
  var oCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline", e;
  }(Yn), lCe = function(n) {
    K(e, n);
    function e(t, r, i, a) {
      var s = n.call(this, t, r, i) || this;
      return s.type = a || "value", s;
    }
    return e.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, e.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, e;
  }(fo), OT = Math.PI, YW = Wt(), uCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, r) {
      this.api = r;
    }, e.prototype.render = function(t, r, i) {
      if (this.model = t, this.api = i, this.ecModel = r, this.group.removeAll(), t.get("show", true)) {
        var a = this._layout(t, i), s = this._createGroup("_mainGroup"), o = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, t);
        t.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return Xr("nameValue", {
            noName: true,
            value: c
          });
        }, P([
          "AxisLine",
          "AxisTick",
          "Control",
          "CurrentPointer"
        ], function(u) {
          this["_render" + u](a, s, l, t);
        }, this), this._renderAxisLabel(a, o, l, t), this._position(a, t);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, e.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._clearTimer();
    }, e.prototype._layout = function(t, r) {
      var i = t.get([
        "label",
        "position"
      ]), a = t.get("orient"), s = hCe(t, r), o;
      i == null || i === "auto" ? o = a === "horizontal" ? s.y + s.height / 2 < r.getHeight() / 2 ? "-" : "+" : s.x + s.width / 2 < r.getWidth() / 2 ? "+" : "-" : Ie(i) ? o = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][i] : o = i;
      var l = {
        horizontal: "center",
        vertical: o >= 0 || o === "+" ? "left" : "right"
      }, u = {
        horizontal: o >= 0 || o === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: OT / 2
      }, h = a === "vertical" ? s.height : s.width, d = t.getModel("controlStyle"), f = d.get("show", true), p = f ? d.get("itemSize") : 0, g = f ? d.get("itemGap") : 0, m = p + g, v = t.get([
        "label",
        "rotate"
      ]) || 0;
      v = v * OT / 180;
      var y, x, b, w = d.get("position", true), _ = f && d.get("showPlayBtn", true), S = f && d.get("showPrevBtn", true), I = f && d.get("showNextBtn", true), C = 0, T = h;
      w === "left" || w === "bottom" ? (_ && (y = [
        0,
        0
      ], C += m), S && (x = [
        C,
        0
      ], C += m), I && (b = [
        T - p,
        0
      ], T -= m)) : (_ && (y = [
        T - p,
        0
      ], T -= m), S && (x = [
        0,
        0
      ], C += m), I && (b = [
        T - p,
        0
      ], T -= m));
      var k = [
        C,
        T
      ];
      return t.get("inverse") && k.reverse(), {
        viewRect: s,
        mainLength: h,
        orient: a,
        rotation: c[a],
        labelRotation: v,
        labelPosOpt: o,
        labelAlign: t.get([
          "label",
          "align"
        ]) || l[a],
        labelBaseline: t.get([
          "label",
          "verticalAlign"
        ]) || t.get([
          "label",
          "baseline"
        ]) || u[a],
        playPosition: y,
        prevBtnPosition: x,
        nextBtnPosition: b,
        axisExtent: k,
        controlSize: p,
        controlGap: g
      };
    }, e.prototype._position = function(t, r) {
      var i = this._mainGroup, a = this._labelGroup, s = t.viewRect;
      if (t.orient === "vertical") {
        var o = za(), l = s.x, u = s.y + s.height;
        Jo(o, o, [
          -l,
          -u
        ]), Md(o, o, -OT / 2), Jo(o, o, [
          l,
          u
        ]), s = s.clone(), s.applyTransform(o);
      }
      var c = y(s), h = y(i.getBoundingRect()), d = y(a.getBoundingRect()), f = [
        i.x,
        i.y
      ], p = [
        a.x,
        a.y
      ];
      p[0] = f[0] = c[0][0];
      var g = t.labelPosOpt;
      if (g == null || Ie(g)) {
        var m = g === "+" ? 0 : 1;
        x(f, h, c, 1, m), x(p, d, c, 1, 1 - m);
      } else {
        var m = g >= 0 ? 0 : 1;
        x(f, h, c, 1, m), p[1] = f[1] + g;
      }
      i.setPosition(f), a.setPosition(p), i.rotation = a.rotation = t.rotation, v(i), v(a);
      function v(b) {
        b.originX = c[0][0] - b.x, b.originY = c[1][0] - b.y;
      }
      function y(b) {
        return [
          [
            b.x,
            b.x + b.width
          ],
          [
            b.y,
            b.y + b.height
          ]
        ];
      }
      function x(b, w, _, S, I) {
        b[S] += _[S][I] - w[S][I];
      }
    }, e.prototype._createAxis = function(t, r) {
      var i = r.getData(), a = r.get("axisType"), s = cCe(r, a);
      s.getTicks = function() {
        return i.mapArray([
          "value"
        ], function(u) {
          return {
            value: u
          };
        });
      };
      var o = i.getDataExtent("value");
      s.setExtent(o[0], o[1]), s.calcNiceTicks();
      var l = new lCe("value", s, t.axisExtent, a);
      return l.model = r, l;
    }, e.prototype._createGroup = function(t) {
      var r = this[t] = new tt();
      return this.group.add(r), r;
    }, e.prototype._renderAxisLine = function(t, r, i, a) {
      var s = i.getExtent();
      if (a.get([
        "lineStyle",
        "show"
      ])) {
        var o = new zr({
          shape: {
            x1: s[0],
            y1: 0,
            x2: s[1],
            y2: 0
          },
          style: oe({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: true,
          z2: 1
        });
        r.add(o);
        var l = this._progressLine = new zr({
          shape: {
            x1: s[0],
            x2: this._currentPointer ? this._currentPointer.x : s[0],
            y1: 0,
            y2: 0
          },
          style: je({
            lineCap: "round",
            lineWidth: o.style.lineWidth
          }, a.getModel([
            "progress",
            "lineStyle"
          ]).getLineStyle()),
          silent: true,
          z2: 1
        });
        r.add(l);
      }
    }, e.prototype._renderAxisTick = function(t, r, i, a) {
      var s = this, o = a.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], P(l, function(u) {
        var c = i.dataToCoord(u.value), h = o.getItemModel(u.value), d = h.getModel("itemStyle"), f = h.getModel([
          "emphasis",
          "itemStyle"
        ]), p = h.getModel([
          "progress",
          "itemStyle"
        ]), g = {
          x: c,
          y: 0,
          onclick: Ae(s._changeTimeline, s, u.value)
        }, m = qW(h, d, r, g);
        m.ensureState("emphasis").style = f.getItemStyle(), m.ensureState("progress").style = p.getItemStyle(), Qh(m);
        var v = rt(m);
        h.get("tooltip") ? (v.dataIndex = u.value, v.dataModel = a) : v.dataIndex = v.dataModel = null, s._tickSymbols.push(m);
      });
    }, e.prototype._renderAxisLabel = function(t, r, i, a) {
      var s = this, o = i.getLabelModel();
      if (o.get("show")) {
        var l = a.getData(), u = i.getViewLabels();
        this._tickLabels = [], P(u, function(c) {
          var h = c.tickValue, d = l.getItemModel(h), f = d.getModel("label"), p = d.getModel([
            "emphasis",
            "label"
          ]), g = d.getModel([
            "progress",
            "label"
          ]), m = i.dataToCoord(c.tickValue), v = new Gt({
            x: m,
            y: 0,
            rotation: t.labelRotation - t.rotation,
            onclick: Ae(s._changeTimeline, s, h),
            silent: false,
            style: $n(f, {
              text: c.formattedLabel,
              align: t.labelAlign,
              verticalAlign: t.labelBaseline
            })
          });
          v.ensureState("emphasis").style = $n(p), v.ensureState("progress").style = $n(g), r.add(v), Qh(v), YW(v).dataIndex = h, s._tickLabels.push(v);
        });
      }
    }, e.prototype._renderControl = function(t, r, i, a) {
      var s = t.controlSize, o = t.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel([
        "emphasis",
        "controlStyle"
      ]).getItemStyle(), c = a.getPlayState(), h = a.get("inverse", true);
      d(t.nextBtnPosition, "next", Ae(this._changeTimeline, this, h ? "-" : "+")), d(t.prevBtnPosition, "prev", Ae(this._changeTimeline, this, h ? "+" : "-")), d(t.playPosition, c ? "stop" : "play", Ae(this._handlePlayClick, this, !c), true);
      function d(f, p, g, m) {
        if (f) {
          var v = no(it(a.get([
            "controlStyle",
            p + "BtnSize"
          ]), s), s), y = [
            0,
            -v / 2,
            v,
            v
          ], x = dCe(a, p + "Icon", y, {
            x: f[0],
            y: f[1],
            originX: s / 2,
            originY: 0,
            rotation: m ? -o : 0,
            rectHover: true,
            style: l,
            onclick: g
          });
          x.ensureState("emphasis").style = u, r.add(x), Qh(x);
        }
      }
    }, e.prototype._renderCurrentPointer = function(t, r, i, a) {
      var s = a.getData(), o = a.getCurrentIndex(), l = s.getItemModel(o).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(h) {
          h.draggable = true, h.drift = Ae(u._handlePointerDrag, u), h.ondragend = Ae(u._handlePointerDragend, u), jW(h, u._progressLine, o, i, a, true);
        },
        onUpdate: function(h) {
          jW(h, u._progressLine, o, i, a);
        }
      };
      this._currentPointer = qW(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, e.prototype._handlePlayClick = function(t) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: t,
        from: this.uid
      });
    }, e.prototype._handlePointerDrag = function(t, r, i) {
      this._clearTimer(), this._pointerChangeTimeline([
        i.offsetX,
        i.offsetY
      ]);
    }, e.prototype._handlePointerDragend = function(t) {
      this._pointerChangeTimeline([
        t.offsetX,
        t.offsetY
      ], true);
    }, e.prototype._pointerChangeTimeline = function(t, r) {
      var i = this._toAxisCoord(t)[0], a = this._axis, s = vs(a.getExtent().slice());
      i > s[1] && (i = s[1]), i < s[0] && (i = s[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var o = this._progressLine;
      o && (o.shape.x2 = i, o.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (r || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, e.prototype._doPlayStop = function() {
      var t = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var r = t.model;
        t._changeTimeline(r.getCurrentIndex() + (r.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, e.prototype._toAxisCoord = function(t) {
      var r = this._mainGroup.getLocalTransform();
      return Zs(t, r, true);
    }, e.prototype._findNearestTick = function(t) {
      var r = this.model.getData(), i = 1 / 0, a, s = this._axis;
      return r.each([
        "value"
      ], function(o, l) {
        var u = s.dataToCoord(o), c = Math.abs(u - t);
        c < i && (i = c, a = l);
      }), a;
    }, e.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, e.prototype._changeTimeline = function(t) {
      var r = this.model.getCurrentIndex();
      t === "+" ? t = r + 1 : t === "-" && (t = r - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: t,
        from: this.uid
      });
    }, e.prototype._updateTicksStatus = function() {
      var t = this.model.getCurrentIndex(), r = this._tickSymbols, i = this._tickLabels;
      if (r) for (var a = 0; a < r.length; a++) r && r[a] && r[a].toggleState("progress", a < t);
      if (i) for (var a = 0; a < i.length; a++) i && i[a] && i[a].toggleState("progress", YW(i[a]).dataIndex <= t);
    }, e.type = "timeline.slider", e;
  }(oCe);
  function cCe(n, e) {
    if (e = e || n.get("type"), e) switch (e) {
      case "category":
        return new zC({
          ordinalMeta: n.getCategories(),
          extent: [
            1 / 0,
            -1 / 0
          ]
        });
      case "time":
        return new kE({
          locale: n.ecModel.getLocaleModel(),
          useUTC: n.ecModel.get("useUTC")
        });
      default:
        return new jl();
    }
  }
  function hCe(n, e) {
    return Er(n.getBoxLayoutParams(), {
      width: e.getWidth(),
      height: e.getHeight()
    }, n.get("padding"));
  }
  function dCe(n, e, t, r) {
    var i = r.style, a = Fx(n.get([
      "controlStyle",
      e
    ]), r || {}, new vt(t[0], t[1], t[2], t[3]));
    return i && a.setStyle(i), a;
  }
  function qW(n, e, t, r, i, a) {
    var s = e.get("color");
    if (i) i.setColor(s), t.add(i), a && a.onUpdate(i);
    else {
      var o = n.get("symbol");
      i = xr(o, -1, -1, 2, 2, s), i.setStyle("strokeNoScale", true), t.add(i), a && a.onCreate(i);
    }
    var l = e.getItemStyle([
      "color"
    ]);
    i.setStyle(l), r = pt({
      rectHover: true,
      z2: 100
    }, r, true);
    var u = Cm(n.get("symbolSize"));
    r.scaleX = u[0] / 2, r.scaleY = u[1] / 2;
    var c = Fd(n.get("symbolOffset"), u);
    c && (r.x = (r.x || 0) + c[0], r.y = (r.y || 0) + c[1]);
    var h = n.get("symbolRotate");
    return r.rotation = (h || 0) * Math.PI / 180 || 0, i.attr(r), i.updateTransform(), i;
  }
  function jW(n, e, t, r, i, a) {
    if (!n.dragging) {
      var s = i.getModel("checkpointStyle"), o = r.dataToCoord(i.getData().get("value", t));
      if (a || !s.get("animation", true)) n.attr({
        x: o,
        y: 0
      }), e && e.attr({
        shape: {
          x2: o
        }
      });
      else {
        var l = {
          duration: s.get("animationDuration", true),
          easing: s.get("animationEasing", true)
        };
        n.stopAnimation(null, true), n.animateTo({
          x: o,
          y: 0
        }, l), e && e.animateTo({
          shape: {
            x2: o
          }
        }, l);
      }
    }
  }
  function fCe(n) {
    n.registerAction({
      type: "timelineChange",
      event: "timelineChanged",
      update: "prepareAndUpdate"
    }, function(e, t, r) {
      var i = t.getComponent("timeline");
      return i && e.currentIndex != null && (i.setCurrentIndex(e.currentIndex), !i.get("loop", true) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(false), r.dispatchAction({
        type: "timelinePlayChange",
        playState: false,
        from: e.from
      }))), t.resetOption("timeline", {
        replaceMerge: i.get("replaceMerge", true)
      }), je({
        currentIndex: i.option.currentIndex
      }, e);
    }), n.registerAction({
      type: "timelinePlayChange",
      event: "timelinePlayChanged",
      update: "update"
    }, function(e, t) {
      var r = t.getComponent("timeline");
      r && e.playState != null && r.setPlayState(e.playState);
    });
  }
  function pCe(n) {
    var e = n && n.timeline;
    de(e) || (e = e ? [
      e
    ] : []), P(e, function(t) {
      t && gCe(t);
    });
  }
  function gCe(n) {
    var e = n.type, t = {
      number: "value",
      time: "time"
    };
    if (t[e] && (n.axisType = t[e], delete n.type), KW(n), Rh(n, "controlPosition")) {
      var r = n.controlStyle || (n.controlStyle = {});
      Rh(r, "position") || (r.position = n.controlPosition), r.position === "none" && !Rh(r, "show") && (r.show = false, delete r.position), delete n.controlPosition;
    }
    P(n.data || [], function(i) {
      Ze(i) && !de(i) && (!Rh(i, "value") && Rh(i, "name") && (i.value = i.name), KW(i));
    });
  }
  function KW(n) {
    var e = n.itemStyle || (n.itemStyle = {}), t = e.emphasis || (e.emphasis = {}), r = n.label || n.label || {}, i = r.normal || (r.normal = {}), a = {
      normal: 1,
      emphasis: 1
    };
    P(r, function(s, o) {
      !a[o] && !Rh(i, o) && (i[o] = s);
    }), t.label && !Rh(r, "emphasis") && (r.emphasis = t.label, delete t.label);
  }
  function Rh(n, e) {
    return n.hasOwnProperty(e);
  }
  function mCe(n) {
    n.registerComponentModel($K), n.registerComponentView(uCe), n.registerSubTypeDefaulter("timeline", function() {
      return "slider";
    }), fCe(n), n.registerPreprocessor(pCe);
  }
  function RM(n, e) {
    if (!n) return false;
    for (var t = de(n) ? n : [
      n
    ], r = 0; r < t.length; r++) if (t[r] && t[r][e]) return true;
    return false;
  }
  function ow(n) {
    ud(n, "label", [
      "show"
    ]);
  }
  var lw = Wt(), Zl = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.createdBySelf = false, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i), this._mergeOption(t, i, false, true);
    }, e.prototype.isAnimationEnabled = function() {
      if (Dt.node) return false;
      var t = this.__hostSeries;
      return this.getShallow("animation") && t && t.isAnimationEnabled();
    }, e.prototype.mergeOption = function(t, r) {
      this._mergeOption(t, r, false, false);
    }, e.prototype._mergeOption = function(t, r, i, a) {
      var s = this.mainType;
      i || r.eachSeries(function(o) {
        var l = o.get(this.mainType, true), u = lw(o)[s];
        if (!l || !l.data) {
          lw(o)[s] = null;
          return;
        }
        u ? u._mergeOption(l, r, true) : (a && ow(l), P(l.data, function(c) {
          c instanceof Array ? (ow(c[0]), ow(c[1])) : ow(c);
        }), u = this.createMarkerModelFromSeries(l, this, r), oe(u, {
          mainType: this.mainType,
          seriesIndex: o.seriesIndex,
          name: o.name,
          createdBySelf: true
        }), u.__hostSeries = o), lw(o)[s] = u;
      }, this);
    }, e.prototype.formatTooltip = function(t, r, i) {
      var a = this.getData(), s = this.getRawValue(t), o = a.getName(t);
      return Xr("section", {
        header: this.name,
        blocks: [
          Xr("nameValue", {
            name: o,
            value: s,
            noName: !o,
            noValue: s == null
          })
        ]
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.setData = function(t) {
      this._data = t;
    }, e.prototype.getDataParams = function(t, r) {
      var i = MC.prototype.getDataParams.call(this, t, r), a = this.__hostSeries;
      return a && (i.seriesId = a.id, i.seriesName = a.name, i.seriesType = a.subType), i;
    }, e.getMarkerModelFromSeries = function(t, r) {
      return lw(t)[r];
    }, e.type = "marker", e.dependencies = [
      "series",
      "grid",
      "polar",
      "geo"
    ], e;
  }(Et);
  br(Zl, MC.prototype);
  var vCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markPoint", e.defaultOption = {
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }, e;
  }(Zl);
  function YR(n) {
    return !(isNaN(parseFloat(n.x)) && isNaN(parseFloat(n.y)));
  }
  function yCe(n) {
    return !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
  }
  function uw(n, e, t, r, i, a) {
    var s = [], o = ic(e, r), l = o ? e.getCalculationInfo("stackResultDimension") : r, u = $M(e, l, n), c = e.indicesOfNearest(l, u)[0];
    s[i] = e.get(t, c), s[a] = e.get(l, c);
    var h = e.get(r, c), d = Oo(e.get(r, c));
    return d = Math.min(d, 20), d >= 0 && (s[a] = +s[a].toFixed(d)), [
      s,
      h
    ];
  }
  var BT = {
    min: lt(uw, "min"),
    max: lt(uw, "max"),
    average: lt(uw, "average"),
    median: lt(uw, "median")
  };
  function Z0(n, e) {
    if (e) {
      var t = n.getData(), r = n.coordinateSystem, i = r && r.dimensions;
      if (!yCe(e) && !de(e.coord) && de(i)) {
        var a = NK(e, t, r, n);
        if (e = Qe(e), e.type && BT[e.type] && a.baseAxis && a.valueAxis) {
          var s = bt(i, a.baseAxis.dim), o = bt(i, a.valueAxis.dim), l = BT[e.type](t, a.baseDataDim, a.valueDataDim, s, o);
          e.coord = l[0], e.value = l[1];
        } else e.coord = [
          e.xAxis != null ? e.xAxis : e.radiusAxis,
          e.yAxis != null ? e.yAxis : e.angleAxis
        ];
      }
      if (e.coord == null || !de(i)) e.coord = [];
      else for (var u = e.coord, c = 0; c < 2; c++) BT[u[c]] && (u[c] = $M(t, t.mapDimension(i[c]), u[c]));
      return e;
    }
  }
  function NK(n, e, t, r) {
    var i = {};
    return n.valueIndex != null || n.valueDim != null ? (i.valueDataDim = n.valueIndex != null ? e.getDimension(n.valueIndex) : n.valueDim, i.valueAxis = t.getAxis(xCe(r, i.valueDataDim)), i.baseAxis = t.getOtherAxis(i.valueAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim)) : (i.baseAxis = r.getBaseAxis(), i.valueAxis = t.getOtherAxis(i.baseAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim), i.valueDataDim = e.mapDimension(i.valueAxis.dim)), i;
  }
  function xCe(n, e) {
    var t = n.getData().getDimensionInfo(e);
    return t && t.coordDim;
  }
  function Q0(n, e) {
    return n && n.containData && e.coord && !YR(e) ? n.containData(e.coord) : true;
  }
  function bCe(n, e, t) {
    return n && n.containZone && e.coord && t.coord && !YR(e) && !YR(t) ? n.containZone(e.coord, t.coord) : true;
  }
  function EK(n, e) {
    return n ? function(t, r, i, a) {
      var s = a < 2 ? t.coord && t.coord[a] : t.value;
      return Yu(s, e[a]);
    } : function(t, r, i, a) {
      return Yu(t.value, e[a]);
    };
  }
  function $M(n, e, t) {
    if (t === "average") {
      var r = 0, i = 0;
      return n.each(e, function(a, s) {
        isNaN(a) || (r += a, i++);
      }), r / i;
    } else return t === "median" ? n.getMedian(e) : n.getDataExtent(e)[t === "max" ? 1 : 0];
  }
  var zT = Wt(), NM = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this.markerGroupMap = Pe();
    }, e.prototype.render = function(t, r, i) {
      var a = this, s = this.markerGroupMap;
      s.each(function(o) {
        zT(o).keep = false;
      }), r.eachSeries(function(o) {
        var l = Zl.getMarkerModelFromSeries(o, a.type);
        l && a.renderSeries(o, l, r, i);
      }), s.each(function(o) {
        !zT(o).keep && a.group.remove(o.group);
      });
    }, e.prototype.markKeep = function(t) {
      zT(t).keep = true;
    }, e.prototype.toggleBlurSeries = function(t, r) {
      var i = this;
      P(t, function(a) {
        var s = Zl.getMarkerModelFromSeries(a, i.type);
        if (s) {
          var o = s.getData();
          o.eachItemGraphicEl(function(l) {
            l && (r ? C8(l) : KN(l));
          });
        }
      });
    }, e.type = "marker", e;
  }(Yn);
  function ZW(n, e, t) {
    var r = e.coordinateSystem;
    n.each(function(i) {
      var a = n.getItemModel(i), s, o = _e(a.get("x"), t.getWidth()), l = _e(a.get("y"), t.getHeight());
      if (!isNaN(o) && !isNaN(l)) s = [
        o,
        l
      ];
      else if (e.getMarkerPosition) s = e.getMarkerPosition(n.getValues(n.dimensions, i));
      else if (r) {
        var u = n.get(r.dimensions[0], i), c = n.get(r.dimensions[1], i);
        s = r.dataToPoint([
          u,
          c
        ]);
      }
      isNaN(o) || (s[0] = o), isNaN(l) || (s[1] = l), n.setItemLayout(i, s);
    });
  }
  var wCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(a) {
        var s = Zl.getMarkerModelFromSeries(a, "markPoint");
        s && (ZW(s.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, a) {
      var s = t.coordinateSystem, o = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(o) || u.set(o, new Gx()), h = _Ce(s, t, r);
      r.setData(h), ZW(r.getData(), t, a), h.each(function(d) {
        var f = h.getItemModel(d), p = f.getShallow("symbol"), g = f.getShallow("symbolSize"), m = f.getShallow("symbolRotate"), v = f.getShallow("symbolOffset"), y = f.getShallow("symbolKeepAspect");
        if (Xe(p) || Xe(g) || Xe(m) || Xe(v)) {
          var x = r.getRawValue(d), b = r.getDataParams(d);
          Xe(p) && (p = p(x, b)), Xe(g) && (g = g(x, b)), Xe(m) && (m = m(x, b)), Xe(v) && (v = v(x, b));
        }
        var w = f.getModel("itemStyle").getItemStyle(), _ = Bx(l, "color");
        w.fill || (w.fill = _), h.setItemVisual(d, {
          symbol: p,
          symbolSize: g,
          symbolRotate: m,
          symbolOffset: v,
          symbolKeepAspect: y,
          style: w
        });
      }), c.updateData(h), this.group.add(c.group), h.eachItemGraphicEl(function(d) {
        d.traverse(function(f) {
          rt(f).dataModel = r;
        });
      }), this.markKeep(c), c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markPoint", e;
  }(NM);
  function _Ce(n, e, t) {
    var r;
    n ? r = me(n && n.dimensions, function(o) {
      var l = e.getData().getDimensionInfo(e.getData().mapDimension(o)) || {};
      return oe(oe({}, l), {
        name: o,
        ordinalMeta: null
      });
    }) : r = [
      {
        name: "value",
        type: "float"
      }
    ];
    var i = new Ki(r, t), a = me(t.get("data"), lt(Z0, e));
    n && (a = rn(a, lt(Q0, n)));
    var s = EK(!!n, r);
    return i.initData(a, null, s), i;
  }
  function SCe(n) {
    n.registerComponentModel(vCe), n.registerComponentView(wCe), n.registerPreprocessor(function(e) {
      RM(e.series, "markPoint") && (e.markPoint = e.markPoint || {});
    });
  }
  var CCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markLine", e.defaultOption = {
      z: 5,
      symbol: [
        "circle",
        "arrow"
      ],
      symbolSize: [
        8,
        16
      ],
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, e;
  }(Zl), cw = Wt(), ICe = function(n, e, t, r) {
    var i = n.getData(), a;
    if (de(r)) a = r;
    else {
      var s = r.type;
      if (s === "min" || s === "max" || s === "average" || s === "median" || r.xAxis != null || r.yAxis != null) {
        var o = void 0, l = void 0;
        if (r.yAxis != null || r.xAxis != null) o = e.getAxis(r.yAxis != null ? "y" : "x"), l = ni(r.yAxis, r.xAxis);
        else {
          var u = NK(r, i, e, n);
          o = u.valueAxis;
          var c = IY(i, u.valueDataDim);
          l = $M(i, c, s);
        }
        var h = o.dim === "x" ? 0 : 1, d = 1 - h, f = Qe(r), p = {
          coord: []
        };
        f.type = null, f.coord = [], f.coord[d] = -1 / 0, p.coord[d] = 1 / 0;
        var g = t.get("precision");
        g >= 0 && Yt(l) && (l = +l.toFixed(Math.min(g, 20))), f.coord[h] = p.coord[h] = l, a = [
          f,
          p,
          {
            type: s,
            valueIndex: r.valueIndex,
            value: l
          }
        ];
      } else a = [];
    }
    var m = [
      Z0(n, a[0]),
      Z0(n, a[1]),
      oe({}, a[2])
    ];
    return m[2].type = m[2].type || null, pt(m[2], m[0]), pt(m[2], m[1]), m;
  };
  function mS(n) {
    return !isNaN(n) && !isFinite(n);
  }
  function QW(n, e, t, r) {
    var i = 1 - n, a = r.dimensions[n];
    return mS(e[i]) && mS(t[i]) && e[n] === t[n] && r.getAxis(a).containData(e[n]);
  }
  function kCe(n, e) {
    if (n.type === "cartesian2d") {
      var t = e[0].coord, r = e[1].coord;
      if (t && r && (QW(1, t, r, n) || QW(0, t, r, n))) return true;
    }
    return Q0(n, e[0]) && Q0(n, e[1]);
  }
  function VT(n, e, t, r, i) {
    var a = r.coordinateSystem, s = n.getItemModel(e), o, l = _e(s.get("x"), i.getWidth()), u = _e(s.get("y"), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) o = [
      l,
      u
    ];
    else {
      if (r.getMarkerPosition) o = r.getMarkerPosition(n.getValues(n.dimensions, e));
      else {
        var c = a.dimensions, h = n.get(c[0], e), d = n.get(c[1], e);
        o = a.dataToPoint([
          h,
          d
        ]);
      }
      if (Bd(a, "cartesian2d")) {
        var f = a.getAxis("x"), p = a.getAxis("y"), c = a.dimensions;
        mS(n.get(c[0], e)) ? o[0] = f.toGlobalCoord(f.getExtent()[t ? 0 : 1]) : mS(n.get(c[1], e)) && (o[1] = p.toGlobalCoord(p.getExtent()[t ? 0 : 1]));
      }
      isNaN(l) || (o[0] = l), isNaN(u) || (o[1] = u);
    }
    n.setItemLayout(e, o);
  }
  var TCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(a) {
        var s = Zl.getMarkerModelFromSeries(a, "markLine");
        if (s) {
          var o = s.getData(), l = cw(s).from, u = cw(s).to;
          l.each(function(c) {
            VT(l, c, true, a, i), VT(u, c, false, a, i);
          }), o.each(function(c) {
            o.setItemLayout(c, [
              l.getItemLayout(c),
              u.getItemLayout(c)
            ]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, a) {
      var s = t.coordinateSystem, o = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(o) || u.set(o, new JE());
      this.group.add(c.group);
      var h = ACe(s, t, r), d = h.from, f = h.to, p = h.line;
      cw(r).from = d, cw(r).to = f, r.setData(p);
      var g = r.get("symbol"), m = r.get("symbolSize"), v = r.get("symbolRotate"), y = r.get("symbolOffset");
      de(g) || (g = [
        g,
        g
      ]), de(m) || (m = [
        m,
        m
      ]), de(v) || (v = [
        v,
        v
      ]), de(y) || (y = [
        y,
        y
      ]), h.from.each(function(b) {
        x(d, b, true), x(f, b, false);
      }), p.each(function(b) {
        var w = p.getItemModel(b).getModel("lineStyle").getLineStyle();
        p.setItemLayout(b, [
          d.getItemLayout(b),
          f.getItemLayout(b)
        ]), w.stroke == null && (w.stroke = d.getItemVisual(b, "style").fill), p.setItemVisual(b, {
          fromSymbolKeepAspect: d.getItemVisual(b, "symbolKeepAspect"),
          fromSymbolOffset: d.getItemVisual(b, "symbolOffset"),
          fromSymbolRotate: d.getItemVisual(b, "symbolRotate"),
          fromSymbolSize: d.getItemVisual(b, "symbolSize"),
          fromSymbol: d.getItemVisual(b, "symbol"),
          toSymbolKeepAspect: f.getItemVisual(b, "symbolKeepAspect"),
          toSymbolOffset: f.getItemVisual(b, "symbolOffset"),
          toSymbolRotate: f.getItemVisual(b, "symbolRotate"),
          toSymbolSize: f.getItemVisual(b, "symbolSize"),
          toSymbol: f.getItemVisual(b, "symbol"),
          style: w
        });
      }), c.updateData(p), h.line.eachItemGraphicEl(function(b) {
        rt(b).dataModel = r, b.traverse(function(w) {
          rt(w).dataModel = r;
        });
      });
      function x(b, w, _) {
        var S = b.getItemModel(w);
        VT(b, w, _, t, a);
        var I = S.getModel("itemStyle").getItemStyle();
        I.fill == null && (I.fill = Bx(l, "color")), b.setItemVisual(w, {
          symbolKeepAspect: S.get("symbolKeepAspect"),
          symbolOffset: it(S.get("symbolOffset", true), y[_ ? 0 : 1]),
          symbolRotate: it(S.get("symbolRotate", true), v[_ ? 0 : 1]),
          symbolSize: it(S.get("symbolSize"), m[_ ? 0 : 1]),
          symbol: it(S.get("symbol", true), g[_ ? 0 : 1]),
          style: I
        });
      }
      this.markKeep(c), c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markLine", e;
  }(NM);
  function ACe(n, e, t) {
    var r;
    n ? r = me(n && n.dimensions, function(u) {
      var c = e.getData().getDimensionInfo(e.getData().mapDimension(u)) || {};
      return oe(oe({}, c), {
        name: u,
        ordinalMeta: null
      });
    }) : r = [
      {
        name: "value",
        type: "float"
      }
    ];
    var i = new Ki(r, t), a = new Ki(r, t), s = new Ki([], t), o = me(t.get("data"), lt(ICe, e, n, t));
    n && (o = rn(o, lt(kCe, n)));
    var l = EK(!!n, r);
    return i.initData(me(o, function(u) {
      return u[0];
    }), null, l), a.initData(me(o, function(u) {
      return u[1];
    }), null, l), s.initData(me(o, function(u) {
      return u[2];
    })), s.hasItemOption = true, {
      from: i,
      to: a,
      line: s
    };
  }
  function DCe(n) {
    n.registerComponentModel(CCe), n.registerComponentView(TCe), n.registerPreprocessor(function(e) {
      RM(e.series, "markLine") && (e.markLine = e.markLine || {});
    });
  }
  var RCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, r, i) {
      return new e(t, r, i);
    }, e.type = "markArea", e.defaultOption = {
      z: 1,
      tooltip: {
        trigger: "item"
      },
      animation: false,
      label: {
        show: true,
        position: "top"
      },
      itemStyle: {
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: true,
          position: "top"
        }
      }
    }, e;
  }(Zl), hw = Wt(), $Ce = function(n, e, t, r) {
    var i = r[0], a = r[1];
    if (!(!i || !a)) {
      var s = Z0(n, i), o = Z0(n, a), l = s.coord, u = o.coord;
      l[0] = ni(l[0], -1 / 0), l[1] = ni(l[1], -1 / 0), u[0] = ni(u[0], 1 / 0), u[1] = ni(u[1], 1 / 0);
      var c = NN([
        {},
        s,
        o
      ]);
      return c.coord = [
        s.coord,
        o.coord
      ], c.x0 = s.x, c.y0 = s.y, c.x1 = o.x, c.y1 = o.y, c;
    }
  };
  function vS(n) {
    return !isNaN(n) && !isFinite(n);
  }
  function JW(n, e, t, r) {
    var i = 1 - n;
    return vS(e[i]) && vS(t[i]);
  }
  function NCe(n, e) {
    var t = e.coord[0], r = e.coord[1], i = {
      coord: t,
      x: e.x0,
      y: e.y0
    }, a = {
      coord: r,
      x: e.x1,
      y: e.y1
    };
    return Bd(n, "cartesian2d") ? t && r && (JW(1, t, r) || JW(0, t, r)) ? true : bCe(n, i, a) : Q0(n, i) || Q0(n, a);
  }
  function eG(n, e, t, r, i) {
    var a = r.coordinateSystem, s = n.getItemModel(e), o, l = _e(s.get(t[0]), i.getWidth()), u = _e(s.get(t[1]), i.getHeight());
    if (!isNaN(l) && !isNaN(u)) o = [
      l,
      u
    ];
    else {
      if (r.getMarkerPosition) {
        var c = n.getValues([
          "x0",
          "y0"
        ], e), h = n.getValues([
          "x1",
          "y1"
        ], e), d = a.clampData(c), f = a.clampData(h), p = [];
        t[0] === "x0" ? p[0] = d[0] > f[0] ? h[0] : c[0] : p[0] = d[0] > f[0] ? c[0] : h[0], t[1] === "y0" ? p[1] = d[1] > f[1] ? h[1] : c[1] : p[1] = d[1] > f[1] ? c[1] : h[1], o = r.getMarkerPosition(p, t, true);
      } else {
        var g = n.get(t[0], e), m = n.get(t[1], e), v = [
          g,
          m
        ];
        a.clampData && a.clampData(v, v), o = a.dataToPoint(v, true);
      }
      if (Bd(a, "cartesian2d")) {
        var y = a.getAxis("x"), x = a.getAxis("y"), g = n.get(t[0], e), m = n.get(t[1], e);
        vS(g) ? o[0] = y.toGlobalCoord(y.getExtent()[t[0] === "x0" ? 0 : 1]) : vS(m) && (o[1] = x.toGlobalCoord(x.getExtent()[t[1] === "y0" ? 0 : 1]));
      }
      isNaN(l) || (o[0] = l), isNaN(u) || (o[1] = u);
    }
    return o;
  }
  var tG = [
    [
      "x0",
      "y0"
    ],
    [
      "x1",
      "y0"
    ],
    [
      "x1",
      "y1"
    ],
    [
      "x0",
      "y1"
    ]
  ], ECe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, r, i) {
      r.eachSeries(function(a) {
        var s = Zl.getMarkerModelFromSeries(a, "markArea");
        if (s) {
          var o = s.getData();
          o.each(function(l) {
            var u = me(tG, function(h) {
              return eG(o, l, h, a, i);
            });
            o.setItemLayout(l, u);
            var c = o.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, e.prototype.renderSeries = function(t, r, i, a) {
      var s = t.coordinateSystem, o = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(o) || u.set(o, {
        group: new tt()
      });
      this.group.add(c.group), this.markKeep(c);
      var h = MCe(s, t, r);
      r.setData(h), h.each(function(d) {
        var f = me(tG, function(I) {
          return eG(h, d, I, t, a);
        }), p = s.getAxis("x").scale, g = s.getAxis("y").scale, m = p.getExtent(), v = g.getExtent(), y = [
          p.parse(h.get("x0", d)),
          p.parse(h.get("x1", d))
        ], x = [
          g.parse(h.get("y0", d)),
          g.parse(h.get("y1", d))
        ];
        vs(y), vs(x);
        var b = !(m[0] > y[1] || m[1] < y[0] || v[0] > x[1] || v[1] < x[0]), w = !b;
        h.setItemLayout(d, {
          points: f,
          allClipped: w
        });
        var _ = h.getItemModel(d).getModel("itemStyle").getItemStyle(), S = Bx(l, "color");
        _.fill || (_.fill = S, Ie(_.fill) && (_.fill = E_(_.fill, 0.4))), _.stroke || (_.stroke = S), h.setItemVisual(d, "style", _);
      }), h.diff(hw(c).data).add(function(d) {
        var f = h.getItemLayout(d);
        if (!f.allClipped) {
          var p = new ia({
            shape: {
              points: f.points
            }
          });
          h.setItemGraphicEl(d, p), c.group.add(p);
        }
      }).update(function(d, f) {
        var p = hw(c).data.getItemGraphicEl(f), g = h.getItemLayout(d);
        g.allClipped ? p && c.group.remove(p) : (p ? Kt(p, {
          shape: {
            points: g.points
          }
        }, r, d) : p = new ia({
          shape: {
            points: g.points
          }
        }), h.setItemGraphicEl(d, p), c.group.add(p));
      }).remove(function(d) {
        var f = hw(c).data.getItemGraphicEl(d);
        c.group.remove(f);
      }).execute(), h.eachItemGraphicEl(function(d, f) {
        var p = h.getItemModel(f), g = h.getItemVisual(f, "style");
        d.useStyle(h.getItemVisual(f, "style")), gi(d, Hr(p), {
          labelFetcher: r,
          labelDataIndex: f,
          defaultText: h.getName(f) || "",
          inheritColor: Ie(g.fill) ? E_(g.fill, 1) : "#000"
        }), pi(d, p), Qn(d, null, null, p.get([
          "emphasis",
          "disabled"
        ])), rt(d).dataModel = r;
      }), hw(c).data = h, c.group.silent = r.get("silent") || t.get("silent");
    }, e.type = "markArea", e;
  }(NM);
  function MCe(n, e, t) {
    var r, i, a = [
      "x0",
      "y0",
      "x1",
      "y1"
    ];
    if (n) {
      var s = me(n && n.dimensions, function(u) {
        var c = e.getData(), h = c.getDimensionInfo(c.mapDimension(u)) || {};
        return oe(oe({}, h), {
          name: u,
          ordinalMeta: null
        });
      });
      i = me(a, function(u, c) {
        return {
          name: u,
          type: s[c % 2].type
        };
      }), r = new Ki(i, t);
    } else i = [
      {
        name: "value",
        type: "float"
      }
    ], r = new Ki(i, t);
    var o = me(t.get("data"), lt($Ce, e, n, t));
    n && (o = rn(o, lt(NCe, n)));
    var l = n ? function(u, c, h, d) {
      var f = u.coord[Math.floor(d / 2)][d % 2];
      return Yu(f, i[d]);
    } : function(u, c, h, d) {
      return Yu(u.value, i[d]);
    };
    return r.initData(o, null, l), r.hasItemOption = true, r;
  }
  function PCe(n) {
    n.registerComponentModel(RCe), n.registerComponentView(ECe), n.registerPreprocessor(function(e) {
      RM(e.series, "markArea") && (e.markArea = e.markArea || {});
    });
  }
  var LCe = function(n, e) {
    if (e === "all") return {
      type: "all",
      title: n.getLocaleModel().get([
        "legend",
        "selector",
        "all"
      ])
    };
    if (e === "inverse") return {
      type: "inverse",
      title: n.getLocaleModel().get([
        "legend",
        "selector",
        "inverse"
      ])
    };
  }, qR = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: true
      }, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), this._updateSelector(t);
    }, e.prototype._updateSelector = function(t) {
      var r = t.selector, i = this.ecModel;
      r === true && (r = t.selector = [
        "all",
        "inverse"
      ]), de(r) && P(r, function(a, s) {
        Ie(a) && (a = {
          type: a
        }), r[s] = pt(a, LCe(i, a.type));
      });
    }, e.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var t = this._data;
      if (t[0] && this.get("selectedMode") === "single") {
        for (var r = false, i = 0; i < t.length; i++) {
          var a = t[i].get("name");
          if (this.isSelected(a)) {
            this.select(a), r = true;
            break;
          }
        }
        !r && this.select(t[0].get("name"));
      }
    }, e.prototype._updateData = function(t) {
      var r = [], i = [];
      t.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var h = l.legendVisualProvider, d = h.getAllNames();
          t.isSeriesFiltered(l) || (i = i.concat(d)), d.length ? r = r.concat(d) : c = true;
        } else c = true;
        c && WN(l) && r.push(l.name);
      }), this._availableNames = i;
      var a = this.get("data") || r, s = Pe(), o = me(a, function(l) {
        return (Ie(l) || Yt(l)) && (l = {
          name: l
        }), s.get(l.name) ? null : (s.set(l.name, true), new on(l, this, this.ecModel));
      }, this);
      this._data = rn(o, function(l) {
        return !!l;
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.select = function(t) {
      var r = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var a = this._data;
        P(a, function(s) {
          r[s.get("name")] = false;
        });
      }
      r[t] = true;
    }, e.prototype.unSelect = function(t) {
      this.get("selectedMode") !== "single" && (this.option.selected[t] = false);
    }, e.prototype.toggleSelected = function(t) {
      var r = this.option.selected;
      r.hasOwnProperty(t) || (r[t] = true), this[r[t] ? "unSelect" : "select"](t);
    }, e.prototype.allSelect = function() {
      var t = this._data, r = this.option.selected;
      P(t, function(i) {
        r[i.get("name", true)] = true;
      });
    }, e.prototype.inverseSelect = function() {
      var t = this._data, r = this.option.selected;
      P(t, function(i) {
        var a = i.get("name", true);
        r.hasOwnProperty(a) || (r[a] = true), r[a] = !r[a];
      });
    }, e.prototype.isSelected = function(t) {
      var r = this.option.selected;
      return !(r.hasOwnProperty(t) && !r[t]) && bt(this._availableNames, t) >= 0;
    }, e.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, e.type = "legend.plain", e.dependencies = [
      "series"
    ], e.defaultOption = {
      z: 4,
      show: true,
      orient: "horizontal",
      left: "center",
      top: 0,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: true,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: true,
      selector: false,
      selectorLabel: {
        show: true,
        borderRadius: 10,
        padding: [
          3,
          5,
          3,
          5
        ],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: true,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: false
      }
    }, e;
  }(Et), Wp = lt, jR = P, dw = tt, MK = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = false, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._contentGroup = new dw()), this.group.add(this._selectorGroup = new dw()), this._isFirstRender = true;
    }, e.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, e.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, e.prototype.render = function(t, r, i) {
      var a = this._isFirstRender;
      if (this._isFirstRender = false, this.resetInner(), !!t.get("show", true)) {
        var s = t.get("align"), o = t.get("orient");
        (!s || s === "auto") && (s = t.get("left") === "right" && o === "vertical" ? "right" : "left");
        var l = t.get("selector", true), u = t.get("selectorPosition", true);
        l && (!u || u === "auto") && (u = o === "horizontal" ? "end" : "start"), this.renderInner(s, t, r, i, l, o, u);
        var c = t.getBoxLayoutParams(), h = {
          width: i.getWidth(),
          height: i.getHeight()
        }, d = t.get("padding"), f = Er(c, h, d), p = this.layoutInner(t, s, f, a, l, u), g = Er(je({
          width: p.width,
          height: p.height
        }, c), h, d);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = _K(p, t));
      }
    }, e.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, e.prototype.renderInner = function(t, r, i, a, s, o, l) {
      var u = this.getContentGroup(), c = Pe(), h = r.get("selectedMode"), d = [];
      i.eachRawSeries(function(f) {
        !f.get("legendHoverLink") && d.push(f.id);
      }), jR(r.getData(), function(f, p) {
        var g = f.get("name");
        if (!this.newlineDisabled && (g === "" || g === `
`)) {
          var m = new dw();
          m.newline = true, u.add(m);
          return;
        }
        var v = i.getSeriesByName(g)[0];
        if (!c.get(g)) if (v) {
          var y = v.getData(), x = y.getVisual("legendLineStyle") || {}, b = y.getVisual("legendIcon"), w = y.getVisual("style"), _ = this._createItem(v, g, p, f, r, t, x, w, b, h, a);
          _.on("click", Wp(nG, g, null, a, d)).on("mouseover", Wp(KR, v.name, null, a, d)).on("mouseout", Wp(ZR, v.name, null, a, d)), i.ssr && _.eachChild(function(S) {
            var I = rt(S);
            I.seriesIndex = v.seriesIndex, I.dataIndex = p, I.ssrType = "legend";
          }), c.set(g, true);
        } else i.eachRawSeries(function(S) {
          if (!c.get(g) && S.legendVisualProvider) {
            var I = S.legendVisualProvider;
            if (!I.containName(g)) return;
            var C = I.indexOfName(g), T = I.getItemVisual(C, "style"), k = I.getItemVisual(C, "legendIcon"), D = Va(T.fill);
            D && D[3] === 0 && (D[3] = 0.2, T = oe(oe({}, T), {
              fill: Pl(D, "rgba")
            }));
            var R = this._createItem(S, g, p, f, r, t, {}, T, k, h, a);
            R.on("click", Wp(nG, null, g, a, d)).on("mouseover", Wp(KR, null, g, a, d)).on("mouseout", Wp(ZR, null, g, a, d)), i.ssr && R.eachChild(function(N) {
              var E = rt(N);
              E.seriesIndex = S.seriesIndex, E.dataIndex = p, E.ssrType = "legend";
            }), c.set(g, true);
          }
        }, this);
      }, this), s && this._createSelector(s, r, a, o, l);
    }, e.prototype._createSelector = function(t, r, i, a, s) {
      var o = this.getSelectorGroup();
      jR(t, function(u) {
        var c = u.type, h = new Gt({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect",
              legendId: r.id
            });
          }
        });
        o.add(h);
        var d = r.getModel("selectorLabel"), f = r.getModel([
          "emphasis",
          "selectorLabel"
        ]);
        gi(h, {
          normal: d,
          emphasis: f
        }, {
          defaultText: u.title
        }), Qh(h);
      });
    }, e.prototype._createItem = function(t, r, i, a, s, o, l, u, c, h, d) {
      var f = t.visualDrawType, p = s.get("itemWidth"), g = s.get("itemHeight"), m = s.isSelected(r), v = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), x = a.get("icon");
      c = x || c || "roundRect";
      var b = FCe(c, a, l, u, f, m, d), w = new dw(), _ = a.getModel("textStyle");
      if (Xe(t.getLegendIcon) && (!x || x === "inherit")) w.add(t.getLegendIcon({
        itemWidth: p,
        itemHeight: g,
        icon: c,
        iconRotate: v,
        itemStyle: b.itemStyle,
        lineStyle: b.lineStyle,
        symbolKeepAspect: y
      }));
      else {
        var S = x === "inherit" && t.getData().getVisual("symbol") ? v === "inherit" ? t.getData().getVisual("symbolRotate") : v : 0;
        w.add(OCe({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: S,
          itemStyle: b.itemStyle,
          symbolKeepAspect: y
        }));
      }
      var I = o === "left" ? p + 5 : -5, C = o, T = s.get("formatter"), k = r;
      Ie(T) && T ? k = T.replace("{name}", r ?? "") : Xe(T) && (k = T(r));
      var D = m ? _.getTextColor() : a.get("inactiveColor");
      w.add(new Gt({
        style: $n(_, {
          text: k,
          x: I,
          y: g / 2,
          fill: D,
          align: C,
          verticalAlign: "middle"
        }, {
          inheritColor: D
        })
      }));
      var R = new Vt({
        shape: w.getBoundingRect(),
        style: {
          fill: "transparent"
        }
      }), N = a.getModel("tooltip");
      return N.get("show") && Pd({
        el: R,
        componentModel: s,
        itemName: r,
        itemTooltipOption: N.option
      }), w.add(R), w.eachChild(function(E) {
        E.silent = true;
      }), R.silent = !h, this.getContentGroup().add(w), Qh(w), w.__legendDataIndex = i, w;
    }, e.prototype.layoutInner = function(t, r, i, a, s, o) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      ed(t.get("orient"), l, t.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), h = [
        -c.x,
        -c.y
      ];
      if (u.markRedraw(), l.markRedraw(), s) {
        ed("horizontal", u, t.get("selectorItemGap", true));
        var d = u.getBoundingRect(), f = [
          -d.x,
          -d.y
        ], p = t.get("selectorButtonGap", true), g = t.getOrient().index, m = g === 0 ? "width" : "height", v = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
        o === "end" ? f[g] += c[m] + p : h[g] += d[m] + p, f[1 - g] += c[v] / 2 - d[v] / 2, u.x = f[0], u.y = f[1], l.x = h[0], l.y = h[1];
        var x = {
          x: 0,
          y: 0
        };
        return x[m] = c[m] + p + d[m], x[v] = Math.max(c[v], d[v]), x[y] = Math.min(0, d[y] + f[1 - g]), x;
      } else return l.x = h[0], l.y = h[1], this.group.getBoundingRect();
    }, e.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = true;
    }, e.type = "legend.plain", e;
  }(Yn);
  function FCe(n, e, t, r, i, a, s) {
    function o(m, v) {
      m.lineWidth === "auto" && (m.lineWidth = v.lineWidth > 0 ? 2 : 0), jR(m, function(y, x) {
        m[x] === "inherit" && (m[x] = v[x]);
      });
    }
    var l = e.getModel("itemStyle"), u = l.getItemStyle(), c = n.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", h = l.getShallow("decal");
    u.decal = !h || h === "inherit" ? r.decal : Lg(h, s), u.fill === "inherit" && (u.fill = r[i]), u.stroke === "inherit" && (u.stroke = r[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? r : t).opacity), o(u, r);
    var d = e.getModel("lineStyle"), f = d.getLineStyle();
    if (o(f, t), u.fill === "auto" && (u.fill = r.fill), u.stroke === "auto" && (u.stroke = r.fill), f.stroke === "auto" && (f.stroke = r.fill), !a) {
      var p = e.get("inactiveBorderWidth"), g = u[c];
      u.lineWidth = p === "auto" ? r.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), f.stroke = d.get("inactiveColor"), f.lineWidth = d.get("inactiveWidth");
    }
    return {
      itemStyle: u,
      lineStyle: f
    };
  }
  function OCe(n) {
    var e = n.icon || "roundRect", t = xr(e, 0, 0, n.itemWidth, n.itemHeight, n.itemStyle.fill, n.symbolKeepAspect);
    return t.setStyle(n.itemStyle), t.rotation = (n.iconRotate || 0) * Math.PI / 180, t.setOrigin([
      n.itemWidth / 2,
      n.itemHeight / 2
    ]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t;
  }
  function nG(n, e, t, r) {
    ZR(n, e, t, r), t.dispatchAction({
      type: "legendToggleSelect",
      name: n ?? e
    }), KR(n, e, t, r);
  }
  function PK(n) {
    for (var e = n.getZr().storage.getDisplayList(), t, r = 0, i = e.length; r < i && !(t = e[r].states.emphasis); ) r++;
    return t && t.hoverLayer;
  }
  function KR(n, e, t, r) {
    PK(t) || t.dispatchAction({
      type: "highlight",
      seriesName: n,
      name: e,
      excludeSeriesId: r
    });
  }
  function ZR(n, e, t, r) {
    PK(t) || t.dispatchAction({
      type: "downplay",
      seriesName: n,
      name: e,
      excludeSeriesId: r
    });
  }
  function BCe(n) {
    var e = n.findComponents({
      mainType: "legend"
    });
    e && e.length && n.filterSeries(function(t) {
      for (var r = 0; r < e.length; r++) if (!e[r].isSelected(t.name)) return false;
      return true;
    });
  }
  function my(n, e, t) {
    var r = n === "allSelect" || n === "inverseSelect", i = {}, a = [];
    t.eachComponent({
      mainType: "legend",
      query: e
    }, function(o) {
      r ? o[n]() : o[n](e.name), rG(o, i), a.push(o.componentIndex);
    });
    var s = {};
    return t.eachComponent("legend", function(o) {
      P(i, function(l, u) {
        o[l ? "select" : "unSelect"](u);
      }), rG(o, s);
    }), r ? {
      selected: s,
      legendIndex: a
    } : {
      name: e.name,
      selected: s
    };
  }
  function rG(n, e) {
    var t = e || {};
    return P(n.getData(), function(r) {
      var i = r.get("name");
      if (!(i === `
` || i === "")) {
        var a = n.isSelected(i);
        $e(t, i) ? t[i] = t[i] && a : t[i] = a;
      }
    }), t;
  }
  function zCe(n) {
    n.registerAction("legendToggleSelect", "legendselectchanged", lt(my, "toggleSelected")), n.registerAction("legendAllSelect", "legendselectall", lt(my, "allSelect")), n.registerAction("legendInverseSelect", "legendinverseselect", lt(my, "inverseSelect")), n.registerAction("legendSelect", "legendselected", lt(my, "select")), n.registerAction("legendUnSelect", "legendunselected", lt(my, "unSelect"));
  }
  function LK(n) {
    n.registerComponentModel(qR), n.registerComponentView(MK), n.registerProcessor(n.PRIORITY.PROCESSOR.SERIES_FILTER, BCe), n.registerSubTypeDefaulter("legend", function() {
      return "plain";
    }), zCe(n);
  }
  var VCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.setScrollDataIndex = function(t) {
      this.option.scrollDataIndex = t;
    }, e.prototype.init = function(t, r, i) {
      var a = bm(t);
      n.prototype.init.call(this, t, r, i), iG(this, t, a);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), iG(this, this.option, t);
    }, e.type = "legend.scroll", e.defaultOption = mc(qR.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: [
          "M0,0L12,-10L12,10z",
          "M0,0L-12,-10L-12,10z"
        ],
        vertical: [
          "M0,0L20,0L10,-20z",
          "M0,0L20,0L10,20z"
        ]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), e;
  }(qR);
  function iG(n, e, t) {
    var r = n.getOrient(), i = [
      1,
      1
    ];
    i[r.index] = 0, rc(e, t, {
      type: "box",
      ignoreSize: !!i
    });
  }
  var aG = tt, WT = [
    "width",
    "height"
  ], GT = [
    "x",
    "y"
  ], WCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = true, t._currentIndex = 0, t;
    }
    return e.prototype.init = function() {
      n.prototype.init.call(this), this.group.add(this._containerGroup = new aG()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new aG());
    }, e.prototype.resetInner = function() {
      n.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, e.prototype.renderInner = function(t, r, i, a, s, o, l) {
      var u = this;
      n.prototype.renderInner.call(this, t, r, i, a, s, o, l);
      var c = this._controllerGroup, h = r.get("pageIconSize", true), d = de(h) ? h : [
        h,
        h
      ];
      p("pagePrev", 0);
      var f = r.getModel("pageTextStyle");
      c.add(new Gt({
        name: "pageText",
        style: {
          text: "xx/xx",
          fill: f.getTextColor(),
          font: f.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: true
      })), p("pageNext", 1);
      function p(g, m) {
        var v = g + "DataIndex", y = Fx(r.get("pageIcons", true)[r.getOrient().name][m], {
          onclick: Ae(u._pageGo, u, v, r, a)
        }, {
          x: -d[0] / 2,
          y: -d[1] / 2,
          width: d[0],
          height: d[1]
        });
        y.name = g, c.add(y);
      }
    }, e.prototype.layoutInner = function(t, r, i, a, s, o) {
      var l = this.getSelectorGroup(), u = t.getOrient().index, c = WT[u], h = GT[u], d = WT[1 - u], f = GT[1 - u];
      s && ed("horizontal", l, t.get("selectorItemGap", true));
      var p = t.get("selectorButtonGap", true), g = l.getBoundingRect(), m = [
        -g.x,
        -g.y
      ], v = Qe(i);
      s && (v[c] = i[c] - g[c] - p);
      var y = this._layoutContentAndController(t, a, v, u, c, d, f, h);
      if (s) {
        if (o === "end") m[u] += y[c] + p;
        else {
          var x = g[c] + p;
          m[u] -= x, y[h] -= x;
        }
        y[c] += g[c] + p, m[1 - u] += y[f] + y[d] / 2 - g[d] / 2, y[d] = Math.max(y[d], g[d]), y[f] = Math.min(y[f], g[f] + m[1 - u]), l.x = m[0], l.y = m[1], l.markRedraw();
      }
      return y;
    }, e.prototype._layoutContentAndController = function(t, r, i, a, s, o, l, u) {
      var c = this.getContentGroup(), h = this._containerGroup, d = this._controllerGroup;
      ed(t.get("orient"), c, t.get("itemGap"), a ? i.width : null, a ? null : i.height), ed("horizontal", d, t.get("pageButtonItemGap", true));
      var f = c.getBoundingRect(), p = d.getBoundingRect(), g = this._showController = f[s] > i[s], m = [
        -f.x,
        -f.y
      ];
      r || (m[a] = c[u]);
      var v = [
        0,
        0
      ], y = [
        -p.x,
        -p.y
      ], x = it(t.get("pageButtonGap", true), t.get("itemGap", true));
      if (g) {
        var b = t.get("pageButtonPosition", true);
        b === "end" ? y[a] += i[s] - p[s] : v[a] += p[s] + x;
      }
      y[1 - a] += f[o] / 2 - p[o] / 2, c.setPosition(m), h.setPosition(v), d.setPosition(y);
      var w = {
        x: 0,
        y: 0
      };
      if (w[s] = g ? i[s] : f[s], w[o] = Math.max(f[o], p[o]), w[l] = Math.min(0, p[l] + y[1 - a]), h.__rectSize = i[s], g) {
        var _ = {
          x: 0,
          y: 0
        };
        _[s] = Math.max(i[s] - p[s] - x, 0), _[o] = w[o], h.setClipPath(new Vt({
          shape: _
        })), h.__rectSize = _[s];
      } else d.eachChild(function(I) {
        I.attr({
          invisible: true,
          silent: true
        });
      });
      var S = this._getPageInfo(t);
      return S.pageIndex != null && Kt(c, {
        x: S.contentPosition[0],
        y: S.contentPosition[1]
      }, g ? t : null), this._updatePageInfoView(t, S), w;
    }, e.prototype._pageGo = function(t, r, i) {
      var a = this._getPageInfo(r)[t];
      a != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: r.id
      });
    }, e.prototype._updatePageInfoView = function(t, r) {
      var i = this._controllerGroup;
      P([
        "pagePrev",
        "pageNext"
      ], function(c) {
        var h = c + "DataIndex", d = r[h] != null, f = i.childOfName(c);
        f && (f.setStyle("fill", d ? t.get("pageIconColor", true) : t.get("pageIconInactiveColor", true)), f.cursor = d ? "pointer" : "default");
      });
      var a = i.childOfName("pageText"), s = t.get("pageFormatter"), o = r.pageIndex, l = o != null ? o + 1 : 0, u = r.pageCount;
      a && s && a.setStyle("text", Ie(s) ? s.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : s({
        current: l,
        total: u
      }));
    }, e.prototype._getPageInfo = function(t) {
      var r = t.get("scrollDataIndex", true), i = this.getContentGroup(), a = this._containerGroup.__rectSize, s = t.getOrient().index, o = WT[s], l = GT[s], u = this._findTargetItemIndex(r), c = i.children(), h = c[u], d = c.length, f = d ? 1 : 0, p = {
        contentPosition: [
          i.x,
          i.y
        ],
        pageCount: f,
        pageIndex: f - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!h) return p;
      var g = b(h);
      p.contentPosition[s] = -g.s;
      for (var m = u + 1, v = g, y = g, x = null; m <= d; ++m) x = b(c[m]), (!x && y.e > v.s + a || x && !w(x, v.s)) && (y.i > v.i ? v = y : v = x, v && (p.pageNextDataIndex == null && (p.pageNextDataIndex = v.i), ++p.pageCount)), y = x;
      for (var m = u - 1, v = g, y = g, x = null; m >= -1; --m) x = b(c[m]), (!x || !w(y, x.s)) && v.i < y.i && (y = v, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = v.i), ++p.pageCount, ++p.pageIndex), v = x;
      return p;
      function b(_) {
        if (_) {
          var S = _.getBoundingRect(), I = S[l] + _[l];
          return {
            s: I,
            e: I + S[o],
            i: _.__legendDataIndex
          };
        }
      }
      function w(_, S) {
        return _.e >= S && _.s <= S + a;
      }
    }, e.prototype._findTargetItemIndex = function(t) {
      if (!this._showController) return 0;
      var r, i = this.getContentGroup(), a;
      return i.eachChild(function(s, o) {
        var l = s.__legendDataIndex;
        a == null && l != null && (a = o), l === t && (r = o);
      }), r ?? a;
    }, e.type = "legend.scroll", e;
  }(MK);
  function GCe(n) {
    n.registerAction("legendScroll", "legendscroll", function(e, t) {
      var r = e.scrollDataIndex;
      r != null && t.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: e
      }, function(i) {
        i.setScrollDataIndex(r);
      });
    });
  }
  function UCe(n) {
    Ct(LK), n.registerComponentModel(VCe), n.registerComponentView(WCe), GCe(n);
  }
  function HCe(n) {
    Ct(LK), Ct(UCe);
  }
  var XCe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.inside", e.defaultOption = mc(K0.defaultOption, {
      disabled: false,
      zoomLock: false,
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: false,
      preventDefaultMouseMove: true
    }), e;
  }(K0), EM = Wt();
  function YCe(n, e, t) {
    EM(n).coordSysRecordMap.each(function(r) {
      var i = r.dataZoomInfoMap.get(e.uid);
      i && (i.getRange = t);
    });
  }
  function qCe(n, e) {
    for (var t = EM(n).coordSysRecordMap, r = t.keys(), i = 0; i < r.length; i++) {
      var a = r[i], s = t.get(a), o = s.dataZoomInfoMap;
      if (o) {
        var l = e.uid, u = o.get(l);
        u && (o.removeKey(l), o.keys().length || FK(t, s));
      }
    }
  }
  function FK(n, e) {
    if (e) {
      n.removeKey(e.model.uid);
      var t = e.controller;
      t && t.dispose();
    }
  }
  function jCe(n, e) {
    var t = {
      model: e,
      containsPoint: lt(ZCe, e),
      dispatchAction: lt(KCe, n),
      dataZoomInfoMap: null,
      controller: null
    }, r = t.controller = new qx(n.getZr());
    return P([
      "pan",
      "zoom",
      "scrollMove"
    ], function(i) {
      r.on(i, function(a) {
        var s = [];
        t.dataZoomInfoMap.each(function(o) {
          if (a.isAvailableBehavior(o.model.option)) {
            var l = (o.getRange || {})[i], u = l && l(o.dzReferCoordSysInfo, t.model.mainType, t.controller, a);
            !o.model.get("disabled", true) && u && s.push({
              dataZoomId: o.model.id,
              start: u[0],
              end: u[1]
            });
          }
        }), s.length && t.dispatchAction(s);
      });
    }), t;
  }
  function KCe(n, e) {
    n.isDisposed() || n.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch: e
    });
  }
  function ZCe(n, e, t, r) {
    return n.coordinateSystem.containPoint([
      t,
      r
    ]);
  }
  function QCe(n) {
    var e, t = "type_", r = {
      type_true: 2,
      type_move: 1,
      type_false: 0,
      type_undefined: -1
    }, i = true;
    return n.each(function(a) {
      var s = a.model, o = s.get("disabled", true) ? false : s.get("zoomLock", true) ? "move" : true;
      r[t + o] > r[t + e] && (e = o), i = i && s.get("preventDefaultMouseMove", true);
    }), {
      controlType: e,
      opt: {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: true,
        preventDefaultMouseMove: !!i
      }
    };
  }
  function JCe(n) {
    n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, function(e, t) {
      var r = EM(t), i = r.coordSysRecordMap || (r.coordSysRecordMap = Pe());
      i.each(function(a) {
        a.dataZoomInfoMap = null;
      }), e.eachComponent({
        mainType: "dataZoom",
        subType: "inside"
      }, function(a) {
        var s = xK(a);
        P(s.infoList, function(o) {
          var l = o.model.uid, u = i.get(l) || i.set(l, jCe(t, o.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = Pe());
          c.set(a.uid, {
            dzReferCoordSysInfo: o,
            model: a,
            getRange: null
          });
        });
      }), i.each(function(a) {
        var s = a.controller, o, l = a.dataZoomInfoMap;
        if (l) {
          var u = l.keys()[0];
          u != null && (o = l.get(u));
        }
        if (!o) {
          FK(i, a);
          return;
        }
        var c = QCe(l);
        s.enable(c.controlType, c.opt), s.setPointerChecker(a.containsPoint), Sm(a, "dispatchAction", o.model.get("throttle", true), "fixRate");
      });
    });
  }
  var eIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataZoom.inside", t;
    }
    return e.prototype.render = function(t, r, i) {
      if (n.prototype.render.apply(this, arguments), t.noTarget()) {
        this._clear();
        return;
      }
      this.range = t.getPercentRange(), YCe(i, t, {
        pan: Ae(UT.pan, this),
        zoom: Ae(UT.zoom, this),
        scrollMove: Ae(UT.scrollMove, this)
      });
    }, e.prototype.dispose = function() {
      this._clear(), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      qCe(this.api, this.dataZoomModel), this.range = null;
    }, e.type = "dataZoom.inside", e;
  }(CM), UT = {
    zoom: function(n, e, t, r) {
      var i = this.range, a = i.slice(), s = n.axisModels[0];
      if (s) {
        var o = HT[e](null, [
          r.originX,
          r.originY
        ], s, t, n), l = (o.signal > 0 ? o.pixelStart + o.pixelLength - o.pixel : o.pixel - o.pixelStart) / o.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / r.scale, 0);
        a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
        var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        if (Vd(0, a, [
          0,
          100
        ], 0, c.minSpan, c.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1]) return a;
      }
    },
    pan: sG(function(n, e, t, r, i, a) {
      var s = HT[r]([
        a.oldX,
        a.oldY
      ], [
        a.newX,
        a.newY
      ], e, i, t);
      return s.signal * (n[1] - n[0]) * s.pixel / s.pixelLength;
    }),
    scrollMove: sG(function(n, e, t, r, i, a) {
      var s = HT[r]([
        0,
        0
      ], [
        a.scrollDelta,
        a.scrollDelta
      ], e, i, t);
      return s.signal * (n[1] - n[0]) * a.scrollDelta;
    })
  };
  function sG(n) {
    return function(e, t, r, i) {
      var a = this.range, s = a.slice(), o = e.axisModels[0];
      if (o) {
        var l = n(s, o, e, t, r, i);
        if (Vd(l, s, [
          0,
          100
        ], "all"), this.range = s, a[0] !== s[0] || a[1] !== s[1]) return s;
      }
    };
  }
  var HT = {
    grid: function(n, e, t, r, i) {
      var a = t.axis, s = {}, o = i.model.coordinateSystem.getRect();
      return n = n || [
        0,
        0
      ], a.dim === "x" ? (s.pixel = e[0] - n[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - n[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
    },
    polar: function(n, e, t, r, i) {
      var a = t.axis, s = {}, o = i.model.coordinateSystem, l = o.getRadiusAxis().getExtent(), u = o.getAngleAxis().getExtent();
      return n = n ? o.pointToCoord(n) : [
        0,
        0
      ], e = o.pointToCoord(e), t.mainType === "radiusAxis" ? (s.pixel = e[0] - n[0], s.pixelLength = l[1] - l[0], s.pixelStart = l[0], s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - n[1], s.pixelLength = u[1] - u[0], s.pixelStart = u[0], s.signal = a.inverse ? -1 : 1), s;
    },
    singleAxis: function(n, e, t, r, i) {
      var a = t.axis, s = i.model.coordinateSystem.getRect(), o = {};
      return n = n || [
        0,
        0
      ], a.orient === "horizontal" ? (o.pixel = e[0] - n[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - n[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
    }
  };
  function OK(n) {
    IM(n), n.registerComponentModel(XCe), n.registerComponentView(eIe), JCe(n);
  }
  var tIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = mc(K0.defaultOption, {
      show: true,
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: true,
      showDataShadow: "auto",
      realtime: true,
      zoomLock: false,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: true,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleLabel: {
          show: true
        },
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), e;
  }(K0), vy = Vt, oG = 7, nIe = 1, XT = 30, rIe = 7, yy = "horizontal", lG = "vertical", iIe = 5, aIe = [
    "line",
    "bar",
    "candlestick",
    "scatter"
  ], sIe = {
    easing: "cubicOut",
    duration: 100,
    delay: 0
  }, oIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._displayables = {}, t;
    }
    return e.prototype.init = function(t, r) {
      this.api = r, this._onBrush = Ae(this._onBrush, this), this._onBrushEnd = Ae(this._onBrushEnd, this);
    }, e.prototype.render = function(t, r, i, a) {
      if (n.prototype.render.apply(this, arguments), Sm(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === false) {
        this.group.removeAll();
        return;
      }
      if (t.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, e.prototype.dispose = function() {
      this._clear(), n.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      F0(this, "_dispatchZoomAction");
      var t = this.api.getZr();
      t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd);
    }, e.prototype._buildView = function() {
      var t = this.group;
      t.removeAll(), this._brushing = false, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var r = this._displayables.sliderGroup = new tt();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(r), this._positionGroup();
    }, e.prototype._resetLocation = function() {
      var t = this.dataZoomModel, r = this.api, i = t.get("brushSelect"), a = i ? rIe : 0, s = this._findCoordRect(), o = {
        width: r.getWidth(),
        height: r.getHeight()
      }, l = this._orient === yy ? {
        right: o.width - s.x - s.width,
        top: o.height - XT - oG - a,
        width: s.width,
        height: XT
      } : {
        right: oG,
        top: s.y,
        width: XT,
        height: s.height
      }, u = bm(t.option);
      P([
        "right",
        "top",
        "width",
        "height"
      ], function(h) {
        u[h] === "ph" && (u[h] = l[h]);
      });
      var c = Er(u, o);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [
        c.width,
        c.height
      ], this._orient === lG && this._size.reverse();
    }, e.prototype._positionGroup = function() {
      var t = this.group, r = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), s = a && a.get("inverse"), o = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      o.attr(i === yy && !s ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === yy && s ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === lG && !s ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = t.getBoundingRect([
        o
      ]);
      t.x = r.x - u.x, t.y = r.y - u.y, t.markRedraw();
    }, e.prototype._getViewExtent = function() {
      return [
        0,
        this._size[0]
      ];
    }, e.prototype._renderBackground = function() {
      var t = this.dataZoomModel, r = this._size, i = this._displayables.sliderGroup, a = t.get("brushSelect");
      i.add(new vy({
        silent: true,
        shape: {
          x: 0,
          y: 0,
          width: r[0],
          height: r[1]
        },
        style: {
          fill: t.get("backgroundColor")
        },
        z2: -40
      }));
      var s = new vy({
        shape: {
          x: 0,
          y: 0,
          width: r[0],
          height: r[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: Ae(this._onClickPanel, this)
      }), o = this.api.getZr();
      a ? (s.on("mousedown", this._onBrushStart, this), s.cursor = "crosshair", o.on("mousemove", this._onBrush), o.on("mouseup", this._onBrushEnd)) : (o.off("mousemove", this._onBrush), o.off("mouseup", this._onBrushEnd)), i.add(s);
    }, e.prototype._renderDataShadow = function() {
      var t = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !t) return;
      var r = this._size, i = this._shadowSize || [], a = t.series, s = a.getRawData(), o = a.getShadowDim && a.getShadowDim(), l = o && s.getDimensionInfo(o) ? a.getShadowDim() : t.otherDim;
      if (l == null) return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (s !== this._shadowData || l !== this._shadowDim || r[0] !== i[0] || r[1] !== i[1]) {
        var h = s.getDataExtent(l), d = (h[1] - h[0]) * 0.3;
        h = [
          h[0] - d,
          h[1] + d
        ];
        var f = [
          0,
          r[1]
        ], p = [
          0,
          r[0]
        ], g = [
          [
            r[0],
            0
          ],
          [
            0,
            0
          ]
        ], m = [], v = p[1] / (s.count() - 1), y = 0, x = Math.round(s.count() / r[0]), b;
        s.each([
          l
        ], function(C, T) {
          if (x > 0 && T % x) {
            y += v;
            return;
          }
          var k = C == null || isNaN(C) || C === "", D = k ? 0 : sn(C, h, f, true);
          k && !b && T ? (g.push([
            g[g.length - 1][0],
            0
          ]), m.push([
            m[m.length - 1][0],
            0
          ])) : !k && b && (g.push([
            y,
            0
          ]), m.push([
            y,
            0
          ])), g.push([
            y,
            D
          ]), m.push([
            y,
            D
          ]), y += v, b = k;
        }), u = this._shadowPolygonPts = g, c = this._shadowPolylinePts = m;
      }
      this._shadowData = s, this._shadowDim = l, this._shadowSize = [
        r[0],
        r[1]
      ];
      var w = this.dataZoomModel;
      function _(C) {
        var T = w.getModel(C ? "selectedDataBackground" : "dataBackground"), k = new tt(), D = new ia({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: T.getModel("areaStyle").getAreaStyle(),
          silent: true,
          z2: -20
        }), R = new oa({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: T.getModel("lineStyle").getLineStyle(),
          silent: true,
          z2: -19
        });
        return k.add(D), k.add(R), k;
      }
      for (var S = 0; S < 3; S++) {
        var I = _(S === 1);
        this._displayables.sliderGroup.add(I), this._displayables.dataShadowSegs.push(I);
      }
    }, e.prototype._prepareDataShadowInfo = function() {
      var t = this.dataZoomModel, r = t.get("showDataShadow");
      if (r !== false) {
        var i, a = this.ecModel;
        return t.eachTargetAxis(function(s, o) {
          var l = t.getAxisProxy(s, o).getTargetSeriesModels();
          P(l, function(u) {
            if (!i && !(r !== true && bt(aIe, u.get("type")) < 0)) {
              var c = a.getComponent(zu(s), o).axis, h = lIe(s), d, f = u.coordinateSystem;
              h != null && f.getOtherAxis && (d = f.getOtherAxis(c).inverse), h = u.getData().mapDimension(h), i = {
                thisAxis: c,
                series: u,
                thisDim: s,
                otherDim: h,
                otherAxisInverse: d
              };
            }
          }, this);
        }, this), i;
      }
    }, e.prototype._renderHandle = function() {
      var t = this.group, r = this._displayables, i = r.handles = [
        null,
        null
      ], a = r.handleLabels = [
        null,
        null
      ], s = this._displayables.sliderGroup, o = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, h = l.get("brushSelect"), d = r.filler = new vy({
        silent: h,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      s.add(d), s.add(new vy({
        silent: true,
        subPixelOptimize: true,
        shape: {
          x: 0,
          y: 0,
          width: o[0],
          height: o[1],
          r: c
        },
        style: {
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: nIe,
          fill: "rgba(0,0,0,0)"
        }
      })), P([
        0,
        1
      ], function(x) {
        var b = l.get("handleIcon");
        !q_[b] && b.indexOf("path://") < 0 && b.indexOf("image://") < 0 && (b = "path://" + b);
        var w = xr(b, -1, 0, 2, 2, null, true);
        w.attr({
          cursor: uG(this._orient),
          draggable: true,
          drift: Ae(this._onDragMove, this, x),
          ondragend: Ae(this._onDragEnd, this),
          onmouseover: Ae(this._showDataInfo, this, true),
          onmouseout: Ae(this._showDataInfo, this, false),
          z2: 5
        });
        var _ = w.getBoundingRect(), S = l.get("handleSize");
        this._handleHeight = _e(S, this._size[1]), this._handleWidth = _.width / _.height * this._handleHeight, w.setStyle(l.getModel("handleStyle").getItemStyle()), w.style.strokeNoScale = true, w.rectHover = true, w.ensureState("emphasis").style = l.getModel([
          "emphasis",
          "handleStyle"
        ]).getItemStyle(), Qh(w);
        var I = l.get("handleColor");
        I != null && (w.style.fill = I), s.add(i[x] = w);
        var C = l.getModel("textStyle"), T = l.get("handleLabel") || {}, k = T.show || false;
        t.add(a[x] = new Gt({
          silent: true,
          invisible: !k,
          style: $n(C, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: C.getTextColor(),
            font: C.getFont()
          }),
          z2: 10
        }));
      }, this);
      var f = d;
      if (h) {
        var p = _e(l.get("moveHandleSize"), o[1]), g = r.moveHandle = new Vt({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: true,
          shape: {
            r: [
              0,
              0,
              2,
              2
            ],
            y: o[1] - 0.5,
            height: p
          }
        }), m = p * 0.8, v = r.moveHandleIcon = xr(l.get("moveHandleIcon"), -m / 2, -m / 2, m, m, "#fff", true);
        v.silent = true, v.y = o[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel([
          "emphasis",
          "moveHandleStyle"
        ]).getItemStyle();
        var y = Math.min(o[1] / 2, Math.max(p, 10));
        f = r.moveZone = new Vt({
          invisible: true,
          shape: {
            y: o[1] - y,
            height: p + y
          }
        }), f.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), s.add(g), s.add(v), s.add(f);
      }
      f.attr({
        draggable: true,
        cursor: uG(this._orient),
        drift: Ae(this._onDragMove, this, "all"),
        ondragstart: Ae(this._showDataInfo, this, true),
        ondragend: Ae(this._onDragEnd, this),
        onmouseover: Ae(this._showDataInfo, this, true),
        onmouseout: Ae(this._showDataInfo, this, false)
      });
    }, e.prototype._resetInterval = function() {
      var t = this._range = this.dataZoomModel.getPercentRange(), r = this._getViewExtent();
      this._handleEnds = [
        sn(t[0], [
          0,
          100
        ], r, true),
        sn(t[1], [
          0,
          100
        ], r, true)
      ];
    }, e.prototype._updateInterval = function(t, r) {
      var i = this.dataZoomModel, a = this._handleEnds, s = this._getViewExtent(), o = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [
        0,
        100
      ];
      Vd(r, a, s, i.get("zoomLock") ? "all" : t, o.minSpan != null ? sn(o.minSpan, l, s, true) : null, o.maxSpan != null ? sn(o.maxSpan, l, s, true) : null);
      var u = this._range, c = this._range = vs([
        sn(a[0], s, l, true),
        sn(a[1], s, l, true)
      ]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, e.prototype._updateView = function(t) {
      var r = this._displayables, i = this._handleEnds, a = vs(i.slice()), s = this._size;
      P([
        0,
        1
      ], function(f) {
        var p = r.handles[f], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          x: i[f] + (f ? -1 : 1),
          y: s[1] / 2 - g / 2
        });
      }, this), r.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: s[1]
      });
      var o = {
        x: a[0],
        width: a[1] - a[0]
      };
      r.moveHandle && (r.moveHandle.setShape(o), r.moveZone.setShape(o), r.moveZone.getBoundingRect(), r.moveHandleIcon && r.moveHandleIcon.attr("x", o.x + o.width / 2));
      for (var l = r.dataShadowSegs, u = [
        0,
        a[0],
        a[1],
        s[0]
      ], c = 0; c < l.length; c++) {
        var h = l[c], d = h.getClipPath();
        d || (d = new Vt(), h.setClipPath(d)), d.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: s[1]
        });
      }
      this._updateDataInfo(t);
    }, e.prototype._updateDataInfo = function(t) {
      var r = this.dataZoomModel, i = this._displayables, a = i.handleLabels, s = this._orient, o = [
        "",
        ""
      ];
      if (r.get("showDetail")) {
        var l = r.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, h = t ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          o = [
            this._formatLabel(h[0], u),
            this._formatLabel(h[1], u)
          ];
        }
      }
      var d = vs(this._handleEnds.slice());
      f.call(this, 0), f.call(this, 1);
      function f(p) {
        var g = Jh(i.handles[p].parent, this.group), m = IC(p === 0 ? "right" : "left", g), v = this._handleWidth / 2 + iIe, y = Zs([
          d[p] + (p === 0 ? -v : v),
          this._size[1] / 2
        ], g);
        a[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: s === yy ? "middle" : m,
          align: s === yy ? m : "center",
          text: o[p]
        });
      }
    }, e.prototype._formatLabel = function(t, r) {
      var i = this.dataZoomModel, a = i.get("labelFormatter"), s = i.get("labelPrecision");
      (s == null || s === "auto") && (s = r.getPixelPrecision());
      var o = t == null || isNaN(t) ? "" : r.type === "category" || r.type === "time" ? r.scale.getLabel({
        value: Math.round(t)
      }) : t.toFixed(Math.min(s, 20));
      return Xe(a) ? a(t, o) : Ie(a) ? a.replace("{value}", o) : o;
    }, e.prototype._showDataInfo = function(t) {
      var r = this.dataZoomModel.get("handleLabel") || {}, i = r.show || false, a = this.dataZoomModel.getModel([
        "emphasis",
        "handleLabel"
      ]), s = a.get("show") || false, o = t || this._dragging ? s : i, l = this._displayables, u = l.handleLabels;
      u[0].attr("invisible", !o), u[1].attr("invisible", !o), l.moveHandle && this.api[o ? "enterEmphasis" : "leaveEmphasis"](l.moveHandle, 1);
    }, e.prototype._onDragMove = function(t, r, i, a) {
      this._dragging = true, Ul(a.event);
      var s = this._displayables.sliderGroup.getLocalTransform(), o = Zs([
        r,
        i
      ], s, true), l = this._updateInterval(t, o[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(true);
    }, e.prototype._onDragEnd = function() {
      this._dragging = false, this._showDataInfo(false);
      var t = this.dataZoomModel.get("realtime");
      !t && this._dispatchZoomAction(false);
    }, e.prototype._onClickPanel = function(t) {
      var r = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
      if (!(i[0] < 0 || i[0] > r[0] || i[1] < 0 || i[1] > r[1])) {
        var a = this._handleEnds, s = (a[0] + a[1]) / 2, o = this._updateInterval("all", i[0] - s);
        this._updateView(), o && this._dispatchZoomAction(false);
      }
    }, e.prototype._onBrushStart = function(t) {
      var r = t.offsetX, i = t.offsetY;
      this._brushStart = new mt(r, i), this._brushing = true, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, e.prototype._onBrushEnd = function(t) {
      if (this._brushing) {
        var r = this._displayables.brushRect;
        if (this._brushing = false, !!r) {
          r.attr("ignore", true);
          var i = r.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var s = this._getViewExtent(), o = [
              0,
              100
            ];
            this._range = vs([
              sn(i.x, s, o, true),
              sn(i.x + i.width, s, o, true)
            ]), this._handleEnds = [
              i.x,
              i.x + i.width
            ], this._updateView(), this._dispatchZoomAction(false);
          }
        }
      }
    }, e.prototype._onBrush = function(t) {
      this._brushing && (Ul(t.event), this._updateBrushRect(t.offsetX, t.offsetY));
    }, e.prototype._updateBrushRect = function(t, r) {
      var i = this._displayables, a = this.dataZoomModel, s = i.brushRect;
      s || (s = i.brushRect = new vy({
        silent: true,
        style: a.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(s)), s.attr("ignore", false);
      var o = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(t, r), c = l.transformCoordToLocal(o.x, o.y), h = this._size;
      u[0] = Math.max(Math.min(h[0], u[0]), 0), s.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: h[1]
      });
    }, e.prototype._dispatchZoomAction = function(t) {
      var r = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: t ? sIe : null,
        start: r[0],
        end: r[1]
      });
    }, e.prototype._findCoordRect = function() {
      var t, r = xK(this.dataZoomModel).infoList;
      if (!t && r.length) {
        var i = r[0].model.coordinateSystem;
        t = i.getRect && i.getRect();
      }
      if (!t) {
        var a = this.api.getWidth(), s = this.api.getHeight();
        t = {
          x: a * 0.2,
          y: s * 0.2,
          width: a * 0.6,
          height: s * 0.6
        };
      }
      return t;
    }, e.type = "dataZoom.slider", e;
  }(CM);
  function lIe(n) {
    var e = {
      x: "y",
      y: "x",
      radius: "angle",
      angle: "radius"
    };
    return e[n];
  }
  function uG(n) {
    return n === "vertical" ? "ns-resize" : "ew-resize";
  }
  function BK(n) {
    n.registerComponentModel(tIe), n.registerComponentView(oIe), IM(n);
  }
  function uIe(n) {
    Ct(OK), Ct(BK);
  }
  var zK = {
    get: function(n, e, t) {
      var r = Qe((cIe[n] || {})[e]);
      return t && de(r) ? r[r.length - 1] : r;
    }
  }, cIe = {
    color: {
      active: [
        "#006edd",
        "#e0ffff"
      ],
      inactive: [
        "rgba(0,0,0,0)"
      ]
    },
    colorHue: {
      active: [
        0,
        360
      ],
      inactive: [
        0,
        0
      ]
    },
    colorSaturation: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    colorLightness: {
      active: [
        0.9,
        0.5
      ],
      inactive: [
        0,
        0
      ]
    },
    colorAlpha: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    opacity: {
      active: [
        0.3,
        1
      ],
      inactive: [
        0,
        0
      ]
    },
    symbol: {
      active: [
        "circle",
        "roundRect",
        "diamond"
      ],
      inactive: [
        "none"
      ]
    },
    symbolSize: {
      active: [
        10,
        50
      ],
      inactive: [
        0,
        0
      ]
    }
  }, cG = Gr.mapVisual, hIe = Gr.eachVisual, dIe = de, hG = P, fIe = vs, pIe = sn, yS = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.stateList = [
        "inRange",
        "outOfRange"
      ], t.replacableOptionKeys = [
        "inRange",
        "outOfRange",
        "target",
        "controller",
        "color"
      ], t.layoutMode = {
        type: "box",
        ignoreSize: true
      }, t.dataBound = [
        -1 / 0,
        1 / 0
      ], t.targetVisuals = {}, t.controllerVisuals = {}, t;
    }
    return e.prototype.init = function(t, r, i) {
      this.mergeDefaultAndTheme(t, i);
    }, e.prototype.optionUpdated = function(t, r) {
      var i = this.option;
      !r && DK(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, e.prototype.resetVisual = function(t) {
      var r = this.stateList;
      t = Ae(t, this), this.controllerVisuals = HR(this.option.controller, r, t), this.targetVisuals = HR(this.option.target, r, t);
    }, e.prototype.getItemSymbol = function() {
      return null;
    }, e.prototype.getTargetSeriesIndices = function() {
      var t = this.option.seriesIndex, r = [];
      return t == null || t === "all" ? this.ecModel.eachSeries(function(i, a) {
        r.push(a);
      }) : r = xn(t), r;
    }, e.prototype.eachTargetSeries = function(t, r) {
      P(this.getTargetSeriesIndices(), function(i) {
        var a = this.ecModel.getSeriesByIndex(i);
        a && t.call(r, a);
      }, this);
    }, e.prototype.isTargetSeries = function(t) {
      var r = false;
      return this.eachTargetSeries(function(i) {
        i === t && (r = true);
      }), r;
    }, e.prototype.formatValueText = function(t, r, i) {
      var a = this.option, s = a.precision, o = this.dataBound, l = a.formatter, u;
      i = i || [
        "<",
        ">"
      ], de(t) && (t = t.slice(), u = true);
      var c = r ? t : u ? [
        h(t[0]),
        h(t[1])
      ] : h(t);
      if (Ie(l)) return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (Xe(l)) return u ? l(t[0], t[1]) : l(t);
      if (u) return t[0] === o[0] ? i[0] + " " + c[1] : t[1] === o[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function h(d) {
        return d === o[0] ? "min" : d === o[1] ? "max" : (+d).toFixed(Math.min(s, 20));
      }
    }, e.prototype.resetExtent = function() {
      var t = this.option, r = fIe([
        t.min,
        t.max
      ]);
      this._dataExtent = r;
    }, e.prototype.getDataDimensionIndex = function(t) {
      var r = this.option.dimension;
      if (r != null) return t.getDimensionIndex(r);
      for (var i = t.dimensions, a = i.length - 1; a >= 0; a--) {
        var s = i[a], o = t.getDimensionInfo(s);
        if (!o.isCalculationCoord) return o.storeDimIndex;
      }
    }, e.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, e.prototype.completeVisualOption = function() {
      var t = this.ecModel, r = this.option, i = {
        inRange: r.inRange,
        outOfRange: r.outOfRange
      }, a = r.target || (r.target = {}), s = r.controller || (r.controller = {});
      pt(a, i), pt(s, i);
      var o = this.isCategory();
      l.call(this, a), l.call(this, s), u.call(this, a, "inRange", "outOfRange"), c.call(this, s);
      function l(h) {
        dIe(r.color) && !h.inRange && (h.inRange = {
          color: r.color.slice().reverse()
        }), h.inRange = h.inRange || {
          color: t.get("gradientColor")
        };
      }
      function u(h, d, f) {
        var p = h[d], g = h[f];
        p && !g && (g = h[f] = {}, hG(p, function(m, v) {
          if (Gr.isValidType(v)) {
            var y = zK.get(v, "inactive", o);
            y != null && (g[v] = y, v === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [
              0,
              0
            ]));
          }
        }));
      }
      function c(h) {
        var d = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol, f = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), m = g || "roundRect";
        hG(this.stateList, function(v) {
          var y = this.itemSize, x = h[v];
          x || (x = h[v] = {
            color: o ? p : [
              p
            ]
          }), x.symbol == null && (x.symbol = d && Qe(d) || (o ? m : [
            m
          ])), x.symbolSize == null && (x.symbolSize = f && Qe(f) || (o ? y[0] : [
            y[0],
            y[0]
          ])), x.symbol = cG(x.symbol, function(_) {
            return _ === "none" ? m : _;
          });
          var b = x.symbolSize;
          if (b != null) {
            var w = -1 / 0;
            hIe(b, function(_) {
              _ > w && (w = _);
            }), x.symbolSize = cG(b, function(_) {
              return pIe(_, [
                0,
                w
              ], [
                0,
                y[0]
              ], true);
            });
          }
        }, this);
      }
    }, e.prototype.resetItemSize = function() {
      this.itemSize = [
        parseFloat(this.get("itemWidth")),
        parseFloat(this.get("itemHeight"))
      ];
    }, e.prototype.isCategory = function() {
      return !!this.option.categories;
    }, e.prototype.setSelected = function(t) {
    }, e.prototype.getSelected = function() {
      return null;
    }, e.prototype.getValueState = function(t) {
      return null;
    }, e.prototype.getVisualMeta = function(t) {
      return null;
    }, e.type = "visualMap", e.dependencies = [
      "series"
    ], e.defaultOption = {
      show: true,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: false,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
      }
    }, e;
  }(Et), dG = [
    20,
    140
  ], gIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, e.prototype.resetItemSize = function() {
      n.prototype.resetItemSize.apply(this, arguments);
      var t = this.itemSize;
      (t[0] == null || isNaN(t[0])) && (t[0] = dG[0]), (t[1] == null || isNaN(t[1])) && (t[1] = dG[1]);
    }, e.prototype._resetRange = function() {
      var t = this.getExtent(), r = this.option.range;
      !r || r.auto ? (t.auto = 1, this.option.range = t) : de(r) && (r[0] > r[1] && r.reverse(), r[0] = Math.max(r[0], t[0]), r[1] = Math.min(r[1], t[1]));
    }, e.prototype.completeVisualOption = function() {
      n.prototype.completeVisualOption.apply(this, arguments), P(this.stateList, function(t) {
        var r = this.option.controller[t].symbolSize;
        r && r[0] !== r[1] && (r[0] = r[1] / 3);
      }, this);
    }, e.prototype.setSelected = function(t) {
      this.option.range = t.slice(), this._resetRange();
    }, e.prototype.getSelected = function() {
      var t = this.getExtent(), r = vs((this.get("range") || []).slice());
      return r[0] > t[1] && (r[0] = t[1]), r[1] > t[1] && (r[1] = t[1]), r[0] < t[0] && (r[0] = t[0]), r[1] < t[0] && (r[1] = t[0]), r;
    }, e.prototype.getValueState = function(t) {
      var r = this.option.range, i = this.getExtent();
      return (r[0] <= i[0] || r[0] <= t) && (r[1] >= i[1] || t <= r[1]) ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var r = [];
      return this.eachTargetSeries(function(i) {
        var a = [], s = i.getData();
        s.each(this.getDataDimensionIndex(s), function(o, l) {
          t[0] <= o && o <= t[1] && a.push(l);
        }, this), r.push({
          seriesId: i.id,
          dataIndex: a
        });
      }, this), r;
    }, e.prototype.getVisualMeta = function(t) {
      var r = fG(this, "outOfRange", this.getExtent()), i = fG(this, "inRange", this.option.range.slice()), a = [];
      function s(f, p) {
        a.push({
          value: f,
          color: t(f, p)
        });
      }
      for (var o = 0, l = 0, u = i.length, c = r.length; l < c && (!i.length || r[l] <= i[0]); l++) r[l] < i[o] && s(r[l], "outOfRange");
      for (var h = 1; o < u; o++, h = 0) h && a.length && s(i[o], "outOfRange"), s(i[o], "inRange");
      for (var h = 1; l < c; l++) (!i.length || i[i.length - 1] < r[l]) && (h && (a.length && s(a[a.length - 1].value, "outOfRange"), h = 0), s(r[l], "outOfRange"));
      var d = a.length;
      return {
        stops: a,
        outerColors: [
          d ? a[0].color : "transparent",
          d ? a[d - 1].color : "transparent"
        ]
      };
    }, e.type = "visualMap.continuous", e.defaultOption = mc(yS.defaultOption, {
      align: "auto",
      calculable: false,
      hoverLink: true,
      realtime: true,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
    }), e;
  }(yS);
  function fG(n, e, t) {
    if (t[0] === t[1]) return t.slice();
    for (var r = 200, i = (t[1] - t[0]) / r, a = t[0], s = [], o = 0; o <= r && a < t[1]; o++) s.push(a), a += i;
    return s.push(t[1]), s;
  }
  var VK = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, t;
    }
    return e.prototype.init = function(t, r) {
      this.ecModel = t, this.api = r;
    }, e.prototype.render = function(t, r, i, a) {
      if (this.visualMapModel = t, t.get("show") === false) {
        this.group.removeAll();
        return;
      }
      this.doRender(t, r, i, a);
    }, e.prototype.renderBackground = function(t) {
      var r = this.visualMapModel, i = xm(r.get("padding") || 0), a = t.getBoundingRect();
      t.add(new Vt({
        z2: -1,
        silent: true,
        shape: {
          x: a.x - i[3],
          y: a.y - i[0],
          width: a.width + i[3] + i[1],
          height: a.height + i[0] + i[2]
        },
        style: {
          fill: r.get("backgroundColor"),
          stroke: r.get("borderColor"),
          lineWidth: r.get("borderWidth")
        }
      }));
    }, e.prototype.getControllerVisual = function(t, r, i) {
      i = i || {};
      var a = i.forceState, s = this.visualMapModel, o = {};
      if (r === "color") {
        var l = s.get("contentColor");
        o.color = l;
      }
      function u(f) {
        return o[f];
      }
      function c(f, p) {
        o[f] = p;
      }
      var h = s.controllerVisuals[a || s.getValueState(t)], d = Gr.prepareVisualTypes(h);
      return P(d, function(f) {
        var p = h[f];
        i.convertOpacityToAlpha && f === "opacity" && (f = "colorAlpha", p = h.__alphaForOpacity), Gr.dependsOn(f, r) && p && p.applyVisual(t, u, c);
      }), o[r];
    }, e.prototype.positionGroup = function(t) {
      var r = this.visualMapModel, i = this.api;
      NC(t, r.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, e.prototype.doRender = function(t, r, i, a) {
    }, e.type = "visualMap", e;
  }(Yn), pG = [
    [
      "left",
      "right",
      "width"
    ],
    [
      "top",
      "bottom",
      "height"
    ]
  ];
  function WK(n, e, t) {
    var r = n.option, i = r.align;
    if (i != null && i !== "auto") return i;
    for (var a = {
      width: e.getWidth(),
      height: e.getHeight()
    }, s = r.orient === "horizontal" ? 1 : 0, o = pG[s], l = [
      0,
      null,
      10
    ], u = {}, c = 0; c < 3; c++) u[pG[1 - s][c]] = l[c], u[o[c]] = c === 2 ? t[0] : r[o[c]];
    var h = [
      [
        "x",
        "width",
        3
      ],
      [
        "y",
        "height",
        0
      ]
    ][s], d = Er(u, a, r.padding);
    return o[(d.margin[h[2]] || 0) + d[h[0]] + d[h[1]] * 0.5 < a[h[1]] * 0.5 ? 0 : 1];
  }
  function p_(n, e) {
    return P(n || [], function(t) {
      t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "");
    }), n;
  }
  var ko = sn, mIe = P, gG = Math.min, YT = Math.max, vIe = 12, yIe = 6, xIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t;
    }
    return e.prototype.init = function(t, r) {
      n.prototype.init.call(this, t, r), this._hoverLinkFromSeriesMouseOver = Ae(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = Ae(this._hideIndicator, this);
    }, e.prototype.doRender = function(t, r, i, a) {
      (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, e.prototype._buildView = function() {
      this.group.removeAll();
      var t = this.visualMapModel, r = this.group;
      this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(r);
      var i = t.get("text");
      this._renderEndsText(r, i, 0), this._renderEndsText(r, i, 1), this._updateView(true), this.renderBackground(r), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(r);
    }, e.prototype._renderEndsText = function(t, r, i) {
      if (r) {
        var a = r[1 - i];
        a = a != null ? a + "" : "";
        var s = this.visualMapModel, o = s.get("textGap"), l = s.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([
          l[0] / 2,
          i === 0 ? -o : l[1] + o
        ], u), h = this._applyTransform(i === 0 ? "bottom" : "top", u), d = this._orient, f = this.visualMapModel.textStyleModel;
        this.group.add(new Gt({
          style: $n(f, {
            x: c[0],
            y: c[1],
            verticalAlign: d === "horizontal" ? "middle" : h,
            align: d === "horizontal" ? h : "center",
            text: a
          })
        }));
      }
    }, e.prototype._renderBar = function(t) {
      var r = this.visualMapModel, i = this._shapes, a = r.itemSize, s = this._orient, o = this._useHandle, l = WK(r, this.api, a), u = i.mainGroup = this._createBarGroup(l), c = new tt();
      u.add(c), c.add(i.outOfRange = mG()), c.add(i.inRange = mG(null, o ? yG(this._orient) : null, Ae(this._dragHandle, this, "all", false), Ae(this._dragHandle, this, "all", true))), c.setClipPath(new Vt({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var h = r.textStyleModel.getTextRect("\u56FD"), d = YT(h.width, h.height);
      o && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(r, u, 0, a, d, s), this._createHandle(r, u, 1, a, d, s)), this._createIndicator(r, u, a, d, s), t.add(u);
    }, e.prototype._createHandle = function(t, r, i, a, s, o) {
      var l = Ae(this._dragHandle, this, i, false), u = Ae(this._dragHandle, this, i, true), c = no(t.get("handleSize"), a[0]), h = xr(t.get("handleIcon"), -c / 2, -c / 2, c, c, null, true), d = yG(this._orient);
      h.attr({
        cursor: d,
        draggable: true,
        drift: l,
        ondragend: u,
        onmousemove: function(v) {
          Ul(v.event);
        }
      }), h.x = a[0] / 2, h.useStyle(t.getModel("handleStyle").getItemStyle()), h.setStyle({
        strokeNoScale: true,
        strokeFirst: true
      }), h.style.lineWidth *= 2, h.ensureState("emphasis").style = t.getModel([
        "emphasis",
        "handleStyle"
      ]).getItemStyle(), Fh(h, true), r.add(h);
      var f = this.visualMapModel.textStyleModel, p = new Gt({
        cursor: d,
        draggable: true,
        drift: l,
        onmousemove: function(v) {
          Ul(v.event);
        },
        ondragend: u,
        style: $n(f, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [
        c,
        0
      ], m = this._shapes;
      m.handleThumbs[i] = h, m.handleLabelPoints[i] = g, m.handleLabels[i] = p;
    }, e.prototype._createIndicator = function(t, r, i, a, s) {
      var o = no(t.get("indicatorSize"), i[0]), l = xr(t.get("indicatorIcon"), -o / 2, -o / 2, o, o, null, true);
      l.attr({
        cursor: "move",
        invisible: true,
        silent: true,
        x: i[0] / 2
      });
      var u = t.getModel("indicatorStyle").getItemStyle();
      if (l instanceof oi) {
        var c = l.style;
        l.useStyle(oe({
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else l.useStyle(u);
      r.add(l);
      var h = this.visualMapModel.textStyleModel, d = new Gt({
        silent: true,
        invisible: true,
        style: $n(h, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(d);
      var f = [
        (s === "horizontal" ? a / 2 : yIe) + i[0] / 2,
        0
      ], p = this._shapes;
      p.indicator = l, p.indicatorLabel = d, p.indicatorLabelPoint = f, this._firstShowIndicator = true;
    }, e.prototype._dragHandle = function(t, r, i, a) {
      if (this._useHandle) {
        if (this._dragging = !r, !r) {
          var s = this._applyTransform([
            i,
            a
          ], this._shapes.mainGroup, true);
          this._updateInterval(t, s[1]), this._hideIndicator(), this._updateView();
        }
        r === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), r ? !this._hovering && this._clearHoverLinkToSeries() : vG(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], false);
      }
    }, e.prototype._resetInterval = function() {
      var t = this.visualMapModel, r = this._dataInterval = t.getSelected(), i = t.getExtent(), a = [
        0,
        t.itemSize[1]
      ];
      this._handleEnds = [
        ko(r[0], i, a, true),
        ko(r[1], i, a, true)
      ];
    }, e.prototype._updateInterval = function(t, r) {
      r = r || 0;
      var i = this.visualMapModel, a = this._handleEnds, s = [
        0,
        i.itemSize[1]
      ];
      Vd(r, a, s, t, 0);
      var o = i.getExtent();
      this._dataInterval = [
        ko(a[0], s, o, true),
        ko(a[1], s, o, true)
      ];
    }, e.prototype._updateView = function(t) {
      var r = this.visualMapModel, i = r.getExtent(), a = this._shapes, s = [
        0,
        r.itemSize[1]
      ], o = t ? s : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, o, "inRange"), u = this._createBarVisual(i, i, s, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
      }).setShape("points", u.barPoints), this._updateHandle(o, l);
    }, e.prototype._createBarVisual = function(t, r, i, a) {
      var s = {
        forceState: a,
        convertOpacityToAlpha: true
      }, o = this._makeColorGradient(t, s), l = [
        this.getControllerVisual(t[0], "symbolSize", s),
        this.getControllerVisual(t[1], "symbolSize", s)
      ], u = this._createBarPoints(i, l);
      return {
        barColor: new Px(0, 0, 0, 1, o),
        barPoints: u,
        handlesColor: [
          o[0].color,
          o[o.length - 1].color
        ]
      };
    }, e.prototype._makeColorGradient = function(t, r) {
      var i = 100, a = [], s = (t[1] - t[0]) / i;
      a.push({
        color: this.getControllerVisual(t[0], "color", r),
        offset: 0
      });
      for (var o = 1; o < i; o++) {
        var l = t[0] + s * o;
        if (l > t[1]) break;
        a.push({
          color: this.getControllerVisual(l, "color", r),
          offset: o / i
        });
      }
      return a.push({
        color: this.getControllerVisual(t[1], "color", r),
        offset: 1
      }), a;
    }, e.prototype._createBarPoints = function(t, r) {
      var i = this.visualMapModel.itemSize;
      return [
        [
          i[0] - r[0],
          t[0]
        ],
        [
          i[0],
          t[0]
        ],
        [
          i[0],
          t[1]
        ],
        [
          i[0] - r[1],
          t[1]
        ]
      ];
    }, e.prototype._createBarGroup = function(t) {
      var r = this._orient, i = this.visualMapModel.get("inverse");
      return new tt(r === "horizontal" && !i ? {
        scaleX: t === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : r === "horizontal" && i ? {
        scaleX: t === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : r === "vertical" && !i ? {
        scaleX: t === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: t === "left" ? 1 : -1
      });
    }, e.prototype._updateHandle = function(t, r) {
      if (this._useHandle) {
        var i = this._shapes, a = this.visualMapModel, s = i.handleThumbs, o = i.handleLabels, l = a.itemSize, u = a.getExtent(), c = this._applyTransform("left", i.mainGroup);
        mIe([
          0,
          1
        ], function(h) {
          var d = s[h];
          d.setStyle("fill", r.handlesColor[h]), d.y = t[h];
          var f = ko(t[h], [
            0,
            l[1]
          ], u, true), p = this.getControllerVisual(f, "symbolSize");
          d.scaleX = d.scaleY = p / l[0], d.x = l[0] - p / 2;
          var g = Zs(i.handleLabelPoints[h], Jh(d, this.group));
          if (this._orient === "horizontal") {
            var m = c === "left" || c === "top" ? (l[0] - p) / 2 : (l[0] - p) / -2;
            g[1] += m;
          }
          o[h].setStyle({
            x: g[0],
            y: g[1],
            text: a.formatValueText(this._dataInterval[h]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, e.prototype._showIndicator = function(t, r, i, a) {
      var s = this.visualMapModel, o = s.getExtent(), l = s.itemSize, u = [
        0,
        l[1]
      ], c = this._shapes, h = c.indicator;
      if (h) {
        h.attr("invisible", false);
        var d = {
          convertOpacityToAlpha: true
        }, f = this.getControllerVisual(t, "color", d), p = this.getControllerVisual(t, "symbolSize"), g = ko(t, o, u, true), m = l[0] - p / 2, v = {
          x: h.x,
          y: h.y
        };
        h.y = g, h.x = m;
        var y = Zs(c.indicatorLabelPoint, Jh(h, this.group)), x = c.indicatorLabel;
        x.attr("invisible", false);
        var b = this._applyTransform("left", c.mainGroup), w = this._orient, _ = w === "horizontal";
        x.setStyle({
          text: (i || "") + s.formatValueText(r),
          verticalAlign: _ ? b : "middle",
          align: _ ? "center" : b
        });
        var S = {
          x: m,
          y: g,
          style: {
            fill: f
          }
        }, I = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (s.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var C = {
            duration: 100,
            easing: "cubicInOut",
            additive: true
          };
          h.x = v.x, h.y = v.y, h.animateTo(S, C), x.animateTo(I, C);
        } else h.attr(S), x.attr(I);
        this._firstShowIndicator = false;
        var T = this._shapes.handleLabels;
        if (T) for (var k = 0; k < T.length; k++) this.api.enterBlur(T[k]);
      }
    }, e.prototype._enableHoverLinkToSeries = function() {
      var t = this;
      this._shapes.mainGroup.on("mousemove", function(r) {
        if (t._hovering = true, !t._dragging) {
          var i = t.visualMapModel.itemSize, a = t._applyTransform([
            r.offsetX,
            r.offsetY
          ], t._shapes.mainGroup, true, true);
          a[1] = gG(YT(0, a[1]), i[1]), t._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]);
        }
      }).on("mouseout", function() {
        t._hovering = false, !t._dragging && t._clearHoverLinkToSeries();
      });
    }, e.prototype._enableHoverLinkFromSeries = function() {
      var t = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, e.prototype._doHoverLinkToSeries = function(t, r) {
      var i = this.visualMapModel, a = i.itemSize;
      if (i.option.hoverLink) {
        var s = [
          0,
          a[1]
        ], o = i.getExtent();
        t = gG(YT(s[0], t), s[1]);
        var l = bIe(i, o, s), u = [
          t - l,
          t + l
        ], c = ko(t, s, o, true), h = [
          ko(u[0], s, o, true),
          ko(u[1], s, o, true)
        ];
        u[0] < s[0] && (h[0] = -1 / 0), u[1] > s[1] && (h[1] = 1 / 0), r && (h[0] === -1 / 0 ? this._showIndicator(c, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, "\u2248 ", l));
        var d = this._hoverLinkDataIndices, f = [];
        (r || vG(i)) && (f = this._hoverLinkDataIndices = i.findTargetDataIndices(h));
        var p = kle(d, f);
        this._dispatchHighDown("downplay", p_(p[0], i)), this._dispatchHighDown("highlight", p_(p[1], i));
      }
    }, e.prototype._hoverLinkFromSeriesMouseOver = function(t) {
      var r;
      if (Bh(t.target, function(l) {
        var u = rt(l);
        if (u.dataIndex != null) return r = u, true;
      }, true), !!r) {
        var i = this.ecModel.getSeriesByIndex(r.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(i)) {
          var s = i.getData(r.dataType), o = s.getStore().get(a.getDataDimensionIndex(s), r.dataIndex);
          isNaN(o) || this._showIndicator(o, o);
        }
      }
    }, e.prototype._hideIndicator = function() {
      var t = this._shapes;
      t.indicator && t.indicator.attr("invisible", true), t.indicatorLabel && t.indicatorLabel.attr("invisible", true);
      var r = this._shapes.handleLabels;
      if (r) for (var i = 0; i < r.length; i++) this.api.leaveBlur(r[i]);
    }, e.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var t = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", p_(t, this.visualMapModel)), t.length = 0;
    }, e.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var t = this.api.getZr();
      t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
    }, e.prototype._applyTransform = function(t, r, i, a) {
      var s = Jh(r, a ? null : this.group);
      return de(t) ? Zs(t, s, i) : IC(t, s, i);
    }, e.prototype._dispatchHighDown = function(t, r) {
      r && r.length && this.api.dispatchAction({
        type: t,
        batch: r
      });
    }, e.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.type = "visualMap.continuous", e;
  }(VK);
  function mG(n, e, t, r) {
    return new ia({
      shape: {
        points: n
      },
      draggable: !!t,
      cursor: e,
      drift: t,
      onmousemove: function(i) {
        Ul(i.event);
      },
      ondragend: r
    });
  }
  function bIe(n, e, t) {
    var r = vIe / 2, i = n.get("hoverLinkDataSize");
    return i && (r = ko(i, e, t, true) / 2), r;
  }
  function vG(n) {
    var e = n.get("hoverLinkOnHandle");
    return !!(e ?? n.get("realtime"));
  }
  function yG(n) {
    return n === "vertical" ? "ns-resize" : "ew-resize";
  }
  var wIe = {
    type: "selectDataRange",
    event: "dataRangeSelected",
    update: "update"
  }, _Ie = function(n, e) {
    e.eachComponent({
      mainType: "visualMap",
      query: n
    }, function(t) {
      t.setSelected(n.selected);
    });
  }, SIe = [
    {
      createOnAllSeries: true,
      reset: function(n, e) {
        var t = [];
        return e.eachComponent("visualMap", function(r) {
          var i = n.pipelineContext;
          !r.isTargetSeries(n) || i && i.large || t.push(HSe(r.stateList, r.targetVisuals, Ae(r.getValueState, r), r.getDataDimensionIndex(n.getData())));
        }), t;
      }
    },
    {
      createOnAllSeries: true,
      reset: function(n, e) {
        var t = n.getData(), r = [];
        e.eachComponent("visualMap", function(i) {
          if (i.isTargetSeries(n)) {
            var a = i.getVisualMeta(Ae(CIe, null, n, i)) || {
              stops: [],
              outerColors: []
            }, s = i.getDataDimensionIndex(t);
            s >= 0 && (a.dimension = s, r.push(a));
          }
        }), n.getData().setVisual("visualMeta", r);
      }
    }
  ];
  function CIe(n, e, t, r) {
    for (var i = e.targetVisuals[r], a = Gr.prepareVisualTypes(i), s = {
      color: Bx(n.getData(), "color")
    }, o = 0, l = a.length; o < l; o++) {
      var u = a[o], c = i[u === "opacity" ? "__alphaForOpacity" : u];
      c && c.applyVisual(t, h, d);
    }
    return s.color;
    function h(f) {
      return s[f];
    }
    function d(f, p) {
      s[f] = p;
    }
  }
  var xG = P;
  function IIe(n) {
    var e = n && n.visualMap;
    de(e) || (e = e ? [
      e
    ] : []), xG(e, function(t) {
      if (t) {
        Gp(t, "splitList") && !Gp(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
        var r = t.pieces;
        r && de(r) && xG(r, function(i) {
          Ze(i) && (Gp(i, "start") && !Gp(i, "min") && (i.min = i.start), Gp(i, "end") && !Gp(i, "max") && (i.max = i.end));
        });
      }
    });
  }
  function Gp(n, e) {
    return n && n.hasOwnProperty && n.hasOwnProperty(e);
  }
  var bG = false;
  function GK(n) {
    bG || (bG = true, n.registerSubTypeDefaulter("visualMap", function(e) {
      return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise";
    }), n.registerAction(wIe, _Ie), P(SIe, function(e) {
      n.registerVisual(n.PRIORITY.VISUAL.COMPONENT, e);
    }), n.registerPreprocessor(IIe));
  }
  function UK(n) {
    n.registerComponentModel(gIe), n.registerComponentView(xIe), GK(n);
  }
  var kIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t._pieceList = [], t;
    }
    return e.prototype.optionUpdated = function(t, r) {
      n.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], TIe[this._mode].call(this, this._pieceList), this._resetSelected(t, r);
      var a = this.option.categories;
      this.resetVisual(function(s, o) {
        i === "categories" ? (s.mappingMethod = "category", s.categories = Qe(a)) : (s.dataExtent = this.getExtent(), s.mappingMethod = "piecewise", s.pieceList = me(this._pieceList, function(l) {
          return l = Qe(l), o !== "inRange" && (l.visual = null), l;
        }));
      });
    }, e.prototype.completeVisualOption = function() {
      var t = this.option, r = {}, i = Gr.listVisualTypes(), a = this.isCategory();
      P(t.pieces, function(o) {
        P(i, function(l) {
          o.hasOwnProperty(l) && (r[l] = 1);
        });
      }), P(r, function(o, l) {
        var u = false;
        P(this.stateList, function(c) {
          u = u || s(t, c, l) || s(t.target, c, l);
        }, this), !u && P(this.stateList, function(c) {
          (t[c] || (t[c] = {}))[l] = zK.get(l, c === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function s(o, l, u) {
        return o && o[l] && o[l].hasOwnProperty(u);
      }
      n.prototype.completeVisualOption.apply(this, arguments);
    }, e.prototype._resetSelected = function(t, r) {
      var i = this.option, a = this._pieceList, s = (r ? i : t).selected || {};
      if (i.selected = s, P(a, function(l, u) {
        var c = this.getSelectedMapKey(l);
        s.hasOwnProperty(c) || (s[c] = true);
      }, this), i.selectedMode === "single") {
        var o = false;
        P(a, function(l, u) {
          var c = this.getSelectedMapKey(l);
          s[c] && (o ? s[c] = false : o = true);
        }, this);
      }
    }, e.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, e.prototype.getSelectedMapKey = function(t) {
      return this._mode === "categories" ? t.value + "" : t.index + "";
    }, e.prototype.getPieceList = function() {
      return this._pieceList;
    }, e.prototype._determineMode = function() {
      var t = this.option;
      return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, e.prototype.setSelected = function(t) {
      this.option.selected = Qe(t);
    }, e.prototype.getValueState = function(t) {
      var r = Gr.findPieceIndex(t, this._pieceList);
      return r != null && this.option.selected[this.getSelectedMapKey(this._pieceList[r])] ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var r = [], i = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var s = [], o = a.getData();
        o.each(this.getDataDimensionIndex(o), function(l, u) {
          var c = Gr.findPieceIndex(l, i);
          c === t && s.push(u);
        }, this), r.push({
          seriesId: a.id,
          dataIndex: s
        });
      }, this), r;
    }, e.prototype.getRepresentValue = function(t) {
      var r;
      if (this.isCategory()) r = t.value;
      else if (t.value != null) r = t.value;
      else {
        var i = t.interval || [];
        r = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return r;
    }, e.prototype.getVisualMeta = function(t) {
      if (this.isCategory()) return;
      var r = [], i = [
        "",
        ""
      ], a = this;
      function s(c, h) {
        var d = a.getRepresentValue({
          interval: c
        });
        h || (h = a.getValueState(d));
        var f = t(d, h);
        c[0] === -1 / 0 ? i[0] = f : c[1] === 1 / 0 ? i[1] = f : r.push({
          value: c[0],
          color: f
        }, {
          value: c[1],
          color: f
        });
      }
      var o = this._pieceList.slice();
      if (!o.length) o.push({
        interval: [
          -1 / 0,
          1 / 0
        ]
      });
      else {
        var l = o[0].interval[0];
        l !== -1 / 0 && o.unshift({
          interval: [
            -1 / 0,
            l
          ]
        }), l = o[o.length - 1].interval[1], l !== 1 / 0 && o.push({
          interval: [
            l,
            1 / 0
          ]
        });
      }
      var u = -1 / 0;
      return P(o, function(c) {
        var h = c.interval;
        h && (h[0] > u && s([
          u,
          h[0]
        ], "outOfRange"), s(h.slice()), u = h[1]);
      }, this), {
        stops: r,
        outerColors: i
      };
    }, e.type = "visualMap.piecewise", e.defaultOption = mc(yS.defaultOption, {
      selected: null,
      minOpen: false,
      maxOpen: false,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: true
    }), e;
  }(yS), TIe = {
    splitNumber: function(n) {
      var e = this.option, t = Math.min(e.precision, 20), r = this.getExtent(), i = e.splitNumber;
      i = Math.max(parseInt(i, 10), 1), e.splitNumber = i;
      for (var a = (r[1] - r[0]) / i; +a.toFixed(t) !== a && t < 5; ) t++;
      e.precision = t, a = +a.toFixed(t), e.minOpen && n.push({
        interval: [
          -1 / 0,
          r[0]
        ],
        close: [
          0,
          0
        ]
      });
      for (var s = 0, o = r[0]; s < i; o += a, s++) {
        var l = s === i - 1 ? r[1] : o + a;
        n.push({
          interval: [
            o,
            l
          ],
          close: [
            1,
            1
          ]
        });
      }
      e.maxOpen && n.push({
        interval: [
          r[1],
          1 / 0
        ],
        close: [
          0,
          0
        ]
      }), pF(n), P(n, function(u, c) {
        u.index = c, u.text = this.formatValueText(u.interval);
      }, this);
    },
    categories: function(n) {
      var e = this.option;
      P(e.categories, function(t) {
        n.push({
          text: this.formatValueText(t, true),
          value: t
        });
      }, this), wG(e, n);
    },
    pieces: function(n) {
      var e = this.option;
      P(e.pieces, function(t, r) {
        Ze(t) || (t = {
          value: t
        });
        var i = {
          text: "",
          index: r
        };
        if (t.label != null && (i.text = t.label), t.hasOwnProperty("value")) {
          var a = i.value = t.value;
          i.interval = [
            a,
            a
          ], i.close = [
            1,
            1
          ];
        } else {
          for (var s = i.interval = [], o = i.close = [
            0,
            0
          ], l = [
            1,
            0,
            1
          ], u = [
            -1 / 0,
            1 / 0
          ], c = [], h = 0; h < 2; h++) {
            for (var d = [
              [
                "gte",
                "gt",
                "min"
              ],
              [
                "lte",
                "lt",
                "max"
              ]
            ][h], f = 0; f < 3 && s[h] == null; f++) s[h] = t[d[f]], o[h] = l[f], c[h] = f === 2;
            s[h] == null && (s[h] = u[h]);
          }
          c[0] && s[1] === 1 / 0 && (o[0] = 0), c[1] && s[0] === -1 / 0 && (o[1] = 0), s[0] === s[1] && o[0] && o[1] && (i.value = s[0]);
        }
        i.visual = Gr.retrieveVisuals(t), n.push(i);
      }, this), wG(e, n), pF(n), P(n, function(t) {
        var r = t.close, i = [
          [
            "<",
            "\u2264"
          ][r[1]],
          [
            ">",
            "\u2265"
          ][r[0]]
        ];
        t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, false, i);
      }, this);
    }
  };
  function wG(n, e) {
    var t = n.inverse;
    (n.orient === "vertical" ? !t : t) && e.reverse();
  }
  var AIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.doRender = function() {
      var t = this.group;
      t.removeAll();
      var r = this.visualMapModel, i = r.get("textGap"), a = r.textStyleModel, s = a.getFont(), o = a.getTextColor(), l = this._getItemAlign(), u = r.itemSize, c = this._getViewData(), h = c.endsText, d = ni(r.get("showLabel", true), !h), f = !r.get("selectedMode");
      h && this._renderEndsText(t, h[0], u, d, l), P(c.viewPieceList, function(p) {
        var g = p.piece, m = new tt();
        m.onclick = Ae(this._onItemClick, this, g), this._enableHoverLink(m, p.indexInModelPieceList);
        var v = r.getRepresentValue(g);
        if (this._createItemSymbol(m, v, [
          0,
          0,
          u[0],
          u[1]
        ], f), d) {
          var y = this.visualMapModel.getValueState(v);
          m.add(new Gt({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: g.text,
              verticalAlign: "middle",
              align: l,
              font: s,
              fill: o,
              opacity: y === "outOfRange" ? 0.5 : 1
            },
            silent: f
          }));
        }
        t.add(m);
      }, this), h && this._renderEndsText(t, h[1], u, d, l), ed(r.get("orient"), t, r.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
    }, e.prototype._enableHoverLink = function(t, r) {
      var i = this;
      t.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(s) {
        var o = i.visualMapModel;
        o.option.hoverLink && i.api.dispatchAction({
          type: s,
          batch: p_(o.findTargetDataIndices(r), o)
        });
      };
    }, e.prototype._getItemAlign = function() {
      var t = this.visualMapModel, r = t.option;
      if (r.orient === "vertical") return WK(t, this.api, t.itemSize);
      var i = r.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, e.prototype._renderEndsText = function(t, r, i, a, s) {
      if (r) {
        var o = new tt(), l = this.visualMapModel.textStyleModel;
        o.add(new Gt({
          style: $n(l, {
            x: a ? s === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: a ? s : "center",
            text: r
          })
        })), t.add(o);
      }
    }, e.prototype._getViewData = function() {
      var t = this.visualMapModel, r = me(t.getPieceList(), function(o, l) {
        return {
          piece: o,
          indexInModelPieceList: l
        };
      }), i = t.get("text"), a = t.get("orient"), s = t.get("inverse");
      return (a === "horizontal" ? s : !s) ? r.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: r,
        endsText: i
      };
    }, e.prototype._createItemSymbol = function(t, r, i, a) {
      var s = xr(this.getControllerVisual(r, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(r, "color"));
      s.silent = a, t.add(s);
    }, e.prototype._onItemClick = function(t) {
      var r = this.visualMapModel, i = r.option, a = i.selectedMode;
      if (a) {
        var s = Qe(i.selected), o = r.getSelectedMapKey(t);
        a === "single" || a === true ? (s[o] = true, P(s, function(l, u) {
          s[u] = u === o;
        })) : s[o] = !s[o], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: s
        });
      }
    }, e.type = "visualMap.piecewise", e;
  }(VK);
  function HK(n) {
    n.registerComponentModel(kIe), n.registerComponentView(AIe), GK(n);
  }
  function DIe(n) {
    Ct(UK), Ct(HK);
  }
  var RIe = {
    label: {
      enabled: true
    },
    decal: {
      show: false
    }
  }, _G = Wt(), $Ie = {};
  function NIe(n, e) {
    var t = n.getModel("aria");
    if (!t.get("enabled")) return;
    var r = Qe(RIe);
    pt(r.label, n.getLocaleModel().get("aria"), false), pt(t.option, r, false), i(), a();
    function i() {
      var u = t.getModel("decal"), c = u.get("show");
      if (c) {
        var h = Pe();
        n.eachSeries(function(d) {
          if (!d.isColorBySeries()) {
            var f = h.get(d.type);
            f || (f = {}, h.set(d.type, f)), _G(d).scope = f;
          }
        }), n.eachRawSeries(function(d) {
          if (n.isSeriesFiltered(d)) return;
          if (Xe(d.enableAriaDecal)) {
            d.enableAriaDecal();
            return;
          }
          var f = d.getData();
          if (d.isColorBySeries()) {
            var y = ZD(d.ecModel, d.name, $Ie, n.getSeriesCount()), x = f.getVisual("decal");
            f.setVisual("decal", b(x, y));
          } else {
            var p = d.getRawData(), g = {}, m = _G(d).scope;
            f.each(function(w) {
              var _ = f.getRawIndex(w);
              g[_] = w;
            });
            var v = p.count();
            p.each(function(w) {
              var _ = g[w], S = p.getName(w) || w + "", I = ZD(d.ecModel, S, m, v), C = f.getItemVisual(_, "decal");
              f.setItemVisual(_, "decal", b(C, I));
            });
          }
          function b(w, _) {
            var S = w ? oe(oe({}, _), w) : _;
            return S.dirty = true, S;
          }
        });
      }
    }
    function a() {
      var u = e.getZr().dom;
      if (u) {
        var c = n.getLocaleModel().get("aria"), h = t.getModel("label");
        if (h.option = je(h.option, c), !!h.get("enabled")) {
          if (u.setAttribute("role", "img"), h.get("description")) {
            u.setAttribute("aria-label", h.get("description"));
            return;
          }
          var d = n.getSeriesCount(), f = h.get([
            "data",
            "maxCount"
          ]) || 10, p = h.get([
            "series",
            "maxCount"
          ]) || 10, g = Math.min(d, p), m;
          if (!(d < 1)) {
            var v = o();
            if (v) {
              var y = h.get([
                "general",
                "withTitle"
              ]);
              m = s(y, {
                title: v
              });
            } else m = h.get([
              "general",
              "withoutTitle"
            ]);
            var x = [], b = d > 1 ? h.get([
              "series",
              "multiple",
              "prefix"
            ]) : h.get([
              "series",
              "single",
              "prefix"
            ]);
            m += s(b, {
              seriesCount: d
            }), n.eachSeries(function(I, C) {
              if (C < g) {
                var T = void 0, k = I.get("name"), D = k ? "withName" : "withoutName";
                T = d > 1 ? h.get([
                  "series",
                  "multiple",
                  D
                ]) : h.get([
                  "series",
                  "single",
                  D
                ]), T = s(T, {
                  seriesId: I.seriesIndex,
                  seriesName: I.get("name"),
                  seriesType: l(I.subType)
                });
                var R = I.getData();
                if (R.count() > f) {
                  var N = h.get([
                    "data",
                    "partialData"
                  ]);
                  T += s(N, {
                    displayCnt: f
                  });
                } else T += h.get([
                  "data",
                  "allData"
                ]);
                for (var E = h.get([
                  "data",
                  "separator",
                  "middle"
                ]), A = h.get([
                  "data",
                  "separator",
                  "end"
                ]), M = h.get([
                  "data",
                  "excludeDimensionId"
                ]), $ = [], L = 0; L < R.count(); L++) if (L < f) {
                  var F = R.getName(L), O = M ? rn(R.getValues(L), function(V, H) {
                    return bt(M, H) === -1;
                  }) : R.getValues(L), z = h.get([
                    "data",
                    F ? "withName" : "withoutName"
                  ]);
                  $.push(s(z, {
                    name: F,
                    value: O.join(E)
                  }));
                }
                T += $.join(E) + A, x.push(T);
              }
            });
            var w = h.getModel([
              "series",
              "multiple",
              "separator"
            ]), _ = w.get("middle"), S = w.get("end");
            m += x.join(_) + S, u.setAttribute("aria-label", m);
          }
        }
      }
    }
    function s(u, c) {
      if (!Ie(u)) return u;
      var h = u;
      return P(c, function(d, f) {
        h = h.replace(new RegExp("\\{\\s*" + f + "\\s*\\}", "g"), d);
      }), h;
    }
    function o() {
      var u = n.get("title");
      return u && u.length && (u = u[0]), u && u.text;
    }
    function l(u) {
      var c = n.getLocaleModel().get([
        "series",
        "typeNames"
      ]);
      return c[u] || c.chart;
    }
  }
  function EIe(n) {
    if (!(!n || !n.aria)) {
      var e = n.aria;
      e.show != null && (e.enabled = e.show), e.label = e.label || {}, P([
        "description",
        "general",
        "series",
        "data"
      ], function(t) {
        e[t] != null && (e.label[t] = e[t]);
      });
    }
  }
  function MIe(n) {
    n.registerPreprocessor(EIe), n.registerVisual(n.PRIORITY.VISUAL.ARIA, NIe);
  }
  var SG = {
    value: "eq",
    "<": "lt",
    "<=": "lte",
    ">": "gt",
    ">=": "gte",
    "=": "eq",
    "!=": "ne",
    "<>": "ne"
  }, PIe = function() {
    function n(e) {
      var t = this._condVal = Ie(e) ? new RegExp(e) : Gse(e) ? e : null;
      if (t == null) {
        var r = "";
        nn(r);
      }
    }
    return n.prototype.evaluate = function(e) {
      var t = typeof e;
      return Ie(t) ? this._condVal.test(e) : Yt(t) ? this._condVal.test(e + "") : false;
    }, n;
  }(), LIe = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      return this.value;
    }, n;
  }(), FIe = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++) if (!e[t].evaluate()) return false;
      return true;
    }, n;
  }(), OIe = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++) if (e[t].evaluate()) return true;
      return false;
    }, n;
  }(), BIe = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, n;
  }(), zIe = function() {
    function n() {
    }
    return n.prototype.evaluate = function() {
      for (var e = !!this.valueParser, t = this.getValue, r = t(this.valueGetterParam), i = e ? this.valueParser(r) : null, a = 0; a < this.subCondList.length; a++) if (!this.subCondList[a].evaluate(e ? i : r)) return false;
      return true;
    }, n;
  }();
  function MM(n, e) {
    if (n === true || n === false) {
      var t = new LIe();
      return t.value = n, t;
    }
    var r = "";
    return XK(n) || nn(r), n.and ? CG("and", n, e) : n.or ? CG("or", n, e) : n.not ? VIe(n, e) : WIe(n, e);
  }
  function CG(n, e, t) {
    var r = e[n], i = "";
    de(r) || nn(i), r.length || nn(i);
    var a = n === "and" ? new FIe() : new OIe();
    return a.children = me(r, function(s) {
      return MM(s, t);
    }), a.children.length || nn(i), a;
  }
  function VIe(n, e) {
    var t = n.not, r = "";
    XK(t) || nn(r);
    var i = new BIe();
    return i.child = MM(t, e), i.child || nn(r), i;
  }
  function WIe(n, e) {
    for (var t = "", r = e.prepareGetValue(n), i = [], a = Mt(n), s = n.parser, o = s ? TX(s) : null, l = 0; l < a.length; l++) {
      var u = a[l];
      if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
        var c = $e(SG, u) ? SG[u] : u, h = n[u], d = o ? o(h) : h, f = Dhe(c, d) || c === "reg" && new PIe(d);
        f || nn(t), i.push(f);
      }
    }
    i.length || nn(t);
    var p = new zIe();
    return p.valueGetterParam = r, p.valueParser = o, p.getValue = e.getValue, p.subCondList = i, p;
  }
  function XK(n) {
    return Ze(n) && !Mi(n);
  }
  var GIe = function() {
    function n(e, t) {
      this._cond = MM(e, t);
    }
    return n.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, n;
  }();
  function UIe(n, e) {
    return new GIe(n, e);
  }
  var HIe = {
    type: "echarts:filter",
    transform: function(n) {
      for (var e = n.upstream, t, r = UIe(n.config, {
        valueGetterAttrMap: Pe({
          dimension: true
        }),
        prepareGetValue: function(o) {
          var l = "", u = o.dimension;
          $e(o, "dimension") || nn(l);
          var c = e.getDimensionInfo(u);
          return c || nn(l), {
            dimIdx: c.index
          };
        },
        getValue: function(o) {
          return e.retrieveValueFromItem(t, o.dimIdx);
        }
      }), i = [], a = 0, s = e.count(); a < s; a++) t = e.getRawDataItem(a), r.evaluate() && i.push(t);
      return {
        data: i
      };
    }
  }, XIe = {
    type: "echarts:sort",
    transform: function(n) {
      var e = n.upstream, t = n.config, r = "", i = xn(t);
      i.length || nn(r);
      var a = [];
      P(i, function(c) {
        var h = c.dimension, d = c.order, f = c.parser, p = c.incomparable;
        if (h == null && nn(r), d !== "asc" && d !== "desc" && nn(r), p && p !== "min" && p !== "max") {
          var g = "";
          nn(g);
        }
        if (d !== "asc" && d !== "desc") {
          var m = "";
          nn(m);
        }
        var v = e.getDimensionInfo(h);
        v || nn(r);
        var y = f ? TX(f) : null;
        f && !y && nn(r), a.push({
          dimIdx: v.index,
          parser: y,
          comparator: new DX(d, p)
        });
      });
      var s = e.sourceFormat;
      s !== Pi && s !== Ts && nn(r);
      for (var o = [], l = 0, u = e.count(); l < u; l++) o.push(e.getRawDataItem(l));
      return o.sort(function(c, h) {
        for (var d = 0; d < a.length; d++) {
          var f = a[d], p = e.retrieveValueFromItem(c, f.dimIdx), g = e.retrieveValueFromItem(h, f.dimIdx);
          f.parser && (p = f.parser(p), g = f.parser(g));
          var m = f.comparator.evaluate(p, g);
          if (m !== 0) return m;
        }
        return 0;
      }), {
        data: o
      };
    }
  };
  function YIe(n) {
    n.registerTransform(HIe), n.registerTransform(XIe);
  }
  var qIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.prototype.init = function(t, r, i) {
      n.prototype.init.call(this, t, r, i), this._sourceManager = new EX(this), kO(this);
    }, e.prototype.mergeOption = function(t, r) {
      n.prototype.mergeOption.call(this, t, r), kO(this);
    }, e.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, e.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, e.type = "dataset", e.defaultOption = {
      seriesLayoutBy: Ho
    }, e;
  }(Et), jIe = function(n) {
    K(e, n);
    function e() {
      var t = n !== null && n.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.type = "dataset", e;
  }(Yn);
  function KIe(n) {
    n.registerComponentModel(qIe), n.registerComponentView(jIe);
  }
  var So = nl.CMD;
  function yg(n, e) {
    return Math.abs(n - e) < 1e-5;
  }
  function QR(n) {
    var e = n.data, t = n.len(), r = [], i, a = 0, s = 0, o = 0, l = 0;
    function u(R, N) {
      i && i.length > 2 && r.push(i), i = [
        R,
        N
      ];
    }
    function c(R, N, E, A) {
      yg(R, E) && yg(N, A) || i.push(R, N, E, A, E, A);
    }
    function h(R, N, E, A, M, $) {
      var L = Math.abs(N - R), F = Math.tan(L / 4) * 4 / 3, O = N < R ? -1 : 1, z = Math.cos(R), V = Math.sin(R), H = Math.cos(N), Y = Math.sin(N), le = z * M + E, ve = V * $ + A, re = H * M + E, ae = Y * $ + A, fe = M * F * O, ce = $ * F * O;
      i.push(le - fe * V, ve + ce * z, re + fe * Y, ae - ce * H, re, ae);
    }
    for (var d, f, p, g, m = 0; m < t; ) {
      var v = e[m++], y = m === 1;
      switch (y && (a = e[m], s = e[m + 1], o = a, l = s, (v === So.L || v === So.C || v === So.Q) && (i = [
        o,
        l
      ])), v) {
        case So.M:
          a = o = e[m++], s = l = e[m++], u(o, l);
          break;
        case So.L:
          d = e[m++], f = e[m++], c(a, s, d, f), a = d, s = f;
          break;
        case So.C:
          i.push(e[m++], e[m++], e[m++], e[m++], a = e[m++], s = e[m++]);
          break;
        case So.Q:
          d = e[m++], f = e[m++], p = e[m++], g = e[m++], i.push(a + 2 / 3 * (d - a), s + 2 / 3 * (f - s), p + 2 / 3 * (d - p), g + 2 / 3 * (f - g), p, g), a = p, s = g;
          break;
        case So.A:
          var x = e[m++], b = e[m++], w = e[m++], _ = e[m++], S = e[m++], I = e[m++] + S;
          m += 1;
          var C = !e[m++];
          d = Math.cos(S) * w + x, f = Math.sin(S) * _ + b, y ? (o = d, l = f, u(o, l)) : c(a, s, d, f), a = Math.cos(I) * w + x, s = Math.sin(I) * _ + b;
          for (var T = (C ? -1 : 1) * Math.PI / 2, k = S; C ? k > I : k < I; k += T) {
            var D = C ? Math.max(k + T, I) : Math.min(k + T, I);
            h(k, D, x, b, w, _);
          }
          break;
        case So.R:
          o = a = e[m++], l = s = e[m++], d = o + e[m++], f = l + e[m++], u(d, l), c(d, l, d, f), c(d, f, o, f), c(o, f, o, l), c(o, l, d, l);
          break;
        case So.Z:
          i && c(a, s, o, l), a = o, s = l;
          break;
      }
    }
    return i && i.length > 2 && r.push(i), r;
  }
  function JR(n, e, t, r, i, a, s, o, l, u) {
    if (yg(n, t) && yg(e, r) && yg(i, s) && yg(a, o)) {
      l.push(s, o);
      return;
    }
    var c = 2 / u, h = c * c, d = s - n, f = o - e, p = Math.sqrt(d * d + f * f);
    d /= p, f /= p;
    var g = t - n, m = r - e, v = i - s, y = a - o, x = g * g + m * m, b = v * v + y * y;
    if (x < h && b < h) {
      l.push(s, o);
      return;
    }
    var w = d * g + f * m, _ = -d * v - f * y, S = x - w * w, I = b - _ * _;
    if (S < h && w >= 0 && I < h && _ >= 0) {
      l.push(s, o);
      return;
    }
    var C = [], T = [];
    tc(n, t, i, s, 0.5, C), tc(e, r, a, o, 0.5, T), JR(C[0], T[0], C[1], T[1], C[2], T[2], C[3], T[3], l, u), JR(C[4], T[4], C[5], T[5], C[6], T[6], C[7], T[7], l, u);
  }
  function ZIe(n, e) {
    var t = QR(n), r = [];
    e = e || 1;
    for (var i = 0; i < t.length; i++) {
      var a = t[i], s = [], o = a[0], l = a[1];
      s.push(o, l);
      for (var u = 2; u < a.length; ) {
        var c = a[u++], h = a[u++], d = a[u++], f = a[u++], p = a[u++], g = a[u++];
        JR(o, l, c, h, d, f, p, g, s, e), o = p, l = g;
      }
      r.push(s);
    }
    return r;
  }
  function YK(n, e, t) {
    var r = n[e], i = n[1 - e], a = Math.abs(r / i), s = Math.ceil(Math.sqrt(a * t)), o = Math.floor(t / s);
    o === 0 && (o = 1, s = t);
    for (var l = [], u = 0; u < s; u++) l.push(o);
    var c = s * o, h = t - c;
    if (h > 0) for (var u = 0; u < h; u++) l[u % s] += 1;
    return l;
  }
  function IG(n, e, t) {
    for (var r = n.r0, i = n.r, a = n.startAngle, s = n.endAngle, o = Math.abs(s - a), l = o * i, u = i - r, c = l > Math.abs(u), h = YK([
      l,
      u
    ], c ? 0 : 1, e), d = (c ? o : u) / h.length, f = 0; f < h.length; f++) for (var p = (c ? u : o) / h[f], g = 0; g < h[f]; g++) {
      var m = {};
      c ? (m.startAngle = a + d * f, m.endAngle = a + d * (f + 1), m.r0 = r + p * g, m.r = r + p * (g + 1)) : (m.startAngle = a + p * g, m.endAngle = a + p * (g + 1), m.r0 = r + d * f, m.r = r + d * (f + 1)), m.clockwise = n.clockwise, m.cx = n.cx, m.cy = n.cy, t.push(m);
    }
  }
  function QIe(n, e, t) {
    for (var r = n.width, i = n.height, a = r > i, s = YK([
      r,
      i
    ], a ? 0 : 1, e), o = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", c = a ? "y" : "x", h = n[o] / s.length, d = 0; d < s.length; d++) for (var f = n[l] / s[d], p = 0; p < s[d]; p++) {
      var g = {};
      g[u] = d * h, g[c] = p * f, g[o] = h, g[l] = f, g.x += n.x, g.y += n.y, t.push(g);
    }
  }
  function kG(n, e, t, r) {
    return n * r - t * e;
  }
  function JIe(n, e, t, r, i, a, s, o) {
    var l = t - n, u = r - e, c = s - i, h = o - a, d = kG(c, h, l, u);
    if (Math.abs(d) < 1e-6) return null;
    var f = n - i, p = e - a, g = kG(f, p, c, h) / d;
    return g < 0 || g > 1 ? null : new mt(g * l + n, g * u + e);
  }
  function e2e(n, e, t) {
    var r = new mt();
    mt.sub(r, t, e), r.normalize();
    var i = new mt();
    mt.sub(i, n, e);
    var a = i.dot(r);
    return a;
  }
  function Up(n, e) {
    var t = n[n.length - 1];
    t && t[0] === e[0] && t[1] === e[1] || n.push(e);
  }
  function t2e(n, e, t) {
    for (var r = n.length, i = [], a = 0; a < r; a++) {
      var s = n[a], o = n[(a + 1) % r], l = JIe(s[0], s[1], o[0], o[1], e.x, e.y, t.x, t.y);
      l && i.push({
        projPt: e2e(l, e, t),
        pt: l,
        idx: a
      });
    }
    if (i.length < 2) return [
      {
        points: n
      },
      {
        points: n
      }
    ];
    i.sort(function(m, v) {
      return m.projPt - v.projPt;
    });
    var u = i[0], c = i[i.length - 1];
    if (c.idx < u.idx) {
      var h = u;
      u = c, c = h;
    }
    for (var d = [
      u.pt.x,
      u.pt.y
    ], f = [
      c.pt.x,
      c.pt.y
    ], p = [
      d
    ], g = [
      f
    ], a = u.idx + 1; a <= c.idx; a++) Up(p, n[a].slice());
    Up(p, f), Up(p, d);
    for (var a = c.idx + 1; a <= u.idx + r; a++) Up(g, n[a % r].slice());
    return Up(g, d), Up(g, f), [
      {
        points: p
      },
      {
        points: g
      }
    ];
  }
  function TG(n) {
    var e = n.points, t = [], r = [];
    xC(e, t, r);
    var i = new vt(t[0], t[1], r[0] - t[0], r[1] - t[1]), a = i.width, s = i.height, o = i.x, l = i.y, u = new mt(), c = new mt();
    return a > s ? (u.x = c.x = o + a / 2, u.y = l, c.y = l + s) : (u.y = c.y = l + s / 2, u.x = o, c.x = o + a), t2e(e, u, c);
  }
  function xS(n, e, t, r) {
    if (t === 1) r.push(e);
    else {
      var i = Math.floor(t / 2), a = n(e);
      xS(n, a[0], i, r), xS(n, a[1], t - i, r);
    }
    return r;
  }
  function n2e(n, e) {
    for (var t = [], r = 0; r < e; r++) t.push(QN(n));
    return t;
  }
  function r2e(n, e) {
    e.setStyle(n.style), e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel;
  }
  function i2e(n) {
    for (var e = [], t = 0; t < n.length; ) e.push([
      n[t++],
      n[t++]
    ]);
    return e;
  }
  function a2e(n, e) {
    var t = [], r = n.shape, i;
    switch (n.type) {
      case "rect":
        QIe(r, e, t), i = Vt;
        break;
      case "sector":
        IG(r, e, t), i = ra;
        break;
      case "circle":
        IG({
          r0: 0,
          r: r.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: r.cx,
          cy: r.cy
        }, e, t), i = ra;
        break;
      default:
        var a = n.getComputedTransform(), s = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, o = me(ZIe(n.getUpdatedPathProxy(), s), function(v) {
          return i2e(v);
        }), l = o.length;
        if (l === 0) xS(TG, {
          points: o[0]
        }, e, t);
        else if (l === e) for (var u = 0; u < l; u++) t.push({
          points: o[u]
        });
        else {
          var c = 0, h = me(o, function(v) {
            var y = [], x = [];
            xC(v, y, x);
            var b = (x[1] - y[1]) * (x[0] - y[0]);
            return c += b, {
              poly: v,
              area: b
            };
          });
          h.sort(function(v, y) {
            return y.area - v.area;
          });
          for (var d = e, u = 0; u < l; u++) {
            var f = h[u];
            if (d <= 0) break;
            var p = u === l - 1 ? d : Math.ceil(f.area / c * e);
            p < 0 || (xS(TG, {
              points: f.poly
            }, p, t), d -= p);
          }
        }
        i = ia;
        break;
    }
    if (!i) return n2e(n, e);
    for (var g = [], u = 0; u < t.length; u++) {
      var m = new i();
      m.setShape(t[u]), r2e(n, m), g.push(m);
    }
    return g;
  }
  function s2e(n, e) {
    var t = n.length, r = e.length;
    if (t === r) return [
      n,
      e
    ];
    for (var i = [], a = [], s = t < r ? n : e, o = Math.min(t, r), l = Math.abs(r - t) / 6, u = (o - 2) / 6, c = Math.ceil(l / u) + 1, h = [
      s[0],
      s[1]
    ], d = l, f = 2; f < o; ) {
      var p = s[f - 2], g = s[f - 1], m = s[f++], v = s[f++], y = s[f++], x = s[f++], b = s[f++], w = s[f++];
      if (d <= 0) {
        h.push(m, v, y, x, b, w);
        continue;
      }
      for (var _ = Math.min(d, c - 1) + 1, S = 1; S <= _; S++) {
        var I = S / _;
        tc(p, m, y, b, I, i), tc(g, v, x, w, I, a), p = i[3], g = a[3], h.push(i[1], a[1], i[2], a[2], p, g), m = i[5], v = a[5], y = i[6], x = a[6];
      }
      d -= _ - 1;
    }
    return s === n ? [
      h,
      e
    ] : [
      n,
      h
    ];
  }
  function AG(n, e) {
    for (var t = n.length, r = n[t - 2], i = n[t - 1], a = [], s = 0; s < e.length; ) a[s++] = r, a[s++] = i;
    return a;
  }
  function o2e(n, e) {
    for (var t, r, i, a = [], s = [], o = 0; o < Math.max(n.length, e.length); o++) {
      var l = n[o], u = e[o], c = void 0, h = void 0;
      l ? u ? (t = s2e(l, u), c = t[0], h = t[1], r = c, i = h) : (h = AG(i || l, l), c = l) : (c = AG(r || u, u), h = u), a.push(c), s.push(h);
    }
    return [
      a,
      s
    ];
  }
  function DG(n) {
    for (var e = 0, t = 0, r = 0, i = n.length, a = 0, s = i - 2; a < i; s = a, a += 2) {
      var o = n[s], l = n[s + 1], u = n[a], c = n[a + 1], h = o * c - u * l;
      e += h, t += (o + u) * h, r += (l + c) * h;
    }
    return e === 0 ? [
      n[0] || 0,
      n[1] || 0
    ] : [
      t / e / 3,
      r / e / 3,
      e
    ];
  }
  function l2e(n, e, t, r) {
    for (var i = (n.length - 2) / 6, a = 1 / 0, s = 0, o = n.length, l = o - 2, u = 0; u < i; u++) {
      for (var c = u * 6, h = 0, d = 0; d < o; d += 2) {
        var f = d === 0 ? c : (c + d - 2) % l + 2, p = n[f] - t[0], g = n[f + 1] - t[1], m = e[d] - r[0], v = e[d + 1] - r[1], y = m - p, x = v - g;
        h += y * y + x * x;
      }
      h < a && (a = h, s = u);
    }
    return s;
  }
  function u2e(n) {
    for (var e = [], t = n.length, r = 0; r < t; r += 2) e[r] = n[t - r - 2], e[r + 1] = n[t - r - 1];
    return e;
  }
  function c2e(n, e, t, r) {
    for (var i = [], a, s = 0; s < n.length; s++) {
      var o = n[s], l = e[s], u = DG(o), c = DG(l);
      a == null && (a = u[2] < 0 != c[2] < 0);
      var h = [], d = [], f = 0, p = 1 / 0, g = [], m = o.length;
      a && (o = u2e(o));
      for (var v = l2e(o, l, u, c) * 6, y = m - 2, x = 0; x < y; x += 2) {
        var b = (v + x) % y + 2;
        h[x + 2] = o[b] - u[0], h[x + 3] = o[b + 1] - u[1];
      }
      h[0] = o[v] - u[0], h[1] = o[v + 1] - u[1];
      for (var w = r / t, _ = -r / 2; _ <= r / 2; _ += w) {
        for (var S = Math.sin(_), I = Math.cos(_), C = 0, x = 0; x < o.length; x += 2) {
          var T = h[x], k = h[x + 1], D = l[x] - c[0], R = l[x + 1] - c[1], N = D * I - R * S, E = D * S + R * I;
          g[x] = N, g[x + 1] = E;
          var A = N - T, M = E - k;
          C += A * A + M * M;
        }
        if (C < p) {
          p = C, f = _;
          for (var $ = 0; $ < g.length; $++) d[$] = g[$];
        }
      }
      i.push({
        from: h,
        to: d,
        fromCp: u,
        toCp: c,
        rotation: -f
      });
    }
    return i;
  }
  function bS(n) {
    return n.__isCombineMorphing;
  }
  var qK = "__mOriginal_";
  function wS(n, e, t) {
    var r = qK + e, i = n[r] || n[e];
    n[r] || (n[r] = n[e]);
    var a = t.replace, s = t.after, o = t.before;
    n[e] = function() {
      var l = arguments, u;
      return o && o.apply(this, l), a ? u = a.apply(this, l) : u = i.apply(this, l), s && s.apply(this, l), u;
    };
  }
  function p0(n, e) {
    var t = qK + e;
    n[t] && (n[e] = n[t], n[t] = null);
  }
  function RG(n, e) {
    for (var t = 0; t < n.length; t++) for (var r = n[t], i = 0; i < r.length; ) {
      var a = r[i], s = r[i + 1];
      r[i++] = e[0] * a + e[2] * s + e[4], r[i++] = e[1] * a + e[3] * s + e[5];
    }
  }
  function jK(n, e) {
    var t = n.getUpdatedPathProxy(), r = e.getUpdatedPathProxy(), i = o2e(QR(t), QR(r)), a = i[0], s = i[1], o = n.getComputedTransform(), l = e.getComputedTransform();
    function u() {
      this.transform = null;
    }
    o && RG(a, o), l && RG(s, l), wS(e, "updateTransform", {
      replace: u
    }), e.transform = null;
    var c = c2e(a, s, 10, Math.PI), h = [];
    wS(e, "buildPath", {
      replace: function(d) {
        for (var f = e.__morphT, p = 1 - f, g = [], m = 0; m < c.length; m++) {
          var v = c[m], y = v.from, x = v.to, b = v.rotation * f, w = v.fromCp, _ = v.toCp, S = Math.sin(b), I = Math.cos(b);
          jw(g, w, _, f);
          for (var C = 0; C < y.length; C += 2) {
            var T = y[C], k = y[C + 1], D = x[C], R = x[C + 1], N = T * p + D * f, E = k * p + R * f;
            h[C] = N * I - E * S + g[0], h[C + 1] = N * S + E * I + g[1];
          }
          var A = h[0], M = h[1];
          d.moveTo(A, M);
          for (var C = 2; C < y.length; ) {
            var D = h[C++], R = h[C++], $ = h[C++], L = h[C++], F = h[C++], O = h[C++];
            A === D && M === R && $ === F && L === O ? d.lineTo(F, O) : d.bezierCurveTo(D, R, $, L, F, O), A = F, M = O;
          }
        }
      }
    });
  }
  function PM(n, e, t) {
    if (!n || !e) return e;
    var r = t.done, i = t.during;
    jK(n, e), e.__morphT = 0;
    function a() {
      p0(e, "buildPath"), p0(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape();
    }
    return e.animateTo({
      __morphT: 1
    }, je({
      during: function(s) {
        e.dirtyShape(), i && i(s);
      },
      done: function() {
        a(), r && r();
      }
    }, t)), e;
  }
  function h2e(n, e, t, r, i, a) {
    var s = 16;
    n = i === t ? 0 : Math.round(32767 * (n - t) / (i - t)), e = a === r ? 0 : Math.round(32767 * (e - r) / (a - r));
    for (var o = 0, l, u = (1 << s) / 2; u > 0; u /= 2) {
      var c = 0, h = 0;
      (n & u) > 0 && (c = 1), (e & u) > 0 && (h = 1), o += u * u * (3 * c ^ h), h === 0 && (c === 1 && (n = u - 1 - n, e = u - 1 - e), l = n, n = e, e = l);
    }
    return o;
  }
  function _S(n) {
    var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, a = me(n, function(o) {
      var l = o.getBoundingRect(), u = o.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), h = l.y + l.height / 2 + (u ? u[5] : 0);
      return e = Math.min(c, e), t = Math.min(h, t), r = Math.max(c, r), i = Math.max(h, i), [
        c,
        h
      ];
    }), s = me(a, function(o, l) {
      return {
        cp: o,
        z: h2e(o[0], o[1], e, t, r, i),
        path: n[l]
      };
    });
    return s.sort(function(o, l) {
      return o.z - l.z;
    }).map(function(o) {
      return o.path;
    });
  }
  function KK(n) {
    return a2e(n.path, n.count);
  }
  function e$() {
    return {
      fromIndividuals: [],
      toIndividuals: [],
      count: 0
    };
  }
  function d2e(n, e, t) {
    var r = [];
    function i(w) {
      for (var _ = 0; _ < w.length; _++) {
        var S = w[_];
        bS(S) ? i(S.childrenRef()) : S instanceof At && r.push(S);
      }
    }
    i(n);
    var a = r.length;
    if (!a) return e$();
    var s = t.dividePath || KK, o = s({
      path: e,
      count: a
    });
    if (o.length !== a) return console.error("Invalid morphing: unmatched splitted path"), e$();
    r = _S(r), o = _S(o);
    for (var l = t.done, u = t.during, c = t.individualDelay, h = new Tl(), d = 0; d < a; d++) {
      var f = r[d], p = o[d];
      p.parent = e, p.copyTransform(h), c || jK(f, p);
    }
    e.__isCombineMorphing = true, e.childrenRef = function() {
      return o;
    };
    function g(w) {
      for (var _ = 0; _ < o.length; _++) o[_].addSelfToZr(w);
    }
    wS(e, "addSelfToZr", {
      after: function(w) {
        g(w);
      }
    }), wS(e, "removeSelfFromZr", {
      after: function(w) {
        for (var _ = 0; _ < o.length; _++) o[_].removeSelfFromZr(w);
      }
    });
    function m() {
      e.__isCombineMorphing = false, e.__morphT = -1, e.childrenRef = null, p0(e, "addSelfToZr"), p0(e, "removeSelfFromZr");
    }
    var v = o.length;
    if (c) for (var y = v, x = function() {
      y--, y === 0 && (m(), l && l());
    }, d = 0; d < v; d++) {
      var b = c ? je({
        delay: (t.delay || 0) + c(d, v, r[d], o[d]),
        done: x
      }, t) : t;
      PM(r[d], o[d], b);
    }
    else e.__morphT = 0, e.animateTo({
      __morphT: 1
    }, je({
      during: function(w) {
        for (var _ = 0; _ < v; _++) {
          var S = o[_];
          S.__morphT = e.__morphT, S.dirtyShape();
        }
        u && u(w);
      },
      done: function() {
        m();
        for (var w = 0; w < n.length; w++) p0(n[w], "updateTransform");
        l && l();
      }
    }, t));
    return e.__zr && g(e.__zr), {
      fromIndividuals: r,
      toIndividuals: o,
      count: v
    };
  }
  function f2e(n, e, t) {
    var r = e.length, i = [], a = t.dividePath || KK;
    function s(f) {
      for (var p = 0; p < f.length; p++) {
        var g = f[p];
        bS(g) ? s(g.childrenRef()) : g instanceof At && i.push(g);
      }
    }
    if (bS(n)) {
      s(n.childrenRef());
      var o = i.length;
      if (o < r) for (var l = 0, u = o; u < r; u++) i.push(QN(i[l++ % o]));
      i.length = r;
    } else {
      i = a({
        path: n,
        count: r
      });
      for (var c = n.getComputedTransform(), u = 0; u < i.length; u++) i[u].setLocalTransform(c);
      if (i.length !== r) return console.error("Invalid morphing: unmatched splitted path"), e$();
    }
    i = _S(i), e = _S(e);
    for (var h = t.individualDelay, u = 0; u < r; u++) {
      var d = h ? je({
        delay: (t.delay || 0) + h(u, r, i[u], e[u])
      }, t) : t;
      PM(i[u], e[u], d);
    }
    return {
      fromIndividuals: i,
      toIndividuals: e,
      count: e.length
    };
  }
  function $G(n) {
    return de(n[0]);
  }
  function NG(n, e) {
    for (var t = [], r = n.length, i = 0; i < r; i++) t.push({
      one: n[i],
      many: []
    });
    for (var i = 0; i < e.length; i++) {
      var a = e[i].length, s = void 0;
      for (s = 0; s < a; s++) t[s % r].many.push(e[i][s]);
    }
    for (var o = 0, i = r - 1; i >= 0; i--) if (!t[i].many.length) {
      var l = t[o].many;
      if (l.length <= 1) if (o) o = 0;
      else return t;
      var a = l.length, u = Math.ceil(a / 2);
      t[i].many = l.slice(u, a), t[o].many = l.slice(0, u), o++;
    }
    return t;
  }
  var p2e = {
    clone: function(n) {
      for (var e = [], t = 1 - Math.pow(1 - n.path.style.opacity, 1 / n.count), r = 0; r < n.count; r++) {
        var i = QN(n.path);
        i.setStyle("opacity", t), e.push(i);
      }
      return e;
    },
    split: null
  };
  function qT(n, e, t, r, i, a) {
    if (!n.length || !e.length) return;
    var s = mm("update", r, i);
    if (!(s && s.duration > 0)) return;
    var o = r.getModel("universalTransition").get("delay"), l = Object.assign({
      setToFinal: true
    }, s), u, c;
    $G(n) && (u = n, c = e), $G(e) && (u = e, c = n);
    function h(v, y, x, b, w) {
      var _ = v.many, S = v.one;
      if (_.length === 1 && !w) {
        var I = y ? _[0] : S, C = y ? S : _[0];
        if (bS(I)) h({
          many: [
            I
          ],
          one: C
        }, true, x, b, true);
        else {
          var T = o ? je({
            delay: o(x, b)
          }, l) : l;
          PM(I, C, T), a(I, C, I, C, T);
        }
      } else for (var k = je({
        dividePath: p2e[t],
        individualDelay: o && function(M, $, L, F) {
          return o(M + x, b);
        }
      }, l), D = y ? d2e(_, S, k) : f2e(S, _, k), R = D.fromIndividuals, N = D.toIndividuals, E = R.length, A = 0; A < E; A++) {
        var T = o ? je({
          delay: o(A, E)
        }, l) : l;
        a(R[A], N[A], y ? _[A] : v.one, y ? v.one : _[A], T);
      }
    }
    for (var d = u ? u === n : n.length > e.length, f = u ? NG(c, u) : NG(d ? e : n, [
      d ? n : e
    ]), p = 0, g = 0; g < f.length; g++) p += f[g].many.length;
    for (var m = 0, g = 0; g < f.length; g++) h(f[g], d, m, p), m += f[g].many.length;
  }
  function bh(n) {
    if (!n) return [];
    if (de(n)) {
      for (var e = [], t = 0; t < n.length; t++) e.push(bh(n[t]));
      return e;
    }
    var r = [];
    return n.traverse(function(i) {
      i instanceof At && !i.disableMorphing && !i.invisible && !i.ignore && r.push(i);
    }), r;
  }
  var ZK = 1e4, g2e = 0, EG = 1, MG = 2, m2e = Wt();
  function v2e(n, e) {
    for (var t = n.dimensions, r = 0; r < t.length; r++) {
      var i = n.getDimensionInfo(t[r]);
      if (i && i.otherDims[e] === 0) return t[r];
    }
  }
  function y2e(n, e, t) {
    var r = n.getDimensionInfo(t), i = r && r.ordinalMeta;
    if (r) {
      var a = n.get(r.name, e);
      return i && i.categories[a] || a + "";
    }
  }
  function PG(n, e, t, r) {
    var i = r ? "itemChildGroupId" : "itemGroupId", a = v2e(n, i);
    if (a) {
      var s = y2e(n, e, a);
      return s;
    }
    var o = n.getRawDataItem(e), l = r ? "childGroupId" : "groupId";
    if (o && o[l]) return o[l] + "";
    if (!r) return t || n.getId(e);
  }
  function LG(n) {
    var e = [];
    return P(n, function(t) {
      var r = t.data, i = t.dataGroupId;
      if (!(r.count() > ZK)) for (var a = r.getIndices(), s = 0; s < a.length; s++) e.push({
        data: r,
        groupId: PG(r, s, i, false),
        childGroupId: PG(r, s, i, true),
        divide: t.divide,
        dataIndex: s
      });
    }), e;
  }
  function jT(n, e, t) {
    n.traverse(function(r) {
      r instanceof At && Un(r, {
        style: {
          opacity: 0
        }
      }, e, {
        dataIndex: t,
        isFrom: true
      });
    });
  }
  function KT(n) {
    if (n.parent) {
      var e = n.getComputedTransform();
      n.setLocalTransform(e), n.parent.remove(n);
    }
  }
  function Hp(n) {
    n.stopAnimation(), n.isGroup && n.traverse(function(e) {
      e.stopAnimation();
    });
  }
  function x2e(n, e, t) {
    var r = mm("update", t, e);
    r && n.traverse(function(i) {
      if (i instanceof _s) {
        var a = dce(i);
        a && i.animateFrom({
          style: a
        }, r);
      }
    });
  }
  function b2e(n, e) {
    var t = n.length;
    if (t !== e.length) return false;
    for (var r = 0; r < t; r++) {
      var i = n[r], a = e[r];
      if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex)) return false;
    }
    return true;
  }
  function QK(n, e, t) {
    var r = LG(n), i = LG(e);
    function a(x, b, w, _, S) {
      (w || x) && b.animateFrom({
        style: w && w !== x ? oe(oe({}, w.style), x.style) : x.style
      }, S);
    }
    var s = false, o = g2e, l = Pe(), u = Pe();
    r.forEach(function(x) {
      x.groupId && l.set(x.groupId, true), x.childGroupId && u.set(x.childGroupId, true);
    });
    for (var c = 0; c < i.length; c++) {
      var h = i[c].groupId;
      if (u.get(h)) {
        o = EG;
        break;
      }
      var d = i[c].childGroupId;
      if (d && l.get(d)) {
        o = MG;
        break;
      }
    }
    function f(x, b) {
      return function(w) {
        var _ = w.data, S = w.dataIndex;
        return b ? _.getId(S) : x ? o === EG ? w.childGroupId : w.groupId : o === MG ? w.childGroupId : w.groupId;
      };
    }
    var p = b2e(r, i), g = {};
    if (!p) for (var c = 0; c < i.length; c++) {
      var m = i[c], v = m.data.getItemGraphicEl(m.dataIndex);
      v && (g[v.id] = true);
    }
    function y(x, b) {
      var w = r[b], _ = i[x], S = _.data.hostModel, I = w.data.getItemGraphicEl(w.dataIndex), C = _.data.getItemGraphicEl(_.dataIndex);
      if (I === C) {
        C && x2e(C, _.dataIndex, S);
        return;
      }
      I && g[I.id] || C && (Hp(C), I ? (Hp(I), KT(I), s = true, qT(bh(I), bh(C), _.divide, S, x, a)) : jT(C, S, x));
    }
    new ql(r, i, f(true, p), f(false, p), null, "multiple").update(y).updateManyToOne(function(x, b) {
      var w = i[x], _ = w.data, S = _.hostModel, I = _.getItemGraphicEl(w.dataIndex), C = rn(me(b, function(T) {
        return r[T].data.getItemGraphicEl(r[T].dataIndex);
      }), function(T) {
        return T && T !== I && !g[T.id];
      });
      I && (Hp(I), C.length ? (P(C, function(T) {
        Hp(T), KT(T);
      }), s = true, qT(bh(C), bh(I), w.divide, S, x, a)) : jT(I, S, w.dataIndex));
    }).updateOneToMany(function(x, b) {
      var w = r[b], _ = w.data.getItemGraphicEl(w.dataIndex);
      if (!(_ && g[_.id])) {
        var S = rn(me(x, function(C) {
          return i[C].data.getItemGraphicEl(i[C].dataIndex);
        }), function(C) {
          return C && C !== _;
        }), I = i[x[0]].data.hostModel;
        S.length && (P(S, function(C) {
          return Hp(C);
        }), _ ? (Hp(_), KT(_), s = true, qT(bh(_), bh(S), w.divide, I, x[0], a)) : P(S, function(C) {
          return jT(C, I, x[0]);
        }));
      }
    }).updateManyToMany(function(x, b) {
      new ql(b, x, function(w) {
        return r[w].data.getId(r[w].dataIndex);
      }, function(w) {
        return i[w].data.getId(i[w].dataIndex);
      }).update(function(w, _) {
        y(x[w], b[_]);
      }).execute();
    }).execute(), s && P(e, function(x) {
      var b = x.data, w = b.hostModel, _ = w && t.getViewOfSeriesModel(w), S = mm("update", w, 0);
      _ && w.isAnimationEnabled() && S && S.duration > 0 && _.group.traverse(function(I) {
        I instanceof At && !I.animators.length && I.animateFrom({
          style: {
            opacity: 0
          }
        }, S);
      });
    });
  }
  function FG(n) {
    var e = n.getModel("universalTransition").get("seriesKey");
    return e || n.id;
  }
  function OG(n) {
    return de(n) ? n.sort().join(",") : n;
  }
  function Du(n) {
    if (n.hostModel) return n.hostModel.getModel("universalTransition").get("divideShape");
  }
  function w2e(n, e) {
    var t = Pe(), r = Pe(), i = Pe();
    return P(n.oldSeries, function(a, s) {
      var o = n.oldDataGroupIds[s], l = n.oldData[s], u = FG(a), c = OG(u);
      r.set(c, {
        dataGroupId: o,
        data: l
      }), de(u) && P(u, function(h) {
        i.set(h, {
          key: c,
          dataGroupId: o,
          data: l
        });
      });
    }), P(e.updatedSeries, function(a) {
      if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
        var s = a.get("dataGroupId"), o = a.getData(), l = FG(a), u = OG(l), c = r.get(u);
        if (c) t.set(u, {
          oldSeries: [
            {
              dataGroupId: c.dataGroupId,
              divide: Du(c.data),
              data: c.data
            }
          ],
          newSeries: [
            {
              dataGroupId: s,
              divide: Du(o),
              data: o
            }
          ]
        });
        else if (de(l)) {
          var h = [];
          P(l, function(p) {
            var g = r.get(p);
            g.data && h.push({
              dataGroupId: g.dataGroupId,
              divide: Du(g.data),
              data: g.data
            });
          }), h.length && t.set(u, {
            oldSeries: h,
            newSeries: [
              {
                dataGroupId: s,
                data: o,
                divide: Du(o)
              }
            ]
          });
        } else {
          var d = i.get(l);
          if (d) {
            var f = t.get(d.key);
            f || (f = {
              oldSeries: [
                {
                  dataGroupId: d.dataGroupId,
                  data: d.data,
                  divide: Du(d.data)
                }
              ],
              newSeries: []
            }, t.set(d.key, f)), f.newSeries.push({
              dataGroupId: s,
              data: o,
              divide: Du(o)
            });
          }
        }
      }
    }), t;
  }
  function BG(n, e) {
    for (var t = 0; t < n.length; t++) {
      var r = e.seriesIndex != null && e.seriesIndex === n[t].seriesIndex || e.seriesId != null && e.seriesId === n[t].id;
      if (r) return t;
    }
  }
  function _2e(n, e, t, r) {
    var i = [], a = [];
    P(xn(n.from), function(s) {
      var o = BG(e.oldSeries, s);
      o >= 0 && i.push({
        dataGroupId: e.oldDataGroupIds[o],
        data: e.oldData[o],
        divide: Du(e.oldData[o]),
        groupIdDim: s.dimension
      });
    }), P(xn(n.to), function(s) {
      var o = BG(t.updatedSeries, s);
      if (o >= 0) {
        var l = t.updatedSeries[o].getData();
        a.push({
          dataGroupId: e.oldDataGroupIds[o],
          data: l,
          divide: Du(l),
          groupIdDim: s.dimension
        });
      }
    }), i.length > 0 && a.length > 0 && QK(i, a, r);
  }
  function S2e(n) {
    n.registerUpdateLifecycle("series:beforeupdate", function(e, t, r) {
      P(xn(r.seriesTransition), function(i) {
        P(xn(i.to), function(a) {
          for (var s = r.updatedSeries, o = 0; o < s.length; o++) (a.seriesIndex != null && a.seriesIndex === s[o].seriesIndex || a.seriesId != null && a.seriesId === s[o].id) && (s[o][o_] = true);
        });
      });
    }), n.registerUpdateLifecycle("series:transition", function(e, t, r) {
      var i = m2e(t);
      if (i.oldSeries && r.updatedSeries && r.optionChanged) {
        var a = r.seriesTransition;
        if (a) P(xn(a), function(f) {
          _2e(f, i, r, t);
        });
        else {
          var s = w2e(i, r);
          P(s.keys(), function(f) {
            var p = s.get(f);
            QK(p.oldSeries, p.newSeries, t);
          });
        }
        P(r.updatedSeries, function(f) {
          f[o_] && (f[o_] = false);
        });
      }
      for (var o = e.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], h = 0; h < o.length; h++) {
        var d = o[h].getData();
        d.count() < ZK && (l.push(o[h]), u.push(o[h].get("dataGroupId")), c.push(d));
      }
    });
  }
  Ct([
    Ege
  ]);
  Ct([
    Age
  ]);
  Ct([
    Jge,
    pme,
    Cme,
    rve,
    pve,
    eye,
    Aye,
    h0e,
    E0e,
    B0e,
    q0e,
    Wxe,
    fbe,
    Cbe,
    zbe,
    Ube,
    e1e,
    o1e,
    y1e,
    C1e,
    M1e,
    vwe
  ]);
  Ct(Lwe);
  Ct(l_e);
  Ct(Kq);
  Ct(w_e);
  Ct(Pj);
  Ct(I_e);
  Ct(M_e);
  Ct(wSe);
  Ct(zSe);
  Ct(Kx);
  Ct(rCe);
  Ct(sCe);
  Ct(mCe);
  Ct(SCe);
  Ct(DCe);
  Ct(PCe);
  Ct(HCe);
  Ct(uIe);
  Ct(OK);
  Ct(BK);
  Ct(DIe);
  Ct(UK);
  Ct(HK);
  Ct(MIe);
  Ct(YIe);
  Ct(KIe);
  Ct(S2e);
  Ct(qpe);
  const C2e = (n) => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var fw = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };
  const I2e = ({ size: n, strokeWidth: e = 2, absoluteStrokeWidth: t, color: r, iconNode: i, name: a, class: s, ...o }, { slots: l }) => js("svg", {
    ...fw,
    width: n || fw.width,
    height: n || fw.height,
    stroke: r || fw.stroke,
    "stroke-width": t ? Number(e) * 24 / Number(n) : e,
    class: [
      "lucide",
      `lucide-${C2e(a ?? "icon")}`
    ],
    ...o
  }, [
    ...i.map((u) => js(...u)),
    ...l.default ? [
      l.default()
    ] : []
  ]);
  const LM = (n, e) => (t, { slots: r }) => js(I2e, {
    ...t,
    iconNode: e,
    name: n
  }, r);
  const k2e = LM("LoaderIcon", [
    [
      "path",
      {
        d: "M12 2v4",
        key: "3427ic"
      }
    ],
    [
      "path",
      {
        d: "m16.2 7.8 2.9-2.9",
        key: "r700ao"
      }
    ],
    [
      "path",
      {
        d: "M18 12h4",
        key: "wj9ykh"
      }
    ],
    [
      "path",
      {
        d: "m16.2 16.2 2.9 2.9",
        key: "1bxg5t"
      }
    ],
    [
      "path",
      {
        d: "M12 18v4",
        key: "jadmvz"
      }
    ],
    [
      "path",
      {
        d: "m4.9 19.1 2.9-2.9",
        key: "bwix9q"
      }
    ],
    [
      "path",
      {
        d: "M2 12h4",
        key: "j09sii"
      }
    ],
    [
      "path",
      {
        d: "m4.9 4.9 2.9 2.9",
        key: "giyufr"
      }
    ]
  ]);
  const T2e = LM("UploadIcon", [
    [
      "path",
      {
        d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
        key: "ih7n3h"
      }
    ],
    [
      "polyline",
      {
        points: "17 8 12 3 7 8",
        key: "t8dd8p"
      }
    ],
    [
      "line",
      {
        x1: "12",
        x2: "12",
        y1: "3",
        y2: "15",
        key: "widbto"
      }
    ]
  ]);
  const A2e = LM("XIcon", [
    [
      "path",
      {
        d: "M18 6 6 18",
        key: "1bl5f8"
      }
    ],
    [
      "path",
      {
        d: "m6 6 12 12",
        key: "d8bk6v"
      }
    ]
  ]);
  hse();
  function JK(n) {
    return typeof n > "u" || n === null;
  }
  function D2e(n) {
    return typeof n == "object" && n !== null;
  }
  function R2e(n) {
    return Array.isArray(n) ? n : JK(n) ? [] : [
      n
    ];
  }
  function $2e(n, e) {
    var t, r, i, a;
    if (e) for (a = Object.keys(e), t = 0, r = a.length; t < r; t += 1) i = a[t], n[i] = e[i];
    return n;
  }
  function N2e(n, e) {
    var t = "", r;
    for (r = 0; r < e; r += 1) t += n;
    return t;
  }
  function E2e(n) {
    return n === 0 && Number.NEGATIVE_INFINITY === 1 / n;
  }
  var M2e = JK, P2e = D2e, L2e = R2e, F2e = N2e, O2e = E2e, B2e = $2e, Br = {
    isNothing: M2e,
    isObject: P2e,
    toArray: L2e,
    repeat: F2e,
    isNegativeZero: O2e,
    extend: B2e
  };
  function e7(n, e) {
    var t = "", r = n.reason || "(unknown reason)";
    return n.mark ? (n.mark.name && (t += 'in "' + n.mark.name + '" '), t += "(" + (n.mark.line + 1) + ":" + (n.mark.column + 1) + ")", !e && n.mark.snippet && (t += `

` + n.mark.snippet), r + " " + t) : r;
  }
  function J0(n, e) {
    Error.call(this), this.name = "YAMLException", this.reason = n, this.mark = e, this.message = e7(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  J0.prototype = Object.create(Error.prototype);
  J0.prototype.constructor = J0;
  J0.prototype.toString = function(e) {
    return this.name + ": " + e7(this, e);
  };
  var qi = J0;
  function ZT(n, e, t, r, i) {
    var a = "", s = "", o = Math.floor(i / 2) - 1;
    return r - e > o && (a = " ... ", e = r - o + a.length), t - r > o && (s = " ...", t = r + o - s.length), {
      str: a + n.slice(e, t).replace(/\t/g, "\u2192") + s,
      pos: r - e + a.length
    };
  }
  function QT(n, e) {
    return Br.repeat(" ", e - n.length) + n;
  }
  function z2e(n, e) {
    if (e = Object.create(e || null), !n.buffer) return null;
    e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
    for (var t = /\r?\n|\r|\0/g, r = [
      0
    ], i = [], a, s = -1; a = t.exec(n.buffer); ) i.push(a.index), r.push(a.index + a[0].length), n.position <= a.index && s < 0 && (s = r.length - 2);
    s < 0 && (s = r.length - 1);
    var o = "", l, u, c = Math.min(n.line + e.linesAfter, i.length).toString().length, h = e.maxLength - (e.indent + c + 3);
    for (l = 1; l <= e.linesBefore && !(s - l < 0); l++) u = ZT(n.buffer, r[s - l], i[s - l], n.position - (r[s] - r[s - l]), h), o = Br.repeat(" ", e.indent) + QT((n.line - l + 1).toString(), c) + " | " + u.str + `
` + o;
    for (u = ZT(n.buffer, r[s], i[s], n.position, h), o += Br.repeat(" ", e.indent) + QT((n.line + 1).toString(), c) + " | " + u.str + `
`, o += Br.repeat("-", e.indent + c + 3 + u.pos) + `^
`, l = 1; l <= e.linesAfter && !(s + l >= i.length); l++) u = ZT(n.buffer, r[s + l], i[s + l], n.position - (r[s] - r[s + l]), h), o += Br.repeat(" ", e.indent) + QT((n.line + l + 1).toString(), c) + " | " + u.str + `
`;
    return o.replace(/\n$/, "");
  }
  var V2e = z2e, W2e = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ], G2e = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function U2e(n) {
    var e = {};
    return n !== null && Object.keys(n).forEach(function(t) {
      n[t].forEach(function(r) {
        e[String(r)] = t;
      });
    }), e;
  }
  function H2e(n, e) {
    if (e = e || {}, Object.keys(e).forEach(function(t) {
      if (W2e.indexOf(t) === -1) throw new qi('Unknown option "' + t + '" is met in definition of "' + n + '" YAML type.');
    }), this.options = e, this.tag = n, this.kind = e.kind || null, this.resolve = e.resolve || function() {
      return true;
    }, this.construct = e.construct || function(t) {
      return t;
    }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || false, this.styleAliases = U2e(e.styleAliases || null), G2e.indexOf(this.kind) === -1) throw new qi('Unknown kind "' + this.kind + '" is specified for "' + n + '" YAML type.');
  }
  var fi = H2e;
  function zG(n, e) {
    var t = [];
    return n[e].forEach(function(r) {
      var i = t.length;
      t.forEach(function(a, s) {
        a.tag === r.tag && a.kind === r.kind && a.multi === r.multi && (i = s);
      }), t[i] = r;
    }), t;
  }
  function X2e() {
    var n = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, e, t;
    function r(i) {
      i.multi ? (n.multi[i.kind].push(i), n.multi.fallback.push(i)) : n[i.kind][i.tag] = n.fallback[i.tag] = i;
    }
    for (e = 0, t = arguments.length; e < t; e += 1) arguments[e].forEach(r);
    return n;
  }
  function t$(n) {
    return this.extend(n);
  }
  t$.prototype.extend = function(e) {
    var t = [], r = [];
    if (e instanceof fi) r.push(e);
    else if (Array.isArray(e)) r = r.concat(e);
    else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit))) e.implicit && (t = t.concat(e.implicit)), e.explicit && (r = r.concat(e.explicit));
    else throw new qi("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    t.forEach(function(a) {
      if (!(a instanceof fi)) throw new qi("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      if (a.loadKind && a.loadKind !== "scalar") throw new qi("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      if (a.multi) throw new qi("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }), r.forEach(function(a) {
      if (!(a instanceof fi)) throw new qi("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    });
    var i = Object.create(t$.prototype);
    return i.implicit = (this.implicit || []).concat(t), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = zG(i, "implicit"), i.compiledExplicit = zG(i, "explicit"), i.compiledTypeMap = X2e(i.compiledImplicit, i.compiledExplicit), i;
  };
  var t7 = t$, n7 = new fi("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(n) {
      return n !== null ? n : "";
    }
  }), r7 = new fi("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(n) {
      return n !== null ? n : [];
    }
  }), i7 = new fi("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(n) {
      return n !== null ? n : {};
    }
  }), a7 = new t7({
    explicit: [
      n7,
      r7,
      i7
    ]
  });
  function Y2e(n) {
    if (n === null) return true;
    var e = n.length;
    return e === 1 && n === "~" || e === 4 && (n === "null" || n === "Null" || n === "NULL");
  }
  function q2e() {
    return null;
  }
  function j2e(n) {
    return n === null;
  }
  var s7 = new fi("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: Y2e,
    construct: q2e,
    predicate: j2e,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function K2e(n) {
    if (n === null) return false;
    var e = n.length;
    return e === 4 && (n === "true" || n === "True" || n === "TRUE") || e === 5 && (n === "false" || n === "False" || n === "FALSE");
  }
  function Z2e(n) {
    return n === "true" || n === "True" || n === "TRUE";
  }
  function Q2e(n) {
    return Object.prototype.toString.call(n) === "[object Boolean]";
  }
  var o7 = new fi("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: K2e,
    construct: Z2e,
    predicate: Q2e,
    represent: {
      lowercase: function(n) {
        return n ? "true" : "false";
      },
      uppercase: function(n) {
        return n ? "TRUE" : "FALSE";
      },
      camelcase: function(n) {
        return n ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function J2e(n) {
    return 48 <= n && n <= 57 || 65 <= n && n <= 70 || 97 <= n && n <= 102;
  }
  function eke(n) {
    return 48 <= n && n <= 55;
  }
  function tke(n) {
    return 48 <= n && n <= 57;
  }
  function nke(n) {
    if (n === null) return false;
    var e = n.length, t = 0, r = false, i;
    if (!e) return false;
    if (i = n[t], (i === "-" || i === "+") && (i = n[++t]), i === "0") {
      if (t + 1 === e) return true;
      if (i = n[++t], i === "b") {
        for (t++; t < e; t++) if (i = n[t], i !== "_") {
          if (i !== "0" && i !== "1") return false;
          r = true;
        }
        return r && i !== "_";
      }
      if (i === "x") {
        for (t++; t < e; t++) if (i = n[t], i !== "_") {
          if (!J2e(n.charCodeAt(t))) return false;
          r = true;
        }
        return r && i !== "_";
      }
      if (i === "o") {
        for (t++; t < e; t++) if (i = n[t], i !== "_") {
          if (!eke(n.charCodeAt(t))) return false;
          r = true;
        }
        return r && i !== "_";
      }
    }
    if (i === "_") return false;
    for (; t < e; t++) if (i = n[t], i !== "_") {
      if (!tke(n.charCodeAt(t))) return false;
      r = true;
    }
    return !(!r || i === "_");
  }
  function rke(n) {
    var e = n, t = 1, r;
    if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), r = e[0], (r === "-" || r === "+") && (r === "-" && (t = -1), e = e.slice(1), r = e[0]), e === "0") return 0;
    if (r === "0") {
      if (e[1] === "b") return t * parseInt(e.slice(2), 2);
      if (e[1] === "x") return t * parseInt(e.slice(2), 16);
      if (e[1] === "o") return t * parseInt(e.slice(2), 8);
    }
    return t * parseInt(e, 10);
  }
  function ike(n) {
    return Object.prototype.toString.call(n) === "[object Number]" && n % 1 === 0 && !Br.isNegativeZero(n);
  }
  var l7 = new fi("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: nke,
    construct: rke,
    predicate: ike,
    represent: {
      binary: function(n) {
        return n >= 0 ? "0b" + n.toString(2) : "-0b" + n.toString(2).slice(1);
      },
      octal: function(n) {
        return n >= 0 ? "0o" + n.toString(8) : "-0o" + n.toString(8).slice(1);
      },
      decimal: function(n) {
        return n.toString(10);
      },
      hexadecimal: function(n) {
        return n >= 0 ? "0x" + n.toString(16).toUpperCase() : "-0x" + n.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [
        2,
        "bin"
      ],
      octal: [
        8,
        "oct"
      ],
      decimal: [
        10,
        "dec"
      ],
      hexadecimal: [
        16,
        "hex"
      ]
    }
  }), ake = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
  function ske(n) {
    return !(n === null || !ake.test(n) || n[n.length - 1] === "_");
  }
  function oke(n) {
    var e, t;
    return e = n.replace(/_/g, "").toLowerCase(), t = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? t === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : t * parseFloat(e, 10);
  }
  var lke = /^[-+]?[0-9]+e/;
  function uke(n, e) {
    var t;
    if (isNaN(n)) switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
    else if (Number.POSITIVE_INFINITY === n) switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
    else if (Number.NEGATIVE_INFINITY === n) switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
    else if (Br.isNegativeZero(n)) return "-0.0";
    return t = n.toString(10), lke.test(t) ? t.replace("e", ".e") : t;
  }
  function cke(n) {
    return Object.prototype.toString.call(n) === "[object Number]" && (n % 1 !== 0 || Br.isNegativeZero(n));
  }
  var u7 = new fi("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: ske,
    construct: oke,
    predicate: cke,
    represent: uke,
    defaultStyle: "lowercase"
  }), c7 = a7.extend({
    implicit: [
      s7,
      o7,
      l7,
      u7
    ]
  }), h7 = c7, d7 = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), f7 = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
  function hke(n) {
    return n === null ? false : d7.exec(n) !== null || f7.exec(n) !== null;
  }
  function dke(n) {
    var e, t, r, i, a, s, o, l = 0, u = null, c, h, d;
    if (e = d7.exec(n), e === null && (e = f7.exec(n)), e === null) throw new Error("Date resolve error");
    if (t = +e[1], r = +e[2] - 1, i = +e[3], !e[4]) return new Date(Date.UTC(t, r, i));
    if (a = +e[4], s = +e[5], o = +e[6], e[7]) {
      for (l = e[7].slice(0, 3); l.length < 3; ) l += "0";
      l = +l;
    }
    return e[9] && (c = +e[10], h = +(e[11] || 0), u = (c * 60 + h) * 6e4, e[9] === "-" && (u = -u)), d = new Date(Date.UTC(t, r, i, a, s, o, l)), u && d.setTime(d.getTime() - u), d;
  }
  function fke(n) {
    return n.toISOString();
  }
  var p7 = new fi("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: hke,
    construct: dke,
    instanceOf: Date,
    represent: fke
  });
  function pke(n) {
    return n === "<<" || n === null;
  }
  var g7 = new fi("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: pke
  }), FM = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function gke(n) {
    if (n === null) return false;
    var e, t, r = 0, i = n.length, a = FM;
    for (t = 0; t < i; t++) if (e = a.indexOf(n.charAt(t)), !(e > 64)) {
      if (e < 0) return false;
      r += 6;
    }
    return r % 8 === 0;
  }
  function mke(n) {
    var e, t, r = n.replace(/[\r\n=]/g, ""), i = r.length, a = FM, s = 0, o = [];
    for (e = 0; e < i; e++) e % 4 === 0 && e && (o.push(s >> 16 & 255), o.push(s >> 8 & 255), o.push(s & 255)), s = s << 6 | a.indexOf(r.charAt(e));
    return t = i % 4 * 6, t === 0 ? (o.push(s >> 16 & 255), o.push(s >> 8 & 255), o.push(s & 255)) : t === 18 ? (o.push(s >> 10 & 255), o.push(s >> 2 & 255)) : t === 12 && o.push(s >> 4 & 255), new Uint8Array(o);
  }
  function vke(n) {
    var e = "", t = 0, r, i, a = n.length, s = FM;
    for (r = 0; r < a; r++) r % 3 === 0 && r && (e += s[t >> 18 & 63], e += s[t >> 12 & 63], e += s[t >> 6 & 63], e += s[t & 63]), t = (t << 8) + n[r];
    return i = a % 3, i === 0 ? (e += s[t >> 18 & 63], e += s[t >> 12 & 63], e += s[t >> 6 & 63], e += s[t & 63]) : i === 2 ? (e += s[t >> 10 & 63], e += s[t >> 4 & 63], e += s[t << 2 & 63], e += s[64]) : i === 1 && (e += s[t >> 2 & 63], e += s[t << 4 & 63], e += s[64], e += s[64]), e;
  }
  function yke(n) {
    return Object.prototype.toString.call(n) === "[object Uint8Array]";
  }
  var m7 = new fi("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: gke,
    construct: mke,
    predicate: yke,
    represent: vke
  }), xke = Object.prototype.hasOwnProperty, bke = Object.prototype.toString;
  function wke(n) {
    if (n === null) return true;
    var e = [], t, r, i, a, s, o = n;
    for (t = 0, r = o.length; t < r; t += 1) {
      if (i = o[t], s = false, bke.call(i) !== "[object Object]") return false;
      for (a in i) if (xke.call(i, a)) if (!s) s = true;
      else return false;
      if (!s) return false;
      if (e.indexOf(a) === -1) e.push(a);
      else return false;
    }
    return true;
  }
  function _ke(n) {
    return n !== null ? n : [];
  }
  var v7 = new fi("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: wke,
    construct: _ke
  }), Ske = Object.prototype.toString;
  function Cke(n) {
    if (n === null) return true;
    var e, t, r, i, a, s = n;
    for (a = new Array(s.length), e = 0, t = s.length; e < t; e += 1) {
      if (r = s[e], Ske.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1)) return false;
      a[e] = [
        i[0],
        r[i[0]]
      ];
    }
    return true;
  }
  function Ike(n) {
    if (n === null) return [];
    var e, t, r, i, a, s = n;
    for (a = new Array(s.length), e = 0, t = s.length; e < t; e += 1) r = s[e], i = Object.keys(r), a[e] = [
      i[0],
      r[i[0]]
    ];
    return a;
  }
  var y7 = new fi("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: Cke,
    construct: Ike
  }), kke = Object.prototype.hasOwnProperty;
  function Tke(n) {
    if (n === null) return true;
    var e, t = n;
    for (e in t) if (kke.call(t, e) && t[e] !== null) return false;
    return true;
  }
  function Ake(n) {
    return n !== null ? n : {};
  }
  var x7 = new fi("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: Tke,
    construct: Ake
  }), OM = h7.extend({
    implicit: [
      p7,
      g7
    ],
    explicit: [
      m7,
      v7,
      y7,
      x7
    ]
  }), oc = Object.prototype.hasOwnProperty, SS = 1, b7 = 2, w7 = 3, CS = 4, JT = 1, Dke = 2, VG = 3, Rke = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, $ke = /[\x85\u2028\u2029]/, Nke = /[,\[\]\{\}]/, _7 = /^(?:!|!!|![a-z\-]+!)$/i, S7 = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function WG(n) {
    return Object.prototype.toString.call(n);
  }
  function Xo(n) {
    return n === 10 || n === 13;
  }
  function rd(n) {
    return n === 9 || n === 32;
  }
  function _a(n) {
    return n === 9 || n === 32 || n === 10 || n === 13;
  }
  function xg(n) {
    return n === 44 || n === 91 || n === 93 || n === 123 || n === 125;
  }
  function Eke(n) {
    var e;
    return 48 <= n && n <= 57 ? n - 48 : (e = n | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
  }
  function Mke(n) {
    return n === 120 ? 2 : n === 117 ? 4 : n === 85 ? 8 : 0;
  }
  function Pke(n) {
    return 48 <= n && n <= 57 ? n - 48 : -1;
  }
  function GG(n) {
    return n === 48 ? "\0" : n === 97 ? "\x07" : n === 98 ? "\b" : n === 116 || n === 9 ? "	" : n === 110 ? `
` : n === 118 ? "\v" : n === 102 ? "\f" : n === 114 ? "\r" : n === 101 ? "\x1B" : n === 32 ? " " : n === 34 ? '"' : n === 47 ? "/" : n === 92 ? "\\" : n === 78 ? "\x85" : n === 95 ? "\xA0" : n === 76 ? "\u2028" : n === 80 ? "\u2029" : "";
  }
  function Lke(n) {
    return n <= 65535 ? String.fromCharCode(n) : String.fromCharCode((n - 65536 >> 10) + 55296, (n - 65536 & 1023) + 56320);
  }
  var C7 = new Array(256), I7 = new Array(256);
  for (var Xp = 0; Xp < 256; Xp++) C7[Xp] = GG(Xp) ? 1 : 0, I7[Xp] = GG(Xp);
  function Fke(n, e) {
    this.input = n, this.filename = e.filename || null, this.schema = e.schema || OM, this.onWarning = e.onWarning || null, this.legacy = e.legacy || false, this.json = e.json || false, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = n.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
  }
  function k7(n, e) {
    var t = {
      name: n.filename,
      buffer: n.input.slice(0, -1),
      position: n.position,
      line: n.line,
      column: n.position - n.lineStart
    };
    return t.snippet = V2e(t), new qi(e, t);
  }
  function ut(n, e) {
    throw k7(n, e);
  }
  function IS(n, e) {
    n.onWarning && n.onWarning.call(null, k7(n, e));
  }
  var UG = {
    YAML: function(e, t, r) {
      var i, a, s;
      e.version !== null && ut(e, "duplication of %YAML directive"), r.length !== 1 && ut(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && ut(e, "ill-formed argument of the YAML directive"), a = parseInt(i[1], 10), s = parseInt(i[2], 10), a !== 1 && ut(e, "unacceptable YAML version of the document"), e.version = r[0], e.checkLineBreaks = s < 2, s !== 1 && s !== 2 && IS(e, "unsupported YAML version of the document");
    },
    TAG: function(e, t, r) {
      var i, a;
      r.length !== 2 && ut(e, "TAG directive accepts exactly two arguments"), i = r[0], a = r[1], _7.test(i) || ut(e, "ill-formed tag handle (first argument) of the TAG directive"), oc.call(e.tagMap, i) && ut(e, 'there is a previously declared suffix for "' + i + '" tag handle'), S7.test(a) || ut(e, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        a = decodeURIComponent(a);
      } catch {
        ut(e, "tag prefix is malformed: " + a);
      }
      e.tagMap[i] = a;
    }
  };
  function ju(n, e, t, r) {
    var i, a, s, o;
    if (e < t) {
      if (o = n.input.slice(e, t), r) for (i = 0, a = o.length; i < a; i += 1) s = o.charCodeAt(i), s === 9 || 32 <= s && s <= 1114111 || ut(n, "expected valid JSON character");
      else Rke.test(o) && ut(n, "the stream contains non-printable characters");
      n.result += o;
    }
  }
  function HG(n, e, t, r) {
    var i, a, s, o;
    for (Br.isObject(t) || ut(n, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(t), s = 0, o = i.length; s < o; s += 1) a = i[s], oc.call(e, a) || (e[a] = t[a], r[a] = true);
  }
  function bg(n, e, t, r, i, a, s, o, l) {
    var u, c;
    if (Array.isArray(i)) for (i = Array.prototype.slice.call(i), u = 0, c = i.length; u < c; u += 1) Array.isArray(i[u]) && ut(n, "nested arrays are not supported inside keys"), typeof i == "object" && WG(i[u]) === "[object Object]" && (i[u] = "[object Object]");
    if (typeof i == "object" && WG(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), r === "tag:yaml.org,2002:merge") if (Array.isArray(a)) for (u = 0, c = a.length; u < c; u += 1) HG(n, e, a[u], t);
    else HG(n, e, a, t);
    else !n.json && !oc.call(t, i) && oc.call(e, i) && (n.line = s || n.line, n.lineStart = o || n.lineStart, n.position = l || n.position, ut(n, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: true,
      enumerable: true,
      writable: true,
      value: a
    }) : e[i] = a, delete t[i];
    return e;
  }
  function BM(n) {
    var e;
    e = n.input.charCodeAt(n.position), e === 10 ? n.position++ : e === 13 ? (n.position++, n.input.charCodeAt(n.position) === 10 && n.position++) : ut(n, "a line break is expected"), n.line += 1, n.lineStart = n.position, n.firstTabInLine = -1;
  }
  function Sr(n, e, t) {
    for (var r = 0, i = n.input.charCodeAt(n.position); i !== 0; ) {
      for (; rd(i); ) i === 9 && n.firstTabInLine === -1 && (n.firstTabInLine = n.position), i = n.input.charCodeAt(++n.position);
      if (e && i === 35) do
        i = n.input.charCodeAt(++n.position);
      while (i !== 10 && i !== 13 && i !== 0);
      if (Xo(i)) for (BM(n), i = n.input.charCodeAt(n.position), r++, n.lineIndent = 0; i === 32; ) n.lineIndent++, i = n.input.charCodeAt(++n.position);
      else break;
    }
    return t !== -1 && r !== 0 && n.lineIndent < t && IS(n, "deficient indentation"), r;
  }
  function KC(n) {
    var e = n.position, t;
    return t = n.input.charCodeAt(e), !!((t === 45 || t === 46) && t === n.input.charCodeAt(e + 1) && t === n.input.charCodeAt(e + 2) && (e += 3, t = n.input.charCodeAt(e), t === 0 || _a(t)));
  }
  function zM(n, e) {
    e === 1 ? n.result += " " : e > 1 && (n.result += Br.repeat(`
`, e - 1));
  }
  function Oke(n, e, t) {
    var r, i, a, s, o, l, u, c, h = n.kind, d = n.result, f;
    if (f = n.input.charCodeAt(n.position), _a(f) || xg(f) || f === 35 || f === 38 || f === 42 || f === 33 || f === 124 || f === 62 || f === 39 || f === 34 || f === 37 || f === 64 || f === 96 || (f === 63 || f === 45) && (i = n.input.charCodeAt(n.position + 1), _a(i) || t && xg(i))) return false;
    for (n.kind = "scalar", n.result = "", a = s = n.position, o = false; f !== 0; ) {
      if (f === 58) {
        if (i = n.input.charCodeAt(n.position + 1), _a(i) || t && xg(i)) break;
      } else if (f === 35) {
        if (r = n.input.charCodeAt(n.position - 1), _a(r)) break;
      } else {
        if (n.position === n.lineStart && KC(n) || t && xg(f)) break;
        if (Xo(f)) if (l = n.line, u = n.lineStart, c = n.lineIndent, Sr(n, false, -1), n.lineIndent >= e) {
          o = true, f = n.input.charCodeAt(n.position);
          continue;
        } else {
          n.position = s, n.line = l, n.lineStart = u, n.lineIndent = c;
          break;
        }
      }
      o && (ju(n, a, s, false), zM(n, n.line - l), a = s = n.position, o = false), rd(f) || (s = n.position + 1), f = n.input.charCodeAt(++n.position);
    }
    return ju(n, a, s, false), n.result ? true : (n.kind = h, n.result = d, false);
  }
  function Bke(n, e) {
    var t, r, i;
    if (t = n.input.charCodeAt(n.position), t !== 39) return false;
    for (n.kind = "scalar", n.result = "", n.position++, r = i = n.position; (t = n.input.charCodeAt(n.position)) !== 0; ) if (t === 39) if (ju(n, r, n.position, true), t = n.input.charCodeAt(++n.position), t === 39) r = n.position, n.position++, i = n.position;
    else return true;
    else Xo(t) ? (ju(n, r, i, true), zM(n, Sr(n, false, e)), r = i = n.position) : n.position === n.lineStart && KC(n) ? ut(n, "unexpected end of the document within a single quoted scalar") : (n.position++, i = n.position);
    ut(n, "unexpected end of the stream within a single quoted scalar");
  }
  function zke(n, e) {
    var t, r, i, a, s, o;
    if (o = n.input.charCodeAt(n.position), o !== 34) return false;
    for (n.kind = "scalar", n.result = "", n.position++, t = r = n.position; (o = n.input.charCodeAt(n.position)) !== 0; ) {
      if (o === 34) return ju(n, t, n.position, true), n.position++, true;
      if (o === 92) {
        if (ju(n, t, n.position, true), o = n.input.charCodeAt(++n.position), Xo(o)) Sr(n, false, e);
        else if (o < 256 && C7[o]) n.result += I7[o], n.position++;
        else if ((s = Mke(o)) > 0) {
          for (i = s, a = 0; i > 0; i--) o = n.input.charCodeAt(++n.position), (s = Eke(o)) >= 0 ? a = (a << 4) + s : ut(n, "expected hexadecimal character");
          n.result += Lke(a), n.position++;
        } else ut(n, "unknown escape sequence");
        t = r = n.position;
      } else Xo(o) ? (ju(n, t, r, true), zM(n, Sr(n, false, e)), t = r = n.position) : n.position === n.lineStart && KC(n) ? ut(n, "unexpected end of the document within a double quoted scalar") : (n.position++, r = n.position);
    }
    ut(n, "unexpected end of the stream within a double quoted scalar");
  }
  function Vke(n, e) {
    var t = true, r, i, a, s = n.tag, o, l = n.anchor, u, c, h, d, f, p = /* @__PURE__ */ Object.create(null), g, m, v, y;
    if (y = n.input.charCodeAt(n.position), y === 91) c = 93, f = false, o = [];
    else if (y === 123) c = 125, f = true, o = {};
    else return false;
    for (n.anchor !== null && (n.anchorMap[n.anchor] = o), y = n.input.charCodeAt(++n.position); y !== 0; ) {
      if (Sr(n, true, e), y = n.input.charCodeAt(n.position), y === c) return n.position++, n.tag = s, n.anchor = l, n.kind = f ? "mapping" : "sequence", n.result = o, true;
      t ? y === 44 && ut(n, "expected the node content, but found ','") : ut(n, "missed comma between flow collection entries"), m = g = v = null, h = d = false, y === 63 && (u = n.input.charCodeAt(n.position + 1), _a(u) && (h = d = true, n.position++, Sr(n, true, e))), r = n.line, i = n.lineStart, a = n.position, Gg(n, e, SS, false, true), m = n.tag, g = n.result, Sr(n, true, e), y = n.input.charCodeAt(n.position), (d || n.line === r) && y === 58 && (h = true, y = n.input.charCodeAt(++n.position), Sr(n, true, e), Gg(n, e, SS, false, true), v = n.result), f ? bg(n, o, p, m, g, v, r, i, a) : h ? o.push(bg(n, null, p, m, g, v, r, i, a)) : o.push(g), Sr(n, true, e), y = n.input.charCodeAt(n.position), y === 44 ? (t = true, y = n.input.charCodeAt(++n.position)) : t = false;
    }
    ut(n, "unexpected end of the stream within a flow collection");
  }
  function Wke(n, e) {
    var t, r, i = JT, a = false, s = false, o = e, l = 0, u = false, c, h;
    if (h = n.input.charCodeAt(n.position), h === 124) r = false;
    else if (h === 62) r = true;
    else return false;
    for (n.kind = "scalar", n.result = ""; h !== 0; ) if (h = n.input.charCodeAt(++n.position), h === 43 || h === 45) JT === i ? i = h === 43 ? VG : Dke : ut(n, "repeat of a chomping mode identifier");
    else if ((c = Pke(h)) >= 0) c === 0 ? ut(n, "bad explicit indentation width of a block scalar; it cannot be less than one") : s ? ut(n, "repeat of an indentation width identifier") : (o = e + c - 1, s = true);
    else break;
    if (rd(h)) {
      do
        h = n.input.charCodeAt(++n.position);
      while (rd(h));
      if (h === 35) do
        h = n.input.charCodeAt(++n.position);
      while (!Xo(h) && h !== 0);
    }
    for (; h !== 0; ) {
      for (BM(n), n.lineIndent = 0, h = n.input.charCodeAt(n.position); (!s || n.lineIndent < o) && h === 32; ) n.lineIndent++, h = n.input.charCodeAt(++n.position);
      if (!s && n.lineIndent > o && (o = n.lineIndent), Xo(h)) {
        l++;
        continue;
      }
      if (n.lineIndent < o) {
        i === VG ? n.result += Br.repeat(`
`, a ? 1 + l : l) : i === JT && a && (n.result += `
`);
        break;
      }
      for (r ? rd(h) ? (u = true, n.result += Br.repeat(`
`, a ? 1 + l : l)) : u ? (u = false, n.result += Br.repeat(`
`, l + 1)) : l === 0 ? a && (n.result += " ") : n.result += Br.repeat(`
`, l) : n.result += Br.repeat(`
`, a ? 1 + l : l), a = true, s = true, l = 0, t = n.position; !Xo(h) && h !== 0; ) h = n.input.charCodeAt(++n.position);
      ju(n, t, n.position, false);
    }
    return true;
  }
  function XG(n, e) {
    var t, r = n.tag, i = n.anchor, a = [], s, o = false, l;
    if (n.firstTabInLine !== -1) return false;
    for (n.anchor !== null && (n.anchorMap[n.anchor] = a), l = n.input.charCodeAt(n.position); l !== 0 && (n.firstTabInLine !== -1 && (n.position = n.firstTabInLine, ut(n, "tab characters must not be used in indentation")), !(l !== 45 || (s = n.input.charCodeAt(n.position + 1), !_a(s)))); ) {
      if (o = true, n.position++, Sr(n, true, -1) && n.lineIndent <= e) {
        a.push(null), l = n.input.charCodeAt(n.position);
        continue;
      }
      if (t = n.line, Gg(n, e, w7, false, true), a.push(n.result), Sr(n, true, -1), l = n.input.charCodeAt(n.position), (n.line === t || n.lineIndent > e) && l !== 0) ut(n, "bad indentation of a sequence entry");
      else if (n.lineIndent < e) break;
    }
    return o ? (n.tag = r, n.anchor = i, n.kind = "sequence", n.result = a, true) : false;
  }
  function Gke(n, e, t) {
    var r, i, a, s, o, l, u = n.tag, c = n.anchor, h = {}, d = /* @__PURE__ */ Object.create(null), f = null, p = null, g = null, m = false, v = false, y;
    if (n.firstTabInLine !== -1) return false;
    for (n.anchor !== null && (n.anchorMap[n.anchor] = h), y = n.input.charCodeAt(n.position); y !== 0; ) {
      if (!m && n.firstTabInLine !== -1 && (n.position = n.firstTabInLine, ut(n, "tab characters must not be used in indentation")), r = n.input.charCodeAt(n.position + 1), a = n.line, (y === 63 || y === 58) && _a(r)) y === 63 ? (m && (bg(n, h, d, f, p, null, s, o, l), f = p = g = null), v = true, m = true, i = true) : m ? (m = false, i = true) : ut(n, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), n.position += 1, y = r;
      else {
        if (s = n.line, o = n.lineStart, l = n.position, !Gg(n, t, b7, false, true)) break;
        if (n.line === a) {
          for (y = n.input.charCodeAt(n.position); rd(y); ) y = n.input.charCodeAt(++n.position);
          if (y === 58) y = n.input.charCodeAt(++n.position), _a(y) || ut(n, "a whitespace character is expected after the key-value separator within a block mapping"), m && (bg(n, h, d, f, p, null, s, o, l), f = p = g = null), v = true, m = false, i = false, f = n.tag, p = n.result;
          else if (v) ut(n, "can not read an implicit mapping pair; a colon is missed");
          else return n.tag = u, n.anchor = c, true;
        } else if (v) ut(n, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else return n.tag = u, n.anchor = c, true;
      }
      if ((n.line === a || n.lineIndent > e) && (m && (s = n.line, o = n.lineStart, l = n.position), Gg(n, e, CS, true, i) && (m ? p = n.result : g = n.result), m || (bg(n, h, d, f, p, g, s, o, l), f = p = g = null), Sr(n, true, -1), y = n.input.charCodeAt(n.position)), (n.line === a || n.lineIndent > e) && y !== 0) ut(n, "bad indentation of a mapping entry");
      else if (n.lineIndent < e) break;
    }
    return m && bg(n, h, d, f, p, null, s, o, l), v && (n.tag = u, n.anchor = c, n.kind = "mapping", n.result = h), v;
  }
  function Uke(n) {
    var e, t = false, r = false, i, a, s;
    if (s = n.input.charCodeAt(n.position), s !== 33) return false;
    if (n.tag !== null && ut(n, "duplication of a tag property"), s = n.input.charCodeAt(++n.position), s === 60 ? (t = true, s = n.input.charCodeAt(++n.position)) : s === 33 ? (r = true, i = "!!", s = n.input.charCodeAt(++n.position)) : i = "!", e = n.position, t) {
      do
        s = n.input.charCodeAt(++n.position);
      while (s !== 0 && s !== 62);
      n.position < n.length ? (a = n.input.slice(e, n.position), s = n.input.charCodeAt(++n.position)) : ut(n, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; s !== 0 && !_a(s); ) s === 33 && (r ? ut(n, "tag suffix cannot contain exclamation marks") : (i = n.input.slice(e - 1, n.position + 1), _7.test(i) || ut(n, "named tag handle cannot contain such characters"), r = true, e = n.position + 1)), s = n.input.charCodeAt(++n.position);
      a = n.input.slice(e, n.position), Nke.test(a) && ut(n, "tag suffix cannot contain flow indicator characters");
    }
    a && !S7.test(a) && ut(n, "tag name cannot contain such characters: " + a);
    try {
      a = decodeURIComponent(a);
    } catch {
      ut(n, "tag name is malformed: " + a);
    }
    return t ? n.tag = a : oc.call(n.tagMap, i) ? n.tag = n.tagMap[i] + a : i === "!" ? n.tag = "!" + a : i === "!!" ? n.tag = "tag:yaml.org,2002:" + a : ut(n, 'undeclared tag handle "' + i + '"'), true;
  }
  function Hke(n) {
    var e, t;
    if (t = n.input.charCodeAt(n.position), t !== 38) return false;
    for (n.anchor !== null && ut(n, "duplication of an anchor property"), t = n.input.charCodeAt(++n.position), e = n.position; t !== 0 && !_a(t) && !xg(t); ) t = n.input.charCodeAt(++n.position);
    return n.position === e && ut(n, "name of an anchor node must contain at least one character"), n.anchor = n.input.slice(e, n.position), true;
  }
  function Xke(n) {
    var e, t, r;
    if (r = n.input.charCodeAt(n.position), r !== 42) return false;
    for (r = n.input.charCodeAt(++n.position), e = n.position; r !== 0 && !_a(r) && !xg(r); ) r = n.input.charCodeAt(++n.position);
    return n.position === e && ut(n, "name of an alias node must contain at least one character"), t = n.input.slice(e, n.position), oc.call(n.anchorMap, t) || ut(n, 'unidentified alias "' + t + '"'), n.result = n.anchorMap[t], Sr(n, true, -1), true;
  }
  function Gg(n, e, t, r, i) {
    var a, s, o, l = 1, u = false, c = false, h, d, f, p, g, m;
    if (n.listener !== null && n.listener("open", n), n.tag = null, n.anchor = null, n.kind = null, n.result = null, a = s = o = CS === t || w7 === t, r && Sr(n, true, -1) && (u = true, n.lineIndent > e ? l = 1 : n.lineIndent === e ? l = 0 : n.lineIndent < e && (l = -1)), l === 1) for (; Uke(n) || Hke(n); ) Sr(n, true, -1) ? (u = true, o = a, n.lineIndent > e ? l = 1 : n.lineIndent === e ? l = 0 : n.lineIndent < e && (l = -1)) : o = false;
    if (o && (o = u || i), (l === 1 || CS === t) && (SS === t || b7 === t ? g = e : g = e + 1, m = n.position - n.lineStart, l === 1 ? o && (XG(n, m) || Gke(n, m, g)) || Vke(n, g) ? c = true : (s && Wke(n, g) || Bke(n, g) || zke(n, g) ? c = true : Xke(n) ? (c = true, (n.tag !== null || n.anchor !== null) && ut(n, "alias node should not have any properties")) : Oke(n, g, SS === t) && (c = true, n.tag === null && (n.tag = "?")), n.anchor !== null && (n.anchorMap[n.anchor] = n.result)) : l === 0 && (c = o && XG(n, m))), n.tag === null) n.anchor !== null && (n.anchorMap[n.anchor] = n.result);
    else if (n.tag === "?") {
      for (n.result !== null && n.kind !== "scalar" && ut(n, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + n.kind + '"'), h = 0, d = n.implicitTypes.length; h < d; h += 1) if (p = n.implicitTypes[h], p.resolve(n.result)) {
        n.result = p.construct(n.result), n.tag = p.tag, n.anchor !== null && (n.anchorMap[n.anchor] = n.result);
        break;
      }
    } else if (n.tag !== "!") {
      if (oc.call(n.typeMap[n.kind || "fallback"], n.tag)) p = n.typeMap[n.kind || "fallback"][n.tag];
      else for (p = null, f = n.typeMap.multi[n.kind || "fallback"], h = 0, d = f.length; h < d; h += 1) if (n.tag.slice(0, f[h].tag.length) === f[h].tag) {
        p = f[h];
        break;
      }
      p || ut(n, "unknown tag !<" + n.tag + ">"), n.result !== null && p.kind !== n.kind && ut(n, "unacceptable node kind for !<" + n.tag + '> tag; it should be "' + p.kind + '", not "' + n.kind + '"'), p.resolve(n.result, n.tag) ? (n.result = p.construct(n.result, n.tag), n.anchor !== null && (n.anchorMap[n.anchor] = n.result)) : ut(n, "cannot resolve a node with !<" + n.tag + "> explicit tag");
    }
    return n.listener !== null && n.listener("close", n), n.tag !== null || n.anchor !== null || c;
  }
  function Yke(n) {
    var e = n.position, t, r, i, a = false, s;
    for (n.version = null, n.checkLineBreaks = n.legacy, n.tagMap = /* @__PURE__ */ Object.create(null), n.anchorMap = /* @__PURE__ */ Object.create(null); (s = n.input.charCodeAt(n.position)) !== 0 && (Sr(n, true, -1), s = n.input.charCodeAt(n.position), !(n.lineIndent > 0 || s !== 37)); ) {
      for (a = true, s = n.input.charCodeAt(++n.position), t = n.position; s !== 0 && !_a(s); ) s = n.input.charCodeAt(++n.position);
      for (r = n.input.slice(t, n.position), i = [], r.length < 1 && ut(n, "directive name must not be less than one character in length"); s !== 0; ) {
        for (; rd(s); ) s = n.input.charCodeAt(++n.position);
        if (s === 35) {
          do
            s = n.input.charCodeAt(++n.position);
          while (s !== 0 && !Xo(s));
          break;
        }
        if (Xo(s)) break;
        for (t = n.position; s !== 0 && !_a(s); ) s = n.input.charCodeAt(++n.position);
        i.push(n.input.slice(t, n.position));
      }
      s !== 0 && BM(n), oc.call(UG, r) ? UG[r](n, r, i) : IS(n, 'unknown document directive "' + r + '"');
    }
    if (Sr(n, true, -1), n.lineIndent === 0 && n.input.charCodeAt(n.position) === 45 && n.input.charCodeAt(n.position + 1) === 45 && n.input.charCodeAt(n.position + 2) === 45 ? (n.position += 3, Sr(n, true, -1)) : a && ut(n, "directives end mark is expected"), Gg(n, n.lineIndent - 1, CS, false, true), Sr(n, true, -1), n.checkLineBreaks && $ke.test(n.input.slice(e, n.position)) && IS(n, "non-ASCII line breaks are interpreted as content"), n.documents.push(n.result), n.position === n.lineStart && KC(n)) {
      n.input.charCodeAt(n.position) === 46 && (n.position += 3, Sr(n, true, -1));
      return;
    }
    if (n.position < n.length - 1) ut(n, "end of the stream or a document separator is expected");
    else return;
  }
  function T7(n, e) {
    n = String(n), e = e || {}, n.length !== 0 && (n.charCodeAt(n.length - 1) !== 10 && n.charCodeAt(n.length - 1) !== 13 && (n += `
`), n.charCodeAt(0) === 65279 && (n = n.slice(1)));
    var t = new Fke(n, e), r = n.indexOf("\0");
    for (r !== -1 && (t.position = r, ut(t, "null byte is not allowed in input")), t.input += "\0"; t.input.charCodeAt(t.position) === 32; ) t.lineIndent += 1, t.position += 1;
    for (; t.position < t.length - 1; ) Yke(t);
    return t.documents;
  }
  function qke(n, e, t) {
    e !== null && typeof e == "object" && typeof t > "u" && (t = e, e = null);
    var r = T7(n, t);
    if (typeof e != "function") return r;
    for (var i = 0, a = r.length; i < a; i += 1) e(r[i]);
  }
  function jke(n, e) {
    var t = T7(n, e);
    if (t.length !== 0) {
      if (t.length === 1) return t[0];
      throw new qi("expected a single document in the stream, but found more");
    }
  }
  var Kke = qke, Zke = jke, A7 = {
    loadAll: Kke,
    load: Zke
  }, D7 = Object.prototype.toString, R7 = Object.prototype.hasOwnProperty, VM = 65279, Qke = 9, ex = 10, Jke = 13, eTe = 32, tTe = 33, nTe = 34, n$ = 35, rTe = 37, iTe = 38, aTe = 39, sTe = 42, $7 = 44, oTe = 45, kS = 58, lTe = 61, uTe = 62, cTe = 63, hTe = 64, N7 = 91, E7 = 93, dTe = 96, M7 = 123, fTe = 124, P7 = 125, Fi = {};
  Fi[0] = "\\0";
  Fi[7] = "\\a";
  Fi[8] = "\\b";
  Fi[9] = "\\t";
  Fi[10] = "\\n";
  Fi[11] = "\\v";
  Fi[12] = "\\f";
  Fi[13] = "\\r";
  Fi[27] = "\\e";
  Fi[34] = '\\"';
  Fi[92] = "\\\\";
  Fi[133] = "\\N";
  Fi[160] = "\\_";
  Fi[8232] = "\\L";
  Fi[8233] = "\\P";
  var pTe = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ], gTe = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function mTe(n, e) {
    var t, r, i, a, s, o, l;
    if (e === null) return {};
    for (t = {}, r = Object.keys(e), i = 0, a = r.length; i < a; i += 1) s = r[i], o = String(e[s]), s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)), l = n.compiledTypeMap.fallback[s], l && R7.call(l.styleAliases, o) && (o = l.styleAliases[o]), t[s] = o;
    return t;
  }
  function vTe(n) {
    var e, t, r;
    if (e = n.toString(16).toUpperCase(), n <= 255) t = "x", r = 2;
    else if (n <= 65535) t = "u", r = 4;
    else if (n <= 4294967295) t = "U", r = 8;
    else throw new qi("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + t + Br.repeat("0", r - e.length) + e;
  }
  var yTe = 1, tx = 2;
  function xTe(n) {
    this.schema = n.schema || OM, this.indent = Math.max(1, n.indent || 2), this.noArrayIndent = n.noArrayIndent || false, this.skipInvalid = n.skipInvalid || false, this.flowLevel = Br.isNothing(n.flowLevel) ? -1 : n.flowLevel, this.styleMap = mTe(this.schema, n.styles || null), this.sortKeys = n.sortKeys || false, this.lineWidth = n.lineWidth || 80, this.noRefs = n.noRefs || false, this.noCompatMode = n.noCompatMode || false, this.condenseFlow = n.condenseFlow || false, this.quotingType = n.quotingType === '"' ? tx : yTe, this.forceQuotes = n.forceQuotes || false, this.replacer = typeof n.replacer == "function" ? n.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function YG(n, e) {
    for (var t = Br.repeat(" ", e), r = 0, i = -1, a = "", s, o = n.length; r < o; ) i = n.indexOf(`
`, r), i === -1 ? (s = n.slice(r), r = o) : (s = n.slice(r, i + 1), r = i + 1), s.length && s !== `
` && (a += t), a += s;
    return a;
  }
  function r$(n, e) {
    return `
` + Br.repeat(" ", n.indent * e);
  }
  function bTe(n, e) {
    var t, r, i;
    for (t = 0, r = n.implicitTypes.length; t < r; t += 1) if (i = n.implicitTypes[t], i.resolve(e)) return true;
    return false;
  }
  function TS(n) {
    return n === eTe || n === Qke;
  }
  function nx(n) {
    return 32 <= n && n <= 126 || 161 <= n && n <= 55295 && n !== 8232 && n !== 8233 || 57344 <= n && n <= 65533 && n !== VM || 65536 <= n && n <= 1114111;
  }
  function qG(n) {
    return nx(n) && n !== VM && n !== Jke && n !== ex;
  }
  function jG(n, e, t) {
    var r = qG(n), i = r && !TS(n);
    return (t ? r : r && n !== $7 && n !== N7 && n !== E7 && n !== M7 && n !== P7) && n !== n$ && !(e === kS && !i) || qG(e) && !TS(e) && n === n$ || e === kS && i;
  }
  function wTe(n) {
    return nx(n) && n !== VM && !TS(n) && n !== oTe && n !== cTe && n !== kS && n !== $7 && n !== N7 && n !== E7 && n !== M7 && n !== P7 && n !== n$ && n !== iTe && n !== sTe && n !== tTe && n !== fTe && n !== lTe && n !== uTe && n !== aTe && n !== nTe && n !== rTe && n !== hTe && n !== dTe;
  }
  function _Te(n) {
    return !TS(n) && n !== kS;
  }
  function Vy(n, e) {
    var t = n.charCodeAt(e), r;
    return t >= 55296 && t <= 56319 && e + 1 < n.length && (r = n.charCodeAt(e + 1), r >= 56320 && r <= 57343) ? (t - 55296) * 1024 + r - 56320 + 65536 : t;
  }
  function L7(n) {
    var e = /^\n* /;
    return e.test(n);
  }
  var F7 = 1, i$ = 2, O7 = 3, B7 = 4, og = 5;
  function STe(n, e, t, r, i, a, s, o) {
    var l, u = 0, c = null, h = false, d = false, f = r !== -1, p = -1, g = wTe(Vy(n, 0)) && _Te(Vy(n, n.length - 1));
    if (e || s) for (l = 0; l < n.length; u >= 65536 ? l += 2 : l++) {
      if (u = Vy(n, l), !nx(u)) return og;
      g = g && jG(u, c, o), c = u;
    }
    else {
      for (l = 0; l < n.length; u >= 65536 ? l += 2 : l++) {
        if (u = Vy(n, l), u === ex) h = true, f && (d = d || l - p - 1 > r && n[p + 1] !== " ", p = l);
        else if (!nx(u)) return og;
        g = g && jG(u, c, o), c = u;
      }
      d = d || f && l - p - 1 > r && n[p + 1] !== " ";
    }
    return !h && !d ? g && !s && !i(n) ? F7 : a === tx ? og : i$ : t > 9 && L7(n) ? og : s ? a === tx ? og : i$ : d ? B7 : O7;
  }
  function CTe(n, e, t, r, i) {
    n.dump = function() {
      if (e.length === 0) return n.quotingType === tx ? '""' : "''";
      if (!n.noCompatMode && (pTe.indexOf(e) !== -1 || gTe.test(e))) return n.quotingType === tx ? '"' + e + '"' : "'" + e + "'";
      var a = n.indent * Math.max(1, t), s = n.lineWidth === -1 ? -1 : Math.max(Math.min(n.lineWidth, 40), n.lineWidth - a), o = r || n.flowLevel > -1 && t >= n.flowLevel;
      function l(u) {
        return bTe(n, u);
      }
      switch (STe(e, o, n.indent, s, l, n.quotingType, n.forceQuotes && !r, i)) {
        case F7:
          return e;
        case i$:
          return "'" + e.replace(/'/g, "''") + "'";
        case O7:
          return "|" + KG(e, n.indent) + ZG(YG(e, a));
        case B7:
          return ">" + KG(e, n.indent) + ZG(YG(ITe(e, s), a));
        case og:
          return '"' + kTe(e) + '"';
        default:
          throw new qi("impossible error: invalid scalar style");
      }
    }();
  }
  function KG(n, e) {
    var t = L7(n) ? String(e) : "", r = n[n.length - 1] === `
`, i = r && (n[n.length - 2] === `
` || n === `
`), a = i ? "+" : r ? "" : "-";
    return t + a + `
`;
  }
  function ZG(n) {
    return n[n.length - 1] === `
` ? n.slice(0, -1) : n;
  }
  function ITe(n, e) {
    for (var t = /(\n+)([^\n]*)/g, r = function() {
      var u = n.indexOf(`
`);
      return u = u !== -1 ? u : n.length, t.lastIndex = u, QG(n.slice(0, u), e);
    }(), i = n[0] === `
` || n[0] === " ", a, s; s = t.exec(n); ) {
      var o = s[1], l = s[2];
      a = l[0] === " ", r += o + (!i && !a && l !== "" ? `
` : "") + QG(l, e), i = a;
    }
    return r;
  }
  function QG(n, e) {
    if (n === "" || n[0] === " ") return n;
    for (var t = / [^ ]/g, r, i = 0, a, s = 0, o = 0, l = ""; r = t.exec(n); ) o = r.index, o - i > e && (a = s > i ? s : o, l += `
` + n.slice(i, a), i = a + 1), s = o;
    return l += `
`, n.length - i > e && s > i ? l += n.slice(i, s) + `
` + n.slice(s + 1) : l += n.slice(i), l.slice(1);
  }
  function kTe(n) {
    for (var e = "", t = 0, r, i = 0; i < n.length; t >= 65536 ? i += 2 : i++) t = Vy(n, i), r = Fi[t], !r && nx(t) ? (e += n[i], t >= 65536 && (e += n[i + 1])) : e += r || vTe(t);
    return e;
  }
  function TTe(n, e, t) {
    var r = "", i = n.tag, a, s, o;
    for (a = 0, s = t.length; a < s; a += 1) o = t[a], n.replacer && (o = n.replacer.call(t, String(a), o)), (Ql(n, e, o, false, false) || typeof o > "u" && Ql(n, e, null, false, false)) && (r !== "" && (r += "," + (n.condenseFlow ? "" : " ")), r += n.dump);
    n.tag = i, n.dump = "[" + r + "]";
  }
  function JG(n, e, t, r) {
    var i = "", a = n.tag, s, o, l;
    for (s = 0, o = t.length; s < o; s += 1) l = t[s], n.replacer && (l = n.replacer.call(t, String(s), l)), (Ql(n, e + 1, l, true, true, false, true) || typeof l > "u" && Ql(n, e + 1, null, true, true, false, true)) && ((!r || i !== "") && (i += r$(n, e)), n.dump && ex === n.dump.charCodeAt(0) ? i += "-" : i += "- ", i += n.dump);
    n.tag = a, n.dump = i || "[]";
  }
  function ATe(n, e, t) {
    var r = "", i = n.tag, a = Object.keys(t), s, o, l, u, c;
    for (s = 0, o = a.length; s < o; s += 1) c = "", r !== "" && (c += ", "), n.condenseFlow && (c += '"'), l = a[s], u = t[l], n.replacer && (u = n.replacer.call(t, l, u)), Ql(n, e, l, false, false) && (n.dump.length > 1024 && (c += "? "), c += n.dump + (n.condenseFlow ? '"' : "") + ":" + (n.condenseFlow ? "" : " "), Ql(n, e, u, false, false) && (c += n.dump, r += c));
    n.tag = i, n.dump = "{" + r + "}";
  }
  function DTe(n, e, t, r) {
    var i = "", a = n.tag, s = Object.keys(t), o, l, u, c, h, d;
    if (n.sortKeys === true) s.sort();
    else if (typeof n.sortKeys == "function") s.sort(n.sortKeys);
    else if (n.sortKeys) throw new qi("sortKeys must be a boolean or a function");
    for (o = 0, l = s.length; o < l; o += 1) d = "", (!r || i !== "") && (d += r$(n, e)), u = s[o], c = t[u], n.replacer && (c = n.replacer.call(t, u, c)), Ql(n, e + 1, u, true, true, true) && (h = n.tag !== null && n.tag !== "?" || n.dump && n.dump.length > 1024, h && (n.dump && ex === n.dump.charCodeAt(0) ? d += "?" : d += "? "), d += n.dump, h && (d += r$(n, e)), Ql(n, e + 1, c, true, h) && (n.dump && ex === n.dump.charCodeAt(0) ? d += ":" : d += ": ", d += n.dump, i += d));
    n.tag = a, n.dump = i || "{}";
  }
  function e4(n, e, t) {
    var r, i, a, s, o, l;
    for (i = t ? n.explicitTypes : n.implicitTypes, a = 0, s = i.length; a < s; a += 1) if (o = i[a], (o.instanceOf || o.predicate) && (!o.instanceOf || typeof e == "object" && e instanceof o.instanceOf) && (!o.predicate || o.predicate(e))) {
      if (t ? o.multi && o.representName ? n.tag = o.representName(e) : n.tag = o.tag : n.tag = "?", o.represent) {
        if (l = n.styleMap[o.tag] || o.defaultStyle, D7.call(o.represent) === "[object Function]") r = o.represent(e, l);
        else if (R7.call(o.represent, l)) r = o.represent[l](e, l);
        else throw new qi("!<" + o.tag + '> tag resolver accepts not "' + l + '" style');
        n.dump = r;
      }
      return true;
    }
    return false;
  }
  function Ql(n, e, t, r, i, a, s) {
    n.tag = null, n.dump = t, e4(n, t, false) || e4(n, t, true);
    var o = D7.call(n.dump), l = r, u;
    r && (r = n.flowLevel < 0 || n.flowLevel > e);
    var c = o === "[object Object]" || o === "[object Array]", h, d;
    if (c && (h = n.duplicates.indexOf(t), d = h !== -1), (n.tag !== null && n.tag !== "?" || d || n.indent !== 2 && e > 0) && (i = false), d && n.usedDuplicates[h]) n.dump = "*ref_" + h;
    else {
      if (c && d && !n.usedDuplicates[h] && (n.usedDuplicates[h] = true), o === "[object Object]") r && Object.keys(n.dump).length !== 0 ? (DTe(n, e, n.dump, i), d && (n.dump = "&ref_" + h + n.dump)) : (ATe(n, e, n.dump), d && (n.dump = "&ref_" + h + " " + n.dump));
      else if (o === "[object Array]") r && n.dump.length !== 0 ? (n.noArrayIndent && !s && e > 0 ? JG(n, e - 1, n.dump, i) : JG(n, e, n.dump, i), d && (n.dump = "&ref_" + h + n.dump)) : (TTe(n, e, n.dump), d && (n.dump = "&ref_" + h + " " + n.dump));
      else if (o === "[object String]") n.tag !== "?" && CTe(n, n.dump, e, a, l);
      else {
        if (o === "[object Undefined]") return false;
        if (n.skipInvalid) return false;
        throw new qi("unacceptable kind of an object to dump " + o);
      }
      n.tag !== null && n.tag !== "?" && (u = encodeURI(n.tag[0] === "!" ? n.tag.slice(1) : n.tag).replace(/!/g, "%21"), n.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", n.dump = u + " " + n.dump);
    }
    return true;
  }
  function RTe(n, e) {
    var t = [], r = [], i, a;
    for (a$(n, t, r), i = 0, a = r.length; i < a; i += 1) e.duplicates.push(t[r[i]]);
    e.usedDuplicates = new Array(a);
  }
  function a$(n, e, t) {
    var r, i, a;
    if (n !== null && typeof n == "object") if (i = e.indexOf(n), i !== -1) t.indexOf(i) === -1 && t.push(i);
    else if (e.push(n), Array.isArray(n)) for (i = 0, a = n.length; i < a; i += 1) a$(n[i], e, t);
    else for (r = Object.keys(n), i = 0, a = r.length; i < a; i += 1) a$(n[r[i]], e, t);
  }
  function $Te(n, e) {
    e = e || {};
    var t = new xTe(e);
    t.noRefs || RTe(n, t);
    var r = n;
    return t.replacer && (r = t.replacer.call({
      "": r
    }, "", r)), Ql(t, 0, r, true, true) ? t.dump + `
` : "";
  }
  var NTe = $Te, ETe = {
    dump: NTe
  };
  function WM(n, e) {
    return function() {
      throw new Error("Function yaml." + n + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
    };
  }
  var MTe = fi, PTe = t7, LTe = a7, FTe = c7, OTe = h7, BTe = OM, zTe = A7.load, VTe = A7.loadAll, WTe = ETe.dump, GTe = qi, UTe = {
    binary: m7,
    float: u7,
    map: i7,
    null: s7,
    pairs: y7,
    set: x7,
    timestamp: p7,
    bool: o7,
    int: l7,
    merge: g7,
    omap: v7,
    seq: r7,
    str: n7
  }, HTe = WM("safeLoad", "load"), XTe = WM("safeLoadAll", "loadAll"), YTe = WM("safeDump", "dump"), qTe = {
    Type: MTe,
    Schema: PTe,
    FAILSAFE_SCHEMA: LTe,
    JSON_SCHEMA: FTe,
    CORE_SCHEMA: OTe,
    DEFAULT_SCHEMA: BTe,
    load: zTe,
    loadAll: VTe,
    dump: WTe,
    YAMLException: GTe,
    types: UTe,
    safeLoad: HTe,
    safeLoadAll: XTe,
    safeDump: YTe
  };
  const jTe = 1e-7, KTe = 1e-4;
  class ZC {
    constructor(e, t) {
      this.backend = e, this.dataMover = t, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
    }
    get(e) {
      return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
    }
    set(e, t) {
      this.dataIdsCount++, this.data.set(e, t);
    }
    has(e) {
      return this.data.has(e);
    }
    delete(e) {
      return this.dataIdsCount--, this.data.delete(e);
    }
    numDataIds() {
      return this.dataIdsCount;
    }
  }
  class Zx {
    refCount(e) {
      return pa("refCount");
    }
    incRef(e) {
      return pa("incRef");
    }
    timerAvailable() {
      return true;
    }
    time(e) {
      return pa("time");
    }
    read(e) {
      return pa("read");
    }
    readSync(e) {
      return pa("readSync");
    }
    readToGPU(e, t) {
      return pa("readToGPU");
    }
    numDataIds() {
      return pa("numDataIds");
    }
    disposeData(e, t) {
      return pa("disposeData");
    }
    write(e, t, r) {
      return pa("write");
    }
    move(e, t, r, i, a) {
      return pa("move");
    }
    createTensorFromGPUData(e, t, r) {
      return pa("createTensorFromGPUData");
    }
    memory() {
      return pa("memory");
    }
    floatPrecision() {
      return pa("floatPrecision");
    }
    epsilon() {
      return this.floatPrecision() === 32 ? jTe : KTe;
    }
    dispose() {
      return pa("dispose");
    }
  }
  function pa(n) {
    throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
  }
  function ZTe(n) {
    let e = n.length, t = 0;
    for (; e > 0; ) t = Math.random() * e | 0, e--, lg(n, e, t);
  }
  function md(n, e, t) {
    return Math.max(n, Math.min(e, t));
  }
  function GM(n) {
    return n % 2 === 0 ? n : n + 1;
  }
  function lg(n, e, t) {
    const r = n[e];
    n[e] = n[t], n[t] = r;
  }
  function z7(n) {
    let e = 0;
    for (let t = 0; t < n.length; t++) e += n[t];
    return e;
  }
  function B(n, e) {
    if (!n) throw new Error(typeof e == "string" ? e : e());
  }
  function Qx(n, e, t = "") {
    B(Jt(n, e), () => t + ` Shapes ${n} and ${e} must match`);
  }
  function V7(n) {
    B(n != null, () => "The input to the tensor constructor must be a non-null value.");
  }
  function X(n) {
    if (n.length === 0) return 1;
    let e = n[0];
    for (let t = 1; t < n.length; t++) e *= n[t];
    return e;
  }
  function t4(n) {
    return n.length === 0;
  }
  function Jt(n, e) {
    if (n === e) return true;
    if (n == null || e == null || n.length !== e.length) return false;
    for (let t = 0; t < n.length; t++) if (n[t] !== e[t]) return false;
    return true;
  }
  function Ug(n) {
    return n % 1 === 0;
  }
  function s$(n) {
    const e = Math.ceil(Math.sqrt(n));
    return [
      e,
      Math.ceil(n / e)
    ];
  }
  function Tg(n, e) {
    return e <= n.length ? n : n + " ".repeat(e - n.length);
  }
  function n4(n, e = (i) => 0, t, r) {
    return new Promise((i, a) => {
      let s = 0;
      const o = () => {
        if (n()) {
          i();
          return;
        }
        s++;
        const l = e(s);
        if (t != null && s >= t) {
          a();
          return;
        }
        r != null ? r(o, l) : setTimeout(o, l);
      };
      o();
    });
  }
  function QC(n, e) {
    let t = 1, r = -1;
    for (let a = 0; a < n.length; ++a) if (n[a] >= 0) t *= n[a];
    else if (n[a] === -1) {
      if (r !== -1) throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);
      r = a;
    } else if (n[a] < 0) throw Error(`Shapes can not be < 0. Found ${n[a]} at dim ${a}`);
    if (r === -1) {
      if (e > 0 && e !== t) throw Error(`Size(${e}) must match the product of shape ${n}`);
      return n;
    }
    if (t === 0) throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);
    if (e % t !== 0) throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);
    const i = n.slice();
    return i[r] = e / t, i;
  }
  function yt(n, e) {
    const t = e.length;
    return n = n == null ? e.map((r, i) => i) : [].concat(n), B(n.every((r) => r >= -t && r < t), () => `All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`), B(n.every((r) => Ug(r)), () => `All values in axis param must be integers but got axis ${n}`), n.map((r) => r < 0 ? t + r : r);
  }
  function vc(n, e) {
    const t = [], r = [], i = e != null && Array.isArray(e) && e.length === 0, a = e == null || i ? null : yt(e, n).sort();
    let s = 0;
    for (let o = 0; o < n.length; ++o) {
      if (a != null) {
        if (a[s] === o && n[o] !== 1) throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);
        (a[s] == null || a[s] > o) && n[o] === 1 && (t.push(n[o]), r.push(o)), a[s] <= o && s++;
      }
      n[o] !== 1 && (t.push(n[o]), r.push(o));
    }
    return {
      newShape: t,
      keptDims: r
    };
  }
  function Yr(n, e) {
    return ir(n, e);
  }
  function ir(n, e) {
    let t = null;
    if (n == null || n === "float32") t = new Float32Array(e);
    else if (n === "int32") t = new Int32Array(e);
    else if (n === "bool") t = new Uint8Array(e);
    else if (n === "string") t = new Array(e);
    else throw new Error(`Unknown data type ${n}`);
    return t;
  }
  function QTe(n, e) {
    for (let t = 0; t < n.length; t++) {
      const r = n[t];
      if (isNaN(r) || !isFinite(r)) throw Error(`A tensor of type ${e} being uploaded contains ${r}.`);
    }
  }
  function JTe(n) {
    return n === "bool" || n === "complex64" || n === "float32" || n === "int32" || n === "string";
  }
  function UM(n, e) {
    return !(e === "complex64" || e === "float32" && n !== "complex64" || e === "int32" && n !== "float32" && n !== "complex64" || e === "bool" && n === "bool");
  }
  function Hg(n) {
    if (n === "float32" || n === "int32") return 4;
    if (n === "complex64") return 8;
    if (n === "bool") return 1;
    throw new Error(`Unknown dtype ${n}`);
  }
  function eAe(n) {
    if (n == null) return 0;
    let e = 0;
    return n.forEach((t) => e += t.length), e;
  }
  function Tm(n) {
    return typeof n == "string" || n instanceof String;
  }
  function tAe(n) {
    return typeof n == "boolean";
  }
  function o$(n) {
    return typeof n == "number";
  }
  function yc(n) {
    return Array.isArray(n) ? yc(n[0]) : n instanceof Float32Array ? "float32" : n instanceof Int32Array || n instanceof Uint8Array || n instanceof Uint8ClampedArray ? "int32" : o$(n) ? "float32" : Tm(n) ? "string" : tAe(n) ? "bool" : "float32";
  }
  function l$(n) {
    return !!(n && n.constructor && n.call && n.apply);
  }
  function u$(n, e) {
    for (let t = e; t < n; ++t) if (n % t === 0) return t;
    return n;
  }
  function Be(n) {
    const e = n.length;
    if (e < 2) return [];
    const t = new Array(e - 1);
    t[e - 2] = n[e - 1];
    for (let r = e - 3; r >= 0; --r) t[r] = t[r + 1] * n[r + 1];
    return t;
  }
  function W7(n, e, t, r = false) {
    const i = new Array();
    if (e.length === 1) {
      const a = e[0] * (r ? 2 : 1);
      for (let s = 0; s < a; s++) i[s] = t[n + s];
    } else {
      const a = e[0], s = e.slice(1), o = s.reduce((l, u) => l * u) * (r ? 2 : 1);
      for (let l = 0; l < a; l++) i[l] = W7(n + l * o, s, t, r);
    }
    return i;
  }
  function Qs(n, e, t = false) {
    if (n.length === 0) return e[0];
    const r = n.reduce((i, a) => i * a) * (t ? 2 : 1);
    if (r === 0) return [];
    if (r !== e.length) throw new Error(`[${n}] does not match the input size ${e.length}${t ? " for a complex tensor" : ""}.`);
    return W7(0, n, e, t);
  }
  function g_(n, e) {
    if (Array.isArray(n)) return n;
    if (e === "float32") return n instanceof Float32Array ? n : new Float32Array(n);
    if (e === "int32") return n instanceof Int32Array ? n : new Int32Array(n);
    if (e === "bool" || e === "string") return Uint8Array.from(new Int32Array(n));
    throw new Error(`Unknown dtype ${e}`);
  }
  function HM(n, e) {
    const t = si(n, e);
    for (let r = 0; r < t.length; r++) t[r] = 1;
    return t;
  }
  function si(n, e) {
    if (e == null || e === "float32" || e === "complex64") return new Float32Array(n);
    if (e === "int32") return new Int32Array(n);
    if (e === "bool") return new Uint8Array(n);
    throw new Error(`Unknown data type ${e}`);
  }
  function G7(n, e) {
    const t = n.reduce((r, i) => r * i, 1);
    if (e == null || e === "float32") return Qs(n, new Float32Array(t));
    if (e === "int32") return Qs(n, new Int32Array(t));
    if (e === "bool") return Qs(n, new Uint8Array(t));
    throw new Error(`Unknown data type ${e}`);
  }
  function su(n) {
    n.forEach((e) => {
      B(Number.isInteger(e) && e >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${n}].`);
    });
  }
  function Yo(n, e, t) {
    if (e === 0) return 0;
    if (e === 1) return n[0];
    let r = n[n.length - 1];
    for (let i = 0; i < n.length - 1; ++i) r += t[i] * n[i];
    return r;
  }
  function Am(n, e, t) {
    if (e === 0) return [];
    if (e === 1) return [
      n
    ];
    const r = new Array(e);
    for (let i = 0; i < r.length - 1; ++i) r[i] = Math.floor(n / t[i]), n -= r[i] * t[i];
    return r[r.length - 1] = n, r;
  }
  function XM(n) {
    return n && n.then && typeof n.then == "function";
  }
  const r4 = "tfjsflags";
  class nAe {
    constructor(e) {
      this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = rAe, this.populateURLFlags();
    }
    setPlatform(e, t) {
      this.platform != null && (ne().getBool("IS_TEST") || ne().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)), this.platformName = e, this.platform = t;
    }
    registerFlag(e, t, r) {
      if (this.flagRegistry[e] = {
        evaluationFn: t,
        setHook: r
      }, this.urlFlags[e] != null) {
        const i = this.urlFlags[e];
        ne().getBool("IS_TEST") || ne().getBool("PROD") || console.warn(`Setting feature override from URL ${e}: ${i}.`), this.set(e, i);
      }
    }
    async getAsync(e) {
      return e in this.flags ? this.flags[e] : (this.flags[e] = await this.evaluateFlag(e), this.flags[e]);
    }
    get(e) {
      if (e in this.flags) return this.flags[e];
      const t = this.evaluateFlag(e);
      if (XM(t)) throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);
      return this.flags[e] = t, this.flags[e];
    }
    getNumber(e) {
      return this.get(e);
    }
    getBool(e) {
      return this.get(e);
    }
    getString(e) {
      return this.get(e);
    }
    getFlags() {
      return this.flags;
    }
    get features() {
      return this.flags;
    }
    set(e, t) {
      if (this.flagRegistry[e] == null) throw new Error(`Cannot set flag ${e} as it has not been registered.`);
      this.flags[e] = t, this.flagRegistry[e].setHook != null && this.flagRegistry[e].setHook(t);
    }
    evaluateFlag(e) {
      if (this.flagRegistry[e] == null) throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);
      return this.flagRegistry[e].evaluationFn();
    }
    setFlags(e) {
      this.flags = Object.assign({}, e);
    }
    reset() {
      this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
    }
    populateURLFlags() {
      if (typeof this.global > "u" || typeof this.global.location > "u" || typeof this.global.location.search > "u") return;
      const e = this.getQueryParams(this.global.location.search);
      r4 in e && e[r4].split(",").forEach((r) => {
        const [i, a] = r.split(":");
        this.urlFlags[i] = aAe(i, a);
      });
    }
  }
  function rAe(n) {
    const e = {};
    return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (t, ...r) => (iAe(e, r[0], r[1]), r.join("="))), e;
  }
  function iAe(n, e, t) {
    n[decodeURIComponent(e)] = decodeURIComponent(t || "");
  }
  function aAe(n, e) {
    const t = e.toLowerCase();
    return t === "true" || t === "false" ? t === "true" : `${+t}` === t ? +t : e;
  }
  function ne() {
    return U7;
  }
  let U7 = null;
  function sAe(n) {
    U7 = n;
  }
  let eA;
  function H7() {
    if (eA == null) {
      let n;
      if (typeof window < "u") n = window;
      else if (typeof global < "u") n = global;
      else if (typeof process < "u") n = process;
      else if (typeof self < "u") n = self;
      else throw new Error("Could not find a global object");
      eA = n;
    }
    return eA;
  }
  function oAe() {
    const n = H7();
    return n._tfGlobals == null && (n._tfGlobals = /* @__PURE__ */ new Map()), n._tfGlobals;
  }
  function YM(n, e) {
    const t = oAe();
    if (t.has(n)) return t.get(n);
    {
      const r = e();
      return t.set(n, r), t.get(n);
    }
  }
  const Dm = "Abs", Wd = "Acos", Gd = "Acosh", xc = "Add", Rm = "AddN", $m = "All", Nm = "Any", Em = "ArgMax", Mm = "ArgMin", Ud = "Asin", Hd = "Asinh", Xd = "Atan", Yd = "Atanh", qd = "Atan2", jd = "AvgPool", Jx = "AvgPoolGrad", Pm = "AvgPool3D", eb = "AvgPool3DGrad", Kd = "BatchMatMul", Lm = "BatchToSpaceND", Fm = "Bincount", JC = "BitwiseAnd", lAe = "BroadcastTo", eI = "BroadcastArgs", Zd = "Cast", Qd = "Ceil", bc = "ClipByValue", tI = "Complex", tb = "ComplexAbs", Om = "Concat", Jd = "Conv2D", nI = "Conv2DBackpropFilter", ef = "Conv2DBackpropInput", tf = "Conv3D", Bm = "Conv3DBackpropFilterV2", zm = "Conv3DBackpropInputV2", nf = "Cos", rf = "Cosh", Vm = "Cumprod", af = "Cumsum", Wm = "CropAndResize", nb = "DenseBincount", Gm = "DepthToSpace", sf = "DepthwiseConv2dNative", rI = "DepthwiseConv2dNativeBackpropFilter", iI = "DepthwiseConv2dNativeBackpropInput", aI = "Diag", of = "Dilation2D", Xg = "Dilation2DBackpropInput", Yg = "Dilation2DBackpropFilter", X7 = "Draw", lf = "RealDiv", sI = "Einsum", uf = "Elu", Um = "EluGrad", cf = "Erf", Hm = "Equal", hf = "Exp", Xm = "ExpandDims", df = "Expm1", oI = "FFT", rb = "Fill", Ym = "FlipLeftRight", ff = "Floor", pf = "FloorDiv", gf = "FusedBatchNorm", qm = "GatherV2", ib = "GatherNd", jm = "Greater", mf = "GreaterEqual", vf = "Identity", lI = "IFFT", uI = "Imag", yf = "IsFinite", xf = "IsInf", bf = "IsNan", wf = "LeakyRelu", Km = "Less", Zm = "LessEqual", ab = "LinSpace", _f = "Log", Sf = "Log1p", Qm = "LogicalAnd", Jm = "LogicalNot", ev = "LogicalOr", uAe = "LogicalXor", cAe = "LogSoftmax", Cf = "LRN", tv = "LRNGrad", If = "Max", kf = "Maximum", Tf = "MaxPool", sb = "MaxPoolGrad", nv = "MaxPool3D", ob = "MaxPool3DGrad", cI = "MaxPoolWithArgmax", Af = "Mean", Df = "Min", Rf = "Minimum", $f = "MirrorPad", Nf = "Mod", lb = "Multinomial", Ef = "Multiply", rv = "Neg", iv = "NotEqual", av = "NonMaxSuppressionV3", ub = "NonMaxSuppressionV4", sv = "NonMaxSuppressionV5", ov = "OnesLike", Mf = "OneHot", lv = "Pack", Pf = "PadV2", Lf = "Pow", Ff = "Prelu", Of = "Prod", Y7 = "RaggedGather", q7 = "RaggedRange", j7 = "RaggedTensorToTensor", cb = "Range", hI = "Real", Bf = "Reciprocal", zf = "Relu", uv = "Reshape", Vf = "ResizeNearestNeighbor", cv = "ResizeNearestNeighborGrad", Wf = "ResizeBilinear", hv = "ResizeBilinearGrad", Gf = "Relu6", Uf = "Reverse", Hf = "Round", Xf = "Rsqrt", hb = "ScatterNd", db = "TensorScatterUpdate", fb = "SearchSorted", dv = "Select", Yf = "Selu", fv = "Slice", qf = "Sin", jf = "Sinh", Kf = "Sign", Zf = "Sigmoid", Qf = "Softplus", Jf = "Sqrt", ep = "Sum", pv = "SpaceToBatchND", gv = "SplitV", tp = "Softmax", qM = "SparseFillEmptyRows", dI = "SparseReshape", fI = "SparseSegmentMean", pI = "SparseSegmentSum", pb = "SparseToDense", np = "SquaredDifference", gb = "Square", jM = "StaticRegexReplace", mv = "StridedSlice", gI = "StringNGrams", KM = "StringSplit", ZM = "StringToHashBucketFast", rp = "Sub", ip = "Tan", ap = "Tanh", wc = "Tile", vv = "TopK", yv = "Transform", Ol = "Transpose", mI = "Unique", xv = "Unpack", mb = "UnsortedSegmentSum", bv = "ZerosLike", _c = "Step", K7 = "FromPixels", wv = "RotateWithOffset", vd = "_FusedMatMul", yd = "FusedConv2D", vb = "FusedDepthwiseConv2D";
  function Fa(...n) {
    ne().getBool("IS_TEST") || ne().getBool("PROD") || console.warn(...n);
  }
  function hAe(...n) {
    ne().getBool("IS_TEST") || ne().getBool("PROD") || console.log(...n);
  }
  const AS = YM("kernelRegistry", () => /* @__PURE__ */ new Map()), c$ = YM("gradRegistry", () => /* @__PURE__ */ new Map());
  function i4(n, e) {
    const t = Z7(n, e);
    return AS.get(t);
  }
  function a4(n) {
    return c$.get(n);
  }
  function s4(n) {
    const e = AS.entries(), t = [];
    for (; ; ) {
      const { done: r, value: i } = e.next();
      if (r) break;
      const [a, s] = i, [o] = a.split("_");
      o === n && t.push(s);
    }
    return t;
  }
  function vI(n) {
    const { kernelName: e, backendName: t } = n, r = Z7(e, t);
    AS.has(r) && Fa(`The kernel '${e}' for backend '${t}' is already registered`), AS.set(r, n);
  }
  function dAe(n) {
    const { kernelName: e } = n;
    c$.has(e) && ne().getBool("DEBUG") && Fa(`Overriding the gradient for '${e}'`), c$.set(e, n);
  }
  function Z7(n, e) {
    return `${e}_${n}`;
  }
  function Q7(n) {
    return n instanceof Float32Array || n instanceof Int32Array || n instanceof Uint8Array || n instanceof Uint8ClampedArray;
  }
  var o4 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function _v(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
  }
  function fAe(n) {
    if (n.__esModule) return n;
    var e = n.default;
    if (typeof e == "function") {
      var t = function r() {
        return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
      };
      t.prototype = e.prototype;
    } else t = {};
    return Object.defineProperty(t, "__esModule", {
      value: true
    }), Object.keys(n).forEach(function(r) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      Object.defineProperty(t, r, i.get ? i : {
        enumerable: true,
        get: function() {
          return n[r];
        }
      });
    }), t;
  }
  var tA, l4;
  function pAe() {
    if (l4) return tA;
    l4 = 1, tA = e;
    var n = null;
    try {
      n = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch {
    }
    function e(T, k, D) {
      this.low = T | 0, this.high = k | 0, this.unsigned = !!D;
    }
    e.prototype.__isLong__, Object.defineProperty(e.prototype, "__isLong__", {
      value: true
    });
    function t(T) {
      return (T && T.__isLong__) === true;
    }
    e.isLong = t;
    var r = {}, i = {};
    function a(T, k) {
      var D, R, N;
      return k ? (T >>>= 0, (N = 0 <= T && T < 256) && (R = i[T], R) ? R : (D = o(T, (T | 0) < 0 ? -1 : 0, true), N && (i[T] = D), D)) : (T |= 0, (N = -128 <= T && T < 128) && (R = r[T], R) ? R : (D = o(T, T < 0 ? -1 : 0, false), N && (r[T] = D), D));
    }
    e.fromInt = a;
    function s(T, k) {
      if (isNaN(T)) return k ? y : v;
      if (k) {
        if (T < 0) return y;
        if (T >= p) return S;
      } else {
        if (T <= -9223372036854776e3) return I;
        if (T + 1 >= g) return _;
      }
      return T < 0 ? s(-T, k).neg() : o(T % f | 0, T / f | 0, k);
    }
    e.fromNumber = s;
    function o(T, k, D) {
      return new e(T, k, D);
    }
    e.fromBits = o;
    var l = Math.pow;
    function u(T, k, D) {
      if (T.length === 0) throw Error("empty string");
      if (T === "NaN" || T === "Infinity" || T === "+Infinity" || T === "-Infinity") return v;
      if (typeof k == "number" ? (D = k, k = false) : k = !!k, D = D || 10, D < 2 || 36 < D) throw RangeError("radix");
      var R;
      if ((R = T.indexOf("-")) > 0) throw Error("interior hyphen");
      if (R === 0) return u(T.substring(1), k, D).neg();
      for (var N = s(l(D, 8)), E = v, A = 0; A < T.length; A += 8) {
        var M = Math.min(8, T.length - A), $ = parseInt(T.substring(A, A + M), D);
        if (M < 8) {
          var L = s(l(D, M));
          E = E.mul(L).add(s($));
        } else E = E.mul(N), E = E.add(s($));
      }
      return E.unsigned = k, E;
    }
    e.fromString = u;
    function c(T, k) {
      return typeof T == "number" ? s(T, k) : typeof T == "string" ? u(T, k) : o(T.low, T.high, typeof k == "boolean" ? k : T.unsigned);
    }
    e.fromValue = c;
    var h = 65536, d = 1 << 24, f = h * h, p = f * f, g = p / 2, m = a(d), v = a(0);
    e.ZERO = v;
    var y = a(0, true);
    e.UZERO = y;
    var x = a(1);
    e.ONE = x;
    var b = a(1, true);
    e.UONE = b;
    var w = a(-1);
    e.NEG_ONE = w;
    var _ = o(-1, 2147483647, false);
    e.MAX_VALUE = _;
    var S = o(-1, -1, true);
    e.MAX_UNSIGNED_VALUE = S;
    var I = o(0, -2147483648, false);
    e.MIN_VALUE = I;
    var C = e.prototype;
    return C.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }, C.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);
    }, C.toString = function(k) {
      if (k = k || 10, k < 2 || 36 < k) throw RangeError("radix");
      if (this.isZero()) return "0";
      if (this.isNegative()) if (this.eq(I)) {
        var D = s(k), R = this.div(D), N = R.mul(D).sub(this);
        return R.toString(k) + N.toInt().toString(k);
      } else return "-" + this.neg().toString(k);
      for (var E = s(l(k, 6), this.unsigned), A = this, M = ""; ; ) {
        var $ = A.div(E), L = A.sub($.mul(E)).toInt() >>> 0, F = L.toString(k);
        if (A = $, A.isZero()) return F + M;
        for (; F.length < 6; ) F = "0" + F;
        M = "" + F + M;
      }
    }, C.getHighBits = function() {
      return this.high;
    }, C.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    }, C.getLowBits = function() {
      return this.low;
    }, C.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    }, C.getNumBitsAbs = function() {
      if (this.isNegative()) return this.eq(I) ? 64 : this.neg().getNumBitsAbs();
      for (var k = this.high != 0 ? this.high : this.low, D = 31; D > 0 && !(k & 1 << D); D--) ;
      return this.high != 0 ? D + 33 : D + 1;
    }, C.isZero = function() {
      return this.high === 0 && this.low === 0;
    }, C.eqz = C.isZero, C.isNegative = function() {
      return !this.unsigned && this.high < 0;
    }, C.isPositive = function() {
      return this.unsigned || this.high >= 0;
    }, C.isOdd = function() {
      return (this.low & 1) === 1;
    }, C.isEven = function() {
      return (this.low & 1) === 0;
    }, C.equals = function(k) {
      return t(k) || (k = c(k)), this.unsigned !== k.unsigned && this.high >>> 31 === 1 && k.high >>> 31 === 1 ? false : this.high === k.high && this.low === k.low;
    }, C.eq = C.equals, C.notEquals = function(k) {
      return !this.eq(k);
    }, C.neq = C.notEquals, C.ne = C.notEquals, C.lessThan = function(k) {
      return this.comp(k) < 0;
    }, C.lt = C.lessThan, C.lessThanOrEqual = function(k) {
      return this.comp(k) <= 0;
    }, C.lte = C.lessThanOrEqual, C.le = C.lessThanOrEqual, C.greaterThan = function(k) {
      return this.comp(k) > 0;
    }, C.gt = C.greaterThan, C.greaterThanOrEqual = function(k) {
      return this.comp(k) >= 0;
    }, C.gte = C.greaterThanOrEqual, C.ge = C.greaterThanOrEqual, C.compare = function(k) {
      if (t(k) || (k = c(k)), this.eq(k)) return 0;
      var D = this.isNegative(), R = k.isNegative();
      return D && !R ? -1 : !D && R ? 1 : this.unsigned ? k.high >>> 0 > this.high >>> 0 || k.high === this.high && k.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(k).isNegative() ? -1 : 1;
    }, C.comp = C.compare, C.negate = function() {
      return !this.unsigned && this.eq(I) ? I : this.not().add(x);
    }, C.neg = C.negate, C.add = function(k) {
      t(k) || (k = c(k));
      var D = this.high >>> 16, R = this.high & 65535, N = this.low >>> 16, E = this.low & 65535, A = k.high >>> 16, M = k.high & 65535, $ = k.low >>> 16, L = k.low & 65535, F = 0, O = 0, z = 0, V = 0;
      return V += E + L, z += V >>> 16, V &= 65535, z += N + $, O += z >>> 16, z &= 65535, O += R + M, F += O >>> 16, O &= 65535, F += D + A, F &= 65535, o(z << 16 | V, F << 16 | O, this.unsigned);
    }, C.subtract = function(k) {
      return t(k) || (k = c(k)), this.add(k.neg());
    }, C.sub = C.subtract, C.multiply = function(k) {
      if (this.isZero()) return v;
      if (t(k) || (k = c(k)), n) {
        var D = n.mul(this.low, this.high, k.low, k.high);
        return o(D, n.get_high(), this.unsigned);
      }
      if (k.isZero()) return v;
      if (this.eq(I)) return k.isOdd() ? I : v;
      if (k.eq(I)) return this.isOdd() ? I : v;
      if (this.isNegative()) return k.isNegative() ? this.neg().mul(k.neg()) : this.neg().mul(k).neg();
      if (k.isNegative()) return this.mul(k.neg()).neg();
      if (this.lt(m) && k.lt(m)) return s(this.toNumber() * k.toNumber(), this.unsigned);
      var R = this.high >>> 16, N = this.high & 65535, E = this.low >>> 16, A = this.low & 65535, M = k.high >>> 16, $ = k.high & 65535, L = k.low >>> 16, F = k.low & 65535, O = 0, z = 0, V = 0, H = 0;
      return H += A * F, V += H >>> 16, H &= 65535, V += E * F, z += V >>> 16, V &= 65535, V += A * L, z += V >>> 16, V &= 65535, z += N * F, O += z >>> 16, z &= 65535, z += E * L, O += z >>> 16, z &= 65535, z += A * $, O += z >>> 16, z &= 65535, O += R * F + N * L + E * $ + A * M, O &= 65535, o(V << 16 | H, O << 16 | z, this.unsigned);
    }, C.mul = C.multiply, C.divide = function(k) {
      if (t(k) || (k = c(k)), k.isZero()) throw Error("division by zero");
      if (n) {
        if (!this.unsigned && this.high === -2147483648 && k.low === -1 && k.high === -1) return this;
        var D = (this.unsigned ? n.div_u : n.div_s)(this.low, this.high, k.low, k.high);
        return o(D, n.get_high(), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? y : v;
      var R, N, E;
      if (this.unsigned) {
        if (k.unsigned || (k = k.toUnsigned()), k.gt(this)) return y;
        if (k.gt(this.shru(1))) return b;
        E = y;
      } else {
        if (this.eq(I)) {
          if (k.eq(x) || k.eq(w)) return I;
          if (k.eq(I)) return x;
          var A = this.shr(1);
          return R = A.div(k).shl(1), R.eq(v) ? k.isNegative() ? x : w : (N = this.sub(k.mul(R)), E = R.add(N.div(k)), E);
        } else if (k.eq(I)) return this.unsigned ? y : v;
        if (this.isNegative()) return k.isNegative() ? this.neg().div(k.neg()) : this.neg().div(k).neg();
        if (k.isNegative()) return this.div(k.neg()).neg();
        E = v;
      }
      for (N = this; N.gte(k); ) {
        R = Math.max(1, Math.floor(N.toNumber() / k.toNumber()));
        for (var M = Math.ceil(Math.log(R) / Math.LN2), $ = M <= 48 ? 1 : l(2, M - 48), L = s(R), F = L.mul(k); F.isNegative() || F.gt(N); ) R -= $, L = s(R, this.unsigned), F = L.mul(k);
        L.isZero() && (L = x), E = E.add(L), N = N.sub(F);
      }
      return E;
    }, C.div = C.divide, C.modulo = function(k) {
      if (t(k) || (k = c(k)), n) {
        var D = (this.unsigned ? n.rem_u : n.rem_s)(this.low, this.high, k.low, k.high);
        return o(D, n.get_high(), this.unsigned);
      }
      return this.sub(this.div(k).mul(k));
    }, C.mod = C.modulo, C.rem = C.modulo, C.not = function() {
      return o(~this.low, ~this.high, this.unsigned);
    }, C.and = function(k) {
      return t(k) || (k = c(k)), o(this.low & k.low, this.high & k.high, this.unsigned);
    }, C.or = function(k) {
      return t(k) || (k = c(k)), o(this.low | k.low, this.high | k.high, this.unsigned);
    }, C.xor = function(k) {
      return t(k) || (k = c(k)), o(this.low ^ k.low, this.high ^ k.high, this.unsigned);
    }, C.shiftLeft = function(k) {
      return t(k) && (k = k.toInt()), (k &= 63) === 0 ? this : k < 32 ? o(this.low << k, this.high << k | this.low >>> 32 - k, this.unsigned) : o(0, this.low << k - 32, this.unsigned);
    }, C.shl = C.shiftLeft, C.shiftRight = function(k) {
      return t(k) && (k = k.toInt()), (k &= 63) === 0 ? this : k < 32 ? o(this.low >>> k | this.high << 32 - k, this.high >> k, this.unsigned) : o(this.high >> k - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, C.shr = C.shiftRight, C.shiftRightUnsigned = function(k) {
      if (t(k) && (k = k.toInt()), k &= 63, k === 0) return this;
      var D = this.high;
      if (k < 32) {
        var R = this.low;
        return o(R >>> k | D << 32 - k, D >>> k, this.unsigned);
      } else return k === 32 ? o(D, 0, this.unsigned) : o(D >>> k - 32, 0, this.unsigned);
    }, C.shru = C.shiftRightUnsigned, C.shr_u = C.shiftRightUnsigned, C.toSigned = function() {
      return this.unsigned ? o(this.low, this.high, false) : this;
    }, C.toUnsigned = function() {
      return this.unsigned ? this : o(this.low, this.high, true);
    }, C.toBytes = function(k) {
      return k ? this.toBytesLE() : this.toBytesBE();
    }, C.toBytesLE = function() {
      var k = this.high, D = this.low;
      return [
        D & 255,
        D >>> 8 & 255,
        D >>> 16 & 255,
        D >>> 24,
        k & 255,
        k >>> 8 & 255,
        k >>> 16 & 255,
        k >>> 24
      ];
    }, C.toBytesBE = function() {
      var k = this.high, D = this.low;
      return [
        k >>> 24,
        k >>> 16 & 255,
        k >>> 8 & 255,
        k & 255,
        D >>> 24,
        D >>> 16 & 255,
        D >>> 8 & 255,
        D & 255
      ];
    }, e.fromBytes = function(k, D, R) {
      return R ? e.fromBytesLE(k, D) : e.fromBytesBE(k, D);
    }, e.fromBytesLE = function(k, D) {
      return new e(k[0] | k[1] << 8 | k[2] << 16 | k[3] << 24, k[4] | k[5] << 8 | k[6] << 16 | k[7] << 24, D);
    }, e.fromBytesBE = function(k, D) {
      return new e(k[4] << 24 | k[5] << 16 | k[6] << 8 | k[7], k[0] << 24 | k[1] << 16 | k[2] << 8 | k[3], D);
    }, tA;
  }
  var J7 = pAe();
  const e9 = _v(J7), gAe = TN({
    __proto__: null,
    default: e9
  }, [
    J7
  ]);
  const $h = e9 || gAe;
  function yI(n) {
    return $h.fromString(n, true, 16);
  }
  const t9 = yI("c3a5c85c97cb3127"), wh = yI("b492b66fbe98f273"), Ti = yI("9ae16a3b2f90404f");
  function h$(n) {
    return n.xor(n.shru(47));
  }
  function n9(n, e, t) {
    const r = n.slice(e, e + t);
    return $h.fromBytes(Array.from(r), true, true);
  }
  function Vn(n, e) {
    return n9(n, e, 8);
  }
  function u4(n, e) {
    return n9(n, e, 4);
  }
  function Or(n, e) {
    return e === 0 ? n : n.shru(e).or(n.shl(64 - e));
  }
  function Ku(n, e, t = yI("9ddfea08eb382d69")) {
    let r = n.xor(e).mul(t);
    r = r.xor(r.shru(47));
    let i = e.xor(r).mul(t);
    return i = i.xor(i.shru(47)), i = i.mul(t), i;
  }
  function mAe(n, e, t, r, i, a) {
    i = i.add(n), a = Or(a.add(i).add(r), 21);
    const s = i;
    return i = i.add(e), i = i.add(t), a = a.add(Or(i, 44)), [
      i.add(r),
      a.add(s)
    ];
  }
  function pw(n, e, t, r) {
    return mAe(Vn(n, e), Vn(n, e + 8), Vn(n, e + 16), Vn(n, e + 24), t, r);
  }
  function vAe(n, e = n.length) {
    if (e >= 8) {
      const t = Ti.add(e * 2), r = Vn(n, 0).add(Ti), i = Vn(n, e - 8), a = Or(i, 37).mul(t).add(r), s = Or(r, 25).add(i).mul(t);
      return Ku(a, s, t);
    }
    if (e >= 4) {
      const t = Ti.add(e * 2), r = u4(n, 0);
      return Ku(r.shl(3).add(e), u4(n, e - 4), t);
    }
    if (e > 0) {
      const t = n[0], r = n[e >> 1], i = n[e - 1], a = t + (r << 8), s = e + (i << 2);
      return h$(Ti.mul(a).xor(t9.mul(s))).mul(Ti);
    }
    return Ti;
  }
  function yAe(n, e = n.length) {
    const t = Ti.add(e * 2), r = Vn(n, 0).mul(wh), i = Vn(n, 8), a = Vn(n, e - 8).mul(t), s = Vn(n, e - 16).mul(Ti);
    return Ku(Or(r.add(i), 43).add(Or(a, 30)).add(s), r.add(Or(i.add(Ti), 18)).add(a), t);
  }
  function xAe(n, e = n.length) {
    const t = Ti.add(e * 2), r = Vn(n, 0).mul(Ti), i = Vn(n, 8), a = Vn(n, e - 8).mul(t), s = Vn(n, e - 16).mul(Ti), o = Or(r.add(i), 43).add(Or(a, 30)).add(s), l = Ku(o, r.add(Or(i.add(Ti), 18)).add(a), t), u = Vn(n, 16).mul(t), c = Vn(n, 24), h = o.add(Vn(n, e - 32)).mul(t), d = l.add(Vn(n, e - 24)).mul(t);
    return Ku(Or(u.add(c), 43).add(Or(h, 30)).add(d), u.add(Or(c.add(r), 18)).add(h), t);
  }
  function bAe(n, e = n.length) {
    const t = $h.fromNumber(81, true);
    if (e <= 32) return e <= 16 ? vAe(n, e) : yAe(n, e);
    if (e <= 64) return xAe(n, e);
    let r = t, i = t.mul(wh).add(113), a = h$(i.mul(Ti).add(113)).mul(Ti), s = [
      $h.UZERO,
      $h.UZERO
    ], o = [
      $h.UZERO,
      $h.UZERO
    ];
    r = r.mul(Ti).add(Vn(n, 0));
    let l = 0;
    const u = (e - 1 >> 6) * 64, c = u + (e - 1 & 63) - 63;
    do
      r = Or(r.add(i).add(s[0]).add(Vn(n, l + 8)), 37).mul(wh), i = Or(i.add(s[1]).add(Vn(n, l + 48)), 42).mul(wh), r = r.xor(o[1]), i = i.add(s[0]).add(Vn(n, l + 40)), a = Or(a.add(o[0]), 33).mul(wh), s = pw(n, l, s[1].mul(wh), r.add(o[0])), o = pw(n, l + 32, a.add(o[1]), i.add(Vn(n, l + 16))), [a, r] = [
        r,
        a
      ], l += 64;
    while (l !== u);
    const h = wh.add(a.and(255).shl(1));
    return l = c, o[0] = o[0].add(e - 1 & 63), s[0] = s[0].add(o[0]), o[0] = o[0].add(s[0]), r = Or(r.add(i).add(s[0]).add(Vn(n, l + 8)), 37).mul(h), i = Or(i.add(s[1]).add(Vn(n, l + 48)), 42).mul(h), r = r.xor(o[1].mul(9)), i = i.add(s[0].mul(9).add(Vn(n, l + 40))), a = Or(a.add(o[0]), 33).mul(h), s = pw(n, l, s[1].mul(h), r.add(o[0])), o = pw(n, l + 32, a.add(o[1]), i.add(Vn(n, l + 16))), [a, r] = [
      r,
      a
    ], Ku(Ku(s[0], o[0], h).add(h$(i).mul(t9)).add(a), Ku(s[1], o[1], h).add(r), h);
  }
  function Sc(n, e) {
    return e === "string" ? Bl(n) : sp([
      n
    ], e);
  }
  function wAe(n, e) {
    return n instanceof Float32Array && e === "float32" || n instanceof Int32Array && e === "int32" || n instanceof Uint8Array && e === "bool";
  }
  function sp(n, e) {
    if (e === "string") throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(n) && (n = Jl(n)), ne().getBool("DEBUG") && QTe(n, e), wAe(n, e)) return n;
    if (e == null || e === "float32" || e === "complex64") return new Float32Array(n);
    if (e === "int32") return new Int32Array(n);
    if (e === "bool") {
      const t = new Uint8Array(n.length);
      for (let r = 0; r < t.length; ++r) Math.round(n[r]) !== 0 && (t[r] = 1);
      return t;
    } else throw new Error(`Unknown data type ${e}`);
  }
  function hi() {
    return ne().platform.now();
  }
  function Bl(n, e = "utf-8") {
    return e = e || "utf-8", ne().platform.encode(n, e);
  }
  function io(n, e = "utf-8") {
    return e = e || "utf-8", ne().platform.decode(n, e);
  }
  function Ss(n) {
    return ne().platform.isTypedArray != null ? ne().platform.isTypedArray(n) : Q7(n);
  }
  function Jl(n, e = [], t = false) {
    if (e == null && (e = []), typeof n == "boolean" || typeof n == "number" || typeof n == "string" || XM(n) || n == null || Ss(n) && t) e.push(n);
    else if (Array.isArray(n) || Ss(n)) for (let r = 0; r < n.length; ++r) Jl(n[r], e, t);
    else {
      let r = -1;
      for (const i of Object.keys(n)) /^([1-9]+[0-9]*|0)$/.test(i) && (r = Math.max(r, Number(i)));
      for (let i = 0; i <= r; i++) Jl(n[i], e, t);
    }
    return e;
  }
  class _Ae {
    constructor(e, t) {
      this.backendTimer = e, this.logger = t, t == null && (this.logger = new CAe());
    }
    profileKernel(e, t, r) {
      let i;
      const a = () => {
        i = r();
      };
      let s;
      const o = hi();
      if (this.backendTimer.timerAvailable()) s = this.backendTimer.time(a);
      else {
        a();
        for (const u of i) u.dataSync();
        s = Promise.resolve({
          kernelMs: hi() - o
        });
      }
      if (ne().getBool("CHECK_COMPUTATION_FOR_ERRORS")) for (let u = 0; u < i.length; u++) {
        const c = i[u];
        c.data().then((h) => {
          SAe(h, c.dtype, e);
        });
      }
      return {
        kernelName: e,
        outputs: i,
        inputs: t,
        timeMs: s.then((u) => u.kernelMs),
        extraInfo: s.then((u) => u.getExtraProfileInfo != null ? u.getExtraProfileInfo() : "")
      };
    }
    logKernelProfile(e) {
      const { kernelName: t, outputs: r, timeMs: i, inputs: a, extraInfo: s } = e;
      r.forEach((o) => {
        Promise.all([
          o.data(),
          i,
          s
        ]).then((l) => {
          this.logger.logKernelProfile(t, o, l[0], l[1], a, l[2]);
        });
      });
    }
  }
  function SAe(n, e, t) {
    if (e !== "float32") return false;
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      if (isNaN(i) || !isFinite(i)) return console.warn(`Found ${i} in the result of '${t}'`), true;
    }
    return false;
  }
  class CAe {
    logKernelProfile(e, t, r, i, a, s) {
      const o = typeof i == "number" ? Tg(`${i}ms`, 9) : i.error, l = Tg(e, 25), u = t.rank, c = t.size, h = Tg(t.shape.toString(), 14);
      let d = "";
      for (const f in a) {
        const p = a[f];
        if (p != null) {
          const g = p.shape || t.shape, m = g.length;
          d += `${f}: ${m}D ${m > 0 ? g : ""} `;
        }
      }
      console.log(`%c${l}	%c${o}	%c${u}D ${h}	%c${c}	%c${d}	%c${s}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }
  }
  function IAe(n, e, t) {
    const r = {}, i = {};
    for (let l = 0; l < e.length; l++) r[e[l].id] = true;
    for (let l = 0; l < n.length; l++) {
      const u = n[l], c = u.inputs;
      for (const h in c) {
        const d = c[h];
        let f = false;
        for (let p = 0; p < e.length; p++) if (r[d.id]) {
          u.outputs.forEach((g) => r[g.id] = true), f = true, i[u.id] = true;
          break;
        }
        if (f) break;
      }
    }
    const a = {};
    a[t.id] = true;
    const s = {};
    for (let l = n.length - 1; l >= 0; l--) {
      const u = n[l], c = u.inputs;
      for (let h = 0; h < u.outputs.length; h++) if (a[u.outputs[h].id]) {
        for (const d in c) a[c[d].id] = true, s[u.id] = true;
        break;
      }
    }
    const o = [];
    for (let l = 0; l < n.length; l++) {
      const u = n[l];
      if (i[u.id] && s[u.id]) {
        const c = {};
        for (const d in u.inputs) {
          const f = u.inputs[d];
          r[f.id] && (c[d] = f);
        }
        const h = Object.assign({}, u);
        h.inputs = c, h.outputs = u.outputs, o.push(h);
      }
    }
    return o;
  }
  function kAe(n, e, t, r) {
    for (let i = e.length - 1; i >= 0; i--) {
      const a = e[i], s = [];
      if (a.outputs.forEach((l) => {
        const u = n[l.id];
        u != null ? s.push(u) : s.push(null);
      }), a.gradient == null) throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);
      const o = a.gradient(s);
      for (const l in a.inputs) {
        if (!(l in o)) throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);
        const u = t(() => o[l]());
        if (u.dtype !== "float32") throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);
        const c = a.inputs[l];
        if (!Jt(u.shape, c.shape)) throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);
        if (n[c.id] == null) n[c.id] = u;
        else {
          const h = n[c.id];
          n[c.id] = r(h, u), h.dispose();
        }
      }
    }
  }
  const c4 = 20, xy = 3, nA = 7;
  function TAe(n, e, t, r) {
    const i = Be(e), a = AAe(n, e, t, i), s = e.length, o = m_(n, e, t, i, a), l = [
      "Tensor"
    ];
    return r && (l.push(`  dtype: ${t}`), l.push(`  rank: ${s}`), l.push(`  shape: [${e}]`), l.push("  values:")), l.push(o.map((u) => "    " + u).join(`
`)), l.join(`
`);
  }
  function AAe(n, e, t, r) {
    const i = X(e), a = r[r.length - 1], s = new Array(a).fill(0), o = e.length, l = t === "complex64" ? Gy(n) : n;
    if (o > 1) for (let u = 0; u < i / a; u++) {
      const c = u * a;
      for (let h = 0; h < a; h++) s[h] = Math.max(s[h], Wy(l[c + h], 0, t).length);
    }
    return s;
  }
  function Wy(n, e, t) {
    let r;
    return Array.isArray(n) ? r = `${parseFloat(n[0].toFixed(nA))} + ${parseFloat(n[1].toFixed(nA))}j` : Tm(n) ? r = `'${n}'` : t === "bool" ? r = r9(n) : r = parseFloat(n.toFixed(nA)).toString(), Tg(r, e);
  }
  function r9(n) {
    return n === 0 ? "false" : "true";
  }
  function m_(n, e, t, r, i, a = true) {
    const s = t === "complex64" ? 2 : 1, o = e[0], l = e.length;
    if (l === 0) {
      if (t === "complex64") {
        const g = Gy(n);
        return [
          Wy(g[0], 0, t)
        ];
      }
      return t === "bool" ? [
        r9(n[0])
      ] : [
        n[0].toString()
      ];
    }
    if (l === 1) {
      if (o > c4) {
        const m = xy * s;
        let v = Array.from(n.slice(0, m)), y = Array.from(n.slice((o - xy) * s, o * s));
        return t === "complex64" && (v = Gy(v), y = Gy(y)), [
          "[" + v.map((x, b) => Wy(x, i[b], t)).join(", ") + ", ..., " + y.map((x, b) => Wy(x, i[o - xy + b], t)).join(", ") + "]"
        ];
      }
      return [
        "[" + (t === "complex64" ? Gy(n) : Array.from(n)).map((m, v) => Wy(m, i[v], t)).join(", ") + "]"
      ];
    }
    const u = e.slice(1), c = r.slice(1), h = r[0] * s, d = [];
    if (o > c4) {
      for (let g = 0; g < xy; g++) {
        const m = g * h, v = m + h;
        d.push(...m_(n.slice(m, v), u, t, c, i, false));
      }
      d.push("...");
      for (let g = o - xy; g < o; g++) {
        const m = g * h, v = m + h;
        d.push(...m_(n.slice(m, v), u, t, c, i, g === o - 1));
      }
    } else for (let g = 0; g < o; g++) {
      const m = g * h, v = m + h;
      d.push(...m_(n.slice(m, v), u, t, c, i, g === o - 1));
    }
    const f = l === 2 ? "," : "";
    d[0] = "[" + (o > 0 ? d[0] + f : "");
    for (let g = 1; g < d.length - 1; g++) d[g] = " " + d[g] + f;
    let p = `,
`;
    for (let g = 2; g < l; g++) p += `
`;
    return d[d.length - 1] = " " + d[d.length - 1] + "]" + (a ? "" : p), d;
  }
  function Gy(n) {
    const e = [];
    for (let t = 0; t < n.length; t += 2) e.push([
      n[t],
      n[t + 1]
    ]);
    return e;
  }
  class ii {
    constructor(e, t, r) {
      if (this.dtype = t, this.shape = e.slice(), this.size = X(e), r != null) {
        const i = r.length;
        B(i === this.size, () => `Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`);
      }
      if (t === "complex64") throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
      this.values = r || ir(t, this.size), this.strides = Be(e);
    }
    set(e, ...t) {
      t.length === 0 && (t = [
        0
      ]), B(t.length === this.rank, () => `The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);
      const r = this.locToIndex(t);
      this.values[r] = e;
    }
    get(...e) {
      e.length === 0 && (e = [
        0
      ]);
      let t = 0;
      for (const i of e) {
        if (i < 0 || i >= this.shape[t]) {
          const a = `Requested out of range element at ${e}.   Buffer shape=${this.shape}`;
          throw new Error(a);
        }
        t++;
      }
      let r = e[e.length - 1];
      for (let i = 0; i < e.length - 1; ++i) r += this.strides[i] * e[i];
      return this.values[r];
    }
    locToIndex(e) {
      if (this.rank === 0) return 0;
      if (this.rank === 1) return e[0];
      let t = e[e.length - 1];
      for (let r = 0; r < e.length - 1; ++r) t += this.strides[r] * e[r];
      return t;
    }
    indexToLoc(e) {
      if (this.rank === 0) return [];
      if (this.rank === 1) return [
        e
      ];
      const t = new Array(this.shape.length);
      for (let r = 0; r < t.length - 1; ++r) t[r] = Math.floor(e / this.strides[r]), e -= t[r] * this.strides[r];
      return t[t.length - 1] = e, t;
    }
    get rank() {
      return this.shape.length;
    }
    toTensor() {
      return Ws().makeTensor(this.values, this.shape, this.dtype);
    }
  }
  let Ws = null, ug = null;
  function DAe(n) {
    Ws = n;
  }
  function RAe(n) {
    ug = n;
  }
  class _r {
    constructor(e, t, r, i) {
      this.kept = false, this.isDisposedInternal = false, this.shape = e.slice(), this.dtype = t || "float32", this.size = X(e), this.strides = Be(e), this.dataId = r, this.id = i, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    get rank() {
      return this.shape.length;
    }
    async buffer() {
      const e = await this.data();
      return ug.buffer(this.shape, this.dtype, e);
    }
    bufferSync() {
      return ug.buffer(this.shape, this.dtype, this.dataSync());
    }
    async array() {
      const e = await this.data();
      return Qs(this.shape, e, this.dtype === "complex64");
    }
    arraySync() {
      return Qs(this.shape, this.dataSync(), this.dtype === "complex64");
    }
    async data() {
      this.throwIfDisposed();
      const e = Ws().read(this.dataId);
      if (this.dtype === "string") {
        const t = await e;
        try {
          return t.map((r) => io(r));
        } catch {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return e;
    }
    dataToGPU(e) {
      return this.throwIfDisposed(), Ws().readToGPU(this.dataId, e);
    }
    dataSync() {
      this.throwIfDisposed();
      const e = Ws().readSync(this.dataId);
      if (this.dtype === "string") try {
        return e.map((t) => io(t));
      } catch {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
      return e;
    }
    async bytes() {
      this.throwIfDisposed();
      const e = await Ws().read(this.dataId);
      return this.dtype === "string" ? e : new Uint8Array(e.buffer);
    }
    dispose() {
      this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), Ws().disposeTensor(this), this.isDisposedInternal = true);
    }
    get isDisposed() {
      return this.isDisposedInternal;
    }
    throwIfDisposed() {
      if (this.isDisposed) throw new Error("Tensor is disposed.");
    }
    print(e = false) {
      return ug.print(this, e);
    }
    clone() {
      return this.throwIfDisposed(), ug.clone(this);
    }
    toString(e = false) {
      const t = this.dataSync();
      return TAe(t, this.shape, this.dtype, e);
    }
    cast(e) {
      return this.throwIfDisposed(), ug.cast(this, e);
    }
    variable(e = true, t, r) {
      return this.throwIfDisposed(), Ws().makeVariable(this, e, t, r);
    }
  }
  Object.defineProperty(_r, Symbol.hasInstance, {
    value: (n) => !!n && n.data != null && n.dataSync != null && n.throwIfDisposed != null
  });
  function he() {
    return YM("Tensor", () => _r);
  }
  he();
  class DS extends _r {
    constructor(e, t, r, i) {
      super(e.shape, e.dtype, e.dataId, i), this.trainable = t, this.name = r;
    }
    assign(e) {
      if (e.dtype !== this.dtype) throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);
      if (!Jt(e.shape, this.shape)) throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);
      Ws().disposeTensor(this), this.dataId = e.dataId, Ws().incRef(this, null);
    }
    dispose() {
      Ws().disposeVariable(this), this.isDisposedInternal = true;
    }
  }
  Object.defineProperty(DS, Symbol.hasInstance, {
    value: (n) => n instanceof _r && n.assign != null && n.assign instanceof Function
  });
  var h4;
  (function(n) {
    n.R0 = "R0", n.R1 = "R1", n.R2 = "R2", n.R3 = "R3", n.R4 = "R4", n.R5 = "R5", n.R6 = "R6";
  })(h4 || (h4 = {}));
  var d$;
  (function(n) {
    n.float32 = "float32", n.int32 = "int32", n.bool = "int32", n.complex64 = "complex64";
  })(d$ || (d$ = {}));
  var f$;
  (function(n) {
    n.float32 = "float32", n.int32 = "int32", n.bool = "bool", n.complex64 = "complex64";
  })(f$ || (f$ = {}));
  var p$;
  (function(n) {
    n.float32 = "float32", n.int32 = "float32", n.bool = "float32", n.complex64 = "complex64";
  })(p$ || (p$ = {}));
  var g$;
  (function(n) {
    n.float32 = "complex64", n.int32 = "complex64", n.bool = "complex64", n.complex64 = "complex64";
  })(g$ || (g$ = {}));
  const $Ae = {
    float32: p$,
    int32: d$,
    bool: f$,
    complex64: g$
  };
  function qr(n, e) {
    if (n === "string" || e === "string") {
      if (n === "string" && e === "string") return "string";
      throw new Error(`Can not upcast ${n} with ${e}`);
    }
    return $Ae[n][e];
  }
  function xI(n) {
    return qr(n, "int32");
  }
  function i9(n) {
    return n != null && typeof n == "object" && "texture" in n && n.texture instanceof WebGLTexture;
  }
  function a9(n) {
    return typeof GPUBuffer < "u" && n != null && typeof n == "object" && "buffer" in n && n.buffer instanceof GPUBuffer;
  }
  function hr(n, e) {
    if (n.dtype === e.dtype) return [
      n,
      e
    ];
    const t = qr(n.dtype, e.dtype);
    return [
      n.cast(t),
      e.cast(t)
    ];
  }
  function s9(n) {
    const e = [];
    return o9(n, e, /* @__PURE__ */ new Set()), e;
  }
  function o9(n, e, t) {
    if (n == null) return;
    if (n instanceof _r) {
      e.push(n);
      return;
    }
    if (!NAe(n)) return;
    const r = n;
    for (const i in r) {
      const a = r[i];
      t.has(a) || (t.add(a), o9(a, e, t));
    }
  }
  function NAe(n) {
    return Array.isArray(n) || typeof n == "object";
  }
  function rA(n) {
    return n.kernelName != null;
  }
  class d4 {
    constructor() {
      this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = {
        newBytes: 0,
        newTensors: 0,
        peakBytes: 0,
        kernels: [],
        result: null,
        get kernelNames() {
          return Array.from(new Set(this.kernels.map((e) => e.name)));
        }
      };
    }
    dispose() {
      for (const e in this.registeredVariables) this.registeredVariables[e].dispose();
    }
  }
  class qg {
    constructor(e) {
      this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new d4();
    }
    async ready() {
      if (this.pendingBackendInit != null) return this.pendingBackendInit.then(() => {
      });
      if (this.backendInstance != null) return;
      const e = this.getSortedBackends();
      for (let t = 0; t < e.length; t++) {
        const r = e[t];
        if (await this.initializeBackend(r).success) {
          await this.setBackend(r);
          return;
        }
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    get backend() {
      if (this.pendingBackendInit != null) throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      if (this.backendInstance == null) {
        const { name: e, asyncInit: t } = this.initializeBackendsAndReturnBest();
        if (t) throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        this.setBackend(e);
      }
      return this.backendInstance;
    }
    backendNames() {
      return Object.keys(this.registryFactory);
    }
    findBackend(e) {
      if (!(e in this.registry)) if (e in this.registryFactory) {
        const { asyncInit: t } = this.initializeBackend(e);
        if (t) return null;
      } else return null;
      return this.registry[e];
    }
    findBackendFactory(e) {
      return e in this.registryFactory ? this.registryFactory[e].factory : null;
    }
    registerBackend(e, t, r = 1) {
      return e in this.registryFactory ? (Fa(`${e} backend was already registered. Reusing existing backend factory.`), false) : (this.registryFactory[e] = {
        factory: t,
        priority: r
      }, true);
    }
    async setBackend(e) {
      if (this.registryFactory[e] == null) throw new Error(`Backend name '${e}' not found in registry`);
      if (this.backendName = e, this.registry[e] == null) {
        this.backendInstance = null;
        const { success: t, asyncInit: r } = this.initializeBackend(e);
        if (!(r ? await t : t)) return false;
      }
      return this.backendInstance = this.registry[e], this.setupRegisteredKernels(), this.profiler = new _Ae(this.backendInstance), true;
    }
    setupRegisteredKernels() {
      s4(this.backendName).forEach((t) => {
        t.setupFunc != null && t.setupFunc(this.backendInstance);
      });
    }
    disposeRegisteredKernels(e) {
      s4(e).forEach((r) => {
        r.disposeFunc != null && r.disposeFunc(this.registry[e]);
      });
    }
    initializeBackend(e) {
      const t = this.registryFactory[e];
      if (t == null) throw new Error(`Cannot initialize backend ${e}, no registration found.`);
      try {
        const r = t.factory();
        if (r && !(r instanceof Zx) && typeof r.then == "function") {
          const i = ++this.pendingBackendInitId, a = r.then((s) => i < this.pendingBackendInitId ? false : (this.registry[e] = s, this.pendingBackendInit = null, true)).catch((s) => (i < this.pendingBackendInitId || (this.pendingBackendInit = null, Fa(`Initialization of backend ${e} failed`), Fa(s.stack || s.message)), false));
          return this.pendingBackendInit = a, {
            success: a,
            asyncInit: true
          };
        } else return this.registry[e] = r, {
          success: true,
          asyncInit: false
        };
      } catch (r) {
        return Fa(`Initialization of backend ${e} failed`), Fa(r.stack || r.message), {
          success: false,
          asyncInit: false
        };
      }
    }
    removeBackend(e) {
      if (!(e in this.registryFactory)) throw new Error(`${e} backend not found in registry`);
      this.backendName === e && this.pendingBackendInit != null && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
    }
    getSortedBackends() {
      if (Object.keys(this.registryFactory).length === 0) throw new Error("No backend found in registry.");
      return Object.keys(this.registryFactory).sort((e, t) => this.registryFactory[t].priority - this.registryFactory[e].priority);
    }
    initializeBackendsAndReturnBest() {
      const e = this.getSortedBackends();
      for (let t = 0; t < e.length; t++) {
        const r = e[t], { success: i, asyncInit: a } = this.initializeBackend(r);
        if (a || i) return {
          name: r,
          asyncInit: a
        };
      }
      throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    moveData(e, t) {
      const r = this.state.tensorInfo.get(t), i = r.backend, a = this.readSync(t), s = i.refCount(t);
      i.disposeData(t, true), r.backend = e, e.move(t, a, r.shape, r.dtype, s), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
    tidy(e, t) {
      let r = null;
      if (t == null) {
        if (typeof e != "function") throw new Error("Please provide a function to tidy()");
        t = e;
      } else {
        if (typeof e != "string" && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        if (typeof t != "function") throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        r = e;
      }
      let i;
      return this.scopedRun(() => this.startScope(r), () => this.endScope(i), () => (i = t(), i instanceof Promise && console.error("Cannot return a Promise inside of tidy."), i));
    }
    scopedRun(e, t, r) {
      e();
      try {
        const i = r();
        return t(), i;
      } catch (i) {
        throw t(), i;
      }
    }
    nextTensorId() {
      return qg.nextTensorId++;
    }
    nextVariableId() {
      return qg.nextVariableId++;
    }
    clone(e) {
      const t = Q.runKernel(vf, {
        x: e
      }), r = {
        x: e
      }, i = (s) => ({
        x: () => {
          const o = "float32", l = {
            x: s
          }, u = {
            dtype: o
          };
          return Q.runKernel(Zd, l, u);
        }
      }), a = [];
      return this.addTapeNode(this.state.activeScope.name, r, [
        t
      ], i, a, {}), t;
    }
    runKernel(e, t, r) {
      if (this.backendName == null && this.backend, !(i4(e, this.backendName) != null)) throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);
      return this.runKernelFunc({
        kernelName: e,
        inputs: t,
        attrs: r
      });
    }
    shouldCheckForMemLeaks() {
      return this.ENV.getBool("IS_TEST");
    }
    checkKernelForMemLeak(e, t, r) {
      const i = this.backend.numDataIds();
      let a = 0;
      r.forEach((l) => {
        a += l.dtype === "complex64" ? 3 : 1;
      });
      const s = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], o = i - t - a - s;
      if (o > 0) throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`);
    }
    runKernelFunc(e) {
      let t, r = [];
      const i = this.isTapeOn(), a = this.state.numBytes, s = this.state.numTensors;
      this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
      let o;
      this.backendName == null && this.backend;
      let l;
      const u = rA(e) ? e.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
      if (rA(e)) {
        const { kernelName: p, inputs: g, attrs: m } = e;
        this.backendName == null && this.backend;
        const v = i4(p, this.backendName);
        B(v != null, () => `Cannot find registered kernel '${p}' for backend '${this.backendName}'`), o = () => {
          const y = this.backend.numDataIds();
          l = v.kernelFunc({
            inputs: g,
            attrs: m,
            backend: this.backend
          });
          const x = Array.isArray(l) ? l : [
            l
          ];
          this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(p, y, x);
          const b = x.map((w) => w.rank != null ? w : this.makeTensorFromTensorInfo(w));
          if (i) {
            const w = this.getTensorsForGradient(p, g, b);
            r = this.saveTensorsForBackwardMode(w);
          }
          return b;
        };
      } else {
        const { forwardFunc: p } = e, g = (m) => {
          i && (r = m.map((v) => this.keep(this.clone(v))));
        };
        o = () => {
          const m = this.backend.numDataIds();
          l = this.tidy(() => p(this.backend, g));
          const v = Array.isArray(l) ? l : [
            l
          ];
          return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(u, m, v), v;
        };
      }
      const { inputs: c, attrs: h } = e, d = rA(e) ? null : e.backwardsFunc;
      let f;
      return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
        !this.ENV.getBool("DEBUG") && !this.state.profiling ? t = o() : (f = this.profiler.profileKernel(u, c, () => o()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(f), t = f.outputs);
      }), i && this.addTapeNode(u, c, t, d, r, h), this.state.profiling && this.state.activeProfile.kernels.push({
        name: u,
        bytesAdded: this.state.numBytes - a,
        totalBytesSnapshot: this.state.numBytes,
        tensorsAdded: this.state.numTensors - s,
        totalTensorsSnapshot: this.state.numTensors,
        inputShapes: Object.keys(c).map((p) => c[p] != null ? c[p].shape : null),
        outputShapes: t.map((p) => p.shape),
        kernelTimeMs: f.timeMs,
        extraInfo: f.extraInfo
      }), Array.isArray(l) ? t : t[0];
    }
    saveTensorsForBackwardMode(e) {
      return e.map((r) => this.keep(this.clone(r)));
    }
    getTensorsForGradient(e, t, r) {
      const i = a4(e);
      if (i != null) {
        const a = i.inputsToSave || [], s = i.outputsToSave || [];
        let o;
        i.saveAllInputs ? (B(Array.isArray(t), () => "saveAllInputs is true, expected inputs to be an array."), o = Object.keys(t).map((u) => t[u])) : o = a.map((u) => t[u]);
        const l = r.filter((u, c) => s[c]);
        return o.concat(l);
      }
      return [];
    }
    makeTensor(e, t, r, i) {
      if (e == null) throw new Error("Values passed to engine.makeTensor() are null");
      r = r || "float32", i = i || this.backend;
      let a = e;
      r === "string" && Tm(e[0]) && (a = e.map((l) => Bl(l)));
      const s = i.write(a, t, r), o = new _r(t, r, s, this.nextTensorId());
      if (this.trackTensor(o, i), r === "string") {
        const l = this.state.tensorInfo.get(s), u = eAe(a);
        this.state.numBytes += u - l.bytes, l.bytes = u;
      }
      return o;
    }
    makeTensorFromDataId(e, t, r, i) {
      r = r || "float32";
      const a = {
        dataId: e,
        shape: t,
        dtype: r
      };
      return this.makeTensorFromTensorInfo(a, i);
    }
    makeTensorFromTensorInfo(e, t) {
      const { dataId: r, shape: i, dtype: a } = e, s = new _r(i, a, r, this.nextTensorId());
      return this.trackTensor(s, t), s;
    }
    makeVariable(e, t = true, r, i) {
      r = r || this.nextVariableId().toString(), i != null && i !== e.dtype && (e = e.cast(i));
      const a = new DS(e, t, r, this.nextTensorId());
      if (this.state.registeredVariables[a.name] != null) throw new Error(`Variable with name ${a.name} was already registered`);
      return this.state.registeredVariables[a.name] = a, this.incRef(a, this.backend), a;
    }
    trackTensor(e, t) {
      this.state.numTensors++, e.dtype === "string" && this.state.numStringTensors++;
      let r = 0;
      e.dtype !== "complex64" && e.dtype !== "string" && (r = e.size * Hg(e.dtype)), this.state.numBytes += r, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
        backend: t || this.backend,
        dtype: e.dtype,
        shape: e.shape,
        bytes: r
      })), e instanceof DS || this.track(e);
    }
    incRef(e, t) {
      this.trackTensor(e, t), this.backend.incRef(e.dataId);
    }
    removeDataId(e, t) {
      this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--);
    }
    disposeTensor(e) {
      if (!this.state.tensorInfo.has(e.dataId)) return;
      const t = this.state.tensorInfo.get(e.dataId);
      if (this.state.numTensors--, e.dtype === "string" && (this.state.numStringTensors--, this.state.numBytes -= t.bytes), e.dtype !== "complex64" && e.dtype !== "string") {
        const r = e.size * Hg(e.dtype);
        this.state.numBytes -= r;
      }
      t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend);
    }
    disposeVariables() {
      for (const e in this.state.registeredVariables) {
        const t = this.state.registeredVariables[e];
        this.disposeVariable(t);
      }
    }
    disposeVariable(e) {
      this.disposeTensor(e), this.state.registeredVariables[e.name] != null && delete this.state.registeredVariables[e.name];
    }
    memory() {
      const e = this.backend.memory();
      return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = true, e.reasons == null && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e;
    }
    async profile(e) {
      this.state.profiling = true;
      const t = this.state.numBytes, r = this.state.numTensors;
      this.state.activeProfile.kernels = [], this.state.activeProfile.result = await e(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((i) => i.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - t, this.state.activeProfile.newTensors = this.state.numTensors - r;
      for (const i of this.state.activeProfile.kernels) i.kernelTimeMs = await i.kernelTimeMs, i.extraInfo = await i.extraInfo;
      return this.state.activeProfile;
    }
    isTapeOn() {
      return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(e, t, r, i, a, s) {
      const o = {
        id: this.state.nextTapeNodeId++,
        kernelName: e,
        inputs: t,
        outputs: r,
        saved: a
      }, l = a4(e);
      l != null && (i = l.gradFunc), i != null && (o.gradient = (u) => (u = u.map((c, h) => {
        if (c == null) {
          const d = r[h], f = si(d.size, d.dtype);
          return this.makeTensor(f, d.shape, d.dtype);
        }
        return c;
      }), i(u.length > 1 ? u : u[0], a, s))), this.state.activeTape.push(o);
    }
    keep(e) {
      return e.kept = true, e;
    }
    startTape() {
      this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
    }
    endTape() {
      this.state.gradientDepth--;
    }
    startScope(e) {
      const t = {
        track: [],
        name: "unnamed scope",
        id: this.state.nextScopeId++
      };
      e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t;
    }
    endScope(e) {
      const t = s9(e), r = new Set(t.map((a) => a.id));
      for (let a = 0; a < this.state.activeScope.track.length; a++) {
        const s = this.state.activeScope.track[a];
        !s.kept && !r.has(s.id) && s.dispose();
      }
      const i = this.state.scopeStack.pop();
      this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t.forEach((a) => {
        !a.kept && a.scopeId === i.id && this.track(a);
      });
    }
    gradients(e, t, r, i = false) {
      if (B(t.length > 0, () => "gradients() received an empty list of xs."), r != null && r.dtype !== "float32") throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);
      const a = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e));
      B(a instanceof _r, () => "The result y returned by f() must be a tensor.");
      const s = IAe(this.state.activeTape, t, a);
      if (!i && s.length === 0 && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      return this.tidy("backward", () => {
        const o = {};
        o[a.id] = r ?? EAe(a.shape), kAe(o, s, (u) => this.tidy(u), MAe);
        const l = t.map((u) => o[u.id]);
        return this.state.gradientDepth === 0 && (this.state.activeTape.forEach((u) => {
          for (const c of u.saved) c.dispose();
        }), this.state.activeTape = null), {
          value: a,
          grads: l
        };
      });
    }
    customGrad(e) {
      return B(l$(e), () => "The f passed in customGrad(f) must be a function."), (...t) => {
        B(t.every((o) => o instanceof _r), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
        let r;
        const i = {};
        t.forEach((o, l) => {
          i[l] = o;
        });
        const a = (o, l) => (r = e(...t, l), B(r.value instanceof _r, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), B(l$(r.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), r.value), s = (o, l) => {
          const u = r.gradFunc(o, l), c = Array.isArray(u) ? u : [
            u
          ];
          B(c.length === t.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), B(c.every((d) => d instanceof _r), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          const h = {};
          return c.forEach((d, f) => {
            h[f] = () => d;
          }), h;
        };
        return this.runKernelFunc({
          forwardFunc: a,
          backwardsFunc: s,
          inputs: i
        });
      };
    }
    readSync(e) {
      return this.state.tensorInfo.get(e).backend.readSync(e);
    }
    read(e) {
      return this.state.tensorInfo.get(e).backend.read(e);
    }
    readToGPU(e, t) {
      return this.state.tensorInfo.get(e).backend.readToGPU(e, t);
    }
    async time(e) {
      const t = hi(), r = await this.backend.time(e);
      return r.wallMs = hi() - t, r;
    }
    track(e) {
      return this.state.activeScope != null && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e;
    }
    get registeredVariables() {
      return this.state.registeredVariables;
    }
    reset() {
      this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new d4();
      for (const e in this.registry) this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
      this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }
  }
  qg.nextTensorId = 0;
  qg.nextVariableId = 0;
  function EAe(n) {
    const e = HM(X(n), "float32");
    return Q.makeTensor(e, n, "float32");
  }
  function l9() {
    const n = H7();
    if (n._tfengine == null) {
      const e = new nAe(n);
      n._tfengine = new qg(e);
    }
    return sAe(n._tfengine.ENV), DAe(() => n._tfengine), n._tfengine;
  }
  const Q = l9();
  function MAe(n, e) {
    const t = {
      a: n,
      b: e
    };
    return Q.runKernel(xc, t);
  }
  function PAe() {
    return typeof navigator < "u" && navigator != null;
  }
  function u9(n) {
    if (n || PAe()) {
      if (n || (n = navigator), n.product === "ReactNative") return true;
      const e = n.userAgent || n.vendor || (typeof window < "u" ? window.opera : "");
      if (!e) {
        const t = n;
        return t.userAgentData && t.userAgentData.mobile;
      }
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4));
    }
    return false;
  }
  function c9() {
    return typeof window < "u" && window.document != null || typeof WorkerGlobalScope < "u";
  }
  const aa = ne();
  aa.registerFlag("DEBUG", () => false, (n) => {
    n && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
  });
  aa.registerFlag("IS_BROWSER", () => c9());
  aa.registerFlag("IS_NODE", () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u");
  aa.registerFlag("IS_CHROME", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
  aa.registerFlag("IS_SAFARI", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
  aa.registerFlag("PROD", () => false);
  aa.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => aa.getBool("DEBUG"));
  aa.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
  aa.registerFlag("IS_TEST", () => false);
  aa.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => aa.getBool("DEBUG"));
  aa.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
  aa.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
  aa.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
  function bI(n, e) {
    let t = n;
    if (Ss(n)) return e === "string" ? [] : [
      n.length
    ];
    if (i9(n)) {
      const i = n.channels || "RGBA";
      return [
        n.height,
        n.width * i.length
      ];
    } else if (a9(n)) return [
      n.buffer.size / (e == null ? 4 : Hg(e))
    ];
    if (!Array.isArray(n)) return [];
    const r = [];
    for (; Array.isArray(t) || Ss(t) && e !== "string"; ) r.push(t.length), t = t[0];
    return Array.isArray(n) && ne().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && h9(n, r, []), r;
  }
  function h9(n, e, t) {
    if (t = t || [], !Array.isArray(n) && !Ss(n)) {
      B(e.length === 0, () => `Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);
      return;
    }
    B(e.length > 0, () => `Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`), B(n.length === e[0], () => `Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);
    const r = e.slice(1);
    for (let i = 0; i < n.length; ++i) h9(n[i], r, t.concat(i));
  }
  function f4(n, e, t, r) {
    if (n !== "string_or_numeric") {
      if (n == null) throw new Error("Expected dtype cannot be null.");
      if (n !== "numeric" && n !== e || n === "numeric" && e === "string") throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`);
    }
  }
  function U(n, e, t, r = "numeric") {
    if (n instanceof he()) return f4(r, n.dtype, e, t), n;
    let i = yc(n);
    if (i !== "string" && [
      "bool",
      "int32",
      "float32"
    ].indexOf(r) >= 0 && (i = r), f4(r, i, e, t), n == null || !Ss(n) && !Array.isArray(n) && typeof n != "number" && typeof n != "boolean" && typeof n != "string") {
      const l = n == null ? "null" : n.constructor.name;
      throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`);
    }
    const a = bI(n, i);
    !Ss(n) && !Array.isArray(n) && (n = [
      n
    ]);
    const o = i !== "string" ? sp(n, i) : Jl(n, [], true);
    return Q.makeTensor(o, a, i);
  }
  function d9(n, e, t, r = "numeric") {
    if (!Array.isArray(n)) throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);
    return n.map((a, s) => U(a, `${e}[${s}]`, t, r));
  }
  const LAe = "__op";
  function te(n) {
    const e = Object.keys(n);
    if (e.length !== 1) throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);
    let t = e[0];
    const r = n[t];
    t.endsWith("_") && (t = t.substring(0, t.length - 1)), t = t + LAe;
    const i = (...a) => {
      Q.startScope(t);
      try {
        const s = r(...a);
        return XM(s) && console.error("Cannot return a Promise inside of tidy."), Q.endScope(s), s;
      } catch (s) {
        throw Q.endScope(null), s;
      }
    };
    return Object.defineProperty(i, "name", {
      value: t,
      configurable: true
    }), i;
  }
  function FAe(n, e) {
    const t = U(n, "real", "complex"), r = U(e, "imag", "complex");
    Qx(t.shape, r.shape, `real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);
    const i = {
      real: t,
      imag: r
    };
    return Q.runKernel(tI, i);
  }
  const jg = te({
    complex_: FAe
  });
  function wI(n, e, t, r) {
    if (r == null) r = yc(n);
    else if (r === "complex64") throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (a9(n) || i9(n)) {
      if (r !== "float32" && r !== "int32") throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);
      return Q.backend.createTensorFromGPUData(n, e || t, r);
    }
    if (!Ss(n) && !Array.isArray(n) && typeof n != "number" && typeof n != "boolean" && typeof n != "string") throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (e != null) {
      su(e);
      const i = X(e), a = X(t);
      B(i === a, () => `Based on the provided shape, [${e}], the tensor should have ${i} values but has ${a}`);
      for (let s = 0; s < t.length; ++s) {
        const o = t[s], l = s === t.length - 1 ? o !== X(e.slice(s)) : true;
        B(t[s] === e[s] || !l, () => `Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `);
      }
    }
    return !Ss(n) && !Array.isArray(n) && (n = [
      n
    ]), e = e || t, n = r !== "string" ? sp(n, r) : Jl(n, [], true), Q.makeTensor(n, e, r);
  }
  function QM(n, e, t) {
    const r = bI(n, t);
    return wI(n, e, r, t);
  }
  class Sv {
    static join(e) {
      return new Sv(e).slice();
    }
    constructor(e) {
      if (this.shards = [], this.previousShardIndex = 0, e == null || (e instanceof Array || (e = [
        e
      ]), e = e.map((r) => Ss(r) ? r.buffer : r), e.length === 0)) return;
      this.bufferUniformSize = e[0].byteLength;
      let t = 0;
      for (let r = 0; r < e.length; r++) {
        const i = e[r];
        r !== e.length - 1 && i.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
        const a = t + i.byteLength;
        this.shards.push({
          buffer: i,
          start: t,
          end: a
        }), t = a;
      }
      this.shards.length === 0 && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
    }
    slice(e = 0, t = this.byteLength) {
      if (this.shards.length === 0) return new ArrayBuffer(0);
      if (e = isNaN(Number(e)) ? 0 : e, t = isNaN(Number(t)) ? 0 : t, e = Math.max(0, e), t = Math.min(this.byteLength, t), t <= e) return new ArrayBuffer(0);
      const r = this.findShardForByte(e);
      if (r === -1) throw new Error(`Could not find start shard for byte ${e}`);
      const i = t - e, a = new ArrayBuffer(i), s = new Uint8Array(a);
      let o = 0;
      for (let l = r; l < this.shards.length; l++) {
        const u = this.shards[l], h = e + o - u.start, d = o, p = Math.min(t, u.end) - u.start, g = new Uint8Array(u.buffer, h, p - h);
        if (s.set(g, d), o += g.length, t < u.end) break;
      }
      return a;
    }
    findShardForByte(e) {
      if (this.shards.length === 0 || e < 0 || e >= this.byteLength) return -1;
      if (this.bufferUniformSize != null) return this.previousShardIndex = Math.floor(e / this.bufferUniformSize), this.previousShardIndex;
      function t(i) {
        return e < i.start ? -1 : e >= i.end ? 1 : 0;
      }
      if (t(this.shards[this.previousShardIndex]) === 0) return this.previousShardIndex;
      const r = OAe(this.shards, t);
      return r === -1 ? -1 : (this.previousShardIndex = r, this.previousShardIndex);
    }
  }
  function OAe(n, e) {
    let t = 0, r = n.length;
    for (; t <= r; ) {
      const i = Math.floor((r - t) / 2) + t, a = e(n[i]);
      if (a === 0) return i;
      a < 0 ? r = i : t = i + 1;
    }
    return -1;
  }
  function ga() {
    return Q;
  }
  function p4() {
    return Q.memory();
  }
  function se(n, e) {
    return Q.tidy(n, e);
  }
  function jt(n) {
    s9(n).forEach((t) => t.dispose());
  }
  function qo(n) {
    return Q.keep(n);
  }
  function g4(n) {
    return Q.setBackend(n);
  }
  function m4() {
    return Q.ready();
  }
  function iA() {
    return Q.backendName;
  }
  function _I(n, e, t = 1) {
    return Q.registerBackend(n, e, t);
  }
  function BAe() {
    return Q.backend;
  }
  const v4 = 4;
  async function y4(n, e) {
    const t = [], r = [], i = Array.isArray(n) ? n.map((s) => s.name) : Object.keys(n);
    for (let s = 0; s < i.length; ++s) {
      const o = i[s], l = Array.isArray(n) ? n[s].tensor : n[o];
      if (l.dtype !== "float32" && l.dtype !== "int32" && l.dtype !== "bool" && l.dtype !== "string" && l.dtype !== "complex64") throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);
      const u = {
        name: o,
        shape: l.shape,
        dtype: l.dtype
      };
      if (l.dtype === "string") {
        const c = new Promise(async (h) => {
          const d = await l.bytes(), f = d.reduce((m, v) => m + v.length, 0) + v4 * d.length, p = new Uint8Array(f);
          let g = 0;
          for (let m = 0; m < d.length; m++) {
            const v = d[m], y = new Uint8Array(new Uint32Array([
              v.length
            ]).buffer);
            p.set(y, g), g += v4, p.set(v, g), g += v.length;
          }
          h(p);
        });
        r.push(c);
      } else r.push(l.data());
      e != null && (u.group = e), t.push(u);
    }
    const a = await Promise.all(r);
    return {
      data: zAe(a),
      specs: t
    };
  }
  function zAe(n) {
    if (n === null) throw new Error(`Invalid input value: ${JSON.stringify(n)}`);
    let e = 0;
    const t = [];
    n.forEach((a) => {
      if (e += a.byteLength, t.push(a.byteLength === a.buffer.byteLength ? a : new a.constructor(a)), !(a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array)) throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`);
    });
    const r = new Uint8Array(e);
    let i = 0;
    return t.forEach((a) => {
      r.set(new Uint8Array(a.buffer), i), i += a.byteLength;
    }), r.buffer;
  }
  const JM = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
  function x4(n) {
    return JM ? Buffer.byteLength(n, "utf8") : new Blob([
      n
    ]).size;
  }
  function VAe(n) {
    if (JM) return Buffer.from(n).toString("base64");
    const e = new Uint8Array(n);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
    return btoa(t);
  }
  function WAe(n) {
    if (JM) {
      const r = Buffer.from(n, "base64");
      return r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
    }
    const e = atob(n), t = new Uint8Array(e.length);
    for (let r = 0; r < e.length; ++r) t.set([
      e.charCodeAt(r)
    ], r);
    return t.buffer;
  }
  function GAe(n) {
    return Sv.join(n);
  }
  function f9(n) {
    if (n.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return {
      dateSaved: /* @__PURE__ */ new Date(),
      modelTopologyType: "JSON",
      modelTopologyBytes: n.modelTopology == null ? 0 : x4(JSON.stringify(n.modelTopology)),
      weightSpecsBytes: n.weightSpecs == null ? 0 : x4(JSON.stringify(n.weightSpecs)),
      weightDataBytes: n.weightData == null ? 0 : new Sv(n.weightData).byteLength
    };
  }
  class Ci {
    constructor() {
      this.saveRouters = [], this.loadRouters = [];
    }
    static getInstance() {
      return Ci.instance == null && (Ci.instance = new Ci()), Ci.instance;
    }
    static registerSaveRouter(e) {
      Ci.getInstance().saveRouters.push(e);
    }
    static registerLoadRouter(e) {
      Ci.getInstance().loadRouters.push(e);
    }
    static getSaveHandlers(e) {
      return Ci.getHandlers(e, "save");
    }
    static getLoadHandlers(e, t) {
      return Ci.getHandlers(e, "load", t);
    }
    static getHandlers(e, t, r) {
      const i = [];
      return (t === "load" ? Ci.getInstance().loadRouters : Ci.getInstance().saveRouters).forEach((s) => {
        const o = s(e, r);
        o !== null && i.push(o);
      }), i;
    }
  }
  const UAe = (n) => Ci.getSaveHandlers(n);
  const m$ = "tensorflowjs", v$ = 1, Gh = "models_store", Vu = "model_info_store";
  function p9() {
    if (!ne().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    const n = typeof window > "u" ? self : window, e = n.indexedDB || n.mozIndexedDB || n.webkitIndexedDB || n.msIndexedDB || n.shimIndexedDB;
    if (e == null) throw new Error("The current browser does not appear to support IndexedDB.");
    return e;
  }
  function y$(n) {
    const e = n.result;
    e.createObjectStore(Gh, {
      keyPath: "modelPath"
    }), e.createObjectStore(Vu, {
      keyPath: "modelPath"
    });
  }
  class xd {
    constructor(e) {
      if (this.indexedDB = p9(), e == null || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      this.modelPath = e;
    }
    async save(e) {
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      return this.databaseAction(this.modelPath, e);
    }
    async load() {
      return this.databaseAction(this.modelPath);
    }
    databaseAction(e, t) {
      return new Promise((r, i) => {
        const a = this.indexedDB.open(m$, v$);
        a.onupgradeneeded = () => y$(a), a.onsuccess = () => {
          const s = a.result;
          if (t == null) {
            const o = s.transaction(Gh, "readonly"), u = o.objectStore(Gh).get(this.modelPath);
            u.onsuccess = () => {
              if (u.result == null) return s.close(), i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
              r(u.result.modelArtifacts);
            }, u.onerror = (c) => (s.close(), i(u.error)), o.oncomplete = () => s.close();
          } else {
            t.weightData = Sv.join(t.weightData);
            const o = f9(t), l = s.transaction(Vu, "readwrite");
            let u = l.objectStore(Vu), c;
            try {
              c = u.put({
                modelPath: this.modelPath,
                modelArtifactsInfo: o
              });
            } catch (d) {
              return i(d);
            }
            let h;
            c.onsuccess = () => {
              h = s.transaction(Gh, "readwrite");
              const d = h.objectStore(Gh);
              let f;
              try {
                f = d.put({
                  modelPath: this.modelPath,
                  modelArtifacts: t,
                  modelArtifactsInfo: o
                });
              } catch (p) {
                return i(p);
              }
              f.onsuccess = () => r({
                modelArtifactsInfo: o
              }), f.onerror = (p) => {
                u = l.objectStore(Vu);
                const g = u.delete(this.modelPath);
                g.onsuccess = () => (s.close(), i(f.error)), g.onerror = (m) => (s.close(), i(f.error));
              };
            }, c.onerror = (d) => (s.close(), i(c.error)), l.oncomplete = () => {
              h == null ? s.close() : h.oncomplete = () => s.close();
            };
          }
        }, a.onerror = (s) => i(a.error);
      });
    }
  }
  xd.URL_SCHEME = "indexeddb://";
  const g9 = (n) => ne().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(xd.URL_SCHEME) ? HAe(n.slice(xd.URL_SCHEME.length)) : null;
  Ci.registerSaveRouter(g9);
  Ci.registerLoadRouter(g9);
  function HAe(n) {
    return new xd(n);
  }
  function XAe(n) {
    return n.startsWith(xd.URL_SCHEME) ? n.slice(xd.URL_SCHEME.length) : n;
  }
  class YAe {
    constructor() {
      this.indexedDB = p9();
    }
    async listModels() {
      return new Promise((e, t) => {
        const r = this.indexedDB.open(m$, v$);
        r.onupgradeneeded = () => y$(r), r.onsuccess = () => {
          const i = r.result, a = i.transaction(Vu, "readonly"), o = a.objectStore(Vu).getAll();
          o.onsuccess = () => {
            const l = {};
            for (const u of o.result) l[u.modelPath] = u.modelArtifactsInfo;
            e(l);
          }, o.onerror = (l) => (i.close(), t(o.error)), a.oncomplete = () => i.close();
        }, r.onerror = (i) => t(r.error);
      });
    }
    async removeModel(e) {
      return e = XAe(e), new Promise((t, r) => {
        const i = this.indexedDB.open(m$, v$);
        i.onupgradeneeded = () => y$(i), i.onsuccess = () => {
          const a = i.result, s = a.transaction(Vu, "readwrite"), o = s.objectStore(Vu), l = o.get(e);
          let u;
          l.onsuccess = () => {
            if (l.result == null) return a.close(), r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));
            {
              const c = o.delete(e), h = () => {
                u = a.transaction(Gh, "readwrite");
                const f = u.objectStore(Gh).delete(e);
                f.onsuccess = () => t(l.result.modelArtifactsInfo), f.onerror = (p) => r(l.error);
              };
              c.onsuccess = h, c.onerror = (d) => (h(), a.close(), r(l.error));
            }
          }, l.onerror = (c) => (a.close(), r(l.error)), s.oncomplete = () => {
            u == null ? a.close() : u.oncomplete = () => a.close();
          };
        }, i.onerror = (a) => r(i.error);
      });
    }
  }
  const kl = "/", cg = "tensorflowjs_models", m9 = "info", qAe = "model_topology", jAe = "weight_specs", KAe = "weight_data", ZAe = "model_metadata";
  function v9(n) {
    return {
      info: [
        cg,
        n,
        m9
      ].join(kl),
      topology: [
        cg,
        n,
        qAe
      ].join(kl),
      weightSpecs: [
        cg,
        n,
        jAe
      ].join(kl),
      weightData: [
        cg,
        n,
        KAe
      ].join(kl),
      modelMetadata: [
        cg,
        n,
        ZAe
      ].join(kl)
    };
  }
  function y9(n) {
    for (const e of Object.values(n)) window.localStorage.removeItem(e);
  }
  function QAe(n) {
    const e = n.split(kl);
    if (e.length < 3) throw new Error(`Invalid key format: ${n}`);
    return e.slice(1, e.length - 1).join(kl);
  }
  function JAe(n) {
    return n.startsWith(bd.URL_SCHEME) ? n.slice(bd.URL_SCHEME.length) : n;
  }
  class bd {
    constructor(e) {
      if (!ne().getBool("IS_BROWSER") || typeof window > "u" || typeof window.localStorage > "u") throw new Error("The current environment does not support local storage.");
      if (this.LS = window.localStorage, e == null || !e) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      this.modelPath = e, this.keys = v9(this.modelPath);
    }
    async save(e) {
      if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      {
        const t = JSON.stringify(e.modelTopology), r = JSON.stringify(e.weightSpecs), i = f9(e), a = Sv.join(e.weightData);
        try {
          this.LS.setItem(this.keys.info, JSON.stringify(i)), this.LS.setItem(this.keys.topology, t), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, VAe(a));
          const s = {
            format: e.format,
            generatedBy: e.generatedBy,
            convertedBy: e.convertedBy,
            signature: e.signature != null ? e.signature : void 0,
            userDefinedMetadata: e.userDefinedMetadata != null ? e.userDefinedMetadata : void 0,
            modelInitializer: e.modelInitializer != null ? e.modelInitializer : void 0,
            initializerSignature: e.initializerSignature != null ? e.initializerSignature : void 0,
            trainingConfig: e.trainingConfig != null ? e.trainingConfig : void 0
          };
          return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(s)), {
            modelArtifactsInfo: i
          };
        } catch {
          throw y9(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`);
        }
      }
    }
    async load() {
      const e = JSON.parse(this.LS.getItem(this.keys.info));
      if (e == null) throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
      if (e.modelTopologyType !== "JSON") throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      const t = {}, r = JSON.parse(this.LS.getItem(this.keys.topology));
      if (r == null) throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
      t.modelTopology = r;
      const i = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
      if (i == null) throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
      t.weightSpecs = i;
      const a = this.LS.getItem(this.keys.modelMetadata);
      if (a != null) {
        const o = JSON.parse(a);
        t.format = o.format, t.generatedBy = o.generatedBy, t.convertedBy = o.convertedBy, o.signature != null && (t.signature = o.signature), o.userDefinedMetadata != null && (t.userDefinedMetadata = o.userDefinedMetadata), o.modelInitializer != null && (t.modelInitializer = o.modelInitializer), o.initializerSignature != null && (t.initializerSignature = o.initializerSignature), o.trainingConfig != null && (t.trainingConfig = o.trainingConfig);
      }
      const s = this.LS.getItem(this.keys.weightData);
      if (s == null) throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
      return t.weightData = WAe(s), t;
    }
  }
  bd.URL_SCHEME = "localstorage://";
  const x9 = (n) => ne().getBool("IS_BROWSER") && !Array.isArray(n) && n.startsWith(bd.URL_SCHEME) ? eDe(n.slice(bd.URL_SCHEME.length)) : null;
  Ci.registerSaveRouter(x9);
  Ci.registerLoadRouter(x9);
  function eDe(n) {
    return new bd(n);
  }
  class tDe {
    constructor() {
      B(ne().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), B(typeof window > "u" || typeof window.localStorage < "u", () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
    }
    async listModels() {
      const e = {}, t = cg + kl, r = kl + m9;
      for (let i = 0; i < this.LS.length; ++i) {
        const a = this.LS.key(i);
        if (a.startsWith(t) && a.endsWith(r)) {
          const s = QAe(a);
          e[s] = JSON.parse(this.LS.getItem(a));
        }
      }
      return e;
    }
    async removeModel(e) {
      e = JAe(e);
      const t = v9(e);
      if (this.LS.getItem(t.info) == null) throw new Error(`Cannot find model at path '${e}'`);
      const r = JSON.parse(this.LS.getItem(t.info));
      return y9(t), r;
    }
  }
  const b4 = "://";
  class No {
    constructor() {
      this.managers = {};
    }
    static getInstance() {
      return No.instance == null && (No.instance = new No()), No.instance;
    }
    static registerManager(e, t) {
      B(e != null, () => "scheme must not be undefined or null."), e.endsWith(b4) && (e = e.slice(0, e.indexOf(b4))), B(e.length > 0, () => "scheme must not be an empty string.");
      const r = No.getInstance();
      B(r.managers[e] == null, () => `A model store manager is already registered for scheme '${e}'.`), r.managers[e] = t;
    }
    static getManager(e) {
      const t = No.getInstance().managers[e];
      if (t == null) throw new Error(`Cannot find model manager for scheme '${e}'`);
      return t;
    }
    static getSchemes() {
      return Object.keys(No.getInstance().managers);
    }
  }
  class nDe {
    constructor() {
      this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = false;
    }
    fetch(e, t) {
      return fetch(e, t);
    }
    now() {
      return performance.now();
    }
    encode(e, t) {
      if (t !== "utf-8" && t !== "utf8") throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);
      return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e);
    }
    decode(e, t) {
      return new TextDecoder(t).decode(e);
    }
    setTimeoutCustom(e, t) {
      if (typeof window > "u" || !ne().getBool("USE_SETTIMEOUTCUSTOM")) {
        setTimeout(e, t);
        return;
      }
      this.functionRefs.push(e), setTimeout(() => {
        window.postMessage({
          name: this.messageName,
          index: this.functionRefs.length - 1
        }, "*");
      }, t), this.hasEventListener || (this.hasEventListener = true, window.addEventListener("message", (r) => {
        if (r.source === window && r.data.name === this.messageName) {
          r.stopPropagation();
          const i = this.functionRefs[r.data.index];
          i(), this.handledMessageCount++, this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], this.handledMessageCount = 0);
        }
      }, true));
    }
    isTypedArray(e) {
      return Q7(e);
    }
  }
  if (ne().get("IS_BROWSER")) {
    ne().setPlatform("browser", new nDe());
    try {
      No.registerManager(bd.URL_SCHEME, new tDe());
    } catch {
    }
    try {
      No.registerManager(xd.URL_SCHEME, new YAe());
    } catch {
    }
  }
  const rDe = {
    importFetch: () => require("node-fetch")
  };
  let aA;
  class iDe {
    constructor() {
      this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
    }
    fetch(e, t) {
      return ne().global.fetch != null ? ne().global.fetch(e, t) : (aA == null && (aA = rDe.importFetch()), aA(e, t));
    }
    now() {
      const e = process.hrtime();
      return e[0] * 1e3 + e[1] / 1e6;
    }
    encode(e, t) {
      if (t !== "utf-8" && t !== "utf8") throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);
      return this.textEncoder.encode(e);
    }
    decode(e, t) {
      return e.length === 0 ? "" : new this.util.TextDecoder(t).decode(e);
    }
    isTypedArray(e) {
      return this.util.types.isFloat32Array(e) || this.util.types.isInt32Array(e) || this.util.types.isUint8Array(e) || this.util.types.isUint8ClampedArray(e);
    }
  }
  ne().get("IS_NODE") && !ne().get("IS_BROWSER") && ne().setPlatform("node", new iDe());
  function Nt(n, e = "float32", t) {
    return e = e || "float32", su(n), new ii(n, e, t);
  }
  function aDe(n, e) {
    const t = U(n, "x", "cast");
    if (!JTe(e)) throw new Error(`Failed to cast to unknown dtype ${e}`);
    if (e === "string" && t.dtype !== "string" || e !== "string" && t.dtype === "string") throw new Error("Only strings can be casted to strings");
    const r = {
      x: t
    }, i = {
      dtype: e
    };
    return Q.runKernel(Zd, r, i);
  }
  const Ve = te({
    cast_: aDe
  });
  function sDe(n) {
    const t = {
      x: U(n, "x", "clone", "string_or_numeric")
    };
    return Q.runKernel(vf, t);
  }
  const id = te({
    clone_: sDe
  });
  function oDe(n, e = false) {
    console.log(n.toString(e));
  }
  l9();
  const lDe = {
    buffer: Nt,
    cast: Ve,
    clone: id,
    print: oDe
  };
  RAe(lDe);
  function uDe(n, e) {
    let t = U(n, "a", "add"), r = U(e, "b", "add");
    [t, r] = hr(t, r);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(xc, i);
  }
  const Ce = te({
    add_: uDe
  });
  function cDe(n, e) {
    let t = U(n, "a", "floorDiv"), r = U(e, "b", "floorDiv");
    [t, r] = hr(t, r);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(pf, i);
  }
  const b9 = te({
    floorDiv_: cDe
  });
  function hDe(n, e) {
    let t = U(n, "a", "div"), r = U(e, "b", "div");
    if ([t, r] = hr(t, r), t.dtype === "int32" && r.dtype === "int32") return b9(t, r);
    const i = {
      a: t,
      b: r
    }, a = {};
    return Q.runKernel(lf, i, a);
  }
  const gt = te({
    div_: hDe
  });
  function dDe(n, e) {
    let t = U(n, "a", "mul"), r = U(e, "b", "mul");
    [t, r] = hr(t, r);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(Ef, i);
  }
  const Z = te({
    mul_: dDe
  });
  function fDe(n) {
    const e = U(n, "x", "abs");
    if (e.dtype === "complex64") {
      const t = {
        x: e
      };
      return Q.runKernel(tb, t);
    } else {
      const t = {
        x: e
      };
      return Q.runKernel(Dm, t);
    }
  }
  const ki = te({
    abs_: fDe
  });
  function pDe(n) {
    const t = {
      x: U(n, "x", "acos")
    };
    return Q.runKernel(Wd, t);
  }
  const gDe = te({
    acos_: pDe
  });
  function mDe(n) {
    const t = {
      x: U(n, "x", "acosh")
    };
    return Q.runKernel(Gd, t);
  }
  const vDe = te({
    acosh_: mDe
  });
  function yDe(n, e = null, t = false) {
    const i = {
      x: U(n, "x", "all", "bool")
    }, a = {
      axis: e,
      keepDims: t
    };
    return Q.runKernel($m, i, a);
  }
  const w9 = te({
    all_: yDe
  });
  function xDe(n, e = null, t = false) {
    const i = {
      x: U(n, "x", "any", "bool")
    }, a = {
      axis: e,
      keepDims: t
    };
    return Q.runKernel(Nm, i, a);
  }
  const x$ = te({
    any_: xDe
  });
  function bDe(n, e = 0) {
    const r = {
      x: U(n, "x", "argMax")
    }, i = {
      axis: e
    };
    return Q.runKernel(Em, r, i);
  }
  const rx = te({
    argMax_: bDe
  });
  function wDe(n, e = 0) {
    const r = {
      x: U(n, "x", "argMin")
    }, i = {
      axis: e
    };
    return Q.runKernel(Mm, r, i);
  }
  const _De = te({
    argMin_: wDe
  });
  function SDe(n) {
    const t = {
      x: U(n, "x", "asin")
    };
    return Q.runKernel(Ud, t);
  }
  const CDe = te({
    asin_: SDe
  });
  function IDe(n) {
    const t = {
      x: U(n, "x", "asinh")
    };
    return Q.runKernel(Hd, t);
  }
  const kDe = te({
    asinh_: IDe
  });
  function TDe(n) {
    const t = {
      x: U(n, "x", "atan")
    };
    return Q.runKernel(Xd, t);
  }
  const ADe = te({
    atan_: TDe
  });
  function DDe(n, e) {
    let t = U(n, "a", "atan2"), r = U(e, "b", "atan2");
    [t, r] = hr(t, r);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(qd, i);
  }
  const RDe = te({
    atan2_: DDe
  });
  function $De(n) {
    const t = {
      x: U(n, "x", "atanh")
    };
    return Q.runKernel(Yd, t);
  }
  const NDe = te({
    atanh_: $De
  });
  function po(n, e, t, r, i = "NHWC", a) {
    const s = n[3], o = [
      ...e,
      s
    ], l = Oi(i);
    return Sn(n, o, t, a, r, null, null, l);
  }
  function dr(n, e, t, r, i, a, s = "channelsLast") {
    const [o, l] = ix(e);
    let u;
    if (s === "channelsLast") u = [
      o,
      l,
      n[3],
      n[3]
    ];
    else if (s === "channelsFirst") u = [
      o,
      l,
      n[1],
      n[1]
    ];
    else throw new Error(`Unknown dataFormat ${s}`);
    return Sn(n, u, t, r, i, a, false, s);
  }
  function vi(n, e, t, r, i, a, s = "NDHWC") {
    const [o, l, u] = b$(e);
    let c, h;
    if (s === "NDHWC") h = "channelsLast", c = [
      o,
      l,
      u,
      n[4],
      n[4]
    ];
    else if (s === "NCDHW") h = "channelsFirst", c = [
      o,
      l,
      u,
      n[1],
      n[1]
    ];
    else throw new Error(`Unknown dataFormat ${s}`);
    return Ra(n, c, t, r, i, false, h, a);
  }
  function Sn(n, e, t, r, i, a, s = false, o = "channelsLast") {
    let [l, u, c, h] = [
      -1,
      -1,
      -1,
      -1
    ];
    if (o === "channelsLast") [l, u, c, h] = n;
    else if (o === "channelsFirst") [l, h, u, c] = n;
    else throw new Error(`Unknown dataFormat ${o}`);
    const [d, f, , p] = e, [g, m] = ix(t), [v, y] = ix(r), x = Ag(d, v), b = Ag(f, y), { padInfo: w, outHeight: _, outWidth: S } = PDe(i, u, c, g, m, x, b, a, o), I = s ? p * h : p;
    let C;
    return o === "channelsFirst" ? C = [
      l,
      I,
      _,
      S
    ] : o === "channelsLast" && (C = [
      l,
      _,
      S,
      I
    ]), {
      batchSize: l,
      dataFormat: o,
      inHeight: u,
      inWidth: c,
      inChannels: h,
      outHeight: _,
      outWidth: S,
      outChannels: I,
      padInfo: w,
      strideHeight: g,
      strideWidth: m,
      filterHeight: d,
      filterWidth: f,
      effectiveFilterHeight: x,
      effectiveFilterWidth: b,
      dilationHeight: v,
      dilationWidth: y,
      inShape: n,
      outShape: C,
      filterShape: e
    };
  }
  function Ra(n, e, t, r, i, a = false, s = "channelsLast", o) {
    let [l, u, c, h, d] = [
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    if (s === "channelsLast") [l, u, c, h, d] = n;
    else if (s === "channelsFirst") [l, d, u, c, h] = n;
    else throw new Error(`Unknown dataFormat ${s}`);
    const [f, p, g, , m] = e, [v, y, x] = b$(t), [b, w, _] = b$(r), S = Ag(f, b), I = Ag(p, w), C = Ag(g, _), { padInfo: T, outDepth: k, outHeight: D, outWidth: R } = LDe(i, u, c, h, v, y, x, S, I, C, o), N = a ? m * d : m;
    let E;
    return s === "channelsFirst" ? E = [
      l,
      N,
      k,
      D,
      R
    ] : s === "channelsLast" && (E = [
      l,
      k,
      D,
      R,
      N
    ]), {
      batchSize: l,
      dataFormat: s,
      inDepth: u,
      inHeight: c,
      inWidth: h,
      inChannels: d,
      outDepth: k,
      outHeight: D,
      outWidth: R,
      outChannels: N,
      padInfo: T,
      strideDepth: v,
      strideHeight: y,
      strideWidth: x,
      filterDepth: f,
      filterHeight: p,
      filterWidth: g,
      effectiveFilterDepth: S,
      effectiveFilterHeight: I,
      effectiveFilterWidth: C,
      dilationDepth: b,
      dilationHeight: w,
      dilationWidth: _,
      inShape: n,
      outShape: E,
      filterShape: e
    };
  }
  function EDe(n, e, t, r, i) {
    r == null && (r = eP(n, e, t));
    const a = n[0], s = n[1], o = ax((a - e + 2 * r) / t + 1, i), l = ax((s - e + 2 * r) / t + 1, i);
    return [
      o,
      l
    ];
  }
  function MDe(n, e, t, r, i, a) {
    i == null && (i = eP(n, e[0], r[0]));
    const s = [
      0,
      0,
      0,
      t
    ];
    for (let o = 0; o < 3; o++) n[o] + 2 * i >= e[o] && (s[o] = ax((n[o] - e[o] + 2 * i) / r[o] + 1, a));
    return s;
  }
  function eP(n, e, t, r = 1) {
    const i = Ag(e, r);
    return Math.floor((n[0] * (t - 1) - t + i) / 2);
  }
  function ix(n) {
    return typeof n == "number" ? [
      n,
      n,
      n
    ] : n.length === 2 ? [
      n[0],
      n[1],
      1
    ] : n;
  }
  function b$(n) {
    return typeof n == "number" ? [
      n,
      n,
      n
    ] : n;
  }
  function Ag(n, e) {
    return e <= 1 ? n : n + (n - 1) * (e - 1);
  }
  function PDe(n, e, t, r, i, a, s, o, l) {
    let u, c, h;
    if (typeof n == "number") {
      u = {
        top: n,
        bottom: n,
        left: n,
        right: n,
        type: n === 0 ? "VALID" : "NUMBER"
      };
      const f = EDe([
        e,
        t
      ], a, r, n, o);
      c = f[0], h = f[1];
    } else if (n === "same") {
      c = Math.ceil(e / r), h = Math.ceil(t / i);
      const d = Math.max(0, (c - 1) * r + a - e), f = Math.max(0, (h - 1) * i + s - t), p = Math.floor(d / 2), g = d - p, m = Math.floor(f / 2), v = f - m;
      u = {
        top: p,
        bottom: g,
        left: m,
        right: v,
        type: "SAME"
      };
    } else if (n === "valid") u = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      type: "VALID"
    }, c = Math.ceil((e - a + 1) / r), h = Math.ceil((t - s + 1) / i);
    else if (typeof n == "object") {
      const d = l === "channelsLast" ? n[1][0] : n[2][0], f = l === "channelsLast" ? n[1][1] : n[2][1], p = l === "channelsLast" ? n[2][0] : n[3][0], g = l === "channelsLast" ? n[2][1] : n[3][1];
      u = {
        top: d,
        bottom: f,
        left: p,
        right: g,
        type: d === 0 && f === 0 && p === 0 && g === 0 ? "VALID" : "EXPLICIT"
      }, c = ax((e - a + d + f) / r + 1, o), h = ax((t - s + p + g) / i + 1, o);
    } else throw Error(`Unknown padding parameter: ${n}`);
    return {
      padInfo: u,
      outHeight: c,
      outWidth: h
    };
  }
  function LDe(n, e, t, r, i, a, s, o, l, u, c) {
    let h, d, f, p;
    if (n === "valid" && (n = 0), typeof n == "number") {
      h = {
        top: n,
        bottom: n,
        left: n,
        right: n,
        front: n,
        back: n,
        type: n === 0 ? "VALID" : "NUMBER"
      };
      const m = MDe([
        e,
        t,
        r,
        1
      ], [
        o,
        l,
        u
      ], 1, [
        i,
        a,
        s
      ], n, c);
      d = m[0], f = m[1], p = m[2];
    } else if (n === "same") {
      d = Math.ceil(e / i), f = Math.ceil(t / a), p = Math.ceil(r / s);
      const g = (d - 1) * i + o - e, m = (f - 1) * a + l - t, v = (p - 1) * s + u - r, y = Math.floor(g / 2), x = g - y, b = Math.floor(m / 2), w = m - b, _ = Math.floor(v / 2), S = v - _;
      h = {
        top: b,
        bottom: w,
        left: _,
        right: S,
        front: y,
        back: x,
        type: "SAME"
      };
    } else throw Error(`Unknown padding parameter: ${n}`);
    return {
      padInfo: h,
      outDepth: d,
      outHeight: f,
      outWidth: p
    };
  }
  function ax(n, e) {
    if (!e) return Math.trunc(n);
    switch (e) {
      case "round":
        return Math.round(n);
      case "ceil":
        return Math.ceil(n);
      case "floor":
        return Math.floor(n);
      default:
        throw new Error(`Unknown roundingMode ${e}`);
    }
  }
  function wd(n) {
    const [e, t, r] = ix(n);
    return e === 1 && t === 1 && r === 1;
  }
  function Pr(n, e) {
    return wd(n) || wd(e);
  }
  function _d(n) {
    return ix(n).every((e) => e > 0);
  }
  function Oi(n) {
    if (n === "NHWC") return "channelsLast";
    if (n === "NCHW") return "channelsFirst";
    throw new Error(`Unknown dataFormat ${n}`);
  }
  function la(n, e, t) {
    if (t != null) {
      if (typeof e == "string") throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);
      if (typeof e == "number") B(Ug(e), () => `Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);
      else if (typeof e == "object") e.forEach((r) => {
        r.forEach((i) => {
          B(Ug(i), () => `Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`);
        });
      });
      else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`);
    }
  }
  function FDe(n, e) {
    const r = {
      x: U(n, "x", "reshape", "string_or_numeric")
    }, i = {
      shape: e
    };
    return Q.runKernel(uv, r, i);
  }
  const ee = te({
    reshape_: FDe
  });
  function ODe(n, e, t, r, i) {
    const a = U(n, "x", "avgPool", "float32"), s = 1;
    B(Pr(t, s), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);
    let o = a, l = false;
    a.rank === 3 && (l = true, o = ee(a, [
      1,
      a.shape[0],
      a.shape[1],
      a.shape[2]
    ])), B(o.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${o.rank}.`), la("avgPool", r, i);
    const u = {
      x: o
    }, c = {
      filterSize: e,
      strides: t,
      pad: r,
      dimRoundingMode: i
    };
    let h = Q.runKernel(jd, u, c);
    return h = Ve(h, a.dtype), l ? ee(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3]
    ]) : h;
  }
  const tP = te({
    avgPool_: ODe
  });
  function BDe(n, e, t, r, i, a = "NDHWC") {
    const s = U(n, "x", "avgPool3d", "float32");
    let o = s, l = false;
    s.rank === 4 && (l = true, o = ee(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2],
      s.shape[3]
    ])), B(o.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`), B(a === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`), B(typeof t == "number" && t > 0 || Array.isArray(t) && t[0] > 0 && t[1] > 0 && t[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${t}'`), la("avgPool3d", r, i);
    const u = {
      x: o
    }, c = {
      filterSize: e,
      strides: t,
      pad: r,
      dimRoundingMode: i,
      dataFormat: a
    };
    let h = Q.runKernel(Pm, u, c);
    return h = Ve(h, o.dtype), l ? ee(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3],
      h.shape[4]
    ]) : h;
  }
  const zDe = te({
    avgPool3d_: BDe
  });
  function VDe(n, e = 0) {
    B(n.length >= 1, () => "Pass at least one tensor to concat");
    const t = d9(n, "tensors", "concat", "string_or_numeric");
    if (t[0].dtype === "complex64" && t.forEach((a) => {
      if (a.dtype !== "complex64") throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `);
    }), t.length === 1) return id(t[0]);
    const r = t, i = {
      axis: e
    };
    return Q.runKernel(Om, r, i);
  }
  const Qi = te({
    concat_: VDe
  });
  function WDe(n, e, t = false, r = false) {
    let i = U(n, "a", "matMul"), a = U(e, "b", "matMul");
    [i, a] = hr(i, a);
    const s = {
      a: i,
      b: a
    }, o = {
      transposeA: t,
      transposeB: r
    };
    return Q.runKernel(Kd, s, o);
  }
  const mn = te({
    matMul_: WDe
  });
  function GDe(n) {
    const t = {
      x: U(n, "x", "sigmoid", "float32")
    };
    return Q.runKernel(Zf, t);
  }
  const Cv = te({
    sigmoid_: GDe
  });
  function UDe(n, e, t) {
    const r = U(n, "x", "slice", "string_or_numeric");
    if (r.rank === 0) throw new Error("Slicing scalar is not possible");
    const i = {
      x: r
    }, a = {
      begin: e,
      size: t
    };
    return Q.runKernel(fv, i, a);
  }
  const Wn = te({
    slice_: UDe
  });
  function HDe(n) {
    const t = {
      x: U(n, "x", "tanh", "float32")
    };
    return Q.runKernel(ap, t);
  }
  const SI = te({
    tanh_: HDe
  });
  function XDe(n, e, t) {
    const r = U(n, "x", "batchToSpaceND"), i = e.reduce((o, l) => o * l);
    B(r.rank >= 1 + e.length, () => `input rank is ${r.rank} but should be > than blockShape.length ${e.length}`), B(t.length === e.length, () => `crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`), B(r.shape[0] % i === 0, () => `input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);
    const a = {
      x: r
    }, s = {
      blockShape: e,
      crops: t
    };
    return Q.runKernel(Lm, a, s);
  }
  const nP = te({
    batchToSpaceND_: XDe
  });
  function YDe(n) {
    let e;
    return n.rank === 0 || n.rank === 1 ? e = ee(n, [
      1,
      1,
      1,
      n.size
    ]) : n.rank === 2 ? e = ee(n, [
      1,
      1,
      n.shape[0],
      n.shape[1]
    ]) : n.rank === 3 ? e = ee(n, [
      1,
      n.shape[0],
      n.shape[1],
      n.shape[2]
    ]) : e = n, e;
  }
  function qDe(n, e, t, r, i, a) {
    a == null && (a = 1e-3);
    const s = U(n, "x", "batchNorm"), o = U(e, "mean", "batchNorm"), l = U(t, "variance", "batchNorm");
    let u;
    i != null && (u = U(i, "scale", "batchNorm"));
    let c;
    r != null && (c = U(r, "offset", "batchNorm")), B(o.rank === l.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), B(c == null || o.rank === c.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), B(u == null || o.rank === u.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    const d = {
      x: YDe(s),
      scale: u,
      offset: c,
      mean: o,
      variance: l
    }, f = {
      varianceEpsilon: a
    }, p = Q.runKernel(gf, d, f);
    return ee(p, s.shape);
  }
  const CI = te({
    batchNorm_: qDe
  });
  function jDe(n, e, t, r, i, a) {
    const s = U(n, "x", "batchNorm"), o = U(e, "mean", "batchNorm"), l = U(t, "variance", "batchNorm");
    let u;
    i != null && (u = U(i, "scale", "batchNorm"));
    let c;
    return r != null && (c = U(r, "offset", "batchNorm")), B(s.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${s.rank}.`), B(o.rank === 2 || o.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`), B(l.rank === 2 || l.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`), u != null && B(u.rank === 2 || u.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`), c != null && B(c.rank === 2 || c.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`), CI(s, o, l, c, u, a);
  }
  const KDe = te({
    batchNorm2d_: jDe
  });
  function ZDe(n, e, t, r, i, a) {
    const s = U(n, "x", "batchNorm"), o = U(e, "mean", "batchNorm"), l = U(t, "variance", "batchNorm");
    let u;
    i != null && (u = U(i, "scale", "batchNorm"));
    let c;
    return r != null && (c = U(r, "offset", "batchNorm")), B(s.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${s.rank}.`), B(o.rank === 3 || o.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`), B(l.rank === 3 || l.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`), u != null && B(u.rank === 3 || u.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`), c != null && B(c.rank === 3 || c.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`), CI(s, o, l, c, u, a);
  }
  const QDe = te({
    batchNorm3d_: ZDe
  });
  function JDe(n, e, t, r, i, a) {
    const s = U(n, "x", "batchNorm"), o = U(e, "mean", "batchNorm"), l = U(t, "variance", "batchNorm");
    let u;
    i != null && (u = U(i, "scale", "batchNorm"));
    let c;
    return r != null && (c = U(r, "offset", "batchNorm")), B(s.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${s.rank}.`), B(o.rank === 4 || o.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`), B(l.rank === 4 || l.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`), u != null && B(u.rank === 4 || u.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`), c != null && B(c.rank === 4 || c.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`), CI(s, o, l, c, u, a);
  }
  const eRe = te({
    batchNorm4d_: JDe
  });
  function tRe(n, e, t) {
    const r = U(n, "x", "bincount"), i = U(e, "weights", "bincount");
    B(r.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${r.dtype}`), B(t >= 0, () => `size must be non-negative, but got ${t}.`), B(i.size === r.size || i.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`);
    const a = {
      x: r,
      weights: i
    }, s = {
      size: t
    };
    return Q.runKernel(Fm, a, s);
  }
  const nRe = te({
    bincount_: tRe
  });
  function rRe(n, e) {
    let t = U(n, "broadcastTo", "x");
    const r = t.shape;
    if (su(e), e.length < t.rank) throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);
    if (e.length > t.rank) {
      const u = t.shape.slice();
      for (; u.length < e.length; ) u.unshift(1);
      t = ee(t, u);
    }
    const i = t.shape, a = Array.from(e);
    for (let u = e.length - 1; u >= 0; u--) if (i[u] === e[u]) a[u] = 1;
    else if (t.shape[u] !== 1) throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);
    if (a.map((u, c) => u > 1 ? c : -1).filter((u) => u >= 0).length === 0) return id(t);
    const o = {
      x: t
    }, l = {
      reps: a
    };
    return Q.runKernel(wc, o, l);
  }
  const g0 = te({
    broadcastTo_: rRe
  });
  function iRe(n) {
    const t = {
      x: U(n, "x", "ceil", "float32")
    };
    return Q.runKernel(Qd, t);
  }
  const aRe = te({
    ceil_: iRe
  });
  function II(n, e, t) {
    su(n), t = t || yc(e);
    const r = {
      shape: n,
      value: e,
      dtype: t
    };
    return Q.runKernel(rb, {}, r);
  }
  function sRe(n, e, t) {
    const r = U(n, "x", "clipByValue");
    if (B(e <= t, () => `Error in clip: min (${e}) must be less than or equal to max (${t}).`), e === t) return II(r.shape, e, r.dtype);
    const i = {
      x: r
    }, a = {
      clipValueMin: e,
      clipValueMax: t
    };
    return Q.runKernel(bc, i, a);
  }
  const Xa = te({
    clipByValue_: sRe
  });
  function oRe(n) {
    return Qi(n, 0);
  }
  const lRe = te({
    concat1d_: oRe
  });
  function uRe(n, e) {
    return Qi(n, e);
  }
  const cRe = te({
    concat2d_: uRe
  });
  function hRe(n, e) {
    return Qi(n, e);
  }
  const dRe = te({
    concat3d_: hRe
  });
  function fRe(n, e) {
    return Qi(n, e);
  }
  const pRe = te({
    concat4d_: fRe
  });
  function gRe(n, e, t, r, i = "NHWC", a = [
    1,
    1
  ], s) {
    const o = U(n, "x", "conv2d", "float32"), l = U(e, "filter", "conv2d", "float32");
    let u = o, c = false;
    o.rank === 3 && (c = true, u = ee(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2]
    ])), B(u.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${u.rank}.`), B(l.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`), la("conv2d", r, s);
    const h = i === "NHWC" ? u.shape[3] : u.shape[1];
    B(h === l.shape[2], () => `Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`), B(Pr(t, a), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`), B(_d(a), () => "Error in conv2D: Dilated rates should be larger than 0."), B(_d(t), () => "Error in conv2D: Strides should be larger than 0.");
    const d = {
      x: u,
      filter: l
    }, f = {
      strides: t,
      pad: r,
      dataFormat: i,
      dilations: a,
      dimRoundingMode: s
    }, p = Q.runKernel(Jd, d, f);
    return c ? ee(p, [
      p.shape[1],
      p.shape[2],
      p.shape[3]
    ]) : p;
  }
  const Sd = te({
    conv2d_: gRe
  });
  function mRe(n, e, t, r, i = "NWC", a = 1, s) {
    const o = U(n, "x", "conv1d"), l = U(e, "filter", "conv1d");
    let u = o, c = false;
    o.rank === 2 && (c = true, u = ee(o, [
      1,
      o.shape[0],
      o.shape[1]
    ])), B(u.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${u.rank}.`), B(l.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`), la("conv1d", r, s), B(u.shape[2] === l.shape[1], () => `Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`), B(Pr(t, a), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`), B(_d(a), () => "Error in conv1D: Dilated rates should be larger than 0."), B(_d(t), () => "Error in conv1D: Stride should be larger than 0."), B(i === "NWC", () => `Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);
    const h = ee(l, [
      1,
      l.shape[0],
      l.shape[1],
      l.shape[2]
    ]), d = ee(u, [
      u.shape[0],
      1,
      u.shape[1],
      u.shape[2]
    ]), m = Sd(d, h, [
      1,
      t
    ], r, "NHWC", [
      1,
      a
    ], s);
    return c ? ee(m, [
      m.shape[2],
      m.shape[3]
    ]) : ee(m, [
      m.shape[0],
      m.shape[2],
      m.shape[3]
    ]);
  }
  const _9 = te({
    conv1d_: mRe
  });
  function vRe(n, e, t, r, i, a = "NHWC", s) {
    B(n.length === e.rank, () => `Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);
    let o = n, l = e, u = false;
    e.rank === 3 && (u = true, l = ee(e, [
      1,
      e.shape[0],
      e.shape[1],
      e.shape[2]
    ]), o = [
      1,
      n[0],
      n[1],
      n[2]
    ]), B(o.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`), B(l.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`), B(t.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);
    const c = a === "NHWC" ? o[3] : o[1], h = a === "NHWC" ? l.shape[3] : l.shape[1];
    B(c === t.shape[2], () => `Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`), B(h === t.shape[3], () => `Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`), la("conv2dDerInput", i, s);
    const d = {
      dy: l,
      filter: t
    }, f = {
      strides: r,
      pad: i,
      dataFormat: a,
      dimRoundingMode: s,
      inputShape: o
    }, p = Q.runKernel(ef, d, f);
    return u ? ee(p, [
      p.shape[1],
      p.shape[2],
      p.shape[3]
    ]) : p;
  }
  const rP = te({
    conv2DBackpropInput_: vRe
  });
  function yRe(n, e, t, r, i, a) {
    const s = U(n, "x", "conv2dTranspose"), o = U(e, "filter", "conv2dTranspose");
    return rP(t, s, o, r, i, "NHWC", a);
  }
  const S9 = te({
    conv2dTranspose_: yRe
  });
  function xRe(n, e, t, r, i = "NDHWC", a = [
    1,
    1,
    1
  ]) {
    const s = U(n, "x", "conv3d"), o = U(e, "filter", "conv3d");
    let l = s, u = false;
    s.rank === 4 && (u = true, l = ee(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2],
      s.shape[3]
    ])), B(l.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${l.rank}.`), B(o.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`), B(l.shape[4] === o.shape[3], () => `Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`), B(Pr(t, a), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`), B(i === "NDHWC", () => `Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`), B(_d(a), () => "Error in conv3D: Dilated rates should be larger than 0."), B(_d(t), () => "Error in conv3D: Strides should be larger than 0.");
    const c = {
      x: l,
      filter: o
    }, h = {
      strides: t,
      pad: r,
      dataFormat: i,
      dilations: a
    }, d = Q.runKernel(tf, c, h);
    return u ? ee(d, [
      d.shape[1],
      d.shape[2],
      d.shape[3],
      d.shape[4]
    ]) : d;
  }
  const bRe = te({
    conv3d_: xRe
  });
  function wRe(n, e, t, r, i) {
    B(n.length === e.rank, () => `Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);
    let a = n, s = e, o = false;
    e.rank === 4 && (o = true, s = ee(e, [
      1,
      e.shape[0],
      e.shape[1],
      e.shape[2],
      e.shape[3]
    ]), a = [
      1,
      n[0],
      n[1],
      n[2],
      n[3]
    ]);
    const l = a[4], u = s.shape[4];
    B(a.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`), B(s.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`), B(t.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`), B(l === t.shape[3], () => `Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`), B(u === t.shape[4], () => `Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);
    const c = {
      dy: s,
      filter: t
    }, h = {
      pad: i,
      strides: r,
      inputShape: a
    }, d = Q.runKernel(zm, c, h);
    return o ? ee(d, [
      d.shape[1],
      d.shape[2],
      d.shape[3],
      d.shape[4]
    ]) : d;
  }
  const C9 = te({
    conv3DBackpropInput_: wRe
  });
  function _Re(n, e, t, r, i) {
    const a = U(n, "x", "conv3dTranspose"), s = U(e, "filter", "conv3dTranspose");
    return C9(t, a, s, r, i);
  }
  const SRe = te({
    conv3dTranspose_: _Re
  });
  function CRe(n) {
    const t = {
      x: U(n, "x", "cos", "float32")
    };
    return Q.runKernel(nf, t);
  }
  const iP = te({
    cos_: CRe
  });
  function IRe(n) {
    const t = {
      x: U(n, "x", "cosh", "float32")
    };
    return Q.runKernel(rf, t);
  }
  const I9 = te({
    cosh_: IRe
  });
  function kRe(n, e = 0, t = false, r = false) {
    const a = {
      x: U(n, "x", "cumprod")
    }, s = {
      axis: e,
      exclusive: t,
      reverse: r
    };
    return Q.runKernel(Vm, a, s);
  }
  const w$ = te({
    cumprod_: kRe
  });
  function TRe(n, e = 0, t = false, r = false) {
    const a = {
      x: U(n, "x", "cumsum")
    }, s = {
      axis: e,
      exclusive: t,
      reverse: r
    };
    return Q.runKernel(af, a, s);
  }
  const k9 = te({
    cumsum_: TRe
  });
  function ARe(n, e, t, r = false) {
    const i = U(n, "x", "denseBincount"), a = U(e, "weights", "denseBincount");
    B(i.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${i.dtype}`), B(i.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`), B(t >= 0, () => `size must be non-negative, but got ${t}.`), B(a.size === i.size || a.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${a.shape}.`);
    const s = {
      x: i,
      weights: a
    }, o = {
      size: t,
      binaryOutput: r
    };
    return Q.runKernel(nb, s, o);
  }
  const w4 = te({
    denseBincount_: ARe
  });
  function DRe(n, e, t = "NHWC") {
    const r = U(n, "x", "depthToSpace", "float32"), i = t === "NHWC" ? r.shape[1] : r.shape[2], a = t === "NHWC" ? r.shape[2] : r.shape[3], s = t === "NHWC" ? r.shape[3] : r.shape[1];
    B(e > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${e}`), B(i * e >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${r.shape}`), B(a * e >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${r.shape}`), B(s % (e * e) === 0, () => `Dimension size must be evenly divisible by ${e * e} but is ${s} for depthToSpace with input shape ${r.shape}`);
    const o = {
      x: r
    }, l = {
      blockSize: e,
      dataFormat: t
    };
    return Q.runKernel(Gm, o, l);
  }
  const RRe = te({
    depthToSpace_: DRe
  });
  function $Re(n, e, t, r, i = "NHWC", a = [
    1,
    1
  ], s) {
    const o = U(n, "x", "depthwiseConv2d", "float32"), l = U(e, "filter", "depthwiseConv2d", "float32");
    let u = o, c = false;
    o.rank === 3 && (c = true, u = ee(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2]
    ])), B(u.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`), B(l.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);
    const h = i === "NHWC" ? u.shape[3] : u.shape[1];
    B(h === l.shape[2], () => `Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`), la("depthwiseConv2d", r, s);
    const d = {
      x: u,
      filter: l
    }, f = {
      strides: t,
      pad: r,
      dataFormat: i,
      dilations: a,
      dimRoundingMode: s
    }, p = Q.runKernel(sf, d, f);
    return c ? ee(p, [
      p.shape[1],
      p.shape[2],
      p.shape[3]
    ]) : p;
  }
  const aP = te({
    depthwiseConv2d_: $Re
  });
  function NRe(n, e, t, r, i = [
    1,
    1
  ], a = "NHWC") {
    const s = U(n, "x", "dilation2d"), o = U(e, "filter", "dilation2d");
    B(s.rank === 3 || s.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${s.rank}.`), B(o.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`), B(a === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);
    let l = s, u = false;
    s.rank === 3 && (l = ee(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2]
    ]), u = true), B(l.shape[3] === o.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);
    const c = {
      x: l,
      filter: o
    }, h = {
      strides: t,
      pad: r,
      dilations: i
    }, d = Q.runKernel(of, c, h);
    return u ? ee(d, [
      d.shape[1],
      d.shape[2],
      d.shape[3]
    ]) : d;
  }
  const ERe = te({
    dilation2d_: NRe
  });
  function lc(n, e) {
    const t = n.length, r = [];
    for (let i = 0; i < t; i++) {
      const a = t - 1 - i, s = n[a] || 1;
      (e[e.length - 1 - i] || 1) > 1 && s === 1 && r.unshift(a);
    }
    return r;
  }
  function Mr(n, e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = n[n.length - r - 1], a = e.length - r - 1, s = e[a];
      (i == null || i === 1 && s > 1) && t.unshift(a);
    }
    return t;
  }
  function ht(n, e) {
    const t = Math.max(n.length, e.length), r = new Array(t);
    for (let i = 0; i < t; i++) {
      let a = n[n.length - i - 1];
      a == null && (a = 1);
      let s = e[e.length - i - 1];
      if (s == null && (s = 1), a === 1) r[t - i - 1] = s;
      else if (s === 1) r[t - i - 1] = a;
      else if (a !== s) {
        const o = `Operands could not be broadcast together with shapes ${n} and ${e}.`;
        throw Error(o);
      } else r[t - i - 1] = a;
    }
    return r;
  }
  function MRe(n, e) {
    let t = U(n, "a", "equal", "string_or_numeric"), r = U(e, "b", "equal", "string_or_numeric");
    [t, r] = hr(t, r), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(Hm, i);
  }
  const rl = te({
    equal_: MRe
  });
  function PRe(n, e, t) {
    const r = U(e, "a", "where"), i = U(t, "b", "where"), a = U(n, "condition", "where", "bool"), s = ht(ht(a.shape, r.shape), i.shape), o = g0(a, s), l = g0(r, s), u = g0(i, s), c = {
      condition: o,
      t: l,
      e: u
    };
    return Q.runKernel(dv, c);
  }
  const Ni = te({
    where_: PRe
  });
  function LRe(n) {
    const t = {
      x: U(n, "x", "zerosLike")
    };
    return Q.runKernel(bv, t);
  }
  const un = te({
    zerosLike_: LRe
  });
  function FRe(n, e) {
    let t = U(n, "a", "div"), r = U(e, "b", "div");
    [t, r] = hr(t, r);
    const i = gt(t, r), a = un(i), s = rl(r, a);
    return Ni(s, a, i);
  }
  const ORe = te({
    divNoNan_: FRe
  });
  function BRe(n, e) {
    const t = U(n, "t1", "dot"), r = U(e, "t2", "dot");
    B((t.rank === 1 || t.rank === 2) && (r.rank === 1 || r.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);
    const i = t.rank === 1 ? t.size : t.shape[1], a = r.rank === 1 ? r.size : r.shape[0];
    if (B(i === a, () => `Error in dot: inner dimensions of inputs must match, but got ${i} and ${a}.`), t.rank === 1 && r.rank === 1) {
      const s = ee(t, [
        1,
        -1
      ]), o = ee(r, [
        -1,
        1
      ]), l = mn(s, o);
      return ee(l, []);
    } else if (t.rank === 1 && r.rank === 2) {
      const s = ee(t, [
        1,
        -1
      ]), o = ee(r, [
        r.shape[0],
        r.shape[1]
      ]), l = mn(s, o);
      return ee(l, [
        l.size
      ]);
    } else if (t.rank === 2 && r.rank === 1) {
      const s = ee(r, [
        -1,
        1
      ]), o = mn(t, s);
      return ee(o, [
        o.size
      ]);
    } else {
      const s = ee(r, [
        r.shape[0],
        r.shape[1]
      ]);
      return mn(t, s);
    }
  }
  const zRe = te({
    dot_: BRe
  });
  function VRe(n, ...e) {
    const t = e.map((i, a) => U(i, `tensors${a}`, "einsum")), r = {
      equation: n
    };
    return Q.runKernel(sI, t, r);
  }
  const by = te({
    einsum_: VRe
  });
  function WRe(n) {
    const t = {
      x: U(n, "x", "elu", "float32")
    };
    return Q.runKernel(uf, t);
  }
  const kI = te({
    elu_: WRe
  });
  function GRe(n) {
    let e = U(n, "x", "erf");
    B(e.dtype === "int32" || e.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), e.dtype === "int32" && (e = Ve(e, "float32"));
    const t = {
      x: e
    };
    return Q.runKernel(cf, t);
  }
  const T9 = te({
    erf_: GRe
  });
  function sP(n, e) {
    for (let t = 0; t < n.length; ++t) if (n[n.length - t - 1] !== e - 1 - t) return false;
    return true;
  }
  function A9(n, e, t) {
    const r = n.length + e.length, i = [];
    let a = 0, s = 0;
    for (let o = 0; o < r; o++) t.indexOf(o) === -1 ? i.push(n[a++]) : i.push(e[s++]);
    return i;
  }
  function Ln(n, e) {
    const t = [], r = n.length;
    for (let a = 0; a < r; a++) e.indexOf(a) === -1 && t.push(n[a]);
    const i = e.map((a) => n[a]);
    return [
      t,
      i
    ];
  }
  function Mn(n, e) {
    const t = e.map((r) => 1);
    return A9(n, t, e);
  }
  function Tn(n, e, t) {
    B(sP(e, t), () => `${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`);
  }
  function bn(n, e) {
    if (sP(n, e)) return null;
    const t = [];
    for (let r = 0; r < e; ++r) n.indexOf(r) === -1 && t.push(r);
    return n.forEach((r) => t.push(r)), t;
  }
  function As(n) {
    return n.map((e, t) => [
      t,
      e
    ]).sort((e, t) => e[1] - t[1]).map((e) => e[0]);
  }
  function gn(n, e) {
    const t = [];
    for (let r = e - n; r < e; ++r) t.push(r);
    return t;
  }
  function URe(n, e = null, t = false) {
    const i = {
      x: U(n, "x", "max")
    }, a = {
      reductionIndices: e,
      keepDims: t
    };
    return Q.runKernel(If, i, a);
  }
  const Js = te({
    max_: URe
  });
  function HRe(n, e = null, t = false) {
    const i = {
      x: U(n, "x", "min")
    }, a = {
      axis: e,
      keepDims: t
    };
    return Q.runKernel(Df, i, a);
  }
  const RS = te({
    min_: HRe
  });
  function XRe(n, e) {
    let t = U(n, "base", "pow"), r = U(e, "exp", "pow");
    [t, r] = hr(t, r);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(Lf, i);
  }
  const Cd = te({
    pow_: XRe
  });
  function yn(n, e) {
    if ((Ss(n) && e !== "string" || Array.isArray(n)) && e !== "complex64") throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if (e === "string" && Ss(n) && !(n instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return wI(n, [], [], e);
  }
  function YRe(n) {
    const t = {
      x: U(n, "x", "sqrt", "float32")
    };
    return Q.runKernel(Jf, t);
  }
  const mi = te({
    sqrt_: YRe
  });
  function qRe(n) {
    const e = U(n, "x", "square"), t = {};
    return Q.runKernel("Square", {
      x: e
    }, t);
  }
  const Xn = te({
    square_: qRe
  });
  function jRe(n, e = null, t = false) {
    let r = U(n, "x", "sum");
    r.dtype === "bool" && (r = Ve(r, "int32"));
    const i = {
      x: r
    }, a = {
      axis: e,
      keepDims: t
    };
    return Q.runKernel(ep, i, a);
  }
  const ct = te({
    sum_: jRe
  });
  function KRe(n, e = "euclidean", t = null, r = false) {
    n = U(n, "x", "norm");
    const i = D9(n, e, t);
    let a = i.shape;
    if (r) {
      const s = yt(t, n.shape);
      a = Mn(i.shape, s);
    }
    return ee(i, a);
  }
  function D9(n, e, t = null) {
    if (n.rank === 0) return ki(n);
    if (n.rank !== 1 && t === null) return D9(ee(n, [
      -1
    ]), e, t);
    if (n.rank === 1 || typeof t == "number" || Array.isArray(t) && t.length === 1) {
      if (e === 1) return ct(ki(n), t);
      if (e === 1 / 0) return Js(ki(n), t);
      if (e === -1 / 0) return RS(ki(n), t);
      if (e === "euclidean" || e === 2) return mi(ct(Cd(ki(n), yn(2, "int32")), t));
      throw new Error(`Error in norm: invalid ord value: ${e}`);
    }
    if (Array.isArray(t) && t.length === 2) {
      if (e === 1) return Js(ct(ki(n), t[0]), t[1] - 1);
      if (e === 1 / 0) return Js(ct(ki(n), t[1]), t[0]);
      if (e === -1 / 0) return RS(ct(ki(n), t[1]), t[0]);
      if (e === "fro" || e === "euclidean") return mi(ct(Xn(n), t));
      throw new Error(`Error in norm: invalid ord value: ${e}`);
    }
    throw new Error(`Error in norm: invalid axis: ${t}`);
  }
  const TI = te({
    norm_: KRe
  });
  function ZRe(n, e = null, t = false) {
    return TI(n, "euclidean", e, t);
  }
  const QRe = te({
    euclideanNorm_: ZRe
  });
  function JRe(n) {
    const t = {
      x: U(n, "x", "exp")
    };
    return Q.runKernel(hf, t);
  }
  const il = te({
    exp_: JRe
  });
  function e$e(n, e = 0) {
    const t = U(n, "x", "expandDims", "string_or_numeric");
    B(e <= t.rank, () => "Axis must be <= rank of the tensor");
    const r = {
      input: t
    }, i = {
      dim: e
    };
    return Q.runKernel(Xm, r, i);
  }
  const Xi = te({
    expandDims_: e$e
  });
  function t$e(n) {
    const t = {
      x: U(n, "x", "expm1")
    };
    return Q.runKernel(df, t);
  }
  const n$e = te({
    expm1_: t$e
  });
  function r$e(n, e) {
    const t = U(n, "x", "tile", "string_or_numeric");
    B(t.rank === e.length, () => `Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);
    const r = {
      x: t
    }, i = {
      reps: e
    };
    return Q.runKernel(wc, r, i);
  }
  const Ys = te({
    tile_: r$e
  });
  function i$e(n, e, t, r = "float32") {
    e == null && (e = n);
    const i = Nt([
      n,
      e
    ], r), a = n <= e ? n : e;
    for (let o = 0; o < a; ++o) i.set(1, o, o);
    const s = ee(i.toTensor(), [
      n,
      e
    ]);
    if (t == null) return s;
    if (t.length === 1) return Ys(Xi(s, 0), [
      t[0],
      1,
      1
    ]);
    if (t.length === 2) return Ys(Xi(Xi(s, 0), 0), [
      t[0],
      t[1],
      1,
      1
    ]);
    if (t.length === 3) return Ys(Xi(Xi(Xi(s, 0), 0), 0), [
      t[0],
      t[1],
      t[2],
      1,
      1
    ]);
    throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`);
  }
  const R9 = te({
    eye_: i$e
  });
  function a$e(n) {
    const t = {
      x: U(n, "x", "floor", "float32")
    };
    return Q.runKernel(ff, t);
  }
  const AI = te({
    floor_: a$e
  });
  function s$e(n, e, t = 0, r = 0) {
    const i = U(n, "x", "gather"), a = U(e, "indices", "gather", "int32"), s = {
      x: i,
      indices: a
    }, o = {
      axis: t,
      batchDims: r
    };
    return Q.runKernel(qm, s, o);
  }
  const oP = te({
    gather_: s$e
  });
  function o$e(n, e) {
    let t = U(n, "a", "greater", "string_or_numeric"), r = U(e, "b", "greater", "string_or_numeric");
    [t, r] = hr(t, r), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(jm, i);
  }
  const ja = te({
    greater_: o$e
  });
  function l$e(n, e) {
    let t = U(n, "a", "greaterEqual", "string_or_numeric"), r = U(e, "b", "greaterEqual", "string_or_numeric");
    [t, r] = hr(t, r), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(mf, i);
  }
  const op = te({
    greaterEqual_: l$e
  });
  function u$e(n) {
    const t = {
      input: U(n, "input", "imag")
    };
    return Q.runKernel(uI, t);
  }
  const lP = te({
    imag_: u$e
  });
  function c$e(n) {
    const t = {
      x: U(n, "x", "isFinite")
    };
    return Q.runKernel(yf, t);
  }
  const h$e = te({
    isFinite_: c$e
  });
  function d$e(n) {
    const t = {
      x: U(n, "x", "isInf")
    };
    return Q.runKernel(xf, t);
  }
  const f$e = te({
    isInf_: d$e
  });
  function p$e(n) {
    const t = {
      x: U(n, "x", "isNaN")
    };
    return Q.runKernel(bf, t);
  }
  const g$e = te({
    isNaN_: p$e
  });
  function m$e(n, e = 0.2) {
    const r = {
      x: U(n, "x", "leakyRelu")
    }, i = {
      alpha: e
    };
    return Q.runKernel(wf, r, i);
  }
  const uP = te({
    leakyRelu_: m$e
  });
  function v$e(n, e) {
    let t = U(n, "a", "less", "string_or_numeric"), r = U(e, "b", "less", "string_or_numeric");
    [t, r] = hr(t, r), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(Km, i);
  }
  const $S = te({
    less_: v$e
  });
  function y$e(n, e) {
    let t = U(n, "a", "lessEqual", "string_or_numeric"), r = U(e, "b", "lessEqual", "string_or_numeric");
    [t, r] = hr(t, r), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(Zm, i);
  }
  const Iv = te({
    lessEqual_: y$e
  });
  function x$e(n, e = 5, t = 1, r = 1, i = 0.5) {
    const a = U(n, "x", "localResponseNormalization");
    B(a.rank === 4 || a.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`), B(Ug(e), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);
    let s = a, o = false;
    a.rank === 3 && (o = true, s = ee(a, [
      1,
      a.shape[0],
      a.shape[1],
      a.shape[2]
    ]));
    const l = {
      x: s
    }, u = {
      depthRadius: e,
      bias: t,
      alpha: r,
      beta: i
    }, c = Q.runKernel(Cf, l, u);
    return o ? ee(c, [
      c.shape[1],
      c.shape[2],
      c.shape[3]
    ]) : c;
  }
  const b$e = te({
    localResponseNormalization_: x$e
  });
  function w$e(n) {
    const t = {
      x: U(n, "x", "log", "float32")
    };
    return Q.runKernel(_f, t);
  }
  const al = te({
    log_: w$e
  });
  function _$e(n) {
    const t = {
      x: U(n, "x", "log1p")
    };
    return Q.runKernel(Sf, t);
  }
  const $9 = te({
    log1p_: _$e
  });
  function S$e(n, e) {
    B(l$(n), () => "The f passed in variableGrads(f) must be a function"), B(e == null || Array.isArray(e) && e.every((u) => u instanceof DS), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
    const t = e != null;
    if (!t) {
      e = [];
      for (const u in Q.registeredVariables) e.push(Q.registeredVariables[u]);
    }
    const r = t ? e.filter((u) => !u.trainable) : null, i = e.length;
    e = e.filter((u) => u.trainable), B(e.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);
    const a = true, { value: s, grads: o } = Q.gradients(n, e, null, a);
    B(o.some((u) => u != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), B(s.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);
    const l = {};
    return e.forEach((u, c) => {
      o[c] != null && (l[u.name] = o[c]);
    }), r == null ? void 0 : r.forEach((u) => l[u.name] = null), {
      value: s,
      grads: l
    };
  }
  function Kg(n) {
    return Q.customGrad(n);
  }
  function C$e(n) {
    const t = {
      x: U(n, "x", "neg")
    };
    return Q.runKernel(rv, t);
  }
  const cr = te({
    neg_: C$e
  });
  function I$e(n) {
    const t = {
      x: U(n, "x", "softplus")
    };
    return Q.runKernel(Qf, t);
  }
  const yb = te({
    softplus_: I$e
  });
  function k$e(n) {
    const e = U(n, "x", "logSigmoid");
    return Kg((r) => ({
      value: cr(yb(cr(r))),
      gradFunc: (s) => Z(s, Cv(cr(r)))
    }))(e);
  }
  const T$e = te({
    logSigmoid_: k$e
  });
  function A$e(n, e) {
    let t = U(n, "a", "sub"), r = U(e, "b", "sub");
    [t, r] = hr(t, r);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(rp, i);
  }
  const wt = te({
    sub_: A$e
  });
  function D$e(n, e = -1) {
    const t = U(n, "logits", "logSoftmax");
    if (e === -1 && (e = t.rank - 1), e !== t.rank - 1) throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);
    return Kg((i, a) => {
      const o = Js(i, e, true), l = wt(i, o), u = wt(Ve(l, "float32"), al(ct(il(l), e, true)));
      return a([
        u
      ]), {
        value: u,
        gradFunc: (h, d) => {
          const [f] = d, p = true, g = il(f);
          return wt(h, Z(ct(h, e, p), g));
        }
      };
    })(t);
  }
  const N9 = te({
    logSoftmax_: D$e
  });
  function R$e(n, e = null, t = false) {
    const r = U(n, "x", "logSumExp"), i = yt(e, r.shape), a = Js(r, i, true), s = wt(r, a), o = il(s), l = ct(o, i), u = al(l), c = Ce(ee(a, u.shape), u);
    if (t) {
      const h = Mn(c.shape, i);
      return ee(c, h);
    }
    return c;
  }
  const E9 = te({
    logSumExp_: R$e
  });
  function $$e(n, e) {
    const t = U(n, "a", "logicalAnd", "bool"), r = U(e, "b", "logicalAnd", "bool");
    ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(Qm, i);
  }
  const eu = te({
    logicalAnd_: $$e
  });
  function N$e(n) {
    const t = {
      x: U(n, "x", "logicalNot", "bool")
    };
    return Q.runKernel(Jm, t);
  }
  const cP = te({
    logicalNot_: N$e
  });
  function E$e(n, e) {
    const t = U(n, "a", "logicalOr", "bool"), r = U(e, "b", "logicalOr", "bool");
    ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(ev, i);
  }
  const M9 = te({
    logicalOr_: E$e
  });
  function M$e(n, e) {
    const t = U(n, "a", "logicalXor", "bool"), r = U(e, "b", "logicalXor", "bool");
    return ht(t.shape, r.shape), eu(M9(n, e), cP(eu(n, e)));
  }
  const P$e = te({
    logicalXor_: M$e
  });
  function L$e(n, e, t, r, i) {
    const a = U(n, "x", "maxPool"), s = 1;
    let o = a, l = false;
    a.rank === 3 && (l = true, o = ee(a, [
      1,
      a.shape[0],
      a.shape[1],
      a.shape[2]
    ])), B(o.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${o.rank}.`), B(Pr(t, s), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`), la("maxPool", r, i);
    const u = {
      x: o
    }, c = {
      filterSize: e,
      strides: t,
      pad: r,
      dimRoundingMode: i
    }, h = Q.runKernel(Tf, u, c);
    return l ? ee(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3]
    ]) : h;
  }
  const hP = te({
    maxPool_: L$e
  });
  function F$e(n, e = [
    1,
    1,
    1
  ], t, r, i, a = "NDHWC") {
    const s = U(n, "x", "maxPool3d");
    let o = s, l = false;
    s.rank === 4 && (l = true, o = ee(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2],
      s.shape[3]
    ])), B(o.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`), B(a === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`), la("maxPool3d", r, i);
    const u = {
      x: o
    }, c = {
      filterSize: e,
      strides: t,
      pad: r,
      dimRoundingMode: i,
      dataFormat: a
    }, h = Q.runKernel(nv, u, c);
    return l ? ee(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3],
      h.shape[4]
    ]) : h;
  }
  const O$e = te({
    maxPool3d_: F$e
  });
  function B$e(n, e) {
    let t = U(n, "a", "maximum"), r = U(e, "b", "maximum");
    [t, r] = hr(t, r), t.dtype === "bool" && (t = Ve(t, "int32"), r = Ve(r, "int32")), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(kf, i);
  }
  const Cc = te({
    maximum_: B$e
  });
  function z$e(n, e = null, t = false) {
    const i = {
      x: U(n, "x", "mean")
    }, a = {
      axis: e,
      keepDims: t
    };
    return Q.runKernel(Af, i, a);
  }
  const vr = te({
    mean_: z$e
  });
  function Cr(n, e = "float32") {
    if (su(n), e === "complex64") {
      const r = Cr(n, "float32"), i = Cr(n, "float32");
      return jg(r, i);
    }
    const t = si(X(n), e);
    return Q.makeTensor(t, n, e);
  }
  function Ic(n, e = "float32") {
    if (su(n), e === "complex64") {
      const r = Ic(n, "float32"), i = Cr(n, "float32");
      return jg(r, i);
    }
    const t = HM(X(n), e);
    return Q.makeTensor(t, n, e);
  }
  function V$e(n, e) {
    let t = U(n, "a", "minimum"), r = U(e, "b", "minimum");
    [t, r] = hr(t, r), t.dtype === "bool" && (t = Ve(t, "int32"), r = Ve(r, "int32")), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(Rf, i);
  }
  const sx = te({
    minimum_: V$e
  });
  function W$e(n, e, t) {
    B(t === "reflect" || t === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);
    const r = U(n, "x", "mirrorPad");
    if (r.rank === 0) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    B(e.length === r.rank, () => `Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);
    const i = t === "reflect" ? 1 : 0;
    for (let o = 0; o < r.rank; o++) B(e[o].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), B(e[o][0] >= 0 && e[o][0] <= r.shape[o] - i && e[o][1] >= 0 && e[o][1] <= r.shape[o] - i, () => `Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o] - i} or less than 0 for input of shape ${r.shape}`);
    const a = {
      paddings: e,
      mode: t
    }, s = {
      x: r
    };
    return Q.runKernel($f, s, a);
  }
  const G$e = te({
    mirrorPad_: W$e
  });
  function U$e(n, e) {
    let t = U(n, "a", "mod"), r = U(e, "b", "mod");
    [t, r] = hr(t, r);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(Nf, i);
  }
  const H$e = te({
    mod_: U$e
  });
  function X$e(n, e = null, t = false) {
    n = U(n, "x", "moments");
    const r = yt(e, n.shape), i = vr(n, r, t);
    let a = i.shape;
    t || (a = Mn(i.shape, r));
    const s = Xn(wt(Ve(n, "float32"), ee(i, a))), o = vr(s, r, t);
    return {
      mean: i,
      variance: o
    };
  }
  const dP = te({
    moments_: X$e
  });
  function Y$e(n, e) {
    let t = U(n, "a", "notEqual", "string_or_numeric"), r = U(e, "b", "notEqual", "string_or_numeric");
    [t, r] = hr(t, r), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    };
    return Q.runKernel(iv, i);
  }
  const NS = te({
    notEqual_: Y$e
  });
  function q$e(n, e, t = 1, r = 0, i = "int32") {
    if (e < 2) throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);
    const s = {
      indices: U(n, "indices", "oneHot", "int32")
    }, o = {
      dtype: i,
      depth: e,
      onValue: t,
      offValue: r
    };
    return Q.runKernel(Mf, s, o);
  }
  const P9 = te({
    oneHot_: q$e
  });
  function j$e(n) {
    const t = {
      x: U(n, "x", "onesLike")
    };
    return Q.runKernel(ov, t);
  }
  const Cs = te({
    onesLike_: j$e
  });
  function K$e(n, e, t = 0) {
    const r = U(n, "x", "pad");
    if (r.rank === 0) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    const i = {
      paddings: e,
      constantValue: t
    }, a = {
      x: r
    };
    return Q.runKernel(Pf, a, i);
  }
  const fP = te({
    pad_: K$e
  });
  function Z$e(n, e, t) {
    const r = U(n, "x", "spaceToBatchND");
    B(r.rank >= 1 + e.length, () => `input rank ${r.rank} should be > than [blockShape] ${e.length}`), B(t.length === e.length, () => `paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`), B(r.shape.reduce((s, o, l) => l > 0 && l <= e.length ? s && (o + t[l - 1][0] + t[l - 1][1]) % e[l - 1] === 0 : s, true), () => `input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);
    const i = {
      x: r
    }, a = {
      blockShape: e,
      paddings: t
    };
    return Q.runKernel(pv, i, a);
  }
  const pP = te({
    spaceToBatchND_: Z$e
  });
  function Q$e(n, e, t, r, i, a, s) {
    i == null && (i = [
      1,
      1
    ]), a == null && (a = 1), r === 0 && (r = "valid");
    const o = U(n, "x", "maxPool");
    let l = o, u = false;
    o.rank === 3 && (u = true, l = ee(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2]
    ])), B(Pr(a, i), () => `Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${i}'`);
    const c = dr(l.shape, e, a, i, r), h = [
      c.dilationHeight,
      c.dilationWidth
    ];
    let d;
    r === "same" ? d = eNe([
      c.filterHeight,
      c.filterWidth
    ], h) : d = [
      [
        0,
        0
      ],
      [
        0,
        0
      ]
    ];
    const f = h[0] === 1 && h[1] === 1, [p, g] = J$e([
      c.inHeight,
      c.inWidth
    ], h, d), m = f ? r : "valid", v = f ? l : pP(l, h, p), x = (t === "avg" ? () => tP(v, e, a, m, s) : () => hP(v, e, a, m, s))(), b = f ? x : nP(x, h, g);
    return u ? ee(b, [
      b.shape[1],
      b.shape[2],
      b.shape[3]
    ]) : b;
  }
  function J$e(n, e, t) {
    const r = t.map((c) => c[0]), i = t.map((c) => c[1]), a = n.concat(r, i), s = e.map((c, h) => (c - a[h] % c) % c), o = i.map((c, h) => c + s[h]), l = e.map((c, h) => [
      r[h],
      o[h]
    ]), u = e.map((c, h) => [
      0,
      s[h]
    ]);
    return [
      l,
      u
    ];
  }
  function eNe(n, e) {
    const r = n.map((s, o) => s + (s - 1) * (e[o] - 1)).map((s) => s - 1), i = r.map((s) => Math.floor(s / 2)), a = r.map((s, o) => s - i[o]);
    return r.map((s, o) => [
      i[o],
      a[o]
    ]);
  }
  const tNe = te({
    pool_: Q$e
  });
  function nNe(n, e) {
    const t = U(n, "x", "prelu"), r = U(e, "alpha", "prelu"), i = {
      x: t,
      alpha: r
    };
    return Q.runKernel(Ff, i);
  }
  const gP = te({
    prelu_: nNe
  });
  function rNe(n, e = null, t = false) {
    let r = U(n, "x", "prod");
    r.dtype === "bool" && (r = Ve(r, "int32"));
    const i = {
      x: r
    }, a = {
      axis: e,
      keepDims: t
    };
    return Q.runKernel(Of, i, a);
  }
  const iNe = te({
    prod_: rNe
  });
  var v_ = {
    exports: {}
  }, aNe = v_.exports, _4;
  function sNe() {
    return _4 || (_4 = 1, function(n) {
      (function(e, t, r) {
        function i(l) {
          var u = this, c = o();
          u.next = function() {
            var h = 2091639 * u.s0 + u.c * 23283064365386963e-26;
            return u.s0 = u.s1, u.s1 = u.s2, u.s2 = h - (u.c = h | 0);
          }, u.c = 1, u.s0 = c(" "), u.s1 = c(" "), u.s2 = c(" "), u.s0 -= c(l), u.s0 < 0 && (u.s0 += 1), u.s1 -= c(l), u.s1 < 0 && (u.s1 += 1), u.s2 -= c(l), u.s2 < 0 && (u.s2 += 1), c = null;
        }
        function a(l, u) {
          return u.c = l.c, u.s0 = l.s0, u.s1 = l.s1, u.s2 = l.s2, u;
        }
        function s(l, u) {
          var c = new i(l), h = u && u.state, d = c.next;
          return d.int32 = function() {
            return c.next() * 4294967296 | 0;
          }, d.double = function() {
            return d() + (d() * 2097152 | 0) * 11102230246251565e-32;
          }, d.quick = d, h && (typeof h == "object" && a(h, c), d.state = function() {
            return a(c, {});
          }), d;
        }
        function o() {
          var l = 4022871197, u = function(c) {
            c = String(c);
            for (var h = 0; h < c.length; h++) {
              l += c.charCodeAt(h);
              var d = 0.02519603282416938 * l;
              l = d >>> 0, d -= l, d *= l, l = d >>> 0, d -= l, l += d * 4294967296;
            }
            return (l >>> 0) * 23283064365386963e-26;
          };
          return u;
        }
        t && t.exports ? t.exports = s : this.alea = s;
      })(aNe, n);
    }(v_)), v_.exports;
  }
  var y_ = {
    exports: {}
  }, oNe = y_.exports, S4;
  function lNe() {
    return S4 || (S4 = 1, function(n) {
      (function(e, t, r) {
        function i(o) {
          var l = this, u = "";
          l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.next = function() {
            var h = l.x ^ l.x << 11;
            return l.x = l.y, l.y = l.z, l.z = l.w, l.w ^= l.w >>> 19 ^ h ^ h >>> 8;
          }, o === (o | 0) ? l.x = o : u += o;
          for (var c = 0; c < u.length + 64; c++) l.x ^= u.charCodeAt(c) | 0, l.next();
        }
        function a(o, l) {
          return l.x = o.x, l.y = o.y, l.z = o.z, l.w = o.w, l;
        }
        function s(o, l) {
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var d = u.next() >>> 11, f = (u.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (typeof c == "object" && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        t && t.exports ? t.exports = s : this.xor128 = s;
      })(oNe, n);
    }(y_)), y_.exports;
  }
  var x_ = {
    exports: {}
  }, uNe = x_.exports, C4;
  function cNe() {
    return C4 || (C4 = 1, function(n) {
      (function(e, t, r) {
        function i(o) {
          var l = this, u = "";
          l.next = function() {
            var h = l.x ^ l.x >>> 2;
            return l.x = l.y, l.y = l.z, l.z = l.w, l.w = l.v, (l.d = l.d + 362437 | 0) + (l.v = l.v ^ l.v << 4 ^ (h ^ h << 1)) | 0;
          }, l.x = 0, l.y = 0, l.z = 0, l.w = 0, l.v = 0, o === (o | 0) ? l.x = o : u += o;
          for (var c = 0; c < u.length + 64; c++) l.x ^= u.charCodeAt(c) | 0, c == u.length && (l.d = l.x << 10 ^ l.x >>> 4), l.next();
        }
        function a(o, l) {
          return l.x = o.x, l.y = o.y, l.z = o.z, l.w = o.w, l.v = o.v, l.d = o.d, l;
        }
        function s(o, l) {
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var d = u.next() >>> 11, f = (u.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (typeof c == "object" && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        t && t.exports ? t.exports = s : this.xorwow = s;
      })(uNe, n);
    }(x_)), x_.exports;
  }
  var b_ = {
    exports: {}
  }, hNe = b_.exports, I4;
  function dNe() {
    return I4 || (I4 = 1, function(n) {
      (function(e, t, r) {
        function i(o) {
          var l = this;
          l.next = function() {
            var c = l.x, h = l.i, d, f;
            return d = c[h], d ^= d >>> 7, f = d ^ d << 24, d = c[h + 1 & 7], f ^= d ^ d >>> 10, d = c[h + 3 & 7], f ^= d ^ d >>> 3, d = c[h + 4 & 7], f ^= d ^ d << 7, d = c[h + 7 & 7], d = d ^ d << 13, f ^= d ^ d << 9, c[h] = f, l.i = h + 1 & 7, f;
          };
          function u(c, h) {
            var d, f = [];
            if (h === (h | 0)) f[0] = h;
            else for (h = "" + h, d = 0; d < h.length; ++d) f[d & 7] = f[d & 7] << 15 ^ h.charCodeAt(d) + f[d + 1 & 7] << 13;
            for (; f.length < 8; ) f.push(0);
            for (d = 0; d < 8 && f[d] === 0; ++d) ;
            for (d == 8 ? f[7] = -1 : f[d], c.x = f, c.i = 0, d = 256; d > 0; --d) c.next();
          }
          u(l, o);
        }
        function a(o, l) {
          return l.x = o.x.slice(), l.i = o.i, l;
        }
        function s(o, l) {
          o == null && (o = +/* @__PURE__ */ new Date());
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var d = u.next() >>> 11, f = (u.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (c.x && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        t && t.exports ? t.exports = s : this.xorshift7 = s;
      })(hNe, n);
    }(b_)), b_.exports;
  }
  var w_ = {
    exports: {}
  }, fNe = w_.exports, k4;
  function pNe() {
    return k4 || (k4 = 1, function(n) {
      (function(e, t, r) {
        function i(o) {
          var l = this;
          l.next = function() {
            var c = l.w, h = l.X, d = l.i, f, p;
            return l.w = c = c + 1640531527 | 0, p = h[d + 34 & 127], f = h[d = d + 1 & 127], p ^= p << 13, f ^= f << 17, p ^= p >>> 15, f ^= f >>> 12, p = h[d] = p ^ f, l.i = d, p + (c ^ c >>> 16) | 0;
          };
          function u(c, h) {
            var d, f, p, g, m, v = [], y = 128;
            for (h === (h | 0) ? (f = h, h = null) : (h = h + "\0", f = 0, y = Math.max(y, h.length)), p = 0, g = -32; g < y; ++g) h && (f ^= h.charCodeAt((g + 32) % h.length)), g === 0 && (m = f), f ^= f << 10, f ^= f >>> 15, f ^= f << 4, f ^= f >>> 13, g >= 0 && (m = m + 1640531527 | 0, d = v[g & 127] ^= f + m, p = d == 0 ? p + 1 : 0);
            for (p >= 128 && (v[(h && h.length || 0) & 127] = -1), p = 127, g = 4 * 128; g > 0; --g) f = v[p + 34 & 127], d = v[p = p + 1 & 127], f ^= f << 13, d ^= d << 17, f ^= f >>> 15, d ^= d >>> 12, v[p] = f ^ d;
            c.w = m, c.X = v, c.i = p;
          }
          u(l, o);
        }
        function a(o, l) {
          return l.i = o.i, l.w = o.w, l.X = o.X.slice(), l;
        }
        function s(o, l) {
          o == null && (o = +/* @__PURE__ */ new Date());
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var d = u.next() >>> 11, f = (u.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (c.X && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        t && t.exports ? t.exports = s : this.xor4096 = s;
      })(fNe, n);
    }(w_)), w_.exports;
  }
  var __ = {
    exports: {}
  }, gNe = __.exports, T4;
  function mNe() {
    return T4 || (T4 = 1, function(n) {
      (function(e, t, r) {
        function i(o) {
          var l = this, u = "";
          l.next = function() {
            var h = l.b, d = l.c, f = l.d, p = l.a;
            return h = h << 25 ^ h >>> 7 ^ d, d = d - f | 0, f = f << 24 ^ f >>> 8 ^ p, p = p - h | 0, l.b = h = h << 20 ^ h >>> 12 ^ d, l.c = d = d - f | 0, l.d = f << 16 ^ d >>> 16 ^ p, l.a = p - h | 0;
          }, l.a = 0, l.b = 0, l.c = -1640531527, l.d = 1367130551, o === Math.floor(o) ? (l.a = o / 4294967296 | 0, l.b = o | 0) : u += o;
          for (var c = 0; c < u.length + 20; c++) l.b ^= u.charCodeAt(c) | 0, l.next();
        }
        function a(o, l) {
          return l.a = o.a, l.b = o.b, l.c = o.c, l.d = o.d, l;
        }
        function s(o, l) {
          var u = new i(o), c = l && l.state, h = function() {
            return (u.next() >>> 0) / 4294967296;
          };
          return h.double = function() {
            do
              var d = u.next() >>> 11, f = (u.next() >>> 0) / 4294967296, p = (d + f) / (1 << 21);
            while (p === 0);
            return p;
          }, h.int32 = u.next, h.quick = h, c && (typeof c == "object" && a(c, u), h.state = function() {
            return a(u, {});
          }), h;
        }
        t && t.exports ? t.exports = s : this.tychei = s;
      })(gNe, n);
    }(__)), __.exports;
  }
  var S_ = {
    exports: {}
  };
  const vNe = {}, yNe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: vNe
  }, Symbol.toStringTag, {
    value: "Module"
  })), $u = fAe(yNe);
  var xNe = S_.exports, A4;
  function bNe() {
    return A4 || (A4 = 1, function(n) {
      (function(e, t, r) {
        var i = 256, a = 6, s = 52, o = "random", l = r.pow(i, a), u = r.pow(2, s), c = u * 2, h = i - 1, d;
        function f(b, w, _) {
          var S = [];
          w = w == true ? {
            entropy: true
          } : w || {};
          var I = v(m(w.entropy ? [
            b,
            x(t)
          ] : b ?? y(), 3), S), C = new p(S), T = function() {
            for (var k = C.g(a), D = l, R = 0; k < u; ) k = (k + R) * i, D *= i, R = C.g(1);
            for (; k >= c; ) k /= 2, D /= 2, R >>>= 1;
            return (k + R) / D;
          };
          return T.int32 = function() {
            return C.g(4) | 0;
          }, T.quick = function() {
            return C.g(4) / 4294967296;
          }, T.double = T, v(x(C.S), t), (w.pass || _ || function(k, D, R, N) {
            return N && (N.S && g(N, C), k.state = function() {
              return g(C, {});
            }), R ? (r[o] = k, D) : k;
          })(T, I, "global" in w ? w.global : this == r, w.state);
        }
        function p(b) {
          var w, _ = b.length, S = this, I = 0, C = S.i = S.j = 0, T = S.S = [];
          for (_ || (b = [
            _++
          ]); I < i; ) T[I] = I++;
          for (I = 0; I < i; I++) T[I] = T[C = h & C + b[I % _] + (w = T[I])], T[C] = w;
          (S.g = function(k) {
            for (var D, R = 0, N = S.i, E = S.j, A = S.S; k--; ) D = A[N = h & N + 1], R = R * i + A[h & (A[N] = A[E = h & E + D]) + (A[E] = D)];
            return S.i = N, S.j = E, R;
          })(i);
        }
        function g(b, w) {
          return w.i = b.i, w.j = b.j, w.S = b.S.slice(), w;
        }
        function m(b, w) {
          var _ = [], S = typeof b, I;
          if (w && S == "object") for (I in b) try {
            _.push(m(b[I], w - 1));
          } catch {
          }
          return _.length ? _ : S == "string" ? b : b + "\0";
        }
        function v(b, w) {
          for (var _ = b + "", S, I = 0; I < _.length; ) w[h & I] = h & (S ^= w[h & I] * 19) + _.charCodeAt(I++);
          return x(w);
        }
        function y() {
          try {
            var b;
            return d && (b = d.randomBytes) ? b = b(i) : (b = new Uint8Array(i), (e.crypto || e.msCrypto).getRandomValues(b)), x(b);
          } catch {
            var w = e.navigator, _ = w && w.plugins;
            return [
              +/* @__PURE__ */ new Date(),
              e,
              _,
              e.screen,
              x(t)
            ];
          }
        }
        function x(b) {
          return String.fromCharCode.apply(0, b);
        }
        if (v(r.random(), t), n.exports) {
          n.exports = f;
          try {
            d = $u;
          } catch {
          }
        } else r["seed" + o] = f;
      })(typeof self < "u" ? self : xNe, [], Math);
    }(S_)), S_.exports;
  }
  var sA, D4;
  function wNe() {
    if (D4) return sA;
    D4 = 1;
    var n = sNe(), e = lNe(), t = cNe(), r = dNe(), i = pNe(), a = mNe(), s = bNe();
    return s.alea = n, s.xor128 = e, s.xorwow = t, s.xorshift7 = r, s.xor4096 = i, s.tychei = a, sA = s, sA;
  }
  var mP = wNe();
  class L9 {
    constructor(e, t, r, i, a) {
      this.mean = e, this.stdDev = t, this.dtype = r, this.nextVal = NaN, this.truncated = i, this.truncated && (this.upper = this.mean + this.stdDev * 2, this.lower = this.mean - this.stdDev * 2);
      const s = a || Math.random();
      this.random = mP.alea(s.toString());
    }
    nextValue() {
      if (!isNaN(this.nextVal)) {
        const i = this.nextVal;
        return this.nextVal = NaN, i;
      }
      let e, t, r = false;
      for (; !r; ) {
        let i, a, s;
        do
          i = 2 * this.random() - 1, a = 2 * this.random() - 1, s = i * i + a * a;
        while (s >= 1 || s === 0);
        const o = Math.sqrt(-2 * Math.log(s) / s);
        e = this.mean + this.stdDev * i * o, t = this.mean + this.stdDev * a * o, (!this.truncated || this.isValidTruncated(e)) && (r = true);
      }
      return (!this.truncated || this.isValidTruncated(t)) && (this.nextVal = this.convertValue(t)), this.convertValue(e);
    }
    convertValue(e) {
      return this.dtype == null || this.dtype === "float32" ? e : Math.round(e);
    }
    isValidTruncated(e) {
      return e <= this.upper && e >= this.lower;
    }
  }
  class _Ne {
    constructor(e = 0, t = 1, r, i) {
      if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", this.min = e, this.range = t - e, this.dtype = r, i == null && (i = Math.random()), typeof i == "number" && (i = i.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);
      this.random = mP.alea(i);
    }
    convertValue(e) {
      return this.canReturnFloat() ? e : Math.round(e);
    }
    nextValue() {
      return this.convertValue(this.min + this.range * this.random());
    }
  }
  function SNe(n, e = 0, t = 1, r, i) {
    if (su(n), r != null && r === "bool") throw new Error(`Unsupported data type ${r}`);
    const a = new L9(e, t, r, false, i), s = Nt(n, r);
    for (let o = 0; o < s.values.length; o++) s.values[o] = a.nextValue();
    return s.toTensor();
  }
  const CNe = te({
    randomNormal_: SNe
  });
  function INe(n, e = 0, t = 1, r = "float32", i) {
    su(n);
    const a = Nt(n, r), s = new _Ne(e, t, null, i);
    for (let o = 0; o < a.values.length; o++) a.values[o] = s.nextValue();
    return a.toTensor();
  }
  const xb = te({
    randomUniform_: INe
  });
  function ox(n, e, t = 1, r = "float32") {
    if (t === 0) throw new Error("Cannot have a step of zero");
    const i = {
      start: n,
      stop: e,
      step: t,
      dtype: r
    };
    return Q.runKernel(cb, {}, i);
  }
  function kNe(n) {
    const t = {
      input: U(n, "input", "real")
    };
    return Q.runKernel(hI, t);
  }
  const ES = te({
    real_: kNe
  });
  function TNe(n) {
    const t = {
      x: U(n, "x", "reciprocal")
    };
    return Q.runKernel(Bf, t);
  }
  const ANe = te({
    reciprocal_: TNe
  });
  function DNe(n) {
    const t = {
      x: U(n, "x", "relu")
    };
    return Q.runKernel(zf, t);
  }
  const lp = te({
    relu_: DNe
  });
  function RNe(n) {
    const t = {
      x: U(n, "x", "relu6")
    };
    return Q.runKernel(Gf, t);
  }
  const F9 = te({
    relu6_: RNe
  });
  function $Ne(n, e) {
    const r = {
      x: U(n, "x", "reverse")
    }, i = {
      dims: e
    };
    return Q.runKernel(Uf, r, i);
  }
  const Id = te({
    reverse_: $Ne
  });
  function NNe(n) {
    const t = {
      x: U(n, "x", "round")
    };
    return Q.runKernel(Hf, t);
  }
  const O9 = te({
    round_: NNe
  });
  function ENe(n) {
    const t = {
      x: U(n, "x", "rsqrt", "float32")
    };
    return Q.runKernel(Xf, t);
  }
  const B9 = te({
    rsqrt_: ENe
  });
  function MNe(n) {
    const t = {
      x: U(n, "x", "selu")
    };
    return Q.runKernel(Yf, t);
  }
  const z9 = te({
    selu_: MNe
  });
  function PNe(n, e, t, r, i, a = [
    1,
    1
  ], s = "NHWC") {
    const o = U(n, "x", "separableConv2d"), l = U(e, "depthwiseFilter", "separableConv2d"), u = U(t, "pointwiseFilter", "separableConv2d");
    let c = o, h = false;
    if (o.rank === 3 && (h = true, c = ee(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2]
    ])), s === "NCHW") throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    B(c.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`), B(l.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`), B(u.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`), B(u.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`), B(u.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);
    const d = l.shape[2], f = l.shape[3];
    B(u.shape[2] === d * f, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${d * f}, but got ${u.shape[2]}.`);
    const p = aP(c, l, r, i, s, a), m = Sd(p, u, 1, "valid", s);
    return h ? ee(m, [
      m.shape[1],
      m.shape[2],
      m.shape[3]
    ]) : m;
  }
  const V9 = te({
    separableConv2d_: PNe
  });
  function LNe(n) {
    const t = {
      x: U(n, "x", "sign")
    };
    return Q.runKernel(Kf, t);
  }
  const FNe = te({
    sign_: LNe
  });
  function ONe(n) {
    const t = {
      x: U(n, "x", "sin", "float32")
    };
    return Q.runKernel(qf, t);
  }
  const W9 = te({
    sin_: ONe
  });
  function BNe(n) {
    const t = {
      x: U(n, "x", "sinh")
    };
    return Q.runKernel(jf, t);
  }
  const G9 = te({
    sinh_: BNe
  });
  function zNe(n, e, t) {
    const r = U(n, "x", "slice1d");
    return B(r.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`), Wn(r, [
      e
    ], [
      t
    ]);
  }
  const vP = te({
    slice1d_: zNe
  });
  function VNe(n, e, t) {
    const r = U(n, "x", "slice2d");
    return B(r.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`), Wn(r, e, t);
  }
  const U9 = te({
    slice2d_: VNe
  });
  function WNe(n, e, t) {
    const r = U(n, "x", "slice3d");
    return B(r.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`), Wn(r, e, t);
  }
  const yP = te({
    slice3d_: WNe
  });
  function GNe(n, e, t) {
    const r = U(n, "x", "slice4d");
    return B(r.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`), Wn(r, e, t);
  }
  const MS = te({
    slice4d_: GNe
  });
  function UNe(n, e = -1) {
    const t = U(n, "logits", "softmax", "float32");
    if (e === -1 && (e = t.rank - 1), e !== t.rank - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);
    const r = {
      logits: t
    }, i = {
      dim: e
    };
    return Q.runKernel(tp, r, i);
  }
  const xP = te({
    softmax_: UNe
  });
  function HNe(n) {
    B(n.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);
    const e = {
      input: n
    };
    return Q.runKernel(oI, e);
  }
  const H9 = te({
    fft_: HNe
  });
  function XNe(n) {
    B(n.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);
    const e = {
      input: n
    };
    return Q.runKernel(lI, e);
  }
  const _$ = te({
    ifft_: XNe
  });
  function YNe(n) {
    const e = n.shape[n.shape.length - 1], t = n.size / e;
    let r;
    if (e <= 2) {
      const i = ee(n, [
        t,
        e
      ]);
      r = _$(i);
    } else {
      const i = [
        t,
        2 * (e - 1)
      ], a = ee(ES(n), [
        t,
        e
      ]), s = ee(lP(n), [
        t,
        e
      ]), o = Id(Wn(a, [
        0,
        1
      ], [
        t,
        e - 2
      ]), 1), l = Z(Id(Wn(s, [
        0,
        1
      ], [
        t,
        e - 2
      ]), 1), yn(-1)), u = Qi([
        a,
        o
      ], 1), c = Qi([
        s,
        l
      ], 1), h = ee(jg(u, c), [
        i[0],
        i[1]
      ]);
      r = _$(h);
    }
    if (r = ES(r), n.rank === 3 && n.shape[0] !== 0) {
      const i = r, a = n.shape[0];
      r = ee(r, [
        a,
        r.shape[0] / a,
        r.shape[1]
      ]), i.dispose();
    }
    return r;
  }
  const qNe = te({
    irfft_: YNe
  });
  function jNe(n, e, t = 0) {
    const i = {
      x: U(n, "x", "split")
    }, a = {
      numOrSizeSplits: e,
      axis: t
    };
    return Q.runKernel(gv, i, a);
  }
  const Ga = te({
    split_: jNe
  });
  function KNe(n, e) {
    B(n.dtype === "float32", () => `The dtype for rfft() must be real value but got ${n.dtype}`);
    let t = n.shape[n.shape.length - 1];
    const r = n.size / t;
    let i;
    if (e != null && e < t) {
      const p = n.shape.map((m) => 0), g = n.shape.map((m) => m);
      g[n.shape.length - 1] = e, i = Wn(n, p, g), t = e;
    } else if (e != null && e > t) {
      const p = n.shape.map((g) => g);
      p[n.shape.length - 1] = e - t, i = Qi([
        n,
        Cr(p)
      ], n.shape.length - 1), t = e;
    } else i = n;
    const a = un(i), s = ee(jg(i, a), [
      r,
      t
    ]), o = H9(s), l = Math.floor(t / 2) + 1, u = ES(o), c = lP(o), h = Ga(u, [
      l,
      t - l
    ], u.shape.length - 1), d = Ga(c, [
      l,
      t - l
    ], c.shape.length - 1), f = i.shape.slice();
    return f[i.shape.length - 1] = l, ee(jg(h[0], d[0]), f);
  }
  const ZNe = te({
    rfft_: KNe
  });
  function QNe(n, e) {
    let t = U(n, "a", "squaredDifference"), r = U(e, "b", "squaredDifference");
    [t, r] = hr(t, r), ht(t.shape, r.shape);
    const i = {
      a: t,
      b: r
    }, a = {};
    return Q.runKernel(np, i, a);
  }
  const JNe = te({
    squaredDifference_: QNe
  });
  function eEe(n, e) {
    const t = U(n, "x", "squeeze", "string_or_numeric");
    return ee(t, vc(t.shape, e).newShape);
  }
  const bb = te({
    squeeze_: eEe
  });
  function tEe(n, e = 0) {
    const t = d9(n, "tensors", "stack", "string_or_numeric");
    B(t.length >= 1, () => "Pass at least one tensor to tf.stack"), t.length > 0 && B(e <= t[0].rank, () => "Axis must be <= rank of the tensor");
    const r = t, i = {
      axis: e
    };
    return Q.runKernel(lv, r, i);
  }
  const tu = te({
    stack_: tEe
  });
  function nEe(n, e = 0) {
    const r = {
      x: U(n, "x", "step")
    }, i = {
      alpha: e
    };
    return Q.runKernel(_c, r, i);
  }
  const wb = te({
    step_: nEe
  });
  function rEe(n, e, t, r, i = 0, a = 0, s = 0, o = 0, l = 0) {
    const c = {
      x: U(n, "x", "stridedSlice", "string_or_numeric")
    }, h = {
      begin: e,
      end: t,
      strides: r,
      beginMask: i,
      endMask: a,
      ellipsisMask: s,
      newAxisMask: o,
      shrinkAxisMask: l
    };
    return Q.runKernel(mv, c, h);
  }
  const iEe = te({
    stridedSlice_: rEe
  });
  function aEe(n) {
    const t = {
      x: U(n, "x", "tan", "float32")
    };
    return Q.runKernel(ip, t);
  }
  const sEe = te({
    tan_: aEe
  });
  function Sa(n, e) {
    V7(n);
    const t = bI(n, e);
    if (t.length !== 1) throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return wI(n, null, t, e);
  }
  function oA(n, e, t) {
    if (V7(n), e != null && e.length !== 2) throw new Error("tensor2d() requires shape to have two numbers");
    const r = bI(n, t);
    if (r.length !== 2 && r.length !== 1) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (r.length === 1 && e == null) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return wI(n, e, r, t);
  }
  function X9(n, e, t) {
    const r = e.rank > 1 ? e.shape[e.rank - 1] : 1, i = e.rank > 1 ? e.rank - 1 : 1, a = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${i}.`;
    if (t.rank < i) throw new Error(a + ` update.rank < ${i}. `);
    if (n.length < r + (t.rank - i)) throw new Error(a + ` Output shape length < ${r + (t.rank - i)}`);
    if (t.rank !== i + n.length - r) throw new Error(a + ` update.rank != ${i + n.length - r}`);
    for (let s = 0; s < i; ++s) if (t.shape[s] !== e.shape[s]) throw new Error(a + ` updates.shape[${s}] (${t.shape[s]}) != indices.shape[${s}] (${e.shape[s]}).`);
    for (let s = 0; s < t.rank - i; ++s) if (t.shape[s + i] !== n[s + r]) throw new Error(a + ` updates.shape[${s + i}] (${t.shape[s + i]}) != shape[${s + i}] (${n[s + i]})`);
  }
  function oEe(n, e, t) {
    if (e.rank < 1) throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);
    if (n.rank < 1) throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);
    if (e.dtype !== "int32") throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);
    if (t.length < 1) throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);
    if (t.length === 0) {
      if (e.size === 0) throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);
      if (n.size === 0) throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`);
    }
    X9(t, e, n);
  }
  function Ka(n, e, t) {
    const r = e.shape.length, i = r > 1 ? e.shape[r - 1] : 1, a = t.length;
    let s = 1;
    for (let h = i; h < a; ++h) s *= t[h];
    const o = i < 1 ? 1 : i, l = X(e.shape) / o, u = [
      ...Be(t.slice(0, i)),
      1
    ], c = X(t);
    return {
      sliceRank: i,
      numUpdates: l,
      sliceSize: s,
      strides: u,
      outputSize: c
    };
  }
  function lEe(n, e = 1, t = true) {
    const r = U(n, "x", "topk");
    if (r.rank === 0) throw new Error("topk() expects the input to be of rank 1 or higher");
    const i = r.shape[r.shape.length - 1];
    if (e < 0) throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);
    if (e > i) throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);
    const a = {
      x: r
    }, s = {
      k: e,
      sorted: t
    }, [o, l] = Q.runKernel(vv, a, s);
    return {
      values: o,
      indices: l
    };
  }
  const uEe = te({
    topk_: lEe
  });
  function cEe(n, e = 0, t = 1, r, i) {
    if (su(n), r != null && r === "bool") throw new Error("Unsupported data type $ { dtype }");
    const a = new L9(e, t, r, true, i), s = Nt(n, r);
    for (let o = 0; o < s.values.length; o++) s.values[o] = a.nextValue();
    return s.toTensor();
  }
  const Y9 = te({
    truncatedNormal_: cEe
  });
  function hEe(n, e = 0) {
    const t = U(n, "x", "unique", "string_or_numeric");
    B(t.rank > 0, () => "The input tensor must be at least 1D");
    const r = {
      x: t
    }, i = {
      axis: e
    }, [a, s] = Q.runKernel(mI, r, i);
    return {
      values: a,
      indices: s
    };
  }
  const dEe = te({
    unique_: hEe
  });
  function fEe(n, e, t) {
    const r = U(n, "x", "unsortedSegmentSum"), i = U(e, "segmentIds", "unsortedSegmentSum", "int32");
    B(Ug(t), () => "numSegments must be of dtype int");
    const a = {
      x: r,
      segmentIds: i
    }, s = {
      numSegments: t
    };
    return Q.runKernel(mb, a, s);
  }
  const q9 = te({
    unsortedSegmentSum_: fEe
  });
  function pEe(n, e = 0) {
    const t = U(n, "x", "unstack", "string_or_numeric");
    B(e >= -t.shape.length && e < t.shape.length, () => `Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);
    const r = {
      value: t
    }, i = {
      axis: e
    };
    return Q.runKernel(xv, r, i);
  }
  const kd = te({
    unstack_: pEe
  });
  function gEe(n, e = true, t, r) {
    return Q.makeVariable(n, e, t, r);
  }
  function j9(n, e) {
    const t = [];
    for (let a = 0; a < e.length; a++) e[a] && t.push(a);
    const r = Nt(n, "int32"), i = Nt([
      t.length,
      n.length
    ], "int32");
    for (let a = 0; a < t.length; a++) {
      const s = r.indexToLoc(t[a]), o = a * n.length;
      i.values.set(s, o);
    }
    return i.toTensor();
  }
  function mEe(n, e, t) {
    const r = U(n, "x", "transpose");
    if (e == null && (e = r.shape.map((s, o) => o).reverse()), B(r.rank === e.length, () => `Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`), e.forEach((s) => {
      B(s >= 0 && s < r.rank, () => `All entries in 'perm' must be between 0 and ${r.rank - 1} but got ${e}`);
    }), r.rank <= 1) return r.clone();
    const i = {
      x: r
    }, a = {
      perm: e
    };
    return r.dtype === "complex64" ? se(() => {
      let s = ES(r), o = lP(r);
      return s = Q.runKernel(Ol, {
        x: s
      }, a), o = Q.runKernel(Ol, {
        x: o
      }, a), t && (o = cr(o)), jg(s, o);
    }) : Q.runKernel(Ol, i, a);
  }
  const ln = te({
    transpose_: mEe
  });
  function vEe(n, e) {
    if (e == null) return n.shape.slice();
    if (Jt(n.shape, e)) return e;
    if (n.shape.length === e.length) {
      const t = [];
      for (let r = 0; r < n.shape.length; r++) e[r] == null && n.shape[r] != null ? t.push(n.shape[r]) : t.push(e[r]);
      return t;
    }
    return e;
  }
  function yEe(n, e, t, r) {
    const i = U(n, "x", "dropout");
    if (B(i.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`), B(e >= 0 && e < 1, () => `rate must be a float in the range [0, 1), but got ${e}.`), e === 0) return n instanceof _r ? i.clone() : i;
    const a = vEe(i, t), s = 1 - e, o = gt(AI(Ce(xb(a, 0, 1, "float32", r), s)), s);
    return Z(i, o);
  }
  const xEe = te({
    dropout_: yEe
  });
  function bEe(n, e, t, r, i, a = "NHWC", s) {
    let o = n;
    n.rank === 3 && (o = ee(n, [
      1,
      n.shape[0],
      n.shape[1],
      n.shape[2]
    ]));
    let l = e;
    l.rank === 3 && (l = ee(e, [
      1,
      e.shape[0],
      e.shape[1],
      e.shape[2]
    ])), B(o.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`), B(l.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`), B(t.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);
    const u = a === "NHWC" ? o.shape[3] : o.shape[1], c = a === "NHWC" ? l.shape[3] : l.shape[1];
    B(u === t[2], () => `Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`), B(c === t[3], () => `Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`), la("conv2dDerFilter", i, s);
    const h = {
      x: o,
      dy: l
    }, d = {
      strides: r,
      pad: i,
      dataFormat: a,
      dimRoundingMode: s,
      filterShape: t
    };
    return Q.runKernel(nI, h, d);
  }
  const bP = te({
    conv2DBackpropFilter_: bEe
  });
  function wP(n, e, t) {
    if (t == null || t === "linear") return n;
    if (t === "relu") return Z(n, wb(e));
    throw new Error(`Cannot compute gradient for fused activation ${t}.`);
  }
  function _P(n, e) {
    let t = e;
    const r = Mr(n.shape, e.shape);
    return r.length > 0 && (t = ct(t, r)), ee(t, n.shape);
  }
  function SP(n, e, t, r) {
    if (e === "linear") return n;
    if (e === "relu") return lp(n);
    if (e === "elu") return kI(n);
    if (e === "relu6") return F9(n);
    if (e === "prelu") return gP(n, t);
    if (e === "leakyrelu") return uP(n, r);
    if (e === "sigmoid") return Cv(n);
    throw new Error(`Unknown fused activation ${e}.`);
  }
  const CP = (n, e) => !(n > 0) || e === "linear";
  function wEe({ x: n, filter: e, strides: t, pad: r, dataFormat: i = "NHWC", dilations: a = [
    1,
    1
  ], dimRoundingMode: s, bias: o, activation: l = "linear", preluActivationWeights: u, leakyreluAlpha: c }) {
    if (l = l || "linear", CP(Q.state.gradientDepth, l) === false) {
      B(i === "NHWC", () => `Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
      let _ = Sd(n, e, t, r, i, a, s);
      return o != null && (_ = Ce(_, o)), SP(_, l, u, c);
    }
    const h = U(n, "x", "conv2d", "float32"), d = U(e, "filter", "conv2d", "float32");
    let f = h, p = false;
    h.rank === 3 && (p = true, f = ee(h, [
      1,
      h.shape[0],
      h.shape[1],
      h.shape[2]
    ])), B(f.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`), B(d.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`), la("fused conv2d", r, s);
    const g = i === "NHWC" ? f.shape[3] : f.shape[1];
    B(d.shape[2] === g, () => `Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`), B(Pr(t, a), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);
    const m = Sn(f.shape, d.shape, t, a, r, s);
    let v;
    o != null && (v = U(o, "bias", "fused conv2d"), [v] = hr(v, h), i === "NHWC" ? ht(m.outShape, v.shape) : (B(v.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`), B(v.shape.length === 0 || v.shape[0] === m.outChannels || v.shape[0] === 1, () => `Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${m.outChannels})`)));
    let y;
    if (u != null) {
      const _ = u.shape;
      if (B(_.length <= 1 || _.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`), _.length === 1) B(_[0] === 1 || _[0] === m.outChannels, () => `Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${m.outChannels}).`);
      else if (_.length === 3) try {
        ht(_, m.outShape);
      } catch {
        const I = `Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${m.outShape}).`;
        throw Error(I);
      }
      y = U(u, "prelu weights", "fused conv2d");
    }
    const x = (_, S) => {
      B(i === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);
      const [I, C, T, k] = S, D = wP(_, T, l);
      B(wd(a), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);
      const R = rP(C.shape, D, I, t, r), N = bP(C, D, I.shape, t, r), E = [
        R,
        N
      ];
      if (k != null) {
        const A = _P(k, D);
        E.push(A);
      }
      return E;
    }, b = {
      x: f,
      filter: d,
      bias: v,
      preluActivationWeights: y
    }, w = {
      strides: t,
      pad: r,
      dataFormat: i,
      dilations: a,
      dimRoundingMode: s,
      activation: l,
      leakyreluAlpha: c
    };
    return o == null ? Kg((S, I, C) => {
      let T = Q.runKernel(yd, b, w);
      return C([
        I,
        S,
        T
      ]), p && (T = ee(T, [
        T.shape[1],
        T.shape[2],
        T.shape[3]
      ])), {
        value: T,
        gradFunc: x
      };
    })(f, d) : Kg((S, I, C, T) => {
      let k = Q.runKernel(yd, b, w);
      return T([
        I,
        S,
        k,
        C
      ]), p && (k = ee(k, [
        k.shape[1],
        k.shape[2],
        k.shape[3]
      ])), {
        value: k,
        gradFunc: x
      };
    })(f, d, v);
  }
  const _Ee = te({
    fusedConv2d_: wEe
  });
  function SEe(n, e, t, r, i, a = [
    1,
    1
  ], s) {
    let o = n;
    n.rank === 3 && (o = ee(n, [
      1,
      n.shape[0],
      n.shape[1],
      n.shape[2]
    ]));
    let l = e;
    l.rank === 3 && (l = ee(e, [
      1,
      e.shape[0],
      e.shape[1],
      e.shape[2]
    ]));
    const u = {
      x: o,
      dy: l
    }, c = {
      strides: r,
      pad: i,
      dimRoundingMode: s,
      dilations: a,
      filterShape: t
    };
    return Q.runKernel(rI, u, c);
  }
  const CEe = te({
    depthwiseConv2dNativeBackpropFilter_: SEe
  });
  function IEe(n, e, t, r, i, a = [
    1,
    1
  ], s) {
    let o = e, l = false;
    e.rank === 3 && (l = true, o = ee(e, [
      1,
      e.shape[0],
      e.shape[1],
      e.shape[2]
    ]));
    const u = {
      dy: o,
      filter: t
    }, c = {
      strides: r,
      pad: i,
      dimRoundingMode: s,
      dilations: a,
      inputShape: n
    }, h = Q.runKernel(iI, u, c);
    return l ? ee(h, [
      h.shape[1],
      h.shape[2],
      h.shape[3]
    ]) : h;
  }
  const kEe = te({
    depthwiseConv2dNativeBackpropInput_: IEe
  });
  function TEe({ a: n, b: e, transposeA: t = false, transposeB: r = false, bias: i, activation: a = "linear", preluActivationWeights: s, leakyreluAlpha: o = 0.2 }) {
    if (CP(Q.state.gradientDepth, a) === false) {
      let k = mn(n, e, t, r);
      return i != null && (k = Ce(k, i)), SP(k, a, s, o);
    }
    let l = U(n, "a", "fused matMul"), u = U(e, "b", "fused matMul");
    [l, u] = hr(l, u);
    const c = t ? l.shape[l.rank - 2] : l.shape[l.rank - 1], h = r ? u.shape[u.rank - 1] : u.shape[u.rank - 2], d = t ? l.shape[l.rank - 1] : l.shape[l.rank - 2], f = r ? u.shape[u.rank - 2] : u.shape[u.rank - 1], p = l.shape.slice(0, -2), g = u.shape.slice(0, -2), m = X(p), v = X(g);
    B(c === h, () => `Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${r} must match.`);
    const x = ht(l.shape.slice(0, -2), u.shape.slice(0, -2)).concat([
      d,
      f
    ]), b = t ? ee(l, [
      m,
      c,
      d
    ]) : ee(l, [
      m,
      d,
      c
    ]), w = r ? ee(u, [
      v,
      f,
      h
    ]) : ee(u, [
      v,
      h,
      f
    ]);
    let _;
    i != null && (_ = U(i, "bias", "fused matMul"), [_] = hr(_, l), ht(x, _.shape));
    let S;
    s != null && (S = U(s, "prelu weights", "fused matMul"));
    const I = (k, D) => {
      const [R, N, E, A] = D, M = wP(ee(k, E.shape), E, a);
      let $, L;
      if (!t && !r ? ($ = mn(M, N, false, true), L = mn(R, M, true, false)) : !t && r ? ($ = mn(M, N, false, false), L = mn(M, R, true, false)) : t && !r ? ($ = mn(N, M, false, true), L = mn(R, M, false, false)) : ($ = mn(N, M, true, true), L = mn(M, R, true, true)), i != null) {
        const F = _P(A, M);
        return [
          $,
          L,
          F
        ];
      } else return [
        $,
        L
      ];
    }, C = {
      a: b,
      b: w,
      bias: _,
      preluActivationWeights: S
    }, T = {
      transposeA: t,
      transposeB: r,
      activation: a,
      leakyreluAlpha: o
    };
    return i == null ? Kg((D, R, N) => {
      const E = Q.runKernel(vd, C, T);
      return N([
        D,
        R,
        E
      ]), {
        value: ee(E, x),
        gradFunc: I
      };
    })(b, w) : Kg((D, R, N, E) => {
      const A = Q.runKernel(vd, C, T);
      return E([
        D,
        R,
        A,
        N
      ]), {
        value: ee(A, x),
        gradFunc: I
      };
    })(b, w, _);
  }
  const R4 = te({
    fusedMatMul_: TEe
  });
  function AEe(n, e, t, r, i = "bilinear", a = 0) {
    const s = U(n, "image", "cropAndResize"), o = U(e, "boxes", "cropAndResize", "float32"), l = U(t, "boxInd", "cropAndResize", "int32"), u = o.shape[0];
    B(s.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${s.rank}.`), B(o.rank === 2 && o.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`), B(l.rank === 1 && l.shape[0] === u, () => `Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`), B(r.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`), B(r[0] >= 1 && r[1] >= 1, () => `cropSize must be atleast [1,1], but was ${r}`), B(i === "bilinear" || i === "nearest", () => `method must be bilinear or nearest, but was ${i}`);
    const c = {
      image: s,
      boxes: o,
      boxInd: l
    }, h = {
      method: i,
      extrapolationValue: a,
      cropSize: r
    };
    return Q.runKernel(Wm, c, h);
  }
  const DEe = te({
    cropAndResize_: AEe
  });
  function REe(n) {
    const e = U(n, "image", "flipLeftRight", "float32");
    B(e.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);
    const t = {
      image: e
    };
    return Q.runKernel(Ym, t, {});
  }
  const $Ee = te({
    flipLeftRight_: REe
  });
  function NEe(n) {
    const e = U(n, "image", "grayscaleToRGB"), t = e.rank - 1, r = e.shape[t];
    B(e.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`), B(r === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);
    const i = new Array(e.rank);
    return i.fill(1, 0, t), i[t] = 3, Ys(e, i);
  }
  const EEe = te({
    grayscaleToRGB_: NEe
  });
  function MEe(n) {
    const e = U(n, "image", "RGBToGrayscale"), t = e.rank - 1, r = e.shape[t];
    B(e.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`), B(r === 3, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);
    const i = e.dtype, a = Ve(e, "float32"), s = Sa([
      0.2989,
      0.587,
      0.114
    ]);
    let o;
    switch (e.rank) {
      case 2:
        o = by("ij,j->i", a, s);
        break;
      case 3:
        o = by("ijk,k->ij", a, s);
        break;
      case 4:
        o = by("ijkl,l->ijk", a, s);
        break;
      case 5:
        o = by("ijklm,m->ijkl", a, s);
        break;
      case 6:
        o = by("ijklmn,n->ijklm", a, s);
        break;
      default:
        throw new Error("Not a valid tensor rank.");
    }
    return o = Xi(o, -1), Ve(o, i);
  }
  const PEe = te({
    rgbToGrayscale_: MEe
  });
  function LEe(n, e, t = 0, r = 0.5) {
    const i = U(n, "image", "rotateWithOffset", "float32");
    B(i.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);
    const a = {
      image: i
    }, s = {
      radians: e,
      fillValue: t,
      center: r
    };
    return Q.runKernel(wv, a, s);
  }
  const FEe = te({
    rotateWithOffset_: LEe
  });
  function kv(n, e, t, r, i, a) {
    r == null && (r = 0.5), i == null && (i = Number.NEGATIVE_INFINITY), a == null && (a = 0);
    const s = n.shape[0];
    return t = Math.min(t, s), B(0 <= r && r <= 1, () => `iouThreshold must be in [0, 1], but was '${r}'`), B(n.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${n.rank}'`), B(n.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`), B(e.rank === 1, () => "scores must be a 1D tensor"), B(e.shape[0] === s, () => `scores has incompatible shape with boxes. Expected ${s}, but was ${e.shape[0]}`), B(0 <= a && a <= 1, () => `softNmsSigma must be in [0, 1], but was '${a}'`), {
      maxOutputSize: t,
      iouThreshold: r,
      scoreThreshold: i,
      softNmsSigma: a
    };
  }
  function OEe(n, e, t, r = 0.5, i = Number.NEGATIVE_INFINITY) {
    const a = U(n, "boxes", "nonMaxSuppression", "float32"), s = U(e, "scores", "nonMaxSuppression", "float32"), o = kv(a, s, t, r, i);
    t = o.maxOutputSize, r = o.iouThreshold, i = o.scoreThreshold;
    const l = {
      maxOutputSize: t,
      iouThreshold: r,
      scoreThreshold: i
    };
    return Q.runKernel(av, {
      boxes: a,
      scores: s
    }, l);
  }
  const BEe = te({
    nonMaxSuppression_: OEe
  });
  function zEe(n, e, t) {
    const r = VEe(n, e, t), i = r < 0 ? -(r + 1) : r;
    n.splice(i, 0, e);
  }
  function VEe(n, e, t) {
    return GEe(n, e, t || WEe);
  }
  function WEe(n, e) {
    return n > e ? 1 : n < e ? -1 : 0;
  }
  function GEe(n, e, t) {
    let r = 0, i = n.length, a = 0, s = false;
    for (; r < i; ) {
      a = r + (i - r >>> 1);
      const o = t(e, n[a]);
      o > 0 ? r = a + 1 : (i = a, s = !o);
    }
    return s ? r : -r - 1;
  }
  function DI(n, e, t, r, i) {
    return kP(n, e, t, r, i, 0);
  }
  function IP(n, e, t, r, i, a) {
    return kP(n, e, t, r, i, 0, false, a, true);
  }
  function RI(n, e, t, r, i, a) {
    return kP(n, e, t, r, i, a, true);
  }
  function kP(n, e, t, r, i, a, s = false, o = false, l = false) {
    const u = [];
    for (let m = 0; m < e.length; m++) e[m] > i && u.push({
      score: e[m],
      boxIndex: m,
      suppressBeginIndex: 0
    });
    u.sort($4);
    const c = a > 0 ? -0.5 / a : 0, h = [], d = [];
    for (; h.length < t && u.length > 0; ) {
      const m = u.pop(), { score: v, boxIndex: y, suppressBeginIndex: x } = m;
      if (v < i) break;
      let b = false;
      for (let w = h.length - 1; w >= x; --w) {
        const _ = UEe(n, y, h[w]);
        if (_ >= r) {
          b = true;
          break;
        }
        if (m.score = m.score * HEe(r, c, _), m.score <= i) break;
      }
      m.suppressBeginIndex = h.length, b || (m.score === v ? (h.push(y), d.push(m.score)) : m.score > i && zEe(u, m, $4));
    }
    const f = h.length, p = t - f;
    o && p > 0 && (h.push(...new Array(p).fill(0)), d.push(...new Array(p).fill(0)));
    const g = {
      selectedIndices: h
    };
    return s && (g.selectedScores = d), l && (g.validOutputs = f), g;
  }
  function UEe(n, e, t) {
    const r = n.subarray(e * 4, e * 4 + 4), i = n.subarray(t * 4, t * 4 + 4), a = Math.min(r[0], r[2]), s = Math.min(r[1], r[3]), o = Math.max(r[0], r[2]), l = Math.max(r[1], r[3]), u = Math.min(i[0], i[2]), c = Math.min(i[1], i[3]), h = Math.max(i[0], i[2]), d = Math.max(i[1], i[3]), f = (o - a) * (l - s), p = (h - u) * (d - c);
    if (f <= 0 || p <= 0) return 0;
    const g = Math.max(a, u), m = Math.max(s, c), v = Math.min(o, h), y = Math.min(l, d), x = Math.max(v - g, 0) * Math.max(y - m, 0);
    return x / (f + p - x);
  }
  function HEe(n, e, t) {
    const r = Math.exp(e * t * t);
    return t <= n ? r : 0;
  }
  function $4(n, e) {
    return n.score - e.score || n.score === e.score && e.boxIndex - n.boxIndex;
  }
  async function XEe(n, e, t, r = 0.5, i = Number.NEGATIVE_INFINITY) {
    const a = U(n, "boxes", "nonMaxSuppressionAsync"), s = U(e, "scores", "nonMaxSuppressionAsync"), o = kv(a, s, t, r, i);
    t = o.maxOutputSize, r = o.iouThreshold, i = o.scoreThreshold;
    const l = await Promise.all([
      a.data(),
      s.data()
    ]), u = l[0], c = l[1], { selectedIndices: h } = DI(u, c, t, r, i);
    return a !== n && a.dispose(), s !== e && s.dispose(), Sa(h, "int32");
  }
  const YEe = XEe;
  function qEe(n, e, t, r = 0.5, i = Number.NEGATIVE_INFINITY, a = 0) {
    const s = U(n, "boxes", "nonMaxSuppression"), o = U(e, "scores", "nonMaxSuppression"), l = kv(s, o, t, r, i, a);
    t = l.maxOutputSize, r = l.iouThreshold, i = l.scoreThreshold, a = l.softNmsSigma;
    const u = {
      boxes: s,
      scores: o
    }, c = {
      maxOutputSize: t,
      iouThreshold: r,
      scoreThreshold: i,
      softNmsSigma: a
    }, h = Q.runKernel(sv, u, c);
    return {
      selectedIndices: h[0],
      selectedScores: h[1]
    };
  }
  const jEe = te({
    nonMaxSuppressionWithScore_: qEe
  });
  async function KEe(n, e, t, r = 0.5, i = Number.NEGATIVE_INFINITY, a = 0) {
    const s = U(n, "boxes", "nonMaxSuppressionAsync"), o = U(e, "scores", "nonMaxSuppressionAsync"), l = kv(s, o, t, r, i, a);
    t = l.maxOutputSize, r = l.iouThreshold, i = l.scoreThreshold, a = l.softNmsSigma;
    const u = await Promise.all([
      s.data(),
      o.data()
    ]), c = u[0], h = u[1], { selectedIndices: d, selectedScores: f } = RI(c, h, t, r, i, a);
    return s !== n && s.dispose(), o !== e && o.dispose(), {
      selectedIndices: Sa(d, "int32"),
      selectedScores: Sa(f)
    };
  }
  const ZEe = KEe;
  function QEe(n, e, t, r = 0.5, i = Number.NEGATIVE_INFINITY, a = false) {
    const s = U(n, "boxes", "nonMaxSuppression"), o = U(e, "scores", "nonMaxSuppression"), l = kv(s, o, t, r, i, null), u = l.maxOutputSize, c = l.iouThreshold, h = l.scoreThreshold, d = {
      boxes: s,
      scores: o
    }, f = {
      maxOutputSize: u,
      iouThreshold: c,
      scoreThreshold: h,
      padToMaxOutputSize: a
    }, p = Q.runKernel(ub, d, f);
    return {
      selectedIndices: p[0],
      validOutputs: p[1]
    };
  }
  const JEe = te({
    nonMaxSuppressionPadded_: QEe
  });
  async function eMe(n, e, t, r = 0.5, i = Number.NEGATIVE_INFINITY, a = false) {
    const s = U(n, "boxes", "nonMaxSuppressionAsync"), o = U(e, "scores", "nonMaxSuppressionAsync"), l = kv(s, o, t, r, i, null), u = l.maxOutputSize, c = l.iouThreshold, h = l.scoreThreshold, [d, f] = await Promise.all([
      s.data(),
      o.data()
    ]), { selectedIndices: p, validOutputs: g } = IP(d, f, u, c, h, a);
    return s !== n && s.dispose(), o !== e && o.dispose(), {
      selectedIndices: Sa(p, "int32"),
      validOutputs: yn(g, "int32")
    };
  }
  const tMe = eMe;
  function nMe(n, e, t = false, r = false) {
    const i = U(n, "images", "resizeBilinear");
    B(i.rank === 3 || i.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`), B(e.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${e}.`), B(r === false || t === false, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
    let a = i, s = false;
    i.rank === 3 && (s = true, a = ee(i, [
      1,
      i.shape[0],
      i.shape[1],
      i.shape[2]
    ]));
    const o = {
      images: a
    }, l = {
      alignCorners: t,
      halfPixelCenters: r,
      size: e
    }, u = Q.runKernel(Wf, o, l);
    return s ? ee(u, [
      u.shape[1],
      u.shape[2],
      u.shape[3]
    ]) : u;
  }
  const K9 = te({
    resizeBilinear_: nMe
  });
  function rMe(n, e, t = false, r = false) {
    const i = U(n, "images", "resizeNearestNeighbor");
    B(i.rank === 3 || i.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`), B(e.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`), B(i.dtype === "float32" || i.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), B(r === false || t === false, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
    let a = i, s = false;
    i.rank === 3 && (s = true, a = ee(i, [
      1,
      i.shape[0],
      i.shape[1],
      i.shape[2]
    ]));
    const o = {
      images: a
    }, l = {
      alignCorners: t,
      halfPixelCenters: r,
      size: e
    }, u = Q.runKernel(Vf, o, l);
    return s ? ee(u, [
      u.shape[1],
      u.shape[2],
      u.shape[3]
    ]) : u;
  }
  const Z9 = te({
    resizeNearestNeighbor_: rMe
  });
  function iMe(n, e = "binary", t = false, r = 0.5) {
    const i = U(n, "image", "threshold"), a = 0.2989, s = 0.587, o = 0.114, l = i.shape[0] * i.shape[1];
    let u = Z(Sa([
      r
    ]), 255), c, h, d, f;
    if (B(i.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${i.rank}.`), B(i.shape[2] === 3 || i.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`), B(i.dtype === "int32" || i.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`), B(e === "otsu" || e === "binary", () => `Method must be binary or otsu, but was ${e}`), i.shape[2] === 3) {
      [c, h, d] = Ga(i, [
        1,
        1,
        1
      ], -1);
      const m = Z(c, a), v = Z(h, s), y = Z(d, o);
      f = Ce(Ce(m, v), y);
    } else f = n;
    if (e === "otsu") {
      const m = nRe(Ve(O9(f), "int32"), QM([]), 256);
      u = aMe(m, l);
    }
    const p = t ? Iv(f, u) : ja(f, u);
    return Ve(Z(p, 255), "int32");
  }
  function aMe(n, e) {
    let t = Sa([
      -1
    ]), r = Sa([
      0
    ]), i = Sa([
      0
    ]), a, s, o, l, u, c;
    for (let h = 0; h < n.size - 1; h++) {
      a = Wn(n, 0, h + 1), s = Wn(n, h + 1), u = gt(ct(a), e), c = gt(ct(s), e);
      const d = ct(Z(a, ox(0, a.size)));
      o = gt(d, ct(a));
      const f = II(s.shape, a.size), p = Ce(ox(0, s.size), f), g = Z(s, p);
      l = gt(ct(g), ct(s));
      const m = wt(o, l), v = wt(o, l), y = Z(u, c);
      i = Z(Z(y, m), v);
      const x = ja(i, r);
      r = Ni(x, i, r), t = Ni(x, Sa([
        h
      ]), t);
    }
    return t;
  }
  const sMe = te({
    threshold_: iMe
  });
  function oMe(n, e, t = "nearest", r = "constant", i = 0, a) {
    const s = U(n, "image", "transform", "float32"), o = U(e, "transforms", "transform", "float32");
    B(s.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${s.rank}.`), B(o.rank === 2 && (o.shape[0] === s.shape[0] || o.shape[0] === 1) && o.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), B(a == null || a.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${a}.`);
    const l = {
      image: s,
      transforms: o
    }, u = {
      interpolation: t,
      fillMode: r,
      fillValue: i,
      outputShape: a
    };
    return Q.runKernel(yv, l, u);
  }
  const lMe = te({
    transform_: oMe
  });
  function uMe(n, e, t) {
    const r = U(n, "a", "bandPart");
    B(r.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${r.rank}.`);
    const i = r.shape, [a, s] = r.shape.slice(-2);
    let o, l;
    typeof e == "number" ? (B(e % 1 === 0, () => `bandPart(): numLower must be an integer, got ${e}.`), B(e <= a, () => `bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`), o = U(e < 0 ? a : e, "numLower", "bandPart")) : (B(e.dtype === "int32", () => "bandPart(): numLower's dtype must be an int32."), o = Ni($S(e, 0), a, sx(e, a))), typeof t == "number" ? (B(t % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${t}.`), B(t <= s, () => `bandPart(): numUpper (${t}) must not be greater than the number of columns (${s}).`), l = U(t < 0 ? s : t, "numUpper", "bandPart")) : (B(t.dtype === "int32", () => "bandPart(): numUpper's dtype must be an int32."), l = Ni($S(t, 0), s, sx(t, s)));
    const u = ee(ox(0, a, 1, "int32"), [
      -1,
      1
    ]), c = ox(0, s, 1, "int32"), h = wt(u, c), d = eu(Iv(h, o), op(h, cr(l))), f = Cr([
      a,
      s
    ], r.dtype);
    return ee(tu(kd(ee(r, [
      -1,
      a,
      s
    ])).map((p) => Ni(d, p, f))), i);
  }
  const cMe = te({
    bandPart_: uMe
  });
  function hMe(n) {
    let e;
    if (Array.isArray(n)) {
      e = false, B(n != null && n.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
      const i = n[0].shape[0];
      for (let a = 1; a < n.length; ++a) B(n[a].shape[0] === i, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${i})`);
    } else e = true, n = Ga(n, n.shape[0], 0).map((i) => bb(i, [
      0
    ]));
    B(n.length <= n[0].shape[0], () => `Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);
    const t = [], r = n;
    for (let i = 0; i < n.length; ++i) t.push(Q.tidy(() => {
      let a = r[i];
      if (i > 0) for (let s = 0; s < i; ++s) {
        const o = Z(ct(Z(t[s], a)), t[s]);
        a = wt(a, o);
      }
      return gt(a, TI(a, "euclidean"));
    }));
    return e ? tu(t, 0) : t;
  }
  const dMe = te({
    gramSchmidt_: hMe
  });
  function fMe(n, e = false) {
    if (B(n.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`), n.rank === 2) return N4(n, e);
    {
      const t = n.shape.slice(0, n.shape.length - 2).reduce((l, u) => l * u), r = kd(ee(n, [
        t,
        n.shape[n.shape.length - 2],
        n.shape[n.shape.length - 1]
      ]), 0), i = [], a = [];
      r.forEach((l) => {
        const [u, c] = N4(l, e);
        i.push(u), a.push(c);
      });
      const s = ee(tu(i, 0), n.shape), o = ee(tu(a, 0), n.shape);
      return [
        s,
        o
      ];
    }
  }
  function N4(n, e = false) {
    return Q.tidy(() => {
      B(n.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);
      const t = n.shape[0], r = n.shape[1];
      let i = R9(t), a = id(n);
      const s = oA([
        [
          1
        ]
      ], [
        1,
        1
      ]);
      let o = id(s);
      const l = t >= r ? r : t;
      for (let u = 0; u < l; ++u) {
        const c = a, h = o, d = i;
        [o, a, i] = Q.tidy(() => {
          const f = Wn(a, [
            u,
            u
          ], [
            t - u,
            1
          ]), p = TI(f), g = Wn(a, [
            u,
            u
          ], [
            1,
            1
          ]), m = Ni(ja(g, 0), oA([
            [
              -1
            ]
          ]), oA([
            [
              1
            ]
          ])), v = wt(g, Z(m, p)), y = gt(f, v);
          y.shape[0] === 1 ? o = id(s) : o = Qi([
            s,
            Wn(y, [
              1,
              0
            ], [
              y.shape[0] - 1,
              y.shape[1]
            ])
          ], 0);
          const x = cr(gt(mn(m, v), p)), b = Wn(a, [
            u,
            0
          ], [
            t - u,
            r
          ]), w = Z(x, o), _ = ln(o);
          if (u === 0) a = wt(b, mn(w, mn(_, b)));
          else {
            const C = wt(b, mn(w, mn(_, b)));
            a = Qi([
              Wn(a, [
                0,
                0
              ], [
                u,
                r
              ]),
              C
            ], 0);
          }
          const S = ln(w), I = Wn(i, [
            0,
            u
          ], [
            t,
            i.shape[1] - u
          ]);
          if (u === 0) i = wt(I, mn(mn(I, o), S));
          else {
            const C = wt(I, mn(mn(I, o), S));
            i = Qi([
              Wn(i, [
                0,
                0
              ], [
                t,
                u
              ]),
              C
            ], 1);
          }
          return [
            o,
            a,
            i
          ];
        }), jt([
          c,
          h,
          d
        ]);
      }
      return !e && t > r && (i = Wn(i, [
        0,
        0
      ], [
        t,
        r
      ]), a = Wn(a, [
        0,
        0
      ], [
        r,
        r
      ])), [
        i,
        a
      ];
    });
  }
  const pMe = te({
    qr_: fMe
  });
  const Dl = {
    flipLeftRight: $Ee,
    grayscaleToRGB: EEe,
    resizeNearestNeighbor: Z9,
    resizeBilinear: K9,
    rgbToGrayscale: PEe,
    rotateWithOffset: FEe,
    cropAndResize: DEe,
    nonMaxSuppression: BEe,
    nonMaxSuppressionAsync: YEe,
    nonMaxSuppressionWithScore: jEe,
    nonMaxSuppressionWithScoreAsync: ZEe,
    nonMaxSuppressionPadded: JEe,
    nonMaxSuppressionPaddedAsync: tMe,
    threshold: sMe,
    transform: lMe
  }, gMe = {
    bandPart: cMe,
    gramSchmidt: dMe,
    qr: pMe
  };
  const mMe = /* @__PURE__ */ new Map(), vMe = /* @__PURE__ */ new Map();
  class Tv {
    getClassName() {
      return this.constructor.className;
    }
    static fromConfig(e, t) {
      return new e(t);
    }
  }
  class ms {
    constructor() {
      this.classNameMap = {};
    }
    static getMap() {
      return ms.instance == null && (ms.instance = new ms()), ms.instance;
    }
    static register(e) {
      ms.getMap().classNameMap[e.className] = [
        e,
        e.fromConfig
      ];
    }
  }
  function we(n, e, t) {
    B(n.className != null, () => "Class being registered does not have the static className property defined."), B(typeof n.className == "string", () => "className is required to be a string, but got type " + typeof n.className), B(n.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), typeof e > "u" && (e = "Custom"), typeof t > "u" && (t = n.className);
    const r = t, i = e + ">" + r;
    return ms.register(n), mMe.set(i, n), vMe.set(n, i), n;
  }
  class kc extends Tv {
    minimize(e, t = false, r) {
      const { value: i, grads: a } = this.computeGradients(e, r);
      if (r != null) {
        const s = r.map((o) => ({
          name: o.name,
          tensor: a[o.name]
        }));
        this.applyGradients(s);
      } else this.applyGradients(a);
      return jt(a), t ? i : (i.dispose(), null);
    }
    get iterations() {
      return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
    }
    incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
    computeGradients(e, t) {
      return S$e(e, t);
    }
    dispose() {
      this.iterations_ != null && jt(this.iterations_);
    }
    async saveIterations() {
      return this.iterations_ == null && (this.iterations_ = 0), {
        name: "iter",
        tensor: yn(this.iterations_, "int32")
      };
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(e) {
      throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
    }
    async extractIterations(e) {
      return this.iterations_ = (await e[0].tensor.data())[0], e.slice(1);
    }
  }
  Object.defineProperty(kc, Symbol.hasInstance, {
    value: (n) => n.minimize != null && n.computeGradients != null && n.applyGradients != null
  });
  class Q9 extends kc {
    static get className() {
      return "Adadelta";
    }
    constructor(e, t, r = null) {
      super(), this.learningRate = e, this.rho = t, this.epsilon = r, this.accumulatedGrads = [], this.accumulatedUpdates = [], r == null && (this.epsilon = Q.backend.epsilon());
    }
    applyGradients(e) {
      (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, i) => {
        const a = Q.registeredVariables[r], s = false;
        this.accumulatedGrads[i] == null && (this.accumulatedGrads[i] = {
          originalName: `${r}/accum_grad`,
          variable: se(() => un(a).variable(s))
        }), this.accumulatedUpdates[i] == null && (this.accumulatedUpdates[i] = {
          originalName: `${r}/accum_var`,
          variable: se(() => un(a).variable(s))
        });
        const o = Array.isArray(e) ? e[i].tensor : e[r];
        if (o == null) return;
        const l = this.accumulatedGrads[i].variable, u = this.accumulatedUpdates[i].variable;
        se(() => {
          const c = Ce(Z(l, this.rho), Z(Xn(o), 1 - this.rho)), h = Z(gt(mi(Ce(u, this.epsilon)), mi(Ce(l, this.epsilon))), o), d = Ce(Z(u, this.rho), Z(Xn(h), 1 - this.rho));
          l.assign(c), u.assign(d);
          const f = Ce(Z(h, -this.learningRate), a);
          a.assign(f);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedUpdates != null && (jt(this.accumulatedGrads.map((e) => e.variable)), jt(this.accumulatedUpdates.map((e) => e.variable)));
    }
    async getWeights() {
      const e = [
        ...this.accumulatedGrads,
        ...this.accumulatedUpdates
      ];
      return [
        await this.saveIterations()
      ].concat(e.map((t) => ({
        name: t.originalName,
        tensor: t.variable
      })));
    }
    async setWeights(e) {
      e = await this.extractIterations(e);
      const t = e.length / 2, r = false;
      this.accumulatedGrads = e.slice(0, t).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })), this.accumulatedUpdates = e.slice(t, t * 2).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        rho: this.rho,
        epsilon: this.epsilon
      };
    }
    static fromConfig(e, t) {
      return new e(t.learningRate, t.rho, t.epsilon);
    }
  }
  class J9 extends kc {
    static get className() {
      return "Adagrad";
    }
    constructor(e, t = 0.1) {
      super(), this.learningRate = e, this.initialAccumulatorValue = t, this.accumulatedGrads = [];
    }
    applyGradients(e) {
      (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, i) => {
        const a = Q.registeredVariables[r];
        this.accumulatedGrads[i] == null && (this.accumulatedGrads[i] = {
          originalName: `${r}/accumulator`,
          variable: se(() => II(a.shape, this.initialAccumulatorValue).variable(false))
        });
        const s = Array.isArray(e) ? e[i].tensor : e[r];
        if (s == null) return;
        const o = this.accumulatedGrads[i].variable;
        se(() => {
          const l = Ce(o, Xn(s));
          o.assign(l);
          const u = Ce(Z(gt(s, mi(Ce(l, Q.backend.epsilon()))), -this.learningRate), a);
          a.assign(u);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedGrads != null && jt(this.accumulatedGrads.map((e) => e.variable));
    }
    async getWeights() {
      return [
        await this.saveIterations()
      ].concat(this.accumulatedGrads.map((e) => ({
        name: e.originalName,
        tensor: e.variable
      })));
    }
    async setWeights(e) {
      e = await this.extractIterations(e);
      const t = false;
      this.accumulatedGrads = e.map((r) => ({
        originalName: r.name,
        variable: r.tensor.variable(t)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        initialAccumulatorValue: this.initialAccumulatorValue
      };
    }
    static fromConfig(e, t) {
      return new e(t.learningRate, t.initialAccumulatorValue);
    }
  }
  class eZ extends kc {
    static get className() {
      return "Adam";
    }
    constructor(e, t, r, i = null) {
      super(), this.learningRate = e, this.beta1 = t, this.beta2 = r, this.epsilon = i, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], se(() => {
        this.accBeta1 = yn(t).variable(), this.accBeta2 = yn(r).variable();
      }), i == null && (this.epsilon = Q.backend.epsilon());
    }
    applyGradients(e) {
      const t = Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e);
      se(() => {
        const r = wt(1, this.accBeta1), i = wt(1, this.accBeta2);
        t.forEach((a, s) => {
          const o = Q.registeredVariables[a], l = false;
          this.accumulatedFirstMoment[s] == null && (this.accumulatedFirstMoment[s] = {
            originalName: `${a}/m`,
            variable: se(() => un(o).variable(l))
          }), this.accumulatedSecondMoment[s] == null && (this.accumulatedSecondMoment[s] = {
            originalName: `${a}/v`,
            variable: se(() => un(o).variable(l))
          });
          const u = Array.isArray(e) ? e[s].tensor : e[a];
          if (u == null) return;
          const c = this.accumulatedFirstMoment[s].variable, h = this.accumulatedSecondMoment[s].variable, d = Ce(Z(c, this.beta1), Z(u, 1 - this.beta1)), f = Ce(Z(h, this.beta2), Z(Xn(u), 1 - this.beta2)), p = gt(d, r), g = gt(f, i);
          c.assign(d), h.assign(f);
          const m = Ce(Z(gt(p, Ce(mi(g), this.epsilon)), -this.learningRate), o);
          o.assign(m);
        }), this.accBeta1.assign(Z(this.accBeta1, this.beta1)), this.accBeta2.assign(Z(this.accBeta2, this.beta2));
      }), this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && jt(this.accumulatedFirstMoment.map((e) => e.variable)), this.accumulatedSecondMoment != null && jt(this.accumulatedSecondMoment.map((e) => e.variable));
    }
    async getWeights() {
      const e = [
        ...this.accumulatedFirstMoment,
        ...this.accumulatedSecondMoment
      ];
      return [
        await this.saveIterations()
      ].concat(e.map((t) => ({
        name: t.originalName,
        tensor: t.variable
      })));
    }
    async setWeights(e) {
      e = await this.extractIterations(e), se(() => {
        this.accBeta1.assign(Cd(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(Cd(this.beta2, this.iterations_ + 1));
      });
      const t = e.length / 2, r = false;
      this.accumulatedFirstMoment = e.slice(0, t).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })), this.accumulatedSecondMoment = e.slice(t, t * 2).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon
      };
    }
    static fromConfig(e, t) {
      return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);
    }
  }
  class tZ extends kc {
    static get className() {
      return "Adamax";
    }
    constructor(e, t, r, i = null, a = 0) {
      super(), this.learningRate = e, this.beta1 = t, this.beta2 = r, this.epsilon = i, this.decay = a, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], se(() => {
        this.iteration = yn(0).variable(), this.accBeta1 = yn(t).variable();
      }), i == null && (this.epsilon = Q.backend.epsilon());
    }
    applyGradients(e) {
      const t = Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e);
      se(() => {
        const r = wt(1, this.accBeta1), i = gt(-this.learningRate, Ce(Z(this.iteration, this.decay), 1));
        t.forEach((a, s) => {
          const o = Q.registeredVariables[a], l = false;
          this.accumulatedFirstMoment[s] == null && (this.accumulatedFirstMoment[s] = {
            originalName: `${a}/m`,
            variable: un(o).variable(l)
          }), this.accumulatedWeightedInfNorm[s] == null && (this.accumulatedWeightedInfNorm[s] = {
            originalName: `${a}/v`,
            variable: un(o).variable(l)
          });
          const u = Array.isArray(e) ? e[s].tensor : e[a];
          if (u == null) return;
          const c = this.accumulatedFirstMoment[s].variable, h = this.accumulatedWeightedInfNorm[s].variable, d = Ce(Z(c, this.beta1), Z(u, 1 - this.beta1)), f = Z(h, this.beta2), p = ki(u), g = Cc(f, p);
          c.assign(d), h.assign(g);
          const m = Ce(Z(gt(i, r), gt(d, Ce(g, this.epsilon))), o);
          o.assign(m);
        }), this.iteration.assign(Ce(this.iteration, 1)), this.accBeta1.assign(Z(this.accBeta1, this.beta1));
      }), this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && jt(this.accumulatedFirstMoment.map((e) => e.variable)), this.accumulatedWeightedInfNorm != null && jt(this.accumulatedWeightedInfNorm.map((e) => e.variable));
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(e) {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon,
        decay: this.decay
      };
    }
    static fromConfig(e, t) {
      return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);
    }
  }
  class TP extends kc {
    static get className() {
      return "SGD";
    }
    constructor(e) {
      super(), this.learningRate = e, this.setLearningRate(e);
    }
    applyGradients(e) {
      (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, i) => {
        const a = Array.isArray(e) ? e[i].tensor : e[r];
        if (a == null) return;
        const s = Q.registeredVariables[r];
        se(() => {
          const o = Ce(Z(this.c, a), s);
          s.assign(o);
        });
      }), this.incrementIterations();
    }
    setLearningRate(e) {
      this.learningRate = e, this.c != null && this.c.dispose(), this.c = qo(yn(-e));
    }
    dispose() {
      this.c.dispose();
    }
    async getWeights() {
      return [
        await this.saveIterations()
      ];
    }
    async setWeights(e) {
      if (e = await this.extractIterations(e), e.length !== 0) throw new Error("SGD optimizer does not have settable weights.");
    }
    getConfig() {
      return {
        learningRate: this.learningRate
      };
    }
    static fromConfig(e, t) {
      return new e(t.learningRate);
    }
  }
  class nZ extends TP {
    static get className() {
      return "Momentum";
    }
    constructor(e, t, r = false) {
      super(e), this.learningRate = e, this.momentum = t, this.useNesterov = r, this.accumulations = [], this.m = yn(this.momentum);
    }
    applyGradients(e) {
      (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, i) => {
        const a = Q.registeredVariables[r];
        this.accumulations[i] == null && (this.accumulations[i] = {
          originalName: `${r}/momentum`,
          variable: se(() => un(a).variable(false))
        });
        const s = this.accumulations[i].variable, o = Array.isArray(e) ? e[i].tensor : e[r];
        o != null && se(() => {
          let l;
          const u = Ce(Z(this.m, s), o);
          this.useNesterov ? l = Ce(Z(this.c, Ce(o, Z(u, this.m))), a) : l = Ce(Z(this.c, u), a), s.assign(u), a.assign(l);
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.m.dispose(), this.accumulations != null && jt(this.accumulations.map((e) => e.variable));
    }
    setMomentum(e) {
      this.momentum = e;
    }
    async getWeights() {
      return [
        await this.saveIterations()
      ].concat(this.accumulations.map((e) => ({
        name: e.originalName,
        tensor: e.variable
      })));
    }
    async setWeights(e) {
      e = await this.extractIterations(e);
      const t = false;
      this.accumulations = e.map((r) => ({
        originalName: r.name,
        variable: r.tensor.variable(t)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        momentum: this.momentum,
        useNesterov: this.useNesterov
      };
    }
    static fromConfig(e, t) {
      return new e(t.learningRate, t.momentum, t.useNesterov);
    }
  }
  class rZ extends kc {
    static get className() {
      return "RMSProp";
    }
    constructor(e, t = 0.9, r = 0, i = null, a = false) {
      if (super(), this.learningRate = e, this.decay = t, this.momentum = r, this.epsilon = i, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = a, i == null && (this.epsilon = Q.backend.epsilon()), e == null) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    }
    applyGradients(e) {
      (Array.isArray(e) ? e.map((r) => r.name) : Object.keys(e)).forEach((r, i) => {
        const a = Q.registeredVariables[r], s = false;
        this.accumulatedMeanSquares[i] == null && (this.accumulatedMeanSquares[i] = {
          originalName: `${r}/rms`,
          variable: se(() => un(a).variable(s))
        }), this.accumulatedMoments[i] == null && (this.accumulatedMoments[i] = {
          originalName: `${r}/momentum`,
          variable: se(() => un(a).variable(s))
        }), this.accumulatedMeanGrads[i] == null && this.centered && (this.accumulatedMeanGrads[i] = {
          originalName: `${r}/mg`,
          variable: se(() => un(a).variable(s))
        });
        const o = Array.isArray(e) ? e[i].tensor : e[r];
        if (o == null) return;
        const l = this.accumulatedMeanSquares[i].variable, u = this.accumulatedMoments[i].variable;
        se(() => {
          const c = Ce(Z(l, this.decay), Z(Xn(o), 1 - this.decay));
          if (this.centered) {
            const h = this.accumulatedMeanGrads[i].variable, d = Ce(Z(h, this.decay), Z(o, 1 - this.decay)), f = gt(Z(o, this.learningRate), mi(wt(c, Ce(Xn(d), this.epsilon)))), p = Ce(Z(u, this.momentum), f);
            l.assign(c), h.assign(d), u.assign(p);
            const g = wt(a, p);
            a.assign(g);
          } else {
            const h = Ce(Z(l, this.decay), Z(Xn(o), 1 - this.decay)), d = Ce(Z(u, this.momentum), gt(Z(o, this.learningRate), mi(Ce(h, this.epsilon))));
            l.assign(h), u.assign(d);
            const f = wt(a, d);
            a.assign(f);
          }
        });
      }), this.incrementIterations();
    }
    dispose() {
      this.accumulatedMeanSquares != null && jt(this.accumulatedMeanSquares.map((e) => e.variable)), this.accumulatedMeanGrads != null && this.centered && jt(this.accumulatedMeanGrads.map((e) => e.variable)), this.accumulatedMoments != null && jt(this.accumulatedMoments.map((e) => e.variable));
    }
    async getWeights() {
      const e = [
        ...this.accumulatedMeanSquares,
        ...this.accumulatedMoments
      ];
      return this.centered && e.push(...this.accumulatedMeanGrads), [
        await this.saveIterations()
      ].concat(e.map((t) => ({
        name: t.originalName,
        tensor: t.variable
      })));
    }
    async setWeights(e) {
      e = await this.extractIterations(e);
      const t = this.centered ? e.length / 3 : e.length / 2, r = false;
      this.accumulatedMeanSquares = e.slice(0, t).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })), this.accumulatedMoments = e.slice(t, t * 2).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })), this.centered && (this.accumulatedMeanGrads = e.slice(t * 2, t * 3).map((i) => ({
        originalName: i.name,
        variable: i.tensor.variable(r)
      })));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        decay: this.decay,
        momentum: this.momentum,
        epsilon: this.epsilon,
        centered: this.centered
      };
    }
    static fromConfig(e, t) {
      return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);
    }
  }
  const yMe = [
    Q9,
    J9,
    eZ,
    tZ,
    nZ,
    rZ,
    TP
  ];
  function xMe() {
    for (const n of yMe) we(n);
  }
  function _b(n, e) {
    const t = n.shape.length, r = e.shape.length;
    if (t < 1) throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);
    if (r < 1) throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);
    if (e.dtype !== "int32") throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);
    if (e.shape[r - 1] > t) throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r - 1]} vs. ${t}`);
    if (X(n.shape) === 0) throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);
    const i = e.shape, a = i[i.length - 1];
    let s = 1;
    for (let h = 0; h < i.length - 1; ++h) s *= i[h];
    const o = n.shape, l = i.slice();
    l.pop();
    let u = 1;
    for (let h = a; h < t; ++h) u *= o[h], l.push(o[h]);
    const c = [
      ...Be(n.shape).map((h) => h / u),
      1
    ].slice(0, a);
    return [
      l,
      s,
      u,
      c
    ];
  }
  const S$ = -2, bMe = -1;
  function $I(n, e, t) {
    const r = n.shape.length;
    B(r === e.length, () => `Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`), B(r === t.length, () => `Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);
    for (let i = 0; i < r; ++i) B(e[i] + t[i] <= n.shape[i], () => `Error in slice${r}D: begin[${i}] + size[${i}] (${e[i] + t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`);
  }
  function wMe(n) {
    const e = [];
    let t = 0;
    for (; n > 0; ) n & 1 && e.push(t), n /= 2, t++;
    return e;
  }
  function Sb(n, e, t) {
    const r = [];
    for (let i = 0; i < n.length; i++) r[i] = Math.ceil((e[i] - n[i]) / t[i]);
    return r;
  }
  function iZ(n, e, t, r) {
    const i = [
      ...n
    ];
    for (let a = i.length; a < r.length; a++) i.push(1);
    for (let a = 0; a < t; a++) a === 0 ? i[e] = 1 : (i.splice(e, 0, 1), i.pop());
    return i;
  }
  function aZ(n, e, t) {
    return t <= n ? t : t - (e - 1);
  }
  function sZ(n, e) {
    const t = [];
    for (let r = 0; r < n; r++) t.push(e + r);
    return t;
  }
  function _Me(n, e, t, r, i, a, s, o, l) {
    const u = n.length;
    let c = new Array(u), h = new Array(u), d = new Array(u);
    if (e.length && t > 0) {
      const f = e[0], p = t + 1;
      c = oZ(s, f, p, r, n), h = lZ(o, f, p, i, n), d = iZ(a, f, p, n);
    } else for (let f = 0; f < u; f++) c[f] = cZ(s, r, a, n, f, l), h[f] = hZ(o, i, a, n, f, l), d[f] = uZ(a, f, l);
    return {
      begin: c,
      end: h,
      strides: d
    };
  }
  function oZ(n, e, t, r, i) {
    const a = [
      ...i
    ], s = sZ(t, e);
    for (let o = 0; o < a.length; o++) if (s.indexOf(o) > -1) a[o] = 0;
    else {
      const l = aZ(e, t, o);
      let u = r[l];
      n & 1 << l && (u = 0), a[o] = u;
    }
    return a;
  }
  function lZ(n, e, t, r, i) {
    const a = [
      ...i
    ], s = sZ(t, e);
    for (let o = 0; o < a.length; o++) if (s.indexOf(o) > -1) a[o] = Number.MAX_SAFE_INTEGER;
    else {
      const l = aZ(e, t, o);
      let u = r[l];
      n & 1 << l && (u = Number.MAX_SAFE_INTEGER), a[o] = u;
    }
    for (let o = 0; o < a.length; o++) {
      const l = i[o];
      a[o] < 0 && (a[o] += l), a[o] = md(0, a[o], i[o]);
    }
    return a;
  }
  function uZ(n, e, t) {
    let r = n[e];
    return (t & 1 << e || r == null) && (r = 1), r;
  }
  function cZ(n, e, t, r, i, a) {
    let s = e[i];
    const o = t[i] || 1;
    (n & 1 << i || a & 1 << i || s == null) && (o > 0 ? s = Number.MIN_SAFE_INTEGER : s = Number.MAX_SAFE_INTEGER);
    const l = r[i];
    return s < 0 && (s += l), s = md(0, s, l - 1), s;
  }
  function hZ(n, e, t, r, i, a) {
    let s = e[i];
    const o = t[i] || 1;
    (n & 1 << i || a & 1 << i || s == null) && (o > 0 ? s = Number.MAX_SAFE_INTEGER : s = Number.MIN_SAFE_INTEGER);
    const l = r[i];
    return s < 0 && (s += l), o > 0 ? s = md(0, s, l) : s = md(-1, s, l - 1), s;
  }
  function NI(n, e, t) {
    let r = t.length;
    for (let i = 0; i < t.length; i++) if (t[i] > 1) {
      r = i;
      break;
    }
    for (let i = r + 1; i < t.length; i++) if (e[i] > 0 || t[i] !== n[i]) return false;
    return true;
  }
  function EI(n, e) {
    let t = n.length > 0 ? n[n.length - 1] : 1;
    for (let r = 0; r < n.length - 1; r++) t += n[r] * e[r];
    return t;
  }
  function Av(n, e, t) {
    let r;
    const i = n.shape.length;
    typeof e == "number" ? r = [
      e,
      ...new Array(i - 1).fill(0)
    ] : e.length < i ? r = e.concat(new Array(i - e.length).fill(0)) : r = e.slice(), r.forEach((s) => {
      B(s !== -1, () => "slice() does not support negative begin indexing.");
    });
    let a;
    return t == null ? a = new Array(i).fill(-1) : typeof t == "number" ? a = [
      t,
      ...new Array(i - 1).fill(-1)
    ] : t.length < i ? a = t.concat(new Array(i - t.length).fill(-1)) : a = t, a = a.map((s, o) => s >= 0 ? s : (B(s === -1, () => `Negative size values should be exactly -1 but got ${s} for the slice() size at index ${o}.`), n.shape[o] - r[o])), [
      r,
      a
    ];
  }
  function Cb(n, e, t, r, i, a, s, o, l) {
    let u;
    if (r == null ? (u = new Array(e.length), u.fill(1)) : u = r, s != null && s & s - 1) throw new Error("Multiple ellipses in slice is not allowed.");
    let c = false;
    const h = {
      dims: u.length,
      numAddAxisAfterEllipsis: 0,
      begin: e.slice(),
      end: t.slice(),
      strides: u.slice(),
      beginMask: i,
      endMask: a,
      ellipsisMask: s,
      newAxisMask: o,
      shrinkAxisMask: l
    };
    for (let x = 0; x < h.dims; x++) c && 1 << x & o && h.numAddAxisAfterEllipsis++, 1 << x & s && (c = true);
    c || (h.ellipsisMask |= 1 << h.dims, h.dims++);
    const d = {
      dims: n.length,
      beginMask: 0,
      endMask: 0,
      beginValid: false,
      endValid: false
    };
    SMe(h, d);
    let f = true, p = true, g = true;
    const m = [], v = [];
    for (let x = 0; x < n.length; ++x) {
      if (d.strides[x] === 0) throw Error(`strides[${x}] must be non-zero`);
      const b = !!(d.shrinkAxisMask & 1 << x), w = n[x];
      if (w === -1) {
        m.push(b ? 1 : -1);
        continue;
      }
      const _ = [
        d.beginMask & 1 << x,
        d.endMask & 1 << x
      ], S = [
        d.strides[x] > 0 ? 0 : -1,
        d.strides[x] > 0 ? w : w - 1
      ];
      if (b && d.strides[x] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
      g = g && d.strides[x] === 1;
      const I = !!(d.beginMask & 1 << x && d.endMask & 1 << x);
      if (d.beginValid && d.endValid) {
        if (b) {
          const D = d.begin[x] < 0 ? w + d.begin[x] : d.begin[x];
          if (d.begin[x] = D, d.end[x] = d.begin[x] + 1, D < 0 || D >= w) throw Error(`slice index ${d.begin[x]} of dimension ${x} out of bounds.`);
        } else d.begin[x] = E4(d.begin[x], 0, d.strides[x], w, _, S), d.end[x] = E4(d.end[x], 1, d.strides[x], w, _, S);
        const k = d.strides[x] === 1 && d.begin[x] === 0 && d.end[x] === w;
        f = f && k, p = p && (x === 0 && d.strides[x] === 1 || k);
      } else f = f && d.strides[x] === 1 && I, p = p && (x === 0 && d.strides[x] === 1 || I);
      let C, T = false;
      if (d.beginValid && d.endValid ? (C = d.end[x] - d.begin[x], T = true) : b ? (C = 1, T = true) : I && w >= 0 && (d.strides[x] < 0 ? C = -w : C = w, T = true), T) {
        let k;
        C === 0 || C < 0 != d.strides[x] < 0 ? k = 0 : k = Math.trunc(C / d.strides[x]) + (C % d.strides[x] !== 0 ? 1 : 0), m.push(k);
      } else m.push(-1);
    }
    for (let x = 0; x < d.finalShapeGatherIndices.length; ++x) {
      const b = d.finalShapeGatherIndices[x];
      b >= 0 ? v.push(m[b]) : b === S$ && v.push(1);
    }
    return {
      finalShapeSparse: v.filter((x, b) => d.finalShapeGatherIndices[b] !== S$),
      finalShape: v,
      isIdentity: f,
      sliceDim0: p,
      isSimpleSlice: g,
      begin: d.begin,
      end: d.end,
      strides: d.strides
    };
  }
  function SMe(n, e) {
    e.beginMask = 0, e.endMask = 0, e.shrinkAxisMask = 0;
    let t = 0;
    e.beginValid = n.begin != null, e.endValid = n.end != null, e.begin = new Array(e.dims), e.end = new Array(e.dims), e.strides = new Array(e.dims), e.finalShapeGatherIndices = [], e.finalShapeGatherIndicesSparse = [], e.inputShapeGatherIndicesSparse = new Array(e.dims);
    for (let r = 0; r < n.dims; r++) if (1 << r & n.ellipsisMask) {
      const i = Math.min(e.dims - (n.dims - r) + 1 + n.numAddAxisAfterEllipsis, e.dims);
      for (; t < i; t++) e.begin[t] = 0, e.end[t] = 0, e.strides[t] = 1, e.beginMask |= 1 << t, e.endMask |= 1 << t, e.finalShapeGatherIndices.push(t), e.finalShapeGatherIndicesSparse.push(-1), e.inputShapeGatherIndicesSparse[t] = r;
    } else if (1 << r & n.newAxisMask) e.finalShapeGatherIndices.push(S$), e.finalShapeGatherIndicesSparse.push(-1);
    else {
      if (t === e.begin.length) throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);
      n.begin != null && (e.begin[t] = n.begin[r]), n.end != null && (e.end[t] = n.end[r]), e.strides[t] = n.strides[r], n.beginMask & 1 << r && (e.beginMask |= 1 << t), n.endMask & 1 << r && (e.endMask |= 1 << t), n.shrinkAxisMask & 1 << r ? (e.finalShapeGatherIndices.push(bMe), e.finalShapeGatherIndicesSparse.push(-1), e.shrinkAxisMask |= 1 << t) : (e.finalShapeGatherIndices.push(t), e.finalShapeGatherIndicesSparse.push(r)), e.inputShapeGatherIndicesSparse[t] = r, t++;
    }
  }
  function E4(n, e, t, r, i, a) {
    if (i[e]) return t > 0 ? a[e] : a[e + 1 & 1];
    {
      const s = n < 0 ? r + n : n;
      return s < a[0] ? a[0] : s > a[1] ? a[1] : s;
    }
  }
  const CMe = Object.freeze(Object.defineProperty({
    __proto__: null,
    assertParamsValid: $I,
    computeFlatOffset: EI,
    computeOutShape: Sb,
    getNormalizedAxes: _Me,
    isSliceContinous: NI,
    maskToAxes: wMe,
    parseSliceParams: Av,
    sliceInfo: Cb,
    startForAxis: cZ,
    startIndicesWithElidedDims: oZ,
    stopForAxis: hZ,
    stopIndicesWithElidedDims: lZ,
    stridesForAxis: uZ,
    stridesWithElidedDims: iZ
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class IMe {
    static sgd(e) {
      return new TP(e);
    }
    static momentum(e, t, r = false) {
      return new nZ(e, t, r);
    }
    static rmsprop(e, t = 0.9, r = 0, i = null, a = false) {
      return new rZ(e, t, r, i, a);
    }
    static adam(e = 1e-3, t = 0.9, r = 0.999, i = null) {
      return new eZ(e, t, r, i);
    }
    static adadelta(e = 1e-3, t = 0.95, r = null) {
      return new Q9(e, t, r);
    }
    static adamax(e = 2e-3, t = 0.9, r = 0.999, i = null, a = 0) {
      return new tZ(e, t, r, i, a);
    }
    static adagrad(e, t = 0.1) {
      return new J9(e, t);
    }
  }
  const Yp = IMe;
  const kMe = typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : (n) => n();
  function dZ() {
    return new Promise((n) => kMe(() => n()));
  }
  function Ib(n, e) {
    const t = n[0].length;
    n.forEach((i, a) => {
      B(i.length === t, () => `Error in concat${t}D: rank of tensors[${a}] must be the same as the rank of the rest (${t})`);
    }), B(e >= 0 && e < t, () => `Error in concat${t}D: axis must be between 0 and ${t - 1}.`);
    const r = n[0];
    n.forEach((i, a) => {
      for (let s = 0; s < t; s++) B(s === e || i[s] === r[s], () => `Error in concat${t}D: Shape of tensors[${a}] (${i}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`);
    });
  }
  function ai(n, e) {
    const t = n[0].slice();
    for (let r = 1; r < n.length; r++) t[e] += n[r][e];
    return t;
  }
  var Gs;
  (function(n) {
    n[n.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", n[n.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", n[n.ROW_LENGTHS = 2] = "ROW_LENGTHS", n[n.ROW_SPLITS = 3] = "ROW_SPLITS", n[n.ROW_LIMITS = 4] = "ROW_LIMITS", n[n.ROW_STARTS = 5] = "ROW_STARTS";
  })(Gs || (Gs = {}));
  function fZ(n, e, t) {
    let r = new Array();
    if (t == null && e == null) return r;
    if (e == null) for (; r.length < n + t.length; ) r.push(-1);
    else r = e.slice();
    if (t == null) return r;
    if (n + t.length !== r.length) throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n + t.length}, but shape.rank = ${r.length}`);
    for (let i = 1; i < t.length; ++i) {
      const a = t[i], s = r[r.length - t.length + i], o = r[s];
      if (a >= 0) if (o >= 0) {
        if (o !== a) throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i + n}] = ${a} but shape[${i + n}] = ${o}`);
      } else r[s] = a;
    }
    return r;
  }
  function pZ(n) {
    const e = {
      FIRST_DIM_SIZE: Gs.FIRST_DIM_SIZE,
      VALUE_ROWIDS: Gs.VALUE_ROWIDS,
      ROW_LENGTHS: Gs.ROW_LENGTHS,
      ROW_SPLITS: Gs.ROW_SPLITS,
      ROW_LIMITS: Gs.ROW_LIMITS,
      ROW_STARTS: Gs.ROW_STARTS
    }, t = [];
    for (const r of n) if (r in e) t.push(e[r]);
    else break;
    return t;
  }
  function gZ(n) {
    return n.length === 0 ? 0 : n[0] === Gs.FIRST_DIM_SIZE ? n.length - 1 : n.length;
  }
  function mZ(n, e) {
    if (n == null || e == null) return;
    const t = n.length, r = e.length;
    if (t >= r) throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);
    for (let i = 0; i < Math.min(t, r - 1); ++i) {
      const a = n[i], s = e[i + 1];
      if (a >= 0 && s >= 0 && a !== 1 && a !== s) throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i - n.length}] = ${a} but ragged tensor input.flatValues.shape[${i - n.length}] = ${s}`);
    }
  }
  const AP = 30;
  function MI(n) {
    return n <= AP ? n : u$(n, Math.floor(Math.sqrt(n)));
  }
  function kb(n, e, t) {
    const r = t * (typeof n == "number" ? n : n[0]), i = e * (typeof n == "number" ? n : n[1]);
    return [
      r,
      i
    ];
  }
  function ou(n, e, t, r = true) {
    let i = [];
    if (r) i = i.concat(e.slice(0)), i.push(n[0] / t), i = i.concat(n.slice(1));
    else {
      i = i.concat(n[0]);
      const a = e.length;
      for (let s = 0; s < a; ++s) i = i.concat([
        n[s + 1] / e[s],
        e[s]
      ]);
      i = i.concat(n.slice(a + 1));
    }
    return i;
  }
  function lu(n, e, t = true) {
    const r = [];
    if (t) {
      r.push(e);
      for (let i = e + 1; i < n; ++i) i <= 2 * e ? (r.push(i), r.push(i - (e + 1))) : r.push(i);
    } else {
      const i = [], a = [];
      for (let s = 1; s < n; ++s) s >= e * 2 + 1 || s % 2 === 1 ? a.push(s) : i.push(s);
      r.push(...i), r.push(0), r.push(...a);
    }
    return r;
  }
  function uu(n, e, t, r = true) {
    const i = [];
    r ? i.push(n[0] / t) : i.push(n[0] * t);
    for (let a = 1; a < n.length; ++a) a <= e.length ? r ? i.push(e[a - 1] * n[a]) : i.push(n[a] / e[a - 1]) : i.push(n[a]);
    return i;
  }
  function Tb(n, e) {
    const t = [
      0
    ];
    for (let r = 0; r < e; ++r) t.push(n[r][0]);
    return t;
  }
  function Ab(n, e, t) {
    const r = n.slice(0, 1);
    for (let i = 0; i < t; ++i) r.push(n[i + 1] - e[i][0] - e[i][1]);
    return r;
  }
  const Db = 1.7580993408473768, Rb = 1.0507009873554805;
  const PI = 0.3275911, LI = 0.254829592, FI = -0.284496736, OI = 1.421413741, BI = -1.453152027, zI = 1.061405429;
  function ao(n, e) {
    if (n.length !== e.length) throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);
    const t = new Float32Array(n.length * 2);
    for (let r = 0; r < t.length; r += 2) t[r] = n[r / 2], t[r + 1] = e[r / 2];
    return t;
  }
  function vZ(n) {
    const e = new Float32Array(n.length / 2), t = new Float32Array(n.length / 2);
    for (let r = 0; r < n.length; r += 2) e[r / 2] = n[r], t[r / 2] = n[r + 1];
    return {
      real: e,
      imag: t
    };
  }
  function yZ(n) {
    const e = Math.ceil(n.length / 4), t = new Float32Array(e), r = new Float32Array(e);
    for (let i = 0; i < n.length; i += 4) t[Math.floor(i / 4)] = n[i], r[Math.floor(i / 4)] = n[i + 1];
    return {
      real: t,
      imag: r
    };
  }
  function xZ(n) {
    const e = Math.floor(n.length / 4), t = new Float32Array(e), r = new Float32Array(e);
    for (let i = 2; i < n.length; i += 4) t[Math.floor(i / 4)] = n[i], r[Math.floor(i / 4)] = n[i + 1];
    return {
      real: t,
      imag: r
    };
  }
  function DP(n, e) {
    const t = n[e * 2], r = n[e * 2 + 1];
    return {
      real: t,
      imag: r
    };
  }
  function bZ(n, e, t, r) {
    n[r * 2] = e, n[r * 2 + 1] = t;
  }
  function wZ(n, e) {
    const t = new Float32Array(n / 2), r = new Float32Array(n / 2);
    for (let i = 0; i < Math.ceil(n / 2); i++) {
      const a = (e ? 2 : -2) * Math.PI * (i / n);
      t[i] = Math.cos(a), r[i] = Math.sin(a);
    }
    return {
      real: t,
      imag: r
    };
  }
  function _Z(n, e, t) {
    const r = (t ? 2 : -2) * Math.PI * (n / e), i = Math.cos(r), a = Math.sin(r);
    return {
      real: i,
      imag: a
    };
  }
  const lA = "->", TMe = /->/g, M4 = ",", P4 = "...";
  function VI(n, e) {
    n = n.replace(/\s/g, "");
    const t = (n.length - n.replace(TMe, "").length) / lA.length;
    if (t < 1) throw new Error("Equations without an arrow are not supported.");
    if (t > 1) throw new Error(`Equation must contain exactly one arrow ("${lA}").`);
    const [r, i] = n.split(lA);
    B(r.indexOf(P4) === -1, () => `The ellipsis notation ("${P4}") is not supported yet.`);
    const a = r.split(M4), s = a.length;
    if (e !== s) throw new Error(`Expected ${s} input tensors, received ${e}`);
    if (s > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
    const o = [];
    for (let d = 0; d < i.length; ++d) {
      const f = i[d];
      if (!a.some((p) => p.indexOf(f) !== -1)) throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);
      o.indexOf(f) === -1 && o.push(f);
    }
    for (let d = 0; d < r.length; ++d) {
      const f = r[d];
      o.indexOf(f) === -1 && f !== M4 && o.push(f);
    }
    const l = new Array(a.length);
    for (let d = 0; d < s; ++d) {
      if (new Set(a[d].split("")).size !== a[d].length) throw new Error(`Found duplicate axes in input component ${a[d]}. Support for duplicate axes in input is not implemented yet.`);
      l[d] = [];
      for (let f = 0; f < a[d].length; ++f) l[d].push(o.indexOf(a[d][f]));
    }
    const u = o.length, c = i.length, h = [];
    for (let d = c; d < u; ++d) h.push(d);
    return {
      allDims: o,
      summedDims: h,
      idDims: l
    };
  }
  function WI(n, e) {
    let t = new Array(n);
    t.fill(-1);
    for (let i = 0; i < e.length; ++i) t[e[i]] = i;
    const r = [];
    for (let i = 0; i < n; ++i) t[i] === -1 && r.push(i);
    return t = t.filter((i) => i !== -1), {
      permutationIndices: t,
      expandDims: r
    };
  }
  function GI(n, e, t) {
    const r = new Array(n);
    for (let i = 0; i < t.length; ++i) {
      const a = t[i].shape;
      for (let s = 0; s < e[i].length; ++s) r[e[i][s]] === void 0 ? r[e[i][s]] = a[s] : B(r[e[i][s]] === a[s], () => `Expected dimension ${r[e[i][s]]} at axis ${s} of input shaped ${JSON.stringify(a)}, but got dimension ${a[s]}`);
    }
  }
  function UI(n, e) {
    const t = n, r = [];
    let i = 0;
    n.length === 0 && t.push(-1), i = n.length + 1;
    for (let s = 0; s < i; ++s) r.push([]);
    const a = [];
    for (let s = 0; s < t.length; ++s) {
      const o = t[s], l = AMe(e, o);
      for (const u of l) a.indexOf(u) === -1 && (r[s].push(u), a.push(u));
    }
    return {
      path: t,
      steps: r
    };
  }
  function HI(n) {
    return n.every((e, t) => e === t);
  }
  function AMe(n, e) {
    const t = [];
    for (let r = 0; r < n.length; ++r) (n[r].length === 0 || n[r].indexOf(e) !== -1 || e === -1) && t.push(r);
    return t;
  }
  function $b(n, e, t = 0) {
    let r = [];
    if (typeof e == "number") B(n.shape[t] % e === 0, () => "Number of splits must evenly divide the axis."), r = new Array(e).fill(n.shape[t] / e);
    else {
      const i = e.reduce((s, o) => (o === -1 && (s += 1), s), 0);
      B(i <= 1, () => "There should be only one negative value in split array.");
      const a = e.indexOf(-1);
      if (a !== -1) {
        const s = e.reduce((o, l) => l > 0 ? o + l : o);
        e[a] = n.shape[t] - s;
      }
      B(n.shape[t] === e.reduce((s, o) => s + o), () => "The sum of sizes must match the size of the axis dimension."), r = e;
    }
    return r;
  }
  function RP(n) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`;
  }
  function $P(n, e) {
    return `indices(${n}, 0) is invalid: ${e} < 0`;
  }
  function NP(n, e, t) {
    return `indices(${n}, 0) is invalid: ${e} >= ${t}`;
  }
  function EP(n, e) {
    return `only one output dimension may be -1, not both ${n} and ${e}`;
  }
  function MP(n, e) {
    return `size ${n} must be non-negative, not ${e}`;
  }
  function PP() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
  }
  function LP(n, e) {
    const t = X(n), r = X(e);
    return `Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`;
  }
  function FP(n, e) {
    const t = X(n), r = X(e);
    return `Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`;
  }
  function lx() {
    return "segment ids must be >= 0";
  }
  function OP() {
    return "segment ids are not increasing";
  }
  function BP(n, e) {
    return `Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`;
  }
  function zP(n, e, t) {
    return `Bad: indices[${n}] == ${e} out of range [0, ${t})`;
  }
  function SZ(n, e) {
    let t = false, r;
    for (n <= AP ? (r = n, t = true) : r = u$(n, Math.floor(Math.sqrt(n))); !t; ) r > e || r === n ? t = true : r = u$(n, r + 1);
    return r;
  }
  function VP(n, e, t) {
    const r = [], i = n.length;
    for (let a = 0; a < i; a++) a !== e ? r.push(n[a]) : r.push(t);
    return r;
  }
  function Nb(n, e, t, r) {
    const i = e.shape.length, a = n.shape.length;
    if (r !== 0 && (r < -i || r > i)) throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);
    if (r < 0 && (r += i), r > a) throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);
    if (t < r) throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);
    for (let h = 0; h < r; ++h) if (n.shape[h] !== e.shape[h]) throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);
    const s = n.shape[t], o = [];
    let l = 1, u = 1, c = 1;
    for (let h = 0; h < r; ++h) o.push(n.shape[h]), l *= n.shape[h];
    for (let h = r; h < t; h++) o.push(n.shape[h]), u *= n.shape[h];
    for (let h = r; h < i; h++) o.push(e.shape[h]);
    for (let h = t + 1; h < a; h++) o.push(n.shape[h]), c *= n.shape[h];
    return {
      batchSize: l,
      sliceSize: c,
      outerSize: u,
      dimSize: s,
      outputShape: o
    };
  }
  const DMe = Object.freeze(Object.defineProperty({
    __proto__: null,
    collectGatherOpShapeInfo: Nb,
    computeOutShape: VP,
    segOpComputeOptimalWindowSize: SZ
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function so(n) {
    try {
      return n.map((e) => io(e));
    } catch (e) {
      throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`);
    }
  }
  function WP(n) {
    return n.map((e) => Bl(e));
  }
  const RMe = Object.freeze(Object.defineProperty({
    __proto__: null,
    ERF_A1: LI,
    ERF_A2: FI,
    ERF_A3: OI,
    ERF_A4: BI,
    ERF_A5: zI,
    ERF_P: PI,
    PARALLELIZE_THRESHOLD: AP,
    get RowPartitionType() {
      return Gs;
    },
    SELU_SCALE: Rb,
    SELU_SCALEALPHA: Db,
    applyActivation: SP,
    assertAndGetBroadcastShape: ht,
    assertAxesAreInnerMostDims: Tn,
    assertParamsConsistent: Ib,
    assignToTypedArray: bZ,
    axesAreInnerMostDims: sP,
    calculateShapes: Ka,
    checkEinsumDimSizes: GI,
    checkPadOnDimRoundingMode: la,
    combineLocations: A9,
    combineRaggedTensorToTensorShapes: fZ,
    complexWithEvenIndex: yZ,
    complexWithOddIndex: xZ,
    computeConv2DInfo: Sn,
    computeConv3DInfo: Ra,
    computeDefaultPad: eP,
    computeDilation2DInfo: po,
    computeOptimalWindowSize: MI,
    computeOutAndReduceShapes: Ln,
    computeOutShape: ai,
    computePool2DInfo: dr,
    computePool3DInfo: vi,
    convertConv2DDataFormat: Oi,
    decodeEinsumEquation: VI,
    eitherStridesOrDilationsAreOne: Pr,
    expandShapeToKeepDim: Mn,
    exponent: _Z,
    exponents: wZ,
    fromStringArrayToUint8: WP,
    fromUint8ToStringArray: so,
    getAxesPermutation: bn,
    getBroadcastDims: lc,
    getComplexWithIndex: DP,
    getEinsumComputePath: UI,
    getEinsumPermutation: WI,
    getFusedBiasGradient: _P,
    getFusedDyActivation: wP,
    getImageCenter: kb,
    getInnerMostAxes: gn,
    getPermuted: lu,
    getRaggedRank: gZ,
    getReductionAxes: Mr,
    getReshaped: ou,
    getReshapedPermuted: uu,
    getRowPartitionTypesHelper: pZ,
    getSliceBeginCoords: Tb,
    getSliceSize: Ab,
    getSparseFillEmptyRowsIndicesDenseShapeMismatch: RP,
    getSparseFillEmptyRowsNegativeIndexErrorMessage: $P,
    getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: NP,
    getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: PP,
    getSparseReshapeInputOutputMismatchErrorMessage: FP,
    getSparseReshapeInputOutputMultipleErrorMessage: LP,
    getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: EP,
    getSparseReshapeNegativeOutputDimErrorMessage: MP,
    getSparseSegmentReductionIndicesOutOfRangeErrorMessage: zP,
    getSparseSegmentReductionNegativeSegmentIdsErrorMessage: lx,
    getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: OP,
    getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: BP,
    getUndoAxesPermutation: As,
    isIdentityPermutation: HI,
    log: hAe,
    mergeRealAndImagArrays: ao,
    prepareAndValidate: _b,
    prepareSplitSize: $b,
    segment_util: DMe,
    shouldFuse: CP,
    slice_util: CMe,
    splitRealAndImagArrays: vZ,
    stridesOrDilationsArePositive: _d,
    tupleValuesAreOne: wd,
    upcastType: qr,
    validateDefaultValueShape: mZ,
    validateInput: oEe,
    validateUpdateShape: X9,
    warn: Fa
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  xMe();
  const CZ = {
    kernelName: Dm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(n, wb(Ve(t, "float32"), -1))
      };
    }
  };
  const $Me = {
    kernelName: Wd,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => {
          const r = Xn(Ve(t, "float32")), i = mi(wt(yn(1), r));
          return cr(gt(n, i));
        }
      };
    }
  };
  const NMe = {
    kernelName: Gd,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => {
          const r = mi(wt(Xn(Ve(t, "float32")), 1));
          return gt(n, r);
        }
      };
    }
  };
  const EMe = {
    kernelName: xc,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = ht(t.shape, r.shape);
      return {
        a: () => {
          let o = n;
          const l = Mr(t.shape, i);
          return l.length > 0 && (o = ct(o, l)), ee(o, t.shape);
        },
        b: () => {
          let o = n;
          const l = Mr(r.shape, i);
          return l.length > 0 && (o = ct(o, l)), ee(o, r.shape);
        }
      };
    }
  };
  const MMe = {
    kernelName: Rm,
    saveAllInputs: true,
    gradFunc: (n, e) => {
      const t = {};
      return e.forEach((r, i) => {
        t[i] = () => n.clone();
      }), t;
    }
  };
  const PMe = {
    kernelName: Em,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => un(t)
      };
    }
  };
  const LMe = {
    kernelName: Mm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => un(t)
      };
    }
  };
  const FMe = {
    kernelName: Ud,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => gt(n, mi(wt(yn(1), Xn(Ve(t, "float32")))))
      };
    }
  };
  const OMe = {
    kernelName: Hd,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => {
          const r = mi(Ce(yn(1), Xn(Ve(t, "float32"))));
          return gt(n, r);
        }
      };
    }
  };
  const BMe = {
    kernelName: qd,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = ht(t.shape, r.shape);
      return {
        a: () => {
          const o = Ce(Xn(t), Xn(r));
          let l = Z(n, gt(r, o));
          const u = Mr(t.shape, i);
          return u.length > 0 && (l = ct(l, u)), ee(l, t.shape);
        },
        b: () => {
          const o = Ce(Xn(t), Xn(r));
          let l = cr(Z(n, gt(t, o)));
          const u = Mr(r.shape, i);
          return u.length > 0 && (l = ct(l, u)), ee(l, r.shape);
        }
      };
    }
  };
  const zMe = {
    kernelName: Xd,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => gt(n, Ce(Xn(Ve(t, "float32")), 1))
      };
    }
  };
  const VMe = {
    kernelName: Yd,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => gt(n, wt(yn(1), Xn(Ve(t, "float32"))))
      };
    }
  };
  function WMe(n, e, t, r, i, a) {
    const s = U(n, "dy", "avgPool3dGrad"), o = U(e, "input", "avgPool3dGrad");
    let l = s, u = o, c = false;
    o.rank === 4 && (c = true, l = ee(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2],
      s.shape[3]
    ]), u = ee(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2],
      o.shape[3]
    ])), B(l.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`), B(u.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`), la("avgPool3dGrad", i, a);
    const h = {
      dy: l,
      input: u
    }, d = {
      filterSize: t,
      strides: r,
      pad: i,
      dimRoundingMode: a
    }, f = Q.runKernel(eb, h, d);
    return c ? ee(f, [
      f.shape[1],
      f.shape[2],
      f.shape[3],
      f.shape[4]
    ]) : f;
  }
  const GMe = te({
    avgPool3dGrad_: WMe
  });
  const UMe = {
    kernelName: Pm,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { filterSize: i, strides: a, pad: s, dimRoundingMode: o } = t;
      return {
        x: () => GMe(n, r, i, a, s, o)
      };
    }
  };
  function HMe(n, e, t, r, i) {
    const a = U(n, "dy", "avgPoolGrad"), s = U(e, "input", "avgPoolGrad");
    B(s.rank === a.rank, () => `Rank of input (${s.rank}) does not match rank of dy (${a.rank})`);
    let o = s, l = a, u = false;
    s.rank === 3 && (u = true, o = ee(s, [
      1,
      s.shape[0],
      s.shape[1],
      s.shape[2]
    ]), l = ee(a, [
      1,
      a.shape[0],
      a.shape[1],
      a.shape[2]
    ])), B(l.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`), B(o.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);
    const c = {
      dy: l,
      input: o
    }, h = {
      filterSize: t,
      strides: r,
      pad: i
    }, d = Q.runKernel(Jx, c, h);
    return u ? ee(d, [
      d.shape[1],
      d.shape[2],
      d.shape[3]
    ]) : d;
  }
  const XMe = te({
    avgPoolGrad_: HMe
  });
  const YMe = {
    kernelName: jd,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { filterSize: i, strides: a, pad: s } = t;
      return {
        x: () => XMe(n, r, i, a, s)
      };
    }
  };
  const qMe = {
    kernelName: Kd,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e, t) => {
      const [r, i] = e, { transposeA: a, transposeB: s } = t;
      return !a && !s ? {
        a: () => mn(n, i, false, true),
        b: () => mn(r, n, true, false)
      } : !a && s ? {
        a: () => mn(n, i, false, false),
        b: () => mn(n, r, true, false)
      } : a && !s ? {
        a: () => mn(i, n, false, true),
        b: () => mn(r, n, false, false)
      } : {
        a: () => mn(i, n, true, true),
        b: () => mn(n, r, true, true)
      };
    }
  };
  const jMe = {
    kernelName: Lm,
    gradFunc: (n, e, t) => {
      const { blockShape: r, crops: i } = t;
      return {
        x: () => pP(n, r, i)
      };
    }
  };
  const KMe = {
    kernelName: lAe,
    gradFunc: (n, e, t) => {
      const r = t, i = r.inputShape, a = r.shape, s = Array.from(a);
      for (let l = i.length - 1; l >= 0; l--) if (i[l] === a[l]) s[l] = 1;
      else if (i[l] !== 1) throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${a}].`);
      const o = [];
      for (let l = 0; l < s.length; l++) s[l] > 1 && o.push(l);
      return {
        x: () => ct(n, o, true)
      };
    }
  };
  const ZMe = {
    kernelName: Zd,
    gradFunc: (n) => ({
      x: () => n.clone()
    })
  };
  const QMe = {
    kernelName: Qd,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const JMe = {
    kernelName: bc,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { clipValueMin: i, clipValueMax: a } = t;
      return {
        x: () => Ni(eu(op(r, i), Iv(r, a)), n, un(n))
      };
    }
  };
  const ePe = {
    kernelName: tb,
    inputsToSave: [
      "x"
    ],
    gradFunc: CZ.gradFunc
  };
  const tPe = {
    kernelName: Om,
    saveAllInputs: true,
    gradFunc: (n, e, t) => {
      const r = e.map((l) => l.shape), { axis: i } = t, a = yt(i, e[0].shape)[0], s = r.map((l) => l[a]);
      return Ga(n, s, a).map((l) => () => l);
    }
  };
  const nPe = {
    kernelName: Jd,
    inputsToSave: [
      "x",
      "filter"
    ],
    gradFunc: (n, e, t) => {
      const [r, i] = e, { dilations: a, strides: s, pad: o, dataFormat: l } = t;
      return B(wd(a), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`), {
        x: () => rP(r.shape, n, i, s, o, l),
        filter: () => bP(r, n, i.shape, s, o, l)
      };
    }
  };
  const rPe = {
    kernelName: ef,
    inputsToSave: [
      "dy",
      "filter"
    ],
    gradFunc: (n, e, t) => {
      const [r, i] = e, { strides: a, pad: s, dataFormat: o, dimRoundingMode: l } = t;
      return {
        dy: () => Sd(n, i, a, s, o, 1, l),
        filter: () => bP(n, r, i.shape, a, s, o, l)
      };
    }
  };
  function iPe(n, e, t, r, i) {
    let a = n;
    n.rank === 4 && (a = ee(n, [
      1,
      n.shape[0],
      n.shape[1],
      n.shape[2],
      n.shape[3]
    ]));
    let s = e;
    s.rank === 4 && (s = ee(e, [
      1,
      e.shape[0],
      e.shape[1],
      e.shape[2],
      e.shape[3]
    ])), B(a.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`), B(s.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${s.shape}.`), B(t.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`), B(a.shape[4] === t[3], () => `Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${t[3]}.`), B(s.shape[4] === t[4], () => `Error in conv3dDerFilter: depth of dy (${s.shape[4]}) must match output depth for filter (${t[4]}).`);
    const o = {
      x: a,
      dy: s
    }, l = {
      strides: r,
      pad: i,
      filterShape: t
    };
    return Q.runKernel(Bm, o, l);
  }
  const aPe = te({
    conv3DBackpropFilter_: iPe
  });
  const sPe = {
    kernelName: tf,
    inputsToSave: [
      "x",
      "filter"
    ],
    gradFunc: (n, e, t) => {
      const { dilations: r, strides: i, pad: a } = t;
      B(wd(r), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);
      const [s, o] = e;
      return {
        x: () => C9(s.shape, n, o, i, a),
        filter: () => aPe(s, n, o.shape, i, a)
      };
    }
  };
  const oPe = {
    kernelName: nf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(cr(W9(Ve(t, "float32"))), n)
      };
    }
  };
  const lPe = {
    kernelName: rf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(G9(Ve(t, "float32")), n)
      };
    }
  };
  const uPe = {
    kernelName: af,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { axis: i, exclusive: a, reverse: s } = t;
      return {
        x: () => {
          const o = bn([
            i
          ], r.rank);
          let l = k9(n, i, a, !s);
          return o != null && (l = ln(l, o)), l;
        }
      };
    }
  };
  const cPe = {
    kernelName: sf,
    inputsToSave: [
      "x",
      "filter"
    ],
    gradFunc: (n, e, t) => {
      const { dilations: r, strides: i, pad: a, dimRoundingMode: s } = t, o = r ?? [
        1,
        1
      ];
      B(wd(o), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);
      const [l, u] = e;
      return B(l.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`), B(u.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`), B(l.shape[3] === u.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`), B(Pr(i, o), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`), la("depthwiseConv2d", a, s), {
        x: () => kEe(l.shape, n, u, i, a, o, s),
        filter: () => CEe(l, n, u.shape, i, a, o, s)
      };
    }
  };
  const hPe = {
    kernelName: of,
    inputsToSave: [
      "x",
      "filter"
    ],
    gradFunc: (n, e, t) => {
      const [r, i] = e, a = {
        x: r,
        filter: i,
        dy: n
      }, s = {
        x: r,
        filter: i,
        dy: n
      };
      return {
        x: () => Q.runKernel(Xg, a, t),
        filter: () => Q.runKernel(Yg, s, t)
      };
    }
  };
  const dPe = {
    kernelName: uf,
    outputsToSave: [
      true
    ],
    gradFunc: (n, e) => {
      const [t] = e, r = {
        dy: n,
        y: t
      };
      return {
        x: () => Q.runKernel(Um, r)
      };
    }
  };
  const fPe = {
    kernelName: cf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e, r = Z(il(cr(Xn(t))), 2 / Math.sqrt(Math.PI));
      return {
        x: () => Z(n, r)
      };
    }
  };
  const pPe = {
    kernelName: hf,
    outputsToSave: [
      true
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(n, t)
      };
    }
  };
  const gPe = {
    kernelName: Xm,
    inputsToSave: [
      "input"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        input: () => ee(n, t.shape)
      };
    }
  };
  const mPe = {
    kernelName: df,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(n, il(t))
      };
    }
  };
  const vPe = {
    kernelName: ff,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const yPe = {
    kernelName: pf,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = ht(t.shape, r.shape);
      return {
        a: () => {
          const o = gt(n, Ve(r, "float32")), l = Mr(t.shape, i);
          return l.length > 0 ? ee(ct(o, l), t.shape) : o;
        },
        b: () => {
          let o = Z(n, Ve(t, "float32"));
          const l = Mr(r.shape, i);
          l.length > 0 && (o = ee(ct(o, l), r.shape));
          const u = Xn(r);
          return cr(gt(o, Ve(u, "float32")));
        }
      };
    }
  };
  const xPe = {
    kernelName: gf,
    inputsToSave: [
      "x",
      "mean",
      "variance",
      "scale"
    ],
    gradFunc: (n, e, t) => {
      const { varianceEpsilon: r } = t, [i, a, s, o] = e, l = o ?? yn(1), u = Mr(a.shape, i.shape), c = [];
      if (a.rank === 1) {
        for (let b = 0; b < i.shape.length - 1; ++b) c.push(i.shape[b]);
        c.push(1);
      }
      const h = wt(i, a), d = Z(n, l), f = B9(Ce(s, yn(r))), p = Z(Z(Z(f, f), f), yn(-0.5));
      return {
        x: () => a.rank === 1 ? ee(Z(Z(n, Ys(ee(f, [
          1,
          1,
          1,
          a.shape[0]
        ]), c)), l), i.shape) : ee(Z(Z(n, f), l), i.shape),
        mean: () => {
          let b = Z(Z(f, yn(-1)), d);
          return a.rank === 1 && (b = ct(b, u)), ee(b, a.shape);
        },
        variance: () => {
          let b = Z(Z(p, h), d);
          return a.rank === 1 && (b = ct(b, u)), ee(b, a.shape);
        },
        scale: () => {
          const b = Z(h, f);
          let w = Z(n, b);
          return a.rank === 1 && (w = ct(w, u)), ee(w, a.shape);
        },
        offset: () => {
          let b = n;
          return a.rank === 1 && (b = ct(b, u)), ee(b, a.shape);
        }
      };
    }
  };
  const bPe = {
    kernelName: qm,
    inputsToSave: [
      "x",
      "indices"
    ],
    gradFunc: (n, e, t) => {
      const [r, i] = e, { axis: a, batchDims: s } = t, o = yt(a, r.shape)[0], l = (u, c, h) => () => {
        const d = u.shape, f = c.size, p = d.slice(0, o), g = p.length, m = d.slice(a, d.length).slice(1), v = m.length, y = L4(0, g), x = L4(g + 1, g + 1 + v), b = F4([
          p,
          [
            f
          ],
          m
        ]), w = ee(h, b), _ = ee(c, [
          f
        ]), S = F4([
          [
            g
          ],
          y,
          x
        ]), I = ln(w, S);
        let C = q9(I, _, u.shape[o]);
        const T = As(S);
        return C = ln(C, T), C;
      };
      if (s === 1) {
        const u = r.shape[0], c = r.split(u, 0);
        return {
          x: () => tu(c.map((f, p) => l(f, i.slice(p, 1), n.slice(p, 1))())).reshape(r.shape),
          indices: () => i
        };
      } else return {
        x: l(r, i, n),
        indices: () => i
      };
    }
  };
  function L4(n, e) {
    const t = [];
    for (let r = n; r < e; ++r) t.push(r);
    return t;
  }
  function F4(n) {
    const e = [];
    for (let t = 0; t < n.length; ++t) for (let r = 0; r < n[t].length; ++r) e.push(n[t][r]);
    return e;
  }
  const wPe = {
    kernelName: mf,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e;
      return {
        a: () => un(t),
        b: () => un(r)
      };
    }
  };
  const _Pe = {
    kernelName: vf,
    gradFunc: (n) => ({
      x: () => Ve(n, "float32")
    })
  };
  const SPe = {
    kernelName: yf,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const CPe = {
    kernelName: xf,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const IPe = {
    kernelName: bf,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const kPe = {
    kernelName: wf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { alpha: i } = t, a = ja(r, 0);
      return {
        x: () => Ni(a, n, Z(n, i))
      };
    }
  };
  const TPe = {
    kernelName: Sf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => gt(n, Ce(t, 1))
      };
    }
  };
  const APe = {
    kernelName: _f,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => gt(n, Ve(t, "float32"))
      };
    }
  };
  const DPe = {
    kernelName: cAe,
    inputsToSave: [],
    outputsToSave: [
      true
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { axis: i } = t;
      return {
        logits: () => {
          const s = il(r);
          return wt(n, Z(ct(n, i, true), s));
        }
      };
    }
  };
  function RPe(n, e, t, r = 5, i = 1, a = 1, s = 0.5) {
    const o = {
      x: n,
      y: e,
      dy: t
    }, l = {
      depthRadius: r,
      bias: i,
      alpha: a,
      beta: s
    };
    return Q.runKernel(tv, o, l);
  }
  const $Pe = te({
    localResponseNormalizationBackprop_: RPe
  });
  const NPe = {
    kernelName: Cf,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, e, t) => {
      const [r, i] = e, { depthRadius: a, bias: s, alpha: o, beta: l } = t;
      return {
        x: () => $Pe(r, i, n, a, s, o, l)
      };
    }
  };
  function IZ(n, e, t, r) {
    return e.rank < t.rank && (e = ee(e, Mn(e.shape, r))), n.rank < t.rank && (n = ee(n, Mn(n.shape, r))), {
      x: () => Z(n, Ve(rl(t, e), n.dtype))
    };
  }
  const O4 = {
    kernelName: If,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, e, t) => {
      const r = t, { reductionIndices: i } = r, a = e[0], s = e[1], o = yt(i, a.shape), l = IZ(n, s, a, o);
      return {
        x: () => l.x()
      };
    }
  };
  const EPe = {
    kernelName: kf,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e;
      return {
        a: () => Z(n, Ve(op(t, r), "float32")),
        b: () => Z(n, Ve($S(t, r), "float32"))
      };
    }
  };
  function MPe(n, e, t, r, i, a, s) {
    const o = U(n, "dy", "maxPool3dGrad"), l = U(e, "input", "maxPool3dGrad"), u = U(t, "output", "maxPool3dGrad");
    let c = o, h = l, d = u, f = false;
    l.rank === 4 && (f = true, c = ee(o, [
      1,
      o.shape[0],
      o.shape[1],
      o.shape[2],
      o.shape[3]
    ]), h = ee(l, [
      1,
      l.shape[0],
      l.shape[1],
      l.shape[2],
      l.shape[3]
    ]), d = ee(u, [
      1,
      u.shape[0],
      u.shape[1],
      u.shape[2],
      u.shape[3]
    ])), B(c.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`), B(h.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`), B(d.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`), la("maxPool3dGrad", a, s);
    const p = {
      dy: c,
      input: h,
      output: d
    }, g = {
      filterSize: r,
      strides: i,
      pad: a,
      dimRoundingMode: s
    }, m = Q.runKernel(ob, p, g);
    return f ? ee(m, [
      m.shape[1],
      m.shape[2],
      m.shape[3],
      m.shape[4]
    ]) : m;
  }
  const PPe = te({
    maxPool3dGrad_: MPe
  });
  const LPe = {
    kernelName: nv,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, e, t) => {
      const [r, i] = e, { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = t;
      return {
        x: () => PPe(n, r, i, a, s, o, l)
      };
    }
  };
  function FPe(n, e, t, r, i, a, s) {
    const o = U(n, "dy", "maxPoolGrad"), l = U(e, "input", "maxPoolGrad"), u = U(t, "output", "maxPoolGrad");
    B(l.rank === o.rank, () => `Rank of input (${l.rank}) does not match rank of dy (${o.rank})`), B(o.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`), B(l.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`), la("maxPoolGrad", a, s);
    const c = {
      dy: o,
      input: l,
      output: u
    }, h = {
      filterSize: r,
      strides: i,
      pad: a,
      dimRoundingMode: s
    };
    return Q.runKernel(sb, c, h);
  }
  const OPe = te({
    maxPoolGrad_: FPe
  });
  const BPe = {
    kernelName: Tf,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, e, t) => {
      const [r, i] = e, { filterSize: a, strides: s, pad: o } = t;
      return {
        x: () => OPe(n, r, i, a, s, o)
      };
    }
  };
  const zPe = {
    kernelName: Af,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { axis: i } = t, a = yt(i, r.shape), o = Ln(r.shape, a)[1], l = X(o);
      return {
        x: () => {
          const c = r.shape.slice();
          a.forEach((f) => {
            c[f] = 1;
          });
          const h = ee(n, c);
          return gt(Z(h, Ic(r.shape, "float32")), l);
        }
      };
    }
  };
  const VPe = {
    kernelName: Df,
    inputsToSave: [
      "x"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, e, t) => {
      const r = t, { axis: i } = r, [a, s] = e, o = yt(i, a.shape), l = IZ(n, s, a, o);
      return {
        x: () => l.x()
      };
    }
  };
  const WPe = {
    kernelName: Rf,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e;
      return {
        a: () => Z(n, Ve(Iv(t, r), "float32")),
        b: () => Z(n, Ve(ja(t, r), "float32"))
      };
    }
  };
  const GPe = {
    kernelName: $f,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const r = e[0], { paddings: i } = t, a = i.map((s) => s[0]);
      return {
        x: () => Wn(n, a, r.shape)
      };
    }
  };
  const UPe = {
    kernelName: Nf,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = ht(t.shape, r.shape);
      return {
        a: () => {
          const o = Mr(t.shape, i);
          return o.length > 0 ? ee(ct(n, o), t.shape) : n;
        },
        b: () => {
          const o = Z(n, cr(AI(gt(t, r)))), l = Mr(r.shape, i);
          return l.length > 0 ? ee(ct(o, l), r.shape) : o;
        }
      };
    }
  };
  const HPe = {
    kernelName: Ef,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = ht(t.shape, r.shape);
      return {
        a: () => {
          const o = Z(n, Ve(r, "float32")), l = Mr(t.shape, i);
          return l.length > 0 ? ee(ct(o, l), t.shape) : o;
        },
        b: () => {
          const o = Z(n, Ve(t, "float32")), l = Mr(r.shape, i);
          return l.length > 0 ? ee(ct(o, l), r.shape) : o;
        }
      };
    }
  };
  const XPe = {
    kernelName: rv,
    gradFunc: (n) => ({
      x: () => cr(n)
    })
  };
  const YPe = {
    kernelName: Mf,
    inputsToSave: [
      "indices"
    ],
    gradFunc: (n, e) => {
      const t = e[0];
      return {
        indices: () => Cr(t.shape, "float32")
      };
    }
  };
  const qPe = {
    kernelName: ov,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const jPe = {
    kernelName: lv,
    saveAllInputs: true,
    gradFunc: (n, e, t) => {
      const { axis: r } = t;
      return kd(n, r).map((a) => () => a);
    }
  };
  const B4 = {
    kernelName: Pf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const r = e[0], { paddings: i } = t, a = i.map((s) => s[0]);
      return {
        x: () => Wn(n, a, r.shape)
      };
    }
  };
  const KPe = {
    kernelName: Lf,
    inputsToSave: [
      "a",
      "b"
    ],
    outputsToSave: [
      true
    ],
    gradFunc: (n, e) => {
      const [t, r, i] = e, a = t, s = r, o = ht(a.shape, s.shape);
      return {
        a: () => {
          const c = Ve(s, "float32");
          let h = Z(n, Z(c, Cd(a, wt(c, yn(1)))));
          const d = Mr(a.shape, o);
          return d.length > 0 && (h = ct(h, d)), ee(h, a.shape);
        },
        b: () => {
          const c = ja(a, 0), h = Ni(c, al(a), un(a));
          let d = Z(n, Z(i, h));
          const f = Mr(s.shape, o);
          return f.length > 0 && (d = ct(d, f)), ee(d, s.shape);
        }
      };
    }
  };
  const ZPe = {
    kernelName: Ff,
    inputsToSave: [
      "x",
      "alpha"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = ja(t, 0);
      return {
        x: () => Ni(i, n, Z(n, r)),
        alpha: () => {
          let a = Ni(i, un(n), Z(n, t));
          const s = Mr(r.shape, n.shape);
          return s.length > 0 && (a = ct(a, s)), ee(a, r.shape);
        }
      };
    }
  };
  function QPe(n, e, t) {
    const r = n.shape.slice();
    r[t] = 1;
    const i = ee(e, r), a = w$(n, t, true, false), s = w$(n, t, true, true), o = Z(a, s);
    return Z(i, o);
  }
  function JPe(n, e, t) {
    const r = n.shape.length, i = r - t.length, a = bn(t, r);
    let s = n;
    a != null && (s = ln(n, a));
    const o = s.shape.slice(), u = o.splice(r - t.length, t.length).reduce((d, f) => d * f, 1);
    o.push(u);
    const c = s.reshape(o);
    let h = QPe(c, e, i);
    if (h = h.reshape(s.shape), a != null) {
      const d = As(a);
      h = ln(h, d);
    }
    return h;
  }
  const eLe = {
    kernelName: Of,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { axis: i } = t;
      let a = [];
      return i == null ? a = r.shape.map((s, o) => o) : typeof i == "number" ? a = [
        i
      ] : a = i, {
        x: () => JPe(r, n, a)
      };
    }
  };
  const tLe = {
    kernelName: lf,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = ht(t.shape, r.shape);
      return {
        a: () => {
          const o = gt(n, Ve(r, "float32")), l = Mr(t.shape, i);
          return l.length > 0 ? ee(ct(o, l), t.shape) : o;
        },
        b: () => {
          let o = Z(n, Ve(t, "float32"));
          const l = Mr(r.shape, i);
          l.length > 0 && (o = ee(ct(o, l), r.shape));
          const u = Xn(r);
          return cr(gt(o, Ve(u, "float32")));
        }
      };
    }
  };
  const nLe = {
    kernelName: Bf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => gt(n, cr(Xn(t)))
      };
    }
  };
  const rLe = {
    kernelName: Gf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e, r = Z(Iv(t, 6), wb(t));
      return {
        x: () => Z(n, Ve(r, "float32"))
      };
    }
  };
  const iLe = {
    kernelName: zf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(n, Ve(wb(t), "float32"))
      };
    }
  };
  const aLe = {
    kernelName: uv,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => ee(n, t.shape)
      };
    }
  };
  const sLe = {
    kernelName: Wf,
    inputsToSave: [
      "images"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, i = {
        dy: n,
        images: r
      };
      return {
        images: () => Q.runKernel(hv, i, t)
      };
    }
  };
  const oLe = {
    kernelName: Vf,
    inputsToSave: [
      "images"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, i = {
        dy: n,
        images: r
      };
      return {
        images: () => Q.runKernel(cv, i, t)
      };
    }
  };
  const lLe = {
    kernelName: Uf,
    gradFunc: (n, e, t) => {
      const { dims: r } = t, i = yt(r, n.shape);
      return {
        x: () => Id(n, i)
      };
    }
  };
  const uLe = {
    kernelName: Hf,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const cLe = {
    kernelName: Xf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => cr(gt(n, Z(Cd(t, 1.5), 2)))
      };
    }
  };
  const hLe = {
    kernelName: dv,
    inputsToSave: [
      "condition"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        condition: () => Ve(un(t), "float32"),
        t: () => Z(n, Ve(t, n.dtype)),
        e: () => Z(n, Ve(cP(t), n.dtype))
      };
    }
  };
  const dLe = {
    kernelName: Yf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => {
          const r = ja(t, yn(0)), i = yn(Db), a = yn(Rb), s = Z(n, a), o = Z(Z(n, i), il(Ve(t, "float32")));
          return Ni(r, s, o);
        }
      };
    }
  };
  const fLe = {
    kernelName: Zf,
    outputsToSave: [
      true
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(n, Z(t, wt(yn(1), t)))
      };
    }
  };
  const pLe = {
    kernelName: Kf,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const gLe = {
    kernelName: qf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(iP(Ve(t, "float32")), n)
      };
    }
  };
  const mLe = {
    kernelName: jf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(I9(Ve(t, "float32")), n)
      };
    }
  };
  const vLe = {
    kernelName: fv,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { begin: i, size: a } = t, s = r.shape, [o, l] = Av(r, i, a), u = [];
      for (let c = 0; c < n.rank; c++) u.push([
        o[c],
        s[c] - o[c] - l[c]
      ]);
      return {
        x: () => fP(n, u)
      };
    }
  };
  const yLe = {
    kernelName: tp,
    outputsToSave: [
      true
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { dim: i } = t, a = true, s = Z(n, r);
      return {
        logits: () => wt(s, Z(ct(s, [
          i
        ], a), r))
      };
    }
  };
  const xLe = {
    kernelName: Qf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(n, Cv(t))
      };
    }
  };
  const z4 = {
    kernelName: pv,
    gradFunc: (n, e, t) => {
      const { blockShape: r, paddings: i } = t;
      return {
        x: () => nP(n, r, i)
      };
    }
  };
  const V4 = {
    kernelName: gv,
    gradFunc: (n, e, t) => {
      const { axis: r } = t;
      return {
        x: () => Qi(n, r)
      };
    }
  };
  const bLe = {
    kernelName: Jf,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => gt(n, Z(mi(Ve(t, "float32")), 2))
      };
    }
  };
  const wLe = {
    kernelName: gb,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(n, Z(Ve(t, "float32"), 2))
      };
    }
  };
  const _Le = {
    kernelName: np,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = yn(2);
      return {
        a: () => Z(n, Z(i, wt(t, r))),
        b: () => Z(n, Z(i, wt(r, t)))
      };
    }
  };
  const SLe = {
    kernelName: _c,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const CLe = {
    kernelName: rp,
    inputsToSave: [
      "a",
      "b"
    ],
    gradFunc: (n, e) => {
      const [t, r] = e, i = ht(t.shape, r.shape);
      return {
        a: () => {
          let o = n;
          const l = Mr(t.shape, i);
          return l.length > 0 && (o = ct(o, l)), ee(o, t.shape);
        },
        b: () => {
          let o = n;
          const l = Mr(r.shape, i);
          return l.length > 0 && (o = ct(o, l)), ee(cr(o), r.shape);
        }
      };
    }
  };
  const ILe = {
    kernelName: ep,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, i = r.shape.slice(), { axis: a } = t;
      yt(a, r.shape).forEach((u) => {
        i[u] = 1;
      });
      const o = ee(n, i), l = Z(o, Ic(r.shape, "float32"));
      return {
        x: () => l
      };
    }
  };
  const kLe = {
    kernelName: ip,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => gt(n, Xn(iP(t)))
      };
    }
  };
  const TLe = {
    kernelName: ap,
    outputsToSave: [
      true
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => Z(wt(yn(1), Xn(t)), n)
      };
    }
  };
  const ALe = {
    kernelName: wc,
    inputsToSave: [
      "x"
    ],
    gradFunc: (n, e, t) => {
      const [r] = e, { reps: i } = t;
      return {
        x: () => {
          let s = un(r);
          if (r.rank === 1) for (let o = 0; o < i[0]; ++o) s = Ce(s, Wn(n, [
            o * r.shape[0]
          ], [
            r.shape[0]
          ]));
          else if (r.rank === 2) for (let o = 0; o < i[0]; ++o) for (let l = 0; l < i[1]; ++l) s = Ce(s, Wn(n, [
            o * r.shape[0],
            l * r.shape[1]
          ], [
            r.shape[0],
            r.shape[1]
          ]));
          else if (r.rank === 3) for (let o = 0; o < i[0]; ++o) for (let l = 0; l < i[1]; ++l) for (let u = 0; u < i[2]; ++u) s = Ce(s, Wn(n, [
            o * r.shape[0],
            l * r.shape[1],
            u * r.shape[2]
          ], [
            r.shape[0],
            r.shape[1],
            r.shape[2]
          ]));
          else if (r.rank === 4) for (let o = 0; o < i[0]; ++o) for (let l = 0; l < i[1]; ++l) for (let u = 0; u < i[2]; ++u) for (let c = 0; c < i[3]; ++c) s = Ce(s, Wn(n, [
            o * r.shape[0],
            l * r.shape[1],
            u * r.shape[2],
            c * r.shape[3]
          ], [
            r.shape[0],
            r.shape[1],
            r.shape[2],
            r.shape[3]
          ]));
          else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);
          return s;
        }
      };
    }
  };
  const DLe = {
    kernelName: Ol,
    gradFunc: (n, e, t) => {
      const r = t, { perm: i } = r, a = As(i);
      return {
        x: () => ln(n, a)
      };
    }
  };
  const RLe = {
    kernelName: xv,
    gradFunc: (n, e, t) => {
      const r = t, { axis: i } = r;
      return {
        value: () => tu(n, i)
      };
    }
  };
  const $Le = {
    kernelName: mb,
    inputsToSave: [
      "segmentIds"
    ],
    gradFunc: (n, e) => {
      const [t] = e;
      return {
        x: () => NLe(n, t)
      };
    }
  };
  function NLe(n, e) {
    const t = Cc(e, un(e)), r = oP(n, t);
    let i = op(e, yn(0, "int32"));
    const a = r.rank - i.rank;
    for (let o = 0; o < a; ++o) i = Xi(i, o + 1);
    i = eu(i, Ic(r.shape, "bool"));
    const s = un(r);
    return Ni(i, r, s);
  }
  const ELe = {
    kernelName: bv,
    gradFunc: (n) => ({
      x: () => un(n)
    })
  };
  const MLe = [
    CZ,
    $Me,
    NMe,
    EMe,
    MMe,
    PMe,
    LMe,
    FMe,
    OMe,
    BMe,
    zMe,
    VMe,
    UMe,
    YMe,
    qMe,
    jMe,
    KMe,
    ZMe,
    QMe,
    JMe,
    ePe,
    tPe,
    rPe,
    nPe,
    sPe,
    oPe,
    lPe,
    uPe,
    cPe,
    hPe,
    tLe,
    dPe,
    fPe,
    pPe,
    gPe,
    mPe,
    yPe,
    vPe,
    xPe,
    bPe,
    wPe,
    _Pe,
    SPe,
    CPe,
    IPe,
    kPe,
    TPe,
    APe,
    DPe,
    NPe,
    O4,
    O4,
    EPe,
    LPe,
    BPe,
    zPe,
    VPe,
    WPe,
    GPe,
    UPe,
    HPe,
    XPe,
    YPe,
    qPe,
    jPe,
    B4,
    B4,
    KPe,
    ZPe,
    eLe,
    nLe,
    rLe,
    iLe,
    aLe,
    sLe,
    oLe,
    lLe,
    uLe,
    cLe,
    hLe,
    dLe,
    fLe,
    pLe,
    gLe,
    mLe,
    vLe,
    yLe,
    xLe,
    z4,
    z4,
    V4,
    V4,
    bLe,
    _Le,
    wLe,
    SLe,
    CLe,
    ILe,
    kLe,
    TLe,
    ALe,
    DLe,
    RLe,
    $Le,
    ELe
  ];
  for (const n of MLe) dAe(n);
  he().prototype.abs = function() {
    return this.throwIfDisposed(), ki(this);
  };
  he().prototype.acos = function() {
    return this.throwIfDisposed(), gDe(this);
  };
  he().prototype.acosh = function() {
    return this.throwIfDisposed(), vDe(this);
  };
  he().prototype.add = function(n) {
    return this.throwIfDisposed(), Ce(this, n);
  };
  he().prototype.all = function(n, e) {
    return this.throwIfDisposed(), w9(this, n, e);
  };
  he().prototype.any = function(n, e) {
    return this.throwIfDisposed(), x$(this, n, e);
  };
  he().prototype.argMax = function(n) {
    return this.throwIfDisposed(), rx(this, n);
  };
  he().prototype.argMin = function(n) {
    return this.throwIfDisposed(), _De(this, n);
  };
  he().prototype.asScalar = function() {
    return this.throwIfDisposed(), B(this.size === 1, () => "The array must have only 1 element."), ee(this, []);
  };
  he().prototype.asType = function(n) {
    return this.throwIfDisposed(), Ve(this, n);
  };
  he().prototype.as1D = function() {
    return this.throwIfDisposed(), ee(this, [
      this.size
    ]);
  };
  he().prototype.as2D = function(n, e) {
    return this.throwIfDisposed(), ee(this, [
      n,
      e
    ]);
  };
  he().prototype.as3D = function(n, e, t) {
    return this.throwIfDisposed(), ee(this, [
      n,
      e,
      t
    ]);
  };
  he().prototype.as4D = function(n, e, t, r) {
    return this.throwIfDisposed(), ee(this, [
      n,
      e,
      t,
      r
    ]);
  };
  he().prototype.as5D = function(n, e, t, r, i) {
    return this.throwIfDisposed(), ee(this, [
      n,
      e,
      t,
      r,
      i
    ]);
  };
  he().prototype.asin = function() {
    return this.throwIfDisposed(), CDe(this);
  };
  he().prototype.asinh = function() {
    return this.throwIfDisposed(), kDe(this);
  };
  he().prototype.atan = function() {
    return this.throwIfDisposed(), ADe(this);
  };
  he().prototype.atan2 = function(n) {
    return this.throwIfDisposed(), RDe(this, n);
  };
  he().prototype.atanh = function() {
    return this.throwIfDisposed(), NDe(this);
  };
  he().prototype.avgPool = function(n, e, t, r) {
    return this.throwIfDisposed(), tP(this, n, e, t, r);
  };
  he().prototype.batchToSpaceND = function(n, e) {
    return this.throwIfDisposed(), nP(this, n, e);
  };
  he().prototype.batchNorm = function(n, e, t, r, i) {
    return this.throwIfDisposed(), CI(this, n, e, t, r, i);
  };
  he().prototype.broadcastTo = function(n) {
    return this.throwIfDisposed(), g0(this, n);
  };
  he().prototype.cast = function(n) {
    return this.throwIfDisposed(), Ve(this, n);
  };
  he().prototype.ceil = function() {
    return this.throwIfDisposed(), aRe(this);
  };
  he().prototype.clipByValue = function(n, e) {
    return this.throwIfDisposed(), Xa(this, n, e);
  };
  he().prototype.concat = function(n, e) {
    return this.throwIfDisposed(), n instanceof _r && (n = [
      n
    ]), Qi([
      this,
      ...n
    ], e);
  };
  he().prototype.conv1d = function(n, e, t, r, i, a) {
    return this.throwIfDisposed(), _9(this, n, e, t, r, i, a);
  };
  he().prototype.conv2dTranspose = function(n, e, t, r, i) {
    return this.throwIfDisposed(), S9(this, n, e, t, r, i);
  };
  he().prototype.conv2d = function(n, e, t, r, i, a) {
    return this.throwIfDisposed(), Sd(this, n, e, t, r, i, a);
  };
  he().prototype.cos = function() {
    return this.throwIfDisposed(), iP(this);
  };
  he().prototype.cosh = function() {
    return this.throwIfDisposed(), I9(this);
  };
  he().prototype.cumprod = function(n, e, t) {
    return this.throwIfDisposed(), w$(this, n, e, t);
  };
  he().prototype.cumsum = function(n, e, t) {
    return this.throwIfDisposed(), k9(this, n, e, t);
  };
  he().prototype.depthToSpace = function(n, e) {
    return this.throwIfDisposed(), RRe(this, n, e);
  };
  he().prototype.depthwiseConv2d = function(n, e, t, r, i, a) {
    return this.throwIfDisposed(), aP(this, n, e, t, r, i, a);
  };
  he().prototype.dilation2d = function(n, e, t, r, i) {
    return this.throwIfDisposed(), ERe(this, n, e, t, r, i);
  };
  he().prototype.divNoNan = function(n) {
    return this.throwIfDisposed(), ORe(this, n);
  };
  he().prototype.div = function(n) {
    return this.throwIfDisposed(), gt(this, n);
  };
  he().prototype.dot = function(n) {
    return this.throwIfDisposed(), zRe(this, n);
  };
  he().prototype.elu = function() {
    return this.throwIfDisposed(), kI(this);
  };
  he().prototype.equal = function(n) {
    return this.throwIfDisposed(), rl(this, n);
  };
  he().prototype.erf = function() {
    return this.throwIfDisposed(), T9(this);
  };
  he().prototype.euclideanNorm = function(n, e) {
    return this.throwIfDisposed(), QRe(this, n, e);
  };
  he().prototype.exp = function() {
    return this.throwIfDisposed(), il(this);
  };
  he().prototype.expandDims = function(n) {
    return this.throwIfDisposed(), Xi(this, n);
  };
  he().prototype.expm1 = function() {
    return this.throwIfDisposed(), n$e(this);
  };
  he().prototype.fft = function() {
    return this.throwIfDisposed(), H9(this);
  };
  he().prototype.flatten = function() {
    return this.throwIfDisposed(), ee(this, [
      this.size
    ]);
  };
  he().prototype.floor = function() {
    return this.throwIfDisposed(), AI(this);
  };
  he().prototype.floorDiv = function(n) {
    return this.throwIfDisposed(), b9(this, n);
  };
  he().prototype.gather = function(n, e, t) {
    return this.throwIfDisposed(), oP(this, n, e, t);
  };
  he().prototype.greaterEqual = function(n) {
    return this.throwIfDisposed(), op(this, n);
  };
  he().prototype.greater = function(n) {
    return this.throwIfDisposed(), ja(this, n);
  };
  he().prototype.ifft = function() {
    return this.throwIfDisposed(), _$(this);
  };
  he().prototype.irfft = function() {
    return this.throwIfDisposed(), qNe(this);
  };
  he().prototype.isFinite = function() {
    return this.throwIfDisposed(), h$e(this);
  };
  he().prototype.isInf = function() {
    return this.throwIfDisposed(), f$e(this);
  };
  he().prototype.isNaN = function() {
    return this.throwIfDisposed(), g$e(this);
  };
  he().prototype.leakyRelu = function(n) {
    return this.throwIfDisposed(), uP(this, n);
  };
  he().prototype.lessEqual = function(n) {
    return this.throwIfDisposed(), Iv(this, n);
  };
  he().prototype.less = function(n) {
    return this.throwIfDisposed(), $S(this, n);
  };
  he().prototype.localResponseNormalization = function(n, e, t, r) {
    return this.throwIfDisposed(), b$e(this, n, e, t, r);
  };
  he().prototype.logSigmoid = function() {
    return this.throwIfDisposed(), T$e(this);
  };
  he().prototype.logSoftmax = function(n) {
    return this.throwIfDisposed(), N9(this, n);
  };
  he().prototype.logSumExp = function(n, e) {
    return this.throwIfDisposed(), E9(this, n, e);
  };
  he().prototype.log = function() {
    return this.throwIfDisposed(), al(this);
  };
  he().prototype.log1p = function() {
    return this.throwIfDisposed(), $9(this);
  };
  he().prototype.logicalAnd = function(n) {
    return this.throwIfDisposed(), eu(this, n);
  };
  he().prototype.logicalNot = function() {
    return this.throwIfDisposed(), cP(this);
  };
  he().prototype.logicalOr = function(n) {
    return this.throwIfDisposed(), M9(this, n);
  };
  he().prototype.logicalXor = function(n) {
    return this.throwIfDisposed(), P$e(this, n);
  };
  he().prototype.matMul = function(n, e, t) {
    return this.throwIfDisposed(), mn(this, n, e, t);
  };
  he().prototype.maxPool = function(n, e, t, r) {
    return this.throwIfDisposed(), hP(this, n, e, t, r);
  };
  he().prototype.max = function(n, e) {
    return this.throwIfDisposed(), Js(this, n, e);
  };
  he().prototype.maximum = function(n) {
    return this.throwIfDisposed(), Cc(this, n);
  };
  he().prototype.mean = function(n, e) {
    return this.throwIfDisposed(), vr(this, n, e);
  };
  he().prototype.min = function(n, e) {
    return this.throwIfDisposed(), RS(this, n, e);
  };
  he().prototype.minimum = function(n) {
    return this.throwIfDisposed(), sx(this, n);
  };
  he().prototype.mirrorPad = function(n, e) {
    return this.throwIfDisposed(), G$e(this, n, e);
  };
  he().prototype.mod = function(n) {
    return this.throwIfDisposed(), H$e(this, n);
  };
  he().prototype.mul = function(n) {
    return this.throwIfDisposed(), Z(this, n);
  };
  he().prototype.neg = function() {
    return this.throwIfDisposed(), cr(this);
  };
  he().prototype.norm = function(n, e, t) {
    return this.throwIfDisposed(), TI(this, n, e, t);
  };
  he().prototype.notEqual = function(n) {
    return this.throwIfDisposed(), NS(this, n);
  };
  he().prototype.oneHot = function(n, e = 1, t = 0) {
    return this.throwIfDisposed(), P9(this, n, e, t);
  };
  he().prototype.onesLike = function() {
    return this.throwIfDisposed(), Cs(this);
  };
  he().prototype.pad = function(n, e) {
    return this.throwIfDisposed(), fP(this, n, e);
  };
  he().prototype.pool = function(n, e, t, r, i, a) {
    return this.throwIfDisposed(), tNe(this, n, e, t, r, i, a);
  };
  he().prototype.pow = function(n) {
    return this.throwIfDisposed(), Cd(this, n);
  };
  he().prototype.prelu = function(n) {
    return this.throwIfDisposed(), gP(this, n);
  };
  he().prototype.prod = function(n, e) {
    return this.throwIfDisposed(), iNe(this, n, e);
  };
  he().prototype.reciprocal = function() {
    return this.throwIfDisposed(), ANe(this);
  };
  he().prototype.relu = function() {
    return this.throwIfDisposed(), lp(this);
  };
  he().prototype.relu6 = function() {
    return this.throwIfDisposed(), F9(this);
  };
  he().prototype.reshapeAs = function(n) {
    return this.throwIfDisposed(), ee(this, n.shape);
  };
  he().prototype.reshape = function(n) {
    return this.throwIfDisposed(), ee(this, n);
  };
  he().prototype.resizeBilinear = function(n, e, t) {
    return this.throwIfDisposed(), K9(this, n, e, t);
  };
  he().prototype.resizeNearestNeighbor = function(n, e, t) {
    return this.throwIfDisposed(), Z9(this, n, e, t);
  };
  he().prototype.reverse = function(n) {
    return this.throwIfDisposed(), Id(this, n);
  };
  he().prototype.rfft = function() {
    return this.throwIfDisposed(), ZNe(this);
  };
  he().prototype.round = function() {
    return this.throwIfDisposed(), O9(this);
  };
  he().prototype.rsqrt = function() {
    return this.throwIfDisposed(), B9(this);
  };
  he().prototype.selu = function() {
    return this.throwIfDisposed(), z9(this);
  };
  he().prototype.separableConv2d = function(n, e, t, r, i, a) {
    return this.throwIfDisposed(), V9(this, n, e, t, r, i, a);
  };
  he().prototype.sigmoid = function() {
    return this.throwIfDisposed(), Cv(this);
  };
  he().prototype.sign = function() {
    return this.throwIfDisposed(), FNe(this);
  };
  he().prototype.sin = function() {
    return this.throwIfDisposed(), W9(this);
  };
  he().prototype.sinh = function() {
    return this.throwIfDisposed(), G9(this);
  };
  he().prototype.slice = function(n, e) {
    return this.throwIfDisposed(), Wn(this, n, e);
  };
  he().prototype.softmax = function(n) {
    return this.throwIfDisposed(), xP(this, n);
  };
  he().prototype.softplus = function() {
    return this.throwIfDisposed(), yb(this);
  };
  he().prototype.spaceToBatchND = function(n, e) {
    return this.throwIfDisposed(), pP(this, n, e);
  };
  he().prototype.split = function(n, e) {
    return this.throwIfDisposed(), Ga(this, n, e);
  };
  he().prototype.sqrt = function() {
    return this.throwIfDisposed(), mi(this);
  };
  he().prototype.square = function() {
    return this.throwIfDisposed(), Xn(this);
  };
  he().prototype.squaredDifference = function(n) {
    return this.throwIfDisposed(), JNe(this, n);
  };
  he().prototype.squeeze = function(n) {
    return this.throwIfDisposed(), bb(this, n);
  };
  he().prototype.stack = function(n, e) {
    this.throwIfDisposed();
    const t = n instanceof _r ? [
      this,
      n
    ] : [
      this,
      ...n
    ];
    return tu(t, e);
  };
  he().prototype.step = function(n) {
    return this.throwIfDisposed(), wb(this, n);
  };
  he().prototype.stridedSlice = function(n, e, t, r, i, a, s, o) {
    return this.throwIfDisposed(), iEe(this, n, e, t, r, i, a, s, o);
  };
  he().prototype.sub = function(n) {
    return this.throwIfDisposed(), wt(this, n);
  };
  he().prototype.sum = function(n, e) {
    return this.throwIfDisposed(), ct(this, n, e);
  };
  he().prototype.tan = function() {
    return this.throwIfDisposed(), sEe(this);
  };
  he().prototype.tanh = function() {
    return this.throwIfDisposed(), SI(this);
  };
  he().prototype.tile = function(n) {
    return this.throwIfDisposed(), Ys(this, n);
  };
  he().prototype.toBool = function() {
    return this.throwIfDisposed(), Ve(this, "bool");
  };
  he().prototype.toFloat = function() {
    return this.throwIfDisposed(), Ve(this, "float32");
  };
  he().prototype.toInt = function() {
    return this.throwIfDisposed(), Ve(this, "int32");
  };
  he().prototype.topk = function(n, e) {
    return this.throwIfDisposed(), uEe(this, n, e);
  };
  he().prototype.transpose = function(n) {
    return this.throwIfDisposed(), ln(this, n);
  };
  he().prototype.unique = function(n) {
    return this.throwIfDisposed(), dEe(this, n);
  };
  he().prototype.unsortedSegmentSum = function(n, e) {
    return this.throwIfDisposed(), q9(this, n, e);
  };
  he().prototype.unstack = function(n) {
    return this.throwIfDisposed(), kd(this, n);
  };
  he().prototype.where = function(n, e) {
    return this.throwIfDisposed(), Ni(n, this, e);
  };
  he().prototype.zerosLike = function() {
    return this.throwIfDisposed(), un(this);
  };
  class Eo extends Error {
    constructor(e) {
      super(e), Object.setPrototypeOf(this, Eo.prototype);
    }
  }
  class ys extends Error {
    constructor(e) {
      super(e), Object.setPrototypeOf(this, ys.prototype);
    }
  }
  class j extends Error {
    constructor(e) {
      super(e), Object.setPrototypeOf(this, j.prototype);
    }
  }
  class zt extends Error {
    constructor(e) {
      super(e), Object.setPrototypeOf(this, zt.prototype);
    }
  }
  class GP extends Error {
    constructor(e) {
      super(e), Object.setPrototypeOf(this, GP.prototype);
    }
  }
  class kZ {
    constructor(e) {
      this.maxEntries = e || 100, this.cache = /* @__PURE__ */ new Map();
    }
    get(e) {
      let t;
      return this.cache.has(e) && (t = this.cache.get(e), this.cache.delete(e), this.cache.set(e, t)), t;
    }
    put(e, t) {
      if (this.cache.has(e)) this.cache.delete(e);
      else if (this.cache.size >= this.maxEntries) {
        const r = this.cache.keys().next().value;
        this.cache.delete(r);
      }
      this.cache.set(e, t);
    }
    getMaxEntries() {
      return this.maxEntries;
    }
    setMaxEntries(e) {
      if (e < 0) throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);
      if (this.maxEntries > e) for (let t = 0; t < this.maxEntries - e; t++) {
        const r = this.cache.keys().next().value;
        this.cache.delete(r);
      }
      this.maxEntries = e;
    }
  }
  function Td(n, e) {
    if (Array.isArray(n)) {
      let t = [];
      for (let r = 0; r < e; r++) t = t.concat(n);
      return t;
    } else {
      const t = new Array(e);
      return t.fill(n), t;
    }
  }
  function Mo(n, e) {
    if (!n) throw new GP(e);
  }
  function W4(n, e) {
    let t = 0;
    for (const r of n) r === e && t++;
    return t;
  }
  function Yi(n) {
    return n.length === 1 ? n[0] : n;
  }
  function In(n) {
    return Array.isArray(n) ? n : [
      n
    ];
  }
  function Il(n) {
    const t = n.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    return t[0] !== "_" ? t : "private" + t;
  }
  function Nh(n) {
    return n.length <= 1 || n.indexOf("_") === -1 ? n : n.replace(/[_]+(\w|$)/g, (e, t) => t.toUpperCase());
  }
  let rs = {};
  function UP(n) {
    if (n == null) return null;
    const e = {};
    return e.className = n.getClassName(), e.config = n.getConfig(), e;
  }
  function C$(n) {
    if (!(n == null || typeof n != "object")) if (Array.isArray(n)) n.forEach((e) => C$(e));
    else {
      const e = Object.keys(n);
      for (const t of e) {
        const r = n[t];
        r != null && typeof r == "object" && (!Array.isArray(r) && r.type === "ndarray" && typeof r.value == "number" ? n[t] = r.value : C$(r));
      }
    }
  }
  function Eb(n, e = {}, t = {}, r = "object", i = false) {
    if (typeof n == "string") {
      const a = n;
      let s;
      if (a in t) s = t[a];
      else if (a in rs) s = rs[a];
      else if (s = e[a], s == null) throw new j(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      return s;
    } else {
      const a = n;
      if (a.className == null || a.config == null) throw new j(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);
      const s = a.className;
      let o, l;
      if (s in t ? [o, l] = t[s] : s in rs ? [o, l] = rs.className : s in e && ([o, l] = e[s]), o == null) throw new j(`Unknown ${r}: ${s}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      if (l != null) {
        const u = {};
        for (const f of Object.keys(rs)) u[f] = rs[f];
        for (const f of Object.keys(t)) u[f] = t[f];
        const c = a.config;
        c.customObjects = u;
        const h = Object.assign({}, rs);
        for (const f of Object.keys(t)) rs[f] = t[f];
        C$(a.config);
        const d = l(o, a.config, t, i);
        return rs = Object.assign({}, h), d;
      } else {
        const u = Object.assign({}, rs);
        for (const h of Object.keys(t)) rs[h] = t[h];
        const c = new o(a.config);
        return rs = Object.assign({}, u), c;
      }
    }
  }
  function PLe(n, e) {
    return n < e ? -1 : n > e ? 1 : 0;
  }
  function gw(n, e) {
    return -1 * PLe(n, e);
  }
  function Zu(n) {
    if (n == null) return n;
    const e = [];
    for (const t of n) e.indexOf(t) === -1 && e.push(t);
    return e;
  }
  function LLe(n) {
    if (n == null) throw new j(`Invalid value in obj: ${JSON.stringify(n)}`);
    for (const e in n) if (n.hasOwnProperty(e)) return false;
    return true;
  }
  function up(n, e, t) {
    if (t != null && n.indexOf(t) < 0) throw new j(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`);
  }
  function HP(n, e, t = 0, r = 1 / 0) {
    return Mo(t >= 0), Mo(r >= t), Array.isArray(n) && n.length >= t && n.length <= r && n.every((i) => typeof i === e);
  }
  function Wr(n, e) {
    Array.isArray(n) ? (B(n.length > 0, () => `${e} is unexpectedly an empty array.`), n.forEach((t, r) => Wr(t, `element ${r + 1} of ${e}`))) : B(Number.isInteger(n) && n > 0, () => `Expected ${e} to be a positive integer, but got ${TZ(n)}.`);
  }
  function TZ(n) {
    return n === null ? "null" : Array.isArray(n) ? "[" + n.map((e) => TZ(e)).join(",") + "]" : typeof n == "string" ? `"${n}"` : `${n}`;
  }
  function FLe(n, e, t) {
    let r = t != null ? t() : hi(), i;
    return (...s) => {
      const o = t != null ? t() : hi();
      return o - r < e || (r = o, i = n(...s)), i;
    };
  }
  function AZ(n) {
    return n === "relu" ? "relu" : n === "linear" ? "linear" : n === "elu" ? "elu" : null;
  }
  let OLe = 0;
  function DZ() {
    return OLe++;
  }
  const mw = {};
  function XI(n = "") {
    return n in mw || (mw[n] = 0), mw[n] += 1, n + mw[n].toString();
  }
  const BLe = [
    "channelsFirst",
    "channelsLast"
  ], zLe = [
    "nearest",
    "bilinear"
  ], VLe = [
    "valid",
    "same",
    "causal"
  ], WLe = [
    "max",
    "avg"
  ], GLe = [
    "sum",
    "mul",
    "concat",
    "ave"
  ];
  const qp = /* @__PURE__ */ new Map();
  function fr(n) {
    up(BLe, "DataFormat", n);
  }
  function ULe(n) {
    up(zLe, "InterpolationFormat", n);
  }
  function Za(n) {
    up(VLe, "PaddingMode", n);
  }
  function RZ(n) {
    up(WLe, "PoolMode", n);
  }
  const m0 = [], G4 = "/";
  function ad(n, e) {
    m0.push(n);
    try {
      const t = e();
      return m0.pop(), t;
    } catch (t) {
      throw m0.pop(), t;
    }
  }
  function HLe() {
    return m0.length === 0 ? "" : m0.join(G4) + G4;
  }
  function $Z(n) {
    if (!EZ(n)) throw new Error("Not a valid tensor name: '" + n + "'");
    return HLe() + n;
  }
  function NZ(n) {
    if (!EZ(n)) throw new Error("Not a valid tensor name: '" + n + "'");
    qp.has(n) || qp.set(n, 0);
    const e = qp.get(n);
    if (qp.set(n, qp.get(n) + 1), e > 0) {
      const t = `${n}_${e}`;
      return qp.set(t, 1), t;
    } else return n;
  }
  const XLe = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
  function EZ(n) {
    return !!n.match(XLe);
  }
  function YLe(n) {
    return n === parseInt(n.toString(), 10);
  }
  function Qu(n, e, t) {
    e == null && (e = 0), t == null && (t = n.length);
    let r = 1;
    for (let i = e; i < t; ++i) r *= n[i];
    return r;
  }
  function Zg(n) {
    if (n.length === 0) return Number.NaN;
    let e = Number.POSITIVE_INFINITY;
    for (let t = 0; t < n.length; t++) {
      const r = n[t];
      r < e && (e = r);
    }
    return e;
  }
  function uc(n) {
    if (n.length === 0) return Number.NaN;
    let e = Number.NEGATIVE_INFINITY;
    for (let t = 0; t < n.length; t++) {
      const r = n[t];
      r > e && (e = r);
    }
    return e;
  }
  function oo(n, e) {
    if (e < n) throw new j(`end (${e}) < begin (${n}) is forbidden.`);
    const t = [];
    for (let r = n; r < e; ++r) t.push(r);
    return t;
  }
  let uA;
  function Tr() {
    return uA == null && (uA = BAe().epsilon()), uA;
  }
  function lo() {
    return "channelsLast";
  }
  function jo(n, e) {
    return Ve(n, e);
  }
  function Mb(n, e = -1) {
    const t = n.shape.slice();
    return e < 0 && (e = t.length + e + 1), t.splice(e, 0, 1), ee(n, t);
  }
  function qLe(n, e) {
    return se(() => {
      if (n.shape.length !== 2) throw new j(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);
      const t = Mb(n, 1);
      return I$(t, [
        1,
        e,
        1
      ]);
    });
  }
  function jLe(n) {
    const e = [
      Qu(n.shape)
    ];
    return ee(n, e);
  }
  function KLe(n) {
    if (n.rank <= 1) throw new j(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);
    const e = [
      n.shape[0],
      Qu(n.shape, 1)
    ];
    return ee(n, e);
  }
  function sd(n, e, t) {
    return se(() => {
      switch (n.rank) {
        case 1:
          return vP(n, e, t);
        case 2:
          return U9(n, [
            e,
            0
          ], [
            t,
            n.shape[1]
          ]);
        case 3:
          return yP(n, [
            e,
            0,
            0
          ], [
            t,
            n.shape[1],
            n.shape[2]
          ]);
        case 4:
          return MS(n, [
            e,
            0,
            0,
            0
          ], [
            t,
            n.shape[1],
            n.shape[2],
            n.shape[3]
          ]);
        case 5:
          return Wn(n, [
            e,
            0,
            0,
            0,
            0
          ], [
            t,
            n.shape[1],
            n.shape[2],
            n.shape[3],
            n.shape[4]
          ]);
        case 6:
          return Wn(n, [
            e,
            0,
            0,
            0,
            0,
            0
          ], [
            t,
            n.shape[1],
            n.shape[2],
            n.shape[3],
            n.shape[4],
            n.shape[5]
          ]);
        default:
          throw new j(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`);
      }
    });
  }
  function cA(n, e, t) {
    return se(() => {
      switch (n.rank) {
        case 1:
          return vP(n, e, t);
        case 2:
          return U9(n, [
            0,
            e
          ], [
            n.shape[0],
            t
          ]);
        case 3:
          return yP(n, [
            0,
            0,
            e
          ], [
            n.shape[0],
            n.shape[1],
            t
          ]);
        case 4:
          return MS(n, [
            0,
            0,
            0,
            e
          ], [
            n.shape[0],
            n.shape[1],
            n.shape[2],
            t
          ]);
        default:
          throw new j(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`);
      }
    });
  }
  function vw(n, e, t, r) {
    return se(() => {
      switch (n.rank) {
        case 1:
          return vP(n, e, t);
        case 2:
          switch (r) {
            case 1:
              return sd(n, e, t);
            case 2:
              return cA(n, e, t);
            default:
              throw new j(`The axis is not within the rank of the tensor ${r}`);
          }
        case 3:
          switch (r) {
            case 1:
              return sd(n, e, t);
            case 2:
              return yP(n, [
                0,
                e,
                0
              ], [
                n.shape[0],
                t,
                n.shape[2]
              ]);
            case 3:
              return cA(n, e, t);
            default:
              throw new j(`The axis is not within the rank of the tensor ${r}`);
          }
        case 4:
          switch (r) {
            case 1:
              return sd(n, e, t);
            case 2:
              return MS(n, [
                0,
                e,
                0,
                0
              ], [
                n.shape[0],
                t,
                n.shape[2],
                n.shape[3]
              ]);
            case 3:
              return MS(n, [
                0,
                0,
                e,
                0
              ], [
                n.shape[0],
                n.shape[1],
                t,
                n.shape[3]
              ]);
            case 4:
              return cA(n, e, t);
            default:
              throw new j(`The axis is not within the rank of the tensor ${r}`);
          }
        default:
          throw new j(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`);
      }
    });
  }
  function XP(n, e = -1) {
    let t;
    return e < 0 && (t = n[0].rank, t !== 0 ? e = t : e = 0), e === n[0].rank && (e = -1), Qi(n, e);
  }
  function U4(n, e) {
    switch (n.rank) {
      case 1:
        return lRe([
          n,
          e
        ]);
      case 2:
        return cRe([
          n,
          e
        ], 0);
      case 3:
        return dRe([
          n,
          e
        ], 0);
      case 4:
        return pRe([
          n,
          e
        ], 0);
      default:
        throw new j(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`);
    }
  }
  function I$(n, e) {
    if (Array.isArray(e) || (e = [
      e
    ]), n.rank !== e.length) throw new j(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);
    return Ys(n, e);
  }
  function YI(n, e = 0, t = 1, r, i) {
    return CNe(n, e, t, r, i);
  }
  function Ko(n, e, t, r) {
    if (n.rank < 2 || e.rank < 2) throw new zt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);
    if (e.rank >= 3) {
      const i = n.shape.slice(-1)[0], a = e.shape.slice(-2)[0];
      if (i !== a) throw new zt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`);
    }
    if (n.rank === 2 && e.rank === 2) return R4({
      a: n,
      b: e,
      transposeA: false,
      transposeB: false,
      bias: r ? k$(n.rank, r, lo()) : null,
      activation: t
    });
    {
      const i = n.shape.slice(), a = i.pop();
      n = ee(n, [
        -1,
        a
      ]);
      const s = e.shape.slice(), o = s.pop(), l = s.pop(), u = [
        ...s,
        o
      ], c = Array.from({
        length: e.rank
      }, (p, g) => g === 0 ? e.rank - 2 : g <= e.rank - 2 ? g - 1 : g);
      e = ee(ln(e, c), [
        l,
        -1
      ]);
      const h = [
        ...i,
        ...u
      ];
      return ee(R4({
        a: n,
        b: e,
        transposeA: false,
        transposeB: false,
        bias: r ? k$(n.rank, r, lo()) : null,
        activation: t
      }), h);
    }
  }
  function MZ(n, e, t) {
    return se(() => (Array.isArray(e) ? e = Sa(e, "int32") : e = Ve(e, "int32"), oP(n, e, t)));
  }
  function Pb(n) {
    return Z(n, n);
  }
  function k$(n, e, t) {
    const r = e.shape;
    if (e.rank !== 1 && e.rank !== n) throw new j(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);
    if (n === 5) {
      if (t === "channelsFirst") return r.length === 1 ? ee(e, [
        1,
        r[0],
        1,
        1,
        1
      ]) : ee(e, [
        1,
        r[3],
        r[0],
        r[1],
        r[2]
      ]);
      if (t === "channelsLast") return r.length === 1 ? ee(e, [
        1,
        1,
        1,
        1,
        r[0]
      ]) : ee(e, [
        1
      ].concat(r));
    } else if (n === 4) {
      if (t === "channelsFirst") return r.length === 1 ? ee(e, [
        1,
        r[0],
        1,
        1
      ]) : ee(e, [
        1,
        r[2],
        r[0],
        r[1]
      ]);
      if (t === "channelsLast") return r.length === 1 ? ee(e, [
        1,
        1,
        1,
        r[0]
      ]) : ee(e, [
        1
      ].concat(r));
    } else if (n === 3) {
      if (t === "channelsFirst") return r.length === 1 ? ee(e, [
        1,
        r[0],
        1
      ]) : ee(e, [
        1,
        r[1],
        r[0]
      ]);
      if (t === "channelsLast") return r.length === 1 ? ee(e, [
        1,
        1,
        r[0]
      ]) : ee(e, [
        1
      ].concat(r));
    } else if (n < 3) return e;
    throw new j(`Unsupported input rank by biasAdd: ${e.rank}`);
  }
  function go(n, e, t) {
    return se(() => (t == null && (t = lo()), fr(t), Ce(n, k$(n.rank, e, t))));
  }
  function ZLe(n, e = 1) {
    if (e !== 1) throw new zt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);
    return kI(n);
  }
  function QLe(n) {
    return se(() => gt(n, Ce(ki(n), 1)));
  }
  function PZ(n, e, t, r) {
    return se(() => xEe(n, e, t, r));
  }
  function JLe(n) {
    return se(() => {
      const e = Ce(0.5, Z(0.2, n));
      return Xa(e, 0, 1);
    });
  }
  function Lb(n, e, t = false) {
    return t ? n() : e();
  }
  const e3e = [
    "fanIn",
    "fanOut",
    "fanAvg"
  ], t3e = [
    "normal",
    "uniform",
    "truncatedNormal"
  ];
  function n3e(n) {
    up(e3e, "FanMode", n);
  }
  function r3e(n) {
    up(t3e, "Distribution", n);
  }
  class Ds extends Tv {
    fromConfigUsesCustomObjects() {
      return false;
    }
    getConfig() {
      return {};
    }
  }
  class LZ extends Ds {
    apply(e, t) {
      return Cr(e, t);
    }
  }
  LZ.className = "Zeros";
  we(LZ);
  class YP extends Ds {
    apply(e, t) {
      return Ic(e, t);
    }
  }
  YP.className = "Ones";
  we(YP);
  class FZ extends Ds {
    constructor(e) {
      if (super(), typeof e != "object") throw new j(`Expected argument of type ConstantConfig but got ${e}`);
      if (e.value === void 0) throw new j(`config must have value set but got ${e}`);
      this.value = e.value;
    }
    apply(e, t) {
      return se(() => Z(yn(this.value), Ic(e, t)));
    }
    getConfig() {
      return {
        value: this.value
      };
    }
  }
  FZ.className = "Constant";
  we(FZ);
  class OZ extends Ds {
    constructor(e) {
      super(), this.DEFAULT_MINVAL = -0.05, this.DEFAULT_MAXVAL = 0.05, this.minval = e.minval || this.DEFAULT_MINVAL, this.maxval = e.maxval || this.DEFAULT_MAXVAL, this.seed = e.seed;
    }
    apply(e, t) {
      return xb(e, this.minval, this.maxval, t, this.seed);
    }
    getConfig() {
      return {
        minval: this.minval,
        maxval: this.maxval,
        seed: this.seed
      };
    }
  }
  OZ.className = "RandomUniform";
  we(OZ);
  class BZ extends Ds {
    constructor(e) {
      super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
    }
    apply(e, t) {
      if (t = t || "float32", t !== "float32" && t !== "int32") throw new zt(`randomNormal does not support dType ${t}.`);
      return YI(e, this.mean, this.stddev, t, this.seed);
    }
    getConfig() {
      return {
        mean: this.mean,
        stddev: this.stddev,
        seed: this.seed
      };
    }
  }
  BZ.className = "RandomNormal";
  we(BZ);
  class zZ extends Ds {
    constructor(e) {
      super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = 0.05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed;
    }
    apply(e, t) {
      if (t = t || "float32", t !== "float32" && t !== "int32") throw new zt(`truncatedNormal does not support dType ${t}.`);
      return Y9(e, this.mean, this.stddev, t, this.seed);
    }
    getConfig() {
      return {
        mean: this.mean,
        stddev: this.stddev,
        seed: this.seed
      };
    }
  }
  zZ.className = "TruncatedNormal";
  we(zZ);
  class VZ extends Ds {
    constructor(e) {
      super(), this.gain = e.gain != null ? e.gain : 1;
    }
    apply(e, t) {
      return se(() => {
        if (e.length !== 2 || e[0] !== e[1]) throw new j("Identity matrix initializer can only be used for 2D square matrices.");
        return Z(this.gain, R9(e[0]));
      });
    }
    getConfig() {
      return {
        gain: this.gain
      };
    }
  }
  VZ.className = "Identity";
  we(VZ);
  function i3e(n, e = "channelsLast") {
    let t, r;
    if (fr(e), n.length === 2) t = n[0], r = n[1];
    else if ([
      3,
      4,
      5
    ].indexOf(n.length) !== -1) {
      if (e === "channelsFirst") {
        const i = Qu(n, 2);
        t = n[1] * i, r = n[0] * i;
      } else if (e === "channelsLast") {
        const i = Qu(n, 0, n.length - 2);
        t = n[n.length - 2] * i, r = n[n.length - 1] * i;
      }
    } else {
      const i = Qu(n);
      t = Math.sqrt(i), r = Math.sqrt(i);
    }
    return [
      t,
      r
    ];
  }
  class ka extends Ds {
    constructor(e) {
      if (super(), e.scale < 0) throw new j(`scale must be a positive float. Got: ${e.scale}`);
      this.scale = e.scale == null ? 1 : e.scale, this.mode = e.mode == null ? "fanIn" : e.mode, n3e(this.mode), this.distribution = e.distribution == null ? "normal" : e.distribution, r3e(this.distribution), this.seed = e.seed;
    }
    apply(e, t) {
      const r = i3e(e), i = r[0], a = r[1];
      let s = this.scale;
      if (this.mode === "fanIn" ? s /= Math.max(1, i) : this.mode === "fanOut" ? s /= Math.max(1, a) : s /= Math.max(1, (i + a) / 2), this.distribution === "normal") {
        const o = Math.sqrt(s);
        if (t = t || "float32", t !== "float32" && t !== "int32") throw new zt(`${this.getClassName()} does not support dType ${t}.`);
        return Y9(e, 0, o, t, this.seed);
      } else {
        const o = Math.sqrt(3 * s);
        return xb(e, -o, o, t, this.seed);
      }
    }
    getConfig() {
      return {
        scale: this.scale,
        mode: this.mode,
        distribution: this.distribution,
        seed: this.seed
      };
    }
  }
  ka.className = "VarianceScaling";
  we(ka);
  class qP extends ka {
    constructor(e) {
      super({
        scale: 1,
        mode: "fanAvg",
        distribution: "uniform",
        seed: e == null ? null : e.seed
      });
    }
    getClassName() {
      return ka.className;
    }
  }
  qP.className = "GlorotUniform";
  we(qP);
  class jP extends ka {
    constructor(e) {
      super({
        scale: 1,
        mode: "fanAvg",
        distribution: "normal",
        seed: e == null ? null : e.seed
      });
    }
    getClassName() {
      return ka.className;
    }
  }
  jP.className = "GlorotNormal";
  we(jP);
  class KP extends ka {
    constructor(e) {
      super({
        scale: 2,
        mode: "fanIn",
        distribution: "normal",
        seed: e == null ? null : e.seed
      });
    }
    getClassName() {
      return ka.className;
    }
  }
  KP.className = "HeNormal";
  we(KP);
  class ZP extends ka {
    constructor(e) {
      super({
        scale: 2,
        mode: "fanIn",
        distribution: "uniform",
        seed: e == null ? null : e.seed
      });
    }
    getClassName() {
      return ka.className;
    }
  }
  ZP.className = "HeUniform";
  we(ZP);
  class QP extends ka {
    constructor(e) {
      super({
        scale: 1,
        mode: "fanIn",
        distribution: "normal",
        seed: e == null ? null : e.seed
      });
    }
    getClassName() {
      return ka.className;
    }
  }
  QP.className = "LeCunNormal";
  we(QP);
  class JP extends ka {
    constructor(e) {
      super({
        scale: 1,
        mode: "fanIn",
        distribution: "uniform",
        seed: e == null ? null : e.seed
      });
    }
    getClassName() {
      return ka.className;
    }
  }
  JP.className = "LeCunUniform";
  we(JP);
  class WZ extends Ds {
    constructor(e) {
      super(), this.DEFAULT_GAIN = 1, this.ELEMENTS_WARN_SLOW = 2e3, this.gain = e.gain == null ? this.DEFAULT_GAIN : e.gain, this.seed = e.seed;
    }
    apply(e, t) {
      return se(() => {
        if (e.length < 2) throw new zt("Shape must be at least 2D.");
        if (t !== "int32" && t !== "float32" && t !== void 0) throw new TypeError(`Unsupported data type ${t}.`);
        t = t;
        const r = X(e.slice(0, -1)), i = e[e.length - 1], a = r * i;
        a > this.ELEMENTS_WARN_SLOW && console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);
        const s = [
          Math.max(i, r),
          Math.min(i, r)
        ], o = YI(s, 0, 1, t, this.seed), l = gMe.qr(o, false);
        let u = l[0];
        const h = l[1].flatten().stridedSlice([
          0
        ], [
          Math.min(i, r) * Math.min(i, r)
        ], [
          Math.min(i, r) + 1
        ]);
        return u = Z(u, h.sign()), r < i && (u = u.transpose()), Z(yn(this.gain), u.reshape(e));
      });
    }
    getConfig() {
      return {
        gain: this.gain,
        seed: this.seed
      };
    }
  }
  WZ.className = "Orthogonal";
  we(WZ);
  const H4 = {
    constant: "Constant",
    glorotNormal: "GlorotNormal",
    glorotUniform: "GlorotUniform",
    heNormal: "HeNormal",
    heUniform: "HeUniform",
    identity: "Identity",
    leCunNormal: "LeCunNormal",
    leCunUniform: "LeCunUniform",
    ones: "Ones",
    orthogonal: "Orthogonal",
    randomNormal: "RandomNormal",
    randomUniform: "RandomUniform",
    truncatedNormal: "TruncatedNormal",
    varianceScaling: "VarianceScaling",
    zeros: "Zeros"
  };
  function X4(n, e = {}) {
    return Eb(n, ms.getMap().classNameMap, e, "initializer");
  }
  function tr(n) {
    return UP(n);
  }
  function Kn(n) {
    if (typeof n == "string") {
      const e = n in H4 ? H4[n] : n;
      if (e === "GlorotNormal") return new jP();
      if (e === "GlorotUniform") return new qP();
      if (e === "HeNormal") return new KP();
      if (e === "HeUniform") return new ZP();
      if (e === "LeCunNormal") return new QP();
      if (e === "LeCunUniform") return new JP();
      {
        const t = {};
        return t.className = e, t.config = {}, X4(t);
      }
    } else return n instanceof Ds ? n : X4(n);
  }
  function T$(n) {
    return Array.isArray(n) && Array.isArray(n[0]);
  }
  function PS(n) {
    return n.length === 0 ? [] : Array.isArray(n[0]) ? n : [
      n
    ];
  }
  function St(n) {
    let e;
    if (Array.isArray(n)) {
      if (n.length !== 1) throw new j(`Expected Tensor length to be 1; got ${n.length}`);
      e = n[0];
    } else e = n;
    return e;
  }
  function dn(n) {
    if (Array.isArray(n) && Array.isArray(n[0])) {
      if (n.length === 1) return n = n, n[0];
      throw new j(`Expected exactly 1 Shape; got ${n.length}`);
    } else return n;
  }
  function LS(n) {
    let e = 0;
    for (const t of n) t.shape.length === 0 ? e += 1 : e += t.shape.reduce((r, i) => r * i);
    return e;
  }
  const Y4 = "Variable";
  class a3e {
    constructor(e, t = "float32", r = Y4, i = true, a = null) {
      this.dtype = t ?? "float32", this.shape = e.shape, this.id = DZ(), r = r ?? Y4, this.originalName = $Z(r), this.name = NZ(this.originalName), this.trainable_ = i, this.constraint = a, this.val = gEe(e, this.trainable_, this.name, this.dtype);
    }
    read() {
      return this.assertNotDisposed(), this.val;
    }
    write(e) {
      return this.assertNotDisposed(), s3e(this.val, e), this.val.id !== e.id && (this.val.assign(e), this.constraint != null && this.val.assign(this.constraint.apply(this.val))), this;
    }
    dispose() {
      this.assertNotDisposed(), this.val.dispose();
    }
    assertNotDisposed() {
      if (this.val.isDisposed) throw new Error(`LayersVariable ${this.name} is already disposed.`);
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(e) {
      this.trainable_ = e, this.val.trainable = e;
    }
  }
  function s3e(n, e) {
    if (n.shape.toString() !== e.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(n.shape) + " vs. " + JSON.stringify(e.shape));
  }
  function A$(n) {
    return n.map((e) => e.read());
  }
  function eL(n) {
    n.forEach((e) => {
      e[0].write(e[1]);
    });
  }
  class Ar {
    constructor(e) {
      this.dtype = e.dtype, this.shape = e.shape, e.shape != null ? this.ndim = e.shape.length : this.ndim = e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {};
    }
  }
  class sl {
    constructor(e, t, r, i, a, s, o) {
      this.dtype = e, this.shape = t, this.sourceLayer = r, this.inputs = i, this.callArgs = a, this.outputTensorIndex = o, this.id = DZ(), s != null && (this.originalName = $Z(s), this.name = NZ(this.originalName)), this.rank = t.length;
    }
  }
  let o3e = 0;
  class qI {
    constructor(e, t) {
      this.callArgs = t, this.id = o3e++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;
      for (const r of e.inboundLayers) r == null ? void 0 : r.outboundNodes.push(this);
      e.outboundLayer.inboundNodes.push(this);
    }
    getConfig() {
      const e = [];
      for (const t of this.inboundLayers) t != null ? e.push(t.name) : e.push(null);
      return {
        outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
        inboundLayers: e,
        nodeIndices: this.nodeIndices,
        tensorIndices: this.tensorIndices
      };
    }
  }
  let l3e = 0;
  class qt extends Tv {
    constructor(e = {}) {
      super(), this._callHook = null, this._addedWeightNames = [], this._stateful = false, this.id = l3e++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = false, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = false, this.inboundNodes = [], this.outboundNodes = [];
      let t = e.name;
      if (!t) {
        const r = this.getClassName();
        t = Il(r) + "_" + XI(r);
      }
      if (this.name = t, this.trainable_ = e.trainable == null ? true : e.trainable, e.inputShape != null || e.batchInputShape != null) {
        let r;
        if (e.batchInputShape != null) r = e.batchInputShape;
        else if (e.inputShape != null) {
          let a = null;
          e.batchSize != null && (a = e.batchSize), r = [
            a
          ].concat(e.inputShape);
        }
        this.batchInputShape = r;
        let i = e.dtype;
        i == null && (i = e.inputDType), i == null && (i = "float32"), this.dtype = i;
      }
      e.weights != null ? this.initialWeights = e.weights : this.initialWeights = null, this._refCount = null, this.fastWeightInitDuringBuild = false;
    }
    static nodeKey(e, t) {
      return e.name + "_ib-" + t.toString();
    }
    getNodeAtIndex(e, t) {
      if (this.inboundNodes.length === 0) throw new ys(`The layer has never been called and thus has no defined ${t}.`);
      if (this.inboundNodes.length <= e) throw new j(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
      return this.inboundNodes[e];
    }
    getInputAt(e) {
      return Yi(this.getNodeAtIndex(e, "input").inputTensors);
    }
    getOutputAt(e) {
      return Yi(this.getNodeAtIndex(e, "output").outputTensors);
    }
    get input() {
      if (this.inboundNodes.length > 1) throw new Eo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
      if (this.inboundNodes.length === 0) throw new Eo(`Layer ${this.name} is not connected, no input to return.`);
      return Yi(this.getNodeAtIndex(0, "input").inputTensors);
    }
    get output() {
      if (this.inboundNodes.length === 0) throw new Eo(`Layer ${this.name} has no inbound nodes.`);
      if (this.inboundNodes.length > 1) throw new Eo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
      return Yi(this.getNodeAtIndex(0, "output").outputTensors);
    }
    get losses() {
      return this._losses;
    }
    calculateLosses() {
      return this.losses.map((e) => e());
    }
    get updates() {
      return this._updates;
    }
    get built() {
      return this._built;
    }
    set built(e) {
      this._built = e;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(e) {
      this._trainableWeights.forEach((t) => t.trainable = e), this.trainable_ = e;
    }
    get trainableWeights() {
      return this.trainable_ ? this._trainableWeights.filter((e) => e.trainable) : [];
    }
    set trainableWeights(e) {
      this._trainableWeights = e;
    }
    get nonTrainableWeights() {
      return this.trainable ? this._trainableWeights.filter((e) => !e.trainable).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
    }
    set nonTrainableWeights(e) {
      this._nonTrainableWeights = e;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    get stateful() {
      return this._stateful;
    }
    resetStates() {
      if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
    }
    assertInputCompatibility(e) {
      const t = In(e);
      if (this.inputSpec == null || this.inputSpec.length === 0) return;
      const r = In(this.inputSpec);
      if (t.length !== r.length) throw new j(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);
      for (let i = 0; i < t.length; i++) {
        const a = t[i], s = r[i];
        if (s == null) continue;
        const o = a.rank;
        if (s.ndim != null && o !== s.ndim) throw new j(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${o}`);
        if (s.maxNDim != null && o > s.maxNDim) throw new j(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${o}`);
        if (s.minNDim != null && o < s.minNDim) throw new j(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${o}.`);
        if (s.dtype != null && a.dtype !== s.dtype) throw new j(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${a.dtype}.`);
        if (s.axes) {
          const l = a.shape;
          for (const u in s.axes) {
            const c = Number(u), h = s.axes[u], d = c >= 0 ? l[c] : l[l.length + c];
            if (h != null && [
              h,
              null
            ].indexOf(d) === -1) throw new j(`Input ${i} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`);
          }
        }
        if (s.shape != null) for (let l = 0; l < s.shape.length; ++l) {
          const u = s.shape[l], c = a.shape[l];
          if (u != null && c != null && u !== c) throw new j(`Input ${i} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${a.shape}.`);
        }
      }
    }
    call(e, t) {
      return e;
    }
    invokeCallHook(e, t) {
      this._callHook != null && this._callHook(e, t);
    }
    setCallHook(e) {
      this._callHook = e;
    }
    clearCallHook() {
      this._callHook = null;
    }
    apply(e, t) {
      t = t || {}, this.assertNotDisposed();
      const r = In(e), i = h3e(e), a = d3e(e);
      if (i === a) throw new j("Arguments to apply() must be all SymbolicTensors or all Tensors");
      return ad(this.name, () => {
        if (!this.built) {
          this.assertInputCompatibility(e);
          const s = [];
          for (const o of In(e)) s.push(o.shape);
          this.build(Yi(s)), this.built = true, this.initialWeights && this.setWeights(this.initialWeights), this._refCount === null && a && (this._refCount = 1);
        }
        if (this.assertInputCompatibility(e), a) {
          let s = this.call(e, t);
          this.supportsMasking && this.setMaskMetadata(e, s);
          const o = In(s), l = [];
          for (let u of o) r.indexOf(u) !== -1 && (u = u.clone()), l.push(u);
          if (s = Yi(l), this.activityRegularizer != null) throw new zt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return s;
        } else {
          const s = u3e(e), o = this.computeOutputShape(s);
          let l;
          const u = c3e(e);
          if (this.warnOnIncompatibleInputShape(Array.isArray(e) ? s[0] : s), o != null && o.length > 0 && Array.isArray(o[0]) ? l = o.map((c, h) => new sl(u, c, this, In(e), t, this.name, h)) : l = new sl(u, o, this, In(e), t, this.name), this.addInboundNode(e, l, null, null, s, o, t), this._refCount++, this.activityRegularizer != null) throw new zt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return l;
        }
      });
    }
    warnOnIncompatibleInputShape(e) {
      if (this.batchInputShape != null) if (e.length !== this.batchInputShape.length) console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
      else {
        let t = false;
        this.batchInputShape.forEach((r, i) => {
          r != null && e[i] != null && e[i] !== r && (t = true);
        }), t && console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
      }
    }
    get outputShape() {
      if (this.inboundNodes == null || this.inboundNodes.length === 0) throw new Eo(`The layer ${this.name} has never been called and thus has no defined output shape.`);
      const e = [];
      for (const t of this.inboundNodes) {
        const r = JSON.stringify(t.outputShapes);
        e.indexOf(r) === -1 && e.push(r);
      }
      if (e.length === 1) {
        const t = this.inboundNodes[0].outputShapes;
        return Array.isArray(t) && Array.isArray(t[0]) && t.length === 1 ? t[0] : t;
      } else throw new Eo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
    }
    countParams() {
      if (!this.built) throw new ys(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
      return LS(this.weights);
    }
    build(e) {
      this.built = true;
    }
    getWeights(e = false) {
      return A$(e ? this.trainableWeights : this.weights);
    }
    setWeights(e) {
      se(() => {
        const t = this.weights;
        if (t.length !== e.length) throw new j(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);
        if (t.length === 0) return;
        const r = [], i = A$(t);
        for (let a = 0; a < i.length; ++a) {
          const s = i[a], o = t[a], l = e[a];
          if (!Jt(s.shape, l.shape)) throw new j(`Layer weight shape ${s.shape} not compatible with provided weight shape ${l.shape}`);
          r.push([
            o,
            l
          ]);
        }
        eL(r);
      });
    }
    addWeight(e, t, r, i, a, s, o, l) {
      if (this._addedWeightNames.indexOf(e) !== -1) throw new j(`Duplicate weight name ${e} for layer ${this.name}`);
      this._addedWeightNames.push(e), r == null && (r = "float32"), this.fastWeightInitDuringBuild && (i = l != null ? l() : Kn("zeros"));
      const u = i.apply(t, r), c = new a3e(u, r, e, s, o);
      return u.dispose(), a != null && this.addLoss(() => a.apply(c.read())), s == null && (s = true), s ? this._trainableWeights.push(c) : this._nonTrainableWeights.push(c), c;
    }
    setFastWeightInitDuringBuild(e) {
      this.fastWeightInitDuringBuild = e;
    }
    addLoss(e) {
      e == null || Array.isArray(e) && e.length === 0 || (e = In(e), this._losses !== void 0 && this._losses !== null && this.losses.push(...e));
    }
    computeOutputShape(e) {
      return e;
    }
    computeMask(e, t) {
      if (!this.supportsMasking) {
        if (t != null) if (Array.isArray(t)) t.forEach((r) => {
          if (r != null) throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
        });
        else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
        return null;
      }
      return t;
    }
    setMaskMetadata(e, t, r) {
      if (!this.supportsMasking) return;
      const i = this.computeMask(e, r), a = In(t), s = In(i);
      if (a.length !== s.length) throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);
      for (let o = 0; o < a.length; o++) a[o].kerasMask = s[o];
    }
    addInboundNode(e, t, r, i, a, s, o = null) {
      const l = In(e);
      t = In(t), r = In(r), i = In(i), a = PS(a), s = PS(s);
      const u = [], c = [], h = [];
      for (const d of l) u.push(d.sourceLayer), c.push(d.nodeIndex), h.push(d.tensorIndex);
      new qI({
        outboundLayer: this,
        inboundLayers: u,
        nodeIndices: c,
        tensorIndices: h,
        inputTensors: l,
        outputTensors: t,
        inputMasks: r,
        outputMasks: i,
        inputShapes: a,
        outputShapes: s
      }, o);
      for (let d = 0; d < t.length; d++) t[d].sourceLayer = this, t[d].nodeIndex = this.inboundNodes.length - 1, t[d].tensorIndex = d;
    }
    getConfig() {
      const e = {
        name: this.name,
        trainable: this.trainable
      };
      return this.batchInputShape != null && (e.batchInputShape = this.batchInputShape), this.dtype != null && (e.dtype = this.dtype), e;
    }
    disposeWeights() {
      return this.weights.forEach((e) => e.dispose()), this.weights.length;
    }
    assertNotDisposed() {
      if (this._refCount === 0) throw new Error(`Layer '${this.name}' is already disposed.`);
    }
    dispose() {
      if (!this.built) throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
      if (this._refCount === null) throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
      this.assertNotDisposed();
      let e = 0;
      return --this._refCount === 0 && (e = this.disposeWeights()), {
        refCountAfterDispose: this._refCount,
        numDisposedVariables: e
      };
    }
  }
  function u3e(n) {
    n = In(n);
    const e = [];
    for (const t of n) e.push(t.shape);
    return Yi(e);
  }
  function c3e(n) {
    return "float32";
  }
  function GZ(n, e, t) {
    if ((e == null || t != null && t > 0) && (e = n.sourceLayer, t = n.nodeIndex), e.inboundNodes.length === 0) return [
      n
    ];
    {
      const r = e.inboundNodes[t];
      if (r.inboundLayers.length === 0) return r.inputTensors;
      {
        const i = [];
        for (let a = 0; a < r.inboundLayers.length; a++) {
          const s = r.inputTensors[a], o = r.inboundLayers[a], l = r.nodeIndices[a], u = GZ(s, o, l);
          for (const c of u) i.indexOf(c) === -1 && i.push(c);
        }
        return i;
      }
    }
  }
  function h3e(n) {
    let e = true;
    for (const t of In(n)) if (!(t instanceof sl)) {
      e = false;
      break;
    }
    return e;
  }
  function d3e(n) {
    let e = true;
    for (const t of In(n)) if (t instanceof sl) {
      e = false;
      break;
    }
    return e;
  }
  class Fb extends qt {
    constructor(e) {
      if (super({
        dtype: e.dtype,
        name: e.name != null ? e.name : XI("input").toString()
      }), e.batchSize == null && (e.batchSize = null), e.sparse == null && (e.sparse = false), this.trainable = false, this.built = true, this.sparse = e.sparse, e.inputShape != null && e.batchInputShape != null) throw new j("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
      let t = e.batchInputShape;
      if (t == null) {
        if (e.inputShape == null) throw new j("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
        t = [
          e.batchSize
        ].concat(e.inputShape);
      } else if (e.batchSize != null) throw new j("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
      const r = e.dtype || "float32";
      this.batchInputShape = t, this.dtype = r, this.inputSpec = [
        {
          shape: t
        }
      ];
      const i = new sl(this.dtype, this.batchInputShape, this, [], {}, this.name);
      i.nodeIndex = 0, i.tensorIndex = 0, new qI({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: [
          i
        ],
        outputTensors: [
          i
        ],
        inputMasks: [
          null
        ],
        outputMasks: [
          null
        ],
        inputShapes: [
          t
        ],
        outputShapes: [
          t
        ]
      });
    }
    apply(e, t) {
      throw new j(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
    }
    dispose() {
      return {
        refCountAfterDispose: this._refCount,
        numDisposedVariables: 0
      };
    }
    getConfig() {
      return {
        batchInputShape: this.batchInputShape,
        dtype: this.dtype,
        sparse: this.sparse,
        name: this.name
      };
    }
  }
  Fb.className = "InputLayer";
  we(Fb);
  function f3e(n) {
    if (n.batchShape == null && n.shape == null) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
    if (n.batchShape != null && n.shape != null) throw new j("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
    let e = n.batchShape;
    n.shape != null && e == null && (e = [
      null
    ].concat(n.shape));
    let t = n.dtype;
    return t == null && (t = "float32"), new Fb({
      batchInputShape: e,
      name: n.name,
      dtype: t,
      sparse: n.sparse
    }).inboundNodes[0].outputTensors[0];
  }
  function p3e(n, e) {
    if (n.dtype == null || n.dtype === e.dtype) return e;
    try {
      return Ve(e, n.dtype);
    } catch {
      throw new j(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`);
    }
  }
  class Wu {
    constructor(e) {
      if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof Wu) for (const t in e.id2Value) this.id2Value[t] = e.id2Value[t], t in e.id2Mask && (this.id2Mask[t] = e.id2Mask[t]);
      else {
        if (e == null) return;
        for (const t of e) this.add(t.key, t.value);
      }
    }
    add(e, t, r) {
      if (this.id2Value[e.id] == null) this.id2Value[e.id] = p3e(e, t), this.name2Id[e.name] = e.id, r != null && (this.id2Mask[e.id] = r);
      else throw new j(`Duplicate key: name=${e.name}, id=${e.id}`);
      return this;
    }
    addFeed(e) {
      this.add(e.key, e.value);
    }
    hasKey(e) {
      return this.id2Value[e.id] != null;
    }
    names() {
      return Object.keys(this.name2Id);
    }
    getValue(e) {
      if (e instanceof sl) {
        if (this.id2Value[e.id] == null) throw new j(`Nonexistent key: ${e.name}`);
        return this.id2Value[e.id];
      } else {
        const t = this.name2Id[e];
        if (t == null) throw new j(`Feed dict has no SymbolicTensor name: ${e}`);
        return this.id2Value[t];
      }
    }
    getMask(e) {
      if (e instanceof sl) {
        if (this.id2Value[e.id] == null) throw new j(`Nonexistent key: ${e.name}`);
        return this.id2Mask[e.id];
      } else {
        const t = this.name2Id[e];
        if (t == null) throw new j(`Feed dict has no SymbolicTensor name: ${e}`);
        return this.id2Mask[t];
      }
    }
    disposeMasks() {
      this.id2Mask != null && jt(this.id2Mask);
    }
  }
  const FS = new kZ(), OS = new kZ();
  function g3e(n) {
    FS == null ? void 0 : FS.setMaxEntries(n), OS == null ? void 0 : OS.setMaxEntries(n);
  }
  function Uy(n, e, t, r) {
    const i = t == null ? false : t.training, a = Array.isArray(n), s = a ? n : [
      n
    ], o = s.map((p) => p.name), l = [], u = e.names();
    for (const p of o) u.indexOf(p) !== -1 ? l.push(e.getValue(p)) : l.push(null);
    const c = o.join(",") + "|" + e.names().sort().join(",");
    let h = FS.get(c), d;
    if (h == null) {
      const p = m3e(s, e);
      h = p.sorted, d = p.recipientCounts, FS.put(c, h), OS.put(c, d);
    }
    d = {}, i || Object.assign(d, OS.get(c));
    const f = new Wu(e);
    for (let p = 0; p < h.length; ++p) {
      const g = h[p], m = g.sourceLayer;
      if (m instanceof Fb) continue;
      const v = [], y = [], x = [];
      let b = false;
      for (const C of g.inputs) {
        const T = f.getValue(C), k = f.getMask(C);
        v.push(T), y.push(k), k != null && (b = true), i || (d[C.name]--, d[C.name] === 0 && !e.hasKey(C) && o.indexOf(C.name) === -1 && !T.isDisposed && C.sourceLayer.stateful !== true && x.push(T));
      }
      b && (t = t || {}, t.mask = y[0]);
      const w = In(m.apply(v, t));
      let _ = null;
      m.supportsMasking && (_ = m.computeMask(v, y));
      const S = y3e(g), I = Array.isArray(S) ? S : [
        S
      ];
      for (let C = 0; C < I.length; ++C) {
        f.hasKey(I[C]) || f.add(I[C], w[C], Array.isArray(_) ? _[0] : _);
        const T = o.indexOf(I[C].name);
        T !== -1 && (l[T] = w[C]);
      }
      i || jt(x);
    }
    return f.disposeMasks(), a ? l : l[0];
  }
  function m3e(n, e) {
    B(n != null && n.length > 0, () => "Expected at least one fetch, got none");
    let t = [], r = {};
    if (n.length === 1) {
      const i = q4(n[0], e);
      t = i.sorted, r = i.recipientMap;
    } else {
      const i = /* @__PURE__ */ new Set();
      for (const a of n) {
        const { sorted: s, recipientMap: o } = q4(a, e);
        for (const l of s) i.has(l.name) || (t.push(l), i.add(l.name));
        for (const l in o) r[l] == null && (r[l] = /* @__PURE__ */ new Set()), o[l].forEach((u) => r[l].add(u));
      }
    }
    return {
      sorted: t,
      recipientCounts: v3e(r)
    };
  }
  function v3e(n) {
    const e = {};
    for (const t in n) e[t] = n[t].size;
    return e;
  }
  function q4(n, e) {
    const t = /* @__PURE__ */ new Set(), r = [], i = {};
    for (const o of e.names()) t.add(o);
    const a = [], s = [];
    for (a.push(n); a.length > 0; ) {
      const o = a[a.length - 1];
      if (t.has(o.name)) {
        a.pop();
        continue;
      }
      const l = s[s.length - 1] === a.length - 1;
      if (o.inputs.length === 0 || l) a.pop(), r.push(o), t.add(o.name), l && s.pop();
      else {
        s.push(a.length - 1);
        for (const u of o.inputs) i[u.name] == null && (i[u.name] = /* @__PURE__ */ new Set()), i[u.name].add(o.name), !t.has(u.name) && a.push(u);
      }
    }
    return {
      sorted: r,
      recipientMap: i
    };
  }
  function y3e(n) {
    let e;
    if (n.sourceLayer.inboundNodes.length === 1) e = n.sourceLayer.output;
    else {
      let t = null;
      for (let r = 0; r < n.sourceLayer.inboundNodes.length; ++r) for (const i of n.sourceLayer.inboundNodes[r].outputTensors) if (i.id === n.id) {
        t = r;
        break;
      }
      e = n.sourceLayer.getOutputAt(t);
    }
    return e;
  }
  const x3e = ne();
  x3e.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", () => 100, g3e);
  function tL(n, e) {
    return se(() => mi(ct(Z(n, n), e, true)));
  }
  class Ob extends Tv {
    getConfig() {
      return {};
    }
  }
  class UZ extends Ob {
    constructor(e) {
      super(), this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = e.maxValue != null ? e.maxValue : this.defaultMaxValue, this.axis = e.axis != null ? e.axis : this.defaultAxis;
    }
    apply(e) {
      return se(() => {
        const t = tL(e, this.axis), r = Xa(t, 0, this.maxValue);
        return Z(e, gt(r, Ce(Tr(), t)));
      });
    }
    getConfig() {
      return {
        maxValue: this.maxValue,
        axis: this.axis
      };
    }
  }
  UZ.className = "MaxNorm";
  we(UZ);
  class HZ extends Ob {
    constructor(e) {
      super(), this.defaultAxis = 0, this.axis = e.axis != null ? e.axis : this.defaultAxis;
    }
    apply(e) {
      return se(() => gt(e, Ce(Tr(), tL(e, this.axis))));
    }
    getConfig() {
      return {
        axis: this.axis
      };
    }
  }
  HZ.className = "UnitNorm";
  we(HZ);
  class XZ extends Ob {
    apply(e) {
      return lp(e);
    }
  }
  XZ.className = "NonNeg";
  we(XZ);
  class YZ extends Ob {
    constructor(e) {
      super(), this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = e.minValue != null ? e.minValue : this.defaultMinValue, this.maxValue = e.maxValue != null ? e.maxValue : this.defaultMaxValue, this.rate = e.rate != null ? e.rate : this.defaultRate, this.axis = e.axis != null ? e.axis : this.defaultAxis;
    }
    apply(e) {
      return se(() => {
        const t = tL(e, this.axis), r = Ce(Z(this.rate, Xa(t, this.minValue, this.maxValue)), Z(1 - this.rate, t));
        return Z(e, gt(r, Ce(Tr(), t)));
      });
    }
    getConfig() {
      return {
        minValue: this.minValue,
        maxValue: this.maxValue,
        rate: this.rate,
        axis: this.axis
      };
    }
  }
  YZ.className = "MinMaxNorm";
  we(YZ);
  const j4 = {
    maxNorm: "MaxNorm",
    minMaxNorm: "MinMaxNorm",
    nonNeg: "NonNeg",
    unitNorm: "UnitNorm"
  };
  function $r(n) {
    return UP(n);
  }
  function K4(n, e = {}) {
    return Eb(n, ms.getMap().classNameMap, e, "constraint");
  }
  function Nr(n) {
    if (n == null) return null;
    if (typeof n == "string") {
      const t = {
        className: n in j4 ? j4[n] : n,
        config: {}
      };
      return K4(t);
    } else return n instanceof Ob ? n : K4(n);
  }
  async function uh(n) {
    if (n == null) return;
    const e = [], t = [], r = [];
    for (const i in n) {
      const a = n[i];
      if (typeof a != "number") {
        const s = a;
        e.push(s.data()), t.push(i), r.push(s);
      }
    }
    if (e.length > 0) {
      const i = await Promise.all(e);
      for (let a = 0; a < i.length; ++a) n[t[a]] = i[a][0];
      jt(r);
    }
  }
  function qZ(n) {
    if (n != null) for (const e in n) {
      const t = n[e];
      typeof t != "number" && t.dispose();
    }
  }
  var Z4;
  (function(n) {
    n[n.SILENT = 0] = "SILENT", n[n.VERBOSE = 1] = "VERBOSE";
  })(Z4 || (Z4 = {}));
  const b3e = 125;
  class ux {
    constructor() {
      this.validationData = null;
    }
    setParams(e) {
      this.params = e;
    }
    async onEpochBegin(e, t) {
    }
    async onEpochEnd(e, t) {
    }
    async onBatchBegin(e, t) {
    }
    async onBatchEnd(e, t) {
    }
    async onTrainBegin(e) {
    }
    async onTrainEnd(e) {
    }
    setModel(e) {
    }
  }
  class w3e {
    constructor(e, t = 10) {
      e == null && (e = []), this.callbacks = e, this.queueLength = t;
    }
    append(e) {
      this.callbacks.push(e);
    }
    setParams(e) {
      for (const t of this.callbacks) t.setParams(e);
    }
    setModel(e) {
      for (const t of this.callbacks) t.setModel(e);
    }
    async onEpochBegin(e, t) {
      t == null && (t = {});
      for (const r of this.callbacks) await r.onEpochBegin(e, t);
    }
    async onEpochEnd(e, t) {
      t == null && (t = {});
      for (const r of this.callbacks) await r.onEpochEnd(e, t);
    }
    async onBatchBegin(e, t) {
      t == null && (t = {});
      for (const r of this.callbacks) await r.onBatchBegin(e, t);
    }
    async onBatchEnd(e, t) {
      t == null && (t = {});
      for (const r of this.callbacks) await r.onBatchEnd(e, t);
    }
    async onTrainBegin(e) {
      e == null && (e = {});
      for (const t of this.callbacks) await t.onTrainBegin(e);
    }
    async onTrainEnd(e) {
      e == null && (e = {});
      for (const t of this.callbacks) await t.onTrainEnd(e);
    }
  }
  class _3e extends ux {
    constructor() {
      super();
    }
    async onEpochBegin(e) {
      this.seen = 0, this.totals = {};
    }
    async onBatchEnd(e, t) {
      t == null && (t = {});
      const r = t.size == null ? 0 : t.size;
      this.seen += r;
      for (const i in t) {
        const a = t[i];
        if (typeof a == "number") this.totals.hasOwnProperty(i) || (this.totals[i] = 0), this.totals[i] = this.totals[i] + a * r;
        else {
          let s;
          i in this.totals ? s = this.totals[i] : this.totals[i] = 0;
          const o = se(() => Ce(this.totals[i], Z(a, r)));
          this.totals[i] = o, s == null ? void 0 : s.dispose();
        }
      }
    }
    async onEpochEnd(e, t) {
      if (t != null) for (const r of this.params.metrics) this.totals[r] != null && (typeof this.totals[r] == "number" ? t[r] = this.totals[r] / this.seen : se(() => {
        const i = Z(gt(1, this.seen), this.totals[r]);
        t[r] = i, this.totals[r].dispose(), qo(t[r]);
      }));
    }
  }
  class S3e extends ux {
    async onTrainBegin(e) {
      this.epoch = [], this.history = {};
    }
    async onEpochEnd(e, t) {
      t == null && (t = {}), this.epoch.push(e);
      for (const r in t) this.history[r] == null && (this.history[r] = []), this.history[r].push(t[r]);
    }
    async syncData() {
      const e = [], t = [], r = [];
      for (const a in this.history) {
        const s = this.history[a];
        for (let o = 0; o < s.length; ++o) if (typeof s[o] != "number") {
          const l = s[o];
          e.push(l.data()), t.push(a), r.push(o);
        }
      }
      const i = await Promise.all(e);
      for (let a = 0; a < i.length; ++a) this.history[t[a]][r[a]].dispose(), this.history[t[a]][r[a]] = i[a][0];
    }
  }
  class C3e extends ux {
    constructor(e, t) {
      if (super(), this.currentEpoch = 0, this.nowFunc = e.nowFunc, this.nextFrameFunc = e.nextFrameFunc || dZ, this.yieldEvery = t || "auto", this.yieldEvery === "auto" && (this.yieldEvery = b3e), this.yieldEvery === "never" && e.onYield != null) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
      o$(this.yieldEvery) && (this.maybeWait = FLe(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc)), this.trainBegin = e.onTrainBegin, this.trainEnd = e.onTrainEnd, this.epochBegin = e.onEpochBegin, this.epochEnd = e.onEpochEnd, this.batchBegin = e.onBatchBegin, this.batchEnd = e.onBatchEnd, this.yield = e.onYield;
    }
    async maybeWait(e, t, r) {
      const i = [];
      this.yield != null && (await uh(r), i.push(this.yield(e, t, r))), i.push(this.nextFrameFunc()), await Promise.all(i);
    }
    async onEpochBegin(e, t) {
      this.currentEpoch = e, this.epochBegin != null && (await uh(t), await this.epochBegin(e, t));
    }
    async onEpochEnd(e, t) {
      const r = [];
      this.epochEnd != null && (await uh(t), r.push(this.epochEnd(e, t))), this.yieldEvery === "epoch" && r.push(this.nextFrameFunc()), await Promise.all(r);
    }
    async onBatchBegin(e, t) {
      this.batchBegin != null && (await uh(t), await this.batchBegin(e, t));
    }
    async onBatchEnd(e, t) {
      const r = [];
      this.batchEnd != null && (await uh(t), r.push(this.batchEnd(e, t))), this.yieldEvery === "batch" ? r.push(this.nextFrameFunc()) : o$(this.yieldEvery) && r.push(this.maybeWait(this.currentEpoch, e, t)), await Promise.all(r);
    }
    async onTrainBegin(e) {
      this.trainBegin != null && (await uh(e), await this.trainBegin(e));
    }
    async onTrainEnd(e) {
      this.trainEnd != null && (await uh(e), await this.trainEnd(e));
    }
  }
  function jZ(n, e) {
    return n == null && (n = {}), n instanceof ux ? [
      n
    ] : Array.isArray(n) && n[0] instanceof ux ? n : In(n).map((r) => new C3e(r, e));
  }
  class ls {
    constructor() {
    }
    static registerCallbackConstructor(e, t) {
      B(e >= 0 && Number.isInteger(e), () => `Verbosity level is expected to be an integer >= 0, but got ${e}`), ls.checkForDuplicate(t), ls.constructors[e] == null && (ls.constructors[e] = []), ls.constructors[e].push(t);
    }
    static checkForDuplicate(e) {
      for (const t in ls.constructors) ls.constructors[+t].forEach((i) => {
        if (i === e) throw new j("Duplicate callback constructor.");
      });
    }
    static clear() {
      ls.constructors = {};
    }
    static createCallbacks(e) {
      const t = [];
      for (const r in ls.constructors) {
        const i = +r;
        e >= i && t.push(...ls.constructors[i]);
      }
      return t.map((r) => new r());
    }
  }
  ls.constructors = {};
  function KZ(n, e, t, r, i, a, s, o, l) {
    const u = new S3e(), c = [
      new _3e(),
      ...ls.createCallbacks(e)
    ];
    n != null && c.push(...n), c.push(u);
    const h = new w3e(c);
    return h.setParams({
      epochs: t,
      initialEpoch: r,
      samples: i,
      steps: a,
      batchSize: s,
      verbose: e,
      doValidation: o,
      metrics: l
    }), {
      callbackList: h,
      history: u
    };
  }
  function zl(n, e = {}, t = false) {
    return Eb(n, ms.getMap().classNameMap, e, "layer", t);
  }
  function BS(n, e) {
    return se(() => {
      n.dtype !== "float32" && (n = Ve(n, "float32"));
      const t = ct(Pb(n), e, true), r = II(t.shape, Tr()), i = mi(Cc(t, r));
      return gt(n, i);
    });
  }
  function jI(n, e) {
    return se(() => vr(Pb(wt(e, n)), -1));
  }
  function nL(n, e) {
    return se(() => vr(ki(wt(e, n)), -1));
  }
  function rL(n, e) {
    return se(() => {
      const t = wt(n, e), r = Xa(ki(n), Tr(), Number.MAX_VALUE), i = ki(gt(t, r));
      return Z(100, vr(i, -1));
    });
  }
  function I3e(n, e) {
    return se(() => {
      const t = Xa(e, Tr(), Number.MAX_VALUE), r = al(Ce(1, t)), i = Xa(n, Tr(), Number.MAX_VALUE), a = al(Ce(1, i));
      return vr(Pb(wt(r, a)), -1);
    });
  }
  function k3e(n, e) {
    return se(() => {
      const t = Cc(0, wt(1, Z(n, e)));
      return vr(Pb(t), -1);
    });
  }
  function T3e(n, e) {
    return se(() => {
      const t = Cc(0, wt(1, Z(n, e)));
      return vr(t, -1);
    });
  }
  function A3e(n, e) {
    return se(() => {
      const t = ct(Z(n, e), -1), r = Js(Z(wt(1, n), e), -1);
      return Cc(0, Ce(1, wt(r, t)));
    });
  }
  function D3e(n, e) {
    return se(() => {
      const t = Math.log(2), r = wt(e, n), i = wt(Ce(r, yb(Z(-2, r))), t);
      return vr(i, -1);
    });
  }
  function cx(n, e, t = false) {
    return se(() => {
      if (t) e = xP(e);
      else {
        const r = ct(e, e.shape.length - 1, true);
        e = gt(e, r);
      }
      return e = Xa(e, Tr(), 1 - Tr()), cr(ct(Z(Ve(n, "float32"), al(e)), e.shape.length - 1));
    });
  }
  function zS(n, e, t = false) {
    return se(() => {
      const r = Ve(AI(jLe(n)), "int32");
      e = Xa(e, Tr(), 1 - Tr());
      const i = e.shape, a = ee(P9(r, i[i.length - 1]), i);
      return cx(a, e, t);
    });
  }
  function R3e(n, e) {
    if (!Jt(n.shape, e.shape)) throw new j(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);
    return se(() => {
      const t = lp(e), r = cr(ki(e));
      return Ce(wt(t, Z(e, n)), $9(il(r)));
    });
  }
  function KI(n, e) {
    return se(() => {
      let t;
      return t = Xa(e, Tr(), 1 - Tr()), t = al(gt(t, wt(1, t))), vr(R3e(n, t), -1);
    });
  }
  function $3e(n, e) {
    return se(() => {
      const t = Xa(n, Tr(), 1), r = Xa(e, Tr(), 1);
      return ct(Z(n, al(gt(t, r))), -1);
    });
  }
  function N3e(n, e) {
    return se(() => {
      const t = al(Ce(Tr(), e));
      return vr(wt(e, Z(n, t)), -1);
    });
  }
  function ZZ(n, e) {
    return se(() => {
      const t = BS(n, -1), r = BS(e, -1), i = Z(t, r);
      return cr(ct(i, -1));
    });
  }
  const VS = {
    meanSquaredError: jI,
    meanAbsoluteError: nL,
    meanAbsolutePercentageError: rL,
    meanSquaredLogarithmicError: I3e,
    squaredHinge: k3e,
    hinge: T3e,
    categoricalHinge: A3e,
    logcosh: D3e,
    categoricalCrossentropy: cx,
    sparseCategoricalCrossentropy: zS,
    binaryCrossentropy: KI,
    kullbackLeiblerDivergence: $3e,
    poisson: N3e,
    cosineProximity: ZZ
  };
  function hA(n) {
    if (typeof n == "string") {
      if (n in VS) return VS[n];
      let e = `Unknown loss ${n}`;
      throw n.toLowerCase().includes("softmaxcrossentropy") && (e = `Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`), new j(e);
    } else return n;
  }
  function QZ(n, e) {
    return se(() => {
      const t = Z(0.5, Cs(e)), r = jo(ja(e, t), n.dtype);
      return vr(rl(n, r), -1);
    });
  }
  function JZ(n, e) {
    return se(() => jo(rl(rx(n, -1), rx(e, -1)), "float32"));
  }
  function E3e(n, e) {
    return se(() => Ve(ct(eu(rl(n, 1), rl(e, 1))), "float32"));
  }
  function M3e(n, e) {
    return se(() => Ve(ct(eu(rl(n, 0), rl(e, 1))), "float32"));
  }
  function P3e(n, e) {
    return se(() => {
      const t = E3e(n, e), r = M3e(n, e), i = Ce(t, r);
      return Ve(Ni(ja(i, 0), gt(t, i), 0), "float32");
    });
  }
  function L3e(n, e) {
    return KI(n, e);
  }
  function F3e(n, e) {
    return n.rank === e.rank && (n = bb(n, [
      n.rank - 1
    ])), e = rx(e, -1), e.dtype !== n.dtype && (e = Ve(e, n.dtype)), Ve(rl(n, e), "float32");
  }
  const O3e = jI, B3e = jI, z3e = nL, V3e = nL, W3e = rL, G3e = rL, eQ = cx, U3e = ZZ, tQ = zS, WS = {
    binaryAccuracy: QZ,
    categoricalAccuracy: JZ,
    precision: P3e,
    categoricalCrossentropy: eQ,
    sparseCategoricalCrossentropy: tQ,
    mse: O3e,
    MSE: B3e,
    mae: z3e,
    MAE: V3e,
    mape: W3e,
    MAPE: G3e,
    cosine: U3e
  };
  function H3e(n) {
    if (typeof n == "string" && n in WS) return WS[n];
    if (typeof n != "string" && n != null) return n;
    throw new j(`Unknown metric ${n}`);
  }
  function yw(n) {
    if (Mo(n !== null, `Unknown LossOrMetricFn ${n}`), typeof n == "string") return n;
    {
      let e;
      for (const t of Object.keys(VS)) if (VS[t] === n) {
        e = t;
        break;
      }
      if (e !== void 0) return e;
      for (const t of Object.keys(WS)) if (WS[t] === n) {
        e = t;
        break;
      }
      return e !== void 0 ? e : n.name;
    }
  }
  function X3e(n) {
    const e = {
      Adagrad: () => Yp.adagrad(0.01),
      Adadelta: () => Yp.adadelta(1, 0.95, Tr()),
      Adam: () => Yp.adam(1e-3, 0.9, 0.999, Tr()),
      Adamax: () => Yp.adamax(2e-3, 0.9, 0.999, Tr(), 0),
      RMSProp: () => Yp.rmsprop(1e-3, 0.9, 0, Tr()),
      SGD: () => Yp.sgd(0.01)
    };
    if (e.adagrad = e.Adagrad, e.adadelta = e.Adadelta, e.adam = e.Adam, e.adamax = e.Adamax, e.rmsprop = e.RMSProp, e.sgd = e.SGD, n in e) return e[n]();
    throw new j(`Unknown Optimizer ${n}`);
  }
  const Q4 = 1 * 1024 * 1024;
  function J4(n, e, t = false) {
    if (n == null || typeof n != "object" || Object.getPrototypeOf(n) !== Object.prototype || !D$(n)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
    if (t) {
      const r = JSON.stringify(n);
      r.length > Q4 && console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Q4}.`);
    }
  }
  function D$(n) {
    if (n === null) return true;
    if (typeof n == "object") if (Object.getPrototypeOf(n) === Object.prototype) {
      const e = Object.keys(n);
      for (const t of e) if (typeof t != "string" || !D$(n[t])) return false;
      return true;
    } else if (Array.isArray(n)) {
      for (const e of n) if (!D$(e)) return false;
      return true;
    } else return false;
    else {
      const e = typeof n;
      return e === "string" || e === "number" || e === "boolean";
    }
  }
  function Y3e(n, e, t, r = console.log) {
    const i = j3e(n), a = [
      "Layer (type)",
      "Input Shape",
      "Output shape",
      "Param #"
    ];
    i ? (e = e || 90, t = t || [
      0.32,
      0.61,
      0.89,
      1
    ]) : (e = e || 115, t = t || [
      0.24,
      0.48,
      0.7,
      0.8,
      1
    ]), t[t.length - 1] <= 1 && (t = t.map((c) => Math.floor(e * c)));
    let s;
    if (!i) {
      a.push("Receives inputs"), s = [];
      for (const c in n.nodesByDepth) s.push(...n.nodesByDepth[c]);
    }
    r("_".repeat(e)), GS(a, t, r), r("=".repeat(e));
    const o = n.layers;
    for (let c = 0; c < o.length; ++c) i ? K3e(o[c], t, r) : Z3e(o[c], t, s, r), r((c === o.length - 1 ? "=" : "_").repeat(e));
    n.checkTrainableWeightsConsistency();
    const l = q3e(n), u = LS(n.nonTrainableWeights);
    r(`Total params: ${l + u}`), r(`Trainable params: ${l}`), r(`Non-trainable params: ${u}`), r("_".repeat(e));
  }
  function q3e(n) {
    let e;
    return n.collectedTrainableWeights != null ? e = LS(n.collectedTrainableWeights) : e = LS(n.trainableWeights), e;
  }
  function j3e(n) {
    let e = true;
    const t = [], r = [];
    for (const i in n.nodesByDepth) t.push(n.nodesByDepth[i]);
    for (const i of t) {
      if (i.length > 1 || i.length === 1 && i[0].inboundLayers.length > 1) {
        e = false;
        break;
      }
      r.push(...i);
    }
    if (e) for (const i of n.layers) {
      let a = false;
      for (const s of i.inboundNodes) if (r.indexOf(s) !== -1) if (a) {
        e = false;
        break;
      } else a = true;
      if (!e) break;
    }
    return e;
  }
  function GS(n, e, t = console.log) {
    let r = "";
    for (let i = 0; i < n.length; ++i) i > 0 && (r = r.slice(0, r.length - 1) + " "), r += n[i], r = r.slice(0, e[i]), r += " ".repeat(e[i] - r.length);
    t(r);
  }
  function K3e(n, e, t) {
    let r, i;
    try {
      i = n.inboundNodes.map((l) => JSON.stringify(l.inputShapes)).join(",");
    } catch {
      i = "multiple";
    }
    try {
      r = JSON.stringify(n.outputShape);
    } catch {
      r = "multiple";
    }
    const a = n.name, s = n.getClassName(), o = [
      `${a} (${s})`,
      i,
      r,
      n.countParams().toString()
    ];
    GS(o, e, t);
  }
  function Z3e(n, e, t, r) {
    let i, a;
    try {
      a = n.inboundNodes.map((h) => JSON.stringify(h.inputShapes)).join(",");
    } catch {
      a = "multiple";
    }
    try {
      i = JSON.stringify(n.outputShape);
    } catch {
      i = "multiple";
    }
    const s = [];
    for (const h of n.inboundNodes) if (!(t != null && t.length > 0 && t.indexOf(h) === -1)) for (let d = 0; d < h.inboundLayers.length; ++d) {
      const f = h.inboundLayers[d].name, p = h.nodeIndices[d], g = h.tensorIndices[d];
      s.push(`${f}[${p}][${g}]`);
    }
    const o = n.name, l = n.getClassName(), u = s.length === 0 ? "" : s[0], c = [
      `${o} (${l})`,
      a,
      i,
      n.countParams().toString(),
      u
    ];
    GS(c, e, r);
    for (let h = 1; h < s.length; ++h) GS([
      "",
      "",
      "",
      "",
      s[h]
    ], e, r);
  }
  function nQ(n, e, t) {
    return (n === "inboundNodes" || n === "outputLayers" || n === "inputLayers") && e === 0 && typeof t == "string";
  }
  function R$(n, e) {
    if (n === null) return null;
    if (typeof n == "string") return Nh(n);
    if (typeof n == "number" || typeof n == "boolean") return n;
    if (n instanceof Array) {
      const t = [], r = n.length;
      for (let i = 0; i < r; ++i) {
        const a = n[i];
        nQ(e, i, a) ? t.push(a) : t.push(R$(a, e));
      }
      return t;
    } else {
      const t = {};
      for (const r of Object.keys(n)) {
        const i = n[r];
        if (r === "name" && typeof i == "string") t[r] = i;
        else {
          const a = Nh(r);
          t[a] = R$(i, a);
        }
      }
      return t;
    }
  }
  function $$(n, e) {
    if (n == null) return null;
    if (typeof n == "string") return Il(n);
    if (typeof n == "number" || typeof n == "boolean") return n;
    if (n instanceof Array) {
      const t = [], r = n.length;
      for (let i = 0; i < r; ++i) {
        const a = n[i];
        nQ(e, i, a) ? t.push(a) : t.push($$(a, e));
      }
      return t;
    } else {
      const t = {};
      for (const r of Object.keys(n)) {
        const i = n[r], a = Il(r);
        (r === "name" || r === "className") && typeof i == "string" ? t[a] = i : t[a] = $$(i, r);
      }
      return t;
    }
  }
  const rQ = "4.22.0";
  const Q3e = (n) => {
    const e = Object.keys(n);
    if (e.length === 0) return false;
    const t = e[0].split("/");
    return !isNaN(parseInt(t[t.length - 1], 10));
  };
  let J3e = class To extends qt {
    constructor(e) {
      if (super({}), this.containerNodes = /* @__PURE__ */ new Set(), this.name = e.name, this.name == null) {
        const y = this.getClassName().toLowerCase();
        this.name = XI(y);
      }
      if (this.supportsMasking = false, this.trainable_ = true, Array.isArray(e.inputs) ? this.inputs = e.inputs.slice() : this.inputs = [
        e.inputs
      ], Array.isArray(e.outputs) ? this.outputs = e.outputs.slice() : this.outputs = [
        e.outputs
      ], Zu(this.inputs).length !== this.inputs.length) throw new j(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((y) => y.name)}`);
      Zu(this.outputs).length !== this.outputs.length && console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((y) => y.name)}`), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];
      for (const y of this.outputs) {
        const x = y.sourceLayer, b = y.nodeIndex, w = y.tensorIndex;
        this.outputLayers.push(x), this.outputLayersNodeIndices.push(b), this.outputLayersTensorIndices.push(w);
      }
      for (const y of this.inputs) {
        const x = y.sourceLayer, b = y.nodeIndex, w = y.tensorIndex;
        Mo(b === 0, "input layer has >1 nodes"), Mo(w === 0, "input layer has >1 tensors"), this.inputLayers.push(x), this.inputLayersNodeIndices.push(b), this.inputLayersTensorIndices.push(w);
      }
      this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];
      for (let y = 0; y < this.inputLayers.length; y++) {
        const x = this.inputLayers[y];
        if (!(x instanceof Fb)) throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${x.getClassName()}.`);
        this.inputNames.push(x.name), this.feedInputShapes.push(x.batchInputShape), this.feedInputNames.push(x.name);
      }
      for (const y of this.outputLayers) this.outputNames.push(y.name);
      this.internalInputShapes = this.inputs.map((y) => y.shape), this.internalOutputShapes = this.outputs.map((y) => y.shape);
      const t = {}, r = {}, i = {}, a = {}, s = {}, o = [], l = (y, x, b, w, _, S) => {
        (w == null || _ == null || S == null) && (w = y.sourceLayer, _ = y.nodeIndex, S = y.tensorIndex);
        const I = w.inboundNodes[_];
        if (b.indexOf(I) !== -1) throw new ys(`The tensor ${y.name} at layer "${w.name}" is part of a cycle.`);
        if (x.indexOf(I) !== -1) return;
        this.containerNodes.add(To.nodeKey(w, _)), w.id in s || (s[w.id] = Object.keys(s).length), b.indexOf(I) === -1 && b.push(I);
        const C = I.inboundLayers.length;
        for (let T = 0; T < C; T++) {
          const k = I.inputTensors[T], D = I.inboundLayers[T], R = I.nodeIndices[T], N = I.tensorIndices[T];
          l(k, x, b, D, R, N);
        }
        for (x.push(I); b.indexOf(I) >= 0; ) b.splice(b.indexOf(I), 1);
        o.push(I);
      }, u = [], c = [];
      for (const y of this.outputs) l(y, u, c);
      const h = o.slice().reverse();
      for (const y of h) {
        r[y.id] = y, y.id in t || (t[y.id] = 0);
        let x = t[y.id];
        const b = i[y.outboundLayer.id] == null ? 0 : i[y.outboundLayer.id];
        x = Math.max(x, b), i[y.outboundLayer.id] = x, a[y.outboundLayer.id] = y.outboundLayer, t[y.id] = x;
        for (let w = 0; w < y.inboundLayers.length; w++) {
          const _ = y.inboundLayers[w], S = y.nodeIndices[w], I = _.inboundNodes[S], C = t[I.id] == null ? 0 : t[I.id];
          t[I.id] = Math.max(x + 1, C), r[I.id] = I;
        }
      }
      const d = {};
      for (const y in t) {
        const x = t[y];
        x in d || (d[x] = []), d[x].push(r[y]);
      }
      const f = {};
      for (const y in i) {
        const x = i[y];
        x in f || (f[x] = []), f[x].push(a[y]);
      }
      let p = Object.keys(f).map((y) => parseInt(y, 10)).sort(gw);
      this.layers = [];
      for (const y of p) {
        const x = f[y];
        x.sort((b, w) => {
          const _ = s[b.id], S = s[w.id];
          return _ < S ? -1 : _ > S ? 1 : 0;
        });
        for (const b of x) b instanceof To && this.internalContainerRefs.push(b), this.layers.push(b);
      }
      this.layersByDepth = f, p = Object.keys(d).map((y) => parseInt(y, 10)).sort(gw);
      const g = this.inputs.slice(), m = [];
      for (const y of p) for (const x of d[y]) {
        const b = x.outboundLayer;
        if (b != null) {
          for (const w of x.inputTensors) if (g.indexOf(w) === -1) throw new ys(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${b.name}". The following previous layers were accessed without issue: ${m}`);
          for (const w of x.outputTensors) g.push(w);
          m.push(b.name);
        }
      }
      this.nodesByDepth = d;
      const v = this.layers.map((y) => y.name);
      for (const y of v) {
        const x = v.filter((b) => b === y).length;
        if (x !== 1) throw new ys(`The name "${y}" is used ${x} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(v));
      }
      this.outboundNodes = [], this.inboundNodes = [], new qI({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: this.inputs.map((y) => null),
        outputMasks: this.outputs.map((y) => null),
        inputShapes: this.inputs.map((y) => y.shape),
        outputShapes: this.outputs.map((y) => y.shape)
      }), this.built = true, this._refCount = 1;
    }
    assertNotDisposed() {
      if (this._refCount === 0) throw new Error(`Container '${this.name}' is already disposed.`);
    }
    dispose() {
      this.assertNotDisposed();
      const e = {
        refCountAfterDispose: null,
        numDisposedVariables: 0
      };
      if (--this._refCount === 0) {
        for (const t of this.layers) e.numDisposedVariables += t.dispose().numDisposedVariables;
        for (const t of this.internalContainerRefs) e.numDisposedVariables += t.dispose().numDisposedVariables;
      }
      return e.refCountAfterDispose = this._refCount, e;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(e) {
      this.layers.forEach((t) => {
        t._trainableWeights.forEach((r) => r.trainable = e);
      }), this.trainable_ = e;
    }
    get trainableWeights() {
      if (this._trainableWeights.length > 0) throw new j("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
      if (!this.trainable) return [];
      let e = [];
      for (const t of this.layers) e = e.concat(t.trainableWeights);
      return e;
    }
    get nonTrainableWeights() {
      const e = [];
      for (const t of this.layers) e.push(...t.nonTrainableWeights);
      if (!this.trainable) {
        const t = [];
        for (const r of this.layers) t.push(...r.trainableWeights);
        return t.concat(e);
      }
      return e;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    loadWeights(e, t = true) {
      const r = {};
      let i = 0;
      const a = Q3e(e);
      a && this.parseWeights(e);
      for (const o of this.layers) for (const [l, u] of o.weights.entries()) {
        const c = a ? `${u.name.split("/").slice(0, -1).join("/") + "/"}${l}` : u.originalName;
        if (r[c] != null) throw new j(`Duplicate weight name: ${c}`);
        r[c] = u, i++;
      }
      const s = [];
      for (const o in e) {
        let l = o;
        if (r[o] == null) {
          const u = o.split("/");
          l = u.slice(0, -2).concat([
            u[u.length - 1]
          ]).join("/");
        }
        if (r[l] != null) s.push([
          r[l],
          e[o]
        ]);
        else if (t) throw new j(`Provided weight data has no target variable: ${o}`);
        delete r[l];
      }
      if (t) {
        const o = [];
        for (const l in r) o.push(l);
        if (o.length > 0) throw new j(`${o.length} of ${i} weights are not set: ${o}`);
      }
      eL(s);
    }
    parseWeights(e) {
      for (const t in Object.keys(e)) {
        const r = t.split("/"), i = [
          "vars",
          "layer_checkpoint_dependencies"
        ], a = r.map((s) => s.startsWith("_") ? s.slice(1) : s).filter((s) => !i.includes(s)).join("/");
        a !== t && (e[a] = e[t], delete e[t]);
      }
    }
    updatedConfig() {
      const e = this.getConfig(), t = {};
      return t.className = this.getClassName(), t.config = e, t.kerasVersion = `tfjs-layers ${rQ}`, t.backend = "TensorFlow.js", t;
    }
    toJSON(e, t = true) {
      const r = $$(this.updatedConfig());
      return t ? JSON.stringify(r) : r;
    }
    call(e, t) {
      return se(() => {
        e = In(e);
        const r = new Wu();
        for (let i = 0; i < this.inputs.length; ++i) r.add(this.inputs[i], e[i]);
        return Uy(this.outputs, r, t);
      });
    }
    computeMask(e, t) {
      return se(() => {
        e = In(e);
        let r;
        return t == null ? r = Td(null, e.length) : r = In(t), this.runInternalGraph(e, r)[1];
      });
    }
    computeOutputShape(e) {
      const t = PS(e);
      if (t.length !== this.inputLayers.length) throw new j(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);
      const r = {};
      for (let o = 0; o < t.length; o++) {
        const l = this.inputLayers[o], u = t[o], c = l.name + "_0_0";
        r[c] = u;
      }
      const i = Object.keys(this.nodesByDepth).map((o) => parseInt(o, 10)).sort(gw);
      if (i.length > 1) for (const o of i) {
        const l = this.nodesByDepth[o];
        for (const u of l) {
          const c = u.outboundLayer;
          if (this.inputLayers.map((g) => g.id).indexOf(c.id) !== -1) continue;
          const h = [];
          for (let g = 0; g < u.inboundLayers.length; g++) {
            const m = u.inboundLayers[g], v = u.nodeIndices[g], y = u.tensorIndices[g], x = `${m.name}_${v}_${y}`, b = r[x];
            h.push(b);
          }
          const d = c.computeOutputShape(Yi(h)), f = PS(d), p = c.inboundNodes.indexOf(u);
          for (let g = 0; g < f.length; g++) {
            const m = `${c.name}_${p}_${g}`;
            r[m] = f[g];
          }
        }
      }
      const a = [], s = [];
      for (let o = 0; o < this.outputLayers.length; o++) {
        const l = this.outputLayers[o], u = this.outputLayersNodeIndices[o], c = this.outputLayersTensorIndices[o], h = `${l.name}_${u}_${c}`;
        s.push(h);
      }
      for (let o = 0; o < s.length; o++) {
        const l = s[o];
        Mo(l in r), a.push(r[l]);
      }
      return Yi(a);
    }
    runInternalGraph(e, t) {
      t == null && (t = Td(null, e.length));
      const r = {};
      for (let l = 0; l < this.inputs.length; ++l) {
        const u = this.inputs[l], c = e[l], h = t[l];
        r[u.id] = [
          c,
          h
        ];
      }
      const i = Object.keys(this.nodesByDepth).map((l) => parseInt(l, 10)).sort(gw);
      for (const l of i) {
        const u = this.nodesByDepth[l];
        for (const c of u) {
          const h = c.outboundLayer, d = c.inputTensors, f = c.outputTensors, p = new Array();
          for (const g of d) g.id in r && p.push(r[g.id]);
          if (p.length === d.length) {
            let g = {}, m, v, y, x;
            if (c.callArgs != null && (g = c.callArgs), p.length === 1) {
              const [b, w] = p[0];
              g.mask == null && (g.mask = w), y = In(h.call(b, g)), x = In(h.computeMask(b, w)), m = [
                b
              ], v = [
                w
              ];
            } else m = p.map((b) => b[0]), v = p.map((b) => b[1]), g.mask == null && (g.mask = v), y = In(h.call(m, g)), x = In(h.computeMask(m, v));
            if (h.activityRegularizer) throw new zt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
            for (let b = 0; b < f.length; ++b) {
              const w = f[b], _ = y[b], S = x[b];
              r[w.id] = [
                _,
                S
              ];
            }
          }
        }
      }
      const a = [], s = [], o = [];
      for (const l of this.outputs) {
        Mo(l.id in r, `Could not compute output ${l.name} : ${l.id}`);
        const [u, c] = r[l.id];
        o.push(u.shape), a.push(u), s.push(c);
      }
      return [
        a,
        s,
        o
      ];
    }
    buildNodeConversionMap(e) {
      const t = {};
      let r;
      for (const i of this.layers) {
        r = i instanceof To ? 1 : 0;
        for (let a = 0; a < i.inboundNodes.length; a++) {
          const s = To.nodeKey(i, a);
          this.containerNodes.has(s) && (t[s] = r, r += 1);
        }
      }
      return t;
    }
    getLayer(e, t) {
      if (t != null) return this.findLayer(t);
      if (e == null) throw new j("Provide either a layer name or layer index");
      if (typeof e == "number") return this.findLayer(e);
      for (const r of this.layers) if (r.name === e) return r;
      throw new j(`No such layer: ${e}`);
    }
    findLayer(e) {
      if (this.layers.length <= e) throw new j(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);
      return this.layers[e];
    }
    calculateLosses() {
      return se(() => {
        const e = [];
        for (const t of this.layers) for (let r = 0; r < t.inboundNodes.length; ++r) {
          const i = To.nodeKey(t, r);
          this.containerNodes.has(i) && e.push(...t.calculateLosses());
        }
        return e;
      });
    }
    getConfig() {
      const e = {
        name: this.name
      }, t = this.buildNodeConversionMap(this.layers), r = [];
      for (const s of this.layers) {
        const o = s.getClassName(), l = s.getConfig(), u = [];
        for (let h = 0; h < s.inboundNodes.length; h++) {
          const d = s.inboundNodes[h], f = To.nodeKey(s, h);
          let p = {};
          if (this.containerNodes.has(f)) {
            if (d.callArgs) try {
              JSON.stringify(d.callArgs), p = d.callArgs;
            } catch {
              console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`), p = {};
            }
            if (d.inboundLayers.length > 0) {
              const g = [];
              for (let m = 0; m < d.inboundLayers.length; m++) {
                const v = d.inboundLayers[m], y = d.nodeIndices[m], x = d.tensorIndices[m], b = To.nodeKey(v, y);
                let w = t[b];
                w == null && (w = 0), g.push([
                  v.name,
                  w,
                  x,
                  p
                ]);
              }
              u.push(g);
            }
          }
        }
        const c = {};
        c.name = s.name, c.className = o, c.config = l, c.inboundNodes = u, r.push(c);
      }
      e.layers = r;
      const i = [];
      for (let s = 0; s < this.inputLayers.length; s++) {
        const o = this.inputLayers[s], l = this.inputLayersNodeIndices[s], u = To.nodeKey(o, l);
        if (!this.containerNodes.has(u)) continue;
        let c = t[u];
        c == null && (c = 0);
        const h = this.inputLayersTensorIndices[s];
        i.push([
          o.name,
          c,
          h
        ]);
      }
      e.inputLayers = i;
      const a = [];
      for (let s = 0; s < this.outputLayers.length; s++) {
        const o = this.outputLayers[s], l = this.outputLayersNodeIndices[s], u = To.nodeKey(o, l);
        if (!this.containerNodes.has(u)) continue;
        let c = t[u];
        c == null && (c = 0);
        const h = this.outputLayersTensorIndices[s];
        a.push([
          o.name,
          c,
          h
        ]);
      }
      return e.outputLayers = a, e;
    }
    static fromConfig(e, t, r = {}, i = false) {
      const a = {}, s = {};
      function o(m, v) {
        m.name in s ? s[m.name].push(v) : s[m.name] = [
          v
        ];
      }
      function l(m, v) {
        const y = [];
        let x;
        for (const b of v) {
          const w = b[0], _ = b[1], S = b[2];
          if (x = b[3] == null ? {} : b[3], !(w in a)) {
            o(m, v);
            return;
          }
          const I = a[w];
          if (I.inboundNodes.length <= _) {
            o(m, v);
            return;
          }
          const C = I.inboundNodes[_];
          y.push(C.outputTensors[S]);
        }
        y.length > 0 && m.apply(Yi(y), x);
      }
      function u(m) {
        const v = m.name, y = zl(m, t.customObjects != null ? t.customObjects : {});
        y.setFastWeightInitDuringBuild(i), a[v] = y, m.inboundNodes.forEach((b) => {
          if (!(b instanceof Array)) throw new j(`Corrupted configuration, expected array for nodeData: ${b}`);
          o(y, b);
        });
      }
      const c = t.name, h = t.layers;
      for (const m of h) u(m);
      for (; !LLe(s); ) for (const m of h) {
        const v = a[m.name];
        if (v.name in s) {
          const y = s[v.name];
          delete s[v.name];
          for (const x of y) l(v, x);
        }
      }
      const d = [], f = [], p = t.inputLayers;
      for (const m of p) {
        const v = m[0], y = m[1], x = m[2];
        Mo(v in a);
        const w = a[v].inboundNodes[y].outputTensors;
        d.push(w[x]);
      }
      const g = t.outputLayers;
      for (const m of g) {
        const v = m[0], y = m[1], x = m[2];
        Mo(v in a);
        const w = a[v].inboundNodes[y].outputTensors;
        f.push(w[x]);
      }
      return new e({
        inputs: d,
        outputs: f,
        name: c
      });
    }
    get stateful() {
      if (this._stateful) throw new j("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
      for (const e of this.layers) if (e.stateful) return true;
      return false;
    }
    resetStates() {
      se(() => {
        this.layers.forEach((e) => {
          e.stateful && e.resetStates();
        });
      });
    }
  };
  function eFe(n, e, t) {
    const r = e.length;
    if (n == null || Array.isArray(n) && n.length === 0) return e.map((i) => null);
    if (r === 1) return Array.isArray(n) && n.length === 1 ? n : typeof n == "object" && e[0] in n ? [
      n[e[0]]
    ] : [
      n
    ];
    if (Array.isArray(n)) {
      if (n.length !== r) throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);
      return n;
    } else if (typeof n == "object" && Object.keys(n).length > 0 && typeof n[Object.keys(n)[0]] == "object") {
      const i = [];
      return e.forEach((a) => {
        a in n ? i.push(n[a]) : i.push(null);
      }), i;
    } else throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`);
  }
  function iQ(n, e) {
    return eFe(n, e, "classWeight");
  }
  async function aQ(n, e, t, r) {
    if (t != null) {
      const i = se(() => {
        if (n.shape.length === 1) return id(n);
        if (n.shape.length === 2) {
          if (n.shape[1] > 1) return rx(n, 1);
          if (n.shape[1] === 1) return ee(n, [
            n.shape[0]
          ]);
          throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
        } else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
      }), a = Array.from(await i.data());
      jt(i);
      const s = [];
      return a.forEach((o) => {
        if (t[o] == null) throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);
        s.push(t[o]);
      }), Sa(s, "float32");
    } else return null;
  }
  function tFe(n, e) {
    return Z(n, e);
  }
  const nFe = 32;
  function sQ(n, e) {
    let t, r;
    const i = e;
    t = i.xs, r = i.ys, B(t != null && r != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);
    const a = eU("input", n.inputNames, t), s = eU("output", n.outputNames, r), o = a[0].shape[0];
    B(a.length === n.inputs.length, () => `LayersModel has ${n.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`), B(s.length === n.outputs.length, () => `LayersModel has ${n.outputs.length} outputs, but the dataset provides ${s.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);
    for (let l = 0; l < a.length; l++) B(a[l].shape[0] === o, () => `Batch size mismatch: input ${n.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);
    for (let l = 0; l < s.length; l++) B(s[l].shape[0] === o, () => `Batch size mismatch: output ${n.outputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);
    return {
      xs: a,
      ys: s
    };
  }
  function eU(n, e, t) {
    if (t instanceof _r) return [
      t
    ];
    if (Array.isArray(t)) return B(t.length === e.length, () => `Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`), t;
    {
      const r = [];
      for (const i of e) {
        if (t[i] == null) throw new j(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);
        r.push(t[i]);
      }
      return r;
    }
  }
  function rFe(n) {
    if (n.length === 3) throw new zt("Validation with sample weights is not implemented yet.");
    return {
      xs: n[0],
      ys: n[1]
    };
  }
  async function iFe(n, e, t) {
    const r = t.batchesPerEpoch != null;
    if (B(n.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."), B(t != null, () => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."), B(t.epochs != null && t.epochs > 0 && Number.isInteger(t.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`), B(!r || t.batchesPerEpoch > 0 && Number.isInteger(t.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`), B(t.validationSplit == null, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."), n.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
    n.isTraining = true;
    try {
      const i = t.validationData != null;
      let a, s;
      if (i) if (tU(t.validationData)) B(t.validationBatches == null || t.validationBatches > 0 && Number.isInteger(t.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);
      else {
        const m = rFe(t.validationData);
        a = m.xs, s = m.ys;
      }
      const o = n.makeTrainFunction(), l = n.getDedupedMetricsNames();
      let u;
      i ? u = l.slice().concat(l.map((m) => "val_" + m)) : u = l.slice();
      const c = jZ(t.callbacks, t.yieldEvery), h = t.verbose == null ? 1 : t.verbose, { callbackList: d, history: f } = KZ(c, h, t.epochs, null, null, aFe(e, t), null, i, u);
      d.setModel(n), n.history = f, await d.onTrainBegin(), n.stopTraining_ = false;
      let p = t.initialEpoch == null ? 0 : t.initialEpoch, g = await e.iterator();
      for (; p < t.epochs; ) {
        const m = {};
        await d.onEpochBegin(p);
        let v = 0, y = 0;
        for (r || (g = await e.iterator()); !r || v < t.batchesPerEpoch; ) {
          const x = await g.next();
          if (r && x.done) {
            console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch * t.epochs} batches). You may need to use the repeat() function when building your dataset.`);
            break;
          }
          if (x.value != null) {
            const { xs: b, ys: w } = sQ(n, x.value), _ = {};
            _.batch = y, _.size = b[0].shape[0], await d.onBatchBegin(y, _);
            const S = [];
            if (t.classWeight != null) {
              const T = iQ(t.classWeight, n.outputNames);
              for (let k = 0; k < T.length; ++k) S.push(await aQ(w[k], null, T[k]));
            }
            const I = b.concat(w).concat(S), C = o(I);
            jt(I);
            for (let T = 0; T < l.length; ++T) {
              const k = l[T], D = C[T];
              _[k] = D, qo(D);
            }
            await d.onBatchEnd(y, _), qZ(_), y++, v++;
          }
          if (r ? v >= t.batchesPerEpoch : x.done) {
            if (i) {
              let b;
              tU(t.validationData) ? b = In(await n.evaluateDataset(t.validationData, {
                batches: t.validationBatches
              })) : b = In(n.evaluate(a, s, {
                batchSize: t.validationBatchSize == null ? nFe : t.validationBatchSize,
                verbose: 0
              }));
              for (let w = 0; w < n.metricsNames.length; ++w) m[`val_${n.metricsNames[w]}`] = b[w];
            }
            break;
          }
          if (n.stopTraining_) break;
        }
        if (await d.onEpochEnd(p, m), p++, n.stopTraining_) break;
      }
      return await d.onTrainEnd(), await n.history.syncData(), n.history;
    } finally {
      n.isTraining = false;
    }
  }
  function aFe(n, e) {
    let t = null;
    return e.batchesPerEpoch != null ? t = e.batchesPerEpoch : Number.isFinite(n.size) && (t = n.size), t;
  }
  function tU(n) {
    return typeof n.iterator == "function";
  }
  function sFe(n) {
    return typeof n.next == "function";
  }
  async function oFe(n, e, t) {
    t = t || {};
    const r = t.batches != null, i = n.testFunction;
    let a = [];
    if (t.verbose > 0) throw new zt("Verbose mode is not implemented yet.");
    B(!r || t.batches > 0 && Number.isInteger(t.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);
    const s = sFe(e) ? e : await e.iterator();
    let o = 0, l = 0;
    for (; !r || l < t.batches; ) {
      const u = await s.next();
      if (a = se(() => {
        if (u.value) {
          const { xs: c, ys: h } = sQ(n, u.value), d = c.concat(h), f = se(() => i(d));
          if (jt(d), l === 0) for (let g = 0; g < f.length; ++g) a.push(yn(0));
          const p = d[0].shape[0];
          for (let g = 0; g < f.length; ++g) {
            const m = f[g], v = a[g];
            a[g] = se(() => Ce(a[g], Z(p, m))), l > 0 && jt(v);
          }
          jt(f), o += p, ++l;
        }
        return a;
      }), u.done) {
        r && console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);
        break;
      }
    }
    for (let u = 0; u < a.length; ++u) {
      const c = a[u];
      a[u] = gt(a[u], o), jt(c);
    }
    return Yi(a);
  }
  function dA(n) {
    B(n > 0 && Number.isInteger(n), () => `batchSize is required to be a positive integer, but got ${n}`);
  }
  function wy(n, e, t) {
    return n == null ? [
      null
    ] : Array.isArray(n) ? n.map((r) => sd(r, e, t - e)) : sd(n, e, t - e);
  }
  function N$(n, e) {
    return se(() => n == null ? null : Array.isArray(n) ? n.map((t) => N$(t, e)) : MZ(n, e.dtype === "int32" ? e : Ve(e, "int32")));
  }
  function fA(n, e) {
    const t = [];
    let r = 0, i = null;
    for (; r < n; ) i = r + e, i >= n && (i = n), t.push([
      r,
      i
    ]), r = i;
    return t;
  }
  function oQ(n) {
    const e = [];
    n instanceof _r && (n = [
      n
    ]);
    for (let t = 0; t < n.length; ++t) {
      const r = n[t];
      if (r.rank === 1) e.push(Mb(r, 1));
      else {
        if (r.rank === 0) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
        e.push(r);
      }
    }
    return e;
  }
  function Ps(n, e) {
    if (n == null) return;
    const t = [];
    if (e instanceof _r) t.push(e.id);
    else if (Array.isArray(e)) e.forEach((i) => t.push(i.id));
    else if (e != null) for (const i in e) {
      const a = e[i];
      t.push(a.id);
    }
    const r = [];
    if (n instanceof _r) t.indexOf(n.id) === -1 && r.push(n);
    else if (Array.isArray(n)) n.forEach((i) => {
      t.indexOf(i.id) === -1 && r.push(i);
    });
    else if (n != null) for (const i in n) {
      const a = n[i];
      t.indexOf(a.id) === -1 && r.push(a);
    }
    r.forEach((i) => {
      i.isDisposed || i.dispose();
    });
  }
  function lFe(n) {
    return n instanceof _r;
  }
  function E$(n) {
    return Array.isArray(n);
  }
  function nU(n) {
    return !lFe(n) && !E$(n);
  }
  function rU(n, e, t, r = true, i = "") {
    if (e == null || e.length === 0) {
      if (n != null) {
        let s = false;
        if (E$(n) && n.length > 0) s = true;
        else if (nU(n)) {
          for (const o in n) if (n.hasOwnProperty(o)) {
            s = true;
            break;
          }
        } else s = true;
        if (s) throw new j(`Error when checking model ${i} expected no data, but got ${n}`);
      }
      return [];
    }
    if (n == null) return e.map((s) => null);
    let a;
    if (nU(n)) {
      n = n, a = [];
      for (const s of e) {
        if (n[s] == null) throw new j(`No data provided for "${s}". Need data for each key in: ${e}`);
        a.push(n[s]);
      }
    } else if (E$(n)) {
      if (n = n, n.length !== e.length) throw new j(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);
      a = n;
    } else {
      if (n = n, e.length > 1) throw new j(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);
      a = [
        n
      ];
    }
    if (a = oQ(a), t != null) for (let s = 0; s < e.length; ++s) {
      if (t[s] == null) continue;
      const o = a[s];
      if (o.shape.length !== t[s].length) throw new j(`Error when checking ${i}: expected ${e[s]} to have ${t[s].length} dimension(s). but got array with shape ${o.shape}`);
      for (let l = 0; l < t[s].length; ++l) {
        if (l === 0 && !r) continue;
        const u = o.shape[l], c = t[s][l];
        if (c != null && c >= 0 && u !== c) throw new j(`${i} expected a batch of elements where each example has shape [${t[s].slice(1, t[s].length)}] (i.e.,tensor shape [*,${t[s].slice(1, t[s].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1, o.shape.length)}] (tensor shape [${o.shape}])`);
      }
    }
    return a;
  }
  function uFe(n, e, t) {
    const r = Zu(n.map((a) => a.shape[0]));
    r.sort();
    const i = Zu(e.map((a) => a.shape[0]));
    if (i.sort(), r.length > 1) throw new j(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map((a) => a.shape))}`);
    if (i.length > 1) throw new j(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((a) => a.shape))}`);
    if (r.length > 0 && i.length > 0 && !Jt(r, i)) throw new j(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`);
  }
  function cFe(n, e, t) {
    const r = [
      jI,
      KI,
      cx
    ];
    for (let i = 0; i < n.length; ++i) {
      const a = n[i], s = e[i], o = t[i];
      if (s != null) {
        if (s === cx && a.shape[a.shape.length - 1] === 1) throw new j(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
        if (r.indexOf(s) !== -1) {
          const l = a.shape.slice(1), u = o.slice(1);
          for (let c = 0; c < l.length; ++c) {
            const h = l[c], d = u[c];
            if (d != null && h !== d) throw new j(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`);
          }
        }
      }
    }
  }
  function iU(n, e, t, r = true, i = "") {
    let a;
    if (Array.isArray(n)) {
      if (n.length !== e.length) throw new j(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);
      a = n;
    } else {
      if (e.length > 1) throw new j(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);
      a = [
        n
      ];
    }
    if (t != null) for (let s = 0; s < e.length; ++s) {
      if (t[s] == null) continue;
      const o = a[s];
      if (o.shape.length !== t[s].length) throw new j(`Error when checking ${i}: expected ${e[s]} to have ${t[s].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);
      for (let l = 0; l < t[s].length; ++l) {
        if (l === 0 && !r) continue;
        const u = o.shape[l], c = t[s][l];
        if (c != null && c !== u) throw new j(`Error when checking ${i}: expected ${e[s]} to have shape ${JSON.stringify(t[s])} but got array with shape ${JSON.stringify(o.shape)}.`);
      }
    }
  }
  function hFe(n, e) {
    if (n == null || Array.isArray(n) && n.length === 0) return e.map((r) => []);
    let t;
    if (typeof n == "string" || typeof n == "function") t = [
      n
    ];
    else if (Array.isArray(n) || typeof n == "object") t = n;
    else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);
    if (Array.isArray(t)) return e.map((r) => t);
    {
      const r = [];
      for (const i of e) {
        let a = t.hasOwnProperty(i) ? t[i] : [];
        Array.isArray(a) || (a = [
          a
        ]), r.push(a);
      }
      return r;
    }
  }
  const dFe = "layers-model";
  class Dg extends J3e {
    constructor(e) {
      super(e), this.isTraining = false;
    }
    summary(e, t, r = console.log) {
      if (!this.built) throw new j("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
      Y3e(this, e, t, r);
    }
    compile(e) {
      if (e.loss == null && (e.loss = []), this.loss = e.loss, typeof e.optimizer == "string") this.optimizer_ = X3e(e.optimizer), this.isOptimizerOwned = true;
      else {
        if (!(e.optimizer instanceof kc)) throw new j("User-defined optimizer must be an instance of tf.Optimizer.");
        this.optimizer_ = e.optimizer, this.isOptimizerOwned = false;
      }
      let t = [];
      if (!Array.isArray(e.loss) && typeof e.loss != "string" && typeof e.loss != "function") {
        e.loss = e.loss;
        for (const s in e.loss) if (this.outputNames.indexOf(s) === -1) throw new j(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);
        for (const s of this.outputNames) e.loss[s] == null && console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`), t.push(hA(e.loss[s]));
      } else if (Array.isArray(e.loss)) {
        if (e.loss.length !== this.outputs.length) throw new j(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);
        t = e.loss.map((o) => hA(o));
      } else {
        const s = hA(e.loss);
        this.outputs.forEach((o) => {
          t.push(s);
        });
      }
      this.lossFunctions = t, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
      for (let s = 0; s < this.outputs.length; ++s) {
        const o = this.internalOutputShapes[s], l = this.outputNames[s];
        this.feedOutputNames.push(l), this.feedOutputShapes.push(o), this.feedLossFns.push(this.lossFunctions[s]);
      }
      const r = [];
      this.metrics = e.metrics, this.metricsNames = [
        "loss"
      ], this.metricsTensors = [], ad("loss", () => {
        for (let s = 0; s < this.outputs.length; ++s) {
          if (r.indexOf(s) !== -1) continue;
          const o = this.lossFunctions[s];
          this.outputs.length > 1 && (this.metricsTensors.push([
            o,
            s
          ]), this.metricsNames.push(this.outputNames[s] + "_loss"));
        }
      });
      const i = hFe(e.metrics, this.outputNames), a = (s, o, l) => {
        this.outputNames.length > 1 && (o = this.outputNames[s] + "_" + o), this.metricsNames.push(o), this.metricsTensors.push([
          l,
          s
        ]);
      };
      ad("metric", () => {
        for (let s = 0; s < this.outputs.length; ++s) {
          if (r.indexOf(s) !== -1) continue;
          const o = i[s];
          ((u) => {
            const c = "";
            let h, d, f;
            for (const p of u) {
              if (typeof p == "string" && [
                "accuracy",
                "acc",
                "crossentropy",
                "ce"
              ].indexOf(p) !== -1) {
                const m = this.internalOutputShapes[s];
                m[m.length - 1] === 1 || this.lossFunctions[s] === KI ? [
                  "accuracy",
                  "acc"
                ].indexOf(p) !== -1 ? d = QZ : [
                  "crossentropy",
                  "ce"
                ].indexOf(p) !== -1 && (d = L3e) : this.lossFunctions[s] === zS ? [
                  "accuracy",
                  "acc"
                ].indexOf(p) !== -1 ? d = F3e : [
                  "crossentropy",
                  "ce"
                ].indexOf(p) !== -1 && (d = tQ) : [
                  "accuracy",
                  "acc"
                ].indexOf(p) !== -1 ? d = JZ : [
                  "crossentropy",
                  "ce"
                ].indexOf(p) !== -1 && (d = eQ);
                let v;
                [
                  "accuracy",
                  "acc"
                ].indexOf(p) !== -1 ? v = "acc" : [
                  "crossentropy",
                  "ce"
                ].indexOf(p) !== -1 && (v = "ce"), f = d, h = c + v;
              } else f = H3e(p), h = c + yw(p);
              let g;
              ad(h, () => {
                g = f;
              }), a(s, h, g);
            }
          })(o);
        }
      }), this.collectedTrainableWeights = this.trainableWeights;
    }
    checkTrainableWeightsConsistency() {
      this.collectedTrainableWeights != null && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
    }
    evaluate(e, t, r = {}) {
      const i = r.batchSize == null ? 32 : r.batchSize;
      dA(i);
      const s = this.standardizeUserDataXY(e, t, true, i);
      try {
        const o = s[0].concat(s[1]);
        this.makeTestFunction();
        const l = this.testFunction, u = this.testLoop(l, o, i, r.verbose, r.steps);
        return Yi(u);
      } finally {
        Ps(s[0], e), Ps(s[1], t);
      }
    }
    async evaluateDataset(e, t) {
      return this.makeTestFunction(), oFe(this, e, t);
    }
    checkNumSamples(e, t, r, i = "steps") {
      let a;
      if (r != null) {
        if (a = null, t != null) throw new j(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`);
      } else if (e != null) Array.isArray(e) ? a = e[0].shape[0] : a = e.shape[0];
      else throw new j(`Either the input data should have a defined shape, or ${i} shoud be specified.`);
      return a;
    }
    execute(e, t) {
      if (Array.isArray(t) && t.length === 0) throw new j("`outputs` is an empty Array, which is not allowed.");
      const r = Array.isArray(t), i = r ? t : [
        t
      ], a = this.retrieveSymbolicTensors(i), s = new Wu();
      if (e instanceof _r && (e = [
        e
      ]), Array.isArray(e)) {
        if (e.length !== this.inputs.length) throw new j(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
        for (let l = 0; l < this.inputs.length; ++l) s.add(this.inputs[l], e[l]);
      } else for (const l of this.inputs) {
        const u = e[l.name];
        if (u == null) throw new j(`No value is provided for the model's input ${l.name}`);
        s.add(l, u);
      }
      const o = Uy(a, s);
      return r ? o : o[0];
    }
    retrieveSymbolicTensors(e) {
      const t = Td(null, e.length);
      let r = e.length;
      for (const i of this.layers) {
        const a = Array.isArray(i.output) ? i.output : [
          i.output
        ], s = a.map((o) => o.name);
        for (let o = 0; o < e.length; ++o) {
          const l = s.indexOf(e[o]);
          if (l !== -1 && (t[o] = a[l], r--), r === 0) break;
        }
        if (r === 0) break;
      }
      if (r > 0) {
        const i = [];
        throw t.forEach((a, s) => {
          a == null && i.push(e[s]);
        }), new j(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`);
      }
      return t;
    }
    predictLoop(e, t = 32, r = false) {
      return se(() => {
        const i = this.checkNumSamples(e);
        if (r) throw new zt("Verbose predictLoop() is not implemented yet.");
        const a = fA(i, t), s = this.outputs.map((o) => []);
        for (let o = 0; o < a.length; ++o) se(() => {
          const u = a[o][0], c = a[o][1], h = wy(e, u, c), d = [];
          if (Array.isArray(h)) for (let p = 0; p < h.length; ++p) d.push({
            key: this.inputs[p],
            value: h[p]
          });
          else d.push({
            key: this.inputs[0],
            value: h
          });
          const f = new Wu(d);
          return Uy(this.outputs, f);
        }).forEach((u, c) => s[c].push(u));
        return Yi(s.map((o) => Qi(o, 0)));
      });
    }
    predict(e, t = {}) {
      const r = oQ(e);
      iU(r, this.inputNames, this.feedInputShapes, false);
      try {
        const i = t.batchSize == null ? 32 : t.batchSize;
        return dA(i), this.predictLoop(r, i);
      } finally {
        Ps(r, e);
      }
    }
    predictOnBatch(e) {
      iU(e, this.inputNames, this.feedInputShapes, true);
      const t = (Array.isArray(e) ? e[0] : e).shape[0];
      return this.predictLoop(e, t);
    }
    standardizeUserDataXY(e, t, r = true, i) {
      if (this.optimizer_ == null) throw new ys("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
      const a = [];
      for (let s = 0; s < this.feedOutputShapes.length; ++s) {
        const o = this.feedOutputShapes[s];
        this.feedLossFns[s] === zS ? a.push(o.slice(0, o.length - 1).concat([
          1
        ])) : a.push(o);
      }
      if (e = rU(e, this.feedInputNames, this.feedInputShapes, false, "input"), t = rU(t, this.feedOutputNames, a, false, "target"), uFe(e, t), cFe(t, this.feedLossFns, this.feedOutputShapes), this.stateful && i != null && i > 0 && e[0].shape[0] % i !== 0) throw new j(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);
      return [
        e,
        t
      ];
    }
    async standardizeUserData(e, t, r, i, a = true, s) {
      const [o, l] = this.standardizeUserDataXY(e, t, a, s);
      if (r != null) throw new Error("sample weight is not supported yet.");
      let u = null;
      if (i != null) {
        const c = iQ(i, this.outputNames);
        u = [];
        for (let h = 0; h < c.length; ++h) u.push(await aQ(l[h], null, c[h]));
      }
      return [
        o,
        l,
        u
      ];
    }
    testLoop(e, t, r, i = 0, a) {
      return se(() => {
        const s = this.checkNumSamples(t, r, a, "steps"), o = [];
        if (i > 0) throw new zt("Verbose mode is not implemented yet.");
        if (a != null) throw new zt("steps mode in testLoop() is not implemented yet");
        {
          const l = fA(s, r), u = Sa(oo(0, s));
          for (let c = 0; c < l.length; ++c) {
            const h = l[c][0], d = l[c][1], f = sd(u, h, d - h), p = N$(t, f), g = e(p);
            if (c === 0) for (let m = 0; m < g.length; ++m) o.push(yn(0));
            for (let m = 0; m < g.length; ++m) {
              const v = g[m];
              o[m] = Ce(o[m], Z(d - h, v));
            }
          }
          for (let c = 0; c < o.length; ++c) o[c] = gt(o[c], s);
        }
        return o;
      });
    }
    getDedupedMetricsNames() {
      const e = this.metricsNames, t = [];
      for (let r = 0; r < e.length; ++r) {
        const i = e[r];
        let a = i;
        if (W4(e, i) > 1) {
          const s = W4(e.slice(0, r), i);
          a += `_${s}`;
        }
        t.push(a);
      }
      return t;
    }
    makeTrainFunction() {
      return (e) => {
        const t = [], r = e.slice(0, this.inputs.length), i = e.slice(this.inputs.length, this.inputs.length + this.outputs.length), a = e.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2), s = [], o = () => {
          const h = [];
          for (let g = 0; g < this.inputs.length; ++g) h.push({
            key: this.inputs[g],
            value: r[g]
          });
          const d = new Wu(h), f = Uy(this.outputs, d, {
            training: true
          });
          let p;
          for (let g = 0; g < this.lossFunctions.length; ++g) {
            const m = this.lossFunctions[g];
            let v = m(i[g], f[g]);
            a[g] != null && (v = tFe(v, a[g]));
            const y = vr(v);
            t.push(y), g === 0 ? p = v : p = Ce(p, v);
          }
          for (let g = 0; g < this.metricsTensors.length; ++g) {
            let m;
            if (this.outputs.length > 1 && g < this.outputs.length) m = t[g];
            else {
              const v = this.metricsTensors[g][0], y = this.metricsTensors[g][1];
              m = vr(v(i[y], f[y]));
            }
            qo(m), s.push(m);
          }
          return p = vr(p), this.calculateLosses().forEach((g) => {
            p = Ce(p, g);
          }), p;
        }, l = this.collectedTrainableWeights.map((h) => h.read());
        return [
          this.optimizer_.minimize(o, true, l)
        ].concat(s);
      };
    }
    makeTestFunction() {
      this.testFunction = (e) => se(() => {
        const t = [];
        let r;
        const i = e.slice(0, this.inputs.length), a = e.slice(this.inputs.length, this.inputs.length + this.outputs.length), s = [];
        for (let u = 0; u < this.inputs.length; ++u) s.push({
          key: this.inputs[u],
          value: i[u]
        });
        const o = new Wu(s), l = Uy(this.outputs, o);
        for (let u = 0; u < this.lossFunctions.length; ++u) {
          const c = this.lossFunctions[u], h = vr(c(a[u], l[u]));
          u === 0 ? r = h : r = Ce(r, h), t.push(r);
        }
        for (let u = 0; u < this.metricsTensors.length; ++u) {
          const c = this.metricsTensors[u][0], h = this.metricsTensors[u][1], d = vr(c(a[h], l[h]));
          t.push(d);
        }
        return t;
      });
    }
    async fit(e, t, r = {}) {
      if (this.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
      this.isTraining = true;
      let i, a, s, o, l, u, c, h, d;
      try {
        const f = r.batchSize == null ? 32 : r.batchSize;
        dA(f);
        const g = await this.standardizeUserData(e, t, r.sampleWeight, r.classWeight, false, f);
        i = g[0], a = g[1], d = g[2];
        let m = false, v;
        if (r.validationData != null && r.validationData.length > 0) {
          if (m = true, r.validationData.length === 2) l = r.validationData[0], u = r.validationData[1];
          else throw r.validationData.length === 3 ? new zt("validationData including sample weights is not supported yet.") : new j(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);
          const T = await this.standardizeUserData(l, u, null, null, true, f);
          c = T[0], h = T[1], v = c.concat(h);
        } else if (r.validationSplit != null && r.validationSplit > 0 && r.validationSplit < 1) {
          m = true;
          const C = Math.floor(i[0].shape[0] * (1 - r.validationSplit)), T = i[0].shape[0];
          c = wy(i, C, T), s = i, i = wy(i, 0, C), h = wy(a, C, T), o = a, a = wy(a, 0, C), v = c.concat(h);
        } else r.validationSteps != null && (m = true);
        const y = i.concat(a).concat(d);
        this.checkTrainableWeightsConsistency();
        const x = this.makeTrainFunction(), b = this.getDedupedMetricsNames();
        let w, _;
        m ? (this.makeTestFunction(), w = this.testFunction, _ = b.slice().concat(b.map((C) => "val_" + C))) : (w = null, v = [], _ = b.slice());
        const S = jZ(r.callbacks, r.yieldEvery);
        return await this.fitLoop(x, y, b, f, r.epochs, r.verbose, S, w, v, r.shuffle, _, r.initialEpoch, null, null);
      } finally {
        this.isTraining = false, Ps(i, e), Ps(a, t), Ps(s, e), Ps(o, t), Ps(c, l), Ps(h, u), d != null && jt(d);
      }
    }
    async fitLoop(e, t, r, i, a, s, o, l, u, c, h, d, f, p) {
      i == null && (i = 32), a == null && (a = 1), c == null && (c = true), d == null && (d = 0);
      let g = false;
      if (l != null && u != null && (g = true), p != null && (g = true, f == null)) throw new j("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
      const m = this.checkNumSamples(t, i, f, "steps_per_epoch");
      let v;
      m != null && (v = oo(0, m)), s == null && (s = 1);
      const { callbackList: y, history: x } = KZ(o, s, a, d, m, f, i, g, h);
      y.setModel(this), this.history = x, await y.onTrainBegin(), this.stopTraining_ = false;
      for (let b = d; b < a; ++b) {
        await y.onEpochBegin(b);
        const w = {};
        if (f != null) throw new zt("stepsPerEpoch mode is not implemented yet.");
        {
          if (c === "batch") throw new zt("batch shuffling is not implemneted yet");
          c && ZTe(v);
          const _ = Sa(v), S = fA(m, i);
          for (let I = 0; I < S.length; ++I) {
            const C = {};
            if (await y.onBatchBegin(I, C), se(() => {
              const T = S[I][0], k = S[I][1], D = sd(_, T, k - T);
              C.batch = I, C.size = k - T;
              const R = N$(t, D), N = e(R);
              for (let E = 0; E < r.length; ++E) {
                const A = r[E], M = N[E];
                C[A] = M, qo(M);
              }
              if (I === S.length - 1 && g) {
                const E = this.testLoop(l, u, i);
                for (let A = 0; A < r.length; ++A) {
                  const M = r[A], $ = E[A];
                  qo($), w["val_" + M] = $;
                }
              }
            }), await y.onBatchEnd(I, C), qZ(C), this.stopTraining_) break;
          }
          _.dispose();
        }
        if (await y.onEpochEnd(b, w), this.stopTraining_) break;
      }
      return await y.onTrainEnd(), await this.history.syncData(), this.history;
    }
    async fitDataset(e, t) {
      return iFe(this, e, t);
    }
    async trainOnBatch(e, t) {
      const r = await this.standardizeUserData(e, t), i = r[0], a = r[1], o = this.makeTrainFunction()(i.concat(a)), l = [];
      for (const u of o) {
        const c = await u.data();
        l.push(c[0]);
      }
      return jt(o), Ps(r[0], e), Ps(r[1], t), Yi(l);
    }
    getNamedWeights(e) {
      const t = [], r = e != null && e.trainableOnly, i = r ? this.trainableWeights : this.weights, a = this.getWeights(r);
      for (let s = 0; s < i.length; ++s) r && !i[s].trainable || t.push({
        name: i[s].originalName,
        tensor: a[s]
      });
      return t;
    }
    set stopTraining(e) {
      this.stopTraining_ = e;
    }
    get stopTraining() {
      return this.stopTraining_;
    }
    get optimizer() {
      return this.optimizer_;
    }
    set optimizer(e) {
      this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = false);
    }
    dispose() {
      const e = super.dispose();
      if (e.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
        const t = p4().numTensors;
        this.optimizer_.dispose(), e.numDisposedVariables += t - p4().numTensors;
      }
      return e;
    }
    getLossIdentifiers() {
      let e;
      if (typeof this.loss == "string") e = Il(this.loss);
      else if (Array.isArray(this.loss)) {
        for (const t of this.loss) if (typeof t != "string") throw new Error("Serialization of non-string loss is not supported.");
        e = this.loss.map((t) => Il(t));
      } else {
        const t = Object.keys(this.loss);
        e = {};
        const r = this.loss;
        for (const i of t) if (typeof r[i] == "string") e[i] = Il(r[i]);
        else throw new Error("Serialization of non-string loss is not supported.");
      }
      return e;
    }
    getMetricIdentifiers() {
      if (typeof this.metrics == "string" || typeof this.metrics == "function") return [
        Il(yw(this.metrics))
      ];
      if (Array.isArray(this.metrics)) return this.metrics.map((e) => Il(yw(e)));
      {
        const e = {};
        for (const t in this.metrics) e[t] = Il(yw(this.metrics[t]));
        return e;
      }
    }
    getTrainingConfig() {
      return {
        loss: this.getLossIdentifiers(),
        metrics: this.getMetricIdentifiers(),
        optimizer_config: {
          class_name: this.optimizer.getClassName(),
          config: this.optimizer.getConfig()
        }
      };
    }
    loadTrainingConfig(e) {
      if (e.weighted_metrics != null) throw new Error("Loading weight_metrics is not supported yet.");
      if (e.loss_weights != null) throw new Error("Loading loss_weights is not supported yet.");
      if (e.sample_weight_mode != null) throw new Error("Loading sample_weight_mode is not supported yet.");
      const t = R$(e.optimizer_config), r = zl(t);
      let i;
      if (typeof e.loss == "string") i = Nh(e.loss);
      else if (Array.isArray(e.loss)) i = e.loss.map((s) => Nh(s));
      else if (e.loss != null) {
        i = {};
        for (const s in e.loss) i[s] = Nh(e.loss[s]);
      }
      let a;
      if (Array.isArray(e.metrics)) a = e.metrics.map((s) => Nh(s));
      else if (e.metrics != null) {
        a = {};
        for (const s in e.metrics) a[s] = Nh(e.metrics[s]);
      }
      this.compile({
        loss: i,
        metrics: a,
        optimizer: r
      });
    }
    async save(e, t) {
      if (typeof e == "string") {
        const u = UAe(e);
        if (u.length === 0) throw new j(`Cannot find any save handlers for URL '${e}'`);
        if (u.length > 1) throw new j(`Found more than one (${u.length}) save handlers for URL '${e}'`);
        e = u[0];
      }
      if (e.save == null) throw new j("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      const r = await y4(this.getNamedWeights(t)), o = {
        modelTopology: this.toJSON(null, false),
        format: dFe,
        generatedBy: `TensorFlow.js tfjs-layers v${rQ}`,
        convertedBy: null
      };
      if ((t == null ? false : t.includeOptimizer) && this.optimizer != null) {
        o.trainingConfig = this.getTrainingConfig();
        const u = "optimizer", { data: c, specs: h } = await y4(await this.optimizer.getWeights(), u);
        r.specs.push(...h), r.data = GAe([
          r.data,
          c
        ]);
      }
      return this.userDefinedMetadata != null && (J4(this.userDefinedMetadata, this.name, true), o.userDefinedMetadata = this.userDefinedMetadata), o.weightData = r.data, o.weightSpecs = r.specs, e.save(o);
    }
    setUserDefinedMetadata(e) {
      J4(e, this.name), this.userDefinedMetadata = e;
    }
    getUserDefinedMetadata() {
      return this.userDefinedMetadata;
    }
  }
  Dg.className = "Model";
  we(Dg);
  class lQ extends Dg {
  }
  lQ.className = "Functional";
  we(lQ);
  class hx extends Dg {
    constructor(e) {
      if (super({
        inputs: [],
        outputs: []
      }), e = e || {}, this.trainable = true, this.built = false, this.name = e.name != null ? e.name : XI("sequential_"), e.layers != null) for (const t of e.layers) this.add(t);
    }
    checkShape(e) {
      if (e.inboundNodes[0].outputTensors[0].shape.some((r) => r < 0)) throw new j(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`);
    }
    add(e) {
      const t = e instanceof hx || e instanceof Dg;
      let r;
      if (t) {
        if (r = e, r.outputs.length !== 1) throw new j("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        if (r.inputs.length !== 1) throw new j("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
      }
      if (this.outputs.length === 0) {
        if (e.inboundNodes.length === 0) {
          if (e.batchInputShape == null) throw new j("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
          const i = f3e({
            batchShape: e.batchInputShape,
            dtype: e.dtype,
            name: e.name + "_input"
          });
          e.apply(i);
        }
        if (t) this.outputs = r.outputs, this.inputs = r.inputs;
        else {
          if (e.inboundNodes.length !== 1) throw new j(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);
          if (e.inboundNodes[0].outputTensors.length !== 1) throw new j("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          this.checkShape(e), this.outputs = [
            e.inboundNodes[0].outputTensors[0]
          ], this.inputs = GZ(this.outputs[0]);
        }
        this.inboundNodes = [], new qI({
          outboundLayer: this,
          inboundLayers: [],
          nodeIndices: [],
          tensorIndices: [],
          inputTensors: this.inputs,
          outputTensors: this.outputs,
          inputMasks: Td(null, this.inputs.length),
          outputMasks: [
            null
          ],
          inputShapes: this.inputs.map((i) => i.shape),
          outputShapes: this.outputs[0].shape
        });
      } else {
        const i = e.apply(this.outputs[0]);
        if (Array.isArray(i)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(e), this.outputs = [
          i
        ], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [
          this.outputs[0].shape
        ];
      }
      this.layers.push(e), this.built = false;
    }
    pop() {
      if (this.layers.length === 0) throw new TypeError("There are no layers in the model.");
      if (this.layers.pop(), this.layers.length === 0) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
      else {
        const e = this.layers.length - 1;
        this.layers[e].outboundNodes = [], this.outputs = [
          this.layers[e].output
        ], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [
          this.outputs[0].shape
        ];
      }
    }
    call(e, t) {
      return this.model == null && this.build(), this.model.call(e, t);
    }
    build(e) {
      if (dn(e), this.inputs.length === 0 || this.outputs.length === 0) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
      this.model = new Dg({
        inputs: this.inputs,
        outputs: this.outputs[0],
        name: this.name + "_model"
      }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = true;
    }
    countParams() {
      return this.built || this.build(), super.countParams();
    }
    summary(e, t, r = console.log) {
      this.built || this.build(), super.summary(e, t, r);
    }
    setWeights(e) {
      this.model == null && this.build(), this.model.setWeights(e);
    }
    evaluate(e, t, r = {}) {
      if (!this.built) throw new ys("The model needs to be compiled before being used.");
      return this.model.evaluate(e, t, r);
    }
    async evaluateDataset(e, t) {
      if (!this.built) throw new ys("The model needs to be compiled before being used.");
      return this.model.evaluateDataset(e, t);
    }
    predict(e, t = {}) {
      return this.model == null && this.build(), this.model.predict(e, t);
    }
    predictOnBatch(e) {
      return this.model == null && this.build(), this.model.predictOnBatch(e);
    }
    compile(e) {
      this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
    }
    get optimizer() {
      return this.model == null ? void 0 : this.model.optimizer;
    }
    set optimizer(e) {
      this.model.optimizer = e;
    }
    async fit(e, t, r = {}) {
      if (!this.built) throw new ys("The model needs to be compiled before being used.");
      return this.model.fit(e, t, r);
    }
    async fitDataset(e, t) {
      if (!this.built) throw new ys("The model needs to be compiled before being used.");
      return this.model.fitDataset(e, t);
    }
    async trainOnBatch(e, t) {
      return this.model.trainOnBatch(e, t);
    }
    static fromConfig(e, t, r = {}, i = false) {
      let a, s = {};
      if (t instanceof Array) {
        if (t[0].className == null || t[0].className === "Merge") throw new j("Legacy serialization format not supported yet.");
        a = t;
      } else B(t.layers != null, () => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."), a = t.layers, delete t.layers, s = t;
      const o = new e(s);
      if (!(o instanceof hx)) throw new zt(`Sequential.fromConfig called on non-Sequential input: ${o}`);
      for (const l of a) {
        const c = zl(l, void 0, i);
        i && c.setFastWeightInitDuringBuild(true), o.add(c);
      }
      return o;
    }
    set stopTraining(e) {
      if (this.model == null) throw new j("Cannot set the stopTraining property of a sequential model before it is compiled.");
      this.model.stopTraining = e;
    }
    get stopTraining() {
      if (this.model == null) throw new j("Cannot get the stopTraining property of a sequential model before it is compiled.");
      return this.model.stopTraining;
    }
    getConfig() {
      const e = [];
      for (const t of this.layers) {
        const r = {};
        r.className = t.getClassName(), r.config = t.getConfig(), e.push(r);
      }
      return {
        name: this.name,
        layers: e
      };
    }
  }
  hx.className = "Sequential";
  we(hx);
  let yi = class extends Tv {
    getConfig() {
      return {};
    }
  };
  class uQ extends yi {
    apply(e, t = 1) {
      return ZLe(e, t);
    }
  }
  uQ.className = "elu";
  we(uQ);
  class cQ extends yi {
    apply(e) {
      return z9(e);
    }
  }
  cQ.className = "selu";
  we(cQ);
  class hQ extends yi {
    apply(e) {
      return lp(e);
    }
  }
  hQ.className = "relu";
  we(hQ);
  class dQ extends yi {
    apply(e) {
      return se(() => sx(6, lp(e)));
    }
  }
  dQ.className = "relu6";
  we(dQ);
  class fQ extends yi {
    apply(e) {
      return e;
    }
  }
  fQ.className = "linear";
  we(fQ);
  class pQ extends yi {
    apply(e) {
      return Cv(e);
    }
  }
  pQ.className = "sigmoid";
  we(pQ);
  class gQ extends yi {
    apply(e) {
      return JLe(e);
    }
  }
  gQ.className = "hardSigmoid";
  we(gQ);
  class mQ extends yi {
    apply(e) {
      return yb(e);
    }
  }
  mQ.className = "softplus";
  we(mQ);
  class vQ extends yi {
    apply(e) {
      return QLe(e);
    }
  }
  vQ.className = "softsign";
  we(vQ);
  class yQ extends yi {
    apply(e) {
      return SI(e);
    }
  }
  yQ.className = "tanh";
  we(yQ);
  let iL = class extends yi {
    apply(e, t = -1) {
      return xP(e, t);
    }
  };
  iL.className = "softmax";
  we(iL);
  class xQ extends yi {
    apply(e, t = -1) {
      return N9(e, t);
    }
  }
  xQ.className = "logSoftmax";
  we(xQ);
  class bQ extends yi {
    apply(e) {
      return se(() => se(() => {
        const t = Math.sqrt(2), r = Z(0.5, Ce(1, T9(gt(e, t))));
        return Z(e, r);
      }));
    }
  }
  bQ.className = "gelu";
  we(bQ);
  class wQ extends yi {
    apply(e) {
      return se(() => Z(0.5, Z(e, Ce(1, SI(Z(mi(gt(2, Math.PI)), Ce(e, Z(0.044715, Cd(e, 3)))))))));
    }
  }
  wQ.className = "gelu_new";
  we(wQ);
  class _Q extends yi {
    apply(e) {
      return se(() => Z(e, SI(yb(e))));
    }
  }
  _Q.className = "mish";
  we(_Q);
  class SQ extends yi {
    apply(e, t = 1) {
      return se(() => Z(Cv(Z(e, t)), e));
    }
  }
  SQ.className = "swish";
  we(SQ);
  function cc(n) {
    return n.getClassName();
  }
  function pA(n, e = {}) {
    return Eb(n, ms.getMap().classNameMap, e, "activation");
  }
  function hc(n) {
    if (n == null) {
      const e = {};
      return e.className = "linear", e.config = {}, pA(e);
    }
    if (typeof n == "string") {
      const e = {};
      return e.className = n, e.config = {}, pA(e);
    } else return n instanceof yi ? n : pA(n);
  }
  function fFe(n) {
    if (n != null && typeof n != "object") throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`);
  }
  class CQ extends Tv {
  }
  class IQ extends CQ {
    constructor(e) {
      super(), fFe(e), this.l1 = e == null || e.l1 == null ? 0.01 : e.l1, this.l2 = e == null || e.l2 == null ? 0.01 : e.l2, this.hasL1 = this.l1 !== 0, this.hasL2 = this.l2 !== 0;
    }
    apply(e) {
      return se(() => {
        let t = Cr([
          1
        ]);
        return this.hasL1 && (t = Ce(t, ct(Z(this.l1, ki(e))))), this.hasL2 && (t = Ce(t, ct(Z(this.l2, Pb(e))))), ee(t, []);
      });
    }
    getConfig() {
      return {
        l1: this.l1,
        l2: this.l2
      };
    }
    static fromConfig(e, t) {
      return new e({
        l1: t.l1,
        l2: t.l2
      });
    }
  }
  IQ.className = "L1L2";
  we(IQ);
  const aU = {
    l1l2: "L1L2"
  };
  function On(n) {
    return UP(n);
  }
  function sU(n, e = {}) {
    return Eb(n, ms.getMap().classNameMap, e, "regularizer");
  }
  function Zn(n) {
    if (n == null) return null;
    if (typeof n == "string") {
      const t = {
        className: n in aU ? aU[n] : n,
        config: {}
      };
      return sU(t);
    } else return n instanceof CQ ? n : sU(n);
  }
  class kQ extends qt {
    constructor(e) {
      super(e ?? {}), this.supportsMasking = true, e != null && (this.maxValue = e.maxValue);
    }
    call(e, t) {
      e = St(e);
      let r = lp(e);
      return this.maxValue != null && (r = Xa(r, 0, this.maxValue)), r;
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = {
        maxValue: this.maxValue
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  kQ.className = "ReLU";
  we(kQ);
  class TQ extends qt {
    constructor(e) {
      super(e ?? {}), this.DEFAULT_ALPHA = 0.3, e == null && (e = {}), this.alpha = e.alpha == null ? this.DEFAULT_ALPHA : e.alpha;
    }
    call(e, t) {
      const r = St(e);
      return uP(r, this.alpha);
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = {
        alpha: this.alpha
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  TQ.className = "LeakyReLU";
  we(TQ);
  class AQ extends qt {
    constructor(e) {
      if (super(e ?? {}), this.DEFAULT_ALPHA_INITIALIZER = "zeros", e == null && (e = {}), this.supportsMasking = true, this.alphaInitializer = Kn(e.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = Zn(e.alphaRegularizer), this.alphaConstraint = Nr(e.alphaConstraint), e.sharedAxes == null) this.sharedAxes = null;
      else if (Array.isArray(e.sharedAxes)) this.sharedAxes = e.sharedAxes;
      else if (typeof e.sharedAxes == "number") this.sharedAxes = [
        e.sharedAxes
      ];
      else throw new j(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);
    }
    build(e) {
      e = dn(e);
      const t = e.slice(1);
      if (this.sharedAxes != null) for (const i of this.sharedAxes) t[i - 1] = 1;
      this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
      const r = {};
      if (this.sharedAxes != null) for (let i = 1; i < e.length; ++i) r[i] = e[i];
      this.inputSpec = [
        new Ar({
          ndim: e.length,
          axes: r
        })
      ], this.built = true;
    }
    call(e, t) {
      return e = St(e), gP(e, this.alpha.read());
    }
    getConfig() {
      const e = {
        alphaInitializer: tr(this.alphaInitializer),
        alphaRegularizer: On(this.alphaRegularizer),
        alphaConstraint: $r(this.alphaConstraint),
        sharedAxes: this.sharedAxes
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  AQ.className = "PReLU";
  we(AQ);
  let DQ = class extends qt {
    constructor(e) {
      if (super(e ?? {}), this.DEFAULT_ALPHA = 1, e == null && (e = {}), e.alpha != null && e.alpha !== this.DEFAULT_ALPHA) throw new zt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);
      this.alpha = e.alpha == null ? this.DEFAULT_ALPHA : e.alpha;
    }
    call(e, t) {
      const r = St(e);
      return kI(r);
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = {
        alpha: this.alpha
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  };
  DQ.className = "ELU";
  we(DQ);
  class RQ extends qt {
    constructor(e) {
      super(e ?? {}), this.DEFAULT_THETA = 1, e == null && (e = {}), this.theta = e.theta == null ? this.DEFAULT_THETA : e.theta;
    }
    call(e, t) {
      const r = St(e);
      return Z(r, Ve(ja(r, this.theta), "float32"));
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = {
        theta: this.theta
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  RQ.className = "ThresholdedReLU";
  we(RQ);
  class $Q extends qt {
    constructor(e) {
      super(e ?? {}), this.DEFAULT_AXIS = 1, e == null && (e = {}), this.softmax = new iL().apply, this.axis = e.axis == null ? this.DEFAULT_AXIS : e.axis;
    }
    call(e, t) {
      return se(() => {
        let r = St(e);
        const i = t.mask;
        if (i != null) {
          const a = Z(wt(Ic(r.shape), Ve(i, r.dtype)), yn(-1e9));
          r = Ce(r, a);
        }
        return this.axis instanceof Array ? this.axis.length > 1 ? il(wt(r, E9(r, this.axis, true))) : this.softmax(r, this.axis[0]) : this.softmax(r, this.axis);
      });
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = {
        axis: this.axis
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  $Q.className = "Softmax";
  we($Q);
  function Rg(n, e, t) {
    if (typeof n == "number") return Td(n, e);
    if (n.length !== e) throw new j(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);
    for (let r = 0; r < e; ++r) {
      const i = n[r];
      if (!YLe(i)) throw new j(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`);
    }
    return n;
  }
  function eo(n, e, t, r, i = 1) {
    if (n == null) return n;
    const a = e + (e - 1) * (i - 1);
    let s;
    return t === "same" ? s = n : s = n - a + 1, Math.floor((s + r - 1) / r);
  }
  function Po(n, e, t, r) {
    if (n == null) return null;
    if (r === "valid") n = n * e + uc([
      t - e,
      0
    ]);
    else if (r === "same") n = n * e;
    else throw new j(`Unsupport padding mode: ${r}.`);
    return n;
  }
  function aL(n, e) {
    return se(() => (fr(e), e === "channelsFirst" ? ln(n, [
      0,
      2,
      3,
      1
    ]) : n));
  }
  function NQ(n, e) {
    return se(() => (fr(e), e === "channelsFirst" ? ln(n, [
      0,
      2,
      3,
      4,
      1
    ]) : n));
  }
  function pFe(n, e, t, r = 1, i = "valid", a, s = 1) {
    return se(() => {
      if (a == null && (a = lo()), fr(a), n.shape.length !== 3) throw new j(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);
      if (e.shape.length !== 3) throw new j(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);
      if (t != null && t.shape.length !== 1) throw new j(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);
      if (a === "channelsFirst" && (n = ln(n, [
        0,
        2,
        1
      ])), i === "causal") throw new zt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      let o = _9(n, e, r, i === "same" ? "same" : "valid", "NWC", s);
      return t != null && (o = go(o, t)), o;
    });
  }
  function oU(n, e, t, r = [
    1,
    1
  ], i = "valid", a, s, o = null) {
    return se(() => {
      if (a == null && (a = lo()), fr(a), n.rank !== 3 && n.rank !== 4) throw new j(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);
      if (e.rank !== 3 && e.rank !== 4) throw new j(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);
      let l = aL(n, a);
      if (i === "causal") throw new zt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      return l = _Ee({
        x: l,
        filter: e,
        strides: r,
        pad: i === "same" ? "same" : "valid",
        dilations: s,
        dataFormat: "NHWC",
        bias: t,
        activation: o
      }), a === "channelsFirst" && (l = ln(l, [
        0,
        3,
        1,
        2
      ])), l;
    });
  }
  function gFe(n, e, t, r = [
    1,
    1,
    1
  ], i = "valid", a, s) {
    return se(() => {
      if (a == null && (a = lo()), fr(a), n.rank !== 4 && n.rank !== 5) throw new j(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);
      if (e.rank !== 4 && e.rank !== 5) throw new j(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);
      let o = NQ(n, a);
      if (i === "causal") throw new zt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
      return o = bRe(o, e, r, i === "same" ? "same" : "valid", "NDHWC", s), t != null && (o = go(o, t)), a === "channelsFirst" && (o = ln(o, [
        0,
        4,
        1,
        2,
        3
      ])), o;
    });
  }
  class ZI extends qt {
    constructor(e, t) {
      if (super(t), this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", ZI.verifyArgs(t), this.rank = e, Wr(this.rank, "rank"), this.rank !== 1 && this.rank !== 2 && this.rank !== 3) throw new zt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
      if (this.kernelSize = Rg(t.kernelSize, e, "kernelSize"), this.strides = Rg(t.strides == null ? 1 : t.strides, e, "strides"), this.padding = t.padding == null ? "valid" : t.padding, Za(this.padding), this.dataFormat = t.dataFormat == null ? "channelsLast" : t.dataFormat, fr(this.dataFormat), this.activation = hc(t.activation), this.useBias = t.useBias == null ? true : t.useBias, this.biasInitializer = Kn(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = Nr(t.biasConstraint), this.biasRegularizer = Zn(t.biasRegularizer), this.activityRegularizer = Zn(t.activityRegularizer), this.dilationRate = Rg(t.dilationRate == null ? 1 : t.dilationRate, e, "dilationRate"), this.rank === 1 && Array.isArray(this.dilationRate) && this.dilationRate.length !== 1) throw new j(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      if (this.rank === 2) {
        if (typeof this.dilationRate == "number") this.dilationRate = [
          this.dilationRate,
          this.dilationRate
        ];
        else if (this.dilationRate.length !== 2) throw new j(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      } else if (this.rank === 3) {
        if (typeof this.dilationRate == "number") this.dilationRate = [
          this.dilationRate,
          this.dilationRate,
          this.dilationRate
        ];
        else if (this.dilationRate.length !== 3) throw new j(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      }
    }
    static verifyArgs(e) {
      if (Mo("kernelSize" in e, "required key 'kernelSize' not in config"), typeof e.kernelSize != "number" && !HP(e.kernelSize, "number", 1, 3)) throw new j(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`);
    }
    getConfig() {
      const e = {
        kernelSize: this.kernelSize,
        strides: this.strides,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        activation: cc(this.activation),
        useBias: this.useBias,
        biasInitializer: tr(this.biasInitializer),
        biasRegularizer: On(this.biasRegularizer),
        activityRegularizer: On(this.activityRegularizer),
        biasConstraint: $r(this.biasConstraint)
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  class Dv extends ZI {
    constructor(e, t) {
      super(e, t), this.kernel = null, Dv.verifyArgs(t), this.filters = t.filters, Wr(this.filters, "filters"), this.kernelInitializer = Kn(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = Nr(t.kernelConstraint), this.kernelRegularizer = Zn(t.kernelRegularizer);
    }
    build(e) {
      e = dn(e);
      const t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
      if (e[t] == null) throw new j(`The channel dimension of the input should be defined. Found ${e[t]}`);
      const r = e[t], i = this.kernelSize.concat([
        r,
        this.filters
      ]);
      this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
        this.filters
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [
        {
          ndim: this.rank + 2,
          axes: {
            [t]: r
          }
        }
      ], this.built = true;
    }
    call(e, t) {
      return se(() => {
        e = St(e);
        let r;
        const i = this.bias == null ? null : this.bias.read(), a = AZ(this.activation.getClassName());
        if (a != null && this.rank === 2) r = oU(e, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate, a);
        else {
          if (this.rank === 1) r = pFe(e, this.kernel.read(), i, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
          else if (this.rank === 2) r = oU(e, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate);
          else if (this.rank === 3) r = gFe(e, this.kernel.read(), i, this.strides, this.padding, this.dataFormat, this.dilationRate);
          else throw new zt("convolutions greater than 3D are not implemented yet.");
          this.activation != null && (r = this.activation.apply(r));
        }
        return r;
      });
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = [], r = this.dataFormat === "channelsLast" ? e.slice(1, e.length - 1) : e.slice(2);
      for (let a = 0; a < r.length; ++a) {
        const s = eo(r[a], this.kernelSize[a], this.padding, this.strides[a], typeof this.dilationRate == "number" ? this.dilationRate : this.dilationRate[a]);
        t.push(s);
      }
      let i = [
        e[0]
      ];
      return this.dataFormat === "channelsLast" ? (i = i.concat(t), i.push(this.filters)) : (i.push(this.filters), i = i.concat(t)), i;
    }
    getConfig() {
      const e = {
        filters: this.filters,
        kernelInitializer: tr(this.kernelInitializer),
        kernelRegularizer: On(this.kernelRegularizer),
        kernelConstraint: $r(this.kernelConstraint)
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    static verifyArgs(e) {
      if (!("filters" in e) || typeof e.filters != "number" || e.filters < 1) throw new j(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`);
    }
  }
  class Bb extends Dv {
    constructor(e) {
      super(2, e), Bb.verifyArgs(e);
    }
    getConfig() {
      const e = super.getConfig();
      return delete e.rank, e;
    }
    static verifyArgs(e) {
      if (typeof e.kernelSize != "number" && !HP(e.kernelSize, "number", 1, 2)) throw new j(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`);
    }
  }
  Bb.className = "Conv2D";
  we(Bb);
  class zb extends Dv {
    constructor(e) {
      super(3, e), zb.verifyArgs(e);
    }
    getConfig() {
      const e = super.getConfig();
      return delete e.rank, e;
    }
    static verifyArgs(e) {
      if (typeof e.kernelSize != "number" && !(Array.isArray(e.kernelSize) && (e.kernelSize.length === 1 || e.kernelSize.length === 3))) throw new j(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`);
    }
  }
  zb.className = "Conv3D";
  we(zb);
  class EQ extends Bb {
    constructor(e) {
      if (super(e), this.inputSpec = [
        new Ar({
          ndim: 4
        })
      ], this.padding !== "same" && this.padding !== "valid") throw new j(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
    }
    build(e) {
      if (e = dn(e), e.length !== 4) throw new j("Input should have rank 4; Received input shape: " + JSON.stringify(e));
      const t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
      if (e[t] == null) throw new j("The channel dimension of the inputs should be defined. Found `None`.");
      const r = e[t], i = this.kernelSize.concat([
        this.filters,
        r
      ]);
      this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
        this.filters
      ], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [
        new Ar({
          ndim: 4,
          axes: {
            [t]: r
          }
        })
      ], this.built = true;
    }
    call(e, t) {
      return se(() => {
        let r = St(e);
        if (r.shape.length !== 4) throw new j(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);
        const i = r.shape, a = i[0];
        let s, o;
        this.dataFormat === "channelsFirst" ? (s = 2, o = 3) : (s = 1, o = 2);
        const l = i[s], u = i[o], c = this.kernelSize[0], h = this.kernelSize[1], d = this.strides[0], f = this.strides[1], p = Po(l, d, c, this.padding), g = Po(u, f, h, this.padding), m = [
          a,
          p,
          g,
          this.filters
        ];
        this.dataFormat !== "channelsLast" && (r = ln(r, [
          0,
          2,
          3,
          1
        ]));
        let v = S9(r, this.kernel.read(), m, this.strides, this.padding);
        return this.dataFormat !== "channelsLast" && (v = ln(v, [
          0,
          3,
          1,
          2
        ])), this.bias != null && (v = go(v, this.bias.read(), this.dataFormat)), this.activation != null && (v = this.activation.apply(v)), v;
      });
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = e.slice();
      let r, i, a;
      this.dataFormat === "channelsFirst" ? (r = 1, i = 2, a = 3) : (r = 3, i = 1, a = 2);
      const s = this.kernelSize[0], o = this.kernelSize[1], l = this.strides[0], u = this.strides[1];
      return t[r] = this.filters, t[i] = Po(t[i], l, s, this.padding), t[a] = Po(t[a], u, o, this.padding), t;
    }
    getConfig() {
      const e = super.getConfig();
      return delete e.dilationRate, e;
    }
  }
  EQ.className = "Conv2DTranspose";
  we(EQ);
  class MQ extends zb {
    constructor(e) {
      if (super(e), this.inputSpec = [
        new Ar({
          ndim: 5
        })
      ], this.padding !== "same" && this.padding !== "valid") throw new j(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
    }
    build(e) {
      if (e = dn(e), e.length !== 5) throw new j("Input should have rank 5; Received input shape: " + JSON.stringify(e));
      const t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
      if (e[t] == null) throw new j("The channel dimension of the inputs should be defined. Found `None`.");
      const r = e[t], i = this.kernelSize.concat([
        this.filters,
        r
      ]);
      this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
        this.filters
      ], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint)), this.inputSpec = [
        new Ar({
          ndim: 5,
          axes: {
            [t]: r
          }
        })
      ], this.built = true;
    }
    call(e, t) {
      return se(() => {
        let r = St(e);
        if (r.shape.length !== 5) throw new j(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);
        const i = r.shape, a = i[0];
        let s, o, l;
        this.dataFormat === "channelsFirst" ? (l = 2, s = 3, o = 4) : (l = 1, s = 2, o = 3);
        const u = i[l], c = i[s], h = i[o], d = this.kernelSize[0], f = this.kernelSize[1], p = this.kernelSize[2], g = this.strides[0], m = this.strides[1], v = this.strides[2], y = Po(u, g, d, this.padding), x = Po(c, m, f, this.padding), b = Po(h, v, p, this.padding), w = [
          a,
          y,
          x,
          b,
          this.filters
        ];
        this.dataFormat !== "channelsLast" && (r = ln(r, [
          0,
          2,
          3,
          4,
          1
        ]));
        let _ = SRe(r, this.kernel.read(), w, this.strides, this.padding);
        return this.dataFormat !== "channelsLast" && (_ = ln(_, [
          0,
          4,
          1,
          2,
          3
        ])), this.bias !== null && (_ = go(_, this.bias.read(), this.dataFormat)), this.activation !== null && (_ = this.activation.apply(_)), _;
      });
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = e.slice();
      let r, i, a, s;
      this.dataFormat === "channelsFirst" ? (r = 1, i = 2, a = 3, s = 4) : (r = 4, i = 1, a = 2, s = 3);
      const o = this.kernelSize[0], l = this.kernelSize[1], u = this.kernelSize[2], c = this.strides[0], h = this.strides[1], d = this.strides[2];
      return t[r] = this.filters, t[i] = Po(t[i], c, o, this.padding), t[a] = Po(t[a], h, l, this.padding), t[s] = Po(t[s], d, u, this.padding), t;
    }
    getConfig() {
      const e = super.getConfig();
      return delete e.dilationRate, e;
    }
  }
  MQ.className = "Conv3DTranspose";
  we(MQ);
  class PQ extends Dv {
    constructor(e, t) {
      if (super(e, t), this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, t.filters == null) throw new j("The `filters` configuration field is required by SeparableConv, but is unspecified.");
      if (t.kernelInitializer != null || t.kernelRegularizer != null || t.kernelConstraint != null) throw new j("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
      if (t.padding != null && t.padding !== "same" && t.padding !== "valid") throw new j(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);
      this.depthMultiplier = t.depthMultiplier == null ? 1 : t.depthMultiplier, this.depthwiseInitializer = Kn(t.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = Zn(t.depthwiseRegularizer), this.depthwiseConstraint = Nr(t.depthwiseConstraint), this.pointwiseInitializer = Kn(t.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = Zn(t.pointwiseRegularizer), this.pointwiseConstraint = Nr(t.pointwiseConstraint);
    }
    build(e) {
      if (e = dn(e), e.length < this.rank + 2) throw new j(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(e)}`);
      const t = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
      if (e[t] == null || e[t] < 0) throw new j(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);
      const r = e[t], i = this.kernelSize.concat([
        r,
        this.depthMultiplier
      ]), a = [];
      for (let o = 0; o < this.rank; ++o) a.push(1);
      a.push(r * this.depthMultiplier, this.filters);
      const s = true;
      this.depthwiseKernel = this.addWeight("depthwise_kernel", i, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, s, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", a, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, s, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [
        this.filters
      ], "float32", this.biasInitializer, this.biasRegularizer, s, this.biasConstraint) : this.bias = null, this.inputSpec = [
        new Ar({
          ndim: this.rank + 2,
          axes: {
            [t]: r
          }
        })
      ], this.built = true;
    }
    call(e, t) {
      return se(() => {
        e = St(e);
        let r;
        if (this.rank === 1) throw new zt("1D separable convolution is not implemented yet.");
        return this.rank === 2 && (this.dataFormat === "channelsFirst" && (e = ln(e, [
          0,
          2,
          3,
          1
        ])), r = V9(e, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (r = go(r, this.bias.read(), this.dataFormat)), this.activation != null && (r = this.activation.apply(r)), this.dataFormat === "channelsFirst" && (r = ln(r, [
          0,
          3,
          1,
          2
        ])), r;
      });
    }
    getConfig() {
      const e = super.getConfig();
      return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = tr(this.depthwiseInitializer), e.pointwiseInitializer = tr(this.pointwiseInitializer), e.depthwiseRegularizer = On(this.depthwiseRegularizer), e.pointwiseRegularizer = On(this.pointwiseRegularizer), e.depthwiseConstraint = $r(this.depthwiseConstraint), e.pointwiseConstraint = $r(this.pointwiseConstraint), e;
    }
  }
  PQ.className = "SeparableConv";
  class LQ extends PQ {
    constructor(e) {
      super(2, e);
    }
  }
  LQ.className = "SeparableConv2D";
  we(LQ);
  class QI extends Dv {
    constructor(e) {
      super(1, e), QI.verifyArgs(e), this.inputSpec = [
        {
          ndim: 3
        }
      ];
    }
    getConfig() {
      const e = super.getConfig();
      return delete e.rank, delete e.dataFormat, e;
    }
    static verifyArgs(e) {
      if (typeof e.kernelSize != "number" && !HP(e.kernelSize, "number", 1, 1)) throw new j(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`);
    }
  }
  QI.className = "Conv1D";
  we(QI);
  class FQ extends qt {
    constructor(e) {
      super(e), typeof e.cropping == "number" ? this.cropping = [
        [
          e.cropping,
          e.cropping
        ],
        [
          e.cropping,
          e.cropping
        ]
      ] : typeof e.cropping[0] == "number" ? this.cropping = [
        [
          e.cropping[0],
          e.cropping[0]
        ],
        [
          e.cropping[1],
          e.cropping[1]
        ]
      ] : this.cropping = e.cropping, this.dataFormat = e.dataFormat === void 0 ? "channelsLast" : e.dataFormat, this.inputSpec = [
        {
          ndim: 4
        }
      ];
    }
    computeOutputShape(e) {
      return this.dataFormat === "channelsFirst" ? [
        e[0],
        e[1],
        e[2] - this.cropping[0][0] - this.cropping[0][1],
        e[3] - this.cropping[1][0] - this.cropping[1][1]
      ] : [
        e[0],
        e[1] - this.cropping[0][0] - this.cropping[0][1],
        e[2] - this.cropping[1][0] - this.cropping[1][1],
        e[3]
      ];
    }
    call(e, t) {
      return se(() => {
        if (e = St(e), this.dataFormat === "channelsLast") {
          const r = vw(e, this.cropping[0][0], e.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
          return vw(r, this.cropping[1][0], e.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
        } else {
          const r = vw(e, this.cropping[0][0], e.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
          return vw(r, this.cropping[1][0], e.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
        }
      });
    }
    getConfig() {
      const e = {
        cropping: this.cropping,
        dataFormat: this.dataFormat
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  FQ.className = "Cropping2D";
  we(FQ);
  class OQ extends qt {
    constructor(e) {
      super(e), this.DEFAULT_SIZE = [
        2,
        2
      ], this.inputSpec = [
        {
          ndim: 4
        }
      ], this.size = e.size == null ? this.DEFAULT_SIZE : e.size, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, fr(this.dataFormat), this.interpolation = e.interpolation == null ? "nearest" : e.interpolation, ULe(this.interpolation);
    }
    computeOutputShape(e) {
      if (this.dataFormat === "channelsFirst") {
        const t = e[2] == null ? null : this.size[0] * e[2], r = e[3] == null ? null : this.size[1] * e[3];
        return [
          e[0],
          e[1],
          t,
          r
        ];
      } else {
        const t = e[1] == null ? null : this.size[0] * e[1], r = e[2] == null ? null : this.size[1] * e[2];
        return [
          e[0],
          t,
          r,
          e[3]
        ];
      }
    }
    call(e, t) {
      return se(() => {
        let r = St(e);
        const i = r.shape;
        if (this.dataFormat === "channelsFirst") {
          r = ln(r, [
            0,
            2,
            3,
            1
          ]);
          const a = this.size[0] * i[2], s = this.size[1] * i[3], o = this.interpolation === "nearest" ? Dl.resizeNearestNeighbor(r, [
            a,
            s
          ]) : Dl.resizeBilinear(r, [
            a,
            s
          ]);
          return ln(o, [
            0,
            3,
            1,
            2
          ]);
        } else {
          const a = this.size[0] * i[1], s = this.size[1] * i[2];
          return this.interpolation === "nearest" ? Dl.resizeNearestNeighbor(r, [
            a,
            s
          ]) : Dl.resizeBilinear(r, [
            a,
            s
          ]);
        }
      });
    }
    getConfig() {
      const e = {
        size: this.size,
        dataFormat: this.dataFormat,
        interpolation: this.interpolation
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  OQ.className = "UpSampling2D";
  we(OQ);
  function mFe(n, e, t = [
    1,
    1
  ], r = "valid", i, a) {
    return se(() => {
      i == null && (i = lo()), fr(i);
      let s = aL(n, i);
      if (n.rank !== 4) throw new j(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);
      if (e.rank !== 4) throw new j(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);
      return s = aP(s, e, t, r === "same" ? "same" : "valid", "NHWC", a), i === "channelsFirst" && (s = ln(s, [
        0,
        3,
        1,
        2
      ])), s;
    });
  }
  class BQ extends ZI {
    constructor(e) {
      super(2, e), this.depthwiseKernel = null, this.depthMultiplier = e.depthMultiplier == null ? 1 : e.depthMultiplier, this.depthwiseInitializer = Kn(e.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = Nr(e.depthwiseConstraint), this.depthwiseRegularizer = Zn(e.depthwiseRegularizer);
    }
    build(e) {
      if (e = dn(e), e.length < 4) throw new j(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);
      const t = this.dataFormat === "channelsFirst" ? 1 : 3;
      if (e[t] == null || e[t] < 0) throw new j(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);
      const r = e[t], i = [
        this.kernelSize[0],
        this.kernelSize[1],
        r,
        this.depthMultiplier
      ];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", i, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [
        r * this.depthMultiplier
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(e, t) {
      return se(() => {
        e = St(e);
        let r = mFe(e, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
        return this.useBias && (r = go(r, this.bias.read(), this.dataFormat)), this.activation != null && (r = this.activation.apply(r)), r;
      });
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = this.dataFormat === "channelsFirst" ? e[2] : e[1], r = this.dataFormat === "channelsFirst" ? e[3] : e[2], i = this.dataFormat === "channelsFirst" ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier, a = eo(t, this.kernelSize[0], this.padding, this.strides[0]), s = eo(r, this.kernelSize[1], this.padding, this.strides[1]);
      return this.dataFormat === "channelsFirst" ? [
        e[0],
        i,
        a,
        s
      ] : [
        e[0],
        a,
        s,
        i
      ];
    }
    getConfig() {
      const e = super.getConfig();
      return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = tr(this.depthwiseInitializer), e.depthwiseRegularizer = On(this.depthwiseRegularizer), e.depthwiseConstraint = $r(this.depthwiseRegularizer), e;
    }
  }
  BQ.className = "DepthwiseConv2D";
  we(BQ);
  function zQ(n, e, t, r) {
    if (Array.isArray(n)) {
      if (e != null || t != null) throw new j("When inputs is an array, neither initialState or constants should be provided");
      r != null && (t = n.slice(n.length - r, n.length), n = n.slice(0, n.length - r)), n.length > 1 && (e = n.slice(1, n.length)), n = n[0];
    }
    function i(a) {
      return a == null || Array.isArray(a) ? a : [
        a
      ];
    }
    return e = i(e), t = i(t), {
      inputs: n,
      initialState: e,
      constants: t
    };
  }
  function VQ(n, e, t, r = false, i, a, s = false, o = false) {
    return se(() => {
      const l = e.shape.length;
      if (l < 3) throw new j(`Input should be at least 3D, but is ${l}D.`);
      const u = [
        1,
        0
      ].concat(oo(2, l));
      e = ln(e, u), s && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), i != null && (i = Ve(Ve(i, "bool"), "float32"), i.rank === l - 1 && (i = Xi(i, -1)), i = ln(i, u)), r && (e = Id(e, 0), i != null && (i = Id(i, 0)));
      const c = [];
      let h, d = t;
      const f = e.shape[0], p = kd(e);
      let g;
      i != null && (g = kd(i));
      for (let v = 0; v < f; ++v) {
        const y = p[v], x = se(() => n(y, d));
        if (i == null) h = x[0], d = x[1];
        else {
          const b = se(() => {
            const w = g[v], _ = wt(Cs(w), w), S = Ce(Z(x[0], w), Z(d[0], _)), I = d.map((C, T) => Ce(Z(x[1][T], w), Z(C, _)));
            return {
              output: S,
              newStates: I
            };
          });
          h = b.output, d = b.newStates;
        }
        o && c.push(h);
      }
      let m;
      return o && (m = tu(c, 1)), [
        h,
        m,
        d
      ];
    });
  }
  class Tc extends qt {
    constructor(e) {
      super(e);
      let t;
      if (e.cell == null) throw new j("cell property is missing for the constructor of RNN.");
      if (Array.isArray(e.cell) ? t = new lL({
        cells: e.cell
      }) : t = e.cell, t.stateSize == null) throw new j("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
      this.cell = t, this.returnSequences = e.returnSequences == null ? false : e.returnSequences, this.returnState = e.returnState == null ? false : e.returnState, this.goBackwards = e.goBackwards == null ? false : e.goBackwards, this._stateful = e.stateful == null ? false : e.stateful, this.unroll = e.unroll == null ? false : e.unroll, this.supportsMasking = true, this.inputSpec = [
        new Ar({
          ndim: 3
        })
      ], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = [];
    }
    getStates() {
      if (this.states_ == null) {
        const e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        return oo(0, e).map((t) => null);
      } else return this.states_;
    }
    setStates(e) {
      this.states_ = e;
    }
    computeOutputShape(e) {
      T$(e) && (e = e[0]), e = e;
      let t = this.cell.stateSize;
      Array.isArray(t) || (t = [
        t
      ]);
      const r = t[0];
      let i;
      if (this.returnSequences ? i = [
        e[0],
        e[1],
        r
      ] : i = [
        e[0],
        r
      ], this.returnState) {
        const a = [];
        for (const s of t) a.push([
          e[0],
          s
        ]);
        return [
          i
        ].concat(a);
      } else return i;
    }
    computeMask(e, t) {
      return se(() => {
        Array.isArray(t) && (t = t[0]);
        const r = this.returnSequences ? t : null;
        if (this.returnState) {
          const i = this.states.map((a) => null);
          return [
            r
          ].concat(i);
        } else return r;
      });
    }
    get states() {
      if (this.states_ == null) {
        const e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t = [];
        for (let r = 0; r < e; ++r) t.push(null);
        return t;
      } else return this.states_;
    }
    set states(e) {
      this.states_ = e;
    }
    build(e) {
      if (this.numConstants != null) throw new zt("Constants support is not implemented in RNN yet.");
      T$(e) && (e = e[0]), e = e;
      const t = this.stateful ? e[0] : null, r = e.slice(2);
      this.inputSpec[0] = new Ar({
        shape: [
          t,
          null,
          ...r
        ]
      });
      const i = [
        e[0]
      ].concat(e.slice(2));
      this.cell.build(i);
      let a;
      if (Array.isArray(this.cell.stateSize) ? a = this.cell.stateSize : a = [
        this.cell.stateSize
      ], this.stateSpec != null) {
        if (!Jt(this.stateSpec.map((s) => s.shape[s.shape.length - 1]), a)) throw new j(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
      } else this.stateSpec = a.map((s) => new Ar({
        shape: [
          null,
          s
        ]
      }));
      this.stateful && this.resetStates();
    }
    resetStates(e, t = false) {
      se(() => {
        if (!this.stateful) throw new Eo("Cannot call resetStates() on an RNN Layer that is not stateful.");
        const r = this.inputSpec[0].shape[0];
        if (r == null) throw new j("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (this.states_ == null) Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((i) => Cr([
          r,
          i
        ])) : this.states_ = [
          Cr([
            r,
            this.cell.stateSize
          ])
        ];
        else if (e == null) jt(this.states_), this.keptStates != null && (jt(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((i) => Cr([
          r,
          i
        ])) : this.states_[0] = Cr([
          r,
          this.cell.stateSize
        ]);
        else {
          if (Array.isArray(e) || (e = [
            e
          ]), e.length !== this.states_.length) throw new j(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
          t === true ? this.keptStates.push(this.states_.slice()) : jt(this.states_);
          for (let i = 0; i < this.states_.length; ++i) {
            const a = e[i], s = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[i] : this.cell.stateSize, o = [
              r,
              s
            ];
            if (!Jt(a.shape, o)) throw new j(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);
            this.states_[i] = a;
          }
        }
        this.states_ = this.states_.map((i) => qo(i.clone()));
      });
    }
    apply(e, t) {
      let r = t == null ? null : t.initialState, i = t == null ? null : t.constants;
      t == null && (t = {});
      const a = zQ(e, r, i, this.numConstants);
      e = a.inputs, r = a.initialState, i = a.constants;
      let s = [], o = [];
      if (r != null) {
        t.initialState = r, s = s.concat(r), this.stateSpec = [];
        for (const u of r) this.stateSpec.push(new Ar({
          shape: u.shape
        }));
        o = o.concat(this.stateSpec);
      }
      if (i != null && (t.constants = i, s = s.concat(i), this.numConstants = i.length), s[0] instanceof sl) {
        const u = [
          e
        ].concat(s), c = this.inputSpec.concat(o), h = this.inputSpec;
        this.inputSpec = c;
        const d = super.apply(u, t);
        return this.inputSpec = h, d;
      } else return super.apply(e, t);
    }
    call(e, t) {
      return se(() => {
        const r = t == null ? null : t.mask, i = t == null ? null : t.training;
        let a = t == null ? null : t.initialState;
        e = St(e), a == null && (this.stateful ? a = this.states_ : a = this.getInitialState(e));
        const s = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        if (a.length !== s) throw new j(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);
        this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
        const o = {
          training: i
        }, u = VQ((p, g) => {
          const m = this.cell.call([
            p
          ].concat(g), o);
          return [
            m[0],
            m.slice(1)
          ];
        }, e, a, this.goBackwards, r, null, this.unroll, this.returnSequences), c = u[0], h = u[1], d = u[2];
        this.stateful && this.resetStates(d, i);
        const f = this.returnSequences ? h : c;
        return this.returnState ? [
          f
        ].concat(d) : f;
      });
    }
    getInitialState(e) {
      return se(() => {
        let t = Cr(e.shape);
        return t = ct(t, [
          1,
          2
        ]), t = Mb(t), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map((r) => r > 1 ? I$(t, [
          1,
          r
        ]) : t) : this.cell.stateSize > 1 ? [
          I$(t, [
            1,
            this.cell.stateSize
          ])
        ] : [
          t
        ];
      });
    }
    get trainableWeights() {
      return this.trainable ? this.cell.trainableWeights : [];
    }
    get nonTrainableWeights() {
      return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
    }
    setFastWeightInitDuringBuild(e) {
      super.setFastWeightInitDuringBuild(e), this.cell != null && this.cell.setFastWeightInitDuringBuild(e);
    }
    getConfig() {
      const e = super.getConfig(), t = {
        returnSequences: this.returnSequences,
        returnState: this.returnState,
        goBackwards: this.goBackwards,
        stateful: this.stateful,
        unroll: this.unroll
      };
      this.numConstants != null && (t.numConstants = this.numConstants);
      const r = this.cell.getConfig();
      return this.getClassName() === Tc.className && (t.cell = {
        className: this.cell.getClassName(),
        config: r
      }), Object.assign(Object.assign(Object.assign({}, r), e), t);
    }
    static fromConfig(e, t, r = {}) {
      const i = t.cell, a = zl(i, r);
      return new e(Object.assign(t, {
        cell: a
      }));
    }
  }
  Tc.className = "RNN";
  we(Tc);
  class JI extends qt {
  }
  class sL extends JI {
    constructor(e) {
      super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, Wr(this.units, "units"), this.activation = hc(e.activation == null ? this.DEFAULT_ACTIVATION : e.activation), this.useBias = e.useBias == null ? true : e.useBias, this.kernelInitializer = Kn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Kn(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Kn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = Zn(e.kernelRegularizer), this.recurrentRegularizer = Zn(e.recurrentRegularizer), this.biasRegularizer = Zn(e.biasRegularizer), this.kernelConstraint = Nr(e.kernelConstraint), this.recurrentConstraint = Nr(e.recurrentConstraint), this.biasConstraint = Nr(e.biasConstraint), this.dropout = Zg([
        1,
        uc([
          0,
          e.dropout == null ? 0 : e.dropout
        ])
      ]), this.recurrentDropout = Zg([
        1,
        uc([
          0,
          e.recurrentDropout == null ? 0 : e.recurrentDropout
        ])
      ]), this.dropoutFunc = e.dropoutFunc, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(e) {
      e = dn(e), this.kernel = this.addWeight("kernel", [
        e[e.length - 1],
        this.units
      ], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
        this.units,
        this.units
      ], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [
        this.units
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(e, t) {
      return se(() => {
        if (e = e, e.length !== 2) throw new j(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);
        let r = e[1];
        e = e[0];
        const i = t.training == null ? false : t.training;
        0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = dc({
          ones: () => Cs(e),
          rate: this.dropout,
          training: i,
          dropoutFunc: this.dropoutFunc
        })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = dc({
          ones: () => Cs(r),
          rate: this.recurrentDropout,
          training: i,
          dropoutFunc: this.dropoutFunc
        }));
        let a;
        const s = this.dropoutMask, o = this.recurrentDropoutMask;
        s != null ? a = Ko(Z(e, s), this.kernel.read()) : a = Ko(e, this.kernel.read()), this.bias != null && (a = go(a, this.bias.read())), o != null && (r = Z(r, o));
        let l = Ce(a, Ko(r, this.recurrentKernel.read()));
        return this.activation != null && (l = this.activation.apply(l)), [
          l,
          l
        ];
      });
    }
    getConfig() {
      const e = super.getConfig(), t = {
        units: this.units,
        activation: cc(this.activation),
        useBias: this.useBias,
        kernelInitializer: tr(this.kernelInitializer),
        recurrentInitializer: tr(this.recurrentInitializer),
        biasInitializer: tr(this.biasInitializer),
        kernelRegularizer: On(this.kernelRegularizer),
        recurrentRegularizer: On(this.recurrentRegularizer),
        biasRegularizer: On(this.biasRegularizer),
        activityRegularizer: On(this.activityRegularizer),
        kernelConstraint: $r(this.kernelConstraint),
        recurrentConstraint: $r(this.recurrentConstraint),
        biasConstraint: $r(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout
      };
      return Object.assign(Object.assign({}, e), t);
    }
  }
  sL.className = "SimpleRNNCell";
  we(sL);
  class WQ extends Tc {
    constructor(e) {
      e.cell = new sL(e), super(e);
    }
    call(e, t) {
      return se(() => {
        this.cell.dropoutMask != null && (jt(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (jt(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        const r = t == null ? null : t.mask, i = t == null ? null : t.training, a = t == null ? null : t.initialState;
        return super.call(e, {
          mask: r,
          training: i,
          initialState: a
        });
      });
    }
    static fromConfig(e, t) {
      return new e(t);
    }
  }
  WQ.className = "SimpleRNN";
  we(WQ);
  class oL extends JI {
    constructor(e) {
      if (super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.resetAfter) throw new j("GRUCell does not support reset_after parameter set to true.");
      this.units = e.units, Wr(this.units, "units"), this.activation = hc(e.activation === void 0 ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = hc(e.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = e.useBias == null ? true : e.useBias, this.kernelInitializer = Kn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Kn(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Kn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = Zn(e.kernelRegularizer), this.recurrentRegularizer = Zn(e.recurrentRegularizer), this.biasRegularizer = Zn(e.biasRegularizer), this.kernelConstraint = Nr(e.kernelConstraint), this.recurrentConstraint = Nr(e.recurrentConstraint), this.biasConstraint = Nr(e.biasConstraint), this.dropout = Zg([
        1,
        uc([
          0,
          e.dropout == null ? 0 : e.dropout
        ])
      ]), this.recurrentDropout = Zg([
        1,
        uc([
          0,
          e.recurrentDropout == null ? 0 : e.recurrentDropout
        ])
      ]), this.dropoutFunc = e.dropoutFunc, this.implementation = e.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(e) {
      e = dn(e);
      const t = e[e.length - 1];
      this.kernel = this.addWeight("kernel", [
        t,
        this.units * 3
      ], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
        this.units,
        this.units * 3
      ], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [
        this.units * 3
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint) : this.bias = null, this.built = true;
    }
    call(e, t) {
      return se(() => {
        if (e = e, e.length !== 2) throw new j(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);
        const r = t.training == null ? false : t.training;
        let i = e[1];
        e = e[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = dc({
          ones: () => Cs(e),
          rate: this.dropout,
          training: r,
          count: 3,
          dropoutFunc: this.dropoutFunc
        })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = dc({
          ones: () => Cs(i),
          rate: this.recurrentDropout,
          training: r,
          count: 3,
          dropoutFunc: this.dropoutFunc
        }));
        const a = this.dropoutMask, s = this.recurrentDropoutMask;
        let o, l, u;
        0 < this.dropout && this.dropout < 1 && (e = Z(e, a[0]));
        let c = Ko(e, this.kernel.read());
        this.useBias && (c = go(c, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (i = Z(i, s[0]));
        const h = this.recurrentKernel.read(), [d, f] = Ga(h, [
          2 * this.units,
          this.units
        ], h.rank - 1), p = Ko(i, d), [g, m, v] = Ga(c, 3, c.rank - 1), [y, x] = Ga(p, 2, p.rank - 1);
        o = this.recurrentActivation.apply(Ce(g, y)), l = this.recurrentActivation.apply(Ce(m, x));
        const b = Ko(Z(l, i), f);
        u = this.activation.apply(Ce(v, b));
        const w = Ce(Z(o, i), Z(Ce(1, cr(o)), u));
        return [
          w,
          w
        ];
      });
    }
    getConfig() {
      const e = super.getConfig(), t = {
        units: this.units,
        activation: cc(this.activation),
        recurrentActivation: cc(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: tr(this.kernelInitializer),
        recurrentInitializer: tr(this.recurrentInitializer),
        biasInitializer: tr(this.biasInitializer),
        kernelRegularizer: On(this.kernelRegularizer),
        recurrentRegularizer: On(this.recurrentRegularizer),
        biasRegularizer: On(this.biasRegularizer),
        activityRegularizer: On(this.activityRegularizer),
        kernelConstraint: $r(this.kernelConstraint),
        recurrentConstraint: $r(this.recurrentConstraint),
        biasConstraint: $r(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation,
        resetAfter: false
      };
      return Object.assign(Object.assign({}, e), t);
    }
  }
  oL.className = "GRUCell";
  we(oL);
  class GQ extends Tc {
    constructor(e) {
      e.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new oL(e), super(e);
    }
    call(e, t) {
      return se(() => {
        this.cell.dropoutMask != null && (jt(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (jt(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        const r = t == null ? null : t.mask, i = t == null ? null : t.training, a = t == null ? null : t.initialState;
        return super.call(e, {
          mask: r,
          training: i,
          initialState: a
        });
      });
    }
    static fromConfig(e, t) {
      return t.implmentation === 0 && (t.implementation = 1), new e(t);
    }
  }
  GQ.className = "GRU";
  we(GQ);
  class e2 extends JI {
    constructor(e) {
      super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, Wr(this.units, "units"), this.activation = hc(e.activation === void 0 ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = hc(e.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = e.useBias == null ? true : e.useBias, this.kernelInitializer = Kn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Kn(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Kn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = e.unitForgetBias, this.kernelRegularizer = Zn(e.kernelRegularizer), this.recurrentRegularizer = Zn(e.recurrentRegularizer), this.biasRegularizer = Zn(e.biasRegularizer), this.kernelConstraint = Nr(e.kernelConstraint), this.recurrentConstraint = Nr(e.recurrentConstraint), this.biasConstraint = Nr(e.biasConstraint), this.dropout = Zg([
        1,
        uc([
          0,
          e.dropout == null ? 0 : e.dropout
        ])
      ]), this.recurrentDropout = Zg([
        1,
        uc([
          0,
          e.recurrentDropout == null ? 0 : e.recurrentDropout
        ])
      ]), this.dropoutFunc = e.dropoutFunc, this.implementation = e.implementation, this.stateSize = [
        this.units,
        this.units
      ], this.dropoutMask = null, this.recurrentDropoutMask = null;
    }
    build(e) {
      var t;
      e = dn(e);
      const r = e[e.length - 1];
      this.kernel = this.addWeight("kernel", [
        r,
        this.units * 4
      ], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
        this.units,
        this.units * 4
      ], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      let i;
      if (this.useBias) {
        if (this.unitForgetBias) {
          const a = this.biasInitializer, s = this.units;
          i = new (t = class extends Ds {
            apply(l, u) {
              const c = a.apply([
                s
              ]), h = new YP().apply([
                s
              ]), d = a.apply([
                s * 2
              ]);
              return U4(U4(c, h), d);
            }
          }, t.className = "CustomInit", t)();
        } else i = this.biasInitializer;
        this.bias = this.addWeight("bias", [
          this.units * 4
        ], null, i, this.biasRegularizer, true, this.biasConstraint);
      } else this.bias = null;
      this.built = true;
    }
    call(e, t) {
      return se(() => {
        const r = t.training == null ? false : t.training;
        if (e = e, e.length !== 3) throw new j(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
        let i = e[1];
        const a = e[2];
        e = e[0], 0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = dc({
          ones: () => Cs(e),
          rate: this.dropout,
          training: r,
          count: 4,
          dropoutFunc: this.dropoutFunc
        })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = dc({
          ones: () => Cs(i),
          rate: this.recurrentDropout,
          training: r,
          count: 4,
          dropoutFunc: this.dropoutFunc
        }));
        const s = this.dropoutMask, o = this.recurrentDropoutMask;
        let l, u, c, h;
        0 < this.dropout && this.dropout < 1 && (e = Z(e, s[0]));
        let d = Ko(e, this.kernel.read());
        0 < this.recurrentDropout && this.recurrentDropout < 1 && (i = Z(i, o[0])), d = Ce(d, Ko(i, this.recurrentKernel.read())), this.useBias && (d = go(d, this.bias.read()));
        const [f, p, g, m] = Ga(d, 4, d.rank - 1);
        l = this.recurrentActivation.apply(f), u = this.recurrentActivation.apply(p), c = Ce(Z(u, a), Z(l, this.activation.apply(g))), h = this.recurrentActivation.apply(m);
        const v = Z(h, this.activation.apply(c));
        return [
          v,
          v,
          c
        ];
      });
    }
    getConfig() {
      const e = super.getConfig(), t = {
        units: this.units,
        activation: cc(this.activation),
        recurrentActivation: cc(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: tr(this.kernelInitializer),
        recurrentInitializer: tr(this.recurrentInitializer),
        biasInitializer: tr(this.biasInitializer),
        unitForgetBias: this.unitForgetBias,
        kernelRegularizer: On(this.kernelRegularizer),
        recurrentRegularizer: On(this.recurrentRegularizer),
        biasRegularizer: On(this.biasRegularizer),
        activityRegularizer: On(this.activityRegularizer),
        kernelConstraint: $r(this.kernelConstraint),
        recurrentConstraint: $r(this.recurrentConstraint),
        biasConstraint: $r(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
      };
      return Object.assign(Object.assign({}, e), t);
    }
  }
  e2.className = "LSTMCell";
  we(e2);
  class UQ extends Tc {
    constructor(e) {
      e.implementation === 0 && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new e2(e), super(e);
    }
    call(e, t) {
      return se(() => {
        this.cell.dropoutMask != null && (jt(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (jt(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
        const r = t == null ? null : t.mask, i = t == null ? null : t.training, a = t == null ? null : t.initialState;
        return super.call(e, {
          mask: r,
          training: i,
          initialState: a
        });
      });
    }
    static fromConfig(e, t) {
      return t.implmentation === 0 && (t.implementation = 1), new e(t);
    }
  }
  UQ.className = "LSTM";
  we(UQ);
  class lL extends JI {
    constructor(e) {
      super(e), this.cells = e.cells;
    }
    get stateSize() {
      const e = [];
      for (const t of this.cells.slice().reverse()) Array.isArray(t.stateSize) ? e.push(...t.stateSize) : e.push(t.stateSize);
      return e;
    }
    call(e, t) {
      return se(() => {
        e = e;
        let r = e.slice(1);
        const i = [];
        for (const o of this.cells.slice().reverse()) Array.isArray(o.stateSize) ? i.push(r.splice(0, o.stateSize.length)) : i.push(r.splice(0, 1));
        i.reverse();
        const a = [];
        let s;
        for (let o = 0; o < this.cells.length; ++o) {
          const l = this.cells[o];
          r = i[o], o === 0 ? s = [
            e[0]
          ].concat(r) : s = [
            s[0]
          ].concat(r), s = l.call(s, t), a.push(s.slice(1));
        }
        r = [];
        for (const o of a.slice().reverse()) r.push(...o);
        return [
          s[0]
        ].concat(r);
      });
    }
    build(e) {
      T$(e) && (e = e[0]), e = e;
      let t;
      this.cells.forEach((r, i) => {
        ad(`RNNCell_${i}`, () => {
          r.build(e), Array.isArray(r.stateSize) ? t = r.stateSize[0] : t = r.stateSize, e = [
            e[0],
            t
          ];
        });
      }), this.built = true;
    }
    getConfig() {
      const e = super.getConfig(), t = (a) => ({
        className: a.getClassName(),
        config: a.getConfig()
      }), i = {
        cells: this.cells.map(t)
      };
      return Object.assign(Object.assign({}, e), i);
    }
    static fromConfig(e, t, r = {}) {
      const i = [];
      for (const a of t.cells) i.push(zl(a, r));
      return new e({
        cells: i
      });
    }
    get trainableWeights() {
      if (!this.trainable) return [];
      const e = [];
      for (const t of this.cells) e.push(...t.trainableWeights);
      return e;
    }
    get nonTrainableWeights() {
      const e = [];
      for (const t of this.cells) e.push(...t.nonTrainableWeights);
      if (!this.trainable) {
        const t = [];
        for (const r of this.cells) t.push(...r.trainableWeights);
        return t.concat(e);
      }
      return e;
    }
    getWeights() {
      const e = [];
      for (const t of this.cells) e.push(...t.weights);
      return A$(e);
    }
    setWeights(e) {
      const t = [];
      for (const r of this.cells) {
        const i = r.weights.length, a = e.splice(i);
        for (let s = 0; s < r.weights.length; ++s) t.push([
          r.weights[s],
          a[s]
        ]);
      }
      eL(t);
    }
  }
  lL.className = "StackedRNNCells";
  we(lL);
  function dc(n) {
    const { ones: e, rate: t, training: r = false, count: i = 1, dropoutFunc: a } = n, s = () => a != null ? a(e(), t) : PZ(e(), t), o = () => Lb(s, e, r);
    return !i || i <= 1 ? qo(o().clone()) : Array(i).fill(void 0).map(o).map((u) => qo(u.clone()));
  }
  var vFe = function(n, e) {
    var t = {};
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
    return t;
  };
  class HQ extends Tc {
    constructor(e) {
      if (e.unroll) throw new zt("Unrolling is not possible with convolutional RNNs.");
      if (Array.isArray(e.cell)) throw new zt("It is not possible at the moment to stack convolutional cells.");
      super(e), this.inputSpec = [
        new Ar({
          ndim: 5
        })
      ];
    }
    call(e, t) {
      return se(() => {
        if (this.cell.dropoutMask != null && (jt(this.cell.dropoutMask), this.cell.dropoutMask = null), this.cell.recurrentDropoutMask != null && (jt(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), t && t.constants) throw new j("ConvRNN2D cell does not support constants");
        const r = t == null ? null : t.mask, i = t == null ? null : t.training, a = t == null ? null : t.initialState;
        return super.call(e, {
          mask: r,
          training: i,
          initialState: a
        });
      });
    }
    computeOutputShape(e) {
      let t = this.computeSingleOutputShape(e);
      return this.returnSequences || (t = [
        t[0],
        ...t.slice(2)
      ]), this.returnState && (t = [
        t,
        ...Array(2).fill([
          e[0],
          ...t.slice(-3)
        ])
      ]), t;
    }
    getInitialState(e) {
      return se(() => {
        const { stateSize: t } = this.cell, r = e.shape, i = this.computeSingleOutputShape(r), a = [
          i[0],
          ...i.slice(2)
        ], s = Cr(a);
        return Array.isArray(t) ? Array(t.length).fill(s) : [
          s
        ];
      });
    }
    resetStates(e, t = false) {
      se(() => {
        if (!this.stateful) throw new Eo("Cannot call resetStates() on an RNN Layer that is not stateful.");
        const r = this.inputSpec[0].shape, i = this.computeSingleOutputShape(r), a = [
          i[0],
          ...i.slice(2)
        ];
        if (r[0] == null) throw new j("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (this.getStates() == null) Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => Cr(a)) : this.states_ = [
          Cr(a)
        ];
        else if (e == null) jt(this.states_), this.keptStates != null && (jt(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map(() => Cr(a)) : this.states_[0] = Cr(a);
        else {
          if (Array.isArray(e) || (e = [
            e
          ]), e.length !== this.states_.length) throw new j(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
          t ? this.keptStates.push(this.states_.slice()) : jt(this.states_);
          for (let o = 0; o < this.states_.length; ++o) {
            const l = e[o], u = a;
            if (!Jt(l.shape, u)) throw new j(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);
            this.states_[o] = l;
          }
        }
        this.states_ = this.states_.map((o) => qo(o.clone()));
      });
    }
    computeSingleOutputShape(e) {
      const { dataFormat: t, filters: r, kernelSize: i, padding: a, strides: s, dilationRate: o } = this.cell, l = t === "channelsFirst", u = e[l ? 3 : 2], c = e[l ? 4 : 3], h = eo(u, i[0], a, s[0], o[0]), d = eo(c, i[1], a, s[1], o[1]);
      return [
        ...e.slice(0, 2),
        ...l ? [
          r,
          h,
          d
        ] : [
          h,
          d,
          r
        ]
      ];
    }
  }
  HQ.className = "ConvRNN2D";
  class uL extends e2 {
    constructor(e) {
      const { filters: t, kernelSize: r, strides: i, padding: a, dataFormat: s, dilationRate: o } = e;
      super(Object.assign(Object.assign({}, e), {
        units: t
      })), this.filters = t, Wr(this.filters, "filters"), this.kernelSize = Rg(r, 2, "kernelSize"), this.kernelSize.forEach((l) => Wr(l, "kernelSize")), this.strides = Rg(i || 1, 2, "strides"), this.strides.forEach((l) => Wr(l, "strides")), this.padding = a || "valid", Za(this.padding), this.dataFormat = s || "channelsLast", fr(this.dataFormat), this.dilationRate = Rg(o || 1, 2, "dilationRate"), this.dilationRate.forEach((l) => Wr(l, "dilationRate"));
    }
    build(e) {
      var t;
      e = dn(e);
      const r = this.dataFormat === "channelsFirst" ? 1 : e.length - 1;
      if (e[r] == null) throw new j(`The channel dimension of the input should be defined. Found ${e[r]}`);
      const i = e[r], a = 4, s = this.kernelSize.concat([
        i,
        this.filters * a
      ]);
      this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      const o = this.kernelSize.concat([
        this.filters,
        this.filters * a
      ]);
      if (this.recurrentKernel = this.addWeight("recurrent_kernel", o, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint), this.useBias) {
        let l;
        if (this.unitForgetBias) {
          const u = this.biasInitializer, c = this.filters;
          l = new (t = class extends Ds {
            apply(d, f) {
              const p = u.apply([
                c
              ]), g = Ic([
                c
              ]), m = u.apply([
                c * 2
              ]);
              return XP([
                p,
                g,
                m
              ]);
            }
          }, t.className = "CustomInit", t)();
        } else l = this.biasInitializer;
        this.bias = this.addWeight("bias", [
          this.filters * a
        ], null, l, this.biasRegularizer, true, this.biasConstraint);
      }
      this.built = true;
    }
    call(e, t) {
      return se(() => {
        if (e.length !== 3) throw new j(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
        const r = t.training || false, i = e[0], a = e[1], s = e[2], o = 4;
        0 < this.dropout && this.dropout < 1 && this.dropoutMask == null && (this.dropoutMask = dc({
          ones: () => Cs(i),
          rate: this.dropout,
          training: r,
          count: o,
          dropoutFunc: this.dropoutFunc
        }));
        const l = this.dropoutMask, u = (F, O, z) => !O || !O[z] ? F : Z(O[z], F);
        let c = u(i, l, 0), h = u(i, l, 1), d = u(i, l, 2), f = u(i, l, 3);
        0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null && (this.recurrentDropoutMask = dc({
          ones: () => Cs(a),
          rate: this.recurrentDropout,
          training: r,
          count: o,
          dropoutFunc: this.dropoutFunc
        }));
        const p = this.recurrentDropoutMask;
        let g = u(a, p, 0), m = u(a, p, 1), v = u(a, p, 2), y = u(a, p, 3);
        const x = 3, [b, w, _, S] = Ga(this.kernel.read(), o, x), [I, C, T, k] = this.useBias ? Ga(this.bias.read(), o) : [
          null,
          null,
          null,
          null
        ];
        c = this.inputConv(c, b, I, this.padding), h = this.inputConv(h, w, C, this.padding), d = this.inputConv(d, _, T, this.padding), f = this.inputConv(f, S, k, this.padding);
        const [D, R, N, E] = Ga(this.recurrentKernel.read(), o, x);
        g = this.recurrentConv(g, D), m = this.recurrentConv(m, R), v = this.recurrentConv(v, N), y = this.recurrentConv(y, E);
        const A = this.recurrentActivation.apply(Ce(c, g)), M = this.recurrentActivation.apply(Ce(h, m)), $ = Ce(Z(M, s), Z(A, this.activation.apply(Ce(d, v)))), L = Z(this.recurrentActivation.apply(Ce(f, y)), this.activation.apply($));
        return [
          L,
          L,
          $
        ];
      });
    }
    getConfig() {
      const e = super.getConfig(), { units: t } = e, r = vFe(e, [
        "units"
      ]), i = {
        filters: this.filters,
        kernelSize: this.kernelSize,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        strides: this.strides
      };
      return Object.assign(Object.assign({}, r), i);
    }
    inputConv(e, t, r, i) {
      const a = Sd(e, t, this.strides, i || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
      return r ? go(a, r, this.dataFormat) : a;
    }
    recurrentConv(e, t) {
      return Sd(e, t, 1, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
    }
  }
  uL.className = "ConvLSTM2DCell";
  we(uL);
  class XQ extends HQ {
    constructor(e) {
      const t = new uL(e);
      super(Object.assign(Object.assign({}, e), {
        cell: t
      }));
    }
    static fromConfig(e, t) {
      return new e(t);
    }
  }
  XQ.className = "ConvLSTM2D";
  we(XQ);
  class cL extends qt {
    constructor(e) {
      super(e), this.rate = Math.max(Math.min(e.rate, 1), 0), this.noiseShape = e.noiseShape, this.seed = e.seed, this.supportsMasking = true;
    }
    getNoiseShape(e) {
      if (this.noiseShape == null) return this.noiseShape;
      const t = e.shape, r = [];
      for (let i = 0; i < this.noiseShape.length; ++i) r.push(this.noiseShape[i] == null ? t[i] : this.noiseShape[i]);
      return r;
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        const r = St(e);
        if (0 < this.rate && this.rate < 1) {
          const i = t.training == null ? false : t.training, a = this.getNoiseShape(r);
          return Lb(() => PZ(r, this.rate, a, this.seed), () => r, i);
        }
        return e;
      });
    }
    getConfig() {
      const e = {
        rate: this.rate,
        noiseShape: this.noiseShape,
        seed: this.seed
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    dispose() {
      return super.dispose();
    }
  }
  cL.className = "Dropout";
  we(cL);
  class YQ extends cL {
    constructor(e) {
      super(e), this.inputSpec = [
        {
          ndim: 3
        }
      ];
    }
    getNoiseShape(e) {
      const t = e.shape;
      return [
        t[0],
        1,
        t[2]
      ];
    }
  }
  YQ.className = "SpatialDropout1D";
  we(YQ);
  class qQ extends qt {
    constructor(e) {
      if (super(e), this.activation = null, this.useBias = true, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.batchInputShape == null && e.inputShape == null && e.inputDim != null) {
        let t = null;
        e.batchSize != null && (t = e.batchSize), this.batchInputShape = [
          t,
          e.inputDim
        ];
      }
      this.units = e.units, Wr(this.units, "units"), this.activation = hc(e.activation), e.useBias != null && (this.useBias = e.useBias), this.kernelInitializer = Kn(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = Kn(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = Nr(e.kernelConstraint), this.biasConstraint = Nr(e.biasConstraint), this.kernelRegularizer = Zn(e.kernelRegularizer), this.biasRegularizer = Zn(e.biasRegularizer), this.activityRegularizer = Zn(e.activityRegularizer), this.supportsMasking = true, this.inputSpec = [
        {
          minNDim: 2
        }
      ];
    }
    build(e) {
      e = dn(e);
      const t = e[e.length - 1];
      this.kernel == null && (this.kernel = this.addWeight("kernel", [
        t,
        this.units
      ], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
        this.units
      ], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint))), this.inputSpec = [
        {
          minNDim: 2,
          axes: {
            [-1]: t
          }
        }
      ], this.built = true;
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = e.slice();
      return t[t.length - 1] = this.units, t;
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        const r = St(e), i = AZ(this.activation.getClassName());
        let a;
        return i != null ? a = Ko(r, this.kernel.read(), i, this.bias ? this.bias.read() : null) : (a = Ko(r, this.kernel.read()), this.bias != null && (a = go(a, this.bias.read())), this.activation != null && (a = this.activation.apply(a))), a;
      });
    }
    getConfig() {
      const e = {
        units: this.units,
        activation: cc(this.activation),
        useBias: this.useBias,
        kernelInitializer: tr(this.kernelInitializer),
        biasInitializer: tr(this.biasInitializer),
        kernelRegularizer: On(this.kernelRegularizer),
        biasRegularizer: On(this.biasRegularizer),
        activityRegularizer: On(this.activityRegularizer),
        kernelConstraint: $r(this.kernelConstraint),
        biasConstraint: $r(this.biasConstraint)
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  qQ.className = "Dense";
  we(qQ);
  class jQ extends qt {
    constructor(e) {
      e = e || {}, super(e), this.inputSpec = [
        {
          minNDim: 3
        }
      ], this.dataFormat = e.dataFormat;
    }
    computeOutputShape(e) {
      e = dn(e);
      for (const t of e.slice(1)) if (t == null) throw new j(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
      return [
        e[0],
        Qu(e, 1)
      ];
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        let r = St(e);
        if (this.dataFormat === "channelsFirst" && r.rank > 1) {
          const i = [
            0
          ];
          for (let a = 2; a < r.rank; ++a) i.push(a);
          i.push(1), r = ln(r, i);
        }
        return KLe(r);
      });
    }
    getConfig() {
      const e = {};
      this.dataFormat != null && (e.dataFormat = this.dataFormat);
      const t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  jQ.className = "Flatten";
  we(jQ);
  class KQ extends qt {
    constructor(e) {
      super(e), this.supportsMasking = true, this.activation = hc(e.activation);
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        const r = St(e);
        return this.activation.apply(r);
      });
    }
    getConfig() {
      const e = {
        activation: cc(this.activation)
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  KQ.className = "Activation";
  we(KQ);
  class ZQ extends qt {
    constructor(e) {
      super(e), this.n = e.n, this.inputSpec = [
        {
          ndim: 2
        }
      ];
    }
    computeOutputShape(e) {
      return [
        e[0],
        this.n,
        e[1]
      ];
    }
    call(e, t) {
      return se(() => (e = St(e), qLe(e, this.n)));
    }
    getConfig() {
      const e = {
        n: this.n
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  ZQ.className = "RepeatVector";
  we(ZQ);
  class QQ extends qt {
    constructor(e) {
      super(e), this.targetShape = e.targetShape;
      for (let t = 0; t < this.targetShape.length; ++t) this.isUnknown(this.targetShape[t]) && (this.targetShape[t] = null);
    }
    isUnknown(e) {
      return e < 0 || e == null;
    }
    fixUnknownDimension(e, t) {
      const r = "Total size of new array must be unchanged.", i = t.slice();
      let a = 1, s = null;
      for (let l = 0; l < i.length; ++l) {
        const u = i[l];
        if (this.isUnknown(u)) if (s === null) s = l;
        else throw new j("Can only specifiy one unknown dimension.");
        else a *= u;
      }
      const o = Qu(e);
      if (s !== null) {
        if (a === 0 || o % a !== 0) throw new j(r);
        i[s] = o / a;
      } else if (o !== a) throw new j(r);
      return i;
    }
    computeOutputShape(e) {
      let t = false;
      for (let r = 0; r < e.length; ++r) if (this.isUnknown(e[r])) {
        t = true;
        break;
      }
      return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        const r = St(e), i = r.shape, a = i.slice(0, 1).concat(this.fixUnknownDimension(i.slice(1), this.targetShape));
        return ee(r, a);
      });
    }
    getConfig() {
      const e = {
        targetShape: this.targetShape
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  QQ.className = "Reshape";
  we(QQ);
  class JQ extends qt {
    constructor(e) {
      if (super(e), e.dims == null) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
      if (!Array.isArray(e.dims)) throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);
      const t = oo(1, e.dims.length + 1);
      if (!Jt(e.dims.slice().sort(), t)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
      this.dims = e.dims, this.dimsIncludingBatch = [
        0
      ].concat(this.dims), this.inputSpec = [
        new Ar({
          ndim: this.dims.length + 1
        })
      ];
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = e.slice();
      return this.dims.forEach((r, i) => {
        t[i + 1] = e[r];
      }), t;
    }
    call(e, t) {
      return ln(St(e), this.dimsIncludingBatch);
    }
    getConfig() {
      const e = {
        dims: this.dims
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  JQ.className = "Permute";
  we(JQ);
  class eJ extends qt {
    constructor(e) {
      super(e ?? {}), this.supportsMasking = true, e != null ? this.maskValue = e.maskValue == null ? 0 : e.maskValue : this.maskValue = 0;
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = super.getConfig(), t = {
        maskValue: this.maskValue
      };
      return Object.assign(t, e), t;
    }
    computeMask(e, t) {
      const r = St(e);
      return x$(NS(r, this.maskValue), -1);
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        const r = St(e), s = x$(NS(r, this.maskValue), -1, true);
        return Z(r, Ve(s, r.dtype));
      });
    }
  }
  eJ.className = "Masking";
  we(eJ);
  class tJ extends qt {
    constructor(e) {
      if (super(e), this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", e.batchInputShape == null && e.inputShape == null) {
        let t = null;
        e.batchSize != null && (t = e.batchSize), e.inputLength == null ? this.batchInputShape = [
          t,
          null
        ] : this.batchInputShape = [
          t
        ].concat(In(e.inputLength));
      }
      this.inputDim = e.inputDim, Wr(this.inputDim, "inputDim"), this.outputDim = e.outputDim, Wr(this.outputDim, "outputDim"), this.embeddingsInitializer = Kn(e.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = Zn(e.embeddingsRegularizer), this.activityRegularizer = Zn(e.activityRegularizer), this.embeddingsConstraint = Nr(e.embeddingsConstraint), this.maskZero = e.maskZero, this.supportsMasking = e.maskZero, this.inputLength = e.inputLength;
    }
    build(e) {
      this.embeddings = this.addWeight("embeddings", [
        this.inputDim,
        this.outputDim
      ], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint), this.built = true;
    }
    warnOnIncompatibleInputShape(e) {
    }
    computeMask(e, t) {
      return se(() => this.maskZero ? (e = St(e), NS(e, un(e))) : null);
    }
    computeOutputShape(e) {
      if (e = dn(e), this.inputLength == null) return [
        ...e,
        this.outputDim
      ];
      const t = In(this.inputLength);
      if (t.length !== e.length - 1) throw new j(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
      {
        let r = 0;
        for (let i = 0; i < t.length; ++i) {
          const a = t[i], s = e[i + 1];
          if (a != null && s != null && a !== s) throw new j(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
          a == null && (t[r] = s), r++;
        }
      }
      return [
        e[0],
        ...t,
        this.outputDim
      ];
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        let r = St(e);
        r.dtype !== "int32" && (r = jo(r, "int32"));
        const i = MZ(this.embeddings.read(), ee(r, [
          r.size
        ]));
        return ee(i, dn(this.computeOutputShape(r.shape)));
      });
    }
    getConfig() {
      const e = {
        inputDim: this.inputDim,
        outputDim: this.outputDim,
        embeddingsInitializer: tr(this.embeddingsInitializer),
        embeddingsRegularizer: On(this.embeddingsRegularizer),
        activityRegularizer: On(this.activityRegularizer),
        embeddingsConstraint: $r(this.embeddingsConstraint),
        maskZero: this.maskZero,
        inputLength: this.inputLength
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  tJ.className = "Embedding";
  we(tJ);
  class cp extends qt {
    constructor(e) {
      super(e || {}), this.supportsMasking = true;
    }
    mergeFunction(e) {
      throw new zt();
    }
    computeElementwiseOpOutputShape(e, t) {
      if (e == null || t == null) return null;
      if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
      if (t.length === 0) return e;
      const r = e.slice(0, e.length - t.length);
      for (let i = 0; i < t.length; ++i) {
        const a = e[e.length - t.length + i], s = t[i];
        if (a == null || s == null || a < 0 || s < 0) r.push(null);
        else if (a === 1) r.push(s);
        else if (s === 1) r.push(a);
        else {
          if (a !== s) throw new j("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
          r.push(a);
        }
      }
      return r;
    }
    build(e) {
      if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [
        dn(e)
      ]), e = e, e.length < 2) throw new j(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);
      let t = [];
      for (const a of e) a != null && a[0] !== null && t.push(a[0]);
      if (t = Zu(t), t.length > 1) throw new j(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);
      let r = e[0] == null ? null : e[0].slice(1);
      for (let a = 1; a < e.length; ++a) {
        const s = e[a] == null ? null : e[a].slice(1);
        r = this.computeElementwiseOpOutputShape(r, s);
      }
      const i = e.map((a) => a.length);
      e.indexOf(null) === -1 && Zu(i).length === 1 ? this.reshapeRequired = false : this.reshapeRequired = true;
    }
    call(e, t) {
      return se(() => {
        if (e = e, this.reshapeRequired) {
          const r = [], i = e.map((a) => a.rank);
          if (i.indexOf(null) === -1) {
            const a = uc(i);
            for (let s of e) {
              const o = s.rank;
              for (let l = 0; l < a - o; ++l) s = Mb(s, 1);
              r.push(s);
            }
            return this.mergeFunction(r);
          } else {
            let a = false;
            for (const l of e) {
              const u = l.rank;
              if (u == null) {
                const c = l.shape, h = c[0], d = c.slice(1).concat([
                  h
                ]);
                let f = ee(l, [
                  h
                ].concat(Qu(c.slice(1))));
                f = ln(f, [
                  1,
                  0
                ]), f = ee(f, d), r.push(f), a = true;
              } else if (u > 1) {
                const c = oo(1, u).concat([
                  0
                ]);
                r.push(ln(l, c)), a = true;
              } else r.push(l);
            }
            let s = this.mergeFunction(r);
            const o = s.rank;
            if (a) {
              if (o == null) {
                const l = s.shape, u = l.length, c = l[u - 1], h = [
                  c
                ].concat(l.slice(0, l.length - 1));
                s = ee(ln(ee(s, [
                  -1,
                  c
                ]), [
                  1,
                  0
                ]), h);
              } else if (o > 1) {
                const l = [
                  o - 1
                ].concat(oo(0, o - 1));
                s = ln(s, l);
              }
            }
            return s;
          }
        } else return this.mergeFunction(e);
      });
    }
    computeOutputShape(e) {
      e = e;
      let t;
      e[0] == null ? t = null : t = e[0].slice(1);
      for (let i = 1; i < e.length; ++i) {
        const a = e[i] == null ? null : e[i].slice(1);
        t = this.computeElementwiseOpOutputShape(t, a);
      }
      let r = [];
      for (const i of e) i != null && i[0] !== null && r.push(i[0]);
      return r = Zu(r), r.length === 1 ? t = r.concat(t) : t = [
        null
      ].concat(t), t;
    }
    computeMask(e, t) {
      return se(() => {
        if (t == null) return null;
        if (!Array.isArray(t)) throw new j("`mask` should be an Array");
        if (!Array.isArray(e)) throw new j("`inputs` should be an Array");
        if (t.length !== e.length) throw new j(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);
        if (t.every((i) => i == null)) return null;
        t = t.map((i) => i == null ? i : Xi(i, 0));
        let r = t[0];
        for (let i = 1; i < t.length - 1; ++i) r = eu(r, t[i]);
        return r;
      });
    }
  }
  class nJ extends cp {
    constructor(e) {
      super(e);
    }
    mergeFunction(e) {
      return se(() => {
        let t = e[0].clone();
        for (let r = 1; r < e.length; ++r) t = Ce(t, e[r]);
        return t;
      });
    }
  }
  nJ.className = "Add";
  we(nJ);
  class rJ extends cp {
    constructor(e) {
      super(e);
    }
    mergeFunction(e) {
      return se(() => {
        let t = e[0].clone();
        for (let r = 1; r < e.length; ++r) t = Z(t, e[r]);
        return t;
      });
    }
  }
  rJ.className = "Multiply";
  we(rJ);
  class iJ extends cp {
    constructor(e) {
      super(e);
    }
    mergeFunction(e) {
      return se(() => {
        let t = e[0].clone();
        for (let r = 1; r < e.length; ++r) t = Ce(t, e[r]);
        return Z(1 / e.length, t);
      });
    }
  }
  iJ.className = "Average";
  we(iJ);
  class aJ extends cp {
    constructor(e) {
      super(e);
    }
    mergeFunction(e) {
      return se(() => {
        let t = e[0];
        for (let r = 1; r < e.length; ++r) t = Cc(t, e[r]);
        return t;
      });
    }
  }
  aJ.className = "Maximum";
  we(aJ);
  class sJ extends cp {
    constructor(e) {
      super(e);
    }
    mergeFunction(e) {
      return se(() => {
        let t = e[0];
        for (let r = 1; r < e.length; ++r) t = sx(t, e[r]);
        return t;
      });
    }
  }
  sJ.className = "Minimum";
  we(sJ);
  class oJ extends cp {
    constructor(e) {
      super(e), this.DEFAULT_AXIS = -1, e == null && (e = {}), this.axis = e.axis == null ? this.DEFAULT_AXIS : e.axis, this.supportsMasking = true, this.reshapeRequired = false;
    }
    build(e) {
      if (!(Array.isArray(e) && Array.isArray(e[0])) || e.length === 1) throw new j("A `Concatenate` layer should be called on a list of at least 2 inputs");
      e = e;
      let t = true;
      for (const i of e) if (i != null) {
        t = false;
        break;
      }
      if (t) return;
      const r = [];
      for (let i = 0; i < e.length; ++i) {
        const a = e[i].slice();
        a.splice(this.axis, 1);
        let s = false;
        for (const o of r) if (Jt(o, a)) {
          s = true;
          break;
        }
        s || r.push(a);
      }
      if (r.length > 1) throw new j("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
    }
    mergeFunction(e) {
      return se(() => XP(e, this.axis));
    }
    computeOutputShape(e) {
      if (!(Array.isArray(e) && Array.isArray(e[0]))) throw new j("A `Concatenate` layer should be called on a list of inputs.");
      const t = e, r = t[0].slice(), i = this.axis < 0 ? r.length + this.axis : this.axis;
      for (const a of t.slice(1)) {
        if (r[i] == null || a[i] == null) {
          r[i] = null;
          break;
        }
        r[i] += a[i];
      }
      return r;
    }
    computeMask(e, t) {
      if (t == null) return null;
      if (!Array.isArray(t)) throw new j("`mask` should be an array for Concatenate");
      if (!Array.isArray(e)) throw new j("`inputs` should be an array for Concatenate");
      if (t.length !== e.length) throw new j(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);
      return se(() => {
        let r = true;
        if (t.forEach((s) => {
          if (s != null) {
            r = false;
            return;
          }
        }), r) return null;
        const i = [];
        for (let s = 0; s < e.length; ++s) t[s] == null ? i.push(Ve(Cs(e[s]), "bool")) : t[s].rank < e[s].rank ? i.push(Xi(t[s], -1)) : i.push(t[s]);
        const a = Qi(i, this.axis);
        return w9(a, -1, false);
      });
    }
    getConfig() {
      const e = {
        axis: this.axis
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  oJ.className = "Concatenate";
  we(oJ);
  function _y(n, e) {
    for (; n < 0; ) n += e;
    return n;
  }
  function yFe(n, e, t) {
    if (n.shape.length > 3 || e.shape.length > 3) throw new zt("batchDot is not implemented for tensors of 4D or higher rank yet");
    if (B(n.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`), B(n.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`), typeof t == "number" && (t = [
      t,
      t
    ]), n.dtype === "complex64" || e.dtype === "complex64") throw new zt("batchDot is not implemented for complex64-type Tensors yet.");
    const r = n.shape.length, i = e.shape.length;
    t == null && (t = [
      r - 1,
      i - 2
    ]);
    const a = t;
    return se(() => {
      let s;
      if (r > i) {
        s = r - i;
        const l = [];
        for (let u = 0; u < s; ++u) l.push(1);
        e = ee(e, e.shape.concat(l));
      } else if (i > r) {
        s = i - r;
        const l = [];
        for (let u = 0; u < s; ++u) l.push(1);
        n = ee(n, n.shape.concat(l));
      } else s = 0;
      let o;
      if (n.shape.length === 2 && e.shape.length === 2) a[0] === a[1] ? o = ct(Z(n, e), a[0]) : o = ct(Z(ln(n, [
        1,
        0
      ]), e), a[1]);
      else {
        const l = a[0] !== n.shape.length - 1, u = a[1] === e.shape.length - 1;
        o = mn(n, e, l, u);
      }
      if (s > 0) {
        let l;
        r > i ? l = r + i - 3 : l = r - 1;
        const u = [];
        for (let c = l; c < l + s; ++c) u.push(c);
        o = bb(o, u);
      }
      return o.shape.length === 1 && (o = Xi(o, 1)), o;
    });
  }
  class lJ extends cp {
    constructor(e) {
      super(e), this.axes = e.axes, this.normalize = e.normalize == null ? false : e.normalize, this.supportsMasking = true, this.reshapeRequired = false;
    }
    build(e) {
      B(Array.isArray(e) && e.length === 2 && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      const t = e[0], r = e[1];
      if (t.length > 3 || r.length > 3) throw new zt("Dot layer does not support tensors of 4D or higher rank yet.");
      const i = this.interpretAxes(t, r);
      if (t[i[0]] !== r[i[1]]) throw new j(`Dimension incompatibility: ${t[i[0]]} !== ${r[i[1]]}`);
    }
    mergeFunction(e) {
      if (e.length !== 2) throw new j(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);
      let t = e[0], r = e[1], i;
      return Array.isArray(this.axes) ? i = this.axes.map((a, s) => _y(a, e[s].shape.length)) : i = [
        _y(this.axes, t.shape.length),
        _y(this.axes, r.shape.length)
      ], this.normalize && (t = BS(t, i[0]), r = BS(r, i[1])), yFe(t, r, i);
    }
    interpretAxes(e, t) {
      let r;
      return Array.isArray(this.axes) ? r = this.axes : r = [
        _y(this.axes, e.length),
        _y(this.axes, t.length)
      ], r;
    }
    computeOutputShape(e) {
      B(Array.isArray(e) && e.length === 2 && Array.isArray(e[0]) && Array.isArray(e[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      const t = e[0].slice(), r = e[1].slice();
      if (t.length > 3 || r.length > 3) throw new zt("Dot layer does not support tensors of 4D or higher rank yet.");
      const i = this.interpretAxes(t, r);
      t.splice(i[0], 1), r.splice(i[1], 1), r.splice(0, 1);
      const a = t.concat(r);
      return a.length === 1 && a.push(1), a;
    }
    computeMask(e, t) {
      return null;
    }
    getConfig() {
      const e = {
        axes: this.axes,
        normalize: this.normalize
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  lJ.className = "Dot";
  we(lJ);
  class uJ extends qt {
    constructor(e) {
      super(e), this.supportsMasking = true, this.stddev = e.stddev;
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = super.getConfig(), t = {
        stddev: this.stddev
      };
      return Object.assign(t, e), t;
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        const r = St(e);
        return Lb(() => Ce(YI(r.shape, 0, this.stddev), r), () => r, t.training || false);
      });
    }
  }
  uJ.className = "GaussianNoise";
  we(uJ);
  class cJ extends qt {
    constructor(e) {
      super(e), this.supportsMasking = true, this.rate = e.rate;
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = super.getConfig(), t = {
        rate: this.rate
      };
      return Object.assign(t, e), t;
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t);
        const r = St(e);
        return this.rate > 0 && this.rate < 1 ? Lb(() => {
          const a = Math.sqrt(this.rate / (1 - this.rate));
          return Z(r, YI(r.shape, 1, a));
        }, () => r, t.training || false) : r;
      });
    }
  }
  cJ.className = "GaussianDropout";
  we(cJ);
  class hJ extends qt {
    constructor(e) {
      super(e), this.supportsMasking = true, this.rate = e.rate, this.noiseShape = e.noiseShape;
    }
    _getNoiseShape(e) {
      return this.noiseShape || St(e).shape;
    }
    computeOutputShape(e) {
      return e;
    }
    getConfig() {
      const e = super.getConfig(), t = {
        rate: this.rate
      };
      return Object.assign(t, e), t;
    }
    call(e, t) {
      return se(() => {
        if (this.rate < 1 && this.rate > 0) {
          const r = this._getNoiseShape(e);
          return Lb(() => {
            const a = St(e), o = -1.6732632423543772 * 1.0507009873554805;
            let l = op(xb(r), this.rate);
            l = jo(l, "float32");
            const u = ((1 - this.rate) * (1 + this.rate * o ** 2)) ** -0.5, c = -u * o * this.rate, h = Ce(Z(a, l), Z(Ce(l, -1), o));
            return Ce(Z(h, u), c);
          }, () => St(e), t.training || false);
        }
        return e;
      });
    }
  }
  hJ.className = "AlphaDropout";
  we(hJ);
  function dx(n, e, t, r, i, a = 1e-3) {
    let s;
    if (n.rank === 2) s = KDe(n, e, t, r, i, a);
    else if (n.rank === 3) s = QDe(n, e, t, r, i, a);
    else if (n.rank === 4) s = eRe(n, e, t, r, i, a);
    else throw new zt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);
    return s;
  }
  function xFe(n, e, t, r, i = 1e-3) {
    return se(() => {
      const a = dP(n, r), s = a.mean, o = a.variance;
      return [
        dx(n, s, o, t, e, i),
        s,
        o
      ];
    });
  }
  function bFe(n, e, t, r, i = 1e-3) {
    return se(() => {
      const a = dP(n, r), s = a.mean, o = a.variance, l = [];
      for (const p of oo(0, n.rank)) r.indexOf(p) !== -1 ? l.push(1) : l.push(n.shape[p]);
      const u = ee(s, l), c = ee(o, l), h = e == null ? null : ee(e, l), d = t == null ? null : ee(t, l);
      return [
        dx(n, u, c, d, h, i),
        s,
        o
      ];
    });
  }
  function wFe(n, e, t, r, i = 1e-3) {
    return Jt(r.slice().sort(), oo(0, n.rank - 1)) ? xFe(n, e, t, r, i) : bFe(n, e, t, r, i);
  }
  class dJ extends qt {
    constructor(e) {
      e == null && (e = {}), super(e), this.supportsMasking = true, this.axis = e.axis == null ? -1 : e.axis, this.momentum = e.momentum == null ? 0.99 : e.momentum, this.epsilon = e.epsilon == null ? 1e-3 : e.epsilon, this.center = e.center == null ? true : e.center, this.scale = e.scale == null ? true : e.scale, this.betaInitializer = Kn(e.betaInitializer || "zeros"), this.gammaInitializer = Kn(e.gammaInitializer || "ones"), this.movingMeanInitializer = Kn(e.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = Kn(e.movingVarianceInitializer || "ones"), this.betaConstraint = Nr(e.betaConstraint), this.gammaConstraint = Nr(e.gammaConstraint), this.betaRegularizer = Zn(e.betaRegularizer), this.gammaRegularizer = Zn(e.gammaRegularizer);
    }
    build(e) {
      e = dn(e);
      const t = this.axis >= 0 ? this.axis : this.axis + e.length, r = e[t];
      if (r == null) throw new j(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);
      this.inputSpec = [
        new Ar({
          ndim: e.length,
          axes: {
            [t]: r
          }
        })
      ];
      const i = [
        r
      ];
      this.scale && (this.gamma = this.addWeight("gamma", i, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", i, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", i, null, this.movingMeanInitializer, null, false), this.movingVariance = this.addWeight("moving_variance", i, null, this.movingVarianceInitializer, null, false), this.built = true;
    }
    call(e, t) {
      return se(() => {
        const r = t.training == null ? false : t.training, i = St(e), a = i.shape, s = a.length, o = oo(0, s), l = this.axis >= 0 ? this.axis : this.axis + s;
        o.splice(l, 1);
        const u = Td(1, s);
        u[l] = a[l];
        const c = o.slice();
        c.sort();
        const h = !Jt(c, oo(0, s).slice(0, s - 1)), d = () => {
          if (h) {
            const y = ee(this.movingMean.read(), u), x = ee(this.movingVariance.read(), u), b = this.center ? ee(this.beta.read(), u) : null, w = this.scale ? ee(this.gamma.read(), u) : null;
            return dx(i, y, x, b, w, this.epsilon);
          } else return dx(i, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
        };
        if (!r) return d();
        const [f, p, g] = wFe(i, this.gamma.read(), this.beta.read(), o, this.epsilon), m = (y, x, b) => {
          se(() => {
            const w = 1 - b, _ = y.read(), S = Z(wt(_, x), w);
            y.write(wt(_, S));
          });
        };
        return (() => {
          m(this.movingMean, p, this.momentum), m(this.movingVariance, g, this.momentum);
        })(), f;
      });
    }
    getConfig() {
      const e = {
        axis: this.axis,
        momentum: this.momentum,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: tr(this.betaInitializer),
        gammaInitializer: tr(this.gammaInitializer),
        movingMeanInitializer: tr(this.movingMeanInitializer),
        movingVarianceInitializer: tr(this.movingVarianceInitializer),
        betaRegularizer: On(this.betaRegularizer),
        gammaRegularizer: On(this.gammaRegularizer),
        betaConstraint: $r(this.betaConstraint),
        gammaConstraint: $r(this.gammaConstraint)
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  dJ.className = "BatchNormalization";
  we(dJ);
  class fJ extends qt {
    constructor(e) {
      if (e == null && (e = {}), super(e), this.axis = e.axis == null ? -1 : e.axis, typeof this.axis == "number") {
        if (!Number.isInteger(this.axis)) throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
      } else if (Array.isArray(this.axis)) {
        for (const t of this.axis) if (!Number.isInteger(t)) throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
      } else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
      this.epsilon = e.epsilon == null ? 1e-3 : e.epsilon, this.center = e.center == null ? true : e.center, this.scale = e.scale == null ? true : e.scale, this.betaInitializer = Kn(e.betaInitializer || "zeros"), this.gammaInitializer = Kn(e.gammaInitializer || "ones"), this.betaRegularizer = Zn(e.betaRegularizer), this.gammaRegularizer = Zn(e.gammaRegularizer), this.supportsMasking = true;
    }
    build(e) {
      e = dn(e);
      const t = e.length;
      typeof this.axis == "number" && (this.axis = [
        this.axis
      ]);
      for (let a = 0; a < this.axis.length; ++a) this.axis[a] < 0 && (this.axis[a] += t);
      for (const a of this.axis) if (a < 0 || a >= t) throw new Error(`Invalid axis: ${a}`);
      if (this.axis.length !== Zu(this.axis).length) throw new Error(`Found duplicate axes in: ${this.axis}`);
      const r = this.axis.map((a) => e[a]), i = true;
      this.scale ? this.gamma = this.addWeight("gamma", r, "float32", this.gammaInitializer, this.gammaRegularizer, i) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", r, "float32", this.betaInitializer, this.betaRegularizer, i) : this.beta = null, this.built = true;
    }
    call(e, t) {
      const r = St(e), i = r.shape, a = i.length;
      return se(() => {
        let { mean: o, variance: l } = dP(r, this.axis, true);
        const u = Td(1, a);
        for (const g of this.axis) u[g] = i[g];
        const c = (g) => g != null && g.shape.length !== a ? ee(g, u) : g;
        let h = this.scale ? c(this.gamma.read()) : null, d = this.center ? c(this.beta.read()) : null;
        const f = [], p = [];
        for (let g = 0; g < a; ++g) this.axis.indexOf(g) !== -1 ? (f.push(i[g]), p.push(1)) : (f.push(1), p.push(i[g]));
        return o = Ys(o, f), l = Ys(l, f), h != null && (h = Ys(h, p)), d != null && (d = Ys(d, p)), dx(r, o, l, d, h, this.epsilon);
      });
    }
    getConfig() {
      const e = {
        axis: this.axis,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: tr(this.betaInitializer),
        gammaInitializer: tr(this.gammaInitializer),
        betaRegularizer: On(this.betaRegularizer),
        gammaRegularizer: On(this.gammaRegularizer)
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  fJ.className = "LayerNormalization";
  we(fJ);
  function _Fe(n, e, t) {
    return se(() => {
      if (n.rank !== 4) throw new j(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);
      if (e == null && (e = [
        [
          1,
          1
        ],
        [
          1,
          1
        ]
      ]), e.length !== 2 || e[0].length !== 2 || e[1].length !== 2) throw new j("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
      if (t == null && (t = lo()), t !== "channelsLast" && t !== "channelsFirst") throw new j(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
      let r;
      return t === "channelsFirst" ? r = [
        [
          0,
          0
        ],
        [
          0,
          0
        ],
        e[0],
        e[1]
      ] : r = [
        [
          0,
          0
        ],
        e[0],
        e[1],
        [
          0,
          0
        ]
      ], fP(n, r);
    });
  }
  class pJ extends qt {
    constructor(e) {
      if (e == null && (e = {}), super(e), this.dataFormat = e.dataFormat == null ? lo() : e.dataFormat, e.padding == null) this.padding = [
        [
          1,
          1
        ],
        [
          1,
          1
        ]
      ];
      else if (typeof e.padding == "number") this.padding = [
        [
          e.padding,
          e.padding
        ],
        [
          e.padding,
          e.padding
        ]
      ];
      else {
        if (e.padding = e.padding, e.padding.length !== 2) throw new j(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);
        let t, r;
        if (typeof e.padding[0] == "number") t = [
          e.padding[0],
          e.padding[0]
        ], r = [
          e.padding[1],
          e.padding[1]
        ];
        else {
          if (e.padding = e.padding, e.padding[0].length !== 2) throw new j(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);
          if (t = e.padding[0], e.padding[1].length !== 2) throw new j(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);
          r = e.padding[1];
        }
        this.padding = [
          t,
          r
        ];
      }
      this.inputSpec = [
        new Ar({
          ndim: 4
        })
      ];
    }
    computeOutputShape(e) {
      e = dn(e);
      let t, r;
      return this.dataFormat === "channelsFirst" ? (e[2] != null && e[2] >= 0 ? t = e[2] + this.padding[0][0] + this.padding[0][1] : t = null, e[3] != null && e[3] >= 0 ? r = e[3] + this.padding[1][0] + this.padding[1][1] : r = null, [
        e[0],
        e[1],
        t,
        r
      ]) : (e[1] != null && e[1] >= 0 ? t = e[1] + this.padding[0][0] + this.padding[0][1] : t = null, e[2] != null && e[2] >= 0 ? r = e[2] + this.padding[1][0] + this.padding[1][1] : r = null, [
        e[0],
        t,
        r,
        e[3]
      ]);
    }
    call(e, t) {
      return se(() => _Fe(St(e), this.padding, this.dataFormat));
    }
    getConfig() {
      const e = {
        padding: this.padding,
        dataFormat: this.dataFormat
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  pJ.className = "ZeroPadding2D";
  we(pJ);
  function t2(n, e, t, r, i, a) {
    return se(() => {
      fr(i), RZ(a), Za(r), t == null && (t = [
        1,
        1
      ]), r == null && (r = "valid"), i == null && (i = lo()), a == null && (a = "max"), n = aL(n, i);
      let s;
      const o = r === "same" ? "same" : "valid";
      return a === "max" ? s = hP(n, e, t, o) : s = tP(n, e, t, o), i === "channelsFirst" && (s = ln(s, [
        0,
        3,
        1,
        2
      ])), s;
    });
  }
  function gJ(n, e, t, r, i, a) {
    return se(() => {
      fr(i), RZ(a), Za(r), t == null && (t = [
        1,
        1,
        1
      ]), r == null && (r = "valid"), i == null && (i = lo()), a == null && (a = "max"), n = NQ(n, i);
      let s;
      const o = r === "same" ? "same" : "valid";
      return a === "max" ? s = O$e(n, e, t, o) : s = zDe(n, e, t, o), i === "channelsFirst" && (s = ln(s, [
        0,
        4,
        1,
        2,
        3
      ])), s;
    });
  }
  class mJ extends qt {
    constructor(e) {
      if (e.poolSize == null && (e.poolSize = 2), super(e), typeof e.poolSize == "number") this.poolSize = [
        e.poolSize
      ];
      else if (Array.isArray(e.poolSize) && e.poolSize.length === 1 && typeof e.poolSize[0] == "number") this.poolSize = e.poolSize;
      else throw new j(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);
      if (Wr(this.poolSize, "poolSize"), e.strides == null) this.strides = this.poolSize;
      else if (typeof e.strides == "number") this.strides = [
        e.strides
      ];
      else if (Array.isArray(e.strides) && e.strides.length === 1 && typeof e.strides[0] == "number") this.strides = e.strides;
      else throw new j(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);
      Wr(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, Za(this.padding), this.inputSpec = [
        new Ar({
          ndim: 3
        })
      ];
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = eo(e[1], this.poolSize[0], this.padding, this.strides[0]);
      return [
        e[0],
        t,
        e[2]
      ];
    }
    call(e, t) {
      return se(() => {
        this.invokeCallHook(e, t), e = Mb(St(e), 2);
        const r = this.poolingFunction(St(e), [
          this.poolSize[0],
          1
        ], [
          this.strides[0],
          1
        ], this.padding, "channelsLast");
        return bb(r, [
          2
        ]);
      });
    }
    getConfig() {
      const e = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  class vJ extends mJ {
    constructor(e) {
      super(e);
    }
    poolingFunction(e, t, r, i, a) {
      return fr(a), Za(i), t2(e, t, r, i, a, "max");
    }
  }
  vJ.className = "MaxPooling1D";
  we(vJ);
  class yJ extends mJ {
    constructor(e) {
      super(e);
    }
    poolingFunction(e, t, r, i, a) {
      return fr(a), Za(i), t2(e, t, r, i, a, "avg");
    }
  }
  yJ.className = "AveragePooling1D";
  we(yJ);
  class xJ extends qt {
    constructor(e) {
      if (e.poolSize == null && (e.poolSize = [
        2,
        2
      ]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [
        e.poolSize,
        e.poolSize
      ], e.strides == null) this.strides = this.poolSize;
      else if (Array.isArray(e.strides)) {
        if (e.strides.length !== 2) throw new j(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);
        this.strides = e.strides;
      } else this.strides = [
        e.strides,
        e.strides
      ];
      Wr(this.poolSize, "poolSize"), Wr(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, fr(this.dataFormat), Za(this.padding), this.inputSpec = [
        new Ar({
          ndim: 4
        })
      ];
    }
    computeOutputShape(e) {
      e = dn(e);
      let t = this.dataFormat === "channelsFirst" ? e[2] : e[1], r = this.dataFormat === "channelsFirst" ? e[3] : e[2];
      return t = eo(t, this.poolSize[0], this.padding, this.strides[0]), r = eo(r, this.poolSize[1], this.padding, this.strides[1]), this.dataFormat === "channelsFirst" ? [
        e[0],
        e[1],
        t,
        r
      ] : [
        e[0],
        t,
        r,
        e[3]
      ];
    }
    call(e, t) {
      return se(() => (this.invokeCallHook(e, t), this.poolingFunction(St(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
    }
    getConfig() {
      const e = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  class bJ extends xJ {
    constructor(e) {
      super(e);
    }
    poolingFunction(e, t, r, i, a) {
      return fr(a), Za(i), t2(e, t, r, i, a, "max");
    }
  }
  bJ.className = "MaxPooling2D";
  we(bJ);
  class wJ extends xJ {
    constructor(e) {
      super(e);
    }
    poolingFunction(e, t, r, i, a) {
      return fr(a), Za(i), t2(e, t, r, i, a, "avg");
    }
  }
  wJ.className = "AveragePooling2D";
  we(wJ);
  class _J extends qt {
    constructor(e) {
      if (e.poolSize == null && (e.poolSize = [
        2,
        2,
        2
      ]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [
        e.poolSize,
        e.poolSize,
        e.poolSize
      ], e.strides == null) this.strides = this.poolSize;
      else if (Array.isArray(e.strides)) {
        if (e.strides.length !== 3) throw new j(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);
        this.strides = e.strides;
      } else this.strides = [
        e.strides,
        e.strides,
        e.strides
      ];
      Wr(this.poolSize, "poolSize"), Wr(this.strides, "strides"), this.padding = e.padding == null ? "valid" : e.padding, this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, fr(this.dataFormat), Za(this.padding), this.inputSpec = [
        new Ar({
          ndim: 5
        })
      ];
    }
    computeOutputShape(e) {
      e = dn(e);
      let t = this.dataFormat === "channelsFirst" ? e[2] : e[1], r = this.dataFormat === "channelsFirst" ? e[3] : e[2], i = this.dataFormat === "channelsFirst" ? e[4] : e[3];
      return t = eo(t, this.poolSize[0], this.padding, this.strides[0]), r = eo(r, this.poolSize[1], this.padding, this.strides[1]), i = eo(i, this.poolSize[2], this.padding, this.strides[2]), this.dataFormat === "channelsFirst" ? [
        e[0],
        e[1],
        t,
        r,
        i
      ] : [
        e[0],
        t,
        r,
        i,
        e[4]
      ];
    }
    call(e, t) {
      return se(() => (this.invokeCallHook(e, t), this.poolingFunction(St(e), this.poolSize, this.strides, this.padding, this.dataFormat)));
    }
    getConfig() {
      const e = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  class SJ extends _J {
    constructor(e) {
      super(e);
    }
    poolingFunction(e, t, r, i, a) {
      return fr(a), Za(i), gJ(e, t, r, i, a, "max");
    }
  }
  SJ.className = "MaxPooling3D";
  we(SJ);
  class CJ extends _J {
    constructor(e) {
      super(e);
    }
    poolingFunction(e, t, r, i, a) {
      return fr(a), Za(i), gJ(e, t, r, i, a, "avg");
    }
  }
  CJ.className = "AveragePooling3D";
  we(CJ);
  class IJ extends qt {
    constructor(e) {
      super(e), this.inputSpec = [
        new Ar({
          ndim: 3
        })
      ];
    }
    computeOutputShape(e) {
      return [
        e[0],
        e[2]
      ];
    }
    call(e, t) {
      throw new zt();
    }
  }
  class kJ extends IJ {
    constructor(e) {
      super(e || {});
    }
    call(e, t) {
      return se(() => {
        const r = St(e);
        return vr(r, 1);
      });
    }
  }
  kJ.className = "GlobalAveragePooling1D";
  we(kJ);
  class TJ extends IJ {
    constructor(e) {
      super(e || {});
    }
    call(e, t) {
      return se(() => {
        const r = St(e);
        return Js(r, 1);
      });
    }
  }
  TJ.className = "GlobalMaxPooling1D";
  we(TJ);
  class AJ extends qt {
    constructor(e) {
      super(e), this.dataFormat = e.dataFormat == null ? "channelsLast" : e.dataFormat, fr(this.dataFormat), this.inputSpec = [
        new Ar({
          ndim: 4
        })
      ];
    }
    computeOutputShape(e) {
      return e = e, this.dataFormat === "channelsLast" ? [
        e[0],
        e[3]
      ] : [
        e[0],
        e[1]
      ];
    }
    call(e, t) {
      throw new zt();
    }
    getConfig() {
      const e = {
        dataFormat: this.dataFormat
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  class DJ extends AJ {
    call(e, t) {
      return se(() => {
        const r = St(e);
        return this.dataFormat === "channelsLast" ? vr(r, [
          1,
          2
        ]) : vr(r, [
          2,
          3
        ]);
      });
    }
  }
  DJ.className = "GlobalAveragePooling2D";
  we(DJ);
  class RJ extends AJ {
    call(e, t) {
      return se(() => {
        const r = St(e);
        return this.dataFormat === "channelsLast" ? Js(r, [
          1,
          2
        ]) : Js(r, [
          2,
          3
        ]);
      });
    }
  }
  RJ.className = "GlobalMaxPooling2D";
  we(RJ);
  class $J extends qt {
    constructor(e) {
      super(e), this.layer = e.layer;
    }
    build(e) {
      this.built = true;
    }
    get trainable() {
      return this.layer != null ? this.layer.trainable : false;
    }
    set trainable(e) {
      this.layer != null && (this.layer.trainable = e);
    }
    get trainableWeights() {
      return this.layer.trainableWeights;
    }
    get nonTrainableWeights() {
      return this.layer.nonTrainableWeights;
    }
    get updates() {
      return this.layer._updates;
    }
    get losses() {
      return this.layer.losses;
    }
    getWeights() {
      return this.layer.getWeights();
    }
    setWeights(e) {
      this.layer.setWeights(e);
    }
    getConfig() {
      const e = {
        layer: {
          className: this.layer.getClassName(),
          config: this.layer.getConfig()
        }
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    setFastWeightInitDuringBuild(e) {
      super.setFastWeightInitDuringBuild(e), this.layer != null && this.layer.setFastWeightInitDuringBuild(e);
    }
    static fromConfig(e, t, r = {}) {
      const i = t.layer, a = zl(i, r);
      delete t.layer;
      const s = {
        layer: a
      };
      return Object.assign(s, t), new e(s);
    }
  }
  class NJ extends $J {
    constructor(e) {
      super(e), this.supportsMasking = true;
    }
    build(e) {
      if (e = dn(e), e.length < 3) throw new j(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);
      this.inputSpec = [
        {
          shape: e
        }
      ];
      const t = [
        e[0]
      ].concat(e.slice(2));
      this.layer.built || (this.layer.build(t), this.layer.built = true), super.build(e);
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = [
        e[0]
      ].concat(e.slice(2)), r = this.layer.computeOutputShape(t), i = e[1];
      return [
        r[0],
        i
      ].concat(r.slice(1));
    }
    call(e, t) {
      return se(() => (e = St(e), VQ((s, o) => [
        St(this.layer.call(s, t)),
        []
      ], e, [], false, null, null, false, true)[1]));
    }
  }
  NJ.className = "TimeDistributed";
  we(NJ);
  function SFe(n) {
    up(GLe, "BidirectionalMergeMode", n);
  }
  const CFe = "concat";
  class EJ extends $J {
    constructor(e) {
      super(e);
      const t = e.layer.getConfig(), r = {};
      r.className = e.layer.getClassName(), r.config = t, this.forwardLayer = zl(r), t.goBackwards = t.goBackwards !== true;
      const i = {};
      if (i.className = e.layer.getClassName(), i.config = t, this.backwardLayer = zl(i), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = e.mergeMode === void 0 ? CFe : e.mergeMode, SFe(this.mergeMode), e.weights) throw new zt("weights support is not implemented for Bidirectional layer yet.");
      this._stateful = e.layer.stateful, this.returnSequences = e.layer.returnSequences, this.returnState = e.layer.returnState, this.supportsMasking = true, this._trainable = true, this.inputSpec = e.layer.inputSpec, this.numConstants = null;
    }
    get trainable() {
      return this._trainable;
    }
    set trainable(e) {
      this._trainable = e, this.forwardLayer != null && (this.forwardLayer.trainable = e), this.backwardLayer != null && (this.backwardLayer.trainable = e);
    }
    getWeights() {
      return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    }
    setWeights(e) {
      const t = e.length, r = Math.floor(t / 2);
      this.forwardLayer.setWeights(e.slice(0, r)), this.backwardLayer.setWeights(e.slice(r));
    }
    computeOutputShape(e) {
      let t = this.forwardLayer.computeOutputShape(e);
      Array.isArray(t) && Array.isArray(t[0]) || (t = [
        t
      ]), t = t;
      let r, i, a;
      return this.returnState && (a = t.slice(1)), r = t[0], r = r, this.mergeMode === "concat" ? (r[r.length - 1] *= 2, i = [
        r
      ]) : this.mergeMode == null ? i = [
        r,
        r.slice()
      ] : i = [
        r
      ], this.returnState ? this.mergeMode == null ? i.concat(a).concat(a.slice()) : [
        r
      ].concat(a).concat(a.slice()) : Yi(i);
    }
    apply(e, t) {
      let r = t == null ? null : t.initialState, i = t == null ? null : t.constants;
      t == null && (t = {});
      const a = zQ(e, r, i, this.numConstants);
      if (e = a.inputs, r = a.initialState, i = a.constants, Array.isArray(e) && (r = e.slice(1), e = e[0]), (r == null || r.length === 0) && i == null) return super.apply(e, t);
      const s = [], o = [];
      if (r != null) {
        const u = r.length;
        if (u % 2 > 0) throw new j("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
        t.initialState = r, s.push(...r);
        const c = r.map((h) => new Ar({
          shape: h.shape
        }));
        this.forwardLayer.stateSpec = c.slice(0, u / 2), this.backwardLayer.stateSpec = c.slice(u / 2), o.push(...c);
      }
      if (i != null) throw new zt("Support for constants in Bidirectional layers is not implemented yet.");
      const l = s[0] instanceof sl;
      for (const u of s) if (u instanceof sl !== l) throw new j("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
      if (l) {
        const u = [
          e
        ].concat(s), c = this.inputSpec.concat(o), h = this.inputSpec;
        this.inputSpec = c;
        const d = super.apply(u, t);
        return this.inputSpec = h, d;
      } else return super.apply(e, t);
    }
    call(e, t) {
      return se(() => {
        const r = t.initialState;
        let i, a;
        if (r == null) i = this.forwardLayer.call(e, t), a = this.backwardLayer.call(e, t);
        else {
          const l = r.slice(0, r.length / 2), u = r.slice(r.length / 2);
          i = this.forwardLayer.call(e, Object.assign(t, {
            initialState: l
          })), a = this.backwardLayer.call(e, Object.assign(t, {
            initialState: u
          }));
        }
        let s;
        this.returnState && (Array.isArray(i) && (s = i.slice(1).concat(a.slice(1))), i = i[0], a = a[0]), this.returnSequences && (a = Id(a, 1));
        let o;
        return this.mergeMode === "concat" ? o = XP([
          i,
          a
        ]) : this.mergeMode === "sum" ? o = Ce(i, a) : this.mergeMode === "ave" ? o = Z(0.5, Ce(i, a)) : this.mergeMode === "mul" ? o = Z(i, a) : this.mergeMode == null && (o = [
          i,
          a
        ]), this.returnState ? this.mergeMode == null ? o.concat(s) : [
          o
        ].concat(s) : o;
      });
    }
    resetStates(e) {
      this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
    }
    build(e) {
      ad(this.forwardLayer.name, () => {
        this.forwardLayer.build(e);
      }), ad(this.backwardLayer.name, () => {
        this.backwardLayer.build(e);
      }), this.built = true;
    }
    computeMask(e, t) {
      Array.isArray(t) && (t = t[0]);
      let r;
      if (this.returnSequences ? this.mergeMode == null ? r = [
        t,
        t
      ] : r = t : this.mergeMode == null ? r = [
        null,
        null
      ] : r = null, this.returnState) {
        const a = this.forwardLayer.states.map((s) => null);
        return Array.isArray(r) ? r.concat(a).concat(a) : [
          r
        ].concat(a).concat(a);
      } else return r;
    }
    get trainableWeights() {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    }
    get nonTrainableWeights() {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    }
    setFastWeightInitDuringBuild(e) {
      super.setFastWeightInitDuringBuild(e), this.forwardLayer != null && this.forwardLayer.setFastWeightInitDuringBuild(e), this.backwardLayer != null && this.backwardLayer.setFastWeightInitDuringBuild(e);
    }
    getConfig() {
      const e = {
        mergeMode: this.mergeMode
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    static fromConfig(e, t) {
      const r = zl(t.layer);
      if (delete t.layer, t.numConstants != null) throw new zt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
      const i = t;
      return i.layer = r, new e(i);
    }
  }
  EJ.className = "Bidirectional";
  we(EJ);
  class MJ extends qt {
    constructor(e) {
      super(e), this.scale = e.scale, e.offset ? this.offset = e.offset : this.offset = 0;
    }
    getConfig() {
      const e = {
        scale: this.scale,
        offset: this.offset
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    call(e, t) {
      return se(() => (e = St(e), e.dtype !== "float32" && (e = jo(e, "float32")), Ce(Z(e, this.scale), this.offset)));
    }
  }
  MJ.className = "Rescaling";
  we(MJ);
  const { resizeBilinear: IFe, cropAndResize: kFe } = Dl;
  class PJ extends qt {
    constructor(e) {
      super(e), this.height = e.height, this.width = e.width;
    }
    centerCrop(e, t, r, i, a, s, o, l) {
      return se(() => {
        let u, c = false;
        const h = t / s, d = r / o, f = (i + t) / s, p = (a + r) / o, g = [
          h,
          d,
          f,
          p
        ], m = [];
        e.rank === 3 ? (c = true, u = tu([
          e
        ])) : u = e;
        for (let w = 0; w < u.shape[0]; w++) m.push(g);
        const v = QM(m, [
          m.length,
          4
        ]), y = ox(0, m.length, 1, "int32"), b = kFe(u, v, y, [
          i,
          a
        ], "nearest");
        return jo(c ? St(kd(b)) : b, l);
      });
    }
    upsize(e, t, r, i) {
      return se(() => {
        const a = IFe(e, [
          t,
          r
        ]);
        return jo(a, i);
      });
    }
    call(e, t) {
      return se(() => {
        const r = St(e), i = r.dtype, a = r.shape, s = a[a.length - 3], o = a[a.length - 2];
        let l = 0;
        s !== this.height && (l = Math.floor((s - this.height) / 2));
        let u = 0;
        return o !== this.width && (u = Math.floor((o - this.width) / 2), u === 0 && (u = 1)), l >= 0 && u >= 0 ? this.centerCrop(r, l, u, this.height, this.width, s, o, i) : this.upsize(e, this.height, this.width, i);
      });
    }
    getConfig() {
      const e = {
        height: this.height,
        width: this.width
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = e.length - 3, r = e.length - 2;
      return e[t] = this.height, e[r] = this.width, e;
    }
  }
  PJ.className = "CenterCrop";
  we(PJ);
  function TFe(n, e, t, r) {
    let i = St(n);
    if (i.dtype !== "int32" && (i = jo(i, "int32")), e === "int") return i;
    const a = i.shape;
    if (i.rank === 0 && (i = Xi(i, -1)), e === "oneHot" && i.shape[i.shape.length - 1] !== 1 && (i = Xi(i, -1)), i.rank > 2) throw new j(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${a} which would result in output rank ${i.rank}.`);
    const s = [
      "multiHot",
      "oneHot"
    ].includes(e), o = i;
    let l;
    if (typeof r < "u" && e === "count" ? l = w4(o, r, t, s) : l = w4(o, [], t, s), e !== "tfIdf") return l;
    if (r) return Z(l, r);
    throw new j("When outputMode is 'tfIdf', weights must be provided.");
  }
  class LJ extends qt {
    constructor(e) {
      super(e), this.numTokens = e.numTokens, e.outputMode ? this.outputMode = e.outputMode : this.outputMode = "multiHot";
    }
    getConfig() {
      const e = {
        numTokens: this.numTokens,
        outputMode: this.outputMode
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    computeOutputShape(e) {
      return e = dn(e), e == null ? [
        this.numTokens
      ] : this.outputMode === "oneHot" && e[e.length - 1] !== 1 ? (e.push(this.numTokens), e) : (e[e.length - 1] = this.numTokens, e);
    }
    call(e, t) {
      return se(() => {
        e = St(e), e.dtype !== "int32" && (e = jo(e, "int32"));
        let r;
        if (typeof t.countWeights < "u") {
          if (this.outputMode !== "count") throw new j(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);
          r = St(t.countWeights);
        }
        const i = Js(e), a = RS(e), s = ja(this.numTokens, i).bufferSync().get(0), o = op(a, 0).bufferSync().get(0);
        if (!(s && o)) throw new j(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);
        return TFe(e, this.outputMode, this.numTokens, r);
      });
    }
  }
  LJ.className = "CategoryEncoding";
  we(LJ);
  const AFe = [
    "bilinear",
    "nearest"
  ], lU = new Set(AFe);
  class FJ extends qt {
    constructor(e) {
      if (super(e), this.height = e.height, this.width = e.width, e.interpolation) if (lU.has(e.interpolation)) this.interpolation = e.interpolation;
      else throw new j(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);
      else this.interpolation = "bilinear";
      this.cropToAspectRatio = !!e.cropToAspectRatio;
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = e[2];
      return [
        this.height,
        this.width,
        t
      ];
    }
    getConfig() {
      const e = {
        height: this.height,
        width: this.width,
        interpolation: this.interpolation,
        cropToAspectRatio: this.cropToAspectRatio
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    call(e, t) {
      return se(() => {
        const r = [
          this.height,
          this.width
        ];
        if (this.interpolation === "bilinear") return Dl.resizeBilinear(e, r, !this.cropToAspectRatio);
        if (this.interpolation === "nearest") return Dl.resizeNearestNeighbor(e, r, !this.cropToAspectRatio);
        throw new Error(`Interpolation is ${this.interpolation} but only ${[
          ...lU
        ]} are supported`);
      });
    }
  }
  FJ.className = "Resizing";
  we(FJ);
  class OJ {
    constructor(e) {
      this.seed = e;
    }
    next() {
      if (this.seed !== void 0) return this.seed++;
    }
  }
  OJ.className = "RandomSeed";
  class BJ extends qt {
    constructor(e) {
      super(e), this.randomGenerator = new OJ(e.seed);
    }
    getConfig() {
      const e = {
        seed: this.randomGenerator.seed
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
  }
  BJ.className = "BaseRandomLayer";
  const DFe = [
    "bilinear",
    "nearest"
  ], uU = new Set(DFe);
  class zJ extends BJ {
    constructor(e) {
      super(e);
      const { factor: t, interpolation: r = "bilinear" } = e;
      if (this.factor = t, Array.isArray(this.factor) && this.factor.length === 2) this.widthLower = this.factor[0], this.widthUpper = this.factor[1];
      else if (!Array.isArray(this.factor) && this.factor > 0) this.widthLower = -this.factor, this.widthUpper = this.factor;
      else throw new j(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);
      if (this.widthLower < -1 || this.widthUpper < -1) throw new j(`factor must have values larger than -1. Got: ${this.factor}`);
      if (this.widthUpper < this.widthLower) throw new j(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);
      if (r) if (uU.has(r)) this.interpolation = r;
      else throw new j(`Invalid interpolation parameter: ${r} is not implemented`);
    }
    getConfig() {
      const e = {
        factor: this.factor,
        interpolation: this.interpolation
      }, t = super.getConfig();
      return Object.assign(e, t), e;
    }
    computeOutputShape(e) {
      e = dn(e);
      const t = e[2];
      return [
        this.imgHeight,
        -1,
        t
      ];
    }
    call(e, t) {
      return se(() => {
        const r = St(e);
        this.imgHeight = r.shape[r.shape.length - 3];
        const i = r.shape[r.shape.length - 2];
        this.widthFactor = xb([
          1
        ], 1 + this.widthLower, 1 + this.widthUpper, "float32", this.randomGenerator.next());
        let a = this.widthFactor.dataSync()[0] * i;
        a = Math.round(a);
        const s = [
          this.imgHeight,
          a
        ];
        switch (this.interpolation) {
          case "bilinear":
            return Dl.resizeBilinear(e, s);
          case "nearest":
            return Dl.resizeNearestNeighbor(e, s);
          default:
            throw new Error(`Interpolation is ${this.interpolation}
          but only ${[
              ...uU
            ]} are supported`);
        }
      });
    }
  }
  zJ.className = "RandomWidth";
  we(zJ);
  const RFe = ne();
  RFe.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (n) => {
    n && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
  });
  var cU;
  (function(n) {
    n[n.DT_INVALID = 0] = "DT_INVALID", n[n.DT_FLOAT = 1] = "DT_FLOAT", n[n.DT_DOUBLE = 2] = "DT_DOUBLE", n[n.DT_INT32 = 3] = "DT_INT32", n[n.DT_UINT8 = 4] = "DT_UINT8", n[n.DT_INT16 = 5] = "DT_INT16", n[n.DT_INT8 = 6] = "DT_INT8", n[n.DT_STRING = 7] = "DT_STRING", n[n.DT_COMPLEX64 = 8] = "DT_COMPLEX64", n[n.DT_INT64 = 9] = "DT_INT64", n[n.DT_BOOL = 10] = "DT_BOOL", n[n.DT_QINT8 = 11] = "DT_QINT8", n[n.DT_QUINT8 = 12] = "DT_QUINT8", n[n.DT_QINT32 = 13] = "DT_QINT32", n[n.DT_BFLOAT16 = 14] = "DT_BFLOAT16", n[n.DT_QINT16 = 15] = "DT_QINT16", n[n.DT_QUINT16 = 16] = "DT_QUINT16", n[n.DT_UINT16 = 17] = "DT_UINT16", n[n.DT_COMPLEX128 = 18] = "DT_COMPLEX128", n[n.DT_HALF = 19] = "DT_HALF", n[n.DT_RESOURCE = 20] = "DT_RESOURCE", n[n.DT_VARIANT = 21] = "DT_VARIANT", n[n.DT_UINT32 = 22] = "DT_UINT32", n[n.DT_UINT64 = 23] = "DT_UINT64", n[n.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", n[n.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", n[n.DT_INT32_REF = 103] = "DT_INT32_REF", n[n.DT_UINT8_REF = 104] = "DT_UINT8_REF", n[n.DT_INT16_REF = 105] = "DT_INT16_REF", n[n.DT_INT8_REF = 106] = "DT_INT8_REF", n[n.DT_STRING_REF = 107] = "DT_STRING_REF", n[n.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", n[n.DT_INT64_REF = 109] = "DT_INT64_REF", n[n.DT_BOOL_REF = 110] = "DT_BOOL_REF", n[n.DT_QINT8_REF = 111] = "DT_QINT8_REF", n[n.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", n[n.DT_QINT32_REF = 113] = "DT_QINT32_REF", n[n.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", n[n.DT_QINT16_REF = 115] = "DT_QINT16_REF", n[n.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", n[n.DT_UINT16_REF = 117] = "DT_UINT16_REF", n[n.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", n[n.DT_HALF_REF = 119] = "DT_HALF_REF", n[n.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", n[n.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", n[n.DT_UINT32_REF = 122] = "DT_UINT32_REF", n[n.DT_UINT64_REF = 123] = "DT_UINT64_REF";
  })(cU || (cU = {}));
  var hU;
  (function(n) {
    (function(e) {
      e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2";
    })(n.CheckpointFormatVersion || (n.CheckpointFormatVersion = {}));
  })(hU || (hU = {}));
  var dU;
  (function(n) {
    n[n.FAIL = 0] = "FAIL", n[n.SHORTEST = 1] = "SHORTEST", n[n.LONGEST = 2] = "LONGEST";
  })(dU || (dU = {}));
  function et(n, e) {
    Array.isArray(n) || (n = [
      n
    ]), n.forEach((t) => {
      t != null && B(t.dtype !== "complex64", () => `${e} does not support complex64 tensors in the CPU backend.`);
    });
  }
  const $Fe = j9;
  class n2 extends Zx {
    nextDataId() {
      return n2.nextDataId++;
    }
    constructor() {
      super(), this.blockSize = 48, this.firstUse = true, this.data = new ZC(this, ga());
    }
    write(e, t, r) {
      this.firstUse && (this.firstUse = false, ne().get("IS_NODE") && Fa(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));
      const i = {
        id: this.nextDataId()
      };
      return this.data.set(i, {
        values: e,
        dtype: r,
        refCount: 1
      }), i;
    }
    makeTensorInfo(e, t, r) {
      let i;
      if (t === "string" && r != null && r.length > 0 && Tm(r[0])) {
        const a = r.map((s) => Bl(s));
        i = this.write(a, e, t);
      } else i = this.write(r, e, t);
      return {
        dataId: i,
        shape: e,
        dtype: t
      };
    }
    refCount(e) {
      return this.data.has(e) ? this.data.get(e).refCount : 0;
    }
    incRef(e) {
      const t = this.data.get(e);
      t.refCount++;
    }
    decRef(e) {
      if (this.data.has(e)) {
        const t = this.data.get(e);
        t.refCount--;
      }
    }
    move(e, t, r, i, a) {
      this.data.set(e, {
        values: t,
        dtype: i,
        refCount: a
      });
    }
    numDataIds() {
      return this.data.numDataIds();
    }
    async read(e) {
      return this.readSync(e);
    }
    readSync(e) {
      const { dtype: t, complexTensorInfos: r } = this.data.get(e);
      if (t === "complex64") {
        const i = this.readSync(r.real.dataId), a = this.readSync(r.imag.dataId);
        return ao(i, a);
      }
      return g_(this.data.get(e).values, t);
    }
    bufferSync(e) {
      const t = this.readSync(e.dataId);
      if (e.dtype === "string") try {
        const r = t.map((i) => io(i));
        return Nt(e.shape, e.dtype, r);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return Nt(e.shape, e.dtype, t);
    }
    makeOutput(e, t, r) {
      return ga().makeTensorFromTensorInfo(this.makeTensorInfo(t, r, e), this);
    }
    disposeData(e, t = false) {
      if (this.data.has(e)) {
        if (this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0) return false;
        const { complexTensorInfos: r } = this.data.get(e);
        r != null && (this.disposeData(r.real.dataId, true), this.disposeData(r.imag.dataId, true)), this.data.delete(e);
      }
      return true;
    }
    disposeIntermediateTensorInfo(e) {
      this.disposeData(e.dataId);
    }
    async time(e) {
      const t = hi();
      return e(), {
        kernelMs: hi() - t
      };
    }
    memory() {
      return {
        unreliable: true,
        reasons: [
          "The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."
        ]
      };
    }
    where(e) {
      et([
        e
      ], "where");
      const t = this.readSync(e.dataId);
      return $Fe(e.shape, t);
    }
    dispose() {
    }
    floatPrecision() {
      return 32;
    }
    epsilon() {
      return super.epsilon();
    }
  }
  n2.nextDataId = 0;
  function VJ(n) {
    const e = new Float32Array(n.length);
    for (let t = 0; t < n.length; ++t) e[t] = Math.abs(n[t]);
    return e;
  }
  const NFe = (n) => {
    const { x: e } = n.inputs, t = n.backend;
    et(e, "abs");
    let r = new Float32Array(X(e.shape));
    const i = t.data.get(e.dataId).values;
    return r = VJ(i), t.makeOutput(r, e.shape, e.dtype);
  }, EFe = {
    kernelName: Dm,
    backendName: "cpu",
    kernelFunc: NFe
  };
  function pr(n) {
    return (e, t, r, i, a) => {
      const s = ht(e, t), o = s.length, l = Be(s), u = X(s), c = Yr(a, u), h = e.length, d = t.length, f = Be(e), p = Be(t), g = lc(e, s), m = lc(t, s);
      if (g.length + m.length === 0) for (let v = 0; v < c.length; ++v) c[v] = n(r[v % r.length], i[v % i.length]);
      else for (let v = 0; v < c.length; ++v) {
        const y = Am(v, o, l), x = y.slice(-h);
        g.forEach((S) => x[S] = 0);
        const b = Yo(x, h, f), w = y.slice(-d);
        m.forEach((S) => w[S] = 0);
        const _ = Yo(w, d, p);
        c[v] = n(r[b], i[_]);
      }
      return [
        c,
        s
      ];
    };
  }
  function wa(n) {
    const { inputs: e, backend: t } = n, { real: r, imag: i } = e, a = t.data.get(r.dataId).values, s = t.data.get(i.dataId).values, o = t.makeTensorInfo(r.shape, "complex64"), l = t.data.get(o.dataId);
    return l.complexTensorInfos = {
      real: t.makeTensorInfo(r.shape, "float32", a),
      imag: t.makeTensorInfo(i.shape, "float32", s)
    }, o;
  }
  const MFe = {
    kernelName: tI,
    backendName: "cpu",
    kernelFunc: wa
  };
  function US(n, e, t = "float32") {
    if (t === "complex64") {
      const i = US(n, e, "float32"), a = US(n, e, "float32");
      return wa({
        inputs: {
          real: i,
          imag: a
        },
        backend: n
      });
    }
    const r = si(X(e), t);
    return n.makeTensorInfo(e, t, r);
  }
  function ol(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    return t.incRef(r.dataId), {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  const PFe = {
    kernelName: vf,
    backendName: "cpu",
    kernelFunc: ol
  };
  function Ad(n) {
    const { inputs: e, backend: t } = n, { input: r } = e, i = t.data.get(r.dataId).complexTensorInfos.real, a = t.data.get(i.dataId).values;
    return t.makeTensorInfo(i.shape, i.dtype, a);
  }
  const LFe = {
    kernelName: hI,
    backendName: "cpu",
    kernelFunc: Ad
  };
  function WJ(n, e, t, r) {
    if (r === "int32") {
      const i = Int32Array.from(n);
      return [
        e,
        "int32",
        i
      ];
    }
    if (r === "bool") {
      const i = sp([
        0
      ], t), [a, s] = pr((o, l) => o !== l ? 1 : 0)(e, [], n, i, "bool");
      return [
        s,
        "bool",
        a
      ];
    }
    throw new Error(`Error in Cast: failed to cast ${t} to ${r}`);
  }
  function fc(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { dtype: a } = r;
    if (a === "complex64") {
      if (i.dtype === "complex64") return ol({
        inputs: {
          x: i
        },
        backend: t
      });
      const c = US(t, i.shape, i.dtype), h = fc({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          dtype: "float32"
        }
      }), d = wa({
        inputs: {
          real: h,
          imag: c
        },
        backend: t
      });
      return t.disposeIntermediateTensorInfo(c), t.disposeIntermediateTensorInfo(h), d;
    }
    if (i.dtype === "complex64") {
      const c = Ad({
        inputs: {
          input: i
        },
        backend: t
      }), h = fc({
        inputs: {
          x: c
        },
        backend: t,
        attrs: {
          dtype: a
        }
      });
      return t.disposeIntermediateTensorInfo(c), h;
    }
    if (!UM(i.dtype, a)) {
      const c = ol({
        inputs: {
          x: i
        },
        backend: t
      });
      return {
        dataId: c.dataId,
        shape: c.shape,
        dtype: a
      };
    }
    const s = t.data.get(i.dataId).values, [o, l, u] = WJ(s, i.shape, i.dtype, a);
    return t.makeTensorInfo(o, l, u);
  }
  const FFe = {
    kernelName: Zd,
    backendName: "cpu",
    kernelFunc: fc
  };
  function Lr(n, e, t, r) {
    return t == null ? ({ inputs: i, backend: a }) => {
      const { a: s, b: o } = i, l = a;
      et([
        s,
        o
      ], n);
      const u = l.data.get(s.dataId).values, c = l.data.get(o.dataId).values, h = s.dtype === "string" ? so(u) : u, d = s.dtype === "string" ? so(c) : c, f = r || s.dtype, [p, g] = e(s.shape, o.shape, h, d, f);
      return l.makeTensorInfo(g, f, p);
    } : ({ inputs: i, backend: a }) => {
      const { a: s, b: o } = i, l = a;
      if (s.dtype === "complex64" || o.dtype === "complex64") {
        const u = fc({
          inputs: {
            x: s
          },
          backend: l,
          attrs: {
            dtype: "complex64"
          }
        }), c = l.data.get(u.dataId), h = c.complexTensorInfos.real, d = c.complexTensorInfos.imag, f = l.data.get(h.dataId).values, p = l.data.get(d.dataId).values, g = fc({
          inputs: {
            x: o
          },
          backend: l,
          attrs: {
            dtype: "complex64"
          }
        }), m = l.data.get(g.dataId), v = m.complexTensorInfos.real, y = m.complexTensorInfos.imag, x = l.data.get(v.dataId).values, b = l.data.get(y.dataId).values, [w, _, S] = t(s.shape, o.shape, f, p, x, b), I = l.makeTensorInfo(S, "float32", w), C = l.makeTensorInfo(S, "float32", _), T = wa({
          inputs: {
            real: I,
            imag: C
          },
          backend: l
        });
        return l.disposeIntermediateTensorInfo(u), l.disposeIntermediateTensorInfo(g), l.disposeIntermediateTensorInfo(I), l.disposeIntermediateTensorInfo(C), T;
      } else {
        const u = l.data.get(s.dataId).values, c = l.data.get(o.dataId).values, h = r || s.dtype, [d, f] = e(s.shape, o.shape, u, c, h);
        return l.makeTensorInfo(f, h, d);
      }
    };
  }
  function hL(n) {
    return (e, t, r, i, a, s) => {
      const o = ht(e, t), l = X(o), u = o.length, c = Be(o), h = Yr("float32", l), d = Yr("float32", l), f = lc(e, o), p = lc(t, o), g = ao(r, i), m = ao(a, s), v = e.length, y = Be(e), x = t.length, b = Be(t);
      if (f.length + p.length === 0) for (let w = 0; w < h.length; w++) {
        const _ = w % g.length, S = w % m.length, I = n(g[_ * 2], g[_ * 2 + 1], m[S * 2], m[S * 2 + 1]);
        h[w] = I.real, d[w] = I.imag;
      }
      else for (let w = 0; w < h.length; w++) {
        const _ = Am(w, u, c), S = _.slice(-v);
        f.forEach((D) => S[D] = 0);
        const I = Yo(S, v, y), C = _.slice(-x);
        p.forEach((D) => C[D] = 0);
        const T = Yo(C, x, b), k = n(g[I * 2], g[I * 2 + 1], m[T * 2], m[T * 2 + 1]);
        h[w] = k.real, d[w] = k.imag;
      }
      return [
        h,
        d,
        o
      ];
    };
  }
  const GJ = pr((n, e) => n + e), OFe = hL((n, e, t, r) => ({
    real: n + t,
    imag: e + r
  })), Qg = Lr(xc, GJ, OFe), BFe = {
    kernelName: xc,
    backendName: "cpu",
    kernelFunc: Qg
  };
  function dL(n, e, t, r, i) {
    const a = X(r), s = si(i, t);
    for (let o = 0; o < n.length; o++) {
      const l = n[o];
      if (l < 0) throw new Error("Input x must be non-negative!");
      l >= i || (a > 0 ? s[l] += e[o] : s[l] += 1);
    }
    return s;
  }
  function UJ(n, e, t, r = false) {
    const i = n.shape[0], a = n.shape[1], s = Nt([
      i,
      t
    ], e.dtype);
    for (let o = 0; o < i; o++) for (let l = 0; l < a; l++) {
      const u = n.get(o, l);
      if (u < 0) throw new Error("Input x must be non-negative!");
      u >= t || (r ? s.set(1, o, u) : e.size > 0 ? s.set(s.get(o, u) + e.get(o, l), o, u) : s.set(s.get(o, u) + 1, o, u));
    }
    return s;
  }
  const HJ = pr((n, e) => n & e), zFe = Lr(JC, HJ), VFe = {
    kernelName: JC,
    backendName: "cpu",
    kernelFunc: zFe
  };
  function dl(n) {
    return (e, t, r) => {
      const i = ir(t, e.length);
      for (let a = 0; a < e.length; ++a) i[a] = n(e[a], r);
      return i;
    };
  }
  function An(n, e, t) {
    const r = dl(e);
    return Ac(n, r, t);
  }
  function Ac(n, e, t) {
    return ({ inputs: r, attrs: i, backend: a }) => {
      const { x: s } = r;
      et(s, n);
      const o = a, l = o.data.get(s.dataId).values;
      let u;
      if (s.dtype === "string") {
        if (!Array.isArray(l)) throw new Error("String tensor's value was not an instance of Array");
        u = so(l);
      } else u = l;
      const c = t || s.dtype, h = e(u, c, i);
      return o.makeTensorInfo(s.shape, c, h);
    };
  }
  const XJ = dl((n) => Math.ceil(n)), WFe = Ac(Qd, XJ), GFe = {
    kernelName: Qd,
    backendName: "cpu",
    kernelFunc: WFe
  };
  function fL(n, e, t, r) {
    const i = ir(t, X(e));
    if (r && t !== "string") {
      let a = 0;
      n.forEach((s) => {
        const o = X(s.shape);
        i.set(s.vals, a), a += o;
      });
    } else {
      let a = 0;
      n.forEach((s) => {
        const o = t === "string" ? so(s.vals) : s.vals;
        let l = 0;
        for (let u = 0; u < s.shape[0]; ++u) {
          const c = u * e[1] + a;
          for (let h = 0; h < s.shape[1]; ++h) i[c + h] = o[l++];
        }
        a += s.shape[1];
      });
    }
    return i;
  }
  const YJ = pr((n, e) => n === e ? 1 : 0), qJ = Lr(Hm, YJ, null, "bool"), UFe = {
    kernelName: Hm,
    backendName: "cpu",
    kernelFunc: qJ
  };
  const jJ = dl((n) => Math.exp(n)), KJ = Ac(hf, jJ, "float32"), HFe = {
    kernelName: hf,
    backendName: "cpu",
    kernelFunc: KJ
  };
  const ZJ = dl((n) => Math.expm1(n)), XFe = Ac(df, ZJ), YFe = {
    kernelName: df,
    backendName: "cpu",
    kernelFunc: XFe
  };
  const QJ = dl((n) => Math.floor(n)), qFe = Ac(ff, QJ), jFe = {
    kernelName: ff,
    backendName: "cpu",
    kernelFunc: qFe
  };
  const JJ = pr((n, e) => Math.floor(n / e)), KFe = Lr(pf, JJ, null, "int32"), ZFe = {
    kernelName: pf,
    backendName: "cpu",
    kernelFunc: KFe
  };
  function eee(n, e, t, r, i, a, s, o, l) {
    const u = Nt([
      r,
      a
    ], t);
    for (let c = 0; c < r; c++) {
      const h = [];
      let d = 0;
      for (let f = 0; f < i; f++) {
        const p = n[c * i + f];
        d += p * s[f], h.push(p);
      }
      if (d < 0 || d >= l / a) throw new Error(`Invalid indices: ${h} does not index into ${o}`);
      for (let f = 0; f < a; f++) u.values[c * a + f] = e.get(...e.indexToLoc(d * a + f));
    }
    return u;
  }
  function tee(n, e, t) {
    const r = Nt(t, n.dtype);
    for (let i = 0; i < r.size; ++i) {
      const s = r.indexToLoc(i).slice(), o = s[0], l = s[2], u = e.locToIndex([
        o,
        l
      ]);
      s[2] = e.values[u];
      const c = n.locToIndex(s);
      0 <= c && c < n.values.length && (r.values[i] = n.values[c]);
    }
    return r;
  }
  const nee = pr((n, e) => n > e ? 1 : 0), QFe = Lr(jm, nee, null, "bool"), JFe = {
    kernelName: jm,
    backendName: "cpu",
    kernelFunc: QFe
  };
  const ree = pr((n, e) => n >= e ? 1 : 0), eOe = Lr(mf, ree, null, "bool"), tOe = {
    kernelName: mf,
    backendName: "cpu",
    kernelFunc: eOe
  };
  const iee = pr((n, e) => n < e ? 1 : 0), nOe = Lr(Km, iee, null, "bool"), rOe = {
    kernelName: Km,
    backendName: "cpu",
    kernelFunc: nOe
  };
  const aee = pr((n, e) => n <= e ? 1 : 0), iOe = Lr(Zm, aee, null, "bool"), aOe = {
    kernelName: Zm,
    backendName: "cpu",
    kernelFunc: iOe
  };
  function see(n, e, t) {
    const r = (e - n) / (t - 1), i = si(t, "float32");
    i[0] = n;
    for (let a = 1; a < i.length; a++) i[a] = i[a - 1] + r;
    return i;
  }
  const oee = dl((n) => Math.log(n)), sOe = Ac(_f, oee), oOe = {
    kernelName: _f,
    backendName: "cpu",
    kernelFunc: sOe
  };
  function lee(n, e, t, r) {
    const i = Yr(r, X(t));
    for (let a = 0; a < i.length; ++a) {
      const s = a * e;
      let o = n[s];
      for (let l = 0; l < e; ++l) {
        const u = n[s + l];
        (Number.isNaN(u) || u > o) && (o = u);
      }
      i[a] = o;
    }
    return i;
  }
  const uee = pr((n, e) => Math.max(n, e)), lOe = Lr(kf, uee), uOe = {
    kernelName: kf,
    backendName: "cpu",
    kernelFunc: lOe
  };
  const cee = pr((n, e) => Math.min(n, e)), cOe = Lr(Rf, cee), hOe = {
    kernelName: Rf,
    backendName: "cpu",
    kernelFunc: cOe
  };
  const pL = pr((n, e) => n * e), dOe = hL((n, e, t, r) => ({
    real: n * t - e * r,
    imag: n * r + e * t
  })), r2 = Lr(Ef, pL, dOe), fOe = {
    kernelName: Ef,
    backendName: "cpu",
    kernelFunc: r2
  };
  function hee(n, e, t) {
    const r = Sc(-1, t);
    return pL([], e, r, n, t);
  }
  function pOe(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    et(r, "neg");
    const i = t.data.get(r.dataId).values, [a, s] = hee(i, r.shape, r.dtype);
    return t.makeTensorInfo(s, r.dtype, a);
  }
  const gOe = {
    kernelName: rv,
    backendName: "cpu",
    kernelFunc: pOe
  };
  const dee = pr((n, e) => n !== e ? 1 : 0), mOe = Lr(iv, dee, null, "bool"), vOe = {
    kernelName: iv,
    backendName: "cpu",
    kernelFunc: mOe
  };
  function gL(n, e, t, r, i) {
    const a = e.length, s = X(e), o = Be(e), l = Be(i), u = Yr(t, X(i));
    for (let c = 0; c < s; ++c) {
      const h = Am(c, a, o), d = new Array(h.length);
      for (let p = 0; p < d.length; p++) d[p] = h[r[p]];
      const f = Yo(d, a, l);
      u[f] = n[c];
    }
    return u;
  }
  function sa(n) {
    const { inputs: e, attrs: t, backend: r } = n, { x: i } = e, { perm: a } = t;
    et(i, "transpose");
    const s = i.shape.length, o = new Array(s);
    for (let h = 0; h < o.length; h++) o[h] = i.shape[a[h]];
    const l = r.data.get(i.dataId).values, u = gL(l, i.shape, i.dtype, a, o);
    return {
      dataId: r.write(u, o, i.dtype),
      shape: o,
      dtype: i.dtype
    };
  }
  const yOe = {
    kernelName: Ol,
    backendName: "cpu",
    kernelFunc: sa
  };
  function fee(n, e, t, r) {
    const [i, a] = Ln(n, r), s = qr(e, "int32"), o = si(X(i), s), l = X(a);
    for (let u = 0; u < o.length; ++u) {
      const c = u * l;
      let h = 1;
      for (let d = 0; d < l; ++d) h *= t[c + d];
      o[u] = h;
    }
    return {
      outVals: o,
      outShape: i,
      outDtype: s
    };
  }
  function xOe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    et(i, "prod");
    const o = i.shape.length, l = yt(a, i.shape), u = bn(l, o);
    let c = l, h = i;
    const d = [];
    u != null && (h = sa({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), d.push(h), c = gn(c.length, o));
    const f = t.data.get(h.dataId).values, { outVals: p, outShape: g, outDtype: m } = fee(h.shape, h.dtype, f, c);
    let v = g;
    return s && (v = Mn(g, l)), d.forEach((y) => t.disposeIntermediateTensorInfo(y)), t.makeTensorInfo(v, m, p);
  }
  const bOe = {
    kernelName: Of,
    backendName: "cpu",
    kernelFunc: xOe
  };
  function wOe(n, e, t) {
    n.forEach((r, i) => {
      if (r < 0 || r >= t) {
        const a = Am(i, e.length, Be(e)).join(",");
        throw new Error(`indices[${a}] = ${r} is not in [0, ${t})`);
      }
    });
  }
  function _Oe(n, e) {
    for (let t = 0; t < n.length; ++t) {
      const r = n[t], i = t === n.length - 1 ? e : n[t + 1].length;
      if (r.length === 0) throw new Error("Ragged splits may not be empty");
      if (r[0] < 0) throw new Error("Ragged splits must be non-negative");
      if (r[r.length - 1] > i) throw new Error("Ragged splits must not point past values");
      for (let a = 1; a < r.length; ++a) if (r[a - 1] > r[a]) throw new Error("Ragged splits must be sorted in ascending order");
    }
  }
  function SOe(n, e, t, r) {
    const i = [];
    let a = 0;
    const s = e.length - 1 + t.length, o = new Array(s).fill(null).map(() => [
      0
    ]);
    _Oe(t, r);
    let l = 1;
    for (let u = 0; u < e.length - 1; ++u) {
      l *= e[u];
      const c = e[u + 1];
      for (let h = 1; h < l + 1; ++h) o[u].push(h * c);
    }
    for (let u = 0; u < n.length; ++u) {
      let c = n[u], h = n[u] + 1;
      for (let d = 0; d < t.length; ++d) {
        const f = t[d], p = d + e.length - 1;
        if (p >= 0) {
          const g = o[p], m = g[g.length - 1] - f[c];
          for (let v = c; v < h; ++v) o[p].push(f[v + 1] + m);
        }
        c = f[c], h = f[h];
      }
      h !== c && (i.push([
        c,
        h
      ]), a += h - c);
    }
    return {
      outSplits: o,
      valueSlices: i,
      numValues: a
    };
  }
  function COe(n) {
    const e = [];
    for (let t = 0; t < n.length; ++t) {
      const r = n[t].length, i = ir("int32", r);
      e.push(i), n[t].forEach((a, s) => i[s] = a);
    }
    return e;
  }
  function fU(n, e) {
    const t = n.slice(0, e);
    for (; t.length < e; ) t.push(1);
    for (let r = e; r < n.length; r++) t[e - 1] *= n[r];
    return t;
  }
  function IOe(n, e, t, r, i, a) {
    const s = fU(e, 2)[1], o = fU(a, 2)[1];
    let l = 0;
    for (const u of t) for (let c = u[0]; c < u[1]; ++c) {
      for (let h = 0; h < r; ++h) i[l * o + h] = n[c * s + h];
      ++l;
    }
  }
  function kOe(n, e, t, r, i) {
    const a = e.slice();
    a[0] = i;
    const s = ir(t, X(a)), o = n.length, l = o === 0 ? 0 : o / e[0];
    return IOe(n, e, r, l, s, a), [
      s,
      a
    ];
  }
  function pee(n, e, t, r, i, a, s, o) {
    if (n.length === 0) throw new Error("paramsNestedSplits must be non empty");
    if (e[0].length === 0) throw new Error("Split tensors must not be scalars");
    const l = e[0][0] - 1;
    if (wOe(a, s, l), r.length === 0) throw new Error("params.rank must be nonzero");
    const u = r[0], { outSplits: c, valueSlices: h, numValues: d } = SOe(a, s, n, u), f = COe(c), p = kOe(t, r, i, h, d);
    return [
      f,
      p[0],
      p[1]
    ];
  }
  const pU = 2147483647;
  function gee(n, e, t, r, i, a, s) {
    if (e.length > 1) throw new Error("starts must be a scalar or vector");
    if (i.length > 1) throw new Error("limits must be a scalar or vector");
    if (s.length > 1) throw new Error("deltas must be a scalar or vector");
    const o = e.length === 0, l = i.length === 0, u = s.length === 0, c = [];
    o || c.push(e[0]), l || c.push(i[0]), u || c.push(s[0]);
    for (let m = 1; m < c.length; ++m) if (c[m] !== c[m - 1]) throw new Error("starts, limits, and deltas must have the same shape");
    const h = c.length === 0 ? 1 : c[0], d = ir("int32", h + 1);
    d[0] = 0;
    for (let m = 0; m < h; ++m) {
      const v = o ? n[0] : n[m], y = l ? r[0] : r[m], x = u ? a[0] : a[m];
      if (x === 0) throw new Error("Requires delta != 0");
      let b;
      if (x > 0 && y < v || x < 0 && y > v) b = 0;
      else if (b = Math.ceil(Math.abs((y - v) / x)), b > pU) throw new Error(`Requires ((limit - start) / delta) <= ${pU}`);
      d[m + 1] = d[m] + b;
    }
    const f = d[h], p = ir(t, f);
    let g = 0;
    for (let m = 0; m < h; ++m) {
      const v = d[m + 1] - d[m];
      let y = o ? n[0] : n[m];
      const x = u ? a[0] : a[m];
      for (let b = 0; b < v; ++b) p[g++] = y, y += x;
    }
    return [
      d,
      p
    ];
  }
  var is = Gs;
  class HS {
    constructor(e, t, r, i, a, s, o, l, u, c) {
      this.shape = e, this.shapeShape = t, this.values = r, this.valuesShape = i, this.valuesDType = a, this.defaultValue = s, this.defaultValueShape = o, this.rowPartitionValues = l, this.rowPartitionValuesShapes = u, this.rowPartitionTypes = pZ(c), this.raggedRank = gZ(this.rowPartitionTypes);
    }
    getRowPartitionTypeByDimension(e) {
      return this.rowPartitionTypes[0] === is.FIRST_DIM_SIZE ? this.rowPartitionTypes[e + 1] : this.rowPartitionTypes[e];
    }
    getRowPartitionTensor(e) {
      return this.rowPartitionTypes[0] === is.FIRST_DIM_SIZE ? this.rowPartitionValues[e + 1] : this.rowPartitionValues[e];
    }
    getMaxWidth(e) {
      const t = this.getRowPartitionTensor(e - 1);
      switch (this.getRowPartitionTypeByDimension(e - 1)) {
        case is.VALUE_ROWIDS:
          return HS.getMaxWidthValueRowID(t);
        case is.ROW_SPLITS:
          return HS.getMaxWidthRowSplit(t);
        default:
          throw new Error(`Cannot handle partition type ${is[this.getRowPartitionTypeByDimension(e - 1)]}`);
      }
    }
    static getMaxWidthRowSplit(e) {
      const t = e.length;
      if (t === 0 || t === 1) return 0;
      let r = 0;
      for (let i = 0; i < t - 1; ++i) {
        const a = e[i + 1] - e[i];
        a > r && (r = a);
      }
      return r;
    }
    static getMaxWidthValueRowID(e) {
      const t = e.length;
      if (t === 0) return 0;
      let r = 0, i = e[0], a = 0;
      for (let s = 1; s < t; ++s) {
        const o = e[s];
        o !== i && (i = o, a = Math.max(s - r, a), r = s);
      }
      return Math.max(t - r, a);
    }
    tensorShapeFromTensor(e, t, r = true) {
      if (t.length === 0) {
        if (e[0] === -1) return [];
        throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
      }
      return mU(e, r);
    }
    calculateOutputSize(e) {
      const t = this.valuesShape, r = this.defaultValueShape;
      mZ(r, t);
      const i = this.tensorShapeFromTensor(this.shape, this.shapeShape), s = fZ(this.raggedRank, i, t);
      s[0] < 0 && (s[0] = e);
      for (let o = 1; o <= this.raggedRank; ++o) s[o] < 0 && (s[o] = this.getMaxWidth(o));
      return s;
    }
    calculateFirstParentOutputIndex(e, t, r) {
      const i = Math.min(e, r), a = [];
      let s = 0;
      for (let o = 0; o < i; ++o, s += t) a.push(s);
      for (let o = i; o < e; ++o) a.push(-1);
      return B(a.length === e, () => "Final length of result must be equal to firstDimension."), a;
    }
    calculateOutputIndexRowSplit(e, t, r, i) {
      const a = e.length, s = [];
      for (let o = 0; o < a - 1; ++o) {
        const l = e[o + 1] - e[o];
        let u = Math.min(i, l), c = t[o];
        c === -1 && (u = 0);
        for (let h = 0; h < u; ++h) s.push(c), c += r;
        for (let h = 0; h < l - u; ++h) s.push(-1);
      }
      if (a > 0 && s.length !== e[a - 1]) throw new Error("Invalid row split size.");
      return s;
    }
    calculateOutputIndexValueRowID(e, t, r, i) {
      const a = e.length, s = [];
      if (a === 0) return [];
      let o = 0, l = e[0];
      if (l >= t.length) throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);
      let u = t[l];
      s.push(u);
      for (let c = 1; c < a; ++c) {
        const h = e[c];
        if (h === l) u >= 0 && (++o, o < i ? u += r : u = -1);
        else {
          if (o = 0, l = h, h >= t.length) throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);
          u = t[h];
        }
        s.push(u);
      }
      if (s.length !== e.length) throw new Error("Invalid row ids.");
      return s;
    }
    calculateOutputIndex(e, t, r, i) {
      const a = this.getRowPartitionTensor(e), s = this.getRowPartitionTypeByDimension(e);
      switch (s) {
        case is.VALUE_ROWIDS:
          return this.calculateOutputIndexValueRowID(a, t, r, i);
        case is.ROW_SPLITS:
          if (a.length - 1 > t.length) throw new Error(`Row partition size is greater than output size: ${a.length - 1} > ${t.length}`);
          return this.calculateOutputIndexRowSplit(a, t, r, i);
        default:
          throw new Error(`Unsupported partition type: ${is[s]}`);
      }
    }
    getFirstDimensionSize() {
      const e = this.rowPartitionValues[0];
      if (this.rowPartitionTypes.length === 0) throw new Error("No row_partition_types given.");
      const t = this.rowPartitionTypes[0];
      switch (t) {
        case is.FIRST_DIM_SIZE:
          return e[0];
        case is.VALUE_ROWIDS:
          throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
        case is.ROW_SPLITS:
          return this.rowPartitionValuesShapes[0][0] - 1;
        default:
          throw new Error(`Cannot handle type ${is[t]}`);
      }
    }
    compute() {
      if (this.rowPartitionValues[0].length <= 0) throw new Error("Invalid first partition input. Tensor requires at least one element.");
      const t = this.getFirstDimensionSize(), r = this.calculateOutputSize(t), i = new Array(this.raggedRank + 1);
      i[i.length - 1] = 1;
      for (let l = i.length - 2; l >= 0; --l) i[l] = i[l + 1] * r[l + 1];
      const a = mU(r, false), s = ir(this.valuesDType, X(a));
      if (i[0] * r[0] > 0) {
        let l = this.calculateFirstParentOutputIndex(t, i[0], r[0]);
        for (let u = 1; u <= this.raggedRank; ++u) l = this.calculateOutputIndex(u - 1, l, i[u], r[u]);
        this.setOutput(this.raggedRank, l, s, a);
      }
      return [
        a,
        s
      ];
    }
    setOutput(e, t, r, i) {
      if (r.length === 0) return;
      const a = this.values, s = r;
      let o = i.slice();
      o = o.slice(e + 1);
      const l = X(o), u = t.length;
      let c = this.defaultValue;
      if (c.length !== l && c.length !== 1) {
        const p = this.defaultValueShape;
        se(() => {
          const g = ee(c, p);
          c = g0(g, o).dataSync();
        });
      }
      let h = 0, d = 0, f = 0;
      for (let p = 0; p <= u; ++p) {
        let g = p < u ? t[p] : -1;
        if (g === f) {
          ++f;
          continue;
        }
        if (d < f) {
          const m = a.subarray(h * l), v = s.subarray(d * l), y = (f - d) * l;
          gU(v, m, y);
        }
        if (p >= u) {
          const m = r.length;
          g = Math.floor(m / l);
        }
        if (g > f) if (this.defaultValue.length === 1) s.subarray(f * l, g * l).fill(this.defaultValue[0]), f = g;
        else for (; g > f; ) {
          const m = s.slice(f * l);
          gU(m, c, l), ++f;
        }
        g < 0 ? (h = p + 1, d = f) : (h = p, d = f, f = d + 1);
      }
    }
  }
  function gU(n, e, t) {
    for (let r = 0; r < t; r++) n[r] = e[r];
  }
  function mU(n, e) {
    const t = [];
    for (let r of n) {
      if (r < 0) {
        if (!e) throw new Error(`Dimension ${r} must be >= 0`);
        if (r < -1) throw new Error(`Dimension ${r} must be >= -1`);
        r = -1;
      }
      t.push(r);
    }
    return t;
  }
  function mee(n, e, t, r, i, a, s, o, l, u) {
    return new HS(n, e, t, r, i, a, s, o, l, u).compute();
  }
  function mL(n, e, t, r) {
    const i = n === e, a = n < e && t < 0, s = e < n && t > 1;
    if (i || a || s) return si(0, r);
    const o = Math.abs(Math.ceil((e - n) / t)), l = si(o, r);
    e < n && t === 1 && (t = -1), l[0] = n;
    for (let u = 1; u < l.length; u++) l[u] = l[u - 1] + t;
    return l;
  }
  const vee = dl((n) => 1 / Math.sqrt(n)), TOe = Ac(Xf, vee), AOe = {
    kernelName: Xf,
    backendName: "cpu",
    kernelFunc: TOe
  };
  function Uh(n, e, t, r, i, a, s, o, l, u) {
    const c = [
      r / i,
      i
    ], h = n.values, d = e.values;
    if (r === 0) return Nt(t, e.dtype);
    const f = l instanceof ii ? l : Nt(c, e.dtype);
    typeof l == "string" || typeof l == "number" ? f.values.fill(l) : typeof l == "boolean" && f.values.fill(+l);
    for (let p = 0; p < a; p++) {
      const g = [];
      let m = 0;
      for (let v = 0; v < s; v++) {
        const y = h[p * s + v];
        g.push(y), m += y * o[v];
      }
      if (m < 0 || m >= r / i) throw new Error(`Invalid indices: ${g} does not index into ${t}`);
      for (let v = 0; v < i; v++) u ? f.values[m * i + v] += d[p * i + v] : f.values[m * i + v] = e.rank === 0 ? d[0] : d[p * i + v];
    }
    return f;
  }
  const DOe = dl((n) => 1 / (1 + Math.exp(-n))), yee = An(Zf, (n) => 1 / (1 + Math.exp(-n))), ROe = {
    kernelName: Zf,
    backendName: "cpu",
    kernelFunc: yee
  };
  function XS(n, e, t, r, i) {
    const a = NI(r, e, t), s = X(t), o = Be(r);
    if (a) {
      const h = EI(e, o);
      return i === "string" ? n.slice(h, h + s) : n.subarray(h, h + s);
    }
    const l = i === "string" ? so(n) : n, u = Nt(r, i, l), c = Nt(t, i);
    for (let h = 0; h < c.size; ++h) {
      const d = c.indexToLoc(h), f = d.map((p, g) => p + e[g]);
      c.set(u.get(...f), ...d);
    }
    return i === "string" ? WP(c.values) : c.values;
  }
  function Dd(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { begin: a, size: s } = r;
    et(i, "slice");
    const [o, l] = Av(i, a, s);
    $I(i, o, l);
    const u = t.data.get(i.dataId).values, c = XS(u, o, l, i.shape, i.dtype);
    return t.makeTensorInfo(l, i.dtype, c);
  }
  const $Oe = {
    kernelName: fv,
    backendName: "cpu",
    kernelFunc: Dd
  };
  function xee(n, e, t, r, i, a, s) {
    const o = e[0], l = a[0], u = new Array(l), c = new Array(o), h = e[1];
    if (l === 0) {
      if (o !== 0) throw new Error(RP(o));
      const m = ir(t, 0), v = ir(i, 0);
      return [
        m,
        [
          0,
          h
        ],
        v,
        u,
        c
      ];
    }
    let d = true, f = 0;
    const p = new Array(l).fill(0);
    for (let m = 0; m < o; ++m) {
      const v = n[m * h];
      if (v < 0) throw new Error($P(m, v));
      if (v >= l) throw new Error(NP(m, v, l));
      ++p[v], d = d && v >= f, f = v;
    }
    let g = true;
    for (let m = 0; m < l; ++m) {
      const v = p[m] === 0;
      u[m] = v, g = g && !v, p[m] = Math.max(p[m], 1), m > 0 && (p[m] += p[m - 1]);
    }
    if (g && d) {
      const m = n, v = r;
      for (let y = 0; y < o; ++y) c[y] = y;
      return [
        m,
        [
          o,
          h
        ],
        v,
        u,
        c
      ];
    } else {
      const m = p[l - 1], v = ir(t, m * h), y = ir(i, m), x = new Array(l).fill(0);
      for (let b = 0; b < o; ++b) {
        const w = n[b * h], _ = x[w], S = (w === 0 ? 0 : p[w - 1]) + _;
        x[w]++;
        for (let I = 0; I < h; ++I) v[S * h + I] = n[b * h + I];
        y[S] = r[b], c[b] = S;
      }
      for (let b = 0; b < l; ++b) if (x[b] === 0) {
        const _ = b === 0 ? 0 : p[b - 1];
        v[_ * h + 0] = b;
        for (let S = 1; S < h; ++S) v[_ * h + S] = 0;
        y[_] = s;
      }
      return [
        v,
        [
          m,
          h
        ],
        y,
        u,
        c
      ];
    }
  }
  function bee(n, e, t, r, i) {
    const a = X(r), s = e[0], o = i.length, l = [];
    let u = 1, c = -1;
    for (let m = 0; m < o; ++m) {
      const v = i[m];
      if (v === -1) {
        if (c !== -1) throw new Error(EP(c, m));
        c = m, l.push(1);
      } else {
        if (v < 0) throw new Error(MP(m, v));
        u *= v, l.push(v);
      }
    }
    if (c !== -1) {
      if (u <= 0) throw new Error(PP());
      const m = Math.trunc(a / u);
      if (u * m !== a) throw new Error(LP(r, l));
      l[c] = m;
    }
    if (X(l) !== a) throw new Error(FP(r, l));
    const d = r.length, f = [];
    if (d > 0) {
      f[d - 1] = 1;
      for (let m = d - 2; m >= 0; --m) f[m] = f[m + 1] * r[m + 1];
    }
    const p = [];
    if (o > 0) {
      p[o - 1] = 1;
      for (let m = o - 2; m >= 0; --m) p[m] = p[m + 1] * l[m + 1];
    }
    const g = ir(t, s * o);
    for (let m = 0; m < s; ++m) {
      let v = 0;
      for (let y = 0; y < d; ++y) v += n[m * d + y] * f[y];
      for (let y = 0; y < o; ++y) g[m * o + y] = Math.trunc(v / p[y]), v %= p[y];
    }
    return [
      g,
      [
        s,
        o
      ],
      l
    ];
  }
  function vL(n, e, t, r, i, a = false, s = 0) {
    const o = r.length, l = [
      e[0],
      n.length / e[0]
    ], u = l[1], h = o > 0 ? i[o - 1] + 1 : 0;
    if (h < 0) throw new Error(lx());
    const d = e.slice();
    d[0] = h;
    const f = d.reduce((x, b) => x * b, 1), p = ir(t, f);
    if (o === 0) return h > 0 && p.fill(s), [
      p,
      d
    ];
    if (h <= 0) throw new Error(lx());
    let g = 0, m = 1, v = 0, y = i[g];
    for (; ; ) {
      let x = 0;
      if (m < o) {
        if (x = i[m], y === x) {
          ++m;
          continue;
        }
        if (y >= x) throw new Error(OP());
      }
      if (y < 0 || y >= h) throw new Error(BP(y, h));
      y > v && p.fill(s, v * u, y * u);
      for (let b = g; b < m; ++b) {
        const w = r[b];
        if (w < 0 || w >= l[0]) throw new Error(zP(b, r[b], l[0]));
        for (let _ = 0; _ < u; _++) p[y * u + _] += n[w * u + _];
      }
      if (a) for (let b = 0; b < u; b++) p[y * u + b] /= m - g;
      if (g = m, ++m, v = y + 1, y = x, m > o) break;
    }
    return v < h && p.fill(s, v * u, h * u), [
      p,
      d
    ];
  }
  const NOe = dl((n) => Math.sqrt(n)), EOe = An(Jf, (n) => Math.sqrt(n)), MOe = {
    kernelName: Jf,
    backendName: "cpu",
    kernelFunc: EOe
  };
  const wee = pr((n, e) => {
    const t = n - e;
    return t * t;
  }), POe = Lr(np, wee), LOe = {
    kernelName: np,
    backendName: "cpu",
    kernelFunc: POe
  };
  const _ee = dl((n, e) => {
    const { pattern: t, replaceGlobal: r, rewrite: i } = e;
    return n.replace(new RegExp(t, r ? "g" : ""), i);
  }), FOe = Ac(jM, _ee), OOe = {
    kernelName: jM,
    backendName: "cpu",
    kernelFunc: FOe
  };
  function See(n, e, t, r) {
    const i = Nt(n, e.dtype);
    for (let a = 0; a < i.size; a++) {
      const s = i.indexToLoc(a), o = new Array(s.length);
      for (let l = 0; l < o.length; l++) o[l] = s[l] * t[l] + r[l];
      i.set(e.get(...o), ...s);
    }
    return i;
  }
  class BOe {
    constructor(e, t, r, i, a, s) {
      this.separator = Bl(e), this.nGramWidths = t, this.leftPad = Bl(r), this.rightPad = Bl(i), this.padWidth = a, this.preserveShort = s;
    }
    getPadWidth(e) {
      return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
    }
    getNumNGrams(e, t) {
      const r = this.getPadWidth(t);
      return Math.max(0, e + 2 * r - t + 1);
    }
    createNGrams(e, t, r, i, a, s) {
      for (let o = 0; o < a; ++o) {
        const l = this.getPadWidth(s), u = Math.max(0, l - o), c = Math.max(0, l - (a - (o + 1))), h = s - (u + c), d = t + (u > 0 ? 0 : o - l);
        let f = 0;
        f += u * this.leftPad.length;
        for (let y = 0; y < h; ++y) f += e[d + y].length;
        f += c * this.rightPad.length;
        const p = u + c + h - 1;
        f += p * this.separator.length, r[i + o] = new Uint8Array(f);
        const g = r[i + o];
        let m = 0;
        const v = (y) => y.forEach((x) => g[m++] = x);
        for (let y = 0; y < u; ++y) v(this.leftPad), v(this.separator);
        for (let y = 0; y < h - 1; ++y) v(e[d + y]), v(this.separator);
        if (h > 0) {
          v(e[d + h - 1]);
          for (let y = 0; y < c; ++y) v(this.separator), v(this.rightPad);
        } else {
          for (let y = 0; y < c - 1; ++y) v(this.rightPad), v(this.separator);
          v(this.rightPad);
        }
      }
    }
    compute(e, t) {
      const r = e.length, i = t.length;
      if (i > 0) {
        let l = t[0];
        if (l !== 0) throw new Error(`First split value must be 0, got ${l}`);
        for (let u = 1; u < i; ++u) {
          let c = t[u] >= l;
          if (c = c && t[u] <= r, !c) throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${r}]`);
          l = t[u];
        }
        if (l !== r) throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`);
      }
      const a = i - 1, s = ir("int32", i);
      if (r === 0 || i === 0) {
        const l = new Array(r);
        for (let u = 0; u <= a; ++u) s[u] = 0;
        return [
          l,
          s
        ];
      }
      s[0] = 0;
      for (let l = 1; l <= a; ++l) {
        const u = t[l] - t[l - 1];
        let c = 0;
        this.nGramWidths.forEach((h) => {
          c += this.getNumNGrams(u, h);
        }), this.preserveShort && u > 0 && c === 0 && (c = 1), s[l] = s[l - 1] + c;
      }
      const o = new Array(s[a]);
      for (let l = 0; l < a; ++l) {
        const u = t[l];
        let c = s[l];
        if (this.nGramWidths.forEach((h) => {
          const d = t[l + 1] - t[l], f = this.getNumNGrams(d, h);
          this.createNGrams(e, u, o, c, f, h), c += f;
        }), this.preserveShort && c === s[l]) {
          const h = t[l + 1] - t[l];
          if (h === 0) continue;
          const d = h + 2 * this.padWidth;
          this.createNGrams(e, u, o, c, 1, d);
        }
      }
      return [
        o,
        s
      ];
    }
  }
  function yL(n, e, t, r, i, a, s, o) {
    return new BOe(t, r, i, a, s, o).compute(n, e);
  }
  function zOe(n, e, t, r) {
    if (!n.length) return;
    if (e.length === 0) {
      for (let a = 0; a < n.length; ++a) r.push(n.subarray(a, a + 1));
      return;
    }
    if (e.length === 1) {
      const a = e[0];
      let s = n.indexOf(a);
      for (; s !== -1; ) {
        const o = n.subarray(0, s);
        (!t || o.length !== 0) && r.push(o), n = n.subarray(s + 1), s = n.indexOf(a);
      }
      (!t || n.length !== 0) && r.push(n);
      return;
    }
    let i = 0;
    for (let a = 0; a < n.length + 1; a++) if (a === n.length || e.indexOf(n[a]) !== -1) {
      const s = n.subarray(i, a);
      (!t || s.length !== 0) && r.push(s), i = a + 1;
    }
  }
  function xL(n, e, t) {
    const r = n.length, i = [];
    let a = 0, s = 0;
    const o = new Array(r);
    for (let d = 0; d < r; ++d) {
      const f = i.length;
      zOe(n[d], e, t, i);
      const p = i.length - f;
      o[d] = p, a += p, s = Math.max(s, p);
    }
    const l = ir("int32", a * 2), u = new Array(a), c = [
      r,
      s
    ];
    let h = 0;
    for (let d = 0; d < r; ++d) for (let f = 0; f < o[d]; ++f) l[h * 2] = d, l[h * 2 + 1] = f, u[h] = i[h], ++h;
    return [
      l,
      u,
      c
    ];
  }
  function bL(n, e) {
    const t = ir("int32", n.length);
    for (let r = 0; r < n.length; ++r) t[r] = bAe(n[r]).modulo(e).getLowBitsUnsigned();
    return t;
  }
  const Cee = pr((n, e) => n - e), VOe = hL((n, e, t, r) => ({
    real: n - t,
    imag: e - r
  })), wL = Lr(rp, Cee, VOe), WOe = {
    kernelName: rp,
    backendName: "cpu",
    kernelFunc: wL
  };
  function Iee(n, e) {
    const t = new Array(n.rank);
    for (let i = 0; i < t.length; i++) t[i] = n.shape[i] * e[i];
    const r = Nt(t, n.dtype);
    for (let i = 0; i < r.values.length; ++i) {
      const a = r.indexToLoc(i), s = new Array(n.rank);
      for (let l = 0; l < s.length; l++) s[l] = a[l] % n.shape[l];
      const o = n.locToIndex(s);
      r.values[i] = n.values[o];
    }
    return r;
  }
  const Hy = (n, e) => {
    const t = e.value - n.value;
    return t === 0 ? n.index - e.index : t;
  };
  function kee(n, e, t = 0, r = n.length - 1) {
    for (; r > t; ) {
      if (r - t > 600) {
        const o = r - t + 1, l = e - t + 1, u = Math.log(o), c = 0.5 * Math.exp(2 * u / 3), h = 0.5 * Math.sqrt(u * c * (o - c) / o) * Math.sign(l - o / 2), d = Math.max(t, Math.floor(e - l * c / o + h)), f = Math.min(r, Math.floor(e + (o - l) * c / o + h));
        kee(n, e, d, f);
      }
      const i = n[e];
      let a = t, s = r;
      for (lg(n, t, e), Hy(n[r], i) > 0 && lg(n, t, r); a < s; ) {
        for (lg(n, a, s), a++, s--; Hy(n[a], i) < 0; ) a = a + 1;
        for (; Hy(n[s], i) > 0; ) s = s - 1;
      }
      Hy(n[t], i) === 0 ? lg(n, t, s) : (s = s + 1, lg(n, s, r)), s <= e && (t = s + 1), e <= s && (r = s - 1);
    }
  }
  function Tee(n, e, t, r, i) {
    const a = e[e.length - 1], [s, o] = [
      n.length / a,
      a
    ], l = Yr(t, s * r), u = Yr("int32", s * r);
    for (let h = 0; h < s; h++) {
      const d = h * o, f = n.subarray(d, d + o);
      let p = new Array(f.length);
      f.forEach((y, x) => p[x] = {
        value: y,
        index: x
      }), r < p.length && (kee(p, r), p = p.slice(0, r)), i && p.sort(Hy);
      const g = h * r, m = l.subarray(g, g + r), v = u.subarray(g, g + r);
      for (let y = 0; y < r; y++) m[y] = p[y].value, v[y] = p[y].index;
    }
    const c = e.slice();
    return c[c.length - 1] = r, [
      Nt(c, t, l),
      Nt(c, "int32", u)
    ];
  }
  function _L(n, e, t, r) {
    const i = yt(e, t)[0], a = [
      1,
      t[0],
      1
    ];
    for (let p = 0; p < i; p++) a[0] *= t[p];
    a[1] = t[i];
    for (let p = i + 1; p < t.length; p++) a[2] *= t[p];
    const s = /* @__PURE__ */ new Map(), o = new Int32Array(t[i]), l = new ii(a, r, n), u = [], c = a[0] === 1 && a[2] === 1;
    for (let p = 0; p < t[i]; p++) {
      let g;
      if (c) g = n[p].toString();
      else {
        const v = [];
        for (let y = 0; y < a[0]; y++) for (let x = 0; x < a[2]; x++) v.push(l.get(y, p, x));
        g = v.join(",");
      }
      const m = s.get(g);
      if (m != null) o[p] = m;
      else {
        const v = s.size;
        s.set(g, v), o[p] = v, u.push(p);
      }
    }
    const h = a.slice();
    h[1] = s.size;
    const d = new ii(h, r);
    u.forEach((p, g) => {
      for (let m = 0; m < a[0]; m++) for (let v = 0; v < a[2]; v++) d.set(l.get(m, p, v), m, g, v);
    });
    const f = t.slice();
    return f[i] = h[1], {
      outputValues: d.values,
      outputShape: f,
      indices: o
    };
  }
  const Aee = Object.freeze(Object.defineProperty({
    __proto__: null,
    addImpl: GJ,
    bincountImpl: dL,
    bincountReduceImpl: UJ,
    bitwiseAndImpl: HJ,
    castImpl: WJ,
    ceilImpl: XJ,
    concatImpl: fL,
    equalImpl: YJ,
    expImpl: jJ,
    expm1Impl: ZJ,
    floorDivImpl: JJ,
    floorImpl: QJ,
    gatherNdImpl: eee,
    gatherV2Impl: tee,
    greaterEqualImpl: ree,
    greaterImpl: nee,
    lessEqualImpl: aee,
    lessImpl: iee,
    linSpaceImpl: see,
    logImpl: oee,
    maxImpl: lee,
    maximumImpl: uee,
    minimumImpl: cee,
    multiplyImpl: pL,
    negImpl: hee,
    notEqualImpl: dee,
    prodImpl: fee,
    raggedGatherImpl: pee,
    raggedRangeImpl: gee,
    raggedTensorToTensorImpl: mee,
    rangeImpl: mL,
    rsqrtImpl: vee,
    scatterImpl: Uh,
    sigmoidImpl: DOe,
    simpleAbsImpl: VJ,
    sliceImpl: XS,
    sparseFillEmptyRowsImpl: xee,
    sparseReshapeImpl: bee,
    sparseSegmentReductionImpl: vL,
    sqrtImpl: NOe,
    squaredDifferenceImpl: wee,
    staticRegexReplaceImpl: _ee,
    stridedSliceImpl: See,
    stringNGramsImpl: yL,
    stringSplitImpl: xL,
    stringToHashBucketFastImpl: bL,
    subImpl: Cee,
    tileImpl: Iee,
    topKImpl: Tee,
    transposeImpl: gL,
    uniqueImpl: _L
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  _I("cpu", () => new n2(), 1);
  const Dee = An(uf, (n) => n >= 0 ? n : Math.exp(n) - 1), GOe = {
    kernelName: uf,
    backendName: "cpu",
    kernelFunc: Dee
  };
  function Ree(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { alpha: a } = r;
    et([
      i
    ], "leakyRelu");
    const s = X(i.shape), o = t.data.get(i.dataId).values, l = Yr("float32", s);
    for (let u = 0; u < o.length; u++) l[u] = o[u] < 0 ? a * o[u] : o[u];
    return t.makeTensorInfo(i.shape, "float32", l);
  }
  const UOe = {
    kernelName: wf,
    backendName: "cpu",
    kernelFunc: Ree
  };
  const HOe = pr((n, e) => n < 0 ? e * n : n);
  function $ee(n) {
    const { inputs: e, backend: t } = n, { x: r, alpha: i } = e;
    et([
      r,
      i
    ], "prelu");
    const a = t.data.get(r.dataId).values, s = t.data.get(i.dataId).values, [o, l] = HOe(r.shape, i.shape, a, s, "float32");
    return t.makeTensorInfo(l, "float32", o);
  }
  const XOe = {
    kernelName: Ff,
    backendName: "cpu",
    kernelFunc: $ee
  };
  const Nee = An(zf, (n) => Math.max(0, n)), YOe = {
    kernelName: zf,
    backendName: "cpu",
    kernelFunc: Nee
  };
  const Eee = An(Gf, (n) => Math.min(Math.max(0, n), 6)), qOe = {
    kernelName: Gf,
    backendName: "cpu",
    kernelFunc: Eee
  };
  function YS(n, e, t, r, i) {
    if (t === "linear") return ol({
      inputs: {
        x: e
      },
      backend: n
    });
    if (t === "relu") return Nee({
      inputs: {
        x: e
      },
      backend: n
    });
    if (t === "elu") return Dee({
      inputs: {
        x: e
      },
      backend: n
    });
    if (t === "relu6") return Eee({
      inputs: {
        x: e
      },
      backend: n
    });
    if (t === "prelu") return $ee({
      inputs: {
        x: e,
        alpha: r
      },
      backend: n
    });
    if (t === "leakyrelu") return Ree({
      inputs: {
        x: e
      },
      backend: n,
      attrs: {
        alpha: i
      }
    });
    if (t === "sigmoid") return yee({
      inputs: {
        x: e
      },
      backend: n
    });
    throw new Error(`Activation ${t} has not been implemented for the CPU backend.`);
  }
  function Hn(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { shape: a } = r, s = X(i.shape), o = QC(a, s), l = X(o);
    B(s === l, () => `The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`), t.incRef(i.dataId);
    const u = t.data.get(i.dataId);
    if (u.complexTensorInfos != null) {
      const c = u.complexTensorInfos.real, h = u.complexTensorInfos.imag;
      c.shape = o, h.shape = o;
    }
    return {
      dataId: i.dataId,
      shape: o,
      dtype: i.dtype
    };
  }
  const jOe = {
    kernelName: uv,
    backendName: "cpu",
    kernelFunc: Hn
  };
  function Mee(n) {
    const { inputs: e, backend: t, attrs: r } = n, { a: i, b: a } = e, { transposeA: s, transposeB: o } = r;
    et([
      i,
      a
    ], "matMul");
    const l = i.shape.length, u = a.shape.length, c = s ? i.shape[l - 2] : i.shape[l - 1], h = o ? a.shape[u - 1] : a.shape[u - 2], d = s ? i.shape[l - 1] : i.shape[l - 2], f = o ? a.shape[u - 2] : a.shape[u - 1], p = i.shape.slice(0, -2), g = a.shape.slice(0, -2), m = X(p), v = X(g), x = ht(i.shape.slice(0, -2), a.shape.slice(0, -2)).concat([
      d,
      f
    ]);
    B(c === h, () => `Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${s} and transposeB=${o} must match.`);
    const b = s ? [
      m,
      c,
      d
    ] : [
      m,
      d,
      c
    ], w = o ? [
      v,
      f,
      h
    ] : [
      v,
      h,
      f
    ], _ = Hn({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: b
      }
    }), S = Hn({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: w
      }
    }), I = s ? _.shape[1] : _.shape[2], C = s ? _.shape[2] : _.shape[1], T = o ? S.shape[1] : S.shape[2], k = Math.max(m, v), D = t.data.get(_.dataId).values, R = t.data.get(S.dataId).values, N = Be(_.shape), E = Be(S.shape), [A, M, $] = s ? [
      N[0],
      1,
      N[1]
    ] : [
      N[0],
      N[1],
      1
    ], [L, F, O] = o ? [
      1,
      E[1],
      E[0]
    ] : [
      E[1],
      1,
      E[0]
    ], z = C * T, V = Nt([
      k,
      C,
      T
    ], _.dtype), H = V.values, Y = t.blockSize;
    for (let le = 0; le < k; le++) {
      const ve = le % m, re = le % v;
      for (let ae = 0; ae < C; ae += Y) {
        const fe = Math.min(ae + Y, C);
        for (let ce = 0; ce < T; ce += Y) {
          const ye = Math.min(ce + Y, T);
          for (let Le = 0; Le < I; Le += Y) {
            const Re = Math.min(Le + Y, I);
            for (let be = ae; be < fe; be++) for (let xe = ce; xe < ye; xe++) {
              let ot = 0;
              for (let G = Le; G < Re; G++) {
                const q = D[ve * A + be * M + G * $], ge = R[G * L + xe * F + re * O];
                ot += q * ge;
              }
              H[le * z + (be * T + xe)] += ot;
            }
          }
        }
      }
    }
    return t.disposeIntermediateTensorInfo(_), t.disposeIntermediateTensorInfo(S), t.makeTensorInfo(x, V.dtype, V.values);
  }
  const KOe = {
    kernelName: Kd,
    backendName: "cpu",
    kernelFunc: Mee
  };
  function ZOe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { a: i, b: a, bias: s, preluActivationWeights: o } = e, { transposeA: l, transposeB: u, activation: c, leakyreluAlpha: h } = r;
    let d, f, p;
    const g = [];
    d = Mee({
      inputs: {
        a: i,
        b: a
      },
      attrs: {
        transposeA: l,
        transposeB: u
      },
      backend: t
    }), s && (f = Qg({
      inputs: {
        a: d,
        b: s
      },
      backend: t
    }), g.push(d), d = f), c && (p = YS(t, d, c, o, h), g.push(d), d = p);
    for (const v of g) t.disposeIntermediateTensorInfo(v);
    return d;
  }
  const QOe = {
    kernelName: vd,
    backendName: "cpu",
    kernelFunc: ZOe
  };
  const JOe = An(Wd, (n) => Math.acos(n)), eBe = {
    kernelName: Wd,
    backendName: "cpu",
    kernelFunc: JOe
  };
  const tBe = An(Gd, (n) => Math.acosh(n)), nBe = {
    kernelName: Gd,
    backendName: "cpu",
    kernelFunc: tBe
  };
  function rBe(n) {
    const { inputs: e, backend: t } = n, r = e;
    et(e, "addN");
    const i = r.map((o) => t.data.get(o.dataId).values), a = Nt(r[0].shape, r[0].dtype), s = a.values;
    for (let o = 0; o < r.length; o++) {
      const l = i[o];
      for (let u = 0; u < s.length; u++) s[u] += l[u];
    }
    return t.makeTensorInfo(a.shape, a.dtype, a.values);
  }
  const iBe = {
    kernelName: Rm,
    backendName: "cpu",
    kernelFunc: rBe
  };
  function aBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    et(i, "all");
    const o = yt(a, i.shape);
    let l = o;
    const u = bn(l, i.shape.length);
    let c = i;
    u != null && (c = sa({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), l = gn(l.length, i.shape.length)), Tn("all", l, c.shape.length);
    const [h, d] = Ln(c.shape, l), f = X(d), p = si(X(h), c.dtype), g = t.data.get(c.dataId).values;
    for (let v = 0; v < p.length; ++v) {
      const y = v * f;
      let x = g[y];
      for (let b = 0; b < f; ++b) {
        const w = g[y + b];
        x = x && w;
      }
      p[v] = x;
    }
    u != null && t.disposeIntermediateTensorInfo(c);
    const m = t.makeTensorInfo(h, c.dtype, p);
    if (s) {
      const v = Mn(h, o), y = Hn({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: v
        }
      });
      return t.disposeIntermediateTensorInfo(m), y;
    }
    return m;
  }
  const sBe = {
    kernelName: $m,
    backendName: "cpu",
    kernelFunc: aBe
  };
  function oBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    et(i, "any");
    const o = yt(a, i.shape);
    let l = o;
    const u = bn(l, i.shape.length);
    let c = i;
    u != null && (c = sa({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), l = gn(l.length, i.shape.length)), Tn("any", l, c.shape.length);
    const [h, d] = Ln(c.shape, l), f = X(d), p = si(X(h), c.dtype), g = t.data.get(c.dataId).values;
    for (let v = 0; v < p.length; ++v) {
      const y = v * f;
      let x = g[y];
      for (let b = 0; b < f; ++b) {
        const w = g[y + b];
        x = x || w;
      }
      p[v] = x;
    }
    u != null && t.disposeIntermediateTensorInfo(c);
    const m = t.makeTensorInfo(h, c.dtype, p);
    if (s) {
      const v = Mn(h, o), y = Hn({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: v
        }
      });
      return t.disposeIntermediateTensorInfo(m), y;
    }
    return m;
  }
  const lBe = {
    kernelName: Nm,
    backendName: "cpu",
    kernelFunc: oBe
  };
  function uBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a } = r;
    et(i, "argMax");
    let s = yt(a, i.shape);
    const o = bn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = sa({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: o
      }
    }), u.push(l), s = gn(s.length, l.shape.length)), s = [
      s[0]
    ], Tn("argMax", s, l.shape.length);
    const [c, h] = Ln(l.shape, s), d = X(c), f = si(d, "int32"), p = X(h), g = t.data.get(l.dataId).values;
    for (let m = 0; m < f.length; ++m) {
      const v = m * p;
      let y = g[v], x = 0;
      for (let b = 0; b < p; ++b) {
        const w = g[v + b];
        w > y && (y = w, x = b);
      }
      f[m] = x;
    }
    return u.forEach((m) => t.disposeIntermediateTensorInfo(m)), t.makeTensorInfo(c, "int32", f);
  }
  const cBe = {
    kernelName: Em,
    backendName: "cpu",
    kernelFunc: uBe
  };
  function hBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a } = r;
    et(i, "argMin");
    let s = yt(a, i.shape);
    const o = bn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = sa({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: o
      }
    }), u.push(l), s = gn(s.length, l.shape.length)), s = [
      s[0]
    ], Tn("argMin", s, l.shape.length);
    const [c, h] = Ln(l.shape, s), d = X(c), f = si(d, "int32"), p = X(h), g = t.data.get(l.dataId).values;
    for (let m = 0; m < f.length; ++m) {
      const v = m * p;
      let y = g[v], x = 0;
      for (let b = 0; b < p; ++b) {
        const w = g[v + b];
        w < y && (y = w, x = b);
      }
      f[m] = x;
    }
    return u.forEach((m) => t.disposeIntermediateTensorInfo(m)), t.makeTensorInfo(c, "int32", f);
  }
  const dBe = {
    kernelName: Mm,
    backendName: "cpu",
    kernelFunc: hBe
  };
  const fBe = An(Ud, (n) => Math.asin(n)), pBe = {
    kernelName: Ud,
    backendName: "cpu",
    kernelFunc: fBe
  };
  const gBe = An(Hd, (n) => Math.asinh(n)), mBe = {
    kernelName: Hd,
    backendName: "cpu",
    kernelFunc: gBe
  };
  const vBe = An(Xd, (n) => Math.atan(n)), yBe = {
    kernelName: Xd,
    backendName: "cpu",
    kernelFunc: vBe
  };
  const xBe = pr((n, e) => Math.atan2(n, e)), bBe = Lr(qd, xBe), wBe = {
    kernelName: qd,
    backendName: "cpu",
    kernelFunc: bBe
  };
  const _Be = An(Yd, (n) => Math.atanh(n)), SBe = {
    kernelName: Yd,
    backendName: "cpu",
    kernelFunc: _Be
  };
  function SL(n, e, t, r, i, a) {
    const s = i.strideHeight, o = i.strideWidth, l = i.dilationHeight, u = i.dilationWidth, c = i.effectiveFilterHeight, h = i.effectiveFilterWidth, d = i.padInfo.top, f = i.padInfo.left, p = a === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, g = Nt(i.outShape, t), m = g.values, v = i.outShape[1] * i.outShape[2] * i.outShape[3], y = i.outShape[2] * i.outShape[3], x = i.outShape[3];
    for (let b = 0; b < i.batchSize; ++b) {
      const w = b * v, _ = b * r[0];
      for (let S = 0; S < i.inChannels; ++S) for (let I = 0; I < i.outHeight; ++I) {
        const C = I * s - d, T = Math.max(0, C), k = Math.min(i.inHeight, c + C), D = w + I * y;
        for (let R = 0; R < i.outWidth; ++R) {
          const N = R * o - f, E = Math.max(0, N), A = Math.min(i.inWidth, h + N);
          let M = p, $ = 0, L = 0;
          for (let O = T; O < k; O += l) {
            const z = _ + O * r[1];
            for (let V = E; V < A; V += u) {
              const H = z + V * r[2], Y = n[H + S];
              a === "max" && Y > M ? M = Y : a === "avg" && ($ += Y, L++);
            }
            if (isNaN(M)) break;
          }
          const F = D + R * x + S;
          m[F] = a === "avg" ? $ / L : M;
        }
      }
    }
    return g;
  }
  function Pee(n, e, t, r, i = false, a = false) {
    const s = Nt(r.outShape, "int32"), o = r.strideHeight, l = r.strideWidth, u = r.dilationHeight, c = r.dilationWidth, h = r.effectiveFilterHeight, d = r.effectiveFilterWidth, f = r.padInfo.top, p = r.padInfo.left, g = Nt(e, t, n);
    for (let m = 0; m < r.batchSize; ++m) for (let v = 0; v < r.inChannels; ++v) for (let y = 0; y < r.outHeight; ++y) {
      const x = y * o - f;
      let b = x;
      for (; b < 0; ) b += u;
      const w = Math.min(r.inHeight, h + x);
      for (let _ = 0; _ < r.outWidth; ++_) {
        const S = _ * l - p;
        let I = S;
        for (; I < 0; ) I += c;
        const C = Math.min(r.inWidth, d + S);
        let T = Number.NEGATIVE_INFINITY, k = -1;
        for (let D = b; D < w; D += u) {
          const R = D - x;
          for (let N = I; N < C; N += c) {
            const E = N - S, A = g.get(m, D, N, v);
            A > T && (T = A, i ? k = a ? ((m * r.inHeight + D) * r.inWidth + N) * r.inChannels + v : (D * r.inWidth + N) * r.inChannels + v : k = R * d + E);
          }
        }
        s.set(k, m, y, _, v);
      }
    }
    return s;
  }
  function Lee(n, e, t, r, i, a) {
    const s = i.strideDepth, o = i.strideHeight, l = i.strideWidth, u = i.dilationDepth, c = i.dilationHeight, h = i.dilationWidth, d = i.effectiveFilterDepth, f = i.effectiveFilterHeight, p = i.effectiveFilterWidth, g = i.padInfo.front, m = i.padInfo.top, v = i.padInfo.left, y = a === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, x = Nt(i.outShape, t), b = x.values, w = i.outShape[1] * i.outShape[2] * i.outShape[3] * i.outShape[4], _ = i.outShape[2] * i.outShape[3] * i.outShape[4], S = i.outShape[3] * i.outShape[4], I = i.outShape[4];
    for (let C = 0; C < i.batchSize; ++C) {
      const T = C * w, k = C * r[0];
      for (let D = 0; D < i.inChannels; ++D) for (let R = 0; R < i.outDepth; ++R) {
        const N = R * s - g;
        let E = N;
        for (; E < 0; ) E += u;
        const A = Math.min(i.inDepth, d + N), M = T + R * _;
        for (let $ = 0; $ < i.outHeight; ++$) {
          const L = $ * o - m;
          let F = L;
          for (; F < 0; ) F += c;
          const O = Math.min(i.inHeight, f + L), z = M + $ * S;
          for (let V = 0; V < i.outWidth; ++V) {
            const H = V * l - v;
            let Y = H;
            for (; Y < 0; ) Y += h;
            const le = Math.min(i.inWidth, p + H), ve = z + V * I;
            let re = y, ae = 0, fe = 0;
            for (let ye = E; ye < A; ye += u) {
              const Le = k + ye * r[1];
              for (let Re = F; Re < O; Re += c) {
                const be = Le + Re * r[2];
                for (let xe = Y; xe < le; xe += h) {
                  const ot = be + xe * r[3], G = n[ot + D];
                  if (a === "max" && G > re ? re = G : a === "avg" && (ae += G, fe++), isNaN(re)) break;
                }
                if (isNaN(re)) break;
              }
              if (isNaN(re)) break;
            }
            const ce = ve + D;
            b[ce] = a === "avg" ? ae / Math.max(fe, 1) : re;
          }
        }
      }
    }
    return x;
  }
  function CBe(n, e) {
    const t = Nt(e.outShape, "int32"), r = e.strideDepth, i = e.strideHeight, a = e.strideWidth, s = e.dilationDepth, o = e.dilationHeight, l = e.dilationWidth, u = e.effectiveFilterDepth, c = e.effectiveFilterHeight, h = e.effectiveFilterWidth, d = e.padInfo.front, f = e.padInfo.top, p = e.padInfo.left;
    for (let g = 0; g < e.batchSize; ++g) for (let m = 0; m < e.inChannels; ++m) for (let v = 0; v < e.outDepth; ++v) {
      const y = v * r - d;
      let x = y;
      for (; x < 0; ) x += s;
      const b = Math.min(e.inDepth, u + y);
      for (let w = 0; w < e.outHeight; ++w) {
        const _ = w * i - f;
        let S = _;
        for (; S < 0; ) S += o;
        const I = Math.min(e.inHeight, c + _);
        for (let C = 0; C < e.outWidth; ++C) {
          const T = C * a - p;
          let k = T;
          for (; k < 0; ) k += l;
          const D = Math.min(e.inWidth, h + T);
          let R = Number.NEGATIVE_INFINITY, N = -1;
          for (let E = x; E < b; E += s) {
            const A = E - y;
            for (let M = S; M < I; M += o) {
              const $ = M - _;
              for (let L = k; L < D; L += l) {
                const F = L - T, O = n.get(g, E, M, L, m);
                O >= R && (R = O, N = A * c * h + $ * c + F);
              }
            }
          }
          t.set(N, g, v, w, C, m);
        }
      }
    }
    return t;
  }
  function IBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e;
    et(i, "avgPool");
    const { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, u = 1;
    B(Pr(s, u), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = dr(i.shape, a, s, u, o, l);
    let h;
    if (c.filterWidth === 1 && c.filterHeight === 1 && Jt(c.inShape, c.outShape)) h = ol({
      inputs: {
        x: i
      },
      backend: t
    });
    else {
      const d = t.data.get(i.dataId).values, f = Be(i.shape), p = SL(d, i.shape, i.dtype, f, c, "avg");
      h = t.makeTensorInfo(c.outShape, i.dtype, p.values);
    }
    return h;
  }
  const kBe = {
    kernelName: jd,
    backendName: "cpu",
    kernelFunc: IBe
  };
  function TBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dimRoundingMode: l, dataFormat: u } = r;
    et(i, "avgPool3d");
    const c = vi(i.shape, a, s, 1, o, l, u), h = t.data.get(i.dataId).values, d = Lee(h, i.shape, i.dtype, Be(i.shape), c, "avg");
    return t.makeTensorInfo(d.shape, "float32", d.values);
  }
  const ABe = {
    kernelName: Pm,
    backendName: "cpu",
    kernelFunc: TBe
  };
  function DBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = r;
    et([
      i,
      a
    ], "avgPool3DGrad");
    const c = vi(a.shape, s, o, 1, l, u), h = c.strideDepth, d = c.strideHeight, f = c.strideWidth, p = c.filterDepth, g = c.filterHeight, m = c.filterWidth, v = c.dilationDepth, y = c.dilationHeight, x = c.dilationWidth, b = c.effectiveFilterDepth, w = c.effectiveFilterHeight, _ = c.effectiveFilterWidth, S = b - 1 - c.padInfo.front, I = _ - 1 - c.padInfo.left, C = w - 1 - c.padInfo.top, T = Nt(a.shape, "float32"), k = 1 / (p * g * m), D = t.bufferSync(i);
    for (let R = 0; R < c.batchSize; ++R) for (let N = 0; N < c.inChannels; ++N) for (let E = 0; E < c.inDepth; ++E) for (let A = 0; A < c.inHeight; ++A) for (let M = 0; M < c.inWidth; ++M) {
      const $ = E - S, L = A - C, F = M - I;
      let O = 0;
      for (let z = 0; z < b; z += v) {
        const V = ($ + z) / h;
        if (!(V < 0 || V >= c.outDepth || Math.floor(V) !== V)) for (let H = 0; H < w; H += y) {
          const Y = (L + H) / d;
          if (!(Y < 0 || Y >= c.outHeight || Math.floor(Y) !== Y)) for (let le = 0; le < _; le += x) {
            const ve = (F + le) / f;
            if (ve < 0 || ve >= c.outWidth || Math.floor(ve) !== ve) continue;
            const re = D.get(R, V, Y, ve, N);
            O += re;
          }
        }
      }
      T.set(O * k, R, E, A, M, N);
    }
    return t.makeTensorInfo(T.shape, T.dtype, T.values);
  }
  const RBe = {
    kernelName: eb,
    backendName: "cpu",
    kernelFunc: DBe
  };
  function $Be(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, s = a;
    et([
      i,
      a
    ], "avgPoolGrad");
    const { filterSize: o, strides: l, pad: u } = r, c = dr(s.shape, o, l, 1, u), h = c.strideHeight, d = c.strideWidth, f = c.filterHeight, p = c.filterWidth, g = c.dilationHeight, m = c.dilationWidth, v = c.effectiveFilterHeight, y = c.effectiveFilterWidth, x = y - 1 - c.padInfo.left, b = v - 1 - c.padInfo.top, w = Nt(s.shape, "float32"), _ = 1 / (f * p), S = t.data.get(i.dataId).values, I = Nt(i.shape, "float32", S);
    for (let C = 0; C < c.batchSize; ++C) for (let T = 0; T < c.inChannels; ++T) for (let k = 0; k < c.inHeight; ++k) for (let D = 0; D < c.inWidth; ++D) {
      const R = k - b, N = D - x;
      let E = 0;
      for (let A = 0; A < v; A += g) {
        const M = (R + A) / h;
        if (!(M < 0 || M >= c.outHeight || Math.floor(M) !== M)) for (let $ = 0; $ < y; $ += m) {
          const L = (N + $) / d;
          if (L < 0 || L >= c.outWidth || Math.floor(L) !== L) continue;
          const F = I.get(C, M, L, T);
          E += F;
        }
      }
      w.set(E * _, C, k, D, T);
    }
    return t.makeTensorInfo(w.shape, w.dtype, w.values);
  }
  const NBe = {
    kernelName: Jx,
    backendName: "cpu",
    kernelFunc: $Be
  };
  function EBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, scale: a, offset: s, mean: o, variance: l } = e;
    B(o.shape.length === l.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), B(s == null || o.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), B(a == null || o.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), et([
      i,
      o,
      l,
      a,
      s
    ], "batchNorm");
    let { varianceEpsilon: u } = r;
    u == null && (u = 1e-3);
    const c = t.data.get(i.dataId).values, h = t.data.get(o.dataId).values, d = t.data.get(l.dataId).values, f = a ? t.data.get(a.dataId).values : new Float32Array([
      1
    ]), p = s ? t.data.get(s.dataId).values : new Float32Array([
      0
    ]), g = new Float32Array(c.length), m = p.length, v = f.length, y = d.length, x = h.length;
    let b = 0, w = 0, _ = 0, S = 0;
    for (let I = 0; I < c.length; ++I) g[I] = p[b++] + (c[I] - h[w++]) * f[_++] / Math.sqrt(d[S++] + u), b >= m && (b = 0), w >= x && (w = 0), _ >= v && (_ = 0), S >= y && (S = 0);
    return t.makeTensorInfo(i.shape, i.dtype, g);
  }
  const MBe = {
    kernelName: gf,
    backendName: "cpu",
    kernelFunc: EBe
  };
  function PBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockShape: a, crops: s } = r;
    et([
      i
    ], "batchToSpaceND");
    const o = a.reduce((v, y) => v * y), l = ou(i.shape, a, o), u = lu(l.length, a.length), c = uu(i.shape, a, o), h = Tb(s, a.length), d = Ab(c, s, a.length), f = Hn({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), p = sa({
      inputs: {
        x: f
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), g = Hn({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), m = Dd({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        begin: h,
        size: d
      }
    });
    return t.disposeIntermediateTensorInfo(f), t.disposeIntermediateTensorInfo(p), t.disposeIntermediateTensorInfo(g), m;
  }
  const LBe = {
    kernelName: Lm,
    backendName: "cpu",
    kernelFunc: PBe
  };
  function FBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, weights: a } = e, { size: s } = r, o = t.data.get(i.dataId).values, l = t.data.get(a.dataId).values, u = dL(o, l, a.dtype, a.shape, s);
    return t.makeTensorInfo([
      s
    ], a.dtype, u);
  }
  const OBe = {
    kernelName: Fm,
    backendName: "cpu",
    kernelFunc: FBe
  };
  function BBe(n) {
    const { inputs: e, backend: t } = n, { s0: r, s1: i } = e, a = t.data.get(r.dataId).values, s = t.data.get(i.dataId).values, o = ht(Array.from(a), Array.from(s));
    return t.makeTensorInfo([
      o.length
    ], "int32", Int32Array.from(o));
  }
  const zBe = {
    kernelName: eI,
    backendName: "cpu",
    kernelFunc: BBe
  };
  const VBe = An(bc, (n, e) => {
    const t = e;
    return n > t.clipValueMax ? t.clipValueMax : n < t.clipValueMin ? t.clipValueMin : n;
  }), WBe = {
    kernelName: bc,
    backendName: "cpu",
    kernelFunc: VBe
  };
  const GBe = (n) => {
    const { x: e } = n.inputs, t = n.backend, r = new Float32Array(X(e.shape)), i = t.data.get(e.dataId), a = i.complexTensorInfos.real, s = i.complexTensorInfos.imag, o = t.data.get(a.dataId).values, l = t.data.get(s.dataId).values;
    for (let u = 0; u < o.length; u++) {
      const c = o[u], h = l[u];
      r[u] = Math.hypot(c, h);
    }
    return t.makeOutput(r, e.shape, "float32");
  }, UBe = {
    kernelName: tb,
    backendName: "cpu",
    kernelFunc: GBe
  };
  function Jg(n) {
    const { inputs: e, backend: t } = n, { input: r } = e, i = t.data.get(r.dataId).complexTensorInfos.imag, a = t.data.get(i.dataId).values;
    return t.makeTensorInfo(i.shape, i.dtype, a);
  }
  const HBe = {
    kernelName: uI,
    backendName: "cpu",
    kernelFunc: Jg
  };
  function em(n) {
    const { inputs: e, backend: t, attrs: r } = n, { axis: i } = r, a = yt(i, e[0].shape)[0], s = e.map((g) => g.shape);
    Ib(s, a);
    let o = ai(e.map((g) => g.shape), a);
    if (X(o) === 0) return t.makeTensorInfo(o, e[0].dtype, []);
    const l = e.filter((g) => X(g.shape) > 0);
    if (l.length === 1) return ol({
      inputs: {
        x: l[0]
      },
      backend: t
    });
    if (l[0].dtype === "complex64") {
      const g = l.map((b) => Ad({
        inputs: {
          input: b
        },
        backend: t
      })), m = l.map((b) => Jg({
        inputs: {
          input: b
        },
        backend: t
      })), v = em({
        inputs: g,
        backend: t,
        attrs: {
          axis: a
        }
      }), y = em({
        inputs: m,
        backend: t,
        attrs: {
          axis: a
        }
      }), x = wa({
        inputs: {
          real: v,
          imag: y
        },
        backend: t
      });
      return g.forEach((b) => t.disposeIntermediateTensorInfo(b)), m.forEach((b) => t.disposeIntermediateTensorInfo(b)), t.disposeIntermediateTensorInfo(v), t.disposeIntermediateTensorInfo(y), x;
    }
    const u = l.map((g) => {
      const v = [
        -1,
        X(g.shape.slice(a))
      ];
      return Hn({
        inputs: {
          x: g
        },
        backend: t,
        attrs: {
          shape: v
        }
      });
    }), c = u.map((g) => ({
      vals: t.data.get(g.dataId).values,
      shape: g.shape
    }));
    o = ai(u.map((g) => g.shape), 1);
    const h = u[0].shape[0] === 1, d = fL(c, o, e[0].dtype, h), f = ai(l.map((g) => g.shape), a), p = t.makeTensorInfo(f, e[0].dtype, d);
    return u.forEach((g) => t.disposeIntermediateTensorInfo(g)), p;
  }
  const XBe = {
    kernelName: Om,
    backendName: "cpu",
    kernelFunc: em
  };
  function Fee(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dataFormat: l, dilations: u, dimRoundingMode: c } = r;
    et([
      i,
      a
    ], "conv2d");
    const h = Oi(l), d = Sn(i.shape, a.shape, s, u, o, c, false, h), f = d.filterHeight, p = d.filterWidth, g = d.dilationHeight, m = d.dilationWidth, v = d.padInfo.left, y = d.padInfo.top, x = d.dataFormat === "channelsLast", b = new ii(d.outShape, i.dtype), w = Be(i.shape), _ = Be(a.shape), S = w[0], I = x ? w[1] : w[2], C = x ? w[2] : 1, T = x ? 1 : w[1], k = b.strides[0], D = x ? b.strides[1] : b.strides[2], R = x ? b.strides[2] : 1, N = x ? 1 : b.strides[1], E = t.data.get(i.dataId).values, A = t.data.get(a.dataId).values, M = b.values;
    for (let $ = 0; $ < d.batchSize; ++$) {
      const L = $ * S, F = $ * k;
      for (let O = 0; O < d.outHeight; ++O) {
        const z = F + O * D, V = O * d.strideHeight - y;
        for (let H = 0; H < f; ++H) {
          const Y = V + H * g;
          if (Y < 0 || Y >= d.inHeight) continue;
          const le = H * _[0], ve = L + Y * I;
          for (let re = 0; re < d.outWidth; ++re) {
            const ae = z + re * R, fe = re * d.strideWidth - v;
            for (let ce = 0; ce < p; ++ce) {
              const ye = fe + ce * m;
              if (ye < 0 || ye >= d.inWidth) continue;
              const Le = le + ce * _[1], Re = ve + ye * C;
              let be = Le;
              for (let xe = 0; xe < d.inChannels; ++xe) {
                const ot = E[Re + xe * T];
                for (let G = 0; G < d.outChannels; ++G) M[ae + G * N] += ot * A[be + G];
                be += d.outChannels;
              }
            }
          }
        }
      }
    }
    return t.makeTensorInfo(b.shape, b.dtype, M);
  }
  const YBe = {
    kernelName: Jd,
    backendName: "cpu",
    kernelFunc: Fee
  };
  function qBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, pad: o, dataFormat: l, dimRoundingMode: u, filterShape: c } = r;
    et([
      i,
      a
    ], "conv2dBackpropFilter");
    const h = Oi(l), d = Sn(i.shape, c, s, 1, o, u, false, h), { strideHeight: f, strideWidth: p, filterHeight: g, filterWidth: m } = d, v = d.dataFormat === "channelsLast", y = new ii(d.filterShape, "float32"), x = d.padInfo.left, b = d.padInfo.top, w = t.data.get(i.dataId).values, _ = t.data.get(a.dataId).values, S = new ii(i.shape, i.dtype, w), I = new ii(a.shape, a.dtype, _);
    for (let C = 0; C < g; ++C) {
      const T = Math.max(0, Math.ceil((b - C) / f)), k = Math.min(d.outHeight, (d.inHeight + b - C) / f);
      for (let D = 0; D < m; ++D) {
        const R = Math.max(0, Math.ceil((x - D) / p)), N = Math.min(d.outWidth, (d.inWidth + x - D) / p);
        for (let E = 0; E < d.inChannels; ++E) for (let A = 0; A < d.outChannels; ++A) {
          let M = 0;
          for (let $ = 0; $ < d.batchSize; ++$) for (let L = T; L < k; ++L) {
            const F = C + L * f - b;
            for (let O = R; O < N; ++O) {
              const z = D + O * p - x;
              v ? M += S.get($, F, z, E) * I.get($, L, O, A) : M += S.get($, E, F, z) * I.get($, A, L, O);
            }
          }
          y.set(M, C, D, E, A);
        }
      }
    }
    return t.makeTensorInfo(y.shape, y.dtype, y.values);
  }
  const jBe = {
    kernelName: nI,
    backendName: "cpu",
    kernelFunc: qBe
  };
  function KBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { inputShape: s, strides: o, pad: l, dataFormat: u, dimRoundingMode: c } = r;
    et([
      i,
      a
    ], "conv2dBackpropInput");
    const h = Be(a.shape), d = Be(i.shape);
    let f = Oi(u);
    const p = Sn(s, a.shape, o, 1, l, c, false, f), g = new ii(p.inShape, "float32"), m = g.values, v = t.data.get(i.dataId).values, y = t.data.get(a.dataId).values, [x, b, w] = h, { batchSize: _, filterHeight: S, filterWidth: I, inChannels: C, inHeight: T, inWidth: k, outChannels: D, outHeight: R, outWidth: N, strideHeight: E, strideWidth: A } = p;
    f = p.dataFormat;
    const M = S - 1 - p.padInfo.top, $ = I - 1 - p.padInfo.left, L = f === "channelsLast", F = g.strides[0], O = L ? g.strides[1] : g.strides[2], z = L ? g.strides[2] : 1, V = L ? 1 : g.strides[1], H = d[0], Y = L ? d[1] : d[2], le = L ? d[2] : 1, ve = L ? 1 : d[1];
    for (let re = 0; re < _; ++re) for (let ae = 0; ae < C; ++ae) for (let fe = 0; fe < T; ++fe) {
      const ce = fe - M, ye = Math.max(0, Math.ceil(ce / E)), Le = Math.min(R, (S + ce) / E);
      for (let Re = 0; Re < k; ++Re) {
        const be = Re - $, xe = Math.max(0, Math.ceil(be / A)), ot = Math.min(N, (I + be) / A);
        let G = 0;
        for (let ge = ye; ge < Le; ++ge) {
          const Fe = ge * E - ce;
          for (let Lt = xe; Lt < ot; ++Lt) {
            const dt = Lt * A - be, ue = H * re + Y * ge + le * Lt, Se = x * (S - 1 - Fe) + b * (I - 1 - dt) + w * ae;
            for (let Ut = 0; Ut < D; ++Ut) {
              const Ht = v[ue + ve * Ut], Jn = y[Se + Ut];
              G += Ht * Jn;
            }
          }
        }
        const q = F * re + O * fe + z * Re + V * ae;
        m[q] = G;
      }
    }
    return t.makeTensorInfo(g.shape, g.dtype, g.values);
  }
  const ZBe = {
    kernelName: ef,
    backendName: "cpu",
    kernelFunc: KBe
  };
  function QBe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l } = r;
    et([
      i,
      a
    ], "conv3d");
    const u = Ra(i.shape, a.shape, s, l, o), { filterDepth: c, filterHeight: h, filterWidth: d, dilationDepth: f, dilationHeight: p, dilationWidth: g, padInfo: m } = u, v = m.front, y = m.left, x = m.top, b = new ii(u.outShape, i.dtype), w = t.data.get(i.dataId).values, _ = t.data.get(a.dataId).values, S = b.values, I = Be(i.shape), C = Be(a.shape);
    for (let T = 0; T < u.batchSize; ++T) {
      const k = T * I[0], D = T * b.strides[0];
      for (let R = 0; R < u.outDepth; ++R) {
        const N = D + R * b.strides[1], E = R * u.strideDepth - v;
        for (let A = 0; A < c; ++A) {
          const M = E + A * f;
          if (M < 0 || M >= u.inDepth) continue;
          const $ = A * C[0], L = k + M * I[1];
          for (let F = 0; F < u.outHeight; ++F) {
            const O = N + F * b.strides[2], z = F * u.strideHeight - x;
            for (let V = 0; V < h; ++V) {
              const H = z + V * p;
              if (H < 0 || H >= u.inHeight) continue;
              const Y = $ + V * C[1], le = L + H * I[2];
              for (let ve = 0; ve < u.outWidth; ++ve) {
                const re = O + ve * u.outChannels, ae = ve * u.strideWidth - y;
                for (let fe = 0; fe < d; ++fe) {
                  const ce = ae + fe * g;
                  if (ce < 0 || ce >= u.inWidth) continue;
                  const ye = Y + fe * C[2], Le = le + ce * u.inChannels;
                  let Re = ye;
                  for (let be = 0; be < u.inChannels; ++be) {
                    const xe = w[Le + be];
                    for (let ot = 0; ot < u.outChannels; ++ot) S[re + ot] += xe * _[Re + ot];
                    Re += u.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }
    return t.makeTensorInfo(b.shape, b.dtype, b.values);
  }
  const JBe = {
    kernelName: tf,
    backendName: "cpu",
    kernelFunc: QBe
  };
  function eze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, pad: o, filterShape: l } = r;
    et([
      i,
      a
    ], "conv3dBackpropFilterV2");
    const u = Be(i.shape), c = Be(a.shape), h = Ra(i.shape, l, s, 1, o), d = h.strideDepth, f = h.strideHeight, p = h.strideWidth, g = h.filterDepth, m = h.filterHeight, v = h.filterWidth, y = new ii(h.filterShape, "float32"), x = y.values, [b, w, _, S] = y.strides, I = t.data.get(a.dataId).values, [C, T, k, D] = c, R = t.data.get(i.dataId).values, [N, E, A, M] = u, $ = h.padInfo.front, L = h.padInfo.left, F = h.padInfo.top;
    for (let O = 0; O < g; ++O) {
      const z = Math.max(0, Math.ceil(($ - O) / d)), V = Math.min(h.outDepth, (h.inDepth + $ - O) / d), H = O * b;
      for (let Y = 0; Y < m; ++Y) {
        const le = Math.max(0, Math.ceil((F - Y) / f)), ve = Math.min(h.outHeight, (h.inHeight + F - Y) / f), re = Y * w + H;
        for (let ae = 0; ae < v; ++ae) {
          const fe = Math.max(0, Math.ceil((L - ae) / p)), ce = Math.min(h.outWidth, (h.inWidth + L - ae) / p), ye = ae * _ + re;
          for (let Le = 0; Le < h.inChannels; ++Le) {
            const Re = Le * S + ye;
            for (let be = 0; be < h.outChannels; ++be) {
              let xe = 0;
              for (let ot = 0; ot < h.batchSize; ++ot) {
                const G = ot * N, q = ot * C;
                for (let ge = z; ge < V; ++ge) {
                  const Lt = (O + ge * d - $) * E + G, dt = ge * T + q;
                  for (let ue = le; ue < ve; ++ue) {
                    const Ut = (Y + ue * f - F) * A + Lt, Ht = ue * k + dt;
                    for (let Jn = fe; Jn < ce; ++Jn) {
                      const ca = (ae + Jn * p - L) * M + Ut, Na = Jn * D + Ht;
                      xe += R[ca + Le] * I[Na + be];
                    }
                  }
                }
              }
              x[Re + be] = xe;
            }
          }
        }
      }
    }
    return t.makeTensorInfo(y.shape, y.dtype, y.values);
  }
  const tze = {
    kernelName: Bm,
    backendName: "cpu",
    kernelFunc: eze
  };
  function nze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { pad: s, strides: o, inputShape: l } = r;
    et([
      i
    ], "conv3dBackpropInputV2");
    const u = Be(i.shape), c = Be(a.shape), h = Ra(l, a.shape, o, 1, s), d = new ii(h.inShape, "float32"), f = d.values, [p, g, m, v] = d.strides, y = t.data.get(i.dataId).values, [x, b, w, _] = u, S = t.data.get(a.dataId).values, [I, C, T, k] = c, { batchSize: D, filterDepth: R, filterHeight: N, filterWidth: E, inChannels: A, inDepth: M, inHeight: $, inWidth: L, outChannels: F, outDepth: O, outHeight: z, outWidth: V, strideDepth: H, strideHeight: Y, strideWidth: le } = h, ve = R - 1 - h.padInfo.front, re = N - 1 - h.padInfo.top, ae = E - 1 - h.padInfo.left;
    for (let fe = 0; fe < D; ++fe) for (let ce = 0; ce < A; ++ce) for (let ye = 0; ye < M; ++ye) {
      const Le = ye - ve, Re = Math.max(0, Math.ceil(Le / H)), be = Math.min(O, (R + Le) / H);
      for (let xe = 0; xe < $; ++xe) {
        const ot = xe - re, G = Math.max(0, Math.ceil(ot / Y)), q = Math.min(z, (N + ot) / Y);
        for (let ge = 0; ge < L; ++ge) {
          const Fe = ge - ae, Lt = Math.max(0, Math.ceil(Fe / le)), dt = Math.min(V, (E + Fe) / le);
          let ue = 0;
          for (let Se = Re; Se < be; ++Se) {
            const Ut = Se * H - Le;
            for (let Ht = G; Ht < q; ++Ht) {
              const Jn = Ht * Y - ot;
              for (let ua = Lt; ua < dt; ++ua) {
                const ca = ua * le - Fe, Na = x * fe + b * Se + w * Ht + _ * ua, bp = I * (R - 1 - Ut) + C * (N - 1 - Jn) + T * (E - 1 - ca) + k * ce;
                for (let yo = 0; yo < F; ++yo) {
                  const du = y[Na + yo], Kr = S[bp + yo];
                  ue += du * Kr;
                }
              }
            }
          }
          f[p * fe + g * ye + m * xe + v * ge + ce] = ue;
        }
      }
    }
    return t.makeTensorInfo(d.shape, d.dtype, d.values);
  }
  const rze = {
    kernelName: zm,
    backendName: "cpu",
    kernelFunc: nze
  };
  const ize = An(nf, (n) => Math.cos(n)), aze = {
    kernelName: nf,
    backendName: "cpu",
    kernelFunc: ize
  };
  const sze = An(rf, (n) => Math.cosh(n)), oze = {
    kernelName: rf,
    backendName: "cpu",
    kernelFunc: sze
  };
  function lze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { image: i, boxes: a, boxInd: s } = e, { cropSize: o, method: l, extrapolationValue: u } = r, [c, h, d, f] = i.shape, p = a.shape[0], [g, m] = o, v = Nt([
      p,
      g,
      m,
      f
    ], "float32"), y = t.data.get(a.dataId).values, x = t.data.get(s.dataId).values, b = t.data.get(i.dataId).values, w = Be(i.shape), _ = Be(v.shape);
    for (let S = 0; S < p; S++) {
      const I = S * 4, C = y[I], T = y[I + 1], k = y[I + 2], D = y[I + 3], R = x[S];
      if (R >= c) continue;
      const N = g > 1 ? (k - C) * (h - 1) / (g - 1) : 0, E = m > 1 ? (D - T) * (d - 1) / (m - 1) : 0;
      for (let A = 0; A < g; A++) {
        const M = g > 1 ? C * (h - 1) + A * N : 0.5 * (C + k) * (h - 1);
        if (M < 0 || M > h - 1) {
          for (let $ = 0; $ < m; $++) for (let L = 0; L < f; L++) {
            const F = L + $ * _[2] + A * _[1] + S * _[0];
            v.values[F] = u;
          }
          continue;
        }
        if (l === "bilinear") {
          const $ = Math.floor(M), L = Math.ceil(M), F = M - $;
          for (let O = 0; O < m; O++) {
            const z = m > 1 ? T * (d - 1) + O * E : 0.5 * (T + D) * (d - 1);
            if (z < 0 || z > d - 1) {
              for (let le = 0; le < f; le++) {
                const ve = le + O * _[2] + A * _[1] + S * _[0];
                v.values[ve] = u;
              }
              continue;
            }
            const V = Math.floor(z), H = Math.ceil(z), Y = z - V;
            for (let le = 0; le < f; le++) {
              let ve = le + V * w[2] + $ * w[1] + R * w[0];
              const re = b[ve];
              ve = le + H * w[2] + $ * w[1] + R * w[0];
              const ae = b[ve];
              ve = le + V * w[2] + L * w[1] + R * w[0];
              const fe = b[ve];
              ve = le + H * w[2] + L * w[1] + R * w[0];
              const ce = b[ve], ye = re + (ae - re) * Y, Le = fe + (ce - fe) * Y;
              ve = le + O * _[2] + A * _[1] + S * _[0], v.values[ve] = ye + (Le - ye) * F;
            }
          }
        } else for (let $ = 0; $ < m; ++$) {
          const L = m > 1 ? T * (d - 1) + $ * E : 0.5 * (T + D) * (d - 1);
          if (L < 0 || L > d - 1) {
            for (let z = 0; z < f; z++) {
              const V = z + $ * _[2] + A * _[1] + S * _[0];
              v.values[V] = u;
            }
            continue;
          }
          const F = Math.round(L), O = Math.round(M);
          for (let z = 0; z < f; z++) {
            const V = z + F * w[2] + O * w[1] + R * w[0], H = z + $ * _[2] + A * _[1] + S * _[0];
            v.values[H] = b[V];
          }
        }
      }
    }
    return t.makeTensorInfo(v.shape, v.dtype, v.values);
  }
  const uze = {
    kernelName: Wm,
    backendName: "cpu",
    kernelFunc: lze
  };
  function cze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, exclusive: s, reverse: o } = r;
    et(i, "cumprod");
    const l = bn([
      a
    ], i.shape.length);
    let u = i;
    l != null && (u = sa({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: l
      }
    }));
    const c = gn(1, i.shape.length)[0];
    if (c !== u.shape.length - 1) throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length - 1} but got axis=${c}`);
    const h = qr(u.dtype, "int32"), d = HM(X(u.shape), h), f = t.data.get(u.dataId).values, p = u.shape[u.shape.length - 1], g = o ? (v, y) => v + p - y - 1 : (v, y) => v + y;
    for (let v = 0; v < f.length; v += p) for (let y = 0; y < p; y++) {
      const x = g(v, y);
      if (y === 0) d[x] = s ? 1 : f[x];
      else {
        const b = g(v, y - 1);
        d[x] = s ? f[b] * d[b] : f[x] * d[b];
      }
    }
    const m = t.makeTensorInfo(u.shape, h, d);
    if (l != null) {
      const v = As(l), y = sa({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          perm: v
        }
      });
      return t.disposeIntermediateTensorInfo(m), t.disposeIntermediateTensorInfo(u), y;
    }
    return m;
  }
  const hze = {
    kernelName: Vm,
    backendName: "cpu",
    kernelFunc: cze
  };
  function dze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, exclusive: s, reverse: o } = r;
    et(i, "cumsum");
    const l = bn([
      a
    ], i.shape.length);
    let u = i;
    l != null && (u = sa({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: l
      }
    }));
    const c = gn(1, i.shape.length)[0];
    if (c !== u.shape.length - 1) throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length - 1} but got axis=${c}`);
    const h = qr(u.dtype, "int32"), d = si(X(u.shape), h), f = t.data.get(u.dataId).values, p = u.shape[u.shape.length - 1], g = o ? (v, y) => v + p - y - 1 : (v, y) => v + y;
    for (let v = 0; v < f.length; v += p) for (let y = 0; y < p; y++) {
      const x = g(v, y);
      if (y === 0) d[x] = s ? 0 : f[x];
      else {
        const b = g(v, y - 1);
        d[x] = s ? f[b] + d[b] : f[x] + d[b];
      }
    }
    const m = t.makeTensorInfo(u.shape, h, d);
    if (l != null) {
      const v = As(l), y = sa({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          perm: v
        }
      });
      return t.disposeIntermediateTensorInfo(m), t.disposeIntermediateTensorInfo(u), y;
    }
    return m;
  }
  const fze = {
    kernelName: af,
    backendName: "cpu",
    kernelFunc: dze
  };
  function pze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, weights: a } = e, { size: s, binaryOutput: o } = r;
    if (i.shape.length === 1) {
      const l = t.data.get(i.dataId).values, u = t.data.get(a.dataId).values, c = dL(l, u, a.dtype, a.shape, s);
      return t.makeTensorInfo([
        s
      ], a.dtype, c);
    } else if (i.shape.length === 2) {
      const l = t.bufferSync(i), u = t.bufferSync(a), c = UJ(l, u, s, o);
      return t.makeTensorInfo(c.shape, a.dtype, c.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`);
  }
  const gze = {
    kernelName: nb,
    backendName: "cpu",
    kernelFunc: pze
  };
  function mze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockSize: a, dataFormat: s } = r;
    B(s === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${s}`);
    const o = i.shape[0], l = i.shape[1], u = i.shape[2], c = i.shape[3], h = l * a, d = u * a, f = c / (a * a), p = t.data.get(i.dataId).values, g = new Float32Array(o * h * d * f);
    let m = 0;
    for (let v = 0; v < o; ++v) for (let y = 0; y < h; ++y) {
      const x = Math.floor(y / a), b = y % a;
      for (let w = 0; w < d; ++w) {
        const _ = Math.floor(w / a), S = w % a, I = (b * a + S) * f;
        for (let C = 0; C < f; ++C) {
          const k = C + I + c * (_ + u * (x + l * v));
          g[m++] = p[k];
        }
      }
    }
    return t.makeTensorInfo([
      o,
      h,
      d,
      f
    ], i.dtype, g);
  }
  const vze = {
    kernelName: Gm,
    backendName: "cpu",
    kernelFunc: mze
  };
  function Oee(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l, dimRoundingMode: u } = r;
    et([
      i,
      a
    ], "depthwiseConv2DNative");
    const c = Be(i.shape), h = Be(a.shape);
    let d = l;
    d == null && (d = [
      1,
      1
    ]), B(Pr(s, d), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);
    const f = Sn(i.shape, a.shape, s, d, o, u, true), { filterHeight: p, filterWidth: g, dilationHeight: m, dilationWidth: v, padInfo: y } = f, x = y.left, b = y.top, w = f.outChannels / f.inChannels, _ = new ii(f.outShape, i.dtype), S = t.data.get(i.dataId).values, I = t.data.get(a.dataId).values, C = _.values;
    for (let T = 0; T < f.batchSize; ++T) {
      const k = T * c[0], D = T * _.strides[0];
      for (let R = 0; R < f.outHeight; ++R) {
        const N = D + R * _.strides[1], E = R * f.strideHeight - b;
        for (let A = 0; A < p; ++A) {
          const M = E + A * m;
          if (M < 0 || M >= f.inHeight) continue;
          const $ = A * h[0], L = k + M * c[1];
          for (let F = 0; F < f.outWidth; ++F) {
            const O = N + F * _.strides[2], z = F * f.strideWidth - x;
            for (let V = 0; V < g; ++V) {
              const H = z + V * v;
              if (H < 0 || H >= f.inWidth) continue;
              const Y = $ + V * h[1], le = L + H * f.inChannels;
              let ve = O, re = Y;
              for (let ae = 0; ae < f.inChannels; ++ae) {
                const fe = S[le + ae];
                for (let ce = 0; ce < w; ++ce) C[ve + ce] += fe * I[re + ce];
                ve += w, re += w;
              }
            }
          }
        }
      }
    }
    return t.makeTensorInfo(_.shape, _.dtype, _.values);
  }
  const yze = {
    kernelName: sf,
    backendName: "cpu",
    kernelFunc: Oee
  };
  function xze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, dilations: o, pad: l, dimRoundingMode: u, filterShape: c } = r;
    et([
      i,
      a
    ], "depthwiseConv2dNativeBackpropFilter");
    const h = Sn(i.shape, c, s, o, l, u, true), { strideHeight: d, strideWidth: f, filterHeight: p, filterWidth: g } = h, m = new ii(h.filterShape, "float32"), v = h.padInfo.left, y = h.padInfo.top, x = h.outChannels / h.inChannels, b = t.data.get(i.dataId).values, w = new ii(i.shape, i.dtype, b), _ = t.data.get(a.dataId).values, S = new ii(a.shape, a.dtype, _);
    for (let I = 0; I < p; ++I) {
      const C = Math.max(0, Math.ceil((y - I) / d)), T = Math.min(h.outHeight, (h.inHeight + y - I) / d);
      for (let k = 0; k < g; ++k) {
        const D = Math.max(0, Math.ceil((v - k) / f)), R = Math.min(h.outWidth, (h.inWidth + v - k) / f);
        for (let N = 0; N < h.outChannels; ++N) {
          const E = Math.trunc(N / x), A = N % x;
          let M = 0;
          for (let $ = 0; $ < h.batchSize; ++$) for (let L = C; L < T; ++L) {
            const F = I + L * d - y;
            for (let O = D; O < R; ++O) {
              const z = k + O * f - v;
              M += w.get($, F, z, E) * S.get($, L, O, N);
            }
          }
          m.set(M, I, k, E, A);
        }
      }
    }
    return t.makeTensorInfo(m.shape, m.dtype, m.values);
  }
  const bze = {
    kernelName: rI,
    backendName: "cpu",
    kernelFunc: xze
  };
  function wze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { strides: s, dilations: o, pad: l, dimRoundingMode: u, inputShape: c } = r;
    et([
      i,
      a
    ], "depthwiseConv2DNativeBackpropInput");
    const h = Be(i.shape), d = Be(a.shape), f = Sn(c, a.shape, s, o, l, u, true), p = new ii(f.inShape, "float32"), g = p.values, [m, v, y] = p.strides, x = t.data.get(i.dataId).values, [b, w, _] = h, S = t.data.get(a.dataId).values, [I, C, T] = d, { batchSize: k, filterHeight: D, filterWidth: R, inChannels: N, inHeight: E, inWidth: A, outChannels: M, outHeight: $, outWidth: L, strideHeight: F, strideWidth: O } = f, z = D - 1 - f.padInfo.top, V = R - 1 - f.padInfo.left, H = M / N;
    for (let Y = 0; Y < k; ++Y) for (let le = 0; le < N; ++le) for (let ve = 0; ve < E; ++ve) {
      const re = ve - z, ae = Math.max(0, Math.ceil(re / F)), fe = Math.min($, (D + re) / F);
      for (let ce = 0; ce < A; ++ce) {
        const ye = ce - V, Le = Math.max(0, Math.ceil(ye / O)), Re = Math.min(L, (R + ye) / O);
        let be = 0;
        for (let xe = ae; xe < fe; ++xe) {
          const ot = xe * F - re;
          for (let G = Le; G < Re; ++G) {
            const q = G * O - ye, ge = b * Y + w * xe + _ * G, Fe = I * (D - 1 - ot) + C * (R - 1 - q) + T * le;
            for (let Lt = 0; Lt < H; ++Lt) {
              const dt = le * H + Lt, ue = x[ge + dt], Se = S[Fe + Lt];
              be += ue * Se;
            }
          }
        }
        g[m * Y + v * ve + y * ce + le] = be;
      }
    }
    return t.makeTensorInfo(p.shape, p.dtype, p.values);
  }
  const _ze = {
    kernelName: iI,
    backendName: "cpu",
    kernelFunc: wze
  };
  function Sze(n) {
    const { inputs: e, backend: t } = n, { x: r } = e, i = X(r.shape), a = t.data.get(r.dataId).values, s = Nt([
      i,
      i
    ], r.dtype), o = s.values;
    for (let u = 0; u < a.length; u++) o[u * i + u] = a[u];
    const l = [
      ...r.shape,
      ...r.shape
    ];
    return t.makeTensorInfo(l, s.dtype, s.values);
  }
  const Cze = {
    kernelName: aI,
    backendName: "cpu",
    kernelFunc: Sze
  };
  const Ize = {
    kernelName: of,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, backend: e, attrs: t }) => {
      const { x: r, filter: i } = n, { strides: a, pad: s, dilations: o } = t, l = e, u = l.data.get(r.dataId).values, c = r.shape.length, h = l.data.get(i.dataId).values, d = i.shape.length, { batchSize: f, inHeight: p, inWidth: g, inChannels: m, outHeight: v, outWidth: y, padInfo: x, strideHeight: b, strideWidth: w, filterHeight: _, filterWidth: S, dilationHeight: I, dilationWidth: C, outShape: T } = po(r.shape, i.shape, a, s, "NHWC", o), k = X(T), D = T.length, R = ir(r.dtype, k);
      for (let E = 0; E < f; ++E) for (let A = 0; A < v; ++A) {
        const M = A * b - x.top;
        for (let $ = 0; $ < y; ++$) {
          const L = $ * w - x.left;
          for (let F = 0; F < m; ++F) {
            let O = Number.MIN_SAFE_INTEGER;
            for (let V = 0; V < _; ++V) {
              const H = M + V * I;
              if (H >= 0 && H < p) for (let Y = 0; Y < S; ++Y) {
                const le = L + Y * C;
                if (le >= 0 && le < g) {
                  const ve = Yo([
                    E,
                    H,
                    le,
                    F
                  ], c, Be(r.shape)), re = Yo([
                    V,
                    Y,
                    F
                  ], d, Be(i.shape)), ae = u[ve] + h[re];
                  ae > O && (O = ae);
                }
              }
            }
            const z = Yo([
              E,
              A,
              $,
              F
            ], D, Be(T));
            R[z] = O;
          }
        }
      }
      return {
        dataId: l.write(sp(R, r.dtype), T, r.dtype),
        shape: T,
        dtype: r.dtype
      };
    }
  };
  const kze = {
    kernelName: Yg,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, backend: e, attrs: t }) => {
      const { x: r, filter: i, dy: a } = n, { strides: s, pad: o, dilations: l } = t, u = e, c = Qs(r.shape, u.data.get(r.dataId).values), h = Qs(i.shape, u.data.get(i.dataId).values), { batchSize: d, inHeight: f, inWidth: p, inChannels: g, outHeight: m, outWidth: v, padInfo: y, strideHeight: x, strideWidth: b, filterHeight: w, filterWidth: _, dilationHeight: S, dilationWidth: I, outShape: C } = po(r.shape, i.shape, s, o, "NHWC", l);
      B(a.rank === C.length, () => `Error in ${Yg}, dy must have the same rank as output ${C.length}, but got ${a.rank}`);
      const T = Qs(C, u.data.get(a.dataId).values), k = G7(i.shape, i.dtype);
      for (let R = 0; R < d; ++R) for (let N = 0; N < m; ++N) {
        const E = N * x - y.top;
        for (let A = 0; A < v; ++A) {
          const M = A * b - y.left;
          for (let $ = 0; $ < g; ++$) {
            let L = Number.MIN_SAFE_INTEGER, F = 0, O = 0;
            for (let z = 0; z < w; ++z) {
              const V = E + z * S;
              if (V >= 0 && V < f) for (let H = 0; H < _; ++H) {
                const Y = M + H * I;
                if (Y >= 0 && Y < p) {
                  const le = c[R][V][Y][$] + h[z][H][$];
                  le > L && (L = le, F = z, O = H);
                }
              }
            }
            k[F][O][$] += T[R][N][A][$];
          }
        }
      }
      return {
        dataId: u.write(sp(k, r.dtype), i.shape, i.dtype),
        shape: i.shape,
        dtype: i.dtype
      };
    }
  };
  const Tze = {
    kernelName: Xg,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, backend: e, attrs: t }) => {
      const { x: r, filter: i, dy: a } = n, { strides: s, pad: o, dilations: l } = t, u = e, c = Qs(r.shape, u.data.get(r.dataId).values), h = Qs(i.shape, u.data.get(i.dataId).values), { batchSize: d, inHeight: f, inWidth: p, inChannels: g, outHeight: m, outWidth: v, padInfo: y, strideHeight: x, strideWidth: b, filterHeight: w, filterWidth: _, dilationHeight: S, dilationWidth: I, outShape: C } = po(r.shape, i.shape, s, o, "NHWC", l);
      B(a.rank === C.length, () => `Error in ${Xg}, dy must have the same rank as output ${C.length}, but got ${a.rank}`);
      const T = Qs(C, u.data.get(a.dataId).values), k = G7(r.shape, r.dtype);
      for (let R = 0; R < d; ++R) for (let N = 0; N < m; ++N) {
        const E = N * x - y.top;
        for (let A = 0; A < v; ++A) {
          const M = A * b - y.left;
          for (let $ = 0; $ < g; ++$) {
            let L = Number.MIN_SAFE_INTEGER, F = E < 0 ? 0 : E, O = M < 0 ? 0 : M;
            for (let z = 0; z < w; ++z) {
              const V = E + z * S;
              if (V >= 0 && V < f) for (let H = 0; H < _; ++H) {
                const Y = M + H * I;
                if (Y >= 0 && Y < p) {
                  const le = c[R][V][Y][$] + h[z][H][$];
                  le > L && (L = le, F = V, O = Y);
                }
              }
            }
            k[R][F][O][$] += T[R][N][A][$];
          }
        }
      }
      return {
        dataId: u.write(sp(k, r.dtype), r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      };
    }
  };
  function Aze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { image: i } = e, { canvas: a, options: s } = r, { contextOptions: o, imageOptions: l } = s || {}, u = (l == null ? void 0 : l.alpha) || 1, c = (o == null ? void 0 : o.contextType) || "2d";
    if (c !== "2d") throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);
    const h = a.getContext(c, (o == null ? void 0 : o.contextAttributes) || {});
    if (h == null) throw new Error(`Could not get the context with ${c} type.`);
    const [d, f] = i.shape.slice(0, 2), p = i.shape.length === 2 ? 1 : i.shape[2], g = t.data.get(i.dataId).values, m = i.dtype === "float32" ? 255 : 1, v = new Uint8ClampedArray(f * d * 4);
    for (let x = 0; x < d * f; ++x) {
      const b = [
        0,
        0,
        0,
        255 * u
      ];
      for (let _ = 0; _ < p; _++) {
        const S = g[x * p + _];
        if (i.dtype === "float32") {
          if (S < 0 || S > 1) throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${S}.`);
        } else if (i.dtype === "int32" && (S < 0 || S > 255)) throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${S}.`);
        p === 1 ? (b[0] = S * m, b[1] = S * m, b[2] = S * m) : b[_] = S * m;
      }
      const w = x * 4;
      v[w + 0] = Math.round(b[0]), v[w + 1] = Math.round(b[1]), v[w + 2] = Math.round(b[2]), v[w + 3] = Math.round(b[3]);
    }
    a.width = f, a.height = d;
    const y = new ImageData(v, f, d);
    return h.putImageData(y, 0, 0), i;
  }
  const Dze = {
    kernelName: X7,
    backendName: "cpu",
    kernelFunc: Aze
  };
  function Vb(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    et(i, "sum");
    let o;
    i.dtype === "bool" ? o = fc({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        dtype: "int32"
      }
    }) : o = ol({
      inputs: {
        x: i
      },
      backend: t
    });
    const l = o.shape.length, u = yt(a, o.shape), c = bn(u, l);
    let h = u, d = o;
    c != null && (d = sa({
      inputs: {
        x: o
      },
      backend: t,
      attrs: {
        perm: c
      }
    }), h = gn(h.length, l)), Tn("sum", h, d.shape.length);
    const [f, p] = Ln(d.shape, h), g = qr(d.dtype, "int32");
    let m = US(t, f, g);
    const v = X(p), y = t.data.get(m.dataId).values, x = t.data.get(d.dataId).values;
    for (let b = 0; b < y.length; ++b) {
      const w = b * v;
      let _ = 0;
      for (let S = 0; S < v; ++S) _ += x[w + S];
      y[b] = _;
    }
    if (s) {
      const b = Mn(m.shape, u), w = m;
      m = Hn({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: b
        }
      }), t.disposeIntermediateTensorInfo(w);
    }
    return t.disposeIntermediateTensorInfo(o), c != null && t.disposeIntermediateTensorInfo(d), m;
  }
  const Rze = {
    kernelName: ep,
    backendName: "cpu",
    kernelFunc: Vb
  };
  function $ze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { equation: i } = r, a = e, { allDims: s, summedDims: o, idDims: l } = VI(i, a.length);
    GI(s.length, l, a);
    const { path: u, steps: c } = UI(o, l), h = c.length;
    let d = null, f = s.length;
    const p = [];
    for (let g = 0; g < h; ++g) {
      for (const m of c[g]) {
        const { permutationIndices: v, expandDims: y } = WI(f, l[m]);
        let x;
        HI(v) ? x = a[m] : (x = sa({
          inputs: {
            x: a[m]
          },
          backend: t,
          attrs: {
            perm: v
          }
        }), p.push(x));
        const b = x.shape.slice();
        for (let w = 0; w < y.length; ++w) b.splice(y[w], 0, 1);
        Jt(x.shape, b) || (x = Hn({
          inputs: {
            x
          },
          backend: t,
          attrs: {
            shape: b
          }
        }), p.push(x)), d === null ? d = x : (d = r2({
          inputs: {
            a: x,
            b: d
          },
          backend: t
        }), p.push(d));
      }
      g < h - 1 && (u[g] >= 0 && (d = Vb({
        inputs: {
          x: d
        },
        backend: t,
        attrs: {
          axis: u[g] - (s.length - f),
          keepDims: false
        }
      }), p.push(d)), f--);
    }
    for (const g of p) g !== d && t.disposeIntermediateTensorInfo(g);
    return d;
  }
  const Nze = {
    kernelName: sI,
    backendName: "cpu",
    kernelFunc: $ze
  };
  function Eze(n) {
    const { inputs: e, backend: t } = n, { dy: r, y: i } = e;
    et([
      r,
      i
    ], "eluGrad");
    const a = new Float32Array(X(i.shape)), s = t.data.get(i.dataId).values, o = t.data.get(r.dataId).values;
    for (let l = 0; l < s.length; ++l) {
      const u = s[l];
      u >= 0 ? a[l] = o[l] : a[l] = o[l] * (u + 1);
    }
    return t.makeTensorInfo(i.shape, "float32", a);
  }
  const Mze = {
    kernelName: Um,
    backendName: "cpu",
    kernelFunc: Eze
  };
  const Pze = PI, Lze = LI, Fze = FI, Oze = OI, Bze = BI, zze = zI, Vze = An(cf, (n) => {
    const e = Math.sign(n), t = Math.abs(n), r = 1 / (1 + Pze * t);
    return e * (1 - ((((zze * r + Bze) * r + Oze) * r + Fze) * r + Lze) * r * Math.exp(-t * t));
  }), Wze = {
    kernelName: cf,
    backendName: "cpu",
    kernelFunc: Vze
  };
  function qS(n) {
    const { inputs: e, backend: t, attrs: r } = n, { input: i } = e, { dim: a } = r, s = i.shape.length, o = i.shape.slice();
    let l = a;
    return a < 0 && (B(-(s + 1) <= a, () => `Axis must be in the interval [${-(s + 1)}, ${s}]`), l = s + a + 1), o.splice(l, 0, 1), Hn({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: o
      }
    });
  }
  const Gze = {
    kernelName: Xm,
    backendName: "cpu",
    kernelFunc: qS
  };
  const Uze = pr((n, e) => n / e), CL = Lr(lf, Uze), M$ = {
    kernelName: lf,
    backendName: "cpu",
    kernelFunc: CL
  };
  function Bee(n, e, t) {
    const r = n.shape, i = r[0], a = r[1], s = t.data.get(n.dataId), o = s.complexTensorInfos.real, l = s.complexTensorInfos.imag, u = [
      i,
      a
    ], c = X(u), h = Yr("float32", c), d = Yr("float32", c);
    for (let m = 0; m < i; m++) {
      const v = Dd({
        inputs: {
          x: o
        },
        backend: t,
        attrs: {
          begin: [
            m,
            0
          ],
          size: [
            1,
            a
          ]
        }
      }), y = Dd({
        inputs: {
          x: l
        },
        backend: t,
        attrs: {
          begin: [
            m,
            0
          ],
          size: [
            1,
            a
          ]
        }
      }), x = wa({
        inputs: {
          real: v,
          imag: y
        },
        backend: t
      }), { real: b, imag: w } = Hze(x, e, t), _ = ao(b, w);
      for (let S = 0; S < a; S++) {
        const I = DP(_, S);
        h[m * a + S] = I.real, d[m * a + S] = I.imag;
      }
      t.disposeIntermediateTensorInfo(v), t.disposeIntermediateTensorInfo(y), t.disposeIntermediateTensorInfo(x);
    }
    const f = t.makeTensorInfo(u, "float32", h), p = t.makeTensorInfo(u, "float32", d), g = wa({
      inputs: {
        real: f,
        imag: p
      },
      backend: t
    });
    return t.disposeIntermediateTensorInfo(f), t.disposeIntermediateTensorInfo(p), g;
  }
  function Hze(n, e, t) {
    const r = X(n.shape), i = t.data.get(n.dataId), a = t.data.get(i.complexTensorInfos.real.dataId).values, s = t.data.get(i.complexTensorInfos.imag.dataId).values;
    if (Xze(r)) {
      const o = P$(a, s, r, e, t), l = [
        n.shape[0],
        n.shape[1]
      ];
      if (e) {
        const u = t.makeTensorInfo(l, "float32", o.real), c = t.makeTensorInfo(l, "float32", o.imag), h = t.makeTensorInfo([], "float32", Sc(r, "float32")), d = ol({
          inputs: {
            x: h
          },
          backend: t
        }), f = M$.kernelFunc({
          inputs: {
            a: u,
            b: h
          },
          backend: t
        }), p = M$.kernelFunc({
          inputs: {
            a: c,
            b: d
          },
          backend: t
        }), g = t.data.get(f.dataId).values, m = t.data.get(p.dataId).values;
        return t.disposeIntermediateTensorInfo(u), t.disposeIntermediateTensorInfo(c), t.disposeIntermediateTensorInfo(h), t.disposeIntermediateTensorInfo(d), t.disposeIntermediateTensorInfo(f), t.disposeIntermediateTensorInfo(p), {
          real: g,
          imag: m
        };
      }
      return o;
    } else {
      const o = ao(a, s), l = Yze(o, r, e);
      return vZ(l);
    }
  }
  function Xze(n) {
    return (n & n - 1) === 0;
  }
  function P$(n, e, t, r, i) {
    if (t === 1) return {
      real: n,
      imag: e
    };
    const a = ao(n, e), s = t / 2, o = yZ(a), l = o.real, u = o.imag, c = [
      l.length
    ], h = i.makeTensorInfo(c, "float32", l), d = i.makeTensorInfo(c, "float32", u), f = wa({
      inputs: {
        real: h,
        imag: d
      },
      backend: i
    }), p = xZ(a), g = p.real, m = p.imag, v = [
      g.length
    ], y = i.makeTensorInfo(v, "float32", g), x = i.makeTensorInfo(v, "float32", m), b = wa({
      inputs: {
        real: y,
        imag: x
      },
      backend: i
    }), w = P$(l, u, s, r, i), _ = w.real, S = w.imag, I = [
      _.length
    ], C = i.makeTensorInfo(I, "float32", _), T = i.makeTensorInfo(I, "float32", S), k = wa({
      inputs: {
        real: C,
        imag: T
      },
      backend: i
    }), D = P$(g, m, s, r, i), R = D.real, N = D.imag, E = [
      R.length
    ], A = i.makeTensorInfo(E, "float32", R), M = i.makeTensorInfo(E, "float32", N), $ = wa({
      inputs: {
        real: A,
        imag: M
      },
      backend: i
    }), L = wZ(t, r), F = [
      L.real.length
    ], O = i.makeTensorInfo(F, "float32", L.real), z = i.makeTensorInfo(F, "float32", L.imag), V = wa({
      inputs: {
        real: O,
        imag: z
      },
      backend: i
    }), H = r2({
      inputs: {
        a: V,
        b: $
      },
      backend: i
    }), Y = Qg({
      inputs: {
        a: k,
        b: H
      },
      backend: i
    }), le = wL({
      inputs: {
        a: k,
        b: H
      },
      backend: i
    }), ve = Ad({
      inputs: {
        input: Y
      },
      backend: i
    }), re = Ad({
      inputs: {
        input: le
      },
      backend: i
    }), ae = Jg({
      inputs: {
        input: Y
      },
      backend: i
    }), fe = Jg({
      inputs: {
        input: le
      },
      backend: i
    }), ce = em({
      inputs: [
        ve,
        re
      ],
      backend: i,
      attrs: {
        axis: 0
      }
    }), ye = em({
      inputs: [
        ae,
        fe
      ],
      backend: i,
      attrs: {
        axis: 0
      }
    }), Le = i.data.get(ce.dataId).values, Re = i.data.get(ye.dataId).values;
    return i.disposeIntermediateTensorInfo(h), i.disposeIntermediateTensorInfo(d), i.disposeIntermediateTensorInfo(f), i.disposeIntermediateTensorInfo(y), i.disposeIntermediateTensorInfo(x), i.disposeIntermediateTensorInfo(b), i.disposeIntermediateTensorInfo(C), i.disposeIntermediateTensorInfo(T), i.disposeIntermediateTensorInfo(k), i.disposeIntermediateTensorInfo(A), i.disposeIntermediateTensorInfo(M), i.disposeIntermediateTensorInfo($), i.disposeIntermediateTensorInfo(O), i.disposeIntermediateTensorInfo(z), i.disposeIntermediateTensorInfo(V), i.disposeIntermediateTensorInfo(H), i.disposeIntermediateTensorInfo(Y), i.disposeIntermediateTensorInfo(le), i.disposeIntermediateTensorInfo(ve), i.disposeIntermediateTensorInfo(ae), i.disposeIntermediateTensorInfo(re), i.disposeIntermediateTensorInfo(fe), i.disposeIntermediateTensorInfo(ce), i.disposeIntermediateTensorInfo(ye), {
      real: Le,
      imag: Re
    };
  }
  function Yze(n, e, t) {
    const r = new Float32Array(e * 2);
    for (let i = 0; i < e; i++) {
      let a = 0, s = 0;
      for (let o = 0; o < e; o++) {
        const l = _Z(i * o, e, t), u = DP(n, o);
        a += u.real * l.real - u.imag * l.imag, s += u.real * l.imag + u.imag * l.real;
      }
      t && (a /= e, s /= e), bZ(r, a, s, i);
    }
    return r;
  }
  function qze(n) {
    const { inputs: e, backend: t } = n, { input: r } = e, i = X(r.shape), a = r.shape[r.shape.length - 1], s = i / a, o = Hn({
      inputs: {
        x: r
      },
      backend: t,
      attrs: {
        shape: [
          s,
          a
        ]
      }
    }), l = Bee(o, false, t), u = Hn({
      inputs: {
        x: l
      },
      backend: t,
      attrs: {
        shape: r.shape
      }
    });
    return t.disposeIntermediateTensorInfo(o), t.disposeIntermediateTensorInfo(l), u;
  }
  const jze = {
    kernelName: oI,
    backendName: "cpu",
    kernelFunc: qze
  };
  function IL(n) {
    const { backend: e, attrs: t } = n, { shape: r, value: i, dtype: a } = t, s = a || yc(i), o = ir(s, X(r));
    return Zze(o, i, s), e.makeTensorInfo(r, s, o);
  }
  const Kze = {
    kernelName: rb,
    backendName: "cpu",
    kernelFunc: IL
  };
  function Zze(n, e, t) {
    n.fill(e);
  }
  const Qze = {
    kernelName: Ym,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { image: r } = n, i = t, a = Yr(r.dtype, X(r.shape)), [s, o, l, u] = r.shape, c = i.data.get(r.dataId).values;
      for (let d = 0; d < s; d++) {
        const f = d * l * o * u;
        for (let p = 0; p < o; p++) {
          const g = p * (l * u);
          for (let m = 0; m < l; m++) {
            const v = m * u;
            for (let y = 0; y < u; y++) {
              const x = Math.round(l - m - 1), b = f + g + v + y;
              let w = c[b];
              if (x >= 0 && x < l) {
                const _ = x * u, S = f + g + _ + y;
                w = c[S];
              }
              a[b] = w;
            }
          }
        }
      }
      return {
        dataId: i.write(a, r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      };
    }
  };
  function Jze(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = e, { strides: l, pad: u, dataFormat: c, dilations: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = r;
    let g = Fee({
      inputs: {
        x: i,
        filter: a
      },
      backend: t,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: d
      }
    });
    if (s) {
      const m = g;
      if (c === "NCHW" && s.shape.length === 1 && s.shape[0] !== 1) {
        const v = Hn({
          inputs: {
            x: s
          },
          backend: t,
          attrs: {
            shape: [
              s.shape[0],
              1,
              1
            ]
          }
        });
        g = Qg({
          inputs: {
            a: g,
            b: v
          },
          backend: t
        }), t.disposeIntermediateTensorInfo(v);
      } else g = Qg({
        inputs: {
          a: g,
          b: s
        },
        backend: t
      });
      t.disposeIntermediateTensorInfo(m);
    }
    if (f) {
      const m = g;
      if (c === "NCHW" && f === "prelu" && o.shape.length === 1 && o.shape[0] !== 1) {
        const v = Hn({
          inputs: {
            x: o
          },
          backend: t,
          attrs: {
            shape: [
              o.shape[0],
              1,
              1
            ]
          }
        });
        g = YS(t, g, f, v, p), t.disposeIntermediateTensorInfo(v);
      } else g = YS(t, g, f, o, p);
      t.disposeIntermediateTensorInfo(m);
    }
    return g;
  }
  const eVe = {
    kernelName: yd,
    backendName: "cpu",
    kernelFunc: Jze
  };
  function tVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = e, { strides: l, pad: u, dataFormat: c, dilations: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = r;
    let g = Oee({
      inputs: {
        x: i,
        filter: a
      },
      backend: t,
      attrs: {
        strides: l,
        pad: u,
        dataFormat: c,
        dilations: h,
        dimRoundingMode: d
      }
    });
    if (s) {
      const m = g;
      g = Qg({
        inputs: {
          a: g,
          b: s
        },
        backend: t
      }), t.disposeIntermediateTensorInfo(m);
    }
    if (f) {
      const m = g;
      g = YS(t, g, f, o, p), t.disposeIntermediateTensorInfo(m);
    }
    return g;
  }
  const nVe = {
    kernelName: vb,
    backendName: "cpu",
    kernelFunc: tVe
  };
  function rVe(n) {
    const { inputs: e, backend: t } = n, { params: r, indices: i } = e, a = X(r.shape), s = i.shape, o = s[s.length - 1], [l, u, c, h] = _b(r, i);
    if (u === 0) return t.makeTensorInfo(l, r.dtype, []);
    const d = t.data.get(i.dataId).values, f = t.bufferSync(r), p = eee(d, f, r.dtype, u, o, c, h, r.shape, a);
    return t.makeTensorInfo(l, r.dtype, p.values);
  }
  const iVe = {
    kernelName: ib,
    backendName: "cpu",
    kernelFunc: rVe
  };
  function aVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, indices: a } = e, { axis: s, batchDims: o } = r;
    et([
      i,
      a
    ], "gatherV2");
    const l = yt(s, i.shape)[0], u = t.data.get(a.dataId).values, c = i.shape[l];
    for (let b = 0; b < u.length; ++b) {
      const w = u[b];
      B(w <= c - 1 && w >= 0, () => `GatherV2: the index value ${w} is not in [0, ${c - 1}]`);
    }
    let h = o;
    o == null && (h = 0);
    const d = X(a.shape), f = Nb(i, a, l, h), p = Hn({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          f.batchSize,
          f.outerSize,
          f.dimSize,
          f.sliceSize
        ]
      }
    }), g = Hn({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          f.batchSize,
          d / f.batchSize
        ]
      }
    }), m = [
      f.batchSize,
      f.outerSize,
      d / f.batchSize,
      f.sliceSize
    ], v = t.bufferSync(g), y = t.bufferSync(p), x = tee(y, v, m);
    return t.disposeIntermediateTensorInfo(p), t.disposeIntermediateTensorInfo(g), t.makeTensorInfo(f.outputShape, x.dtype, x.values);
  }
  const sVe = {
    kernelName: qm,
    backendName: "cpu",
    kernelFunc: aVe
  };
  function oVe(n) {
    const { inputs: e, backend: t } = n, { input: r } = e, i = X(r.shape), a = r.shape[r.shape.length - 1], s = i / a, o = Hn({
      inputs: {
        x: r
      },
      backend: t,
      attrs: {
        shape: [
          s,
          a
        ]
      }
    }), l = Bee(o, true, t), u = Hn({
      inputs: {
        x: l
      },
      backend: t,
      attrs: {
        shape: r.shape
      }
    });
    return t.disposeIntermediateTensorInfo(o), t.disposeIntermediateTensorInfo(l), u;
  }
  const lVe = {
    kernelName: lI,
    backendName: "cpu",
    kernelFunc: oVe
  };
  const uVe = An(yf, (n) => Number.isFinite(n) ? 1 : 0, "bool"), cVe = {
    kernelName: yf,
    backendName: "cpu",
    kernelFunc: uVe
  };
  const hVe = An(xf, (n) => Math.abs(n) === 1 / 0 ? 1 : 0, "bool"), dVe = {
    kernelName: xf,
    backendName: "cpu",
    kernelFunc: hVe
  };
  const fVe = An(bf, (n) => Number.isNaN(n) ? 1 : 0, "bool"), pVe = {
    kernelName: bf,
    backendName: "cpu",
    kernelFunc: fVe
  };
  function gVe(n) {
    const { backend: e, attrs: t } = n, { start: r, stop: i, num: a } = t, s = see(r, i, a);
    return e.makeTensorInfo([
      s.length
    ], "float32", s);
  }
  const mVe = {
    kernelName: ab,
    backendName: "cpu",
    kernelFunc: gVe
  };
  const vVe = An(Sf, (n) => Math.log1p(n)), yVe = {
    kernelName: Sf,
    backendName: "cpu",
    kernelFunc: vVe
  };
  const xVe = pr((n, e) => n && e), bVe = Lr(Qm, xVe, null, "bool"), wVe = {
    kernelName: Qm,
    backendName: "cpu",
    kernelFunc: bVe
  };
  const _Ve = An(Jm, (n) => n ? 0 : 1, "bool"), SVe = {
    kernelName: Jm,
    backendName: "cpu",
    kernelFunc: _Ve
  };
  const CVe = pr((n, e) => n || e), IVe = Lr(ev, CVe, null, "bool"), kVe = {
    kernelName: ev,
    backendName: "cpu",
    kernelFunc: IVe
  };
  function TVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { depthRadius: a, bias: s, alpha: o, beta: l } = r;
    et(i, "LRN");
    const u = i.shape[3], c = u - 1, h = t.data.get(i.dataId).values, d = X(i.shape), f = new Float32Array(d);
    function p(g) {
      const m = g % u;
      let v = g - m + Math.max(0, m - a);
      const y = g - m + Math.min(m + a, c);
      let x = 0;
      for (; v <= y; v++) {
        const b = h[v];
        x += b * b;
      }
      return x;
    }
    for (let g = 0; g < d; g++) {
      const m = p(g), v = h[g] * Math.pow(s + o * m, -l);
      f[g] = v;
    }
    return t.makeTensorInfo(i.shape, i.dtype, f);
  }
  const AVe = {
    kernelName: Cf,
    backendName: "cpu",
    kernelFunc: TVe
  };
  function DVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, y: a, dy: s } = e, { depthRadius: o, bias: l, alpha: u, beta: c } = r;
    et(s, "LRNGrad");
    const h = X(s.shape), d = s.shape[3], f = t.data.get(s.dataId).values, p = t.data.get(i.dataId).values, g = t.data.get(a.dataId).values, m = new Float32Array(h), v = h;
    for (let y = 0; y < v; y++) {
      const x = y % d, b = y - x + Math.max(0, x - o), w = y - x + Math.min(d, x + o + 1);
      let _ = 0;
      for (let S = b; S < w; S++) _ += Math.pow(p[S], 2);
      _ = u * _ + l;
      for (let S = b; S < w; S++) {
        let I = -2 * u * c * p[S] * g[y] / _;
        y === S && (I += Math.pow(_, -c)), I *= f[y], m[S] += I;
      }
    }
    return t.makeTensorInfo(s.shape, i.dtype, m);
  }
  const RVe = {
    kernelName: tv,
    backendName: "cpu",
    kernelFunc: DVe
  };
  function zee(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { reductionIndices: a, keepDims: s } = r, o = t;
    let l = i.shape;
    const u = l.length, c = yt(a, l);
    let h = c;
    const d = bn(h, u);
    let f = o.data.get(i.dataId).values;
    if (d != null) {
      const b = new Array(u);
      for (let w = 0; w < b.length; w++) b[w] = l[d[w]];
      f = gL(f, l, i.dtype, d, b), h = gn(h.length, u), l = b;
    }
    et(i, "max"), Tn("max", h, u);
    const [p, g] = Ln(l, h), m = X(g), v = lee(f, m, p, i.dtype), y = o.write(v, p, i.dtype);
    let x = p;
    return s && (x = Mn(p, c)), {
      dataId: y,
      shape: x,
      dtype: i.dtype
    };
  }
  const $Ve = {
    kernelName: If,
    backendName: "cpu",
    kernelFunc: zee
  };
  function NVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e;
    et(i, "maxPool");
    const { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, u = 1;
    B(Pr(s, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = dr(i.shape, a, s, u, o, l);
    let h;
    if (c.filterWidth === 1 && c.filterHeight === 1 && Jt(c.inShape, c.outShape)) h = ol({
      inputs: {
        x: i
      },
      backend: t
    });
    else {
      const d = t.data.get(i.dataId).values, f = Be(i.shape), p = SL(d, i.shape, i.dtype, f, c, "max");
      h = t.makeTensorInfo(c.outShape, i.dtype, p.values);
    }
    return h;
  }
  const EVe = {
    kernelName: Tf,
    backendName: "cpu",
    kernelFunc: NVe
  };
  function MVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dimRoundingMode: l, dataFormat: u } = r;
    et(i, "maxPool3d");
    const c = vi(i.shape, a, s, 1, o, l, u), h = t.data.get(i.dataId).values, d = Lee(h, i.shape, i.dtype, Be(i.shape), c, "max");
    return t.makeTensorInfo(d.shape, "float32", d.values);
  }
  const PVe = {
    kernelName: nv,
    backendName: "cpu",
    kernelFunc: MVe
  };
  function LVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = r;
    et([
      i,
      a
    ], "maxPool3DGrad");
    const c = vi(a.shape, s, o, 1, l, u), h = t.bufferSync(a), d = CBe(h, c), f = c.strideDepth, p = c.strideHeight, g = c.strideWidth, m = c.dilationDepth, v = c.dilationHeight, y = c.dilationWidth, x = c.effectiveFilterDepth, b = c.effectiveFilterHeight, w = c.effectiveFilterWidth, _ = x - 1 - c.padInfo.front, S = w - 1 - c.padInfo.left, I = b - 1 - c.padInfo.top, C = Nt(a.shape, "float32"), T = t.bufferSync(i);
    for (let k = 0; k < c.batchSize; ++k) for (let D = 0; D < c.inChannels; ++D) for (let R = 0; R < c.inDepth; ++R) for (let N = 0; N < c.inHeight; ++N) for (let E = 0; E < c.inWidth; ++E) {
      const A = R - _, M = N - I, $ = E - S;
      let L = 0;
      for (let F = 0; F < x; F += m) {
        const O = (A + F) / f;
        if (!(O < 0 || O >= c.outDepth || Math.floor(O) !== O)) for (let z = 0; z < b; z += v) {
          const V = (M + z) / p;
          if (!(V < 0 || V >= c.outHeight || Math.floor(V) !== V)) for (let H = 0; H < w; H += y) {
            const Y = ($ + H) / g;
            if (Y < 0 || Y >= c.outWidth || Math.floor(Y) !== Y) continue;
            const le = x * b * w - 1 - d.get(k, O, V, Y, D), ve = F * b * w + z * w + H, re = le === ve ? 1 : 0;
            if (re === 0) continue;
            const ae = T.get(k, O, V, Y, D);
            L += ae * re;
          }
        }
      }
      C.set(L, k, R, N, E, D);
    }
    return t.makeTensorInfo(C.shape, C.dtype, C.values);
  }
  const FVe = {
    kernelName: ob,
    backendName: "cpu",
    kernelFunc: LVe
  };
  function OVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a, output: s } = e, o = a;
    et([
      a,
      s
    ], "maxPoolGrad");
    const { filterSize: l, strides: u, pad: c, dimRoundingMode: h } = r, d = dr(o.shape, l, u, 1, c, h), f = t.data.get(o.dataId).values, p = Nt(d.outShape, o.dtype, Pee(f, o.shape, o.dtype, d).values), g = d.strideHeight, m = d.strideWidth, v = d.dilationHeight, y = d.dilationWidth, x = d.effectiveFilterHeight, b = d.effectiveFilterWidth, w = b - 1 - d.padInfo.left, _ = x - 1 - d.padInfo.top, S = Nt(o.shape, "float32"), I = t.data.get(i.dataId).values, C = Nt(i.shape, "float32", I);
    for (let T = 0; T < d.batchSize; ++T) for (let k = 0; k < d.inChannels; ++k) for (let D = 0; D < d.inHeight; ++D) for (let R = 0; R < d.inWidth; ++R) {
      const N = D - _, E = R - w;
      let A = 0;
      for (let M = 0; M < x; M += v) {
        const $ = (N + M) / g;
        if (!($ < 0 || $ >= d.outHeight || Math.floor($) !== $)) for (let L = 0; L < b; L += y) {
          const F = (E + L) / m;
          if (F < 0 || F >= d.outWidth || Math.floor(F) !== F) continue;
          const O = x * b - 1 - p.get(T, $, F, k), z = M * b + L, V = O === z ? 1 : 0;
          if (V === 0) continue;
          const H = C.get(T, $, F, k);
          A += H * V;
        }
      }
      S.set(A, T, D, R, k);
    }
    return t.makeTensorInfo(S.shape, S.dtype, S.values);
  }
  const BVe = {
    kernelName: sb,
    backendName: "cpu",
    kernelFunc: OVe
  };
  function zVe(n, e, t, r, i) {
    const a = Be(e), s = SL(n, e, t, a, i, "max"), o = Pee(n, e, t, i, true, r);
    return [
      s.values,
      o.values
    ];
  }
  const VVe = {
    kernelName: cI,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { x: r } = n, { filterSize: i, strides: a, pad: s, includeBatchInIndex: o } = e, l = t;
      et(r, "MaxPoolWithArgmax");
      const u = l.data.get(r.dataId).values, c = dr(r.shape, i, a, [
        1,
        1
      ], s), [h, d] = zVe(u, r.shape, r.dtype, o, c), f = l.write(h, c.outShape, r.dtype), p = l.write(d, c.outShape, r.dtype);
      return [
        {
          dataId: f,
          shape: c.outShape,
          dtype: r.dtype
        },
        {
          dataId: p,
          shape: c.outShape,
          dtype: "int32"
        }
      ];
    }
  };
  function WVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r, o = yt(a, i.shape), u = Ln(i.shape, o)[1], c = X(u), h = [], d = t.makeTensorInfo([], "float32", new Float32Array([
      c
    ]));
    h.push(d);
    const f = fc({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        dtype: "float32"
      }
    });
    h.push(f);
    const p = CL({
      inputs: {
        a: f,
        b: d
      },
      backend: t
    });
    h.push(p);
    const g = Vb({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        axis: a,
        keepDims: s
      }
    });
    return h.forEach((m) => t.disposeIntermediateTensorInfo(m)), g;
  }
  const GVe = {
    kernelName: Af,
    backendName: "cpu",
    kernelFunc: WVe
  };
  function UVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    et(i, "min");
    const o = yt(a, i.shape);
    let l = o;
    const u = bn(l, i.shape.length);
    let c = i;
    u != null && (c = sa({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), l = gn(l.length, i.shape.length)), Tn("min", l, c.shape.length);
    const [h, d] = Ln(c.shape, l), f = X(d), p = si(X(h), c.dtype), g = t.data.get(c.dataId).values;
    for (let v = 0; v < p.length; ++v) {
      const y = v * f;
      let x = g[y];
      for (let b = 0; b < f; ++b) {
        const w = g[y + b];
        (Number.isNaN(w) || w < x) && (x = w);
      }
      p[v] = x;
    }
    u != null && t.disposeIntermediateTensorInfo(c);
    const m = t.makeTensorInfo(h, c.dtype, p);
    if (s) {
      const v = Mn(h, o), y = Hn({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: v
        }
      });
      return t.disposeIntermediateTensorInfo(m), y;
    }
    return m;
  }
  const HVe = {
    kernelName: Df,
    backendName: "cpu",
    kernelFunc: UVe
  };
  function XVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { paddings: a, mode: s } = r;
    et(i, "mirrorPad");
    const o = a.map((x, b) => x[0] + i.shape[b] + x[1]), l = a.map((x) => x[0]), u = a.map((x, b) => x[0] + i.shape[b]), c = s === "reflect" ? 0 : 1, h = t.data.get(i.dataId).values, d = i.shape.length, f = Be(i.shape), p = X(o), g = o.length, m = Be(o), v = Yr(i.dtype, p);
    for (let x = 0; x < p; x++) {
      let b = Am(x, g, m);
      for (let _ = 0; _ < g; _++) b[_] < l[_] ? b[_] = l[_] * 2 - b[_] - c : b[_] >= u[_] && (b[_] = (u[_] - 1) * 2 - b[_] + c);
      b = b.map((_, S) => _ - l[S]);
      const w = Yo(b, d, f);
      v[x] = h[w];
    }
    return {
      dataId: t.write(v, o, i.dtype),
      shape: o,
      dtype: i.dtype
    };
  }
  const YVe = {
    kernelName: $f,
    backendName: "cpu",
    kernelFunc: XVe
  };
  const qVe = pr((n, e) => {
    const t = n % e;
    return n < 0 && e < 0 || n >= 0 && e >= 0 ? t : (t + e) % e;
  }), jVe = Lr(Nf, qVe), KVe = {
    kernelName: Nf,
    backendName: "cpu",
    kernelFunc: jVe
  };
  function Vee(n) {
    const { inputs: e, backend: t, attrs: r } = n, { logits: i } = e, { dim: a } = r, s = i.shape.length;
    let o = a;
    if (o === -1 && (o = s - 1), o !== s - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${s} and dim was ${o}`);
    const l = yt([
      o
    ], i.shape), u = zee({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        reductionIndices: l,
        keepDims: false
      }
    }), c = Mn(u.shape, l), h = Hn({
      inputs: {
        x: u
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), d = wL({
      inputs: {
        a: i,
        b: h
      },
      backend: t
    }), f = KJ({
      inputs: {
        x: d
      },
      backend: t
    }), p = Vb({
      inputs: {
        x: f
      },
      backend: t,
      attrs: {
        axis: l,
        keepDims: false
      }
    }), g = Hn({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), m = CL({
      inputs: {
        a: f,
        b: g
      },
      backend: t
    });
    return t.disposeIntermediateTensorInfo(u), t.disposeIntermediateTensorInfo(h), t.disposeIntermediateTensorInfo(d), t.disposeIntermediateTensorInfo(f), t.disposeIntermediateTensorInfo(p), t.disposeIntermediateTensorInfo(g), m;
  }
  const ZVe = {
    kernelName: tp,
    backendName: "cpu",
    kernelFunc: Vee
  };
  function QVe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { logits: i } = e, { numSamples: a, seed: s, normalized: o } = r;
    et(i, "multinomial");
    const l = o ? i : Vee({
      inputs: {
        logits: i
      },
      backend: t,
      attrs: {
        dim: -1
      }
    }), u = l.shape[0], c = l.shape[1], h = t.data.get(l.dataId).values, d = [
      u,
      a
    ], f = si(X(d), "int32");
    for (let p = 0; p < u; ++p) {
      const g = p * c, m = new Float32Array(c - 1);
      m[0] = h[g];
      for (let x = 1; x < m.length; ++x) m[x] = m[x - 1] + h[g + x];
      const v = mP.alea(s.toString()), y = p * a;
      for (let x = 0; x < a; ++x) {
        const b = v();
        f[y + x] = m.length;
        for (let w = 0; w < m.length; w++) if (b < m[w]) {
          f[y + x] = w;
          break;
        }
      }
    }
    return o || t.disposeIntermediateTensorInfo(l), t.makeTensorInfo(d, "int32", f);
  }
  const JVe = {
    kernelName: lb,
    backendName: "cpu",
    kernelFunc: QVe
  };
  const eWe = DI;
  function tWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { boxes: i, scores: a } = e, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l } = r;
    et(i, "NonMaxSuppression");
    const u = t.data.get(i.dataId).values, c = t.data.get(a.dataId).values, { selectedIndices: h } = eWe(u, c, s, o, l);
    return t.makeTensorInfo([
      h.length
    ], "int32", new Int32Array(h));
  }
  const nWe = {
    kernelName: av,
    backendName: "cpu",
    kernelFunc: tWe
  };
  const rWe = IP;
  function iWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { boxes: i, scores: a } = e, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, padToMaxOutputSize: u } = r;
    et(i, "NonMaxSuppressionPadded");
    const c = t.data.get(i.dataId).values, h = t.data.get(a.dataId).values, { selectedIndices: d, validOutputs: f } = rWe(c, h, s, o, l, u);
    return [
      t.makeTensorInfo([
        d.length
      ], "int32", new Int32Array(d)),
      t.makeTensorInfo([], "int32", new Int32Array([
        f
      ]))
    ];
  }
  const aWe = {
    kernelName: ub,
    backendName: "cpu",
    kernelFunc: iWe
  };
  const sWe = RI;
  function oWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { boxes: i, scores: a } = e, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, softNmsSigma: u } = r;
    et(i, "NonMaxSuppressionWithScore");
    const c = t.data.get(i.dataId).values, h = t.data.get(a.dataId).values, d = s, f = o, p = l, g = u, { selectedIndices: m, selectedScores: v } = sWe(c, h, d, f, p, g);
    return [
      t.makeTensorInfo([
        m.length
      ], "int32", new Int32Array(m)),
      t.makeTensorInfo([
        v.length
      ], "float32", new Float32Array(v))
    ];
  }
  const lWe = {
    kernelName: sv,
    backendName: "cpu",
    kernelFunc: oWe
  };
  function uWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { indices: i } = e, { dtype: a, depth: s, onValue: o, offValue: l } = r;
    et(i, "oneHot");
    const u = X(i.shape), c = new Float32Array(u * s);
    c.fill(l);
    const h = t.data.get(i.dataId).values;
    for (let d = 0; d < u; ++d) h[d] >= 0 && h[d] < s && (c[d * s + h[d]] = o);
    return t.makeTensorInfo([
      ...i.shape,
      s
    ], a, c);
  }
  const cWe = {
    kernelName: Mf,
    backendName: "cpu",
    kernelFunc: uWe
  };
  function jS(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (r.dtype === "string") throw new Error("zerosLike is not supported for string tensors");
    if (r.dtype === "complex64") {
      const i = Ad({
        inputs: {
          input: r
        },
        backend: t
      }), a = jS({
        inputs: {
          x: i
        },
        backend: t
      }), s = Jg({
        inputs: {
          input: r
        },
        backend: t
      }), o = jS({
        inputs: {
          x: s
        },
        backend: t
      }), l = wa({
        inputs: {
          real: a,
          imag: o
        },
        backend: t
      });
      return t.disposeIntermediateTensorInfo(i), t.disposeIntermediateTensorInfo(a), t.disposeIntermediateTensorInfo(s), t.disposeIntermediateTensorInfo(o), l;
    } else return IL({
      backend: t,
      attrs: {
        shape: r.shape,
        value: 0,
        dtype: r.dtype
      }
    });
  }
  const hWe = {
    kernelName: bv,
    backendName: "cpu",
    kernelFunc: jS
  };
  function Wee(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (r.dtype === "string") throw new Error("onesLike is not supported for string tensors");
    if (r.dtype === "complex64") {
      const i = Ad({
        inputs: {
          input: r
        },
        backend: t
      }), a = Wee({
        inputs: {
          x: i
        },
        backend: t
      }), s = Jg({
        inputs: {
          input: r
        },
        backend: t
      }), o = jS({
        inputs: {
          x: s
        },
        backend: t
      }), l = wa({
        inputs: {
          real: a,
          imag: o
        },
        backend: t
      });
      return t.disposeIntermediateTensorInfo(i), t.disposeIntermediateTensorInfo(a), t.disposeIntermediateTensorInfo(s), t.disposeIntermediateTensorInfo(o), l;
    } else return IL({
      backend: t,
      attrs: {
        shape: r.shape,
        value: 1,
        dtype: r.dtype
      }
    });
  }
  const dWe = {
    kernelName: ov,
    backendName: "cpu",
    kernelFunc: Wee
  };
  function Gee(n) {
    const { inputs: e, backend: t, attrs: r } = n, { axis: i } = r;
    if (e.length === 1) return qS({
      inputs: {
        input: e[0]
      },
      backend: t,
      attrs: {
        dim: i
      }
    });
    const a = e[0].shape, s = e[0].dtype;
    e.forEach((c) => {
      Qx(a, c.shape, "All tensors passed to stack must have matching shapes"), B(s === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const o = [], l = e.map((c) => {
      const h = qS({
        inputs: {
          input: c
        },
        backend: t,
        attrs: {
          dim: i
        }
      });
      return o.push(h), h;
    }), u = em({
      inputs: l,
      backend: t,
      attrs: {
        axis: i
      }
    });
    return o.forEach((c) => t.disposeIntermediateTensorInfo(c)), u;
  }
  const fWe = {
    kernelName: lv,
    backendName: "cpu",
    kernelFunc: Gee
  };
  function pWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { paddings: a, constantValue: s } = r;
    et(i, "pad");
    const o = a.map((y, x) => y[0] + i.shape[x] + y[1]), l = a.map((y) => y[0]), u = t.data.get(i.dataId).values, c = X(i.shape), h = i.shape.length, d = Be(i.shape), f = X(o), p = o.length, g = Be(o), m = Yr(i.dtype, f);
    s !== 0 && m.fill(s);
    for (let y = 0; y < c; y++) {
      const b = Am(y, h, d).map((_, S) => _ + l[S]), w = Yo(b, p, g);
      m[w] = u[y];
    }
    return {
      dataId: t.write(m, o, i.dtype),
      shape: o,
      dtype: i.dtype
    };
  }
  const Uee = {
    kernelName: Pf,
    backendName: "cpu",
    kernelFunc: pWe
  };
  const gWe = pr((n, e) => Math.pow(n, e)), mWe = Lr(Lf, gWe), vWe = {
    kernelName: Lf,
    backendName: "cpu",
    kernelFunc: mWe
  };
  function yWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { paramsNestedSplits: i, paramsDenseValues: a, indices: s } = e, { outputRaggedRank: o } = r, l = i.map((v) => t.data.get(v.dataId).values), u = i.map((v) => v.shape), c = t.data.get(a.dataId).values, h = t.data.get(s.dataId).values, [d, f, p] = pee(l, u, c, a.shape, a.dtype, h, s.shape), g = d.map((v) => t.makeTensorInfo([
      v.length
    ], "int32", v)), m = t.makeTensorInfo(p, a.dtype, f);
    return g.concat([
      m
    ]);
  }
  const xWe = {
    kernelName: Y7,
    backendName: "cpu",
    kernelFunc: yWe
  };
  function bWe(n) {
    const { inputs: e, backend: t } = n, { starts: r, limits: i, deltas: a } = e, s = t.data.get(r.dataId).values, o = t.data.get(i.dataId).values, l = t.data.get(a.dataId).values, [u, c] = gee(s, r.shape, r.dtype, o, i.shape, l, a.shape), h = t.makeTensorInfo([
      u.length
    ], "int32", u), d = t.makeTensorInfo([
      c.length
    ], r.dtype, c);
    return [
      h,
      d
    ];
  }
  const wWe = {
    kernelName: q7,
    backendName: "cpu",
    kernelFunc: bWe
  };
  function _We(n) {
    const { inputs: e, backend: t, attrs: r } = n, { shape: i, values: a, defaultValue: s, rowPartitionTensors: o } = e, { rowPartitionTypes: l } = r, u = t.data.get(i.dataId).values, c = t.data.get(a.dataId).values, h = t.data.get(s.dataId).values, d = o.map((m) => t.data.get(m.dataId).values), f = o.map((m) => m.shape), [p, g] = mee(u, i.shape, c, a.shape, a.dtype, h, s.shape, d, f, l);
    return t.makeTensorInfo(p, a.dtype, g);
  }
  const SWe = {
    kernelName: j7,
    backendName: "cpu",
    kernelFunc: _We
  };
  function CWe(n) {
    const { backend: e, attrs: t } = n, { start: r, stop: i, dtype: a, step: s } = t, o = mL(r, i, s, a);
    return e.makeTensorInfo([
      o.length
    ], a, o);
  }
  const IWe = {
    kernelName: cb,
    backendName: "cpu",
    kernelFunc: CWe
  };
  const kWe = An(Bf, (n) => 1 / n), TWe = {
    kernelName: Bf,
    backendName: "cpu",
    kernelFunc: kWe
  };
  function AWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i } = e, { alignCorners: a, halfPixelCenters: s, size: o } = r;
    et(i, "resizeBilinear");
    const l = Be(i.shape), [u, c] = o, [h, d, f, p] = i.shape, g = t.data.get(i.dataId).values, m = new Float32Array(X([
      h,
      u,
      c,
      p
    ])), v = [
      a && u > 1 ? d - 1 : d,
      a && c > 1 ? f - 1 : f
    ], y = [
      a && u > 1 ? u - 1 : u,
      a && c > 1 ? c - 1 : c
    ];
    let x = 0;
    const b = v[0] / y[0], w = v[1] / y[1];
    for (let _ = 0; _ < h; _++) for (let S = 0; S < u; S++) {
      let I;
      s ? I = b * (S + 0.5) - 0.5 : I = b * S;
      const C = Math.max(0, Math.floor(I)), T = I - C, k = Math.min(d - 1, Math.ceil(I)), D = _ * l[0] + C * l[1], R = _ * l[0] + k * l[1];
      for (let N = 0; N < c; N++) {
        let E;
        s ? E = w * (N + 0.5) - 0.5 : E = w * N;
        const A = Math.max(0, Math.floor(E)), M = E - A, $ = Math.min(f - 1, Math.ceil(E)), L = D + A * l[2], F = R + A * l[2], O = D + $ * l[2], z = R + $ * l[2];
        for (let V = 0; V < p; V++) {
          const H = g[L + V], Y = g[F + V], le = g[O + V], ve = g[z + V], re = H + (le - H) * M, ae = Y + (ve - Y) * M, fe = re + (ae - re) * T;
          m[x++] = fe;
        }
      }
    }
    return t.makeTensorInfo([
      h,
      u,
      c,
      p
    ], "float32", m);
  }
  const DWe = {
    kernelName: Wf,
    backendName: "cpu",
    kernelFunc: AWe
  };
  function RWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i, dy: a } = e, { alignCorners: s } = r;
    et([
      a,
      i
    ], "resizeBilinearGrad");
    const o = Be(i.shape), [l, u, c, h] = i.shape, [, d, f] = a.shape, p = new Float32Array(l * u * c * h), g = [
      s && d > 1 ? u - 1 : u,
      s && f > 1 ? c - 1 : c
    ], m = [
      s && d > 1 ? d - 1 : d,
      s && f > 1 ? f - 1 : f
    ], v = g[0] / m[0], y = g[1] / m[1], x = t.data.get(a.dataId).values;
    let b = 0;
    for (let w = 0; w < l; w++) {
      const _ = w * o[0];
      for (let S = 0; S < d; S++) {
        const I = S * v, C = Math.floor(I), T = Math.min(Math.ceil(I), u - 1), k = _ + C * o[1], D = _ + T * o[1], R = I - C, N = 1 - R;
        for (let E = 0; E < f; E++) {
          const A = E * y, M = Math.floor(A), $ = Math.min(Math.ceil(A), c - 1), L = A - M, F = 1 - L, O = k + M * o[2], z = k + $ * o[2], V = D + M * o[2], H = D + $ * o[2], Y = N * F, le = N * L, ve = R * F, re = R * L;
          for (let ae = 0; ae < h; ae++) {
            const fe = x[b++];
            p[O + ae] += fe * Y, p[z + ae] += fe * le, p[V + ae] += fe * ve, p[H + ae] += fe * re;
          }
        }
      }
    }
    return t.makeTensorInfo([
      l,
      c,
      u,
      h
    ], "float32", p);
  }
  const $We = {
    kernelName: hv,
    backendName: "cpu",
    kernelFunc: RWe
  };
  function NWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i } = e, { alignCorners: a, halfPixelCenters: s, size: o } = r;
    et(i, "resizeNearestNeighbor");
    const l = Be(i.shape), [u, c] = o, [h, d, f, p] = i.shape, g = t.data.get(i.dataId).values, m = new Float32Array(h * u * c * p), v = [
      a && u > 1 ? d - 1 : d,
      a && c > 1 ? f - 1 : f
    ], y = [
      a && u > 1 ? u - 1 : u,
      a && c > 1 ? c - 1 : c
    ], x = v[0] / y[0], b = v[1] / y[1];
    let w = 0;
    for (let _ = 0; _ < h; _++) {
      const S = _ * l[0];
      for (let I = 0; I < u; I++) {
        const C = s ? x * (I + 0.5) : x * I;
        let T = Math.min(d - 1, a ? Math.round(C) : Math.floor(C));
        s && (T = Math.max(0, T));
        const k = S + T * l[1];
        for (let D = 0; D < c; D++) {
          const R = s ? b * (D + 0.5) : b * D;
          let N = Math.min(f - 1, a ? Math.round(R) : Math.floor(R));
          s && (N = Math.max(0, N));
          const E = k + N * l[2];
          for (let A = 0; A < p; A++) {
            const M = g[E + A];
            m[w++] = M;
          }
        }
      }
    }
    return t.makeTensorInfo([
      h,
      u,
      c,
      p
    ], i.dtype, m);
  }
  const EWe = {
    kernelName: Vf,
    backendName: "cpu",
    kernelFunc: NWe
  };
  function MWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i, dy: a } = e, { alignCorners: s } = r;
    et([
      a,
      i
    ], "resizeNearestNeighborGrad");
    const o = Be(i.shape), l = Be(a.shape), [u, c, h, d] = i.shape, [, f, p] = a.shape, g = new Float32Array(u * c * h * d), m = t.data.get(a.dataId).values, v = [
      s && f > 1 ? c - 1 : c,
      s && p > 1 ? h - 1 : h
    ], y = [
      s && f > 1 ? f - 1 : f,
      s && p > 1 ? p - 1 : p
    ], x = v[0] / y[0], b = v[1] / y[1], w = 1 / x, _ = 1 / b, S = Math.ceil(w) * 2 + 2, I = Math.ceil(_) * 2 + 2;
    for (let C = 0; C < u; C++) {
      const T = C * o[0];
      for (let k = 0; k < c; k++) {
        const D = T + k * o[1], R = Math.floor(k * w), N = Math.floor(R - S / 2);
        for (let E = 0; E < h; E++) {
          const A = D + E * o[2], M = Math.floor(E * _), $ = Math.floor(M - I / 2);
          for (let L = 0; L < d; L++) {
            let F = 0;
            for (let O = 0; O < S; O++) {
              const z = O + N;
              if (z < 0 || z >= f) continue;
              const V = T + z * l[1], H = z * x, Y = Math.min(c - 1, s ? Math.round(H) : Math.floor(H));
              if (k === Y) for (let le = 0; le < I; le++) {
                const ve = le + $;
                if (ve < 0 || ve >= p) continue;
                const re = V + ve * l[2], ae = ve * b, fe = Math.min(h - 1, s ? Math.round(ae) : Math.floor(ae));
                E === fe && (F += m[re + L]);
              }
            }
            g[A + L] = F;
          }
        }
      }
    }
    return t.makeTensorInfo(i.shape, i.dtype, g);
  }
  const PWe = {
    kernelName: cv,
    backendName: "cpu",
    kernelFunc: MWe
  };
  function LWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { dims: a } = r;
    et(i, "reverse");
    const s = i.shape.length, o = yt(a, i.shape);
    if (s === 0) return ol({
      inputs: {
        x: i
      },
      backend: t
    });
    const l = new ii(i.shape, i.dtype), u = t.bufferSync(i);
    for (let c = 0; c < l.size; c++) {
      const h = l.indexToLoc(c), d = h.slice();
      o.forEach((f) => d[f] = i.shape[f] - 1 - d[f]), l.set(u.get(...d), ...h);
    }
    return t.makeTensorInfo(l.shape, l.dtype, l.values);
  }
  const FWe = {
    kernelName: Uf,
    backendName: "cpu",
    kernelFunc: LWe
  };
  const OWe = {
    kernelName: wv,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { image: r } = n, { radians: i, fillValue: a, center: s } = e, o = t, l = Yr(r.dtype, X(r.shape)), [u, c, h, d] = r.shape, [f, p] = kb(s, c, h), g = 255, m = Math.sin(i), v = Math.cos(i), y = o.data.get(r.dataId).values;
      for (let b = 0; b < u; b++) {
        const w = b * h * c * d;
        for (let _ = 0; _ < c; _++) {
          const S = _ * (h * d);
          for (let I = 0; I < h; I++) {
            const C = I * d;
            for (let T = 0; T < d; T++) {
              const k = [
                u,
                _,
                I,
                T
              ], D = k[2], R = k[1];
              let N = (D - f) * v - (R - p) * m, E = (D - f) * m + (R - p) * v;
              N = Math.round(N + f), E = Math.round(E + p);
              let A = a;
              if (typeof a != "number" && (T === 3 ? A = g : A = a[T]), N >= 0 && N < h && E >= 0 && E < c) {
                const $ = E * (h * d), L = N * d, F = w + $ + L + T;
                A = y[F];
              }
              const M = w + S + C + T;
              l[M] = A;
            }
          }
        }
      }
      return {
        dataId: o.write(l, r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      };
    }
  };
  const BWe = An(Hf, (n) => {
    const e = Math.floor(n);
    return n - e < 0.5 ? Math.floor(n) : n - e > 0.5 ? Math.ceil(n) : e % 2 === 0 ? e : e + 1;
  }), zWe = {
    kernelName: Hf,
    backendName: "cpu",
    kernelFunc: BWe
  };
  function VWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { indices: i, updates: a } = e, { shape: s } = r, { sliceRank: o, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Ka(a, i, s), d = true, f = t.bufferSync(i), p = t.bufferSync(a), g = Uh(f, p, s, h, u, l, o, c, 0, d);
    return t.makeTensorInfo(s, g.dtype, g.values);
  }
  const WWe = {
    kernelName: hb,
    backendName: "cpu",
    kernelFunc: VWe
  };
  function GWe(n, e) {
    let t = 0, r = n.length, i = 0;
    for (; t < r; ) i = Math.floor((t + r) / 2), n[i] < e ? t = i + 1 : r = i;
    return r;
  }
  function UWe(n, e) {
    let t = 0, r = n.length, i = 0;
    for (; t < r; ) i = Math.floor((t + r) / 2), n[i] <= e ? t = i + 1 : r = i;
    return r;
  }
  function HWe(n, e, t, r, i, a) {
    const s = ir("int32", t * i);
    for (let o = 0; o < t; ++o) {
      const l = n.slice(o * r, (o + 1) * r), u = o * i;
      for (let c = 0; c < i; ++c) s[u + c] = a === "left" ? GWe(l, e[c + u]) : UWe(l, e[c + u]);
    }
    return s;
  }
  function XWe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { sortedSequence: i, values: a } = e, { side: s } = r, o = t.data.get(i.dataId).values, l = t.data.get(a.dataId).values, u = HWe(o, l, i.shape[0], i.shape[1], a.shape[1], s);
    return t.makeTensorInfo(a.shape, "int32", u);
  }
  const YWe = {
    kernelName: fb,
    backendName: "cpu",
    kernelFunc: XWe
  };
  function qWe(n) {
    const { inputs: e, backend: t } = n, { condition: r, t: i, e: a } = e;
    et([
      r,
      i,
      a
    ], "select");
    const s = r.shape.length, o = t.data.get(r.dataId).values, l = t.data.get(i.dataId).values, u = t.data.get(a.dataId).values, c = qr(i.dtype, a.dtype), h = si(X(i.shape), c);
    let d = 0;
    const f = s === 0 || s > 1 || i.shape.length === 1 ? 1 : X(i.shape.slice(1));
    for (let p = 0; p < o.length; p++) for (let g = 0; g < f; g++) o[p] === 1 ? h[d++] = l[p] : h[d++] = u[p];
    return t.makeTensorInfo(i.shape, c, h);
  }
  const jWe = {
    kernelName: dv,
    backendName: "cpu",
    kernelFunc: qWe
  };
  const KWe = Db, ZWe = Rb, QWe = An(Yf, (n) => n >= 0 ? ZWe * n : KWe * (Math.exp(n) - 1)), JWe = {
    kernelName: Yf,
    backendName: "cpu",
    kernelFunc: QWe
  };
  const eGe = An(Kf, (n) => n < 0 ? -1 : n > 0 ? 1 : 0), tGe = {
    kernelName: Kf,
    backendName: "cpu",
    kernelFunc: eGe
  };
  const nGe = An(qf, (n) => Math.sin(n)), rGe = {
    kernelName: qf,
    backendName: "cpu",
    kernelFunc: nGe
  };
  const iGe = An(jf, (n) => Math.sinh(n)), aGe = {
    kernelName: jf,
    backendName: "cpu",
    kernelFunc: iGe
  };
  const sGe = 11920928955078125e-23, vU = Math.log(sGe) + 2, oGe = An(Qf, (n) => {
    const e = n > -vU, t = n < vU, r = Math.exp(n);
    let i;
    return t ? i = r : e ? i = n : i = Math.log(1 + r), i;
  }), lGe = {
    kernelName: Qf,
    backendName: "cpu",
    kernelFunc: oGe
  };
  function uGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockShape: a, paddings: s } = r;
    et([
      i
    ], "spaceToBatchND");
    const o = X(a), l = [
      [
        0,
        0
      ]
    ];
    l.push(...s);
    for (let _ = 1 + a.length; _ < i.shape.length; ++_) l.push([
      0,
      0
    ]);
    const u = Uee.kernelFunc({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        paddings: l,
        constantValue: 0
      }
    }), c = ou(u.shape, a, o, false), h = lu(c.length, a.length, false), d = uu(u.shape, a, o, false), g = Hn({
      inputs: {
        x: u
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), y = sa({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        perm: h
      }
    }), w = Hn({
      inputs: {
        x: y
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    return t.disposeIntermediateTensorInfo(u), t.disposeIntermediateTensorInfo(g), t.disposeIntermediateTensorInfo(y), w;
  }
  const cGe = {
    kernelName: pv,
    backendName: "cpu",
    kernelFunc: uGe
  };
  function hGe(n) {
    const { inputs: e, backend: t } = n, { indices: r, values: i, denseShape: a, defaultValue: s } = e;
    if (a.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);
    if (r.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Values must be a vector, saw:
        ${i.shape}`);
    if (s.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${s.shape}`);
    const o = t.data.get(r.dataId).values, l = t.data.get(i.dataId).values, u = t.data.get(a.dataId).values, c = t.data.get(s.dataId).values[0], [h, d, f, p, g] = xee(o, r.shape, r.dtype, l, i.dtype, u, c);
    return [
      t.makeTensorInfo(d, r.dtype, h),
      t.makeTensorInfo([
        d[0]
      ], i.dtype, f),
      t.makeTensorInfo([
        p.length
      ], "bool", new Uint8Array(p.map((m) => Number(m)))),
      t.makeTensorInfo([
        g.length
      ], r.dtype, new Int32Array(g))
    ];
  }
  const dGe = {
    kernelName: qM,
    backendName: "cpu",
    kernelFunc: hGe
  };
  function fGe(n) {
    const { inputs: e, backend: t } = n, { inputIndices: r, inputShape: i, newShape: a } = e;
    if (r.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${a.shape}`);
    const s = Array.from(t.data.get(i.dataId).values), o = t.data.get(r.dataId).values, l = Array.from(t.data.get(a.dataId).values), [u, c, h] = bee(o, r.shape, r.dtype, s, l);
    return [
      t.makeTensorInfo(c, r.dtype, u),
      t.makeTensorInfo([
        h.length
      ], a.dtype, new Int32Array(h))
    ];
  }
  const pGe = {
    kernelName: dI,
    backendName: "cpu",
    kernelFunc: fGe
  };
  function gGe(n) {
    const { inputs: e, backend: t } = n, { data: r, indices: i, segmentIds: a } = e;
    if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (i.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);
    if (i.shape[0] !== a.shape[0]) throw new Error("segmentIds and indices should have same size.");
    const s = t.data.get(r.dataId).values, o = t.data.get(i.dataId).values, l = t.data.get(a.dataId).values, [u, c] = vL(s, r.shape, r.dtype, o, l, true);
    return t.makeTensorInfo(c, r.dtype, u);
  }
  const mGe = {
    kernelName: fI,
    backendName: "cpu",
    kernelFunc: gGe
  };
  function vGe(n) {
    const { inputs: e, backend: t } = n, { data: r, indices: i, segmentIds: a } = e;
    if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (i.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);
    if (i.shape[0] !== a.shape[0]) throw new Error("segmentIds and indices should have same size.");
    const s = t.data.get(r.dataId).values, o = t.data.get(i.dataId).values, l = t.data.get(a.dataId).values, [u, c] = vL(s, r.shape, r.dtype, o, l);
    return t.makeTensorInfo(c, r.dtype, u);
  }
  const yGe = {
    kernelName: pI,
    backendName: "cpu",
    kernelFunc: vGe
  };
  function xGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { sparseIndices: i, sparseValues: a, defaultValue: s } = e, { outputShape: o } = r, { sliceRank: l, numUpdates: u, sliceSize: c, strides: h, outputSize: d } = Ka(a, i, o), f = false, p = t.bufferSync(i);
    let g;
    switch (a.dtype) {
      case "bool": {
        const m = t.bufferSync(a), v = !!t.data.get(s.dataId).values[0];
        g = Uh(p, m, o, d, c, u, l, h, v, f);
        break;
      }
      case "float32": {
        const m = t.bufferSync(a), v = t.data.get(s.dataId).values[0];
        g = Uh(p, m, o, d, c, u, l, h, v, f);
        break;
      }
      case "int32": {
        const m = t.bufferSync(a), v = t.data.get(s.dataId).values[0];
        g = Uh(p, m, o, d, c, u, l, h, v, f);
        break;
      }
      case "string": {
        const m = t.bufferSync(a), v = io(t.data.get(s.dataId).values[0]);
        g = Uh(p, m, o, d, c, u, l, h, v, f);
        break;
      }
      default:
        throw new Error(`Unsupported type ${a.dtype}`);
    }
    return t.makeTensorInfo(o, g.dtype, g.values);
  }
  const bGe = {
    kernelName: pb,
    backendName: "cpu",
    kernelFunc: xGe
  };
  function wGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { numOrSizeSplits: a, axis: s } = r, o = yt(s, i.shape)[0], l = $b(i, a, o), u = new Array(i.shape.length).fill(0), c = i.shape.slice();
    return l.map((h) => {
      const d = [
        ...c
      ];
      d[o] = h;
      const f = Dd({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: u,
          size: d
        }
      });
      return u[o] += h, f;
    });
  }
  const _Ge = {
    kernelName: gv,
    backendName: "cpu",
    kernelFunc: wGe
  };
  const SGe = {
    kernelName: gb,
    backendName: "cpu",
    kernelFunc: ({ inputs: n, backend: e }) => {
      const { x: t } = n, r = e;
      et(t, "square");
      const i = r.data.get(t.dataId).values, a = new Float32Array(i.length);
      for (let o = 0; o < i.length; ++o) {
        const l = i[o];
        a[o] = l * l;
      }
      return {
        dataId: r.write(a, t.shape, t.dtype),
        shape: t.shape,
        dtype: t.dtype
      };
    }
  };
  const CGe = An(_c, (n, e) => {
    const t = e;
    return isNaN(n) ? NaN : n > 0 ? 1 : t.alpha;
  }), IGe = {
    kernelName: _c,
    backendName: "cpu",
    kernelFunc: CGe
  };
  function kGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { begin: a, end: s, strides: o, beginMask: l, endMask: u, ellipsisMask: c, newAxisMask: h, shrinkAxisMask: d } = r;
    et(i, "stridedSlice");
    const { finalShapeSparse: f, finalShape: p, isIdentity: g, sliceDim0: m, isSimpleSlice: v, begin: y, end: x, strides: b } = Cb(i.shape, a, s, o, l, u, c, h, d);
    let w;
    if (g) w = Hn({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: p
      }
    });
    else if (m || v) {
      B(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
      const _ = Sb(y, x, b), S = Dd({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: y,
          size: _
        }
      });
      w = Hn({
        inputs: {
          x: S
        },
        backend: t,
        attrs: {
          shape: p
        }
      }), t.disposeIntermediateTensorInfo(S);
    } else {
      const _ = t.bufferSync(i), S = See(f, _, b, y);
      w = t.makeTensorInfo(p, S.dtype, S.values);
    }
    return w;
  }
  const TGe = {
    kernelName: mv,
    backendName: "cpu",
    kernelFunc: kGe
  };
  function AGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { separator: i, nGramWidths: a, leftPad: s, rightPad: o, padWidth: l, preserveShortSequences: u } = r, { data: c, dataSplits: h } = e, d = t.data.get(c.dataId).values, f = t.data.get(h.dataId).values, [p, g] = yL(d, f, i, a, s, o, l, u);
    return [
      t.makeTensorInfo([
        p.length
      ], "string", p),
      t.makeTensorInfo(h.shape, "int32", g)
    ];
  }
  const DGe = {
    kernelName: gI,
    backendName: "cpu",
    kernelFunc: AGe
  };
  function RGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { skipEmpty: i } = r, { input: a, delimiter: s } = e;
    if (a.dtype !== "string") throw new Error("Input must be of datatype string");
    if (a.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${a.shape}`);
    if (s.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);
    const o = t.data.get(a.dataId).values, l = t.data.get(s.dataId).values[0], [u, c, h] = xL(o, l, i), d = c.length;
    return [
      t.makeTensorInfo([
        d,
        2
      ], "int32", u),
      t.makeTensorInfo([
        d
      ], "string", c),
      t.makeTensorInfo([
        2
      ], "int32", new Int32Array(h))
    ];
  }
  const $Ge = {
    kernelName: KM,
    backendName: "cpu",
    kernelFunc: RGe
  };
  function NGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { numBuckets: i } = r, { input: a } = e;
    if (a.dtype !== "string") throw new Error("Input must be of datatype string");
    if (i <= 0) throw new Error("Number of buckets must be at least 1");
    const s = t.data.get(a.dataId).values, o = bL(s, i);
    return t.makeTensorInfo(a.shape, "int32", o);
  }
  const EGe = {
    kernelName: ZM,
    backendName: "cpu",
    kernelFunc: NGe
  };
  const MGe = An(ip, (n) => Math.tan(n)), PGe = {
    kernelName: ip,
    backendName: "cpu",
    kernelFunc: MGe
  };
  const LGe = An(ap, (n) => Math.tanh(n)), FGe = {
    kernelName: ap,
    backendName: "cpu",
    kernelFunc: LGe
  };
  function OGe(n) {
    const { inputs: e, backend: t } = n, { tensor: r, indices: i, updates: a } = e, { sliceRank: s, numUpdates: o, sliceSize: l, strides: u, outputSize: c } = Ka(a, i, r.shape), h = false, d = t.bufferSync(i), f = t.bufferSync(a), p = t.bufferSync(r), g = Uh(d, f, r.shape, c, l, o, s, u, p, h);
    return t.makeTensorInfo(r.shape, g.dtype, g.values);
  }
  const BGe = {
    kernelName: db,
    backendName: "cpu",
    kernelFunc: OGe
  };
  function zGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { reps: a } = r;
    et(i, "tile");
    const s = Iee(t.bufferSync(i), a);
    return t.makeTensorInfo(s.shape, s.dtype, s.values);
  }
  const VGe = {
    kernelName: wc,
    backendName: "cpu",
    kernelFunc: zGe
  };
  function WGe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { k: a, sorted: s } = r;
    et(i, "topk");
    const o = t.data.get(i.dataId).values, [l, u] = Tee(o, i.shape, i.dtype, a, s);
    return [
      t.makeTensorInfo(l.shape, l.dtype, l.values),
      t.makeTensorInfo(u.shape, u.dtype, u.values)
    ];
  }
  const GGe = {
    kernelName: vv,
    backendName: "cpu",
    kernelFunc: WGe
  };
  function UGe(n) {
    const { inputs: e, attrs: t, backend: r } = n, { image: i, transforms: a } = e, { interpolation: s, fillMode: o, fillValue: l, outputShape: u } = t, [c, h, d, f] = i.shape, [p, g] = u ?? [
      h,
      d
    ], m = [
      c,
      p,
      g,
      f
    ], v = Be(i.shape), y = v[0], x = v[1], b = v[2], w = Be(m), _ = w[0], S = w[1], I = w[2], C = Yr(i.dtype, X(m));
    C.fill(l);
    const T = r.data.get(i.dataId).values, k = r.data.get(a.dataId).values;
    for (let R = 0; R < c; ++R) {
      const N = a.shape[0] === 1 ? k : k.subarray(R * 8, R * 8 + 8);
      for (let E = 0; E < p; ++E) for (let A = 0; A < g; ++A) for (let M = 0; M < f; ++M) {
        let $;
        const L = N[6] * A + N[7] * E + 1;
        if (L === 0) continue;
        const F = (N[0] * A + N[1] * E + N[2]) / L, O = (N[3] * A + N[4] * E + N[5]) / L, z = yU(F, d, o), V = yU(O, h, o);
        switch (s) {
          case "nearest":
            $ = KGe(T, h, d, y, x, b, R, V, z, M, l);
            break;
          case "bilinear":
            $ = ZGe(T, h, d, y, x, b, R, V, z, M, l);
            break;
          default:
            throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${s}`);
        }
        const H = R * _ + E * S + A * I + M;
        C[H] = $;
      }
      return r.makeTensorInfo(m, i.dtype, C);
    }
    return {
      dataId: r.write(C, m, i.dtype),
      shape: i.shape,
      dtype: i.dtype
    };
  }
  const HGe = {
    kernelName: yv,
    backendName: "cpu",
    kernelFunc: UGe
  };
  function yU(n, e, t) {
    switch (t) {
      case "reflect":
        return XGe(n, e);
      case "wrap":
        return YGe(n, e);
      case "nearest":
        return jGe(n, e);
      case "constant":
      default:
        return qGe(n);
    }
  }
  function XGe(n, e) {
    let t = n;
    if (t < 0) if (e <= 1) t = 0;
    else {
      const r = 2 * e;
      t < r && (t = r * Math.trunc(-t / r) + t), t = t < -e ? t + r : -t - 1;
    }
    else if (t > e - 1) if (e <= 1) t = 0;
    else {
      const r = 2 * e;
      t -= r * Math.trunc(t / r), t >= e && (t = r - t - 1);
    }
    return md(0, t, e - 1);
  }
  function YGe(n, e) {
    let t = n;
    if (t < 0) if (e <= 1) t = 0;
    else {
      const r = e - 1;
      t += e * (Math.trunc(-t / r) + 1);
    }
    else if (t > e - 1) if (e <= 1) t = 0;
    else {
      const r = e - 1;
      t -= e * Math.trunc(t / r);
    }
    return md(0, t, e - 1);
  }
  function qGe(n, e) {
    return n;
  }
  function jGe(n, e) {
    return md(0, n, e - 1);
  }
  function Xy(n, e, t, r, i, a, s, o, l, u, c) {
    const h = s * r + o * i + l * a + u;
    return 0 <= o && o < e && 0 <= l && l < t ? n[h] : c;
  }
  function KGe(n, e, t, r, i, a, s, o, l, u, c) {
    const h = Math.round(o), d = Math.round(l);
    return Xy(n, e, t, r, i, a, s, h, d, u, c);
  }
  function ZGe(n, e, t, r, i, a, s, o, l, u, c) {
    const h = Math.floor(o), d = Math.floor(l), f = h + 1, p = d + 1, g = (p - l) * Xy(n, e, t, r, i, a, s, h, d, u, c) + (l - d) * Xy(n, e, t, r, i, a, s, h, p, u, c), m = (p - l) * Xy(n, e, t, r, i, a, s, f, d, u, c) + (l - d) * Xy(n, e, t, r, i, a, s, f, p, u, c);
    return (f - o) * g + (o - h) * m;
  }
  function QGe(n) {
    const { inputs: e, attrs: t, backend: r } = n, { axis: i } = t, { x: a } = e;
    et(a, "unique");
    const s = r.data.get(a.dataId).values, { outputValues: o, outputShape: l, indices: u } = _L(s, i, a.shape, a.dtype);
    return [
      r.makeTensorInfo(l, a.dtype, o),
      r.makeTensorInfo([
        u.length
      ], "int32", u)
    ];
  }
  const JGe = {
    kernelName: mI,
    backendName: "cpu",
    kernelFunc: QGe
  };
  function e4e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { value: i } = e;
    let { axis: a } = r;
    a < 0 && (a += i.shape.length);
    const s = i.shape.length, o = i.shape[a], l = new Array(s - 1);
    let u = 0;
    for (let f = 0; f < s; f++) f !== a && (l[u++] = i.shape[f]);
    const c = new Array(s).fill(0), h = i.shape.slice();
    h[a] = 1;
    const d = new Array(o);
    for (let f = 0; f < d.length; f++) {
      c[a] = f;
      const p = Dd({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: c,
          size: h
        }
      });
      d[f] = Hn({
        inputs: {
          x: p
        },
        backend: t,
        attrs: {
          shape: l
        }
      }), t.disposeIntermediateTensorInfo(p);
    }
    return d;
  }
  const t4e = {
    kernelName: xv,
    backendName: "cpu",
    kernelFunc: e4e
  };
  function n4e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, segmentIds: a } = e, { numSegments: s } = r;
    et(i, "unsortedSegmentSum");
    const o = i.shape.length, l = a.shape.length, u = [], c = [], h = o - l;
    let d = a;
    for (let p = 0; p < h; ++p) {
      const g = qS({
        inputs: {
          input: d
        },
        backend: t,
        attrs: {
          dim: p + 1
        }
      });
      d = g, c.push(g);
    }
    for (let p = 0; p < s; ++p) {
      const g = Sc(p, "int32"), m = t.makeTensorInfo([], "int32", g), v = qJ({
        inputs: {
          a: m,
          b: d
        },
        backend: t
      }), y = fc({
        inputs: {
          x: v
        },
        backend: t,
        attrs: {
          dtype: "float32"
        }
      }), x = r2({
        inputs: {
          a: y,
          b: i
        },
        backend: t
      }), b = Vb({
        inputs: {
          x
        },
        backend: t,
        attrs: {
          axis: 0,
          keepDims: false
        }
      });
      u.push(b), c.push(m), c.push(v), c.push(y), c.push(x), c.push(b);
    }
    const f = Gee({
      inputs: u,
      backend: t,
      attrs: {
        axis: 0
      }
    });
    return c.forEach((p) => t.disposeIntermediateTensorInfo(p)), f;
  }
  const r4e = {
    kernelName: mb,
    backendName: "cpu",
    kernelFunc: n4e
  };
  const i4e = [
    QOe,
    EFe,
    eBe,
    nBe,
    BFe,
    iBe,
    sBe,
    lBe,
    cBe,
    dBe,
    pBe,
    mBe,
    yBe,
    wBe,
    SBe,
    kBe,
    ABe,
    RBe,
    NBe,
    KOe,
    MBe,
    LBe,
    OBe,
    VFe,
    zBe,
    FFe,
    GFe,
    WBe,
    MFe,
    UBe,
    XBe,
    YBe,
    jBe,
    ZBe,
    JBe,
    tze,
    rze,
    aze,
    oze,
    uze,
    hze,
    fze,
    gze,
    vze,
    yze,
    bze,
    _ze,
    Cze,
    Ize,
    kze,
    Tze,
    Dze,
    Nze,
    GOe,
    Mze,
    UFe,
    Wze,
    HFe,
    Gze,
    YFe,
    jze,
    Kze,
    Qze,
    jFe,
    ZFe,
    eVe,
    nVe,
    iVe,
    sVe,
    JFe,
    tOe,
    PFe,
    lVe,
    HBe,
    cVe,
    dVe,
    pVe,
    UOe,
    rOe,
    aOe,
    mVe,
    oOe,
    yVe,
    wVe,
    SVe,
    kVe,
    AVe,
    RVe,
    $Ve,
    uOe,
    EVe,
    PVe,
    FVe,
    BVe,
    VVe,
    GVe,
    HVe,
    hOe,
    YVe,
    KVe,
    JVe,
    fOe,
    gOe,
    nWe,
    aWe,
    lWe,
    vOe,
    cWe,
    dWe,
    fWe,
    Uee,
    vWe,
    XOe,
    bOe,
    xWe,
    wWe,
    SWe,
    IWe,
    LFe,
    M$,
    TWe,
    YOe,
    qOe,
    jOe,
    DWe,
    $We,
    EWe,
    PWe,
    FWe,
    OWe,
    zWe,
    AOe,
    WWe,
    YWe,
    jWe,
    JWe,
    ROe,
    tGe,
    rGe,
    aGe,
    $Oe,
    ZVe,
    lGe,
    cGe,
    dGe,
    pGe,
    mGe,
    yGe,
    bGe,
    _Ge,
    MOe,
    SGe,
    LOe,
    OOe,
    IGe,
    TGe,
    DGe,
    $Ge,
    EGe,
    WOe,
    Rze,
    PGe,
    FGe,
    BGe,
    VGe,
    GGe,
    HGe,
    yOe,
    JGe,
    t4e,
    r4e,
    hWe
  ];
  for (const n of i4e) vI(n);
  const Eh = {}, xw = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
  };
  function a4e(n, e) {
    Eh[n] = e;
  }
  function uo(n, e) {
    if (!(n in Eh) || e != null) {
      const r = o4e(n, e);
      if (r !== null) Eh[n] = r;
      else return console.log("Could not get context for WebGL version", n), null;
    }
    const t = Eh[n];
    return t == null || t.isContextLost() ? (delete Eh[n], uo(n)) : (t.disable(t.DEPTH_TEST), t.disable(t.STENCIL_TEST), t.disable(t.BLEND), t.disable(t.DITHER), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SAMPLE_COVERAGE), t.enable(t.SCISSOR_TEST), t.enable(t.CULL_FACE), t.cullFace(t.BACK), Eh[n]);
  }
  function s4e(n) {
    if (!ne().getBool("IS_SAFARI") && typeof OffscreenCanvas < "u" && n === 2) return new OffscreenCanvas(300, 150);
    if (typeof document < "u") return document.createElement("canvas");
    throw new Error("Cannot create a canvas in this context");
  }
  function o4e(n, e) {
    if (n !== 1 && n !== 2) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    const t = e ?? s4e(n);
    return t.addEventListener("webglcontextlost", (r) => {
      r.preventDefault(), delete Eh[n];
    }, false), ne().getBool("SOFTWARE_WEBGL_ENABLED") && (xw.failIfMajorPerformanceCaveat = false), n === 1 ? t.getContext("webgl", xw) || t.getContext("experimental-webgl", xw) : t.getContext("webgl2", xw);
  }
  var fx;
  (function(n) {
    n[n.DENSE = 0] = "DENSE", n[n.SHARED_BATCH = 1] = "SHARED_BATCH";
  })(fx || (fx = {}));
  var Ba;
  (function(n) {
    n[n.RENDER = 0] = "RENDER", n[n.UPLOAD = 1] = "UPLOAD", n[n.PIXELS = 2] = "PIXELS", n[n.DOWNLOAD = 3] = "DOWNLOAD";
  })(Ba || (Ba = {}));
  var ti;
  (function(n) {
    n[n.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", n[n.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", n[n.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", n[n.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", n[n.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
  })(ti || (ti = {}));
  function Wb(n, e) {
    return [
      e,
      n
    ];
  }
  function l4e(n, e) {
    return n * e;
  }
  function bw(n) {
    const e = X(n), t = Math.ceil(e / 4);
    return s$(t);
  }
  function Rv(n, e) {
    return [
      Math.max(1, Math.ceil(e / 2)),
      Math.max(1, Math.ceil(n / 2))
    ];
  }
  function u4e(n, e) {
    const [t, r] = Rv(n, e);
    return t * r * 4;
  }
  function kL(n, e) {
    const t = n;
    let r, i, a, s, o, l, u, c, h, d;
    return ne().getNumber("WEBGL_VERSION") === 2 ? (r = t.R32F, i = t.R16F, a = t.RGBA16F, s = t.RGBA32F, o = t.RED, u = 4, c = 1, h = t.HALF_FLOAT, d = t.FLOAT, l = t.RGBA8) : (r = n.RGBA, i = n.RGBA, a = n.RGBA, s = t.RGBA, o = n.RGBA, u = 4, c = 4, h = e != null ? e.HALF_FLOAT_OES : null, d = n.FLOAT, l = n.RGBA), {
      internalFormatFloat: r,
      internalFormatHalfFloat: i,
      internalFormatPackedHalfFloat: a,
      internalFormatPackedFloat: s,
      textureFormatFloat: o,
      downloadTextureFormat: l,
      downloadUnpackNumChannels: u,
      defaultNumChannels: c,
      textureTypeHalfFloat: h,
      textureTypeFloat: d
    };
  }
  function ze(n, e) {
    const t = e();
    return ne().getBool("DEBUG") && c4e(n), t;
  }
  function c4e(n) {
    const e = n.getError();
    if (e !== n.NO_ERROR) throw new Error("WebGL Error: " + p4e(n, e));
  }
  const h4e = 596e-10, d4e = 65504;
  function f4e(n) {
    return !!(ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || n === 0 || h4e < Math.abs(n) && Math.abs(n) < d4e);
  }
  function p4e(n, e) {
    switch (e) {
      case n.NO_ERROR:
        return "NO_ERROR";
      case n.INVALID_ENUM:
        return "INVALID_ENUM";
      case n.INVALID_VALUE:
        return "INVALID_VALUE";
      case n.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case n.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case n.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case n.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return `Unknown error code ${e}`;
    }
  }
  function ww(n, e) {
    return cu(n, () => n.getExtension(e), 'Extension "' + e + '" not supported on this browser.');
  }
  function g4e(n, e) {
    const t = cu(n, () => n.createShader(n.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
    if (ze(n, () => n.shaderSource(t, e)), ze(n, () => n.compileShader(t)), n.getShaderParameter(t, n.COMPILE_STATUS) === false) throw console.log(n.getShaderInfoLog(t)), new Error("Failed to compile vertex shader.");
    return t;
  }
  function m4e(n, e) {
    const t = cu(n, () => n.createShader(n.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
    if (ze(n, () => n.shaderSource(t, e)), ze(n, () => n.compileShader(t)), ne().get("ENGINE_COMPILE_ONLY")) return t;
    if (n.getShaderParameter(t, n.COMPILE_STATUS) === false) throw Hee(e, n.getShaderInfoLog(t)), new Error("Failed to compile fragment shader.");
    return t;
  }
  const v4e = /ERROR: [0-9]+:([0-9]+):/g;
  function Hee(n, e) {
    const t = v4e.exec(e);
    if (t == null) {
      console.log(`Couldn't parse line number in error: ${e}`), console.log(n);
      return;
    }
    const r = +t[1], i = n.split(`
`), a = i.length.toString().length + 2, s = i.map((h, d) => Tg((d + 1).toString(), a) + h);
    let o = 0;
    for (let h = 0; h < s.length; h++) o = Math.max(s[h].length, o);
    const l = s.slice(0, r - 1), u = s.slice(r - 1, r), c = s.slice(r);
    console.log(l.join(`
`)), console.log(e.split(`
`)[0]), console.log(`%c ${Tg(u[0], o)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c.join(`
`));
  }
  function y4e(n) {
    return cu(n, () => n.createProgram(), "Unable to create WebGLProgram.");
  }
  function x4e(n, e) {
    if (ze(n, () => n.linkProgram(e)), !ne().get("ENGINE_COMPILE_ONLY") && n.getProgramParameter(e, n.LINK_STATUS) === false) throw console.log(n.getProgramInfoLog(e)), new Error("Failed to link vertex and fragment shaders.");
  }
  function gA(n, e) {
    if (ze(n, () => n.validateProgram(e)), n.getProgramParameter(e, n.VALIDATE_STATUS) === false) throw console.log(n.getProgramInfoLog(e)), new Error("Shader program validation failed.");
  }
  function b4e(n, e) {
    const t = cu(n, () => n.createBuffer(), "Unable to create WebGLBuffer");
    return ze(n, () => n.bindBuffer(n.ARRAY_BUFFER, t)), ze(n, () => n.bufferData(n.ARRAY_BUFFER, e, n.STATIC_DRAW)), t;
  }
  function w4e(n, e) {
    const t = cu(n, () => n.createBuffer(), "Unable to create WebGLBuffer");
    return ze(n, () => n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t)), ze(n, () => n.bufferData(n.ELEMENT_ARRAY_BUFFER, e, n.STATIC_DRAW)), t;
  }
  function _4e(n) {
    return cu(n, () => n.createTexture(), "Unable to create WebGLTexture.");
  }
  function S4e(n, e) {
    const t = ne().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (n <= 0 || e <= 0) {
      const r = `[${n}x${e}]`;
      throw new Error("Requested texture size " + r + " is invalid.");
    }
    if (n > t || e > t) {
      const r = `[${n}x${e}]`, i = `[${t}x${t}]`;
      throw new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU " + i + ".");
    }
  }
  function C4e(n) {
    return cu(n, () => n.createFramebuffer(), "Unable to create WebGLFramebuffer.");
  }
  function xU(n, e, t, r, i, a, s) {
    const o = n.getAttribLocation(e, t);
    return o === -1 ? false : (ze(n, () => n.bindBuffer(n.ARRAY_BUFFER, r)), ze(n, () => n.vertexAttribPointer(o, i, n.FLOAT, false, a, s)), ze(n, () => n.enableVertexAttribArray(o)), true);
  }
  function I4e(n, e, t) {
    R4e(n, t), ze(n, () => n.activeTexture(n.TEXTURE0 + t)), ze(n, () => n.bindTexture(n.TEXTURE_2D, e));
  }
  function k4e(n, e, t) {
    return cu(n, () => n.getUniformLocation(e, t), 'uniform "' + t + '" not present in program.');
  }
  function T4e(n, e, t) {
    return n.getUniformLocation(e, t);
  }
  function A4e(n, e, t, r) {
    ze(n, () => I4e(n, e, r)), ze(n, () => n.uniform1i(t, r));
  }
  function mA(n, e, t) {
    ze(n, () => n.bindFramebuffer(n.FRAMEBUFFER, t)), ze(n, () => n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e, 0));
  }
  function bU(n, e) {
    ze(n, () => n.bindFramebuffer(n.FRAMEBUFFER, e)), ze(n, () => n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, null, 0));
  }
  function _w(n) {
    const e = n.checkFramebufferStatus(n.FRAMEBUFFER);
    if (e !== n.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + D4e(n, e));
  }
  function D4e(n, e) {
    switch (e) {
      case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case n.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return `unknown error ${e}`;
    }
  }
  function cu(n, e, t) {
    const r = ze(n, () => e());
    if (r == null) throw new Error(t);
    return r;
  }
  function R4e(n, e) {
    const t = n.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r = e + n.TEXTURE0;
    if (r < n.TEXTURE0 || r > t) {
      const i = `[gl.TEXTURE0, gl.TEXTURE${t}]`;
      throw new Error(`textureUnit must be in ${i}.`);
    }
  }
  function tm(n, e = 2) {
    return X(n.slice(0, n.length - e));
  }
  function nm(n) {
    if (n.length === 0) throw Error("Cannot get rows and columns of an empty shape array.");
    return [
      n.length > 1 ? n[n.length - 2] : 1,
      n[n.length - 1]
    ];
  }
  function Sw(n) {
    let e = [
      1,
      1,
      1
    ];
    return n.length === 0 || n.length === 1 && n[0] === 1 || (e = [
      tm(n),
      ...nm(n)
    ]), e;
  }
  function $4e(n, e = false) {
    let t = ne().getNumber("WEBGL_MAX_TEXTURE_SIZE"), r = ne().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
    r === 1 / 0 && ne().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (r = t / 2), e && (t = t * 2, r = r * 2, n = n.map((o, l) => l >= n.length - 2 ? GM(n[l]) : n[l]), n.length === 1 && (n = [
      2,
      n[0]
    ])), n.length !== 2 && (n = vc(n).newShape);
    let i = X(n), a = null;
    n.length <= 1 && i <= t ? a = [
      1,
      i
    ] : n.length === 2 && n[0] <= t && n[1] <= t ? a = n : n.length === 3 && n[0] * n[1] <= t && n[2] <= t ? a = [
      n[0] * n[1],
      n[2]
    ] : n.length === 3 && n[0] <= t && n[1] * n[2] <= t ? a = [
      n[0],
      n[1] * n[2]
    ] : n.length === 4 && n[0] * n[1] * n[2] <= t && n[3] <= t ? a = [
      n[0] * n[1] * n[2],
      n[3]
    ] : n.length === 4 && n[0] <= t && n[1] * n[2] * n[3] <= t && (a = [
      n[0],
      n[1] * n[2] * n[3]
    ]);
    const s = a != null && Math.max(...a) > r && Math.min(...a) <= (e ? 2 : 1) && Math.min(...a) > 0;
    if (a == null || s) if (e) {
      const o = tm(n);
      let l = 2, u = 2;
      n.length && ([l, u] = nm(n)), i = o * (l / 2) * (u / 2), a = s$(i).map((c) => c * 2);
    } else a = s$(i);
    return a;
  }
  function Cw(n) {
    return n % 2 === 0;
  }
  function KS(n, e) {
    if (n = n.slice(-2), e = e.slice(-2), Jt(n, e) || !n.length || !e.length || n[0] === 0 || n[1] === 0 || e[0] === 0 || e[1] === 0) return true;
    if (n.length !== e.length) {
      const t = n[n.length - 1], r = e[e.length - 1];
      if (t === r || Cw(t) && Cw(r) && (n[0] === 1 || e[0] === 1)) return true;
    }
    return n[1] === e[1] && Cw(n[0]) && Cw(e[0]);
  }
  let vA, yA;
  function N4e(n) {
    if (vA == null) {
      const e = uo(n);
      vA = e.getParameter(e.MAX_TEXTURE_SIZE);
    }
    return vA;
  }
  function E4e(n) {
    if (yA == null) {
      const e = uo(n);
      yA = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, yA);
  }
  function M4e(n) {
    if (n === 0) return 0;
    let e;
    const t = uo(n);
    return xs(t, "EXT_disjoint_timer_query_webgl2") && n === 2 ? e = 2 : xs(t, "EXT_disjoint_timer_query") ? e = 1 : e = 0, e;
  }
  function xs(n, e) {
    return n.getExtension(e) != null;
  }
  function wU(n) {
    try {
      if (uo(n) != null) return true;
    } catch (e) {
      return console.log("Error when getting WebGL context: ", e), false;
    }
    return false;
  }
  function P4e(n) {
    if (n === 0) return false;
    const e = uo(n);
    if (n === 1) {
      if (!xs(e, "OES_texture_float")) return false;
    } else if (!xs(e, "EXT_color_buffer_float")) return false;
    return L$(e);
  }
  function L4e(n) {
    if (n === 0) return false;
    const e = uo(n);
    if (n === 1) {
      if (!xs(e, "OES_texture_float") || !xs(e, "WEBGL_color_buffer_float")) return false;
    } else {
      if (xs(e, "EXT_color_buffer_float")) return L$(e);
      const r = "EXT_color_buffer_half_float";
      if (xs(e, r)) {
        const i = e.getExtension(r);
        return F4e(e, i);
      }
      return false;
    }
    return L$(e);
  }
  function L$(n) {
    const e = kL(n), t = n.createTexture();
    n.bindTexture(n.TEXTURE_2D, t), n.texImage2D(n.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);
    const a = n.createFramebuffer();
    n.bindFramebuffer(n.FRAMEBUFFER, a), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0);
    const s = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
    return n.bindTexture(n.TEXTURE_2D, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteTexture(t), n.deleteFramebuffer(a), s;
  }
  function F4e(n, e) {
    const t = kL(n, e), r = n.createTexture();
    n.bindTexture(n.TEXTURE_2D, r), n.texImage2D(n.TEXTURE_2D, 0, t.internalFormatHalfFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeHalfFloat, null);
    const s = n.createFramebuffer();
    n.bindFramebuffer(n.FRAMEBUFFER, s), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, r, 0);
    const o = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE;
    return n.bindTexture(n.TEXTURE_2D, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteTexture(r), n.deleteFramebuffer(s), o;
  }
  function O4e(n) {
    return n !== 2 ? false : uo(n).fenceSync != null;
  }
  function Gb(n, e) {
    Array.isArray(n) || (n = [
      n
    ]), n.forEach((t) => {
      t != null && B(t.dtype !== "complex64", () => `${e} does not support complex64 tensors in the WebGL backend.`);
    });
  }
  const nt = ne();
  nt.registerFlag("HAS_WEBGL", () => nt.getNumber("WEBGL_VERSION") > 0);
  nt.registerFlag("WEBGL_VERSION", () => wU(2) ? 2 : wU(1) ? 1 : 0);
  nt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
  nt.registerFlag("WEBGL_BUFFER_SUPPORTED", () => nt.get("WEBGL_VERSION") === 2);
  nt.registerFlag("WEBGL_CPU_FORWARD", () => true);
  nt.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
  nt.registerFlag("WEBGL_PACK", () => nt.getBool("HAS_WEBGL"));
  nt.registerFlag("WEBGL_PACK_NORMALIZATION", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_PACK_CLIP", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_PACK_REDUCE", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_LAZILY_UNPACK", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_CONV_IM2COL", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", () => nt.getBool("WEBGL_PACK"));
  nt.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => N4e(nt.getNumber("WEBGL_VERSION")));
  nt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => E4e(nt.getNumber("WEBGL_VERSION")));
  nt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    const n = nt.getNumber("WEBGL_VERSION");
    return n === 0 ? 0 : M4e(n);
  });
  nt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => nt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !u9());
  nt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => P4e(nt.getNumber("WEBGL_VERSION")));
  nt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => nt.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : nt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));
  nt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => L4e(nt.getNumber("WEBGL_VERSION")));
  nt.registerFlag("WEBGL_FENCE_API_ENABLED", () => O4e(nt.getNumber("WEBGL_VERSION")));
  nt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => nt.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0);
  nt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (n) => {
    if (typeof n != "number") throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);
    if (n < 0 && n !== -1) throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`);
  });
  nt.registerFlag("WEBGL_FLUSH_THRESHOLD", () => u9() ? 1 : -1, (n) => {
    if (typeof n != "number") throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);
    if (n < 0 && n !== -1) throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`);
  });
  nt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  nt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
  nt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
  nt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
  nt.registerFlag("WEBGL_EXP_CONV", () => false);
  nt.registerFlag("SOFTWARE_WEBGL_ENABLED", () => nt.getBool("IS_TEST"));
  nt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0);
  nt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false);
  nt.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false);
  nt.registerFlag("ENGINE_COMPILE_ONLY", () => false);
  function Bi() {
    let n, e, t, r, i, a, s, o, l, u;
    return ne().getNumber("WEBGL_VERSION") === 2 ? (n = "#version 300 es", e = "in", t = "out", r = "in", i = "texture", a = "outputColor", s = "out vec4 outputColor;", o = ne().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "", l = "", u = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (n = "", e = "attribute", t = "varying", r = "varying", i = "texture2D", a = "gl_FragColor", s = "", o = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, l = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, u = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), {
      version: n,
      attribute: e,
      varyingVs: t,
      varyingFs: r,
      texture2D: i,
      output: a,
      defineOutput: s,
      defineSpecialNaN: o,
      defineSpecialInf: l,
      defineRound: u
    };
  }
  function hp(n, e, t = "index") {
    const r = Be(e);
    return r.map((i, a) => {
      const s = `int ${n[a]} = ${t} / ${i}`, o = a === r.length - 1 ? `int ${n[a + 1]} = ${t} - ${n[a]} * ${i}` : `index -= ${n[a]} * ${i}`;
      return `${s}; ${o};`;
    }).join("");
  }
  function i2(n, e, t = "index") {
    const r = Be(e);
    return r.map((i, a) => {
      const s = `int ${n[a]} = ${t} / outShapeStrides[${a}]`, o = a === r.length - 1 ? `int ${n[a + 1]} = ${t} - ${n[a]} * outShapeStrides[${a}]` : `index -= ${n[a]} * outShapeStrides[${a}]`;
      return `${s}; ${o};`;
    }).join("");
  }
  function B4e(n, e) {
    const t = n.length, r = n.map((a) => `${e}[${a}]`), i = new Array(t - 1);
    i[t - 2] = r[t - 1];
    for (let a = t - 3; a >= 0; --a) i[a] = `(${i[a + 1]} * ${r[a + 1]})`;
    return i;
  }
  function z4e(n, e, t = "index") {
    const r = n.map((a, s) => s), i = B4e(r, e);
    return i.map((a, s) => {
      const o = `int ${n[s]} = ${t} / ${i[s]}`, l = s === i.length - 1 ? `int ${n[s + 1]} = ${t} - ${n[s]} * ${i[s]}` : `index -= ${n[s]} * ${i[s]}`;
      return `${o}; ${l};`;
    }).join("");
  }
  function TL(n) {
    const e = Be(n).map((t) => t.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`;
  }
  function AL() {
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
  }
  const Xee = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
  const { getBroadcastDims: Yee } = RMe;
  function V4e(n, e, t) {
    const r = [];
    if (n.forEach((f) => {
      const p = X(f.shapeInfo.logicalShape);
      if (f.shapeInfo.isUniform ? r.push(`uniform float ${f.name}${p > 1 ? `[${p}]` : ""};`) : (r.push(`uniform sampler2D ${f.name};`), r.push(`uniform int offset${f.name};`)), t.enableShapeUniforms) {
        const { uniformShape: g } = DL(t.packedInputs, f.shapeInfo.logicalShape, f.shapeInfo.texShape);
        switch (g.length) {
          case 1:
            r.push(`uniform int ${f.name}Shape;`);
            break;
          case 2:
            r.push(`uniform ivec2 ${f.name}Shape;`);
            break;
          case 3:
            r.push(`uniform ivec3 ${f.name}Shape;`);
            break;
          case 4:
            r.push(`uniform ivec4 ${f.name}Shape;`);
            break;
        }
        r.push(`uniform ivec2 ${f.name}TexShape;`);
      }
    }), t.enableShapeUniforms) {
      switch (e.logicalShape.length) {
        case 1:
          r.push("uniform int outShape;");
          break;
        case 2:
          r.push("uniform ivec2 outShape;"), r.push("uniform int outShapeStrides;");
          break;
        case 3:
          r.push("uniform ivec3 outShape;"), r.push("uniform ivec2 outShapeStrides;");
          break;
        case 4:
          r.push("uniform ivec4 outShape;"), r.push("uniform ivec3 outShapeStrides;");
          break;
      }
      r.push("uniform ivec2 outTexShape;");
    }
    t.customUniforms && t.customUniforms.forEach((f) => {
      r.push(`uniform ${f.type} ${f.name}${f.arrayIndex ? `[${f.arrayIndex}]` : ""};`);
    });
    const i = r.join(`
`), a = n.map((f) => W4e(f, e, t.packedInputs, t.enableShapeUniforms)).join(`
`), s = e.texShape, o = Bi(), l = H4e(o);
    let u, c, h = q4e(o);
    return e.isPacked ? (u = G4e(e.logicalShape, s, t.enableShapeUniforms), c = Y4e(o)) : (u = U4e(e.logicalShape, s, t.enableShapeUniforms), c = X4e(o)), t.packedInputs && (h += Q4e), [
      h,
      l,
      c,
      i,
      u,
      a,
      t.userCode
    ].join(`
`);
  }
  function $v(n, e = false) {
    const t = n.shapeInfo.logicalShape;
    switch (t.length) {
      case 0:
        return cUe(n, e);
      case 1:
        return dUe(n, e);
      case 2:
        return pUe(n, e);
      case 3:
        return mUe(n, e);
      case 4:
        return yUe(n, e);
      case 5:
        return xUe(n);
      case 6:
        return bUe(n);
      default:
        throw new Error(`${t.length}-D input sampling is not yet supported`);
    }
  }
  function qee(n, e) {
    switch (n.shapeInfo.logicalShape.length) {
      case 0:
        return uUe(n);
      case 1:
        return hUe(n, e);
      case 2:
        return fUe(n, e);
      case 3:
        return gUe(n, e);
      default:
        return vUe(n, e);
    }
  }
  function W4e(n, e, t = false, r) {
    let i = "";
    t ? i += qee(n, r) : i += $v(n, r);
    const a = n.shapeInfo.logicalShape, s = e.logicalShape;
    return a.length <= s.length && (t ? i += wUe(n, e) : i += _Ue(n, e)), i;
  }
  function G4e(n, e, t) {
    switch (n.length) {
      case 0:
        return jee();
      case 1:
        return J4e(n, e, t);
      case 2:
        return oUe(n, e, t);
      case 3:
        return tUe(n, e, t);
      default:
        return rUe(n, e, t);
    }
  }
  function U4e(n, e, t) {
    switch (n.length) {
      case 0:
        return jee();
      case 1:
        return eUe(n, e, t);
      case 2:
        return lUe(n, e, t);
      case 3:
        return nUe(n, e, t);
      case 4:
        return iUe(n, e, t);
      case 5:
        return aUe(n, e);
      case 6:
        return sUe(n, e);
      default:
        throw new Error(`${n.length}-D output sampling is not yet supported`);
    }
  }
  function H4e(n) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `;
  }
  function X4e(n) {
    return `
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `;
  }
  function Y4e(n) {
    return `
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `;
  }
  function q4e(n) {
    return `${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${j4e}
    ${K4e}
    ${Z4e}
  `;
  }
  const j4e = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, K4e = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, Z4e = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, Q4e = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
  function jee() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
  }
  function J4e(n, e, t) {
    const r = [
      Math.ceil(e[0] / 2),
      Math.ceil(e[1] / 2)
    ];
    return r[0] === 1 ? t ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    ` : r[1] === 1 ? t ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    ` : t ? `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `;
  }
  function eUe(n, e, t) {
    return e[0] === 1 ? t ? `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    ` : e[1] === 1 ? t ? `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    ` : t ? `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `;
  }
  function tUe(n, e, t) {
    if (t) return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
    const r = [
      Math.ceil(e[0] / 2),
      Math.ceil(e[1] / 2)
    ], i = Math.ceil(n[2] / 2), a = i * Math.ceil(n[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  function nUe(n, e, t) {
    if (t) return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${i2([
      "r",
      "c",
      "d"
    ], n)}
    return ivec3(r, c, d);
  }
`;
    const r = hp([
      "r",
      "c",
      "d"
    ], n);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `;
  }
  function rUe(n, e, t) {
    if (t) return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
    const r = [
      Math.ceil(e[0] / 2),
      Math.ceil(e[1] / 2)
    ], i = Math.ceil(n[n.length - 1] / 2), a = i * Math.ceil(n[n.length - 2] / 2);
    let s = a, o = "", l = "b, r, c";
    for (let u = 2; u < n.length - 1; u++) s *= n[n.length - u - 1], o = `
      int b${u} = index / ${s};
      index -= b${u} * ${s};
    ` + o, l = `b${u}, ` + l;
    return `
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `;
  }
  function iUe(n, e, t) {
    if (t) return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${i2([
      "r",
      "c",
      "d",
      "d2"
    ], n)}
      return ivec4(r, c, d, d2);
    }
  `;
    const r = hp([
      "r",
      "c",
      "d",
      "d2"
    ], n);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  function aUe(n, e) {
    const t = hp([
      "r",
      "c",
      "d",
      "d2",
      "d3"
    ], n);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
  }
  function sUe(n, e) {
    const t = hp([
      "r",
      "c",
      "d",
      "d2",
      "d3",
      "d4"
    ], n);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
  }
  function oUe(n, e, t) {
    const r = [
      Math.ceil(e[0] / 2),
      Math.ceil(e[1] / 2)
    ];
    if (Jt(n, e)) return t ? `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;
    const i = Math.ceil(n[1] / 2);
    return t ? `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `;
  }
  function lUe(n, e, t) {
    return Jt(n, e) ? t ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    ` : n[1] === 1 ? t ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : n[0] === 1 ? t ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : t ? `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `;
  }
  function dp(n) {
    return `offset${n}`;
  }
  function uUe(n) {
    const e = n.name, t = "get" + e.charAt(0).toUpperCase() + e.slice(1), r = Bi();
    return `
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `;
  }
  function cUe(n, e) {
    const t = n.name, r = "get" + t.charAt(0).toUpperCase() + t.slice(1);
    if (n.shapeInfo.isUniform) return `float ${r}() {return ${t};}`;
    const [i, a] = n.shapeInfo.texShape;
    if (i === 1 && a === 1) return `
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;
    const s = dp(t);
    if (e) return `
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${s});
      return sampleTexture(${t}, uv);
    }
  `;
    const [o, l] = n.shapeInfo.texShape;
    return `
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${s});
      return sampleTexture(${t}, uv);
    }
  `;
  }
  function hUe(n, e) {
    const t = n.name, r = "get" + t.charAt(0).toUpperCase() + t.slice(1), i = n.shapeInfo.texShape, a = Bi();
    if (e) return `
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${t}, uv);
    }
  `;
    const s = [
      Math.ceil(i[0] / 2),
      Math.ceil(i[1] / 2)
    ];
    return `
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${s[0]}, ${s[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }
  `;
  }
  function dUe(n, e) {
    const t = n.name, r = "get" + t.charAt(0).toUpperCase() + t.slice(1);
    if (n.shapeInfo.isUniform) return `
      float ${r}(int index) {
        ${Nv(n)}
      }
    `;
    const i = n.shapeInfo.texShape, a = i[0], s = i[1];
    if (s === 1 && a === 1) return `
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;
    const o = dp(t);
    return s === 1 ? e ? `
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    ` : `
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${t}, uv);
      }
    ` : a === 1 ? e ? `
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    ` : `
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${s}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    ` : e ? `
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  ` : `
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${s}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `;
  }
  function fUe(n, e) {
    const t = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = n.shapeInfo.texShape, s = a[0], o = a[1], l = Bi();
    if (a != null && Jt(t, a)) return e ? `
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    ` : `
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${s}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;
    if (e) return `
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;
    const u = [
      Math.ceil(a[0] / 2),
      Math.ceil(a[1] / 2)
    ], c = Math.ceil(t[1] / 2);
    return `
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;
  }
  function pUe(n, e) {
    const t = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = n.shapeInfo.texShape;
    if (a != null && Jt(t, a)) {
      if (e) return `
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;
      const d = a[0], f = a[1];
      return `
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;
    }
    const { newShape: s, keptDims: o } = vc(t), l = s;
    if (l.length < t.length) {
      const d = Ev(n, l), f = [
        "row",
        "col"
      ];
      return `
      ${$v(d, e)}
      float ${i}(int row, int col) {
        return ${i}(${Mv(f, o)});
      }
    `;
    }
    if (n.shapeInfo.isUniform) return `
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Nv(n)}
      }
    `;
    const u = a[0], c = a[1], h = dp(r);
    return c === 1 ? e ? `
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    ` : `
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  ` : u === 1 ? e ? `
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    ` : `
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  ` : e ? `
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    ` : `
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`;
  }
  function gUe(n, e) {
    const t = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = n.shapeInfo.texShape, s = [
      Math.ceil(a[0] / 2),
      Math.ceil(a[1] / 2)
    ];
    if (t[0] === 1) {
      const d = t.slice(1), f = [
        1,
        2
      ], p = Ev(n, d), g = [
        "b",
        "row",
        "col"
      ];
      return `
        ${qee(p, e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Mv(g, f)});
        }
      `;
    }
    const o = Bi();
    if (e) return `
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;
    const l = s[0], u = s[1], c = Math.ceil(t[2] / 2), h = c * Math.ceil(t[1] / 2);
    return `
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;
  }
  function mUe(n, e) {
    const t = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = t[1] * t[2], s = t[2], { newShape: o, keptDims: l } = vc(t), u = o;
    if (u.length < t.length) {
      const g = Ev(n, u), m = [
        "row",
        "col",
        "depth"
      ];
      return `
        ${$v(g, e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Mv(m, l)});
        }
      `;
    }
    if (n.shapeInfo.isUniform) return `
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${s}, 1)));
        ${Nv(n)}
      }
    `;
    const c = n.shapeInfo.texShape, h = c[0], d = c[1], f = n.shapeInfo.flatOffset;
    if (d === a && f == null) return e ? `
      float ${i}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    ` : `
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${s}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;
    if (d === s && f == null) return e ? `
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    ` : `
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;
    const p = dp(r);
    return e ? `
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    ` : `
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${s} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `;
  }
  function vUe(n, e) {
    const t = n.name, r = "get" + t.charAt(0).toUpperCase() + t.slice(1), i = Bi();
    if (e) return `
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;
    const a = n.shapeInfo.logicalShape, s = a.length, o = n.shapeInfo.texShape, l = [
      Math.ceil(o[0] / 2),
      Math.ceil(o[1] / 2)
    ], u = l[0], c = l[1], h = Math.ceil(a[s - 1] / 2);
    let d = h * Math.ceil(a[s - 2] / 2), f = "int b, int row, int col", p = `b * ${d} + (row / 2) * ${h} + (col / 2)`;
    for (let g = 2; g < s - 1; g++) f = `int b${g}, ` + f, d *= a[s - g - 1], p = `b${g} * ${d} + ` + p;
    return `
    vec4 ${r}(${f}) {
      int index = ${p};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${i.texture2D}(${t}, uv);
    }
  `;
  }
  function yUe(n, e) {
    const t = n.shapeInfo.logicalShape, r = n.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), a = t[3], s = t[2] * a, o = t[1] * s, { newShape: l, keptDims: u } = vc(t);
    if (l.length < t.length) {
      const y = Ev(n, l), x = [
        "row",
        "col",
        "depth",
        "depth2"
      ];
      return `
      ${$v(y, e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Mv(x, u)});
      }
    `;
    }
    if (n.shapeInfo.isUniform) return `
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${s}, ${a}, 1)));
        ${Nv(n)}
      }
    `;
    const c = n.shapeInfo.flatOffset, h = n.shapeInfo.texShape, d = h[0], f = h[1], p = `int stride2 = ${r}Shape[3];`, g = `int stride1 = ${r}Shape[2] * stride2;`, m = `int stride0 = ${r}Shape[1] * stride1;`;
    if (f === o && c == null) return e ? `
      float ${i}(int row, int col, int depth, int depth2) {
        ${p}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    ` : `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${s}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;
    if (f === a && c == null) return e ? `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    ` : `
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1] * t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;
    const v = dp(r);
    return e ? `
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${v});
      return sampleTexture(${r}, uv);
    }
  ` : `
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${s} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${v});
      return sampleTexture(${r}, uv);
    }
  `;
  }
  function xUe(n) {
    const e = n.shapeInfo.logicalShape, t = n.name, r = "get" + t.charAt(0).toUpperCase() + t.slice(1), i = e[4], a = e[3] * i, s = e[2] * a, o = e[1] * s, { newShape: l, keptDims: u } = vc(e);
    if (l.length < e.length) {
      const g = Ev(n, l), m = [
        "row",
        "col",
        "depth",
        "depth2",
        "depth3"
      ];
      return `
      ${$v(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Mv(m, u)});
      }
    `;
    }
    if (n.shapeInfo.isUniform) return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${s}, ${a}, ${i})) +
          depth3;
        ${Nv(n)}
      }
    `;
    const c = n.shapeInfo.flatOffset, h = n.shapeInfo.texShape, d = h[0], f = h[1];
    if (f === o && c == null) return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${s}, ${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;
    if (f === i && c == null) return `
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1] * e[2] * e[3]},
               ${e[2] * e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;
    const p = dp(t);
    return `
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${s} + depth * ${a} +
          depth2 * ${i} + depth3 + ${p};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `;
  }
  function bUe(n) {
    const e = n.shapeInfo.logicalShape, t = n.name, r = "get" + t.charAt(0).toUpperCase() + t.slice(1), { newShape: i, keptDims: a } = vc(e);
    if (i.length < e.length) {
      const m = Ev(n, i), v = [
        "row",
        "col",
        "depth",
        "depth2",
        "depth3",
        "depth4"
      ];
      return `
      ${$v(m)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Mv(v, a)});
      }
    `;
    }
    const s = e[5], o = e[4] * s, l = e[3] * o, u = e[2] * l, c = e[1] * u;
    if (n.shapeInfo.isUniform) return `
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${s}, 1)));
        ${Nv(n)}
      }
    `;
    const h = n.shapeInfo.flatOffset, d = n.shapeInfo.texShape, f = d[0], p = d[1];
    if (p === c && h == null) return `
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${s})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;
    if (p === s && h == null) return `
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1] * e[2] * e[3] * e[4]},
               ${e[2] * e[3] * e[4]},
               ${e[3] * e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;
    const g = dp(t);
    return `
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${s} + depth4 + ${g};
      vec2 uv = uvFromFlat(${f}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `;
  }
  function Nv(n) {
    const e = n.name, t = X(n.shapeInfo.logicalShape);
    return t < 2 ? `return ${e};` : `
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `;
  }
  function wUe(n, e) {
    const t = n.name, r = t.charAt(0).toUpperCase() + t.slice(1), i = "get" + r + "AtOutCoords", a = n.shapeInfo.logicalShape.length, s = e.logicalShape.length, o = Yee(n.shapeInfo.logicalShape, e.logicalShape), l = Pn(s), u = s - a;
    let c;
    const h = [
      "x",
      "y",
      "z",
      "w",
      "u",
      "v"
    ];
    a === 0 ? c = "" : s < 2 && o.length >= 1 ? c = "coords = 0;" : c = o.map((y) => `coords.${h[y + u]} = 0;`).join(`
`);
    let d = "";
    s < 2 && a > 0 ? d = "coords" : d = n.shapeInfo.logicalShape.map((y, x) => `coords.${h[x + u]}`).join(", ");
    let f = "return outputValue;";
    const g = X(n.shapeInfo.logicalShape) === 1, v = X(e.logicalShape) === 1;
    if (a === 1 && !g && !v) f = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    else if (g && !v) s === 1 ? f = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : f = `
        return vec4(outputValue.x);
      `;
    else if (o.length) {
      const y = a - 2, x = a - 1;
      o.indexOf(y) > -1 && o.indexOf(x) > -1 ? f = "return vec4(outputValue.x);" : o.indexOf(y) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : o.indexOf(x) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);");
    }
    return `
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${d});
      ${f}
    }
  `;
  }
  function _Ue(n, e) {
    const t = n.name, r = t.charAt(0).toUpperCase() + t.slice(1), i = "get" + r + "AtOutCoords", a = e.texShape, s = n.shapeInfo.texShape, o = n.shapeInfo.logicalShape.length, l = e.logicalShape.length;
    if (!n.shapeInfo.isUniform && o === l && n.shapeInfo.flatOffset == null && Jt(s, a)) return `
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;
    const u = Pn(l), c = Yee(n.shapeInfo.logicalShape, e.logicalShape), h = l - o;
    let d;
    const f = [
      "x",
      "y",
      "z",
      "w",
      "u",
      "v"
    ];
    o === 0 ? d = "" : l < 2 && c.length >= 1 ? d = "coords = 0;" : d = c.map((g) => `coords.${f[g + h]} = 0;`).join(`
`);
    let p = "";
    return l < 2 && o > 0 ? p = "coords" : p = n.shapeInfo.logicalShape.map((g, m) => `coords.${f[m + h]}`).join(", "), `
    float ${i}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${r}(${p});
    }
  `;
  }
  function Pn(n) {
    if (n <= 1) return "int";
    if (n === 2) return "ivec2";
    if (n === 3) return "ivec3";
    if (n === 4) return "ivec4";
    if (n === 5) return "ivec5";
    if (n === 6) return "ivec6";
    throw Error(`GPU for rank ${n} is not yet supported`);
  }
  function DL(n, e, t) {
    const { newShape: r, keptDims: i } = vc(e), a = e.length, s = n && a === 3 && e[0] === 1, o = s ? e.slice(1) : r, l = !n && a > 1 && !Jt(e, t) && r.length < a || s;
    return {
      useSqueezeShape: l,
      uniformShape: l ? o : e,
      keptDims: i
    };
  }
  function Ev(n, e) {
    const t = JSON.parse(JSON.stringify(n));
    return t.shapeInfo.logicalShape = e, t;
  }
  function Mv(n, e) {
    return e.map((t) => n[t]).join(", ");
  }
  function SUe(n, e, t, r) {
    const i = t.map((c, h) => {
      const d = {
        logicalShape: c.shape,
        texShape: c.isUniform ? null : c.texData.texShape,
        isUniform: c.isUniform,
        isPacked: c.isUniform ? false : c.texData.isPacked,
        flatOffset: null
      };
      return c.texData != null && c.texData.slice != null && c.texData.slice.flatOffset > 0 && (d.flatOffset = c.texData.slice.flatOffset), {
        name: e.variableNames[h],
        shapeInfo: d
      };
    }), a = i.map((c) => c.shapeInfo), s = {
      logicalShape: r.shape,
      texShape: r.texData.texShape,
      isUniform: false,
      isPacked: r.texData.isPacked,
      flatOffset: null
    }, o = V4e(i, s, e), l = m4e(n.gl, o), u = n.createProgram(l);
    return ne().get("ENGINE_COMPILE_ONLY") ? {
      program: e,
      fragmentShader: l,
      source: o,
      webGLProgram: u,
      inShapeInfos: a,
      outShapeInfo: s,
      variablesLocations: null,
      customUniformLocations: null,
      infLoc: null,
      nanLoc: null,
      outShapeLocation: null,
      outShapeStridesLocation: null,
      outTexShapeLocation: null
    } : (n.buildVao(u), Object.assign({
      program: e,
      fragmentShader: l,
      source: o,
      webGLProgram: u,
      inShapeInfos: a,
      outShapeInfo: s
    }, Kee(n, e, u)));
  }
  function Kee(n, e, t) {
    const r = [], i = [];
    let a, s, o, l = null, u = null;
    u = n.getUniformLocation(t, "NAN", false), ne().getNumber("WEBGL_VERSION") === 1 && (l = n.getUniformLocation(t, "INFINITY", false));
    const c = false;
    for (const h of e.variableNames) {
      const d = {
        name: h,
        uniform: n.getUniformLocation(t, h, c),
        offset: n.getUniformLocation(t, `offset${h}`, c)
      };
      e.enableShapeUniforms && (d.shape = n.getUniformLocation(t, `${h}Shape`, c), d.texShape = n.getUniformLocation(t, `${h}TexShape`, c)), r.push(d);
    }
    if (e.enableShapeUniforms && (a = n.getUniformLocation(t, "outShape", c), o = n.getUniformLocation(t, "outShapeStrides", c), s = n.getUniformLocation(t, "outTexShape", c)), e.customUniforms) for (const h of e.customUniforms) i.push(n.getUniformLocation(t, h.name, c));
    return {
      variablesLocations: r,
      customUniformLocations: i,
      infLoc: l,
      nanLoc: u,
      outShapeLocation: a,
      outShapeStridesLocation: o,
      outTexShapeLocation: s
    };
  }
  function _U(n, e) {
    if (n.length !== e.length) throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);
    n.forEach((t, r) => {
      const i = t.logicalShape, a = e[r], s = a.shape;
      if (!Jt(i, s)) throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${s} must match`);
      if (t.isUniform && a.isUniform) return;
      const o = t.texShape, l = a.isUniform ? null : a.texData.texShape;
      if (!Jt(o, l)) throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`);
    });
  }
  function CUe(n, e, t, r, i) {
    e.program.enableShapeUniforms || (_U(e.inShapeInfos, t), _U([
      e.outShapeInfo
    ], [
      r
    ]));
    const a = r.texData.texture, s = r.texData.texShape;
    r.texData.isPacked ? n.setOutputPackedMatrixTexture(a.texture, s[0], s[1]) : n.setOutputMatrixTexture(a.texture, s[0], s[1]), n.setProgram(e.webGLProgram), n.bindVertexArray(e.webGLProgram.vao), ne().getNumber("WEBGL_VERSION") === 1 && e.infLoc !== null && n.gl.uniform1f(e.infLoc, 1 / 0), e.nanLoc !== null && n.gl.uniform1f(e.nanLoc, NaN);
    for (let l = 0; l < t.length; ++l) {
      const u = t[l], { uniform: c, offset: h, shape: d, texShape: f } = e.variablesLocations[l];
      if (d) {
        const { uniformShape: p } = DL(e.program.packedInputs, u.shape, u.texData.texShape);
        switch (p.length) {
          case 1:
            n.gl.uniform1iv(d, new Int32Array(p));
            break;
          case 2:
            n.gl.uniform2iv(d, new Int32Array(p));
            break;
          case 3:
            n.gl.uniform3iv(d, new Int32Array(p));
            break;
          case 4:
            n.gl.uniform4iv(d, new Int32Array(p));
            break;
        }
      }
      if (f && n.gl.uniform2i(f, u.texData.texShape[0], u.texData.texShape[1]), c != null) {
        if (u.isUniform) {
          if (X(u.shape) < 2) n.gl.uniform1f(c, u.uniformValues[0]);
          else {
            let p = u.uniformValues;
            p instanceof Float32Array || (p = new Float32Array(p)), n.gl.uniform1fv(c, p);
          }
          continue;
        }
        u.texData.slice != null && h != null && n.gl.uniform1i(h, u.texData.slice.flatOffset), n.setInputMatrixTexture(u.texData.texture.texture, c, l);
      }
    }
    const o = e.outShapeLocation;
    if (o) switch (r.shape.length) {
      case 1:
        n.gl.uniform1iv(o, new Int32Array(r.shape));
        break;
      case 2:
        n.gl.uniform2iv(o, new Int32Array(r.shape));
        break;
      case 3:
        n.gl.uniform3iv(o, new Int32Array(r.shape));
        break;
      case 4:
        n.gl.uniform4iv(o, new Int32Array(r.shape));
        break;
    }
    if (e.outShapeStridesLocation) {
      const l = Be(r.shape);
      switch (r.shape.length) {
        case 2:
          n.gl.uniform1iv(e.outShapeStridesLocation, new Int32Array(l));
          break;
        case 3:
          n.gl.uniform2iv(e.outShapeStridesLocation, new Int32Array(l));
          break;
        case 4:
          n.gl.uniform3iv(e.outShapeStridesLocation, new Int32Array(l));
          break;
      }
    }
    if (e.outTexShapeLocation && n.gl.uniform2i(e.outTexShapeLocation, r.texData.texShape[0], r.texData.texShape[1]), e.program.customUniforms && i) for (let l = 0; l < e.program.customUniforms.length; ++l) {
      const u = e.program.customUniforms[l], c = e.customUniformLocations[l], h = i[l];
      if (u.type === "float") n.gl.uniform1fv(c, h);
      else if (u.type === "vec2") n.gl.uniform2fv(c, h);
      else if (u.type === "vec3") n.gl.uniform3fv(c, h);
      else if (u.type === "vec4") n.gl.uniform4fv(c, h);
      else if (u.type === "int") n.gl.uniform1iv(c, h);
      else if (u.type === "ivec2") n.gl.uniform2iv(c, h);
      else if (u.type === "ivec3") n.gl.uniform3iv(c, h);
      else if (u.type === "ivec4") n.gl.uniform4iv(c, h);
      else throw Error(`uniform type ${u.type} is not supported yet.`);
    }
    n.executeProgram();
  }
  function IUe(n, e, t) {
    let r = "";
    e.concat(t).forEach((s) => {
      const o = s.texData != null && s.texData.slice != null && s.texData.slice.flatOffset > 0;
      if (n.enableShapeUniforms && !s.isUniform) {
        const l = s.texData.texShape, { useSqueezeShape: u, uniformShape: c, keptDims: h } = DL(n.packedInputs, s.shape, l);
        let d = "", f = "", p = "";
        if (c.length === 1 && n.packedInputs) {
          const w = [
            Math.ceil(l[0] / 2),
            Math.ceil(l[1] / 2)
          ];
          d = `${w[0] > 1}_${w[1] > 1}`;
        } else if (c.length === 2 && !n.packedInputs) f = `${c[0] > 1}_${c[1] > 1}`;
        else if (c.length > 2 && !n.packedInputs) {
          const w = Be(c);
          p = `${w[0] === l[1]}_${w[w.length - 1] === l[1]}`;
        }
        const g = s.shape.length, m = c.length === 2 && Jt(s.shape, l), v = X(s.shape) === 1, y = lc(s.shape, t.shape), x = !n.packedInputs && g === t.shape.length && Jt(l, t.texData.texShape), b = n.packedInputs || c.length > 2 ? "" : `${l[0] > 1}_${l[1] > 1}`;
        r += `${g}_${x}_${u ? h : ""}_${c.length}_${v}_${y}_${m}_${d}_${f}_${p}_${b}_${o}`;
      } else {
        const l = s.isUniform ? "uniform" : s.texData.texShape;
        r += `${s.shape}_${l}_${o}`;
      }
    });
    const i = n.userCode;
    let a = n.constructor.name;
    return a += "_" + r + "_" + i + `${ne().getNumber("WEBGL_VERSION")}`, a;
  }
  function xi(n) {
    return ne().getBool("WEBGL_USE_SHAPES_UNIFORMS") && n <= 4;
  }
  class kUe {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = fx.DENSE, this.customUniforms = [
        {
          name: "texShape",
          type: "ivec2"
        }
      ];
      const t = Bi();
      this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? i2([
        "r",
        "c",
        "d"
      ], e) : hp([
        "r",
        "c",
        "d"
      ], e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `;
    }
  }
  class TUe {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = fx.DENSE, this.customUniforms = [
        {
          name: "texShape",
          type: "ivec2"
        }
      ];
      const t = Bi();
      this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? i2([
        "r",
        "c",
        "d"
      ], e) : hp([
        "r",
        "c",
        "d"
      ], e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `;
    }
  }
  class AUe {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.outTexUsage = Ba.DOWNLOAD;
      const t = Bi();
      this.outputShape = e, this.userCode = `
      ${Xee}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `;
    }
  }
  class DUe {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = Ba.DOWNLOAD;
      const t = Bi();
      this.outputShape = e, this.userCode = `
      ${Xee}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `;
    }
  }
  const RUe = {
    R: 0,
    G: 1,
    B: 2,
    A: 3
  };
  class SU {
    constructor(e, t = false, r = "RGBA") {
      this.variableNames = [
        "A"
      ], this.customUniforms = [
        {
          name: "texShape",
          type: "ivec2"
        }
      ];
      const i = Bi();
      this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length);
      let a = "result";
      t && (a = "floor(result * 255. + 0.5)");
      let s = "";
      for (let o = 0; o < r.length; o++) {
        const l = r[o];
        s += `
          if(offset == ${o}) {
            result = values[${RUe[l]}];
          }`;
      }
      this.userCode = `
      ${this.enableShapeUniforms ? AL() : TL(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${s}
        }
        ${i.output} = vec4(${a}, 0., 0., 0.);
      }
    `;
    }
  }
  class $Ue {
    constructor(e, t = false) {
      this.variableNames = [
        "A"
      ], this.packedInputs = false, this.packedOutput = true, this.customUniforms = [
        {
          name: "texShape",
          type: "ivec2"
        }
      ];
      const r = Bi();
      this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length);
      let i = "", a = "result";
      t && (a = "floor(result * 255. + 0.5)");
      for (let s = 0; s <= 1; s++) for (let o = 0; o <= 1; o++) {
        const l = s * 2 + o;
        i += `
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms ? "outShape[2]" : `${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms ? "outShape[1]" : `${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `;
      }
      this.userCode = `
        ${this.enableShapeUniforms ? AL() : TL(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${r.output} = ${a};
        }
    `;
    }
  }
  function NUe(n) {
    const e = Bi(), t = `${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return g4e(n, t);
  }
  function EUe(n) {
    const e = new Float32Array([
      -1,
      1,
      0,
      0,
      1,
      -1,
      -1,
      0,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      -1,
      0,
      1,
      0
    ]);
    return b4e(n, e);
  }
  function MUe(n) {
    const e = new Uint16Array([
      0,
      1,
      2,
      2,
      1,
      3
    ]);
    return w4e(n, e);
  }
  function Ub(n, e, t, r, i, a) {
    S4e(e, t);
    const s = _4e(n), o = n.TEXTURE_2D;
    return ze(n, () => n.bindTexture(o, s)), ze(n, () => n.texParameteri(o, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE)), ze(n, () => n.texParameteri(o, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE)), ze(n, () => n.texParameteri(o, n.TEXTURE_MIN_FILTER, n.NEAREST)), ze(n, () => n.texParameteri(o, n.TEXTURE_MAG_FILTER, n.NEAREST)), ne().getNumber("WEBGL_VERSION") === 1 ? ze(n, () => n.texImage2D(o, 0, r, e, t, 0, i, a, null)) : ze(n, () => n.texStorage2D(o, 1, r, e, t)), ze(n, () => n.bindTexture(n.TEXTURE_2D, null)), {
      texture: s,
      texShape: [
        t,
        e
      ]
    };
  }
  function Zee(n) {
    return n.internalFormatFloat;
  }
  function PUe(n, e, t, r) {
    const [i, a] = Wb(e, t);
    return Ub(n, i, a, Zee(r), r.textureFormatFloat, n.FLOAT);
  }
  function Qee(n) {
    return n.internalFormatHalfFloat;
  }
  function LUe(n, e, t, r) {
    const [i, a] = Wb(e, t);
    return Ub(n, i, a, Qee(r), r.textureFormatFloat, r.textureTypeHalfFloat);
  }
  function Jee(n) {
    return n.downloadTextureFormat;
  }
  function FUe(n, e, t, r) {
    const [i, a] = Wb(e, t);
    return Ub(n, i, a, Jee(r), n.RGBA, n.UNSIGNED_BYTE);
  }
  function ete(n) {
    return n.internalFormatPackedFloat;
  }
  function OUe(n, e, t, r) {
    const [i, a] = Rv(e, t);
    return Ub(n, i, a, ete(r), n.RGBA, n.FLOAT);
  }
  function tte(n) {
    return n.internalFormatPackedHalfFloat;
  }
  function BUe(n, e, t, r) {
    const [i, a] = Rv(e, t);
    return Ub(n, i, a, tte(r), n.RGBA, r.textureTypeHalfFloat);
  }
  function zUe(n, e, t) {
    return ze(n, () => n.bindBuffer(n.ARRAY_BUFFER, t)), xU(n, e, "clipSpacePos", t, 3, 20, 0) && xU(n, e, "uv", t, 2, 20, 12);
  }
  function VUe(n, e, t, r, i, a) {
    ze(n, () => n.bindTexture(n.TEXTURE_2D, e));
    let s, o, l;
    i instanceof Uint8Array ? (s = new Uint8Array(t * r * 4), o = n.UNSIGNED_BYTE, l = n.RGBA) : (s = new Float32Array(t * r * 4), o = n.FLOAT, l = a.internalFormatPackedFloat), s.set(i), ne().getNumber("WEBGL_VERSION") === 2 ? ze(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, t, r, n.RGBA, o, s)) : ze(n, () => n.texImage2D(n.TEXTURE_2D, 0, l, t, r, 0, n.RGBA, o, s)), ze(n, () => n.bindTexture(n.TEXTURE_2D, null));
  }
  function WUe(n, e, t) {
    ze(n, () => n.bindTexture(n.TEXTURE_2D, e)), t.data instanceof Uint8Array ? ne().getNumber("WEBGL_VERSION") === 2 ? ze(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, t.width, t.height, n.RGBA, n.UNSIGNED_BYTE, t.data)) : ze(n, () => n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, t.width, t.height, 0, n.RGBA, n.UNSIGNED_BYTE, t.data)) : ne().getNumber("WEBGL_VERSION") === 2 ? ze(n, () => n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, t)) : ze(n, () => n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t)), ze(n, () => n.bindTexture(n.TEXTURE_2D, null));
  }
  function GUe(n, e, t, r) {
    const i = n.createBuffer();
    ze(n, () => n.bindBuffer(n.PIXEL_PACK_BUFFER, i));
    const o = 4 * 4 * e * t;
    return ze(n, () => n.bufferData(n.PIXEL_PACK_BUFFER, o, n.STREAM_READ)), ze(n, () => n.readPixels(0, 0, t, e, n.RGBA, n.FLOAT, 0)), ze(n, () => n.bindBuffer(n.PIXEL_PACK_BUFFER, null)), i;
  }
  function UUe(n, e, t) {
    const r = n, i = new Float32Array(t);
    return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, i), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), i;
  }
  function HUe(n, e, t, r) {
    const [i, a] = Wb(e, t), s = 4, o = new Uint8Array(l4e(e * t, s));
    return ze(n, () => n.readPixels(0, 0, i, a, r.downloadTextureFormat, n.UNSIGNED_BYTE, o)), new Float32Array(o.buffer);
  }
  function XUe(n, e, t, r, i, a, s, o) {
    const l = n, u = new Float32Array(u4e(a, s));
    return l.bindBuffer(l.PIXEL_PACK_BUFFER, e), l.getBufferSubData(l.PIXEL_PACK_BUFFER, 0, u), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), u;
  }
  function YUe(n, e, t) {
    const r = new Float32Array(e * t * 4);
    return ze(n, () => n.readPixels(0, 0, t, e, n.RGBA, n.FLOAT, r)), r;
  }
  class xA {
    constructor(e) {
      this.outputTexture = null, this.program = null, this.disposed = false, this.itemsToPoll = [];
      const t = ne().getNumber("WEBGL_VERSION");
      if (e != null ? (this.gl = e, a4e(t, e)) : this.gl = uo(t), e = this.gl, ne().getNumber("WEBGL_VERSION") === 2) {
        const a = e;
        this.createVertexArray = () => ze(a, () => a.createVertexArray()), this.bindVertexArray = (s) => ze(a, () => a.bindVertexArray(s)), this.deleteVertexArray = (s) => ze(a, () => a.deleteVertexArray(s)), this.getVertexArray = () => ze(a, () => a.getParameter(a.VERTEX_ARRAY_BINDING));
      } else if (e != null) {
        const a = e.getExtension("OES_vertex_array_object");
        if (a == null) throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
        this.createVertexArray = () => ze(e, () => a.createVertexArrayOES()), this.bindVertexArray = (s) => ze(e, () => a.bindVertexArrayOES(s)), this.deleteVertexArray = (s) => ze(e, () => a.deleteVertexArrayOES(s)), this.getVertexArray = () => ze(e, () => e.getParameter(a.VERTEX_ARRAY_BINDING_OES));
      }
      let r = "WEBGL_color_buffer_float";
      const i = "EXT_color_buffer_half_float";
      if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), ne().getNumber("WEBGL_VERSION") === 1) {
        const a = "OES_texture_float", s = "OES_texture_half_float";
        if (this.textureFloatExtension = ww(this.gl, a), xs(this.gl, s)) this.textureHalfFloatExtension = ww(this.gl, s);
        else if (ne().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        if (this.colorBufferFloatExtension = this.gl.getExtension(r), xs(this.gl, i)) this.colorBufferHalfFloatExtension = ww(this.gl, i);
        else if (ne().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      } else if (r = "EXT_color_buffer_float", xs(this.gl, r)) this.colorBufferFloatExtension = this.gl.getExtension(r);
      else if (xs(this.gl, i)) this.colorBufferHalfFloatExtension = this.gl.getExtension(i);
      else throw new Error("GL context does not support color renderable floats");
      this.vertexBuffer = EUe(this.gl), this.indexBuffer = MUe(this.gl), this.framebuffer = C4e(this.gl), this.textureConfig = kL(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
      return ne().getBool("DEBUG");
    }
    dispose() {
      if (this.disposed) return;
      this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      const e = this.gl;
      ze(e, () => e.finish()), ze(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), ze(e, () => e.deleteFramebuffer(this.framebuffer)), ze(e, () => e.bindBuffer(e.ARRAY_BUFFER, null)), ze(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)), ze(e, () => e.deleteBuffer(this.indexBuffer)), this.disposed = true;
    }
    createFloat32MatrixTexture(e, t) {
      return this.throwIfDisposed(), PUe(this.gl, e, t, this.textureConfig);
    }
    createFloat16MatrixTexture(e, t) {
      return this.throwIfDisposed(), LUe(this.gl, e, t, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(e, t) {
      return this.throwIfDisposed(), FUe(this.gl, e, t, this.textureConfig);
    }
    uploadPixelDataToTexture(e, t) {
      this.throwIfDisposed(), WUe(this.gl, e, t);
    }
    uploadDenseMatrixToTexture(e, t, r, i) {
      this.throwIfDisposed(), VUe(this.gl, e, t, r, i, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(e, t) {
      return this.throwIfDisposed(), BUe(this.gl, e, t, this.textureConfig);
    }
    createPackedMatrixTexture(e, t) {
      return this.throwIfDisposed(), OUe(this.gl, e, t, this.textureConfig);
    }
    deleteMatrixTexture(e) {
      this.throwIfDisposed(), this.outputTexture === e && (bU(this.gl, this.framebuffer), this.outputTexture = null), ze(this.gl, () => this.gl.deleteTexture(e));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(e, t, r) {
      return this.downloadMatrixDriver(e, () => HUe(this.gl, t, r, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(e, t, r, i, a, s) {
      return XUe(this.gl, e, t, r, i, a, s, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(e, t) {
      return UUe(this.gl, e, t);
    }
    createBufferFromTexture(e, t, r) {
      this.bindTextureToFrameBuffer(e);
      const i = GUe(this.gl, t, r, this.textureConfig);
      return this.unbindTextureToFrameBuffer(), i;
    }
    createAndWaitForFence() {
      const e = this.createFence(this.gl);
      return this.pollFence(e);
    }
    createFence(e) {
      let t, r;
      if (ne().getBool("WEBGL_FENCE_API_ENABLED")) {
        const i = e, a = i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
        e.flush(), r = () => {
          const s = i.clientWaitSync(a, 0, 0);
          return s === i.ALREADY_SIGNALED || s === i.CONDITION_SATISFIED;
        }, t = a;
      } else ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), r = () => this.isQueryAvailable(t, ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : r = () => true;
      return {
        query: t,
        isFencePassed: r
      };
    }
    downloadMatrixFromPackedTexture(e, t, r) {
      return this.downloadMatrixDriver(e, () => YUe(this.gl, t, r));
    }
    createProgram(e) {
      this.throwIfDisposed();
      const t = this.gl;
      this.vertexShader == null && (this.vertexShader = NUe(t));
      const r = y4e(t);
      ze(t, () => t.attachShader(r, this.vertexShader)), ze(t, () => t.attachShader(r, e)), x4e(t, r);
      const i = Object.assign(r, {
        vao: this.createVertexArray()
      });
      return this.debug && gA(t, i), i;
    }
    buildVao(e) {
      this.setProgram(e), this.bindVertexArray(e.vao);
      const t = this.gl;
      ze(t, () => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer)), zUe(t, e, this.vertexBuffer);
    }
    deleteProgram(e) {
      this.throwIfDisposed(), e === this.program && (this.program = null), e != null && (ze(this.gl, () => this.gl.deleteProgram(e)), this.deleteVertexArray(e.vao));
    }
    setProgram(e) {
      this.throwIfDisposed(), this.program = e, this.program != null && this.debug && gA(this.gl, this.program), ze(this.gl, () => this.gl.useProgram(e));
    }
    getUniformLocation(e, t, r = true) {
      return this.throwIfDisposed(), r ? k4e(this.gl, e, t) : T4e(this.gl, e, t);
    }
    getAttributeLocation(e, t) {
      return this.throwIfDisposed(), ze(this.gl, () => this.gl.getAttribLocation(e, t));
    }
    getUniformLocationNoThrow(e, t) {
      return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);
    }
    setInputMatrixTexture(e, t, r) {
      this.throwIfDisposed(), this.throwIfNoProgram(), A4e(this.gl, e, t, r);
    }
    setOutputMatrixTexture(e, t, r) {
      this.setOutputMatrixTextureDriver(e, r, t);
    }
    setOutputPackedMatrixTexture(e, t, r) {
      this.throwIfDisposed();
      const [i, a] = Rv(t, r);
      this.setOutputMatrixTextureDriver(e, i, a);
    }
    setOutputMatrixWriteRegion(e, t, r, i) {
      this.setOutputMatrixWriteRegionDriver(r, e, i, t);
    }
    setOutputPackedMatrixWriteRegion(e, t, r, i) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
    debugValidate() {
      this.program != null && gA(this.gl, this.program), _w(this.gl);
    }
    executeProgram() {
      this.throwIfDisposed(), this.throwIfNoProgram();
      const e = this.gl;
      if (this.debug) {
        const t = this.getVertexArray();
        console.assert(t === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate();
      }
      ze(e, () => e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
      this.throwIfDisposed(), ze(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
      return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = ww(this.gl, ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
      return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
      return this.getQueryTimerExtension();
    }
    beginQuery() {
      if (ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const r = this.gl, i = this.getQueryTimerExtensionWebGL2(), a = r.createQuery();
        return r.beginQuery(i.TIME_ELAPSED_EXT, a), a;
      }
      const e = this.getQueryTimerExtensionWebGL1(), t = e.createQueryEXT();
      return e.beginQueryEXT(e.TIME_ELAPSED_EXT, t), t;
    }
    endQuery() {
      if (ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const t = this.gl, r = this.getQueryTimerExtensionWebGL2();
        t.endQuery(r.TIME_ELAPSED_EXT);
        return;
      }
      const e = this.getQueryTimerExtensionWebGL1();
      e.endQueryEXT(e.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(e) {
      return await n4(() => this.disposed || this.isQueryAvailable(e, ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(e, ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }
    getQueryTime(e, t) {
      if (t === 0) return null;
      if (t === 2) {
        const r = this.gl;
        return r.getQueryParameter(e, r.QUERY_RESULT) / 1e6;
      } else {
        const r = this.getQueryTimerExtensionWebGL1();
        return r.getQueryObjectEXT(e, r.QUERY_RESULT_EXT) / 1e6;
      }
    }
    isQueryAvailable(e, t) {
      if (t === 0) return true;
      if (t === 2) {
        const r = this.gl, i = this.getQueryTimerExtensionWebGL2(), a = r.getQueryParameter(e, r.QUERY_RESULT_AVAILABLE);
        return this.disjoint == null && (this.disjoint = this.gl.getParameter(i.GPU_DISJOINT_EXT)), a && !this.disjoint;
      } else {
        const r = this.getQueryTimerExtensionWebGL1(), i = r.getQueryObjectEXT(e, r.QUERY_RESULT_AVAILABLE_EXT);
        return this.disjoint == null && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), i && !this.disjoint;
      }
    }
    pollFence(e) {
      return new Promise((t) => {
        this.addItemToPoll(() => e.isFencePassed(), () => t());
      });
    }
    pollItems() {
      const e = qUe(this.itemsToPoll.map((t) => t.isDoneFn));
      for (let t = 0; t <= e; ++t) {
        const { resolveFn: r } = this.itemsToPoll[t];
        r();
      }
      this.itemsToPoll = this.itemsToPoll.slice(e + 1);
    }
    addItemToPoll(e, t) {
      if (this.itemsToPoll.push({
        isDoneFn: e,
        resolveFn: t
      }), this.itemsToPoll.length > 1) return;
      let r;
      "setTimeoutCustom" in ne().platform && (r = ne().platform.setTimeoutCustom.bind(ne().platform)), n4(() => (this.pollItems(), this.itemsToPoll.length === 0), () => 0, null, r);
    }
    bindTextureToFrameBuffer(e) {
      this.throwIfDisposed(), mA(this.gl, e, this.framebuffer), this.debug && _w(this.gl);
    }
    unbindTextureToFrameBuffer() {
      this.outputTexture != null ? (mA(this.gl, this.outputTexture, this.framebuffer), this.debug && _w(this.gl)) : bU(this.gl, this.framebuffer);
    }
    downloadMatrixDriver(e, t) {
      this.bindTextureToFrameBuffer(e);
      const r = t();
      return this.unbindTextureToFrameBuffer(), r;
    }
    setOutputMatrixTextureDriver(e, t, r) {
      this.throwIfDisposed();
      const i = this.gl;
      mA(i, e, this.framebuffer), this.debug && _w(i), this.outputTexture = e, ze(i, () => i.viewport(0, 0, t, r)), ze(i, () => i.scissor(0, 0, t, r));
    }
    setOutputMatrixWriteRegionDriver(e, t, r, i) {
      this.throwIfDisposed(), ze(this.gl, () => this.gl.scissor(e, t, r, i));
    }
    throwIfDisposed() {
      if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
    }
    throwIfNoProgram() {
      if (this.program == null) throw new Error("No GPU program is currently set.");
    }
  }
  function qUe(n) {
    let e = 0;
    for (; e < n.length && n[e](); ++e) ;
    return e - 1;
  }
  const { addImpl: jUe, bincountImpl: nte, bincountReduceImpl: KUe, bitwiseAndImpl: ZUe, castImpl: QUe, ceilImpl: JUe, concatImpl: eHe, equalImpl: tHe, expImpl: nHe, expm1Impl: rHe, floorImpl: iHe, gatherNdImpl: aHe, gatherV2Impl: sHe, greaterImpl: oHe, greaterEqualImpl: lHe, lessImpl: uHe, lessEqualImpl: cHe, linSpaceImpl: hHe, logImpl: dHe, maxImpl: fHe, maximumImpl: pHe, minimumImpl: gHe, multiplyImpl: mHe, negImpl: vHe, notEqualImpl: yHe, prodImpl: xHe, raggedGatherImpl: bHe, raggedRangeImpl: wHe, raggedTensorToTensorImpl: _He, rangeImpl: SHe, rsqrtImpl: CHe, scatterImpl: IHe, sigmoidImpl: kHe, simpleAbsImpl: rte, sliceImpl: THe, sparseFillEmptyRowsImpl: AHe, sparseReshapeImpl: DHe, sparseSegmentReductionImpl: ite, sqrtImpl: RHe, staticRegexReplaceImpl: $He, stridedSliceImpl: NHe, stringNGramsImpl: EHe, stringSplitImpl: MHe, stringToHashBucketFastImpl: PHe, subImpl: LHe, tileImpl: FHe, topKImpl: OHe, transposeImpl: RL, uniqueImpl: BHe } = Aee;
  function ate(n, e) {
    return [
      "x",
      "y",
      "z",
      "w",
      "u",
      "v"
    ].slice(0, e).map((t) => `${n}.${t}`);
  }
  function Di(n, e) {
    return e === 1 ? [
      n
    ] : ate(n, e);
  }
  function zHe(n, e) {
    if (n === 1) return "rc";
    let t = "";
    for (let r = 0; r < n; r++) t += e[r], r < n - 1 && (t += ",");
    return t;
  }
  class VHe {
    constructor(e) {
      if (this.variableNames = [
        "A"
      ], this.packedInputs = false, this.packedOutput = true, this.outputShape = e, this.rank = e.length, this.enableShapeUniforms = xi(this.outputShape.length), this.rank === 0) this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
      else {
        const t = Di("rc", this.rank), r = Pn(this.rank), i = this.getOutOfBoundsCondition(t), a = this.getSetup(t), s = this.getOutput(t);
        this.userCode = `
        void main() {
          ${r} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${s}));
          }
        }
      `;
      }
    }
    getSourceCoordsArr(e) {
      const t = [];
      for (let r = 0; r <= 1; r++) for (let i = 0; i <= 1; i++) {
        let a = `${r === 0 ? "r" : "rp1"}, ${i === 0 ? "c" : "cp1"}`;
        for (let s = 2; s < this.rank; s++) a = `${e[e.length - 1 - s]},` + a;
        t.push(a);
      }
      return t;
    }
    getOutOfBoundsCondition(e) {
      if (this.rank === 1) return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
      let t = "";
      for (let r = this.rank - 2; r < this.rank; r++) t += `${e[r]} >= ${this.enableShapeUniforms ? `outShape[${r}]` : this.outputShape[r]}`, r < this.rank - 1 && (t += "||");
      return t;
    }
    getSetup(e) {
      if (this.rank === 1) return "";
      const t = e.slice(-2), r = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1], i = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
      return `
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${i};
    `;
    }
    getOutput(e) {
      const t = this.getSourceCoordsArr(e);
      return this.rank === 1 ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`;
    }
  }
  class ste {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "inputShape",
          type: "ivec3"
        }
      ], this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length);
      let r = "";
      for (let i = 0; i < 4; i++) {
        let a = "thisRC = rc;";
        i % 2 === 1 && (a += "thisRC.z += 1;"), i > 1 && (a += "thisRC.y += 1;"), r += `
        ${a}
        ${i > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? "}" : ""}
      `;
      }
      this.userCode = `
      ${WHe(t, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? AL() : TL(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : e[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : e[2]};

        ${r}

        setOutput(result);
      }
    `;
    }
  }
  function WHe(n, e) {
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e ? z4e([
      "r",
      "c",
      "d"
    ], "inputShape") : hp([
      "r",
      "c",
      "d"
    ], n)}
      return ivec3(r, c, d);
    }
  `;
  }
  let GHe = class {
    constructor(e) {
      this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.usedTextures = {}, this.logEnabled = false;
    }
    acquireTexture(e, t, r) {
      const i = IU(t, r), a = kU(e, i, r);
      a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []);
      const s = CU(e, i, this.gpgpu.gl, this.gpgpu.textureConfig, r);
      if (this.freeTextures[a].length > 0) {
        this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= s, this.log();
        const l = this.freeTextures[a].pop();
        return this.usedTextures[a].push(l), l;
      }
      let o;
      return i === ti.PACKED_2X2_FLOAT32 ? o = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : i === ti.PACKED_2X2_FLOAT16 ? o = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : i === ti.UNPACKED_FLOAT32 ? o = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : i === ti.UNPACKED_FLOAT16 ? o = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : i === ti.PACKED_4X1_UNSIGNED_BYTE && (o = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[a].push(o), this.numUsedTextures++, this._numBytesAllocated += s, this.log(), o;
    }
    releaseTexture(e, t, r, i) {
      if (this.freeTextures == null) return;
      const a = IU(r, i), s = kU(t, a, i);
      s in this.freeTextures || (this.freeTextures[s] = []);
      const o = CU(t, a, this.gpgpu.gl, this.gpgpu.textureConfig, i), l = ne().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
      l !== -1 && this._numBytesAllocated > l ? (this.gpgpu.deleteMatrixTexture(e.texture), this._numBytesAllocated -= o) : (this.freeTextures[s].push(e), this.numFreeTextures++, this._numBytesFree += o), this.numUsedTextures--;
      const u = this.usedTextures[s], c = u && u.indexOf(e);
      if (c == null || c < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      u[c] = u[u.length - 1], u.pop(), this.log();
    }
    log() {
      if (!this.logEnabled) return;
      const e = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${e})`);
      const t = this._numBytesFree / this._numBytesAllocated;
      console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * t)}%)`);
    }
    get numBytesAllocated() {
      return this._numBytesAllocated;
    }
    get numBytesFree() {
      return this._numBytesFree;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      if (this.freeTextures != null) {
        for (const e in this.freeTextures) this.freeTextures[e].forEach((t) => {
          this.gpgpu.deleteMatrixTexture(t.texture);
        });
        for (const e in this.usedTextures) this.usedTextures[e].forEach((t) => {
          this.gpgpu.deleteMatrixTexture(t.texture);
        });
        this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
      }
    }
  };
  function UHe(n, e) {
    const t = n;
    if (e === t.R32F) return 4;
    if (e === t.R16F) return 2;
    if (e === t.RGBA32F) return 16;
    if (e === n.RGBA) return 16;
    if (e === t.RGBA16F) return 8;
    if (e === t.RGBA8) return 4;
    throw new Error(`Unknown internal format ${e}`);
  }
  function CU(n, e, t, r, i) {
    const a = HHe(e, r);
    let s;
    if (i) {
      const [l, u] = Rv(n[0], n[1]);
      s = l * u;
    } else {
      const [l, u] = Wb(n[0], n[1]);
      s = l * u;
    }
    const o = UHe(t, a);
    return s * o;
  }
  function HHe(n, e) {
    switch (n) {
      case ti.PACKED_2X2_FLOAT32:
        return ete(e);
      case ti.PACKED_2X2_FLOAT16:
        return tte(e);
      case ti.UNPACKED_FLOAT32:
        return Zee(e);
      case ti.UNPACKED_FLOAT16:
        return Qee(e);
      case ti.PACKED_4X1_UNSIGNED_BYTE:
        return Jee(e);
      default:
        throw new Error(`Unknown physical texture type ${n}`);
    }
  }
  function XHe(n) {
    return ne().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? n ? ti.PACKED_2X2_FLOAT32 : ti.UNPACKED_FLOAT32 : n ? ti.PACKED_2X2_FLOAT16 : ti.UNPACKED_FLOAT16;
  }
  function IU(n, e) {
    if (n === Ba.UPLOAD) return ti.PACKED_2X2_FLOAT32;
    if (n === Ba.RENDER || n == null) return XHe(e);
    if (n === Ba.DOWNLOAD || n === Ba.PIXELS) return ti.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error(`Unknown logical texture type ${n}`);
  }
  function kU(n, e, t) {
    return `${n[0]}_${n[1]}_${e}_${t}`;
  }
  let Wo = class {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length), this.userCode = `
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };
  const Rs = "if (isnan(x)) return x;", YHe = "return x;", TU = "return abs(x);", qHe = "return (x >= 0.0) ? x : (exp(x) - 1.0);", jHe = Rs + `
  return (x < 0.0) ? 0.0 : x;
`, KHe = Rs + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, Ru = "return x;", ZHe = "return 1.0 / (1.0 + exp(-1.0 * x));";
  const QHe = "return x;", JHe = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, e5e = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, t5e = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, n5e = "return 1.0 / (1.0 + exp(-1.0 * x));";
  class Gu {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length), this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  }
  class r5e {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = false, this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length);
      const t = e.length, r = Di("rc", t), i = Pn(t), a = zHe(t, r), s = r.slice(-2), o = t <= 1 ? "rc" : `vec2(${s.join(",")})`;
      this.userCode = `
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `;
    }
  }
  const i5e = j9, a5e = 1e-7, s5e = 1e-4, Iw = {};
  function o5e(n) {
    return n in Iw || (Iw[n] = {}), Iw[n];
  }
  const l5e = ne().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"), u5e = 600;
  function c5e() {
    return ne().global.screen == null ? 1024 : ne().global.screen.height * ne().global.screen.width * window.devicePixelRatio * u5e / 1024 / 1024;
  }
  class a2 extends Zx {
    nextDataId() {
      return a2.nextDataId++;
    }
    constructor(e) {
      if (super(), this.pendingRead = /* @__PURE__ */ new WeakMap(), this.pendingDisposal = /* @__PURE__ */ new WeakSet(), this.dataRefCount = /* @__PURE__ */ new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = false, this.pendingDeletes = 0, this.disposed = false, !ne().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
      let t;
      if (e != null) {
        if (e instanceof xA) t = e;
        else {
          const r = uo(ne().getNumber("WEBGL_VERSION"), e);
          t = new xA(r);
        }
        this.binaryCache = {}, this.gpgpuCreatedLocally = false;
      } else {
        const r = uo(ne().getNumber("WEBGL_VERSION"));
        t = new xA(r), this.binaryCache = o5e(ne().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = true;
      }
      this.gpgpu = t, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new GHe(this.gpgpu), this.numMBBeforeWarning = c5e(), this.texData = new ZC(this, ga());
    }
    numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
    writeTexture(e, t, r, i, a, s) {
      const o = this.makeTensorInfo(t, r), l = this.texData.get(o.dataId);
      l.isPacked = false, l.texture = {
        texture: e,
        texShape: [
          i,
          a
        ]
      }, l.texShape = [
        i,
        a
      ];
      const u = Sw(t), c = new SU(u, false, s), h = this.runWebGLProgram(c, [
        o
      ], r, [
        [
          i,
          a
        ]
      ]);
      return h.shape = t, l.texture = null, this.disposeIntermediateTensorInfo(o), h.dataId;
    }
    write(e, t, r) {
      if ((ne().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || ne().getBool("DEBUG")) && this.checkNumericalProblems(e), r === "complex64" && e != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      const i = {
        id: this.nextDataId()
      };
      return this.texData.set(i, {
        shape: t,
        dtype: r,
        values: e,
        usage: Ba.UPLOAD,
        refCount: 1
      }), i;
    }
    refCount(e) {
      return this.texData.has(e) ? this.texData.get(e).refCount : 0;
    }
    incRef(e) {
      const t = this.texData.get(e);
      t.refCount++;
    }
    decRef(e) {
      if (this.texData.has(e)) {
        const t = this.texData.get(e);
        t.refCount--;
      }
    }
    move(e, t, r, i, a) {
      if (ne().getBool("DEBUG") && this.checkNumericalProblems(t), i === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.texData.set(e, {
        shape: r,
        dtype: i,
        values: t,
        usage: Ba.UPLOAD,
        refCount: a
      });
    }
    disposeIntermediateTensorInfo(e) {
      this.disposeData(e.dataId);
    }
    readSync(e) {
      const t = this.texData.get(e), { values: r, dtype: i, complexTensorInfos: a, slice: s, shape: o, isPacked: l } = t;
      if (s != null) {
        let d;
        l ? d = new Gu(o, Ru) : d = new Wo(o, Ru);
        const f = this.runWebGLProgram(d, [
          {
            dataId: e,
            shape: o,
            dtype: i
          }
        ], i), p = this.readSync(f.dataId);
        return this.disposeIntermediateTensorInfo(f), p;
      }
      if (r != null) return this.convertAndCacheOnCPU(e);
      if (i === "string") return r;
      const u = this.activeTimers != null;
      let c;
      u && (c = hi());
      let h;
      if (i === "complex64") {
        const d = this.readSync(a.real.dataId), f = this.readSync(a.imag.dataId);
        h = ao(d, f);
      } else h = this.getValuesFromTexture(e);
      return u && (this.downloadWaitMs += hi() - c), this.convertAndCacheOnCPU(e, h);
    }
    async read(e) {
      if (this.pendingRead.has(e)) {
        const p = this.pendingRead.get(e);
        return new Promise((g) => p.push(g));
      }
      const t = this.texData.get(e), { values: r, shape: i, slice: a, dtype: s, complexTensorInfos: o, isPacked: l } = t;
      if (a != null) {
        let p;
        l ? p = new Gu(i, Ru) : p = new Wo(i, Ru);
        const g = this.runWebGLProgram(p, [
          {
            dataId: e,
            shape: i,
            dtype: s
          }
        ], s), m = this.read(g.dataId);
        return this.disposeIntermediateTensorInfo(g), m;
      }
      if (r != null) return this.convertAndCacheOnCPU(e);
      if (ne().getBool("DEBUG") && !ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && ne().getNumber("WEBGL_VERSION") === 2) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
      let u = null, c;
      if (s !== "complex64" && ne().get("WEBGL_BUFFER_SUPPORTED")) {
        c = this.decode(e);
        const p = this.texData.get(c.dataId);
        u = this.gpgpu.createBufferFromTexture(p.texture.texture, ...bw(i));
      }
      this.pendingRead.set(e, []), s !== "complex64" && await this.gpgpu.createAndWaitForFence();
      let h;
      if (s === "complex64") {
        const p = await Promise.all([
          this.read(o.real.dataId),
          this.read(o.imag.dataId)
        ]), g = p[0], m = p[1];
        h = ao(g, m);
      } else if (u == null) h = this.getValuesFromTexture(e);
      else {
        const p = X(i);
        h = this.gpgpu.downloadFloat32MatrixFromBuffer(u, p);
      }
      if (c != null && this.disposeIntermediateTensorInfo(c), u != null) {
        const p = this.gpgpu.gl;
        ze(p, () => p.deleteBuffer(u));
      }
      const d = this.convertAndCacheOnCPU(e, h), f = this.pendingRead.get(e);
      return this.pendingRead.delete(e), f.forEach((p) => p(d)), this.pendingDisposal.has(e) && (this.pendingDisposal.delete(e), this.disposeData(e) && ga().removeDataId(e, this), this.pendingDeletes--), d;
    }
    readToGPU(e, t = {}) {
      const r = this.texData.get(e), { values: i, shape: a, slice: s, dtype: o, isPacked: l, texture: u } = r;
      if (o === "complex64") throw new Error("Does not support reading texture for complex64 dtype.");
      if (s != null) {
        let f;
        l ? f = new Gu(a, Ru) : f = new Wo(a, Ru);
        const p = this.runWebGLProgram(f, [
          {
            dataId: e,
            shape: a,
            dtype: o
          }
        ], o), g = this.readToGPU(p, t);
        return this.disposeIntermediateTensorInfo(p), g;
      }
      if (u == null) throw i != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
      const c = this.decode(e, t.customTexShape), h = ga().makeTensorFromTensorInfo(c), d = this.texData.get(c.dataId);
      return Object.assign({
        tensorRef: h
      }, d.texture);
    }
    bufferSync(e) {
      const t = this.readSync(e.dataId);
      if (e.dtype === "string") try {
        const r = t.map((i) => io(i));
        return Nt(e.shape, e.dtype, r);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return Nt(e.shape, e.dtype, t);
    }
    checkNumericalProblems(e) {
      if (e != null) for (let t = 0; t < e.length; t++) {
        const r = e[t];
        if (!f4e(r)) throw ne().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${r} cannot be represented on this device.`);
      }
    }
    getValuesFromTexture(e) {
      const { shape: t, dtype: r, isPacked: i } = this.texData.get(e), a = X(t);
      if (ne().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        const d = this.decode(e), f = this.texData.get(d.dataId), p = this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture, ...bw(t)).subarray(0, a);
        return this.disposeIntermediateTensorInfo(d), p;
      }
      const s = ne().getBool("WEBGL_PACK") && i === true, o = s ? Sw(t) : t, l = s ? new DUe(o) : new AUe(o), u = this.runWebGLProgram(l, [
        {
          shape: o,
          dtype: r,
          dataId: e
        }
      ], "float32"), c = this.texData.get(u.dataId), h = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture, c.texShape[0], c.texShape[1]).subarray(0, a);
      return this.disposeIntermediateTensorInfo(u), h;
    }
    timerAvailable() {
      return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    time(e) {
      const t = this.activeTimers, r = [];
      let i = false;
      this.programTimersStack == null ? (this.programTimersStack = r, i = true) : this.activeTimers.push(r), this.activeTimers = r, e();
      const a = Jl(this.activeTimers.map((l) => l.query)).filter((l) => l != null), s = Jl(this.activeTimers.map((l) => l.name)).filter((l) => l != null);
      this.activeTimers = t, i && (this.programTimersStack = null);
      const o = {
        uploadWaitMs: this.uploadWaitMs,
        downloadWaitMs: this.downloadWaitMs,
        kernelMs: null,
        wallMs: null
      };
      return (async () => {
        if (ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          const l = await Promise.all(a);
          o.kernelMs = z7(l), o.getExtraProfileInfo = () => l.map((u, c) => ({
            name: s[c],
            ms: u
          })).map((u) => `${u.name}: ${u.ms}`).join(", ");
        } else o.kernelMs = {
          error: "WebGL query timers are not supported in this environment."
        };
        return this.uploadWaitMs = 0, this.downloadWaitMs = 0, o;
      })();
    }
    memory() {
      return {
        unreliable: false,
        numBytesInGPU: this.numBytesInGPU,
        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
        numBytesInGPUFree: this.textureManager.numBytesFree
      };
    }
    startTimer() {
      return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
        startMs: hi(),
        endMs: null
      };
    }
    endTimer(e) {
      return ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = hi(), e);
    }
    async getQueryTime(e) {
      if (ne().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) return this.gpgpu.waitForQueryAndGetTime(e);
      const t = e;
      return t.endMs - t.startMs;
    }
    disposeData(e, t = false) {
      if (this.pendingDisposal.has(e)) return false;
      if (!this.texData.has(e)) return true;
      if (t ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !t && this.texData.get(e).refCount > 0) return false;
      if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), this.pendingDeletes++, false;
      this.releaseGPUData(e);
      const { complexTensorInfos: r } = this.texData.get(e);
      return r != null && (this.disposeData(r.real.dataId, t), this.disposeData(r.imag.dataId, t)), this.texData.delete(e), true;
    }
    releaseGPUData(e) {
      const { texture: t, dtype: r, texShape: i, usage: a, isPacked: s, slice: o } = this.texData.get(e), l = o && o.origDataId || e, u = this.dataRefCount.get(l);
      u > 1 ? this.dataRefCount.set(l, u - 1) : (this.dataRefCount.delete(l), t != null && (this.numBytesInGPU -= this.computeBytes(i, r), this.textureManager.releaseTexture(t, i, a, s)));
      const c = this.texData.get(e);
      c.texture = null, c.texShape = null, c.isPacked = false, c.slice = null;
    }
    getTexture(e) {
      return this.uploadToGPU(e), this.texData.get(e).texture.texture;
    }
    getDataInfo(e) {
      return this.texData.get(e);
    }
    shouldExecuteOnCPU(e, t = l5e) {
      return ne().getBool("WEBGL_CPU_FORWARD") && e.every((r) => this.texData.get(r.dataId).texture == null && X(r.shape) < t);
    }
    getGPGPUContext() {
      return this.gpgpu;
    }
    where(e) {
      Fa("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      const t = e.dataSync();
      return i5e(e.shape, t);
    }
    packedUnaryOp(e, t, r) {
      const i = new Gu(e.shape, t), a = this.compileAndRun(i, [
        e
      ], r);
      return ga().makeTensorFromTensorInfo(a);
    }
    abs(e) {
      if (this.shouldExecuteOnCPU([
        e
      ]) && e.dtype !== "complex64") {
        const i = rte(this.texData.get(e.dataId).values);
        return this.makeOutput(e.shape, e.dtype, i);
      }
      if (ne().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e, TU, e.dtype);
      const t = new Wo(e.shape, TU), r = this.compileAndRun(t, [
        e
      ]);
      return ga().makeTensorFromTensorInfo(r);
    }
    makeTensorInfo(e, t, r) {
      let i;
      if (t === "string" && r != null && r.length > 0 && Tm(r[0])) {
        const a = r.map((s) => Bl(s));
        i = this.write(a, e, t);
      } else i = this.write(r, e, t);
      return this.texData.get(i).usage = null, {
        dataId: i,
        shape: e,
        dtype: t
      };
    }
    makeOutput(e, t, r) {
      return ga().makeTensorFromTensorInfo(this.makeTensorInfo(e, t, r), this);
    }
    unpackTensor(e) {
      const t = new r5e(e.shape);
      return this.runWebGLProgram(t, [
        e
      ], e.dtype);
    }
    packTensor(e) {
      const t = new VHe(e.shape);
      return this.runWebGLProgram(t, [
        e
      ], e.dtype, null, true);
    }
    packedReshape(e, t) {
      const r = [
        tm(e.shape),
        ...nm(e.shape)
      ], i = {
        dtype: e.dtype,
        shape: r,
        dataId: e.dataId
      }, a = [
        tm(t),
        ...nm(t)
      ], s = new ste(a, r), o = true, l = [
        r
      ], u = this.runWebGLProgram(s, [
        i
      ], e.dtype, l, o);
      return {
        dataId: u.dataId,
        shape: t,
        dtype: u.dtype
      };
    }
    decode(e, t) {
      const r = this.texData.get(e), { isPacked: i, shape: a, dtype: s } = r;
      if (t != null) {
        const d = X(a), f = t[0] * t[1] * 4;
        B(d <= f, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
      }
      const o = Sw(a);
      let l;
      i ? l = new TUe(o) : l = new kUe(o);
      const u = true, c = [
        t ?? bw(o)
      ], h = this.runWebGLProgram(l, [
        {
          shape: o,
          dtype: s,
          dataId: e
        }
      ], s, c, u, t);
      return {
        dtype: s,
        shape: a,
        dataId: h.dataId
      };
    }
    runWebGLProgram(e, t, r, i, a = false, s) {
      const o = this.makeTensorInfo(e.outputShape, r), l = this.texData.get(o.dataId);
      if (e.packedOutput && (l.isPacked = true), e.outPackingScheme === fx.DENSE) {
        const v = s ?? bw(e.outputShape);
        l.texShape = v.map((y) => y * 2);
      }
      if (e.outTexUsage != null && (l.usage = e.outTexUsage), X(o.shape) === 0) return l.values = Yr(o.dtype, 0), o;
      const u = [], c = t.map((v) => {
        if (v.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
        let y = this.texData.get(v.dataId);
        if (y.texture == null) {
          if (!e.packedInputs && X(v.shape) <= ne().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
            shape: v.shape,
            texData: null,
            isUniform: true,
            uniformValues: y.values
          };
          e.packedInputs && (y.isPacked = true, y.shape = v.shape);
        }
        if (this.uploadToGPU(v.dataId), !!y.isPacked != !!e.packedInputs) v = y.isPacked ? this.unpackTensor(v) : this.packTensor(v), u.push(v), y = this.texData.get(v.dataId);
        else if (y.isPacked && !KS(y.shape, v.shape)) {
          const x = v, b = v.shape;
          v.shape = y.shape, v = this.packedReshape(v, b), u.push(v), y = this.texData.get(v.dataId), x.shape = b;
        }
        return {
          shape: v.shape,
          texData: y,
          isUniform: false
        };
      });
      this.uploadToGPU(o.dataId);
      const h = {
        shape: o.shape,
        texData: l,
        isUniform: false
      }, d = IUe(e, c, h), f = this.getAndSaveBinary(d, () => SUe(this.gpgpu, e, c, h)), p = this.activeTimers != null;
      let g;
      p && (g = this.startTimer()), ne().get("ENGINE_COMPILE_ONLY") || CUe(this.gpgpu, f, c, h, i), u.forEach((v) => this.disposeIntermediateTensorInfo(v)), p && (g = this.endTimer(g), this.activeTimers.push({
        name: e.constructor.name,
        query: this.getQueryTime(g)
      }));
      const m = ne().getNumber("WEBGL_FLUSH_THRESHOLD");
      if (m > 0) {
        const v = hi();
        v - this.lastGlFlushTime > m && (this.gpgpu.gl.flush(), this.lastGlFlushTime = v);
      }
      if (!ne().getBool("WEBGL_LAZILY_UNPACK") && l.isPacked && a === false) {
        const v = this.unpackTensor(o);
        return this.disposeIntermediateTensorInfo(o), v;
      }
      return o;
    }
    compileAndRun(e, t, r, i, a = false) {
      return r = r || t[0].dtype, this.runWebGLProgram(e, t, r, i, a);
    }
    getAndSaveBinary(e, t) {
      return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e];
    }
    getTextureManager() {
      return this.textureManager;
    }
    dispose() {
      this.disposed || (ne().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((t) => {
        this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram), delete this.binaryCache[t];
      }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
    }
    floatPrecision() {
      return this.floatPrecisionValue == null && (this.floatPrecisionValue = se(() => {
        if (!ne().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
          const e = ne().getBool("DEBUG");
          ne().set("DEBUG", false);
          const t = this.abs(yn(1e-8)).dataSync()[0];
          if (ne().set("DEBUG", e), t > 0) return 32;
        }
        return 16;
      })), this.floatPrecisionValue;
    }
    epsilon() {
      return this.floatPrecision() === 32 ? a5e : s5e;
    }
    uploadToGPU(e) {
      const t = this.texData.get(e), { shape: r, dtype: i, values: a, texture: s, usage: o, isPacked: l } = t;
      if (s != null) return;
      const u = this.activeTimers != null;
      let c;
      u && (c = hi());
      let h = t.texShape;
      if (h == null && (h = $4e(r, l), t.texShape = h), a != null) {
        const d = Sw(r);
        let f, p = h[1], g = h[0];
        const m = a instanceof Uint8Array || a instanceof Uint8ClampedArray;
        (l || !m) && ([p, g] = Rv(h[0], h[1])), l ? f = new $Ue(d, m) : f = new SU(d, m);
        const v = m ? [
          g,
          p
        ] : h, y = this.makeTensorInfo(v, i), x = this.texData.get(y.dataId);
        m ? x.usage = Ba.PIXELS : x.usage = Ba.UPLOAD, x.texShape = v, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId), p, g, a);
        const b = [
          [
            g,
            p
          ]
        ], _ = this.runWebGLProgram(f, [
          y
        ], i, b, true), S = this.texData.get(_.dataId);
        t.texShape = S.texShape, t.isPacked = S.isPacked, t.usage = S.usage, ne().get("ENGINE_COMPILE_ONLY") ? this.disposeData(_.dataId) : (t.texture = S.texture, t.values = null, this.texData.delete(_.dataId)), this.disposeIntermediateTensorInfo(y), u && (this.uploadWaitMs += hi() - c);
      } else {
        const d = this.acquireTexture(h, o, i, l);
        t.texture = d;
      }
    }
    convertAndCacheOnCPU(e, t) {
      const r = this.texData.get(e), { dtype: i } = r;
      return t != null && (r.values = h5e(t, i)), r.values;
    }
    acquireTexture(e, t, r, i) {
      if (this.numBytesInGPU += this.computeBytes(e, r), !this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
        const a = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true, console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`);
      }
      return this.textureManager.acquireTexture(e, t, i);
    }
    computeBytes(e, t) {
      return e[0] * e[1] * Hg(t);
    }
    checkCompileCompletion() {
      for (const [, e] of Object.entries(this.binaryCache)) this.checkCompletion_(e);
    }
    async checkCompileCompletionAsync() {
      const e = [];
      if (this.gpgpu.parallelCompilationExtension) {
        for (const [, t] of Object.entries(this.binaryCache)) e.push(this.checkCompletionAsync_(t));
        return Promise.all(e);
      } else {
        for (const [, t] of Object.entries(this.binaryCache)) {
          const r = new Promise((i) => {
            try {
              this.checkCompletion_(t), i(true);
            } catch (a) {
              throw a;
            }
          });
          e.push(r);
        }
        return Promise.all(e);
      }
    }
    async checkCompletionAsync_(e) {
      return this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(e) : (await dZ(), this.checkCompletionAsync_(e));
    }
    checkCompletion_(e) {
      if (this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)), this.gpgpu.gl.getShaderParameter(e.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false ? (Hee(e.source, this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)), new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
      return true;
    }
    getUniformLocations() {
      for (const e of Object.values(this.binaryCache)) {
        this.gpgpu.buildVao(e.webGLProgram);
        const { variablesLocations: t, customUniformLocations: r, infLoc: i, nanLoc: a, outShapeLocation: s, outShapeStridesLocation: o, outTexShapeLocation: l } = Kee(this.gpgpu, e.program, e.webGLProgram);
        e.variablesLocations = t, e.customUniformLocations = r, e.infLoc = i, e.nanLoc = a, e.outShapeLocation = s, e.outShapeStridesLocation = o, e.outTexShapeLocation = l;
      }
    }
    createTensorFromGPUData(e, t, r) {
      e.channels = e.channels || "RGBA";
      const { texture: i, height: a, width: s, channels: o } = e, l = ga().backend;
      if (!l.gpgpu.gl.isTexture(i)) throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
      const u = l.writeTexture(i, t, r, a, s, o);
      return ga().makeTensorFromDataId(u, t, r, l);
    }
  }
  a2.nextDataId = 0;
  function h5e(n, e) {
    if (e === "float32" || e === "complex64") return n;
    if (e === "int32" || e === "bool") {
      const t = e === "int32" ? new Int32Array(n.length) : new Uint8Array(n.length);
      for (let r = 0; r < t.length; ++r) t[r] = Math.round(n[r]);
      return t;
    } else throw new Error(`Unknown dtype ${e}`);
  }
  c9() && _I("webgl", () => new a2(), 2);
  const $L = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
  let Rd = class {
    constructor(e, t, r) {
      this.variableNames = [
        "A",
        "B"
      ], this.outputShape = ht(t, r), this.enableShapeUniforms = xi(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
  };
  const fp = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
  class Pv {
    constructor(e, t, r, i = false) {
      this.variableNames = [
        "A",
        "B"
      ], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = ht(t, r);
      const a = this.outputShape.length;
      this.enableShapeUniforms = xi(a);
      let s = "";
      if (i) if (a === 0 || X(this.outputShape) === 1) s = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
      else if (s = `
          ${Pn(a)} coords = getOutputCoords();
        `, a === 1) this.enableShapeUniforms ? s += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          ` : s += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
      else {
        const l = Di("coords", a);
        this.enableShapeUniforms ? s += `
            bool nextRowOutOfBounds =
              (${l[a - 2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a - 1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : s += `
            bool nextRowOutOfBounds =
              (${l[a - 2]} + 1) >= ${this.outputShape[a - 2]};
            bool nextColOutOfBounds =
              (${l[a - 1]} + 1) >= ${this.outputShape[a - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
      }
      this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `;
    }
  }
  function Ta(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    return t.incRef(r.dataId), {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  const d5e = {
    kernelName: vf,
    backendName: "webgl",
    kernelFunc: Ta
  };
  function Dc(n) {
    const { inputs: e, backend: t } = n, { real: r, imag: i } = e, a = t.makeTensorInfo(r.shape, "complex64"), s = t.texData.get(a.dataId), o = Ta({
      inputs: {
        x: r
      },
      backend: t
    }), l = Ta({
      inputs: {
        x: i
      },
      backend: t
    });
    return s.complexTensorInfos = {
      real: o,
      imag: l
    }, a;
  }
  const f5e = {
    kernelName: tI,
    backendName: "webgl",
    kernelFunc: Dc
  };
  const ote = "return (a < 0.) ? b * a : a;", lte = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function p5e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { alpha: a } = r, s = t.makeTensorInfo([], "float32", Sc(a, "float32")), o = ne().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Pv(lte, i.shape, s.shape) : new Rd(ote, i.shape, s.shape), l = t.runWebGLProgram(o, [
      i,
      s
    ], "float32");
    return t.disposeIntermediateTensorInfo(s), l;
  }
  const g5e = {
    kernelName: wf,
    backendName: "webgl",
    kernelFunc: p5e
  };
  const ute = "return (a < 0.) ? b * a : a;", cte = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function m5e(n) {
    const { inputs: e, backend: t } = n, { x: r, alpha: i } = e, a = ne().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Pv(cte, r.shape, i.shape) : new Rd(ute, r.shape, i.shape);
    return t.runWebGLProgram(a, [
      r,
      i
    ], "float32");
  }
  const v5e = {
    kernelName: Ff,
    backendName: "webgl",
    kernelFunc: m5e
  };
  const Lv = "if (isnan(x)) return x;";
  function cn({ opSnippet: n, packedOpSnippet: e, cpuKernelImpl: t, dtype: r }) {
    return ({ inputs: i, backend: a }) => {
      const { x: s } = i, o = a, l = r || s.dtype;
      if (o.shouldExecuteOnCPU([
        s
      ]) && t != null) {
        const h = o.texData.get(s.dataId), d = t(h.values, l);
        return o.makeTensorInfo(s.shape, l, d);
      }
      const u = ne().getBool("WEBGL_PACK_UNARY_OPERATIONS") && e != null;
      let c;
      return u ? c = new Gu(s.shape, e) : c = new Wo(s.shape, n), o.runWebGLProgram(c, [
        s
      ], l);
    };
  }
  function li({ opSnippet: n, packedOpSnippet: e, checkOutOfBounds: t = false, supportsComplex: r = false, cpuKernelImpl: i, dtype: a }) {
    return ({ inputs: s, backend: o }) => {
      const { a: l, b: u } = s, c = o;
      if (r && l.dtype === "complex64") {
        const p = c.texData.get(l.dataId), g = c.texData.get(u.dataId), [m, v] = [
          [
            p.complexTensorInfos.real,
            g.complexTensorInfos.real
          ],
          [
            p.complexTensorInfos.imag,
            g.complexTensorInfos.imag
          ]
        ].map((x) => {
          const [b, w] = x, _ = {
            dataId: b.dataId,
            dtype: b.dtype,
            shape: l.shape
          }, S = {
            dataId: w.dataId,
            dtype: w.dtype,
            shape: u.shape
          }, I = new Rd(n, l.shape, u.shape);
          return c.runWebGLProgram(I, [
            _,
            S
          ], qr(b.dtype, w.dtype));
        }), y = Dc({
          inputs: {
            real: m,
            imag: v
          },
          backend: c
        });
        return c.disposeIntermediateTensorInfo(m), c.disposeIntermediateTensorInfo(v), y;
      }
      const h = a || qr(l.dtype, u.dtype);
      if ((l.dtype === "string" || u.dtype === "string" || c.shouldExecuteOnCPU([
        l,
        u
      ])) && i != null) {
        const p = c.texData.get(l.dataId).values, g = c.texData.get(u.dataId).values, m = l.dtype === "string" ? so(p) : p, v = l.dtype === "string" ? so(g) : g, [y, x] = i(l.shape, u.shape, m, v, h), b = c.makeTensorInfo(x, h), w = c.texData.get(b.dataId);
        return w.values = y, b;
      }
      const d = ne().getBool("WEBGL_PACK_BINARY_OPERATIONS") && e != null;
      let f;
      return d ? f = new Pv(e, l.shape, u.shape, t) : f = new Rd(n, l.shape, u.shape), c.runWebGLProgram(f, [
        l,
        u
      ], h);
    };
  }
  function px(n, e = false) {
    if (n === "linear") return e ? QHe : YHe;
    if (n === "relu") return e ? e5e : jHe;
    if (n === "elu") return e ? JHe : qHe;
    if (n === "relu6") return e ? t5e : KHe;
    if (n === "prelu") return e ? cte : ute;
    if (n === "leakyrelu") return e ? lte : ote;
    if (n === "sigmoid") return e ? n5e : ZHe;
    throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`);
  }
  let hte = class {
    constructor(e, t, r, i = false, a = false, s = false, o = null, l = false, u = false) {
      this.variableNames = [
        "matrixA",
        "matrixB"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = r, this.enableShapeUniforms = xi(this.outputShape.length);
      const c = i ? e[1] : e[2], h = Math.ceil(c / 2), d = i ? "i * 2, rc.y" : "rc.y, i * 2", f = a ? "rc.z, i * 2" : "i * 2, rc.z", p = i ? [
        "a.xxyy",
        "a.zzww"
      ] : [
        "a.xxzz",
        "a.yyww"
      ], g = a ? [
        "b.xzxz",
        "b.ywyw"
      ] : [
        "b.xyxy",
        "b.zwzw"
      ];
      let m = "", v = "";
      o && (l ? m = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }` : u ? m = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }` : m = `vec4 activation(vec4 x) {
          ${o}
        }`, v = "result = activation(result);");
      const y = s ? "result += getBiasAtOutCoords();" : "";
      s && this.variableNames.push("bias"), l && this.variableNames.push("preluActivationWeights"), u && this.variableNames.push("leakyreluAlpha");
      let x = "rc.x", b = "rc.x";
      e[0] < t[0] ? x = `imod(rc.x, ${e[0]})` : t[0] < e[0] && (b = `imod(rc.x, ${t[0]})`), this.userCode = `
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${b};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${g[0]});
          result += (${p[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${v}

        setOutput(result);
      }
    `;
    }
  };
  const AU = {
    REAL: "return areal * breal - aimag * bimag;",
    IMAG: "return areal * bimag + aimag * breal;"
  };
  let DU = class {
    constructor(e, t, r) {
      this.variableNames = [
        "AReal",
        "AImag",
        "BReal",
        "BImag"
      ], this.outputShape = ht(t, r), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
  };
  const RU = "return a * b;";
  function NL(n) {
    const { inputs: e, backend: t } = n, { a: r, b: i } = e, a = qr(r.dtype, i.dtype);
    if (r.dtype === "complex64") {
      const o = t.texData.get(r.dataId), l = t.texData.get(i.dataId), u = new DU(AU.REAL, r.shape, i.shape), c = new DU(AU.IMAG, r.shape, i.shape), h = [
        {
          dataId: o.complexTensorInfos.real.dataId,
          dtype: o.complexTensorInfos.real.dtype,
          shape: r.shape
        },
        {
          dataId: o.complexTensorInfos.imag.dataId,
          dtype: o.complexTensorInfos.imag.dtype,
          shape: r.shape
        },
        {
          dataId: l.complexTensorInfos.real.dataId,
          dtype: l.complexTensorInfos.real.dtype,
          shape: i.shape
        },
        {
          dataId: l.complexTensorInfos.imag.dataId,
          dtype: l.complexTensorInfos.imag.dtype,
          shape: i.shape
        }
      ], d = t.runWebGLProgram(u, h, "float32"), f = t.runWebGLProgram(c, h, "float32"), p = Dc({
        inputs: {
          real: d,
          imag: f
        },
        backend: t
      });
      return t.disposeIntermediateTensorInfo(d), t.disposeIntermediateTensorInfo(f), p;
    }
    if (t.shouldExecuteOnCPU([
      r,
      i
    ])) {
      const o = t.texData.get(r.dataId), l = t.texData.get(i.dataId), [u, c] = mHe(r.shape, i.shape, o.values, l.values, a), h = t.makeTensorInfo(c, a), d = t.texData.get(h.dataId);
      return d.values = u, h;
    }
    let s;
    return ne().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? s = new Pv(RU, r.shape, i.shape) : s = new Rd(RU, r.shape, i.shape), t.runWebGLProgram(s, [
      r,
      i
    ], a);
  }
  const y5e = {
    kernelName: Ef,
    backendName: "webgl",
    kernelFunc: NL
  };
  function x5e(n, e, t) {
    const r = [
      tm(n.shape),
      ...nm(n.shape)
    ], i = {
      dtype: n.dtype,
      shape: r,
      dataId: n.dataId
    }, a = [
      tm(e),
      ...nm(e)
    ], s = new ste(a, r), o = true, l = [
      r
    ], u = t.runWebGLProgram(s, [
      i
    ], n.dtype, l, o);
    return {
      dataId: u.dataId,
      shape: e,
      dtype: u.dtype
    };
  }
  function Me(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { shape: a } = r, s = t, o = X(i.shape), l = QC(a, o), u = X(l);
    B(o === u, () => `The new shape (${l}) has ${u} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);
    const c = s.texData.get(i.dataId);
    return c.isPacked && !KS(i.shape, l) && !(c.texture !== null && KS(c.shape, l)) ? x5e(i, l, s) : (s.incRef(i.dataId), {
      dataId: i.dataId,
      shape: l,
      dtype: i.dtype
    });
  }
  const b5e = {
    kernelName: uv,
    backendName: "webgl",
    kernelFunc: Me
  };
  class $U {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ];
      const { windowSize: r, batchSize: i, inSize: a, outSize: s } = e;
      this.outputShape = [
        i,
        s
      ];
      const o = Math.floor(r / 4) * 4, l = r % 4;
      let u = "sumValue += dot(values, ones);";
      if (t != null) {
        const h = 1 / t;
        u = `sumValue += dot(values * ${Ug(h) ? h.toPrecision(2) : h}, ones);`;
      }
      let c = "";
      a % r > 0 && (c = `
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${l === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `;
    }
  }
  let w5e = class {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ];
      const { windowSize: r, batchSize: i, inSize: a, outSize: s } = e;
      this.outputShape = [
        i,
        s
      ];
      let o = "0.0", l = "";
      t === "prod" ? o = "1.0" : t === "min" ? (o = "1.0 / 1e-20", l = "min") : t === "max" && (o = "-1.0 / 1e-20", l = "max");
      let u = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      t === "sum" ? u = "sumValue" : t === "prod" ? u = "prodValue" : t === "all" ? u = "allValue" : t === "any" && (u = "anyValue");
      const c = Math.floor(r / 4) * 4, h = r % 4;
      let d = `
      if (${t === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${t === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t === "min"} || ${t === "max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, f = "vec4";
      t === "all" ? (o = "1.0", d = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, f = "bvec4") : t === "any" && (o = "0.0", d = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, f = "bvec4");
      let p = "";
      a % r > 0 && (p = `
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h === 1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h === 2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h === 3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `;
    }
  };
  function _5e(n) {
    const e = [];
    for (; e.length === 0 || e[e.length - 1].outSize !== 1; ) {
      const t = e.length ? e[e.length - 1].outSize : n[1], r = MI(t);
      e.push({
        inSize: t,
        windowSize: r,
        outSize: Math.ceil(t / r)
      });
    }
    return e;
  }
  function pp(n, e, t, r) {
    const i = _5e(n.shape);
    let a = n;
    for (let s = 0; s < i.length; s++) {
      const { inSize: o, windowSize: l, outSize: u } = i[s];
      let c, h;
      t === "mean" ? c = s === 0 ? new $U({
        windowSize: l,
        inSize: o,
        batchSize: n.shape[0],
        outSize: u
      }, o) : new $U({
        windowSize: l,
        inSize: o,
        batchSize: n.shape[0],
        outSize: u
      }) : c = new w5e({
        windowSize: l,
        inSize: o,
        batchSize: n.shape[0],
        outSize: u
      }, t), h = a, a = r.runWebGLProgram(c, [
        a
      ], e), h.dataId !== n.dataId && r.disposeIntermediateTensorInfo(h);
    }
    return a;
  }
  let S5e = class {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ];
      const r = new Array(e.length);
      for (let s = 0; s < r.length; s++) r[s] = e[t[s]];
      this.outputShape = r, this.rank = r.length;
      const i = Pn(this.rank), a = C5e(t);
      this.userCode = `
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `;
    }
  };
  function C5e(n) {
    const e = n.length;
    if (e > 6) throw Error(`Transpose for rank ${e} is not yet supported`);
    const t = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w",
      "resRC.u",
      "resRC.v"
    ], r = new Array(e);
    for (let i = 0; i < n.length; i++) r[n[i]] = t[i];
    return r.join();
  }
  class I5e {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true;
      const r = new Array(e.length);
      for (let c = 0; c < r.length; c++) r[c] = e[t[c]];
      if (this.outputShape = r, this.rank = r.length, this.rank > 6) throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
      const i = Pn(this.rank), a = ate("rc", this.rank), s = new Array(this.rank);
      for (let c = 0; c < t.length; c++) s[t[c]] = a[c];
      const o = `vec2(${s.slice(-2).join()})`, l = `++${a[this.rank - 1]} < ${r[this.rank - 1]}`, u = `getChannel(getA(${s.join()}), ${o})`;
      this.userCode = `
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${a[this.rank - 1]};
      if(++${a[this.rank - 2]} < ${r[this.rank - 2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `;
    }
  }
  function s2(n, e, t) {
    const r = ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new I5e(n.shape, e) : new S5e(n.shape, e);
    return t.runWebGLProgram(r, [
      n
    ], n.dtype);
  }
  function k5e(n, e, t, r) {
    const i = e, a = n.shape.length, s = yt(i, n.shape);
    let o = s;
    const l = bn(o, a), u = l != null;
    let c = n;
    u && (c = s2(n, l, r), o = gn(o.length, a)), Tn("sum", o, a);
    const [h, d] = Ln(c.shape, o);
    let f = h;
    t && (f = Mn(h, s));
    const p = X(d), m = X(n.shape) / p, v = Me({
      inputs: {
        x: c
      },
      attrs: {
        shape: [
          m,
          p
        ]
      },
      backend: r
    }), y = xI(n.dtype), x = pp(v, y, "sum", r), b = Me({
      inputs: {
        x
      },
      attrs: {
        shape: f
      },
      backend: r
    });
    return r.disposeIntermediateTensorInfo(v), r.disposeIntermediateTensorInfo(x), u && r.disposeIntermediateTensorInfo(c), b;
  }
  function o2(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    return k5e(i, a, s, t);
  }
  const T5e = {
    kernelName: ep,
    backendName: "webgl",
    kernelFunc: o2
  };
  function Li(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { perm: a } = r, s = t, o = i.shape.length, l = new Array(o);
    for (let c = 0; c < l.length; c++) l[c] = i.shape[a[c]];
    let u;
    if (s.shouldExecuteOnCPU([
      i
    ])) {
      const h = s.texData.get(i.dataId).values, d = RL(h, i.shape, i.dtype, a, l);
      u = s.makeTensorInfo(l, i.dtype);
      const f = s.texData.get(u.dataId);
      f.values = d;
    } else u = s2(i, a, s);
    return u;
  }
  const A5e = {
    kernelName: Ol,
    backendName: "webgl",
    kernelFunc: Li
  };
  const dte = 1e3;
  function ZS({ a: n, b: e, transposeA: t, transposeB: r, backend: i, bias: a = null, preluActivationWeights: s = null, leakyreluAlpha: o = 0, activation: l = null }) {
    const u = n.shape.length, c = e.shape.length, h = t ? n.shape[u - 2] : n.shape[u - 1], d = r ? e.shape[c - 1] : e.shape[c - 2], f = t ? n.shape[u - 1] : n.shape[u - 2], p = r ? e.shape[c - 2] : e.shape[c - 1], g = n.shape.slice(0, -2), m = e.shape.slice(0, -2), v = X(g), y = X(m), b = ht(n.shape.slice(0, -2), e.shape.slice(0, -2)).concat([
      f,
      p
    ]);
    B(h === d, () => `Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);
    const w = t ? [
      v,
      h,
      f
    ] : [
      v,
      f,
      h
    ], _ = r ? [
      y,
      p,
      d
    ] : [
      y,
      d,
      p
    ], S = Me({
      inputs: {
        x: n
      },
      backend: i,
      attrs: {
        shape: w
      }
    }), I = Me({
      inputs: {
        x: e
      },
      backend: i,
      attrs: {
        shape: _
      }
    }), C = [
      S,
      I
    ], T = Math.max(v, y), k = t ? S.shape[1] : S.shape[2], D = a != null, R = s != null, N = l === "leakyrelu", E = l != null ? px(l, true) : null, A = D || R || N || E != null;
    let M;
    if ((f === 1 || p === 1) && k > dte && A === false) {
      let L = S, F = I;
      t && (L = Li({
        inputs: {
          x: S
        },
        backend: i,
        attrs: {
          perm: [
            0,
            2,
            1
          ]
        }
      }), C.push(L)), r && (F = Li({
        inputs: {
          x: I
        },
        backend: i,
        attrs: {
          perm: [
            0,
            2,
            1
          ]
        }
      }), C.push(F));
      const O = p !== 1, z = p === 1;
      let V = L;
      O && (V = Me({
        inputs: {
          x: L
        },
        backend: i,
        attrs: {
          shape: [
            T,
            k,
            1
          ]
        }
      }), C.push(V));
      const H = p === 1 ? 2 : 1;
      let Y = F;
      z && (Y = Me({
        inputs: {
          x: F
        },
        backend: i,
        attrs: {
          shape: [
            T,
            1,
            k
          ]
        }
      }), C.push(Y));
      const le = NL({
        inputs: {
          a: V,
          b: Y
        },
        backend: i
      });
      M = o2({
        inputs: {
          x: le
        },
        backend: i,
        attrs: {
          axis: H,
          keepDims: true
        }
      }), C.push(le);
    } else {
      const L = qr(n.dtype, e.dtype), F = new hte(w, _, [
        T,
        f,
        p
      ], t, r, D, E, R, N), O = [
        S,
        I
      ];
      if (a != null && O.push(a), R && O.push(s), N) {
        const z = i.makeTensorInfo([], "float32", Sc(o, "float32"));
        O.push(z), C.push(z);
      }
      M = i.runWebGLProgram(F, O, L);
    }
    const $ = Me({
      inputs: {
        x: M
      },
      backend: i,
      attrs: {
        shape: b
      }
    });
    C.push(M);
    for (const L of C) i.disposeIntermediateTensorInfo(L);
    return $;
  }
  function D5e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { a: i, b: a, bias: s, preluActivationWeights: o } = e, { transposeA: l, transposeB: u, activation: c, leakyreluAlpha: h } = r;
    return ZS({
      a: i,
      b: a,
      transposeA: l,
      transposeB: u,
      backend: t,
      bias: s,
      preluActivationWeights: o,
      leakyreluAlpha: h,
      activation: c
    });
  }
  const R5e = {
    kernelName: vd,
    backendName: "webgl",
    kernelFunc: D5e
  };
  const NU = "return abs(x);";
  function $5e(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (t.shouldExecuteOnCPU([
      r
    ]) && r.dtype !== "complex64") {
      const a = t.texData.get(r.dataId), s = rte(a.values);
      return t.makeTensorInfo(r.shape, r.dtype, s);
    }
    let i;
    return ne().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? i = new Gu(r.shape, NU) : i = new Wo(r.shape, NU), t.runWebGLProgram(i, [
      r
    ], r.dtype);
  }
  const N5e = {
    kernelName: Dm,
    backendName: "webgl",
    kernelFunc: $5e
  };
  const E5e = Rs + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`, M5e = cn({
    opSnippet: E5e
  }), P5e = {
    kernelName: Wd,
    backendName: "webgl",
    kernelFunc: M5e
  };
  const L5e = Rs + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`, F5e = cn({
    opSnippet: L5e
  }), O5e = {
    kernelName: Gd,
    backendName: "webgl",
    kernelFunc: F5e
  };
  const EU = "return a + b;", B5e = li({
    opSnippet: EU,
    packedOpSnippet: EU,
    supportsComplex: true,
    cpuKernelImpl: jUe
  }), z5e = {
    kernelName: xc,
    backendName: "webgl",
    kernelFunc: B5e
  };
  class V5e {
    constructor(e, t) {
      this.outputShape = [], this.outputShape = e, this.variableNames = t.map((a, s) => `T${s}`);
      const r = [];
      this.variableNames.forEach((a) => {
        r.push(`float v${a} = get${a}AtOutCoords();`);
      });
      const i = this.variableNames.map((a) => `v${a}`).join(" + ");
      this.userCode = `
      void main() {
        ${r.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `;
    }
  }
  let W5e = class {
    constructor(e, t) {
      this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = e, this.variableNames = t.map((a, s) => `T${s}`);
      const r = [];
      this.variableNames.forEach((a) => {
        r.push(`vec4 v${a} = get${a}AtOutCoords();`);
      });
      const i = this.variableNames.map((a) => `v${a}`).join(" + ");
      this.userCode = `
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `;
    }
  };
  function C_(n) {
    const { inputs: e, backend: t } = n, r = e;
    if (r.length === 1) return Ta({
      inputs: {
        x: r[0]
      },
      backend: t
    });
    if (r.length > ne().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      const l = Math.floor(r.length / 2), u = C_({
        inputs: r.slice(0, l),
        backend: t
      }), c = C_({
        inputs: r.slice(l),
        backend: t
      });
      return C_({
        inputs: [
          u,
          c
        ],
        backend: t
      });
    }
    const i = r.map((l) => l.dtype).reduce((l, u) => qr(l, u)), a = r.map((l) => l.shape), o = ne().getBool("WEBGL_PACK") ? new W5e(r[0].shape, a) : new V5e(r[0].shape, a);
    return t.runWebGLProgram(o, r, i);
  }
  const G5e = {
    kernelName: Rm,
    backendName: "webgl",
    kernelFunc: C_
  };
  function U5e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r, o = i.shape.length, l = yt(a, i.shape);
    let u = l;
    const c = bn(u, o);
    let h = i;
    c != null && (h = Li({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: c
      }
    }), u = gn(u.length, o)), Tn("all", u, o);
    const [d, f] = Ln(h.shape, u), p = X(f), g = Me({
      inputs: {
        x: h
      },
      backend: t,
      attrs: {
        shape: [
          -1,
          p
        ]
      }
    }), m = pp(g, g.dtype, "all", t);
    let v;
    if (s) {
      const y = Mn(d, l);
      v = Me({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: y
        }
      });
    } else v = Me({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    return t.disposeIntermediateTensorInfo(g), t.disposeIntermediateTensorInfo(m), c != null && t.disposeIntermediateTensorInfo(h), v;
  }
  const H5e = {
    kernelName: $m,
    backendName: "webgl",
    kernelFunc: U5e
  };
  function X5e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r, o = i.shape.length, l = yt(a, i.shape);
    let u = l;
    const c = bn(u, o);
    let h = i;
    c != null && (h = Li({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: c
      }
    }), u = gn(u.length, o)), Tn("any", u, o);
    const [d, f] = Ln(h.shape, u), p = X(f), g = Me({
      inputs: {
        x: h
      },
      backend: t,
      attrs: {
        shape: [
          -1,
          p
        ]
      }
    }), m = pp(g, g.dtype, "any", t);
    let v;
    if (s) {
      const y = Mn(d, l);
      v = Me({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: y
        }
      });
    } else v = Me({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    return t.disposeIntermediateTensorInfo(g), t.disposeIntermediateTensorInfo(m), c != null && t.disposeIntermediateTensorInfo(h), v;
  }
  const Y5e = {
    kernelName: Nm,
    backendName: "webgl",
    kernelFunc: X5e
  };
  let q5e = class {
    constructor(e, t, r) {
      this.variableNames = [
        "A"
      ];
      const { windowSize: i, batchSize: a, outSize: s } = e;
      r || this.variableNames.push("bestIndicesA"), this.outputShape = [
        a,
        s
      ];
      const o = t === "max" ? ">" : "<", l = r ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
  };
  class j5e {
    constructor(e, t, r, i) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, B(e.length > 2, () => `Packed arg${r.charAt(0).toUpperCase() + r.slice(1)} supports only inputs with rank above 2.`);
      const a = e[e.length - 1], s = Math.ceil(a / t);
      this.outputShape = e.slice(0, -1), s > 1 && this.outputShape.push(s), i || this.variableNames.push("bestIndicesA");
      const o = this.outputShape, l = o.length, u = Pn(l), c = Di("coords", l);
      let h, d;
      if (s === 1) {
        d = l + 1;
        const I = Pn(d);
        h = `
        ${I} sourceLocR = ${I}(${c.join()}, 0);
        ++${c[l - 1]};
        ${I} sourceLocG = ${I}(${c.join()}, 0);
        ++${c[l - 2]};
        ${I} sourceLocA = ${I}(${c.join()}, 0);
        --${c[l - 1]};
        ${I} sourceLocB = ${I}(${c.join()}, 0);
        --${c[l - 2]};`;
      } else d = l, h = `
        ${u} sourceLocR = coords;
        ++${c[l - 1]};
        ${u} sourceLocG = coords;
        ++${c[l - 2]};
        ${u} sourceLocA = coords;
        --${c[l - 1]};
        ${u} sourceLocB = coords;
        --${c[l - 2]};`;
      const f = [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
      ].slice(0, d), p = "." + f[d - 1], g = f.map((I) => "int " + I), m = Di("sourceLocR", d - 1).concat("inIdx.r"), v = Di("sourceLocG", d - 1).concat("inIdx.g"), y = Di("sourceLocB", d - 1).concat("inIdx.b"), x = Di("sourceLocA", d - 1).concat("inIdx.a"), b = r === "max" ? "greaterThan" : "lessThan", w = i ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()})));`, _ = `vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`, S = i ? "" : `
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;
      this.userCode = `
      float getAChannel(${g.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${S}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l - 1]} < ${o[l - 1] - 1};
        bool hasNextRow = ${c[l - 2]} < ${o[l - 2] - 1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${b}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
  }
  function fte(n, e, t, r = null) {
    let i = e.shape[0], a = e.shape[1];
    r != null && (i = r.shape[0], a = r.shape[1]);
    const s = MI(a), o = {
      windowSize: s,
      inSize: a,
      batchSize: i,
      outSize: Math.ceil(a / s)
    }, l = new q5e(o, t, r == null), u = [
      e
    ];
    r != null && u.push(r);
    const c = n.runWebGLProgram(l, u, "int32");
    if (c.shape[1] === 1) return c;
    const h = fte(n, e, t, c);
    return n.disposeIntermediateTensorInfo(c), h;
  }
  function pte(n, e, t, r = null) {
    const i = r != null ? r.shape : e.shape, a = i[i.length - 1], s = MI(a), o = new j5e(i, s, t, r == null), l = r == null ? [
      e
    ] : [
      e,
      r
    ], u = n.runWebGLProgram(o, l, "int32");
    if (u.shape.length === e.shape.length) {
      const c = pte(n, e, t, u);
      return n.disposeIntermediateTensorInfo(u), c;
    }
    return u;
  }
  function gte(n, e, t, r) {
    const i = [
      t
    ];
    if (Tn("arg" + r.charAt(0).toUpperCase() + r.slice(1), i, e.shape.length), !ne().getBool("WEBGL_PACK_REDUCE") || e.shape.length <= 2) {
      const a = [], s = n.texData.get(e.dataId), o = s !== null && s.isPacked;
      let l = e;
      o && (l = n.unpackTensor(e), a.push(l));
      const [u, c] = Ln(l.shape, i), h = X(c), d = Me({
        inputs: {
          x: l
        },
        backend: n,
        attrs: {
          shape: [
            -1,
            h
          ]
        }
      });
      a.push(d);
      const f = fte(n, d, r);
      a.push(f);
      const p = Me({
        inputs: {
          x: f
        },
        backend: n,
        attrs: {
          shape: u
        }
      });
      return a.forEach((g) => n.disposeIntermediateTensorInfo(g)), p;
    }
    return pte(n, e, r);
  }
  function K5e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a } = r;
    let s = yt(a, i.shape);
    const o = bn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = Li({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: o
      }
    }), u.push(l), s = gn(s.length, l.shape.length)), Tn("argMax", [
      s[0]
    ], l.shape.length);
    const c = gte(t, l, s[0], "max");
    return u.forEach((h) => t.disposeIntermediateTensorInfo(h)), c;
  }
  const Z5e = {
    kernelName: Em,
    backendName: "webgl",
    kernelFunc: K5e
  };
  function Q5e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a } = r;
    let s = yt(a, i.shape);
    const o = bn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = Li({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: o
      }
    }), u.push(l), s = gn(s.length, l.shape.length)), Tn("argMin", [
      s[0]
    ], l.shape.length);
    const c = gte(t, l, s[0], "min");
    return u.forEach((h) => t.disposeIntermediateTensorInfo(h)), c;
  }
  const J5e = {
    kernelName: Mm,
    backendName: "webgl",
    kernelFunc: Q5e
  };
  const e6e = Rs + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`, t6e = cn({
    opSnippet: e6e
  }), n6e = {
    kernelName: Ud,
    backendName: "webgl",
    kernelFunc: t6e
  };
  const r6e = Rs + "return log(x + sqrt(x * x + 1.0));", i6e = cn({
    opSnippet: r6e
  }), a6e = {
    kernelName: Hd,
    backendName: "webgl",
    kernelFunc: i6e
  };
  const s6e = Rs + `
  return atan(x);
`, o6e = cn({
    opSnippet: s6e
  }), l6e = {
    kernelName: Xd,
    backendName: "webgl",
    kernelFunc: o6e
  };
  const u6e = $L + `
  return atan(a, b);
`, c6e = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + fp + `
  return result;
`, h6e = li({
    opSnippet: u6e,
    packedOpSnippet: c6e
  }), d6e = {
    kernelName: qd,
    backendName: "webgl",
    kernelFunc: h6e
  };
  const f6e = Rs + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`, p6e = cn({
    opSnippet: f6e
  }), g6e = {
    kernelName: Yd,
    backendName: "webgl",
    kernelFunc: p6e
  };
  let gx = class {
    constructor(e, t, r, i = false, a = false) {
      if (this.variableNames = [
        "x"
      ], t === "avg" && r) throw new Error("Cannot compute positions for average pool.");
      const s = e.filterWidth, o = e.strideHeight, l = e.strideWidth, u = e.dilationHeight, c = e.dilationWidth, h = e.effectiveFilterHeight, d = e.effectiveFilterWidth, f = e.padInfo.top, p = e.padInfo.left;
      this.outputShape = e.outShape;
      const g = t === "avg", m = `((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`, v = `(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;
      let y = "0.0";
      if (g || (y = "-1.0 / 1e-20"), r) {
        const I = ">=";
        this.userCode = `
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${f}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i ? a ? m : v : `wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const x = "max";
      let b = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      t === "avg" && (b = "avgValue / max(count, 1.0)");
      const w = Math.floor(s / 4) * 4, _ = s % 4, S = `
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${f}, ${p});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${S}
          }

          int xC = xCCorner + ${w};
          if (${_ === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${_ === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${_ === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${S}
          }
        }
        setOutput(${b});
      }
    `;
    }
  }, EL = class {
    constructor(e, t, r, i = false, a = false) {
      if (this.variableNames = [
        "x"
      ], t === "avg" && r) throw new Error("Cannot compute positions for average pool.");
      const s = e.filterWidth, o = e.strideDepth, l = e.strideHeight, u = e.strideWidth, c = e.dilationDepth, h = e.dilationHeight, d = e.dilationWidth, f = e.effectiveFilterDepth, p = e.effectiveFilterHeight, g = e.effectiveFilterWidth, m = e.padInfo.front, v = e.padInfo.top, y = e.padInfo.left;
      this.outputShape = e.outShape;
      const x = t === "avg";
      let b = "0.0";
      if (x || (b = "-1.0 / 1e-20"), r) {
        const T = ">=";
        this.userCode = `
        const ivec3 strides =
            ivec3(${o}, ${l}, ${u});
        const ivec3 pads = ivec3(${m}, ${v}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${T} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i ? a ? `(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch` : `((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch` : `wD * ${p} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const w = "max";
      let _ = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      t === "avg" && (_ = "avgValue / max(count, 1.0)");
      const S = Math.floor(s / 4) * 4, I = s % 4, C = `
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec3 strides =
        ivec3(${o}, ${l}, ${u});
      const ivec3 pads = ivec3(${m}, ${v}, ${y});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${S}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${C}
            }

            int xC = xCCorner + ${S};
            if (${I === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${C}
            } else if (${I === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${C}
            } else if (${I === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${C}
            }
          }
        }
        setOutput(${_});
      }
    `;
    }
  };
  function m6e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e;
    Gb(i, "avgPool");
    const { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, u = 1;
    B(Pr(s, u), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = dr(i.shape, a, s, u, o, l);
    if (c.filterWidth === 1 && c.filterHeight === 1 && Jt(c.inShape, c.outShape)) return Ta({
      inputs: {
        x: i
      },
      backend: t
    });
    const h = new gx(c, "avg", false);
    return t.runWebGLProgram(h, [
      i
    ], "float32");
  }
  const v6e = {
    kernelName: jd,
    backendName: "webgl",
    kernelFunc: m6e
  };
  function y6e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dimRoundingMode: l, dataFormat: u } = r, c = [
      1,
      1,
      1
    ], h = vi(i.shape, a, s, c, o, l, u), d = new EL(h, "avg", false);
    return t.runWebGLProgram(d, [
      i
    ], "float32");
  }
  const x6e = {
    kernelName: Pm,
    backendName: "webgl",
    kernelFunc: y6e
  };
  let b6e = class {
    constructor(e) {
      this.variableNames = [
        "dy"
      ], this.outputShape = e.inShape;
      const t = e.filterHeight, r = e.filterWidth, i = e.strideHeight, a = e.strideWidth, s = e.dilationHeight, o = e.dilationWidth, l = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = l - 1 - e.padInfo.top, h = u - 1 - e.padInfo.left, d = 1 / (t * r);
      this.userCode = `
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }, w6e = class {
    constructor(e) {
      this.variableNames = [
        "dy"
      ], this.outputShape = e.inShape;
      const t = e.filterDepth, r = e.filterHeight, i = e.filterWidth, a = e.strideDepth, s = e.strideHeight, o = e.strideWidth, l = e.dilationDepth, u = e.dilationHeight, c = e.dilationWidth, h = e.effectiveFilterDepth, d = e.effectiveFilterHeight, f = e.effectiveFilterWidth, p = h - 1 - e.padInfo.front, g = d - 1 - e.padInfo.top, m = f - 1 - e.padInfo.left, v = 1 / (t * r * i);
      this.userCode = `
      const ivec3 pads = ivec3(${p}, ${g}, ${m});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function _6e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, s = a, { filterSize: o, strides: l, pad: u, dimRoundingMode: c } = r, h = [
      1,
      1,
      1
    ], d = vi(s.shape, o, l, h, u, c), f = new w6e(d);
    return t.runWebGLProgram(f, [
      i
    ], s.dtype);
  }
  const S6e = {
    kernelName: eb,
    backendName: "webgl",
    kernelFunc: _6e
  };
  function C6e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, s = a;
    Gb([
      i,
      a
    ], "avgPoolGrad");
    const { filterSize: o, strides: l, pad: u } = r, c = dr(s.shape, o, l, 1, u), h = new b6e(c);
    return t.runWebGLProgram(h, [
      i
    ], s.dtype);
  }
  const I6e = {
    kernelName: Jx,
    backendName: "webgl",
    kernelFunc: C6e
  };
  function k6e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { a: i, b: a } = e, { transposeA: s, transposeB: o } = r;
    return ZS({
      a: i,
      b: a,
      transposeA: s,
      transposeB: o,
      backend: t
    });
  }
  const T6e = {
    kernelName: Kd,
    backendName: "webgl",
    kernelFunc: k6e
  };
  let A6e = class {
    constructor(e, t, r, i, a, s) {
      this.outputShape = [], this.variableNames = [
        "x",
        "mean",
        "variance"
      ], ht(e, t), ht(e, r);
      let o = "0.0";
      i != null && (ht(e, i), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
      let l = "1.0";
      a != null && (ht(e, a), this.variableNames.push("scale"), l = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
  };
  class D6e {
    constructor(e, t, r, i, a, s) {
      this.packedInputs = true, this.packedOutput = true, this.variableNames = [
        "x",
        "mean",
        "variance"
      ], ht(e, t), ht(e, r);
      let o = "vec4(0.0)";
      i != null && (ht(e, i), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
      let l = "vec4(1.0)";
      a != null && (ht(e, a), this.variableNames.push("scale"), l = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
  }
  const R6e = ({ inputs: n, backend: e, attrs: t }) => {
    const { x: r, mean: i, variance: a, offset: s, scale: o } = n;
    B(i.shape.length === a.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), B(s == null || i.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), B(o == null || i.shape.length === o.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let { varianceEpsilon: l } = t;
    l == null && (l = 1e-3);
    const u = [
      r,
      i,
      a
    ];
    let c = null;
    s != null && (c = s.shape, u.push(s));
    let h = null;
    o != null && (h = o.shape, u.push(o));
    const d = ne().getBool("WEBGL_PACK_NORMALIZATION") ? new D6e(r.shape, i.shape, a.shape, c, h, l) : new A6e(r.shape, i.shape, a.shape, c, h, l);
    return e.runWebGLProgram(d, u, u[0].dtype);
  }, $6e = {
    kernelName: gf,
    backendName: "webgl",
    kernelFunc: R6e
  };
  let N6e = class {
    constructor(e) {
      this.variableNames = [
        "source"
      ], this.outputShape = e, this.rank = e.length;
      const t = Pn(this.rank);
      this.customUniforms = [
        {
          name: "start",
          arrayIndex: this.rank,
          type: "int"
        }
      ];
      const r = E6e(this.rank);
      let i;
      const a = e.map((s, o) => `sourceLoc.${F$[o]} = start[${o}] + coords.${F$[o]};`);
      i = `
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `, this.userCode = `
      void main() {
        ${i}
        setOutput(getSource(${r}));
      }
    `;
    }
  };
  const F$ = [
    "x",
    "y",
    "z",
    "w",
    "u",
    "v"
  ];
  function E6e(n) {
    if (n === 1) return "sourceLoc";
    if (n <= 6) return F$.slice(0, n).map((e) => "sourceLoc." + e).join(",");
    throw Error(`Slicing for rank ${n} is not yet supported`);
  }
  class M6e {
    constructor(e) {
      this.variableNames = [
        "source"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = e, this.rank = e.length, this.customUniforms = [
        {
          name: "start",
          arrayIndex: this.rank,
          type: "int"
        }
      ];
      const t = Pn(this.rank), r = Di("coords", this.rank), i = Di("sourceLoc", this.rank), a = this.rank === 1 ? "sourceLoc" : `vec2(${i.slice(-2).join()})`, s = `getChannel(getSource(${i.join()}), ${a})`, o = `
      result.x = ${s};
      if (++${r[this.rank - 1]} < ${e[this.rank - 1]}) {
        ++${i[this.rank - 1]};
        result.y = ${s};
        --${i[this.rank - 1]};
      }
    `, l = this.rank === 1 ? "" : `
      --${r[this.rank - 1]};
      if (++${r[this.rank - 2]} < ${e[this.rank - 2]}) {
        ++${i[this.rank - 2]};
        result.z = ${s};
        if (++${r[this.rank - 1]} < ${e[this.rank - 1]}) {
          ++${i[this.rank - 1]};
          result.w = ${s};
        }
      }
    `, u = this.rank <= 4 ? `sourceLoc = coords +
            ${t}(${e.map((c, h) => `start[${h}]`).join()});` : e.map((c, h) => `${i[h]} = ${r[h]} + start[${h}];`).join(`
`);
      this.userCode = `
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `;
    }
  }
  function P6e(n, e, t, r) {
    const i = r.texData.get(n.dataId), a = r.makeTensorInfo(t, n.dtype), s = r.texData.get(a.dataId);
    Object.assign(s, i), s.refCount = 1, s.shape = t, s.dtype = n.dtype;
    let o = EI(e, Be(n.shape));
    i.slice && (o += i.slice.flatOffset), s.slice = {
      flatOffset: o,
      origDataId: i.slice && i.slice.origDataId || n.dataId
    };
    const l = r.dataRefCount.get(s.slice.origDataId) || 1;
    return r.dataRefCount.set(s.slice.origDataId, l + 1), a;
  }
  function Fv(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { begin: a, size: s } = r, [o, l] = Av(i, a, s);
    if ($I(i, o, l), X(l) === 0) return t.makeTensorInfo(l, i.dtype, []);
    if (t.shouldExecuteOnCPU([
      i
    ]) || i.dtype === "string") {
      const h = t.texData.get(i.dataId), d = THe(h.values, o, l, i.shape, i.dtype);
      return t.makeTensorInfo(l, i.dtype, d);
    }
    const { isPacked: u } = t.texData.get(i.dataId), c = NI(i.shape, o, l);
    if (u || !c) {
      const h = ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new M6e(l) : new N6e(l), d = [
        o
      ];
      return t.runWebGLProgram(h, [
        i
      ], i.dtype, d);
    }
    return t.uploadToGPU(i.dataId), P6e(i, o, l, t);
  }
  const L6e = {
    kernelName: fv,
    backendName: "webgl",
    kernelFunc: Fv
  };
  const F6e = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockShape: a, crops: s } = r;
    B(i.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
    const o = a.reduce((y, x) => y * x), l = ou(i.shape, a, o), u = lu(l.length, a.length), c = uu(i.shape, a, o), h = Tb(s, a.length), d = Ab(c, s, a.length), f = [], p = Me({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), g = Li({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), m = Me({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), v = Fv({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        begin: h,
        size: d
      }
    });
    return f.push(p), f.push(g), f.push(m), f.forEach((y) => t.disposeIntermediateTensorInfo(y)), v;
  }, O6e = {
    kernelName: Lm,
    backendName: "webgl",
    kernelFunc: F6e
  };
  function B6e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, weights: a } = e, { size: s } = r, o = t.readSync(i.dataId), l = t.readSync(a.dataId), u = nte(o, l, a.dtype, a.shape, s);
    return t.makeTensorInfo([
      s
    ], a.dtype, u);
  }
  const z6e = {
    kernelName: Fm,
    backendName: "webgl",
    kernelFunc: B6e
  };
  const V6e = `
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`, W6e = `
  return float(int(a.r) & int(b.r));
`;
  function G6e(n) {
    const { inputs: e, backend: t } = n, { a: r, b: i } = e, a = ne().getBool("WEBGL_PACK_BINARY_OPERATIONS"), s = ne().getNumber("WEBGL_VERSION");
    if (t.shouldExecuteOnCPU([
      r,
      i
    ]) || s === 1) {
      const l = t.texData.get(r.dataId).values, u = t.texData.get(i.dataId).values, [c, h] = ZUe(r.shape, i.shape, l, u, r.dtype), d = t.makeTensorInfo(h, r.dtype), f = t.texData.get(d.dataId);
      return f.values = c, d;
    }
    let o;
    return a ? o = new Pv(V6e, r.shape, i.shape, false) : o = new Rd(W6e, r.shape, i.shape), t.runWebGLProgram(o, [
      r,
      i
    ], r.dtype);
  }
  const U6e = {
    kernelName: JC,
    backendName: "webgl",
    kernelFunc: G6e
  };
  function H6e(n) {
    const { inputs: e, backend: t } = n, { s0: r, s1: i } = e, a = t.readSync(r.dataId), s = t.readSync(i.dataId), o = ht(Array.from(a), Array.from(s));
    return t.makeTensorInfo([
      o.length
    ], "int32", Int32Array.from(o));
  }
  const X6e = {
    kernelName: eI,
    backendName: "webgl",
    kernelFunc: H6e
  };
  const Y6e = "return float(a != b);", mte = li({
    opSnippet: Y6e,
    cpuKernelImpl: yHe,
    dtype: "bool"
  }), q6e = {
    kernelName: iv,
    backendName: "webgl",
    kernelFunc: mte
  };
  function Hb(n) {
    const { inputs: e, backend: t } = n, { input: r } = e, i = t.texData.get(r.dataId);
    return Ta({
      inputs: {
        x: i.complexTensorInfos.real
      },
      backend: t
    });
  }
  const j6e = {
    kernelName: hI,
    backendName: "webgl",
    kernelFunc: Hb
  };
  const K6e = "return float(int(x));";
  function Z6e(n, e) {
    const t = new Wo(n.shape, K6e), r = e.runWebGLProgram(t, [
      n
    ], "int32");
    return {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  function O$(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { dtype: a } = r;
    if (a === "complex64") {
      if (i.dtype === "complex64") return Ta({
        inputs: {
          x: i
        },
        backend: t
      });
      const s = Cr(i.shape), o = O$({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          dtype: "float32"
        }
      }), l = Dc({
        inputs: {
          real: o,
          imag: s
        },
        backend: t
      });
      return s.dispose(), t.disposeIntermediateTensorInfo(o), l;
    }
    if (i.dtype === "complex64") {
      const s = Hb({
        inputs: {
          input: i
        },
        backend: t
      }), o = O$({
        inputs: {
          x: s
        },
        backend: t,
        attrs: {
          dtype: a
        }
      });
      return t.disposeIntermediateTensorInfo(s), o;
    }
    if (!UM(i.dtype, a)) {
      const s = Ta({
        inputs: {
          x: i
        },
        backend: t
      });
      return {
        dataId: s.dataId,
        shape: s.shape,
        dtype: a
      };
    }
    if (t.shouldExecuteOnCPU([
      i
    ])) {
      const s = t.texData.get(i.dataId).values, [o, l, u] = QUe(s, i.shape, i.dtype, a);
      return t.makeTensorInfo(o, l, u);
    }
    if (a === "int32") return Z6e(i, t);
    if (a === "bool") {
      const s = t.makeTensorInfo([], "bool", Yr("bool", 1)), l = mte({
        inputs: {
          a: i,
          b: s
        },
        backend: t
      });
      return t.disposeIntermediateTensorInfo(s), l;
    }
    throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`);
  }
  const Q6e = {
    kernelName: Zd,
    backendName: "webgl",
    kernelFunc: O$
  };
  const MU = "return ceil(x);", J6e = cn({
    opSnippet: MU,
    packedOpSnippet: MU,
    cpuKernelImpl: JUe
  }), e8e = {
    kernelName: Qd,
    backendName: "webgl",
    kernelFunc: J6e
  };
  let t8e = class {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.customUniforms = [
        {
          name: "minVal",
          type: "float"
        },
        {
          name: "maxVal",
          type: "float"
        }
      ], this.outputShape = e, this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
  };
  class n8e {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "minVal",
          type: "float"
        },
        {
          name: "maxVal",
          type: "float"
        }
      ], this.outputShape = e, this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
  }
  function r8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { clipValueMin: a, clipValueMax: s } = r;
    let o;
    ne().getBool("WEBGL_PACK_CLIP") ? o = new n8e(i.shape) : o = new t8e(i.shape);
    const l = [
      [
        a
      ],
      [
        s
      ]
    ];
    return t.runWebGLProgram(o, [
      i
    ], i.dtype, l);
  }
  const i8e = {
    kernelName: bc,
    backendName: "webgl",
    kernelFunc: r8e
  };
  let a8e = class {
    constructor(e) {
      this.variableNames = [
        "real",
        "imag"
      ], this.outputShape = e, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
  };
  function PU(n, e) {
    return {
      dataId: e.dataId,
      dtype: e.dtype,
      shape: n.shape
    };
  }
  function s8e(n) {
    const { inputs: e, backend: t } = n, { x: r } = e, i = t.texData.get(r.dataId), a = new a8e(r.shape), s = [
      PU(r, i.complexTensorInfos.real),
      PU(r, i.complexTensorInfos.imag)
    ];
    return t.runWebGLProgram(a, s, s[0].dtype);
  }
  const o8e = {
    kernelName: tb,
    backendName: "webgl",
    kernelFunc: s8e
  };
  let l8e = class {
    constructor(e) {
      this.outputShape = [], this.outputShape = ai(e, 1), this.variableNames = e.map((s, o) => `T${o}`);
      const t = new Array(e.length - 1);
      t[0] = e[0][1];
      for (let s = 1; s < t.length; s++) t[s] = t[s - 1] + e[s][1];
      const r = [
        `if (yC < ${t[0]}) setOutput(getT0(yR, yC));`
      ];
      for (let s = 1; s < t.length; s++) {
        const o = t[s - 1];
        r.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${o}));`);
      }
      const i = t.length, a = t[t.length - 1];
      r.push(`else setOutput(getT${i}(yR, yC-${a}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `;
    }
  };
  class u8e {
    constructor(e, t) {
      this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = ai(e, t);
      const r = this.outputShape, i = r.length, a = Pn(i), s = Di("coords", i), o = [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
      ].slice(0, i);
      this.variableNames = e.map((g, m) => `T${m}`);
      const l = new Array(e.length - 1);
      l[0] = e[0][t];
      for (let g = 1; g < l.length; g++) l[g] = l[g - 1] + e[g][t];
      const u = o[t], c = o.slice(-2), h = o.join();
      let d = `if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;
      for (let g = 1; g < l.length; g++) {
        const m = l[g - 1];
        d += `
        if (${u} < ${l[g]}  && ${u} >= ${l[g - 1]}) {
          return getChannel(
            getT${g}(${kw(o, u, m)}),
            vec2(${kw(c, u, m)}));
        }`;
      }
      const f = l.length, p = l[l.length - 1];
      d += `
        return getChannel(
          getT${f}(${kw(o, u, p)}),
          vec2(${kw(c, u, p)}));`, this.userCode = `
      float getValue(${o.map((g) => "int " + g)}) {
        ${d}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[i - 1]} = ${s[i - 1]} + 1;
        if (${s[i - 1]} < ${r[i - 1]}) {
          result.g = getValue(${s});
        }

        ${s[i - 2]} = ${s[i - 2]} + 1;
        if (${s[i - 2]} < ${r[i - 2]}) {
          result.a = getValue(${s});
        }

        ${s[i - 1]} = ${s[i - 1]} - 1;
        if (${s[i - 2]} < ${r[i - 2]} &&
            ${s[i - 1]} < ${r[i - 1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `;
    }
  }
  function kw(n, e, t) {
    const r = n.indexOf(e);
    return n.map((a, s) => s === r ? `${a} - ${t}` : a).join();
  }
  function l2(n) {
    const { inputs: e, backend: t } = n, { input: r } = e, i = t.texData.get(r.dataId);
    return Ta({
      inputs: {
        x: i.complexTensorInfos.imag
      },
      backend: t
    });
  }
  const c8e = {
    kernelName: uI,
    backendName: "webgl",
    kernelFunc: l2
  };
  function Yy(n, e, t) {
    const r = n[0].dtype;
    if (r === "complex64") {
      const f = n.map((y) => Hb({
        inputs: {
          input: y
        },
        backend: t
      })), p = n.map((y) => l2({
        inputs: {
          input: y
        },
        backend: t
      })), g = Yy(f, e, t), m = Yy(p, e, t), v = Dc({
        inputs: {
          real: g,
          imag: m
        },
        backend: t
      });
      return f.forEach((y) => t.disposeIntermediateTensorInfo(y)), p.forEach((y) => t.disposeIntermediateTensorInfo(y)), t.disposeIntermediateTensorInfo(g), t.disposeIntermediateTensorInfo(m), v;
    }
    let i = t.shouldExecuteOnCPU(n);
    if (r === "string" && (i = true), i) {
      const f = n.map((b) => {
        const _ = [
          -1,
          X(b.shape.slice(e))
        ];
        return Me({
          inputs: {
            x: b
          },
          backend: t,
          attrs: {
            shape: _
          }
        });
      }), p = f.map((b) => ({
        vals: t.readSync(b.dataId),
        shape: b.shape
      })), g = ai(f.map((b) => b.shape), 1), m = f[0].shape[0] === 1, v = eHe(p, g, r, m), y = ai(n.map((b) => b.shape), e), x = t.makeTensorInfo(y, r, v);
      return f.forEach((b) => t.disposeIntermediateTensorInfo(b)), x;
    }
    const a = n.filter((f) => X(f.shape) > 0), s = ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && a[0].shape.length > 1;
    if (a.length === 1) {
      const f = s ? new Wo(n[0].shape, Ru) : new Gu(n[0].shape, Ru);
      return t.runWebGLProgram(f, n, r);
    }
    const o = ne().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
    if (a.length > o) {
      const f = [];
      for (let g = 0; g < a.length; g += o) {
        const m = a.slice(g, g + o);
        f.push(Yy(m, e, t));
      }
      const p = Yy(f, e, t);
      for (const g of f) t.disposeIntermediateTensorInfo(g);
      return p;
    }
    if (s) {
      const f = new u8e(a.map((p) => p.shape), e);
      return t.runWebGLProgram(f, a, r);
    }
    const { tensors2D: l, outShape: u } = h8e(a, e, t), c = new l8e(l.map((f) => f.shape)), h = t.runWebGLProgram(c, l, r);
    l.forEach((f) => t.disposeIntermediateTensorInfo(f));
    const d = Me({
      inputs: {
        x: h
      },
      attrs: {
        shape: u
      },
      backend: t
    });
    return t.disposeIntermediateTensorInfo(h), d;
  }
  function h8e(n, e, t) {
    const r = ai(n.map((a) => a.shape), e);
    return {
      tensors2D: n.map((a) => Me({
        inputs: {
          x: a
        },
        attrs: {
          shape: [
            -1,
            X(a.shape.slice(e))
          ]
        },
        backend: t
      })),
      outShape: r
    };
  }
  function vte(n) {
    const { inputs: e, backend: t, attrs: r } = n, { axis: i } = r, a = yt(i, e[0].shape)[0], s = e.map((u) => u.shape);
    Ib(s, a);
    const o = ai(e.map((u) => u.shape), a);
    if (X(o) === 0) return t.makeTensorInfo(o, e[0].dtype, []);
    const l = e.filter((u) => X(u.shape) > 0);
    return l.length === 1 ? Ta({
      inputs: {
        x: l[0]
      },
      backend: t
    }) : Yy(l, a, t);
  }
  const d8e = {
    kernelName: Om,
    backendName: "webgl",
    kernelFunc: vte
  };
  class yte {
    constructor(e, t = false, r = null, i = false, a = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.outputShape = e.outShape;
      const s = e.padInfo.top, o = e.padInfo.left, l = e.strideHeight, u = e.strideWidth, c = e.dilationHeight, h = e.dilationWidth, d = e.filterHeight, f = e.filterWidth, p = Math.floor(e.inChannels / 4) * 4, g = e.inChannels % 4, m = e.dataFormat === "channelsLast", v = m ? 1 : 2, y = m ? 2 : 3, x = m ? 3 : 1;
      let b = "", w = "";
      r && (i ? b = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : a ? b = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : b = `
          float activation(float x) {
            ${r}
          }
        `, w = "result = activation(result);");
      const _ = t ? "result += getBiasAtOutCoords();" : "";
      t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${b}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g === 1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${g === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${w}
        setOutput(result);
      }
    `;
    }
  }
  class f8e {
    constructor(e) {
      this.variableNames = [
        "x",
        "W"
      ], this.outputShape = e.outShape;
      const t = e.padInfo.front, r = e.padInfo.top, i = e.padInfo.left, a = e.strideDepth, s = e.strideHeight, o = e.strideWidth, l = e.dilationDepth, u = e.dilationHeight, c = e.dilationWidth, h = e.filterDepth, d = e.filterHeight, f = e.filterWidth, p = Math.floor(e.inChannels / 4) * 4, g = e.inChannels % 4;
      this.userCode = `
      const ivec3 strides = ivec3(${a}, ${s}, ${o});
      const ivec3 pads = ivec3(${t}, ${r}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${g === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }
  class xte {
    constructor(e, t = false, r = null, i = false, a = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "pads",
          type: "ivec2"
        },
        {
          name: "strides",
          type: "ivec2"
        },
        {
          name: "dilations",
          type: "ivec2"
        },
        {
          name: "inDims",
          type: "ivec2"
        }
      ], this.outputShape = e.outShape, this.enableShapeUniforms = xi(this.outputShape.length);
      const s = e.padInfo.left, o = e.strideWidth, l = e.dilationWidth, u = e.filterHeight, c = e.filterWidth, h = c;
      let d = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
      for (let m = 0; m < c; m++) d += `
           vec4 xTexelC${m * 2};
           int xTexelC${m * 2}Ready;
           vec4 xTexelC${m * 2 + 1};
           int xTexelC${m * 2 + 1}Ready;
           vec4 xC${m};`;
      d += `
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;
      for (let m = 0; m < c; m++) d += `
           xTexelC${m * 2} = vec4(0.0);
           xTexelC${m * 2}Ready = 0;
           xTexelC${m * 2 + 1} = vec4(0.0);
           xTexelC${m * 2 + 1}Ready = 0;
           xC${m} = vec4(0.0);`;
      d += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
      for (let m = 0; m < (h + 1) / 2; m++) {
        const v = m * 2;
        if (d += `
           xC = xCCorner + ${v * l};
           `, o === 1) {
          if (v < c && (s % 2 === 1 ? (d += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `, l === 1 && v > 0 ? d += `
                 xC${v} = vec4(xTexelC${v - 2}.zw, xTexelC${v}.xy);
                 ` : d += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `) : d += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `, v + 1 < c)) {
            const y = s % 2 === 0 ? GM(l) : l;
            l % 2 === 0 && s % 2 === 1 || l % 2 !== 0 && s % 2 !== 1 ? (d += `
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v + 1}Ready == 0) {
                     xTexelC${v + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v + 1}.zw = vec2(0.0);
                     }
                     xTexelC${v + 1}Ready = 1;
                   }
                   `, l > 1 ? d += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v + 1} = vec4(previous.zw, xTexelC${v + 1}.xy);
                     } else {
                      xC${v + 1} = vec4(0.0, 0.0, xTexelC${v + 1}.xy);
                     }
                     ` : d += `
                     xC${v + 1} = vec4(xTexelC${v}.zw, xTexelC${v + 1}.xy);
                     `) : y === 1 ? d += `
                     xC${v + 1} = xTexelC${v};
                     ` : d += `
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v + 1}Ready == 0) {
                       xTexelC${v + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v + 1}.zw = vec2(0.0);
                       }
                       xTexelC${v + 1}Ready = 1;
                     }

                     xC${v + 1} = xTexelC${v + 1};
                     `;
          }
        } else v < c && (s % 2 === 1 ? (d += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v + 1}Ready == 0) {
                   xTexelC${v + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v + 1}.zw = vec2(0.0);
                   }
                   xTexelC${v + 1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v + 1}.zw);
               `, v + 1 < c && (d += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v + 1} = vec4(xTexelC${v + 1}.xy, final.xy);
                 `)) : (d += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v + 1}Ready == 0) {
                   xTexelC${v + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v + 1}.zw = vec2(0.);
                   }
                   xTexelC${v + 1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v + 1}.xy);
               `, v + 1 < c && (d += `
                   xC${v + 1} = vec4(xTexelC${v}.zw, xTexelC${v + 1}.zw);
                 `)));
        v < c && (d += `
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `, v + 1 < c && (d += `
               wTexel = getW(r, ${v + 1}, d1, d2);
               dotProd += xC${v + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `));
      }
      d += `
     }
   `, d += `
     }
   `, d += `
     }
   `;
      let f = "", p = "";
      r && (i ? f = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }` : a ? f = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }` : f = `vec4 activation(vec4 x) {
           ${r}
         }`, p = "result = activation(result);");
      const g = t ? "result += getBiasAtOutCoords();" : "";
      t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = `
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${p}
         setOutput(result);
       }
     `;
    }
  }
  class p8e {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "inputShape",
          type: "ivec4"
        },
        {
          name: "pad",
          type: "ivec2"
        },
        {
          name: "stride",
          type: "ivec2"
        },
        {
          name: "dilation",
          type: "ivec2"
        },
        {
          name: "inChannels",
          type: "int"
        },
        {
          name: "itemsPerBlockRow",
          type: "int"
        },
        {
          name: "outWidth",
          type: "int"
        }
      ], this.outputShape = e, this.enableShapeUniforms = xi(this.outputShape.length);
      const { dataFormat: r } = t, i = Bi(), a = r === "channelsLast", s = a ? 1 : 2, o = a ? 2 : 3, l = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;
      let u = "";
      for (let c = 0; c <= 1; c++) for (let h = 0; h <= 1; h++) u += `
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c * 2 + h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c * 2 + h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
      this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${i.output} = result;
      }
    `;
    }
  }
  function QS(n, e) {
    const t = n.length;
    return t >= 3 ? e ? [
      ...n.slice(0, -3),
      n[t - 3] * n[t - 2],
      n[t - 1]
    ] : [
      ...n.slice(0, -3),
      n[t - 3],
      n[t - 2] * n[t - 1]
    ] : !e && t === 1 && n[0] > 1 ? [
      n[0],
      1
    ] : null;
  }
  function bte({ x: n, filter: e, convInfo: t, backend: r, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: s = 0, activation: o = null }) {
    const l = n.shape, u = r.texData.get(n.dataId), c = t.inChannels, h = l[0] * l[1] * l[2], d = t.outChannels, f = t.dataFormat === "channelsLast", p = false, g = false;
    let m;
    const v = [];
    if (a != null) {
      const b = QS(a.shape, f);
      b != null && (a = Me({
        inputs: {
          x: a
        },
        backend: r,
        attrs: {
          shape: b
        }
      }), v.push(a));
    }
    if (i != null) {
      const b = QS(i.shape, f);
      b != null && (i = Me({
        inputs: {
          x: i
        },
        backend: r,
        attrs: {
          shape: b
        }
      }), v.push(i));
    }
    if (!((h === 1 || d === 1) && c > dte) && u.isPacked && f && u.texture != null && l[2] % 2 !== 0 && Jt(u.shape.slice(-3), l.slice(-3))) {
      const b = l[0] * l[1] * (l[2] + 1), w = {
        dataId: n.dataId,
        shape: [
          1,
          b,
          t.inChannels
        ],
        dtype: n.dtype
      }, _ = u.shape;
      u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, B(KS(u.shape, w.shape), () => `packed reshape ${u.shape} to ${w.shape} isn't free`);
      const S = Me({
        inputs: {
          x: e
        },
        backend: r,
        attrs: {
          shape: [
            1,
            t.inChannels,
            t.outChannels
          ]
        }
      });
      v.push(S);
      const I = ZS({
        a: w,
        b: S,
        backend: r,
        transposeA: p,
        transposeB: g,
        bias: i,
        activation: o,
        preluActivationWeights: a,
        leakyreluAlpha: s
      }), C = r.texData.get(I.dataId);
      B(C.isPacked, () => "batchMatMul result is expected to be packed"), u.shape = _, C.shape = t.outShape, m = Ta({
        inputs: {
          x: I
        },
        backend: r
      }), m.shape = t.outShape, v.push(I);
    } else {
      const b = t.outHeight * t.outWidth, w = Me({
        inputs: {
          x: n
        },
        backend: r,
        attrs: {
          shape: f ? [
            t.batchSize,
            b,
            t.inChannels
          ] : [
            t.batchSize,
            t.inChannels,
            b
          ]
        }
      }), _ = Me({
        inputs: {
          x: e
        },
        backend: r,
        attrs: {
          shape: [
            1,
            t.inChannels,
            t.outChannels
          ]
        }
      }), S = ZS({
        a: f ? w : _,
        b: f ? _ : w,
        transposeA: !f,
        transposeB: g,
        backend: r,
        bias: i,
        activation: o,
        preluActivationWeights: a,
        leakyreluAlpha: s
      });
      m = Me({
        inputs: {
          x: S
        },
        backend: r,
        attrs: {
          shape: t.outShape
        }
      }), v.push(w), v.push(_), v.push(S);
    }
    for (const b of v) r.disposeIntermediateTensorInfo(b);
    return m;
  }
  function wte({ x: n, filter: e, convInfo: t, backend: r, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: s = 0, activation: o = null }) {
    const { filterWidth: l, filterHeight: u, inChannels: c, outWidth: h, outHeight: d, dataFormat: f } = t, p = f === "channelsLast", g = l * u * c, m = d * h, v = [
      t.batchSize,
      g,
      m
    ], y = true, x = false, b = [];
    if (a != null) {
      const $ = QS(a.shape, p);
      $ != null && (a = Me({
        inputs: {
          x: a
        },
        backend: r,
        attrs: {
          shape: $
        }
      }), b.push(a));
    }
    if (i != null) {
      const $ = QS(i.shape, p);
      $ != null && (i = Me({
        inputs: {
          x: i
        },
        backend: r,
        attrs: {
          shape: $
        }
      }), b.push(i));
    }
    const w = Me({
      inputs: {
        x: e
      },
      backend: r,
      attrs: {
        shape: [
          1,
          g,
          X(e.shape) / g
        ]
      }
    });
    b.push(w);
    const _ = new p8e(v, t), S = [
      n.shape,
      [
        t.padInfo.top,
        t.padInfo.left
      ],
      [
        t.strideHeight,
        t.strideWidth
      ],
      [
        t.dilationHeight,
        t.dilationWidth
      ],
      [
        t.inChannels
      ],
      [
        t.filterWidth * t.inChannels
      ],
      [
        t.outWidth
      ]
    ], I = r.runWebGLProgram(_, [
      n
    ], "float32", S), C = Me({
      inputs: {
        x: I
      },
      backend: r,
      attrs: {
        shape: v
      }
    });
    b.push(I), b.push(C);
    const T = i != null, k = a != null, D = o === "leakyrelu", R = o ? px(o, true) : null, N = new hte(p ? C.shape : w.shape, p ? w.shape : C.shape, p ? [
      t.batchSize,
      m,
      t.outChannels
    ] : [
      t.batchSize,
      t.outChannels,
      m
    ], y, x, T, R, k, D), E = p ? [
      C,
      w
    ] : [
      w,
      C
    ];
    if (i && E.push(i), k && E.push(a), D) {
      const $ = r.makeTensorInfo([], "float32", Sc(s, "float32"));
      E.push($), b.push($);
    }
    const A = r.runWebGLProgram(N, E, "float32"), M = Me({
      inputs: {
        x: A
      },
      backend: r,
      attrs: {
        shape: t.outShape
      }
    });
    b.push(A);
    for (const $ of b) r.disposeIntermediateTensorInfo($);
    return M;
  }
  function g8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dataFormat: l, dilations: u, dimRoundingMode: c } = r, h = Oi(l), d = Sn(i.shape, a.shape, s, u, o, c, false, h);
    let f;
    if (d.filterHeight === 1 && d.filterWidth === 1 && d.dilationHeight === 1 && d.dilationWidth === 1 && d.strideHeight === 1 && d.strideWidth === 1 && (d.padInfo.type === "SAME" || d.padInfo.type === "VALID")) f = bte({
      x: i,
      filter: a,
      convInfo: d,
      backend: t
    });
    else if (d.strideWidth <= 2 && h === "channelsLast" && ne().getBool("WEBGL_EXP_CONV")) {
      const g = new xte(d), m = [
        [
          d.padInfo.top,
          d.padInfo.left
        ],
        [
          d.strideHeight,
          d.strideWidth
        ],
        [
          d.dilationHeight,
          d.dilationWidth
        ],
        [
          d.inHeight,
          d.inWidth
        ]
      ];
      f = t.runWebGLProgram(g, [
        i,
        a
      ], "float32", m);
    } else if (ne().getBool("WEBGL_CONV_IM2COL")) f = wte({
      x: i,
      filter: a,
      convInfo: d,
      backend: t
    });
    else {
      const g = new yte(d);
      f = t.runWebGLProgram(g, [
        i,
        a
      ], "float32");
    }
    const p = Me({
      inputs: {
        x: f
      },
      backend: t,
      attrs: {
        shape: d.outShape
      }
    });
    return t.disposeIntermediateTensorInfo(f), p;
  }
  const m8e = {
    kernelName: Jd,
    backendName: "webgl",
    kernelFunc: g8e
  };
  let v8e = class {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.outputShape = e.filterShape;
      const t = e.strideHeight, r = e.strideWidth, i = e.padInfo.top, a = e.padInfo.left, s = e.dataFormat === "channelsLast";
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s ? `float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);` : `float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }, y8e = class {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.outputShape = e.inShape;
      const t = e.filterHeight, r = e.filterWidth, i = e.strideHeight, a = e.strideWidth, s = e.dataFormat === "channelsLast", o = t - 1 - e.padInfo.top, l = r - 1 - e.padInfo.left, u = s ? 1 : 2, c = s ? 2 : 3, h = s ? 3 : 1;
      this.userCode = `
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }, x8e = class {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.outputShape = e.filterShape;
      const t = e.strideDepth, r = e.strideHeight, i = e.strideWidth, a = e.padInfo.front, s = e.padInfo.top, o = e.padInfo.left;
      this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }, b8e = class {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.outputShape = e.inShape;
      const t = e.filterDepth, r = e.filterHeight, i = e.filterWidth, a = e.strideDepth, s = e.strideHeight, o = e.strideWidth, l = t - 1 - e.padInfo.front, u = r - 1 - e.padInfo.top, c = i - 1 - e.padInfo.left;
      this.userCode = `
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function w8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, pad: o, dataFormat: l, dimRoundingMode: u, filterShape: c } = r, h = Oi(l), d = Sn(i.shape, c, s, 1, o, u, false, h), f = new v8e(d);
    return t.runWebGLProgram(f, [
      i,
      a
    ], "float32");
  }
  const _8e = {
    kernelName: nI,
    backendName: "webgl",
    kernelFunc: w8e
  };
  class S8e {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "strides",
          type: "vec2"
        }
      ], this.outputShape = e.inShape, this.enableShapeUniforms = xi(this.outputShape.length);
      const t = e.filterHeight, r = e.filterWidth, i = t - 1 - e.padInfo.top, a = r - 1 - e.padInfo.left;
      this.userCode = `
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
    }
  }
  function C8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { inputShape: s, strides: o, pad: l, dataFormat: u, dimRoundingMode: c } = r, h = Oi(u), d = Sn(s, a.shape, o, 1, l, c, false, h);
    if (ne().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && h === "channelsLast") {
      const f = [
        [
          d.strideHeight,
          d.strideWidth
        ]
      ], p = new S8e(d);
      return t.runWebGLProgram(p, [
        i,
        a
      ], "float32", f);
    } else {
      const f = new y8e(d);
      return t.runWebGLProgram(f, [
        i,
        a
      ], "float32");
    }
  }
  const I8e = {
    kernelName: ef,
    backendName: "webgl",
    kernelFunc: C8e
  };
  function k8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l } = r, u = Ra(i.shape, a.shape, s, l, o), c = new f8e(u);
    return t.runWebGLProgram(c, [
      i,
      a
    ], "float32");
  }
  const T8e = {
    kernelName: tf,
    backendName: "webgl",
    kernelFunc: k8e
  };
  function A8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, pad: o, filterShape: l } = r, u = Ra(i.shape, l, s, 1, o), c = new x8e(u);
    return t.runWebGLProgram(c, [
      i,
      a
    ], "float32");
  }
  const D8e = {
    kernelName: Bm,
    backendName: "webgl",
    kernelFunc: A8e
  };
  function R8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { pad: s, strides: o, inputShape: l } = r, u = Ra(l, a.shape, o, 1, s), c = new b8e(u);
    return t.runWebGLProgram(c, [
      i,
      a
    ], "float32");
  }
  const $8e = {
    kernelName: zm,
    backendName: "webgl",
    kernelFunc: R8e
  };
  const N8e = Lv + `
  return cos(x);
`, E8e = `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${fp}
  return result;
`, M8e = cn({
    opSnippet: N8e,
    packedOpSnippet: E8e
  }), P8e = {
    kernelName: nf,
    backendName: "webgl",
    kernelFunc: M8e
  };
  const L8e = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`, F8e = cn({
    opSnippet: L8e
  }), O8e = {
    kernelName: rf,
    backendName: "webgl",
    kernelFunc: F8e
  };
  let B8e = class {
    constructor(e, t, r, i, a) {
      this.variableNames = [
        "Image",
        "Boxes",
        "BoxInd"
      ], this.outputShape = [];
      const [s, o, l, u] = e, [c] = t, [h, d] = r;
      this.outputShape = [
        c,
        h,
        d,
        u
      ];
      const f = i === "bilinear" ? 1 : 0, [p, g] = [
        `${o - 1}.0`,
        `${l - 1}.0`
      ], [m, v, y] = h > 1 ? [
        `${(o - 1) / (h - 1)}`,
        "(y2-y1) * height_ratio",
        `y1*${p} + float(y)*(height_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (y1+y2) * ${p}`
      ], [x, b, w] = d > 1 ? [
        `${(l - 1) / (d - 1)}`,
        "(x2-x1) * width_ratio",
        `x1*${g} + float(x)*(width_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (x1+x2) * ${g}`
      ];
      this.userCode = `
      const float height_ratio = float(${m});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${b};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
  };
  const z8e = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { image: i, boxes: a, boxInd: s } = e, { cropSize: o, method: l, extrapolationValue: u } = r, c = new B8e(i.shape, a.shape, o, l, u);
    return t.runWebGLProgram(c, [
      i,
      a,
      s
    ], "float32");
  }, V8e = {
    kernelName: Wm,
    backendName: "webgl",
    kernelFunc: z8e
  };
  var mx;
  (function(n) {
    n.Prod = "*", n.Sum = "+";
  })(mx || (mx = {}));
  let LU = class {
    constructor(e, t, r, i) {
      this.op = e, this.outputShape = t, this.variableNames = [
        "x"
      ], this.customUniforms = [
        {
          name: "index",
          type: "float"
        }
      ];
      const a = this.outputShape.length, s = this.op === mx.Prod ? "1.0" : "0.0", o = r ? s : `getX(${FU(a, "coords", this.op)})`, l = this.outputShape[this.outputShape.length - 1];
      let u = "", c = "";
      r ? (u = i ? `end != ${l - 1}` : "end != 0", c = i ? "end + 1" : "end - 1") : (u = i ? `end + pow2 < ${l}` : "end >= pow2", c = i ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${Pn(a)} coords = getOutputCoords();
        int end = ${OU(a, "coords", this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${OU(a, "coords", this.op)} = idx;
          val ${this.op}= getX(${FU(a, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
    }
  };
  function FU(n, e, t) {
    if (n === 1) return `${e}`;
    if (n === 2) return `${e}.x, ${e}.y`;
    if (n === 3) return `${e}.x, ${e}.y, ${e}.z`;
    if (n === 4) return `${e}.x, ${e}.y, ${e}.z, ${e}.w`;
    throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`);
  }
  function OU(n, e, t) {
    if (n === 1) return `${e}`;
    if (n === 2) return `${e}.y`;
    if (n === 3) return `${e}.z`;
    if (n === 4) return `${e}.w`;
    throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`);
  }
  function _te(n, e, t, r, i, a) {
    const s = e.shape.length, o = bn([
      r
    ], s);
    let l = e;
    o != null && (l = Li({
      inputs: {
        x: e
      },
      backend: t,
      attrs: {
        perm: o
      }
    }));
    const u = gn(1, s)[0];
    if (u !== s - 1) throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length - 1} but got axis=${r}`);
    const c = l.shape[u];
    let h = Ta({
      inputs: {
        x: l
      },
      backend: t
    });
    for (let d = 0; d <= Math.ceil(Math.log2(c)) - 1; d++) {
      const f = new LU(n, l.shape, false, a), p = [
        [
          d
        ]
      ], g = h;
      h = t.runWebGLProgram(f, [
        h
      ], h.dtype, p), t.disposeIntermediateTensorInfo(g);
    }
    if (i) {
      const d = new LU(n, l.shape, i, a), f = h;
      h = t.runWebGLProgram(d, [
        h
      ], h.dtype), t.disposeIntermediateTensorInfo(f);
    }
    if (o != null) {
      const d = As(o), f = Li({
        inputs: {
          x: h
        },
        backend: t,
        attrs: {
          perm: d
        }
      });
      return t.disposeIntermediateTensorInfo(h), t.disposeIntermediateTensorInfo(l), f;
    }
    return h;
  }
  function W8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, exclusive: s, reverse: o } = r;
    return _te(mx.Prod, i, t, a, s, o);
  }
  const G8e = {
    kernelName: Vm,
    backendName: "webgl",
    kernelFunc: W8e
  };
  function U8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, exclusive: s, reverse: o } = r;
    return _te(mx.Sum, i, t, a, s, o);
  }
  const H8e = {
    kernelName: af,
    backendName: "webgl",
    kernelFunc: U8e
  };
  function X8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, weights: a } = e, { size: s, binaryOutput: o } = r;
    if (i.shape.length === 1) {
      const l = t.readSync(i.dataId), u = t.readSync(a.dataId), c = nte(l, u, a.dtype, a.shape, s);
      return t.makeTensorInfo([
        s
      ], a.dtype, c);
    } else if (i.shape.length === 2) {
      const l = t.bufferSync(i), u = t.bufferSync(a), c = KUe(l, u, s, o);
      return t.makeTensorInfo(c.shape, a.dtype, c.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`);
  }
  const Y8e = {
    kernelName: nb,
    backendName: "webgl",
    kernelFunc: X8e
  };
  let q8e = class {
    constructor(e, t, r) {
      this.variableNames = [
        "x"
      ], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = r, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
      return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
      return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
    }
    getInputSamplingString() {
      return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
  };
  function j8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockSize: a, dataFormat: s } = r, o = i.shape[0], l = s === "NHWC" ? i.shape[1] : i.shape[2], u = s === "NHWC" ? i.shape[2] : i.shape[3], c = s === "NHWC" ? i.shape[3] : i.shape[1], h = l * a, d = u * a, f = c / (a * a), p = s === "NHWC" ? [
      o,
      h,
      d,
      f
    ] : [
      o,
      f,
      h,
      d
    ], g = new q8e(p, a, s);
    return t.runWebGLProgram(g, [
      i
    ], i.dtype);
  }
  const K8e = {
    kernelName: Gm,
    backendName: "webgl",
    kernelFunc: j8e
  };
  let Ste = class {
    constructor(e, t = false, r = null, i = false, a = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.customUniforms = [
        {
          name: "pads",
          type: "ivec2"
        },
        {
          name: "strides",
          type: "ivec2"
        },
        {
          name: "dilations",
          type: "ivec2"
        },
        {
          name: "inDims",
          type: "ivec2"
        }
      ], this.outputShape = e.outShape, this.enableShapeUniforms = xi(this.outputShape.length);
      const s = e.filterHeight, o = e.filterWidth, l = e.outChannels / e.inChannels;
      let u = "", c = "";
      r && (i ? u = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : a ? u = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : u = `
          float activation(float x) {
            ${r}
          }
        `, c = "result = activation(result);");
      const h = t ? "result += getBiasAtOutCoords();" : "";
      t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `;
    }
  };
  class Cte {
    constructor(e, t = false, r = null, i = false, a = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "pads",
          type: "ivec2"
        },
        {
          name: "strides",
          type: "ivec2"
        },
        {
          name: "dilations",
          type: "ivec2"
        },
        {
          name: "inDims",
          type: "ivec2"
        }
      ], this.outputShape = e.outShape, this.enableShapeUniforms = xi(this.outputShape.length);
      const s = e.outChannels / e.inChannels, o = e.padInfo.left, l = e.strideWidth, u = e.dilationWidth, c = e.filterHeight, h = e.filterWidth, d = h;
      let f = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
      for (let v = 0; v < h; v++) f += `
          vec4 xTexelC${v * 2};
          int xTexelC${v * 2}Ready;
          vec4 xTexelC${v * 2 + 1};
          int xTexelC${v * 2 + 1}Ready;
          vec4 xC${v};`;
      f += `
    for (int r = 0; r < ${c}; r++) {
      `;
      for (let v = 0; v < h; v++) f += `
          xTexelC${v * 2} = vec4(0.0);
          xTexelC${v * 2}Ready = 0;
          xTexelC${v * 2 + 1} = vec4(0.0);
          xTexelC${v * 2 + 1}Ready = 0;
          xC${v} = vec4(0.0);`;
      f += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
      for (let v = 0; v < (d + 1) / 2; v++) {
        const y = v * 2;
        if (f += `
          xC = xCCorner + ${y * u};
          `, l === 1) {
          if (y < h && (o % 2 === 1 ? (f += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `, u === 1 && y > 0 ? f += `
                xC${y} = vec4(xTexelC${y - 2}.zw, xTexelC${y}.xy);
                ` : f += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `) : f += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `, y + 1 < h)) {
            const x = o % 2 === 0 ? GM(u) : u;
            u % 2 === 0 && o % 2 === 1 || u % 2 !== 0 && o % 2 !== 1 ? (f += `
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                    xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y + 1}.zw = vec2(0.0);
                    }
                    xTexelC${y + 1}Ready = 1;
                  }
                  `, u > 1 ? f += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y + 1} = vec4(previous.zw, xTexelC${y + 1}.xy);
                    } else {
                     xC${y + 1} = vec4(0.0, 0.0, xTexelC${y + 1}.xy);
                    }
                    ` : f += `
                    xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.xy);
                    `) : x === 1 ? f += `
                    xC${y + 1} = xTexelC${y};
                    ` : f += `
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                      xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y + 1}.zw = vec2(0.0);
                      }
                      xTexelC${y + 1}Ready = 1;
                    }

                    xC${y + 1} = xTexelC${y + 1};
                    `;
          }
        } else y < h && (o % 2 === 1 ? (f += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y + 1}Ready == 0) {
                  xTexelC${y + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y + 1}.zw = vec2(0.0);
                  }
                  xTexelC${y + 1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
              `, y + 1 < h && (f += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y + 1} = vec4(xTexelC${y + 1}.xy, final.xy);
                `)) : (f += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                  xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y + 1}.zw = vec2(0.);
                  }
                  xTexelC${y + 1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y + 1}.xy);
              `, y + 1 < h && (f += `
                  xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
                `)));
        y < h && (f += `
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `, y + 1 < h && (f += `
              wTexel = getW(r, ${y + 1}, d1, q);
              dotProd += xC${y + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
      }
      f += `
    }
  `, f += `
      }
    `;
      let p = "", g = "";
      r && (i ? p = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }` : a ? p = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }` : p = `vec4 activation(vec4 x) {
          ${r}
        }`, g = "result = activation(result);");
      const m = t ? "result += getBiasAtOutCoords();" : "";
      t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), a && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `;
    }
  }
  function Z8e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l, dimRoundingMode: u } = r;
    let c = l;
    c == null && (c = [
      1,
      1
    ]), B(Pr(s, c), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);
    const h = Sn(i.shape, a.shape, s, c, o, u, true);
    let d;
    ne().getBool("WEBGL_PACK_DEPTHWISECONV") && h.strideWidth <= 2 && h.outChannels / h.inChannels === 1 ? d = new Cte(h) : d = new Ste(h);
    const f = [
      [
        h.padInfo.top,
        h.padInfo.left
      ],
      [
        h.strideHeight,
        h.strideWidth
      ],
      [
        h.dilationHeight,
        h.dilationWidth
      ],
      [
        h.inHeight,
        h.inWidth
      ]
    ];
    return t.runWebGLProgram(d, [
      i,
      a
    ], "float32", f);
  }
  const Q8e = {
    kernelName: sf,
    backendName: "webgl",
    kernelFunc: Z8e
  };
  let J8e = class {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.outputShape = e.filterShape;
      const t = e.strideHeight, r = e.strideWidth, i = e.padInfo.top, a = e.padInfo.left, s = e.outChannels / e.inChannels;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }, eXe = class {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.outputShape = e.inShape;
      const t = e.filterHeight, r = e.filterWidth, i = e.strideHeight, a = e.strideWidth, s = t - 1 - e.padInfo.top, o = r - 1 - e.padInfo.left, l = e.outChannels / e.inChannels;
      this.userCode = `
      const ivec2 pads = ivec2(${s}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function tXe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, dilations: o, pad: l, dimRoundingMode: u, filterShape: c } = r, h = Sn(i.shape, c, s, o, l, u, true), d = new J8e(h);
    return t.runWebGLProgram(d, [
      i,
      a
    ], "float32");
  }
  const nXe = {
    kernelName: rI,
    backendName: "webgl",
    kernelFunc: tXe
  };
  function rXe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { strides: s, dilations: o, pad: l, dimRoundingMode: u, inputShape: c } = r, h = Sn(c, a.shape, s, o, l, u, true), d = new eXe(h);
    return t.runWebGLProgram(d, [
      i,
      a
    ], "float32");
  }
  const iXe = {
    kernelName: iI,
    backendName: "webgl",
    kernelFunc: rXe
  };
  let aXe = class {
    constructor(e) {
      this.variableNames = [
        "X"
      ], this.outputShape = [
        e,
        e
      ], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
  };
  function sXe(n) {
    const { inputs: e, backend: t } = n, { x: r } = e, i = [
      ...r.shape,
      ...r.shape
    ], a = X(r.shape), s = Me({
      inputs: {
        x: r
      },
      backend: t,
      attrs: {
        shape: [
          a
        ]
      }
    }), o = new aXe(a), l = t.runWebGLProgram(o, [
      s
    ], s.dtype), u = Me({
      inputs: {
        x: l
      },
      backend: t,
      attrs: {
        shape: i
      }
    });
    return t.disposeIntermediateTensorInfo(s), t.disposeIntermediateTensorInfo(l), u;
  }
  const oXe = {
    kernelName: aI,
    backendName: "webgl",
    kernelFunc: sXe
  };
  let lXe = class {
    constructor(e) {
      this.variableNames = [
        "x",
        "W"
      ], this.outputShape = e.outShape;
      const { inHeight: t, inWidth: r, padInfo: i, strideHeight: a, strideWidth: s, filterHeight: o, filterWidth: l, dilationHeight: u, dilationWidth: c } = e, { top: h, left: d } = i;
      this.userCode = `
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
  };
  function uXe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l } = r, u = po(i.shape, a.shape, s, o, "NHWC", l);
    let c;
    const h = new lXe(u);
    c = t.runWebGLProgram(h, [
      i,
      a
    ], "float32");
    const d = Me({
      inputs: {
        x: c
      },
      backend: t,
      attrs: {
        shape: u.outShape
      }
    });
    return t.disposeIntermediateTensorInfo(c), d;
  }
  const cXe = {
    kernelName: of,
    backendName: "webgl",
    kernelFunc: uXe
  };
  function hXe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { equation: i } = r, a = e, { allDims: s, summedDims: o, idDims: l } = VI(i, a.length);
    GI(s.length, l, a);
    const { path: u, steps: c } = UI(o, l), h = c.length;
    let d = null, f = s.length;
    const p = [];
    for (let g = 0; g < h; ++g) {
      for (const m of c[g]) {
        const { permutationIndices: v, expandDims: y } = WI(f, l[m]);
        let x;
        HI(v) ? x = a[m] : (x = Li({
          inputs: {
            x: a[m]
          },
          backend: t,
          attrs: {
            perm: v
          }
        }), p.push(x));
        const b = x.shape.slice();
        for (let w = 0; w < y.length; ++w) b.splice(y[w], 0, 1);
        Jt(x.shape, b) || (x = Me({
          inputs: {
            x
          },
          backend: t,
          attrs: {
            shape: b
          }
        }), p.push(x)), d === null ? d = x : (d = NL({
          inputs: {
            a: x,
            b: d
          },
          backend: t
        }), p.push(d));
      }
      g < h - 1 && (u[g] >= 0 && (d = o2({
        inputs: {
          x: d
        },
        backend: t,
        attrs: {
          axis: u[g] - (s.length - f),
          keepDims: false
        }
      }), p.push(d)), f--);
    }
    for (const g of p) g !== d && t.disposeIntermediateTensorInfo(g);
    return d;
  }
  const dXe = {
    kernelName: sI,
    backendName: "webgl",
    kernelFunc: hXe
  };
  const fXe = "return (x >= 0.0) ? x : (exp(x) - 1.0);", pXe = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, gXe = cn({
    opSnippet: fXe,
    packedOpSnippet: pXe
  }), mXe = {
    kernelName: uf,
    backendName: "webgl",
    kernelFunc: gXe
  };
  const vXe = "return (b >= 0.0) ? a : a * (b + 1.0);", yXe = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`, xXe = (n) => {
    const { inputs: e, backend: t } = n, { dy: r, y: i } = e, a = ne().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Pv(yXe, r.shape, i.shape) : new Rd(vXe, r.shape, i.shape);
    return t.runWebGLProgram(a, [
      r,
      i
    ], r.dtype);
  }, bXe = {
    kernelName: Um,
    backendName: "webgl",
    kernelFunc: xXe
  };
  const wXe = `
  return vec4(equal(a, b));
`, _Xe = "return float(a == b);", SXe = li({
    opSnippet: _Xe,
    packedOpSnippet: wXe,
    dtype: "bool",
    cpuKernelImpl: tHe
  }), CXe = {
    kernelName: Hm,
    backendName: "webgl",
    kernelFunc: SXe
  };
  const IXe = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${PI};
  float a1 = ${LI};
  float a2 = ${FI};
  float a3 = ${OI};
  float a4 = ${BI};
  float a5 = ${zI};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`, kXe = cn({
    opSnippet: IXe
  }), TXe = {
    kernelName: cf,
    backendName: "webgl",
    kernelFunc: kXe
  };
  const AXe = Lv + `
  return exp(x);
`, DXe = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, Ite = cn({
    opSnippet: AXe,
    packedOpSnippet: DXe,
    cpuKernelImpl: nHe,
    dtype: "float32"
  }), RXe = {
    kernelName: hf,
    backendName: "webgl",
    kernelFunc: Ite
  };
  function B$(n) {
    const { inputs: e, attrs: t, backend: r } = n, { dim: i } = t, { input: a } = e, s = a.shape.length, o = a.shape.slice();
    let l = i;
    return i < 0 && (B(-(s + 1) <= i, () => `Axis must be in the interval [${-(s + 1)}, ${s}]`), l = s + i + 1), o.splice(l, 0, 1), Me({
      inputs: {
        x: a
      },
      backend: r,
      attrs: {
        shape: o
      }
    });
  }
  const $Xe = {
    kernelName: Xm,
    backendName: "webgl",
    kernelFunc: B$
  };
  const BU = "return exp(x) - 1.0;", NXe = cn({
    opSnippet: BU,
    packedOpSnippet: BU,
    cpuKernelImpl: rHe
  }), EXe = {
    kernelName: df,
    backendName: "webgl",
    kernelFunc: NXe
  };
  let zU = class {
    constructor(e, t, r) {
      this.variableNames = [
        "real",
        "imag"
      ];
      const i = t[1];
      this.outputShape = t;
      const a = r ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`, s = r ? `${i}.0` : "1.0";
      let o;
      if (e === "real") o = "return real * expR - imag * expI;";
      else if (e === "imag") o = "return real * expI + imag * expR;";
      else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);
      this.userCode = `
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
  };
  function kte(n, e, t) {
    const r = t.texData.get(n.dataId), i = X(n.shape), a = n.shape[n.shape.length - 1], s = i / a, o = Me({
      inputs: {
        x: n
      },
      backend: t,
      attrs: {
        shape: [
          s,
          a
        ]
      }
    }), l = o.shape, u = new zU("real", l, e), c = new zU("imag", l, e), h = [
      {
        dataId: r.complexTensorInfos.real.dataId,
        dtype: r.complexTensorInfos.real.dtype,
        shape: l
      },
      {
        dataId: r.complexTensorInfos.imag.dataId,
        dtype: r.complexTensorInfos.imag.dtype,
        shape: l
      }
    ], d = t.runWebGLProgram(u, h, "float32"), f = t.runWebGLProgram(c, h, "float32"), p = Dc({
      inputs: {
        real: d,
        imag: f
      },
      backend: t
    });
    t.disposeIntermediateTensorInfo(d), t.disposeIntermediateTensorInfo(f);
    const g = Me({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        shape: n.shape
      }
    });
    return t.disposeIntermediateTensorInfo(o), t.disposeIntermediateTensorInfo(p), g;
  }
  function MXe(n) {
    const { inputs: e, backend: t } = n, { input: r } = e;
    return kte(r, false, t);
  }
  const PXe = {
    kernelName: oI,
    backendName: "webgl",
    kernelFunc: MXe
  };
  let LXe = class {
    constructor(e, t) {
      this.outputShape = [], this.customUniforms = [
        {
          name: "value",
          type: "float"
        }
      ], this.variableNames = [
        "x"
      ], this.outputShape = e, this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
  };
  function Xb(n) {
    const { backend: e, attrs: t } = n, { shape: r, value: i } = t;
    let { dtype: a } = t;
    if (a = a || yc(i), a === "string") {
      const s = ir(a, X(r));
      return s.fill(i), e.makeTensorInfo(r, a, s);
    } else {
      const s = new LXe(r, i), o = [
        [
          i
        ]
      ];
      return e.runWebGLProgram(s, [], a, o);
    }
  }
  const FXe = {
    kernelName: rb,
    backendName: "webgl",
    kernelFunc: Xb
  };
  let OXe = class {
    constructor(e) {
      this.variableNames = [
        "Image"
      ], this.outputShape = [];
      const t = e[2];
      this.outputShape = e, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };
  const BXe = {
    kernelName: Ym,
    backendName: "webgl",
    kernelFunc: ({ inputs: n, backend: e }) => {
      const { image: t } = n, r = e, i = new OXe(t.shape);
      return r.runWebGLProgram(i, [
        t
      ], t.dtype);
    }
  };
  const VU = "return floor(x);", zXe = cn({
    opSnippet: VU,
    packedOpSnippet: VU,
    cpuKernelImpl: iHe
  }), VXe = {
    kernelName: ff,
    backendName: "webgl",
    kernelFunc: zXe
  };
  const WXe = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`, GXe = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`, UXe = li({
    opSnippet: WXe,
    packedOpSnippet: GXe,
    dtype: "int32"
  }), HXe = {
    kernelName: pf,
    backendName: "webgl",
    kernelFunc: UXe
  };
  let XXe = class {
    constructor(e) {
      this.variableNames = [
        "A"
      ];
      const t = Bi(), [r, i] = e;
      this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
  };
  class YXe {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.packedInputs = false, this.packedOutput = true;
      const t = Bi(), [r, i] = e;
      this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `;
    }
  }
  const qXe = {
    kernelName: K7,
    backendName: "webgl",
    kernelFunc: jXe
  };
  let jp, bA = ne().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function jXe(n) {
    const { inputs: e, backend: t, attrs: r } = n;
    let { pixels: i } = e;
    const { numChannels: a } = r, s = typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement, o = typeof HTMLImageElement < "u" && i instanceof HTMLImageElement, [l, u] = s ? [
      i.videoWidth,
      i.videoHeight
    ] : [
      i.width,
      i.height
    ], c = [
      u,
      l
    ], h = [
      u,
      l,
      a
    ];
    if (o || s) {
      const g = ne().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
      (jp == null || g !== bA) && (bA = g, jp = document.createElement("canvas").getContext("2d", {
        willReadFrequently: bA
      })), jp.canvas.width = l, jp.canvas.height = u, jp.drawImage(i, 0, 0, l, u), i = jp.canvas;
    }
    const d = t.makeTensorInfo(c, "int32");
    t.texData.get(d.dataId).usage = Ba.PIXELS, t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId), i);
    const f = ne().getBool("WEBGL_PACK") ? new YXe(h) : new XXe(h), p = t.runWebGLProgram(f, [
      d
    ], "int32");
    return t.disposeData(d.dataId), p;
  }
  function KXe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = e, { strides: l, pad: u, dataFormat: c, dilations: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = r, g = Oi(c), m = Sn(i.shape, a.shape, l, h, u, d, false, g);
    let v;
    const y = [], x = s != null, b = o != null, w = f === "leakyrelu", _ = () => {
      const I = [
        i,
        a
      ], C = (T, k) => {
        if (k === "NCHW" && T.shape.length === 1 && T.shape[0] !== 1) {
          const D = Me({
            inputs: {
              x: T
            },
            backend: t,
            attrs: {
              shape: [
                T.shape[0],
                1,
                1
              ]
            }
          });
          return y.push(D), D;
        }
        return T;
      };
      if (x && I.push(C(s, c)), b && I.push(C(o, c)), w) {
        const T = t.makeTensorInfo([], "float32", Sc(p, "float32"));
        I.push(T), y.push(T);
      }
      return I;
    };
    if (m.filterHeight === 1 && m.filterWidth === 1 && m.dilationHeight === 1 && m.dilationWidth === 1 && m.strideHeight === 1 && m.strideWidth === 1 && (m.padInfo.type === "SAME" || m.padInfo.type === "VALID")) v = bte({
      x: i,
      filter: a,
      convInfo: m,
      backend: t,
      bias: s,
      activation: f,
      preluActivationWeights: o,
      leakyreluAlpha: p
    });
    else if (m.strideWidth <= 2 && g === "channelsLast" && ne().getBool("WEBGL_EXP_CONV")) {
      const I = f ? px(f, true) : null, C = new xte(m, x, I, b, w), T = [
        [
          m.padInfo.top,
          m.padInfo.left
        ],
        [
          m.strideHeight,
          m.strideWidth
        ],
        [
          m.dilationHeight,
          m.dilationWidth
        ],
        [
          m.inHeight,
          m.inWidth
        ]
      ], k = _();
      v = t.runWebGLProgram(C, k, "float32", T);
    } else if (ne().getBool("WEBGL_CONV_IM2COL")) v = wte({
      x: i,
      filter: a,
      convInfo: m,
      backend: t,
      bias: s,
      activation: f,
      preluActivationWeights: o,
      leakyreluAlpha: p
    });
    else {
      const I = f ? px(f, false) : null, C = new yte(m, x, I, b, w), T = _();
      v = t.runWebGLProgram(C, T, "float32");
    }
    const S = Me({
      inputs: {
        x: v
      },
      backend: t,
      attrs: {
        shape: m.outShape
      }
    });
    return y.push(v), y.forEach((I) => t.disposeIntermediateTensorInfo(I)), S;
  }
  const ZXe = {
    kernelName: yd,
    backendName: "webgl",
    kernelFunc: KXe
  };
  function QXe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = e, { strides: l, pad: u, dilations: c, dimRoundingMode: h, activation: d, leakyreluAlpha: f } = r, p = [];
    let g = c;
    g == null && (g = [
      1,
      1
    ]), B(Pr(l, g), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);
    const m = Sn(i.shape, a.shape, l, g, u, h, true), v = ne().getBool("WEBGL_PACK_DEPTHWISECONV") && m.strideWidth <= 2 && m.outChannels / m.inChannels === 1, y = d ? px(d, v) : null, x = [
      i,
      a
    ], b = s != null, w = o != null, _ = d === "leakyrelu";
    if (b && x.push(s), w && x.push(o), _) {
      const T = t.makeTensorInfo([], "float32", Sc(f, "float32"));
      x.push(T), p.push(T);
    }
    let S;
    v ? S = new Cte(m, b, y, w, _) : S = new Ste(m, b, y, w, _);
    const I = [
      [
        m.padInfo.top,
        m.padInfo.left
      ],
      [
        m.strideHeight,
        m.strideWidth
      ],
      [
        m.dilationHeight,
        m.dilationWidth
      ],
      [
        m.inHeight,
        m.inWidth
      ]
    ], C = t.runWebGLProgram(S, x, "float32", I);
    return p.forEach((T) => t.disposeIntermediateTensorInfo(T)), C;
  }
  const JXe = {
    kernelName: vb,
    backendName: "webgl",
    kernelFunc: QXe
  };
  let eYe = class {
    constructor(e, t, r, i) {
      this.sliceDim = e, this.strides = t, this.paramsShape = i, this.variableNames = [
        "x",
        "indices"
      ], this.outputShape = r;
      const a = Pn(r.length);
      let s = `
    int index;`;
      for (let o = 0; o < this.sliceDim; o++) s += `
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;
      this.userCode = `
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
    }
  };
  function tYe(n) {
    const { inputs: e, backend: t } = n, { params: r, indices: i } = e, a = i.shape, s = a[a.length - 1], o = X(r.shape), [l, u, c, h] = _b(r, i), d = Me({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u,
          s
        ]
      }
    }), f = Me({
      inputs: {
        x: r
      },
      backend: t,
      attrs: {
        shape: [
          X(r.shape) / c,
          c
        ]
      }
    });
    if (t.shouldExecuteOnCPU([
      r,
      i
    ]) || r.dtype === "string") {
      const v = t.readSync(i.dataId), y = t.bufferSync(r), x = aHe(v, y, r.dtype, u, s, c, h, r.shape, o);
      return t.makeTensorInfo(l, r.dtype, x.values);
    }
    const p = new eYe(s, h, [
      u,
      c
    ], r.shape), g = t.runWebGLProgram(p, [
      f,
      d
    ], f.dtype), m = Me({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        shape: l
      }
    });
    return t.disposeIntermediateTensorInfo(d), t.disposeIntermediateTensorInfo(f), t.disposeIntermediateTensorInfo(g), m;
  }
  const nYe = {
    kernelName: ib,
    backendName: "webgl",
    kernelFunc: tYe
  };
  let rYe = class {
    constructor(e, t) {
      this.variableNames = [
        "A",
        "indices"
      ], this.outputShape = t, this.rank = t.length;
      const r = Pn(this.rank), i = iYe(e);
      this.userCode = `
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `;
    }
  };
  function iYe(n, e) {
    const t = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w"
    ], r = [];
    for (let i = 0; i < n.length; i++) i === 2 ? r.push("index") : r.push(`${t[i]}`);
    return r.join();
  }
  function Tte(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, indices: a } = e, { axis: s, batchDims: o } = r, l = yt(s, i.shape)[0];
    if (ne().get("DEBUG")) {
      const y = t.readSync(a.dataId), x = i.shape[l];
      for (let b = 0; b < y.length; ++b) {
        const w = y[b];
        B(w <= x - 1 && w >= 0, () => `GatherV2: the index value ${w} is not in [0, ${x - 1}]`);
      }
    }
    const u = Nb(i, a, l, o), c = X(a.shape), h = [], d = Me({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u.batchSize,
          u.outerSize,
          u.dimSize,
          u.sliceSize
        ]
      }
    }), f = Me({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          u.batchSize,
          c / u.batchSize
        ]
      }
    });
    h.push(d), h.push(f);
    const p = [
      u.batchSize,
      u.outerSize,
      c / u.batchSize,
      u.sliceSize
    ];
    if (t.shouldExecuteOnCPU([
      i,
      a
    ]) || i.dtype === "string") {
      const y = t.bufferSync(f), x = t.bufferSync(d), b = sHe(x, y, p);
      return h.forEach((w) => t.disposeIntermediateTensorInfo(w)), t.makeTensorInfo(u.outputShape, b.dtype, b.values);
    }
    const g = new rYe(d.shape, p), m = t.runWebGLProgram(g, [
      d,
      f
    ], d.dtype);
    h.push(m);
    const v = Me({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        shape: u.outputShape
      }
    });
    return h.forEach((y) => t.disposeIntermediateTensorInfo(y)), v;
  }
  const aYe = {
    kernelName: qm,
    backendName: "webgl",
    kernelFunc: Tte
  };
  const sYe = "return float(a > b);", oYe = `
  return vec4(greaterThan(a, b));
`, lYe = li({
    opSnippet: sYe,
    packedOpSnippet: oYe,
    cpuKernelImpl: oHe,
    dtype: "bool"
  }), uYe = {
    kernelName: jm,
    backendName: "webgl",
    kernelFunc: lYe
  };
  const cYe = "return float(a >= b);", hYe = `
  return vec4(greaterThanEqual(a, b));
`, dYe = li({
    opSnippet: cYe,
    packedOpSnippet: hYe,
    dtype: "bool",
    cpuKernelImpl: lHe
  }), fYe = {
    kernelName: mf,
    backendName: "webgl",
    kernelFunc: dYe
  };
  function pYe(n) {
    const { inputs: e, backend: t } = n, { input: r } = e;
    return kte(r, true, t);
  }
  const gYe = {
    kernelName: lI,
    backendName: "webgl",
    kernelFunc: pYe
  };
  const mYe = "return float(!isnan(x) && !isinf(x));", vYe = cn({
    opSnippet: mYe,
    dtype: "bool"
  }), yYe = {
    kernelName: yf,
    backendName: "webgl",
    kernelFunc: vYe
  };
  const xYe = "return float(isinf(x));", bYe = cn({
    opSnippet: xYe,
    dtype: "bool"
  }), wYe = {
    kernelName: xf,
    backendName: "webgl",
    kernelFunc: bYe
  };
  const _Ye = "return float(isnan(x));", SYe = cn({
    opSnippet: _Ye,
    dtype: "bool"
  }), CYe = {
    kernelName: bf,
    backendName: "webgl",
    kernelFunc: SYe
  };
  const IYe = "return float(a < b);", kYe = `
  return vec4(lessThan(a, b));
`, TYe = li({
    opSnippet: IYe,
    packedOpSnippet: kYe,
    cpuKernelImpl: uHe,
    dtype: "bool"
  }), AYe = {
    kernelName: Km,
    backendName: "webgl",
    kernelFunc: TYe
  };
  const DYe = "return float(a <= b);", RYe = `
  return vec4(lessThanEqual(a, b));
`, $Ye = li({
    opSnippet: DYe,
    packedOpSnippet: RYe,
    cpuKernelImpl: cHe,
    dtype: "bool"
  }), NYe = {
    kernelName: Zm,
    backendName: "webgl",
    kernelFunc: $Ye
  };
  function EYe(n) {
    const { backend: e, attrs: t } = n, { start: r, stop: i, num: a } = t, s = hHe(r, i, a);
    return e.makeTensorInfo([
      s.length
    ], "float32", s);
  }
  const MYe = {
    kernelName: ab,
    backendName: "webgl",
    kernelFunc: EYe
  };
  const PYe = Lv + `
  return x < 0.0 ? 0./0. : log(x);
`, LYe = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`, FYe = cn({
    opSnippet: PYe,
    packedOpSnippet: LYe,
    cpuKernelImpl: dHe
  }), OYe = {
    kernelName: _f,
    backendName: "webgl",
    kernelFunc: FYe
  };
  const BYe = Lv + `
  return log(1.0 + x);
`, zYe = cn({
    opSnippet: BYe
  }), VYe = {
    kernelName: Sf,
    backendName: "webgl",
    kernelFunc: zYe
  };
  const WYe = "return float(a >= 1.0 && b >= 1.0);", GYe = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`, UYe = li({
    opSnippet: WYe,
    packedOpSnippet: GYe,
    dtype: "bool"
  }), HYe = {
    kernelName: Qm,
    backendName: "webgl",
    kernelFunc: UYe
  };
  const XYe = "return float(!(x >= 1.0));", YYe = cn({
    opSnippet: XYe
  }), qYe = {
    kernelName: Jm,
    backendName: "webgl",
    kernelFunc: YYe
  };
  const jYe = "return float(a >= 1.0 || b >= 1.0);", KYe = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`, ZYe = li({
    opSnippet: jYe,
    packedOpSnippet: KYe,
    dtype: "bool"
  }), QYe = {
    kernelName: ev,
    backendName: "webgl",
    kernelFunc: ZYe
  };
  let JYe = class {
    constructor(e, t, r, i, a) {
      this.variableNames = [
        "x"
      ], this.outputShape = [];
      const s = t, o = e[3] - 1;
      this.outputShape = e;
      let l;
      const u = `float(${r}) + float(${i}) * sum`;
      a === 0.5 ? l = `inversesqrt(${u})` : a === 1 ? l = `1.0/(${u})` : l = `exp(log(${u}) * float(-${a}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `;
    }
  };
  class eqe {
    constructor(e, t, r, i, a) {
      this.variableNames = [
        "x"
      ], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
      const s = t, o = e[3] - 1;
      this.outputShape = e;
      let l;
      const u = `float(${r}) + float(${i}) * sum`;
      a === 0.5 ? l = `inversesqrt(${u})` : a === 1 ? l = `1.0/(${u})` : l = `exp(log(${u}) * float(-${a}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `;
    }
  }
  const tqe = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { depthRadius: a, bias: s, alpha: o, beta: l } = r, u = ne().getBool("WEBGL_PACK_NORMALIZATION") ? new eqe(i.shape, a, s, o, l) : new JYe(i.shape, a, s, o, l);
    return t.runWebGLProgram(u, [
      i
    ], i.dtype);
  }, nqe = {
    kernelName: Cf,
    backendName: "webgl",
    kernelFunc: tqe
  };
  let rqe = class {
    constructor(e, t, r, i, a) {
      this.variableNames = [
        "inputImage",
        "outputImage",
        "dy"
      ], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = r, this.alpha = i, this.beta = a, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
  };
  const iqe = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, y: a, dy: s } = e, { depthRadius: o, bias: l, alpha: u, beta: c } = r, h = new rqe(i.shape, o, l, u, c);
    return t.runWebGLProgram(h, [
      i,
      a,
      s
    ], i.dtype);
  }, aqe = {
    kernelName: tv,
    backendName: "webgl",
    kernelFunc: iqe
  };
  function sqe(n, e, t, r) {
    const i = X(e), s = X(n.shape) / i, o = Me({
      inputs: {
        x: n
      },
      attrs: {
        shape: [
          s,
          i
        ]
      },
      backend: r
    }), l = pp(o, n.dtype, "max", r), u = Me({
      inputs: {
        x: l
      },
      attrs: {
        shape: t
      },
      backend: r
    });
    return r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(l), u;
  }
  function Ate(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { reductionIndices: a, keepDims: s } = r, o = i.shape.length, l = yt(a, i.shape);
    let u = l;
    const c = bn(u, o), h = c != null, d = t.shouldExecuteOnCPU([
      i
    ]);
    let f = i;
    if (h) {
      if (d) {
        const x = t.texData.get(f.dataId).values, b = new Array(o);
        for (let S = 0; S < b.length; S++) b[S] = i.shape[c[S]];
        const w = RL(x, i.shape, i.dtype, c, b);
        f = t.makeTensorInfo(b, i.dtype);
        const _ = t.texData.get(f.dataId);
        _.values = w;
      } else f = s2(i, c, t);
      u = gn(u.length, o);
    }
    Tn("max", u, o);
    const [p, g] = Ln(f.shape, u);
    let m = p;
    s && (m = Mn(p, l));
    let v;
    if (d) {
      const x = t.texData.get(f.dataId).values, b = fHe(x, X(g), m, i.dtype);
      v = t.makeTensorInfo(m, i.dtype);
      const w = t.texData.get(v.dataId);
      w.values = b;
    } else v = sqe(f, g, m, t);
    return h && t.disposeIntermediateTensorInfo(f), v;
  }
  const oqe = {
    kernelName: If,
    backendName: "webgl",
    kernelFunc: Ate
  };
  const lqe = $L + `
  return max(a, b);
`, uqe = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + fp + `
  return result;
`, cqe = li({
    opSnippet: lqe,
    packedOpSnippet: uqe,
    cpuKernelImpl: pHe
  }), hqe = {
    kernelName: kf,
    backendName: "webgl",
    kernelFunc: cqe
  };
  function dqe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e;
    Gb(i, "maxPool");
    const { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, u = 1;
    B(Pr(s, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = dr(i.shape, a, s, u, o, l);
    if (c.filterWidth === 1 && c.filterHeight === 1 && Jt(c.inShape, c.outShape)) return Ta({
      inputs: {
        x: i
      },
      backend: t
    });
    const h = new gx(c, "max", false);
    return t.runWebGLProgram(h, [
      i
    ], i.dtype);
  }
  const fqe = {
    kernelName: Tf,
    backendName: "webgl",
    kernelFunc: dqe
  };
  function pqe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dataFormat: l, dimRoundingMode: u } = r, c = [
      1,
      1,
      1
    ], h = vi(i.shape, a, s, c, o, u, l), d = new EL(h, "max", false);
    return t.runWebGLProgram(d, [
      i
    ], i.dtype);
  }
  const gqe = {
    kernelName: nv,
    backendName: "webgl",
    kernelFunc: pqe
  };
  let mqe = class {
    constructor(e) {
      this.variableNames = [
        "dy",
        "maxPos"
      ], this.outputShape = e.inShape;
      const t = e.strideHeight, r = e.strideWidth, i = e.dilationHeight, a = e.effectiveFilterHeight, s = e.effectiveFilterWidth, o = a - 1 - e.padInfo.top, l = s - 1 - e.padInfo.left, u = a * s - 1;
      this.userCode = `
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  }, vqe = class {
    constructor(e) {
      this.variableNames = [
        "dy",
        "maxPos"
      ], this.outputShape = e.inShape;
      const t = e.strideDepth, r = e.strideHeight, i = e.strideWidth, a = e.dilationDepth, s = e.dilationHeight, o = e.dilationWidth, l = e.effectiveFilterDepth, u = e.effectiveFilterHeight, c = e.effectiveFilterWidth, h = l - 1 - e.padInfo.front, d = u - 1 - e.padInfo.top, f = c - 1 - e.padInfo.left, p = l * u * c - 1;
      this.userCode = `
      const ivec3 pads = ivec3(${h}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  function yqe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, s = a, { filterSize: o, strides: l, pad: u, dimRoundingMode: c } = r, h = [
      1,
      1,
      1
    ], d = vi(s.shape, o, l, h, u, c), f = new EL(d, "max", true), p = t.runWebGLProgram(f, [
      s
    ], s.dtype), g = new vqe(d), m = t.runWebGLProgram(g, [
      i,
      p
    ], s.dtype);
    return t.disposeIntermediateTensorInfo(p), m;
  }
  const xqe = {
    kernelName: ob,
    backendName: "webgl",
    kernelFunc: yqe
  };
  function bqe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a, output: s } = e, o = a;
    Gb([
      a,
      s
    ], "maxPoolGrad");
    const { filterSize: l, strides: u, pad: c, dimRoundingMode: h } = r, d = dr(o.shape, l, u, 1, c, h), f = true, p = new gx(d, "max", f), g = t.runWebGLProgram(p, [
      o
    ], o.dtype), m = new mqe(d), v = t.runWebGLProgram(m, [
      i,
      g
    ], o.dtype);
    return t.disposeIntermediateTensorInfo(g), v;
  }
  const wqe = {
    kernelName: sb,
    backendName: "webgl",
    kernelFunc: bqe
  };
  function _qe(n, e, t, r) {
    let i = new gx(t, "max", false);
    const a = r.runWebGLProgram(i, [
      n
    ], "float32");
    i = new gx(t, "max", true, true, e);
    const s = r.runWebGLProgram(i, [
      n
    ], "float32");
    return [
      a,
      s
    ];
  }
  const Sqe = {
    kernelName: cI,
    backendName: "webgl",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { x: r } = n, { filterSize: i, strides: a, pad: s, includeBatchInIndex: o } = e, l = t;
      B(r.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);
      const u = [
        1,
        1
      ];
      B(Pr(a, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
      const c = dr(r.shape, i, a, u, s), [h, d] = _qe(r, o, c, l);
      return [
        h,
        d
      ];
    }
  };
  function Cqe(n, e, t, r) {
    const i = X(e), s = X(n.shape) / i, o = Me({
      inputs: {
        x: n
      },
      attrs: {
        shape: [
          s,
          i
        ]
      },
      backend: r
    }), l = pp(o, "float32", "mean", r), u = Me({
      inputs: {
        x: l
      },
      attrs: {
        shape: t
      },
      backend: r
    });
    return r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(l), u;
  }
  const Iqe = {
    kernelName: Af,
    backendName: "webgl",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { x: r } = n, { keepDims: i, axis: a } = e, s = t, o = r.shape.length, l = yt(a, r.shape);
      let u = l;
      const c = bn(u, o), h = c != null, d = s.shouldExecuteOnCPU([
        r
      ]), f = [];
      let p = r;
      if (h) {
        if (d) {
          const b = s.texData.get(p.dataId).values, w = new Array(o);
          for (let I = 0; I < w.length; I++) w[I] = r.shape[c[I]];
          const _ = RL(b, r.shape, r.dtype, c, w);
          p = s.makeTensorInfo(w, r.dtype);
          const S = s.texData.get(p.dataId);
          S.values = _;
        } else p = s2(r, c, s);
        f.push(p), u = gn(u.length, o);
      }
      Tn("sum", u, o);
      const [g, m] = Ln(p.shape, u);
      let v = g;
      i && (v = Mn(g, l));
      const y = Cqe(p, m, v, s);
      for (const x of f) s.disposeIntermediateTensorInfo(x);
      return y;
    }
  };
  function kqe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r, o = i.shape.length, l = yt(a, i.shape);
    let u = l;
    const c = bn(u, o);
    let h = i;
    c != null && (h = Li({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: c
      }
    }), u = gn(u.length, i.shape.length)), Tn("min", u, o);
    const [d, f] = Ln(h.shape, u), p = X(f), g = Me({
      inputs: {
        x: h
      },
      backend: t,
      attrs: {
        shape: [
          -1,
          p
        ]
      }
    }), m = pp(g, g.dtype, "min", t);
    let v;
    if (s) {
      const y = Mn(d, l);
      v = Me({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: y
        }
      });
    } else v = Me({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    return t.disposeIntermediateTensorInfo(g), t.disposeIntermediateTensorInfo(m), c != null && t.disposeIntermediateTensorInfo(h), v;
  }
  const Tqe = {
    kernelName: Df,
    backendName: "webgl",
    kernelFunc: kqe
  };
  const Aqe = $L + `
  return min(a, b);
`, Dqe = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + fp + `
  return result;
`, Rqe = li({
    opSnippet: Aqe,
    packedOpSnippet: Dqe,
    cpuKernelImpl: gHe
  }), $qe = {
    kernelName: Rf,
    backendName: "webgl",
    kernelFunc: Rqe
  };
  let Nqe = class {
    constructor(e, t, r) {
      this.variableNames = [
        "x"
      ], this.outputShape = t.map((c, h) => c[0] + e[h] + c[1]);
      const i = e.length, a = Pn(i), s = t.map((c) => c[0]).join(","), o = t.map((c, h) => c[0] + e[h]).join(","), l = [
        "coords[0]",
        "coords[1]",
        "coords[2]",
        "coords[3]"
      ].slice(0, i), u = r === "reflect" ? 0 : 1;
      if (i === 1) {
        this.userCode = `
        int start = ${s};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;
        return;
      }
      this.userCode = `
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `;
    }
  };
  class Eqe {
    constructor(e, t, r) {
      this.variableNames = [
        "x"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = t.map((p, g) => p[0] + e[g] + p[1]);
      const i = e.length, a = Pn(i), s = t.map((p) => p[0]).join(","), o = t.map((p, g) => p[0] + e[g]).join(","), l = Di("rc", i), u = Di("source", i), c = `${l[i - 1]} < ${this.outputShape[i - 1]}`, h = i === 1 ? "source" : `vec2(${u.slice(-2).join()})`, d = r === "reflect" ? 0 : 1;
      let f = "";
      if (i === 1) {
        const p = `
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;
        f = `
        ${a} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[i - 1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `;
      } else {
        const p = `
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;
        f = `
        ${a} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[i - 1]} += 1;
        if(${c}) {
          ${p}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[i - 2]} += 1;
        if(${l[i - 2]} < ${this.outputShape[i - 2]}) {
          ${p}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[i - 1]} += 1;
          if(${c}) {
            ${p}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `;
      }
      this.userCode = `
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `;
    }
  }
  const Mqe = ({ inputs: n, backend: e, attrs: t }) => {
    const { x: r } = n, { paddings: i, mode: a } = t, s = ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Eqe(r.shape, i, a) : new Nqe(r.shape, i, a);
    return e.runWebGLProgram(s, [
      r
    ], r.dtype);
  }, Pqe = {
    kernelName: $f,
    backendName: "webgl",
    kernelFunc: Mqe
  };
  const Lqe = `if (b == 0.0) return NAN;
  return mod(a, b);`, Fqe = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + fp + `
  return result;
`, Oqe = li({
    opSnippet: Lqe,
    packedOpSnippet: Fqe
  }), Bqe = {
    kernelName: Nf,
    backendName: "webgl",
    kernelFunc: Oqe
  };
  let zqe = class {
    constructor(e, t, r) {
      this.variableNames = [
        "probs"
      ], this.customUniforms = [
        {
          name: "seed",
          type: "float"
        }
      ], this.outputShape = [
        e,
        r
      ], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t - 1}));
      }
    `;
    }
  };
  const Vqe = `
if (a == b) {
  return 1.0;
};
return a / b;`, Wqe = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`, Dte = li({
    opSnippet: Vqe,
    packedOpSnippet: Wqe,
    checkOutOfBounds: true
  }), Gqe = {
    kernelName: lf,
    backendName: "webgl",
    kernelFunc: Dte
  };
  const WU = "return a - b;", Rte = li({
    opSnippet: WU,
    packedOpSnippet: WU,
    supportsComplex: true,
    cpuKernelImpl: LHe
  }), Uqe = {
    kernelName: rp,
    backendName: "webgl",
    kernelFunc: Rte
  };
  function $te(n) {
    const { inputs: e, backend: t, attrs: r } = n, { logits: i } = e, { dim: a } = r, s = yt([
      a
    ], i.shape), o = Ate({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        reductionIndices: s,
        keepDims: false
      }
    }), l = Mn(o.shape, s), u = Me({
      inputs: {
        x: o
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), c = Rte({
      inputs: {
        a: i,
        b: u
      },
      backend: t
    }), h = Ite({
      inputs: {
        x: c
      },
      backend: t
    }), d = o2({
      inputs: {
        x: h
      },
      backend: t,
      attrs: {
        axis: s,
        keepDims: false
      }
    }), f = Me({
      inputs: {
        x: d
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), p = Dte({
      inputs: {
        a: h,
        b: f
      },
      backend: t
    });
    return t.disposeIntermediateTensorInfo(o), t.disposeIntermediateTensorInfo(u), t.disposeIntermediateTensorInfo(c), t.disposeIntermediateTensorInfo(h), t.disposeIntermediateTensorInfo(d), t.disposeIntermediateTensorInfo(f), p;
  }
  const Hqe = {
    kernelName: tp,
    backendName: "webgl",
    kernelFunc: $te
  };
  function Xqe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { logits: i } = e, { numSamples: a, seed: s, normalized: o } = r, l = o ? i : $te({
      inputs: {
        logits: i
      },
      backend: t,
      attrs: {
        dim: i.shape.length - 1
      }
    }), u = l.shape[0], c = l.shape[1], h = new zqe(u, c, a), d = [
      [
        s
      ]
    ], f = t.runWebGLProgram(h, [
      l
    ], "int32", d);
    return o || t.disposeIntermediateTensorInfo(l), f;
  }
  const Yqe = {
    kernelName: lb,
    backendName: "webgl",
    kernelFunc: Xqe
  };
  const qqe = Rs + `
  return -x;
`, jqe = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  function Kqe(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (t.shouldExecuteOnCPU([
      r
    ])) {
      const a = t.texData.get(r.dataId), [s, o] = vHe(a.values, r.shape, r.dtype);
      return t.makeTensorInfo(o, r.dtype, s);
    }
    let i;
    return ne().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? i = new Gu(r.shape, jqe) : i = new Wo(r.shape, qqe), t.runWebGLProgram(i, [
      r
    ], r.dtype);
  }
  const Zqe = {
    kernelName: rv,
    backendName: "webgl",
    kernelFunc: Kqe
  };
  const Qqe = DI;
  function Jqe(n) {
    Fa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: e, backend: t, attrs: r } = n, { boxes: i, scores: a } = e, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l } = r, u = t.readSync(i.dataId), c = t.readSync(a.dataId), { selectedIndices: h } = Qqe(u, c, s, o, l);
    return t.makeTensorInfo([
      h.length
    ], "int32", new Int32Array(h));
  }
  const eje = {
    kernelName: av,
    backendName: "webgl",
    kernelFunc: Jqe
  };
  const tje = IP;
  function nje(n) {
    Fa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: e, backend: t, attrs: r } = n, { boxes: i, scores: a } = e, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, padToMaxOutputSize: u } = r, c = t.readSync(i.dataId), h = t.readSync(a.dataId), { selectedIndices: d, validOutputs: f } = tje(c, h, s, o, l, u);
    return [
      t.makeTensorInfo([
        d.length
      ], "int32", new Int32Array(d)),
      t.makeTensorInfo([], "int32", new Int32Array([
        f
      ]))
    ];
  }
  const rje = {
    kernelName: ub,
    backendName: "webgl",
    kernelFunc: nje
  };
  const ije = RI;
  function aje(n) {
    Fa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: e, backend: t, attrs: r } = n, { boxes: i, scores: a } = e, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, softNmsSigma: u } = r, c = t.readSync(i.dataId), h = t.readSync(a.dataId), d = s, f = o, p = l, g = u, { selectedIndices: m, selectedScores: v } = ije(c, h, d, f, p, g);
    return [
      t.makeTensorInfo([
        m.length
      ], "int32", new Int32Array(m)),
      t.makeTensorInfo([
        v.length
      ], "float32", new Float32Array(v))
    ];
  }
  const sje = {
    kernelName: sv,
    backendName: "webgl",
    kernelFunc: aje
  };
  let oje = class {
    constructor(e, t, r, i) {
      this.variableNames = [
        "indices"
      ], this.outputShape = [
        e,
        t
      ], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${r}),
                      float(index == coords.y)));
      }
    `;
    }
  };
  const lje = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { indices: i } = e, { dtype: a, depth: s, onValue: o, offValue: l } = r, u = X(i.shape), c = new oje(u, s, o, l), h = Me({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u
        ]
      }
    }), d = t.runWebGLProgram(c, [
      h
    ], a);
    t.disposeIntermediateTensorInfo(h);
    const f = [
      ...i.shape,
      s
    ], p = Me({
      inputs: {
        x: d
      },
      backend: t,
      attrs: {
        shape: f
      }
    });
    return t.disposeIntermediateTensorInfo(d), p;
  }, uje = {
    kernelName: Mf,
    backendName: "webgl",
    kernelFunc: lje
  };
  function JS(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (r.dtype === "complex64") {
      const i = Hb({
        inputs: {
          input: r
        },
        backend: t
      }), a = JS({
        inputs: {
          x: i
        },
        backend: t
      }), s = l2({
        inputs: {
          input: r
        },
        backend: t
      }), o = JS({
        inputs: {
          x: s
        },
        backend: t
      }), l = Dc({
        inputs: {
          real: a,
          imag: o
        },
        backend: t
      });
      return t.disposeIntermediateTensorInfo(i), t.disposeIntermediateTensorInfo(a), t.disposeIntermediateTensorInfo(s), t.disposeIntermediateTensorInfo(o), l;
    } else return Xb({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: r.dtype === "string" ? "" : 0
      },
      backend: t
    });
  }
  const cje = {
    kernelName: bv,
    backendName: "webgl",
    kernelFunc: JS
  };
  function Nte(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (r.dtype === "string") throw new Error("onesLike is not supported under string dtype");
    if (r.dtype === "complex64") {
      const i = Hb({
        inputs: {
          input: r
        },
        backend: t
      }), a = Nte({
        inputs: {
          x: i
        },
        backend: t
      }), s = l2({
        inputs: {
          input: r
        },
        backend: t
      }), o = JS({
        inputs: {
          x: s
        },
        backend: t
      }), l = Dc({
        inputs: {
          real: a,
          imag: o
        },
        backend: t
      });
      return t.disposeIntermediateTensorInfo(i), t.disposeIntermediateTensorInfo(a), t.disposeIntermediateTensorInfo(s), t.disposeIntermediateTensorInfo(o), l;
    } else return Xb({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: 1
      },
      backend: t
    });
  }
  const hje = {
    kernelName: ov,
    backendName: "webgl",
    kernelFunc: Nte
  };
  function dje(n) {
    const { inputs: e, backend: t, attrs: r } = n, { axis: i } = r;
    if (e.length === 1) return B$({
      inputs: {
        input: e[0]
      },
      backend: t,
      attrs: {
        dim: i
      }
    });
    const a = e[0].shape, s = e[0].dtype;
    e.forEach((c) => {
      Qx(a, c.shape, "All tensors passed to stack must have matching shapes"), B(s === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const o = [], l = e.map((c) => {
      const h = B$({
        inputs: {
          input: c
        },
        backend: t,
        attrs: {
          dim: i
        }
      });
      return o.push(h), h;
    }), u = vte({
      inputs: l,
      backend: t,
      attrs: {
        axis: i
      }
    });
    return o.forEach((c) => t.disposeIntermediateTensorInfo(c)), u;
  }
  const fje = {
    kernelName: lv,
    backendName: "webgl",
    kernelFunc: dje
  };
  let pje = class {
    constructor(e, t, r) {
      this.variableNames = [
        "x"
      ], this.customUniforms = [
        {
          name: "value",
          type: "float"
        }
      ], this.outputShape = t.map((u, c) => u[0] + e[c] + u[1]);
      const i = e.length, a = Pn(i), s = t.map((u) => u[0]).join(","), o = t.map((u, c) => u[0] + e[c]).join(","), l = [
        "coords[0]",
        "coords[1]",
        "coords[2]",
        "coords[3]"
      ].slice(0, i);
      if (i === 1) {
        this.userCode = `
        int start = ${s};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
        return;
      }
      this.userCode = `
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `;
    }
  };
  class gje {
    constructor(e, t, r) {
      this.variableNames = [
        "x"
      ], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [
        {
          name: "value",
          type: "float"
        }
      ], this.outputShape = t.map((g, m) => g[0] + e[m] + g[1]);
      const i = e.length, a = Pn(i), s = t.map((g) => g[0]).join(","), o = t.map((g, m) => g[0] + e[m]).join(","), l = Di("rc", i), u = Di("source", i), c = `${l[i - 1]} < ${this.outputShape[i - 1]}`, h = i === 1 ? "source" : `vec2(${u.slice(-2).join()})`, d = [
        `${a} rc = outputLoc;`,
        `${l[i - 1]} += 1;
       if(${c}) {
      `,
        i === 1 ? "" : `}
       rc = outputLoc;
       ${l[i - 2]} += 1;
       if(${l[i - 2]} < ${this.outputShape[i - 2]}) {`,
        i === 1 ? "" : `  ${l[i - 1]} += 1;
         if(${c}) {`
      ], f = i === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
      let p = "";
      for (let g = 0, m = i === 1 ? 2 : 4; g < m; g++) p += `
        ${d[g]}
        if (${f}) {
          result[${g}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${g}] = getChannel(getX(${u.join()}), ${h});
        }
      `;
      p += i === 1 ? "} " : "}}", this.userCode = `
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `;
    }
  }
  const Ete = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { paddings: a, constantValue: s } = r;
    if (X(i.shape) === 0) {
      const u = a.map((c, h) => c[0] + i.shape[h] + c[1]);
      return Xb({
        backend: t,
        attrs: {
          shape: u,
          value: s,
          dtype: i.dtype
        }
      });
    }
    const o = ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new gje(i.shape, a, s) : new pje(i.shape, a, s), l = [
      [
        s
      ]
    ];
    return t.runWebGLProgram(o, [
      i
    ], i.dtype, l);
  }, mje = {
    kernelName: Pf,
    backendName: "webgl",
    kernelFunc: Ete
  };
  const vje = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`, yje = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + fp + `
  return result;
`, xje = li({
    opSnippet: vje,
    packedOpSnippet: yje
  }), bje = {
    kernelName: Lf,
    backendName: "webgl",
    kernelFunc: xje
  };
  function wje(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r, o = i.shape.length, l = [], u = yt(a, i.shape);
    let c = u;
    const h = bn(c, o);
    let d = i;
    h != null && (d = Li({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: h
      }
    }), c = gn(c.length, o), l.push(d)), Tn("prod", c, o);
    let f;
    if (t.shouldExecuteOnCPU([
      d
    ])) {
      const p = t.texData.get(d.dataId).values, { outVals: g, outShape: m, outDtype: v } = xHe(d.shape, d.dtype, p, c);
      f = t.makeTensorInfo(m, v, g);
    } else {
      const [p, g] = Ln(d.shape, c), m = X(g), v = Me({
        inputs: {
          x: d
        },
        backend: t,
        attrs: {
          shape: [
            -1,
            m
          ]
        }
      }), y = xI(i.dtype), x = pp(v, y, "prod", t);
      f = Me({
        inputs: {
          x
        },
        backend: t,
        attrs: {
          shape: p
        }
      }), l.push(v), l.push(x);
    }
    if (s) {
      l.push(f);
      const p = Mn(f.shape, u);
      f = Me({
        inputs: {
          x: f
        },
        backend: t,
        attrs: {
          shape: p
        }
      });
    }
    return l.forEach((p) => t.disposeIntermediateTensorInfo(p)), f;
  }
  const _je = {
    kernelName: Of,
    backendName: "webgl",
    kernelFunc: wje
  };
  function Sje(n) {
    const { inputs: e, backend: t, attrs: r } = n, { paramsNestedSplits: i, paramsDenseValues: a, indices: s } = e, { outputRaggedRank: o } = r, l = i.map((v) => t.readSync(v.dataId)), u = i.map((v) => v.shape), c = t.readSync(a.dataId), h = t.readSync(s.dataId), [d, f, p] = bHe(l, u, c, a.shape, a.dtype, h, s.shape, o), g = d.map((v) => t.makeTensorInfo([
      v.length
    ], "int32", v)), m = t.makeTensorInfo(p, a.dtype, f);
    return g.concat([
      m
    ]);
  }
  const Cje = {
    kernelName: Y7,
    backendName: "webgl",
    kernelFunc: Sje
  };
  function Ije(n) {
    const { inputs: e, backend: t } = n, { starts: r, limits: i, deltas: a } = e, s = t.readSync(r.dataId), o = t.readSync(i.dataId), l = t.readSync(a.dataId), [u, c] = wHe(s, r.shape, r.dtype, o, i.shape, l, a.shape), h = t.makeTensorInfo([
      u.length
    ], "int32", u), d = t.makeTensorInfo([
      c.length
    ], r.dtype, c);
    return [
      h,
      d
    ];
  }
  const kje = {
    kernelName: q7,
    backendName: "webgl",
    kernelFunc: Ije
  };
  function Tje(n) {
    const { inputs: e, backend: t, attrs: r } = n, { shape: i, values: a, defaultValue: s, rowPartitionTensors: o } = e, { rowPartitionTypes: l } = r, u = t.readSync(i.dataId), c = t.readSync(a.dataId), h = t.readSync(s.dataId), d = o.map((m) => t.readSync(m.dataId)), f = o.map((m) => m.shape), [p, g] = _He(u, i.shape, c, a.shape, a.dtype, h, s.shape, d, f, l);
    return t.makeTensorInfo(p, a.dtype, g);
  }
  const Aje = {
    kernelName: j7,
    backendName: "webgl",
    kernelFunc: Tje
  };
  const Mte = (n) => {
    const { backend: e, attrs: t } = n, { start: r, stop: i, step: a, dtype: s } = t, o = SHe(r, i, a, s);
    return e.makeTensorInfo([
      o.length
    ], s, o);
  }, Dje = {
    kernelName: cb,
    backendName: "webgl",
    kernelFunc: Mte
  };
  const Rje = "return 1.0 / x;", $je = cn({
    opSnippet: Rje
  }), Nje = {
    kernelName: Bf,
    backendName: "webgl",
    kernelFunc: $je
  };
  const Eje = Rs + `
  return (x < 0.0) ? 0.0 : x;
`, Mje = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, Pje = cn({
    opSnippet: Eje,
    packedOpSnippet: Mje
  }), Lje = {
    kernelName: zf,
    backendName: "webgl",
    kernelFunc: Pje
  };
  const Fje = Rs + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, Oje = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, Bje = cn({
    opSnippet: Fje,
    packedOpSnippet: Oje
  }), zje = {
    kernelName: Gf,
    backendName: "webgl",
    kernelFunc: Bje
  };
  let Vje = class {
    constructor(e, t, r, i, a) {
      this.variableNames = [
        "A"
      ], this.outputShape = [];
      const [s, o, l, u] = e;
      this.outputShape = [
        s,
        t,
        r,
        u
      ];
      const c = [
        i && t > 1 ? o - 1 : o,
        i && r > 1 ? l - 1 : l
      ], h = [
        i && t > 1 ? t - 1 : t,
        i && r > 1 ? r - 1 : r
      ];
      let d;
      a ? d = "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : d = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0] / h[0]},
          ${c[1] / h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
  };
  class Wje {
    constructor(e, t, r, i, a) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      const [s, o, l, u] = e;
      this.outputShape = [
        s,
        t,
        r,
        u
      ];
      const c = [
        i && t > 1 ? o - 1 : o,
        i && r > 1 ? l - 1 : l
      ], h = [
        i && t > 1 ? t - 1 : t,
        i && r > 1 ? r - 1 : r
      ];
      let d;
      a ? d = "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : d = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0] / h[0]},
          ${c[1] / h[1]},
          ${c[1] / h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u - 1};
        bool hasNextRow = coords.z < ${r - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
  }
  function Gje(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i } = e, { alignCorners: a, halfPixelCenters: s, size: o } = r, [l, u] = o, c = ne().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new Wje(i.shape, l, u, a, s) : new Vje(i.shape, l, u, a, s);
    return t.runWebGLProgram(c, [
      i
    ], "float32");
  }
  const Uje = {
    kernelName: Wf,
    backendName: "webgl",
    kernelFunc: Gje
  };
  let Hje = class {
    constructor(e, t, r) {
      this.variableNames = [
        "dy"
      ], this.outputShape = [], this.outputShape = t;
      const [, i, a] = t, [, s, o] = e, l = [
        r && s > 1 ? i - 1 : i,
        r && o > 1 ? a - 1 : a
      ], u = [
        r && s > 1 ? s - 1 : s,
        r && o > 1 ? o - 1 : o
      ], c = l[0] / u[0], h = l[1] / u[1], d = 1 / c, f = 1 / h, p = Math.ceil(d) * 2 + 2, g = Math.ceil(f) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };
  function Xje(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i, dy: a } = e, { alignCorners: s } = r, o = new Hje(a.shape, i.shape, s);
    return t.runWebGLProgram(o, [
      a
    ], a.dtype);
  }
  const Yje = {
    kernelName: hv,
    backendName: "webgl",
    kernelFunc: Xje
  };
  let qje = class {
    constructor(e, t, r, i, a) {
      this.variableNames = [
        "A"
      ], this.outputShape = [];
      const [s, o, l, u] = e;
      this.outputShape = [
        s,
        t,
        r,
        u
      ];
      const c = [
        i && t > 1 ? o - 1 : o,
        i && r > 1 ? l - 1 : l
      ], h = [
        i && t > 1 ? t - 1 : t,
        i && r > 1 ? r - 1 : r
      ], d = i ? "0.5" : "0.0";
      let f;
      a ? f = "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : f = "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0] / h[0]},
          ${c[1] / h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
  };
  class jje {
    constructor(e, t, r, i, a) {
      this.variableNames = [
        "A"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
      const [s, o, l, u] = e;
      this.outputShape = [
        s,
        t,
        r,
        u
      ];
      const c = [
        i && t > 1 ? o - 1 : o,
        i && r > 1 ? l - 1 : l
      ], h = [
        i && t > 1 ? t - 1 : t,
        i && r > 1 ? r - 1 : r
      ], d = i ? "0.5" : "0.0";
      let f;
      a ? f = "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : f = "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0] / h[0]},
          ${c[1] / h[1]},
          ${c[1] / h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u - 1};
        bool hasNextRow = coords.z < ${r - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
  }
  function Kje(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i } = e, { alignCorners: a, halfPixelCenters: s, size: o } = r, [l, u] = o, c = ne().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new jje(i.shape, l, u, a, s) : new qje(i.shape, l, u, a, s);
    return t.runWebGLProgram(c, [
      i
    ], i.dtype);
  }
  const Zje = {
    kernelName: Vf,
    backendName: "webgl",
    kernelFunc: Kje
  };
  let Qje = class {
    constructor(e, t, r) {
      this.variableNames = [
        "dy"
      ], this.outputShape = [], this.outputShape = t;
      const [, i, a] = t, [, s, o] = e, l = [
        r && s > 1 ? i - 1 : i,
        r && o > 1 ? a - 1 : a
      ], u = [
        r && s > 1 ? s - 1 : s,
        r && o > 1 ? o - 1 : o
      ], c = l[0] / u[0], h = l[1] / u[1], d = 1 / c, f = 1 / h, p = Math.ceil(d) * 2 + 2, g = Math.ceil(f) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };
  function Jje(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i, dy: a } = e, { alignCorners: s } = r, o = new Qje(a.shape, i.shape, s);
    return t.runWebGLProgram(o, [
      a
    ], a.dtype);
  }
  const eKe = {
    kernelName: cv,
    backendName: "webgl",
    kernelFunc: Jje
  };
  let tKe = class {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ];
      const r = e.length;
      if (r > 4) throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);
      if (this.outputShape = e, r === 1) {
        this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;
        return;
      }
      const i = (o) => t.indexOf(o) !== -1 && e[o] !== 1 ? `${e[o]} - coords[${o}] - 1` : `coords[${o}]`, a = e.map((o, l) => i(l)).join(","), s = Pn(r);
      this.userCode = `
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `;
    }
  };
  class nKe {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.packedInputs = true, this.packedOutput = true;
      const r = e.length;
      if (r > 4) throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);
      this.outputShape = e;
      const i = Di("rc", r), a = `${i[r - 1]} + 1 < ${this.outputShape[r - 1]}`, s = `${i[r - 2]} + 1 < ${this.outputShape[r - 2]}`, o = Pn(r);
      r === 1 ? this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : this.userCode = `
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${a}){
            result.g = ${u(i.slice())};
          }
          if(${s}) {
            result.b = ${c(i.slice())};
            if(${a}) {
              result.a = ${h(i.slice())};
            }
          }
          setOutput(result);
        }
    `;
      function l(p) {
        return d(p);
      }
      function u(p) {
        return p[r - 1] = "(" + p[r - 1] + " + 1)", d(p);
      }
      function c(p) {
        return p[r - 2] = "(" + p[r - 2] + " + 1)", d(p);
      }
      function h(p) {
        return p[r - 1] = "(" + p[r - 1] + " + 1)", p[r - 2] = "(" + p[r - 2] + " + 1)", d(p);
      }
      function d(p) {
        const g = e.map((y, x) => f(x, p)), m = g.join(","), v = g.slice(-2).join(",");
        return `getChannel(getX(${m}), vec2(${v}))`;
      }
      function f(p, g) {
        return t.indexOf(p) !== -1 && e[p] !== 1 ? `${e[p]} - ${g[p]} - 1` : `${g[p]}`;
      }
    }
  }
  function rKe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { dims: a } = r, s = i.shape.length, o = yt(a, i.shape);
    if (s === 0) return Ta({
      inputs: {
        x: i
      },
      backend: t
    });
    const l = ne().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new nKe(i.shape, o) : new tKe(i.shape, o);
    return t.runWebGLProgram(l, [
      i
    ], i.dtype);
  }
  const iKe = {
    kernelName: Uf,
    backendName: "webgl",
    kernelFunc: rKe
  };
  let aKe = class {
    constructor(e, t) {
      this.variableNames = [
        "Image"
      ], this.outputShape = [], this.customUniforms = [
        {
          name: "params",
          type: "vec4"
        }
      ];
      const r = e[1], i = e[2];
      this.outputShape = e;
      let a = "";
      typeof t == "number" ? a = `float outputValue = ${t.toFixed(2)};` : a = `
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };
  const sKe = {
    kernelName: wv,
    backendName: "webgl",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { image: r } = n, { radians: i, fillValue: a, center: s } = e, o = t, l = new aKe(r.shape, a), [u, c] = kb(s, r.shape[1], r.shape[2]), h = [
        [
          u,
          c,
          Math.sin(i),
          Math.cos(i)
        ]
      ];
      return o.runWebGLProgram(l, [
        r
      ], r.dtype, h);
    }
  };
  const oKe = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`, lKe = cn({
    opSnippet: oKe
  }), uKe = {
    kernelName: Hf,
    backendName: "webgl",
    kernelFunc: lKe
  };
  const cKe = "return inversesqrt(x);", hKe = cn({
    opSnippet: cKe,
    cpuKernelImpl: CHe
  }), dKe = {
    kernelName: Xf,
    backendName: "webgl",
    kernelFunc: hKe
  };
  let ML = class {
    constructor(e, t, r, i, a, s, o = true, l = false) {
      this.variableNames = [
        "updates",
        "indices",
        "defaultValue"
      ], this.outputShape = s;
      const u = Pn(a.length), c = Pn(s.length);
      let h = "";
      r === 1 ? h = "i" : r === 2 && (h = "i, j");
      const d = `getIndices(${h})`;
      let f = "";
      i === 1 ? f = "i" : i === 2 && (f = "i, coords[1]");
      const p = `getUpdates(${f})`;
      let g = "";
      l && (g = "coords[0], coords[1]");
      const m = `getDefaultValue(${g})`, v = t > 1 ? "strides[j]" : "strides";
      this.userCode = `
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `;
    }
  };
  class fKe {
    constructor(e, t, r, i, a, s, o = true, l = false) {
      this.variableNames = [
        "updates",
        "indices",
        "defaultValue"
      ], this.packedInputs = true, this.packedOutput = true, this.outputShape = s;
      const u = Pn(a.length), c = Pn(s.length);
      let h = "";
      r === 1 ? h = "i" : r === 2 && (h = "i, j");
      const d = `getIndices(${h})`;
      let f = "";
      i === 1 ? f = "i" : i === 2 && (f = "i, coords[1]");
      const p = `getUpdates(${f})`;
      let g = "";
      l && (g = "coords[0], coords[1]");
      const m = `getDefaultValue(${g})`, v = t > 1 ? "strides[j]" : "strides", y = t > 1 ? "strides[j + 1]" : "strides";
      this.userCode = `
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `;
    }
  }
  function pKe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { indices: i, updates: a } = e, { shape: s } = r, { sliceRank: o, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Ka(a, i, s), d = [
      h / u,
      u
    ];
    if (h === 0) return t.makeTensorInfo(s, i.dtype);
    const f = Me({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          l,
          o
        ]
      }
    }), p = Me({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          l,
          u
        ]
      }
    }), g = t.makeTensorInfo([], "float32", new Float32Array([
      0
    ]));
    let m;
    ne().getBool("WEBGL_PACK") ? m = new fKe(l, o, f.shape.length, p.shape.length, c, d) : m = new ML(l, o, f.shape.length, p.shape.length, c, d);
    const v = t.runWebGLProgram(m, [
      p,
      f,
      g
    ], p.dtype), y = Me({
      inputs: {
        x: v
      },
      backend: t,
      attrs: {
        shape: s
      }
    });
    return t.disposeIntermediateTensorInfo(f), t.disposeIntermediateTensorInfo(p), t.disposeIntermediateTensorInfo(v), t.disposeIntermediateTensorInfo(g), y;
  }
  const gKe = {
    kernelName: hb,
    backendName: "webgl",
    kernelFunc: pKe
  };
  let mKe = class {
    constructor(e, t, r, i) {
      this.variableNames = [
        "sortedSequence",
        "values"
      ], this.customUniforms = [
        {
          name: "numInputs",
          type: "int"
        }
      ], this.outputShape = [
        e,
        r
      ];
      const a = "while (left < right) {", s = `for (int i = 0; i < ${Math.ceil(Math.log2(t + 1))}; ++i) { if (left >= right) break;`, o = ne().getNumber("WEBGL_VERSION") === 2 ? a : s, l = i === "left" ? "<" : "<=";
      this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
    }
  };
  function vKe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { sortedSequence: i, values: a } = e, { side: s } = r, o = new mKe(i.shape[0], i.shape[1], a.shape[1], s), l = [
      [
        i.shape[1]
      ]
    ];
    return t.runWebGLProgram(o, [
      i,
      a
    ], "int32", l);
  }
  const yKe = {
    kernelName: fb,
    backendName: "webgl",
    kernelFunc: vKe
  };
  let xKe = class {
    constructor(e, t, r) {
      this.variableNames = [
        "c",
        "a",
        "b"
      ], this.outputShape = t;
      let i, a;
      if (r > 4) throw Error(`Where for rank ${r} is not yet supported`);
      if (r === 1) a = "resRC", i = "resRC";
      else {
        const o = [
          "resRC.x",
          "resRC.y",
          "resRC.z",
          "resRC.w"
        ], l = [], u = [];
        for (let c = 0; c < t.length; c++) u.push(`${o[c]}`), c < e && l.push(`${o[c]}`);
        i = l.join(), a = u.join();
      }
      const s = Pn(r);
      this.userCode = `
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `;
    }
  };
  function bKe(n) {
    const { inputs: e, backend: t } = n, { condition: r, t: i, e: a } = e, s = new xKe(r.shape.length, i.shape, i.shape.length);
    return t.runWebGLProgram(s, [
      r,
      i,
      a
    ], qr(i.dtype, a.dtype));
  }
  const wKe = {
    kernelName: dv,
    backendName: "webgl",
    kernelFunc: bKe
  };
  const _Ke = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Db};
  float scale = ${Rb};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`, SKe = cn({
    opSnippet: _Ke
  }), CKe = {
    kernelName: Yf,
    backendName: "webgl",
    kernelFunc: SKe
  };
  const IKe = Lv + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`, kKe = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, TKe = cn({
    opSnippet: IKe,
    packedOpSnippet: kKe,
    cpuKernelImpl: kHe
  }), AKe = {
    kernelName: Zf,
    backendName: "webgl",
    kernelFunc: TKe
  };
  const DKe = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`, RKe = cn({
    opSnippet: DKe
  }), $Ke = {
    kernelName: Kf,
    backendName: "webgl",
    kernelFunc: RKe
  };
  const NKe = Lv + `
  return sin(x);
`, EKe = `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${fp}
  return result;
`, MKe = cn({
    opSnippet: NKe,
    packedOpSnippet: EKe
  }), PKe = {
    kernelName: qf,
    backendName: "webgl",
    kernelFunc: MKe
  };
  const LKe = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`, FKe = cn({
    opSnippet: LKe
  }), OKe = {
    kernelName: jf,
    backendName: "webgl",
    kernelFunc: FKe
  };
  const BKe = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`, zKe = cn({
    opSnippet: BKe
  }), VKe = {
    kernelName: Qf,
    backendName: "webgl",
    kernelFunc: zKe
  };
  const WKe = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockShape: a, paddings: s } = r;
    B(i.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    const o = a.reduce((v, y) => v * y), l = [
      [
        0,
        0
      ]
    ];
    l.push(...s);
    for (let v = 1 + a.length; v < i.shape.length; ++v) l.push([
      0,
      0
    ]);
    const u = [], c = Ete({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        paddings: l,
        constantValue: 0
      }
    }), h = ou(c.shape, a, o, false), d = lu(h.length, a.length, false), f = uu(c.shape, a, o, false), p = Me({
      inputs: {
        x: c
      },
      backend: t,
      attrs: {
        shape: h
      }
    }), g = Li({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        perm: d
      }
    }), m = Me({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        shape: f
      }
    });
    return u.push(c), u.push(p), u.push(g), u.forEach((v) => t.disposeIntermediateTensorInfo(v)), m;
  }, GKe = {
    kernelName: pv,
    backendName: "webgl",
    kernelFunc: WKe
  };
  function UKe(n) {
    const { inputs: e, backend: t } = n, { indices: r, values: i, denseShape: a, defaultValue: s } = e;
    if (a.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);
    if (r.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Values must be a vector, saw:
         ${i.shape}`);
    if (s.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${s.shape}`);
    const o = t.readSync(r.dataId), l = t.readSync(i.dataId), u = t.readSync(a.dataId), c = t.readSync(s.dataId)[0], [h, d, f, p, g] = AHe(o, r.shape, r.dtype, l, i.dtype, u, c);
    return [
      t.makeTensorInfo(d, r.dtype, h),
      t.makeTensorInfo([
        d[0]
      ], i.dtype, f),
      t.makeTensorInfo([
        p.length
      ], "bool", new Uint8Array(p.map((m) => Number(m)))),
      t.makeTensorInfo([
        g.length
      ], r.dtype, new Int32Array(g))
    ];
  }
  const HKe = {
    kernelName: qM,
    backendName: "webgl",
    kernelFunc: UKe
  };
  function XKe(n) {
    const { inputs: e, backend: t } = n, { inputIndices: r, inputShape: i, newShape: a } = e;
    if (r.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${a.shape}`);
    const s = Array.from(t.readSync(i.dataId)), o = t.readSync(r.dataId), l = Array.from(t.readSync(a.dataId)), [u, c, h] = DHe(o, r.shape, r.dtype, s, l);
    return [
      t.makeTensorInfo(c, r.dtype, u),
      t.makeTensorInfo([
        h.length
      ], a.dtype, new Int32Array(h))
    ];
  }
  const YKe = {
    kernelName: dI,
    backendName: "webgl",
    kernelFunc: XKe
  };
  function qKe(n) {
    const { inputs: e, backend: t } = n, { data: r, indices: i, segmentIds: a } = e;
    if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (i.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);
    const s = t.readSync(r.dataId), o = t.readSync(i.dataId), l = t.readSync(a.dataId), [u, c] = ite(s, r.shape, r.dtype, o, l, true);
    return t.makeTensorInfo(c, r.dtype, u);
  }
  const jKe = {
    kernelName: fI,
    backendName: "webgl",
    kernelFunc: qKe
  };
  function KKe(n) {
    const { inputs: e, backend: t } = n, { data: r, indices: i, segmentIds: a } = e;
    if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
    if (i.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);
    const s = t.readSync(r.dataId), o = t.readSync(i.dataId), l = t.readSync(a.dataId), [u, c] = ite(s, r.shape, r.dtype, o, l);
    return t.makeTensorInfo(c, r.dtype, u);
  }
  const ZKe = {
    kernelName: pI,
    backendName: "webgl",
    kernelFunc: KKe
  };
  function QKe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { sparseIndices: i, sparseValues: a, defaultValue: s } = e, { outputShape: o } = r, { sliceRank: l, numUpdates: u, sliceSize: c, strides: h, outputSize: d } = Ka(a, i, o), f = false;
    if (a.dtype === "string") {
      const v = t.bufferSync(i), y = t.bufferSync(a), x = io(t.readSync(s.dataId)[0]), b = IHe(v, y, o, d, c, u, l, h, x, f);
      return t.makeTensorInfo(o, b.dtype, b.values);
    }
    const p = new ML(u, l, i.shape.length, a.shape.length, h, [
      d,
      1
    ], f), g = t.runWebGLProgram(p, [
      a,
      i,
      s
    ], a.dtype), m = Me({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        shape: o
      }
    });
    return t.disposeIntermediateTensorInfo(g), m;
  }
  const JKe = {
    kernelName: pb,
    backendName: "webgl",
    kernelFunc: QKe
  };
  function e7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { numOrSizeSplits: a, axis: s } = r, o = yt(s, i.shape)[0], l = $b(i, a, o), u = i.shape.length, c = new Array(u).fill(0), h = i.shape.slice();
    return l.map((d) => {
      const f = [
        ...h
      ];
      f[o] = d;
      const p = Fv({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: c,
          size: f
        }
      });
      return c[o] += d, p;
    });
  }
  const t7e = {
    kernelName: gv,
    backendName: "webgl",
    kernelFunc: e7e
  };
  const GU = "return sqrt(x);", n7e = cn({
    opSnippet: GU,
    packedOpSnippet: GU,
    cpuKernelImpl: RHe
  }), r7e = {
    kernelName: Jf,
    backendName: "webgl",
    kernelFunc: n7e
  };
  const i7e = "return x * x;", a7e = cn({
    opSnippet: i7e
  }), s7e = {
    kernelName: gb,
    backendName: "webgl",
    kernelFunc: a7e
  };
  const UU = "return (a - b) * (a - b);", o7e = li({
    opSnippet: UU,
    packedOpSnippet: UU
  }), l7e = {
    kernelName: np,
    backendName: "webgl",
    kernelFunc: o7e
  };
  function u7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e;
    if (i.dtype !== "string") throw new Error("Input must be of datatype string");
    const a = t.readSync(i.dataId), s = so(a), o = $He(s, "string", r);
    return t.makeTensorInfo(i.shape, "string", o);
  }
  const c7e = {
    kernelName: jM,
    backendName: "webgl",
    kernelFunc: u7e
  };
  function h7e({ inputs: n, attrs: e, backend: t }) {
    const { x: r } = n, i = Rs + `
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `, a = new Wo(r.shape, i);
    return t.runWebGLProgram(a, [
      r
    ], r.dtype);
  }
  const d7e = {
    kernelName: _c,
    backendName: "webgl",
    kernelFunc: h7e
  };
  let f7e = class {
    constructor(e, t, r) {
      this.variableNames = [
        "x"
      ], this.outputShape = r;
      const i = r.length, a = Pn(r.length), s = Pn(r.length);
      let o = "";
      if (i === 1) o = "coords * strides + begin";
      else {
        let l = 0;
        o = r.map((u, c) => (l++, r.length === 1 ? `coords * strides[${c}] + begin[${c}]` : `coords[${l - 1}] * strides[${c}] + begin[${c}]`)).join(",");
      }
      this.userCode = `
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `;
    }
  };
  function p7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { begin: a, end: s, strides: o, beginMask: l, endMask: u, ellipsisMask: c, newAxisMask: h, shrinkAxisMask: d } = r, { finalShapeSparse: f, finalShape: p, isIdentity: g, sliceDim0: m, isSimpleSlice: v, begin: y, end: x, strides: b } = Cb(i.shape, a, s, o, l, u, c, h, d);
    let w;
    if (g) w = Me({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: p
      }
    });
    else if (m || v) {
      B(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
      const S = Sb(y, x, b), I = Fv({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: y,
          size: S
        }
      });
      w = Me({
        inputs: {
          x: I
        },
        backend: t,
        attrs: {
          shape: p
        }
      }), t.disposeIntermediateTensorInfo(I);
    } else if (t.shouldExecuteOnCPU([
      i
    ])) {
      const I = t.readSync(i.dataId), C = Nt(i.shape, i.dtype, I), T = NHe(f, C, b, y);
      w = t.makeTensorInfo(p, i.dtype, T.values);
    } else {
      const I = new f7e(y, b, f);
      w = t.runWebGLProgram(I, [
        i
      ], i.dtype);
    }
    const _ = Me({
      inputs: {
        x: w
      },
      backend: t,
      attrs: {
        shape: p
      }
    });
    return t.disposeIntermediateTensorInfo(w), _;
  }
  const g7e = {
    kernelName: mv,
    backendName: "webgl",
    kernelFunc: p7e
  };
  function m7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { separator: i, nGramWidths: a, leftPad: s, rightPad: o, padWidth: l, preserveShortSequences: u } = r, { data: c, dataSplits: h } = e, d = t.readSync(c.dataId), f = t.readSync(h.dataId), [p, g] = EHe(d, f, i, a, s, o, l, u);
    return [
      t.makeTensorInfo([
        p.length
      ], "string", p),
      t.makeTensorInfo(h.shape, "int32", g)
    ];
  }
  const v7e = {
    kernelName: gI,
    backendName: "webgl",
    kernelFunc: m7e
  };
  function y7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { skipEmpty: i } = r, { input: a, delimiter: s } = e;
    if (a.dtype !== "string") throw new Error("Input must be of datatype string");
    if (a.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${a.shape}`);
    if (s.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${s.shape}`);
    const o = t.readSync(a.dataId), l = t.readSync(s.dataId)[0], [u, c, h] = MHe(o, l, i), d = c.length;
    return [
      t.makeTensorInfo([
        d,
        2
      ], "int32", u),
      t.makeTensorInfo([
        d
      ], "string", c),
      t.makeTensorInfo([
        2
      ], "int32", new Int32Array(h))
    ];
  }
  const x7e = {
    kernelName: KM,
    backendName: "webgl",
    kernelFunc: y7e
  };
  function b7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { numBuckets: i } = r, { input: a } = e;
    if (a.dtype !== "string") throw new Error("Input must be of datatype string");
    if (i <= 0) throw new Error("Number of buckets must be at least 1");
    const s = t.readSync(a.dataId), o = PHe(s, i);
    return t.makeTensorInfo(a.shape, "int32", o);
  }
  const w7e = {
    kernelName: ZM,
    backendName: "webgl",
    kernelFunc: b7e
  };
  const _7e = "return tan(x);", S7e = cn({
    opSnippet: _7e
  }), C7e = {
    kernelName: ip,
    backendName: "webgl",
    kernelFunc: S7e
  };
  const I7e = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`, k7e = cn({
    opSnippet: I7e
  }), T7e = {
    kernelName: ap,
    backendName: "webgl",
    kernelFunc: k7e
  };
  function A7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { tensor: i, indices: a, updates: s } = e, { sliceRank: o, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Ka(s, a, i.shape), d = [
      h / u,
      u
    ];
    if (h === 0) return t.makeTensorInfo(i.shape, a.dtype);
    const f = Me({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          l,
          o
        ]
      }
    }), p = Me({
      inputs: {
        x: s
      },
      backend: t,
      attrs: {
        shape: [
          l,
          u
        ]
      }
    }), g = Me({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: d
      }
    }), m = new ML(l, o, f.shape.length, p.shape.length, c, d, false, true), v = t.runWebGLProgram(m, [
      p,
      f,
      g
    ], g.dtype), y = Me({
      inputs: {
        x: v
      },
      backend: t,
      attrs: {
        shape: i.shape
      }
    });
    return t.disposeIntermediateTensorInfo(f), t.disposeIntermediateTensorInfo(p), t.disposeIntermediateTensorInfo(g), t.disposeIntermediateTensorInfo(v), y;
  }
  const D7e = {
    kernelName: db,
    backendName: "webgl",
    kernelFunc: A7e
  };
  let R7e = class {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ];
      const r = new Array(e.length);
      for (let s = 0; s < r.length; s++) r[s] = e[s] * t[s];
      this.outputShape = r, this.rank = r.length;
      const i = Pn(this.rank), a = $7e(e);
      this.userCode = `
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `;
    }
  };
  function $7e(n) {
    const e = n.length;
    if (e > 5) throw Error(`Tile for rank ${e} is not yet supported`);
    if (e === 1) return `imod(resRC, ${n[0]})`;
    const t = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w",
      "resRC.u"
    ], r = [];
    for (let i = 0; i < n.length; i++) r.push(`imod(${t[i]}, ${n[i]})`);
    return r.join();
  }
  function Pte(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { reps: a } = r;
    if (i.dtype === "string" || i.shape.length > 5) {
      const l = t.readSync(i.dataId), u = i.dtype === "string" ? l.map((d) => io(d)) : l, c = Nt(i.shape, i.dtype, u), h = FHe(c, a);
      return t.makeTensorInfo(h.shape, h.dtype, h.values);
    }
    const s = new R7e(i.shape, a);
    return t.runWebGLProgram(s, [
      i
    ], i.dtype);
  }
  const N7e = {
    kernelName: wc,
    backendName: "webgl",
    kernelFunc: Pte
  };
  let E7e = class {
    constructor(e) {
      this.variableNames = [
        "x",
        "indices"
      ], this.customUniforms = [
        {
          name: "n",
          type: "int"
        },
        {
          name: "firstPass",
          type: "int"
        },
        {
          name: "negativeInf",
          type: "float"
        },
        {
          name: "dir",
          type: "int"
        },
        {
          name: "inc",
          type: "int"
        }
      ], this.outputShape = e, this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
  }, M7e = class {
    constructor(e) {
      this.variableNames = [
        "x",
        "indices"
      ], this.customUniforms = [
        {
          name: "n",
          type: "int"
        },
        {
          name: "firstPass",
          type: "int"
        },
        {
          name: "k",
          type: "int"
        }
      ], this.outputShape = e, this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
  };
  function ch(n, e) {
    e !== null && n.disposeIntermediateTensorInfo(e);
  }
  function HU(n) {
    let e = 1;
    for (; e < n; ) e *= 2;
    return e;
  }
  function P7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { k: a, sorted: s } = r, o = ne().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), l = ne().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), u = i.shape, c = u[u.length - 1];
    if (t.shouldExecuteOnCPU([
      i
    ]) || c < o || a > l) {
      const T = t.readSync(i.dataId), [k, D] = OHe(T, u, i.dtype, a, s);
      return [
        t.makeTensorInfo(k.shape, k.dtype, k.values),
        t.makeTensorInfo(D.shape, D.dtype, D.values)
      ];
    }
    if (a === 0) return u[u.length - 1] = 0, [
      t.makeTensorInfo(u, i.dtype, []),
      t.makeTensorInfo(u, "int32", [])
    ];
    if (c === 1) return [
      i,
      Xb({
        attrs: {
          shape: u,
          dtype: "int32",
          value: 0
        },
        backend: t
      })
    ];
    const h = t.texData.get(i.dataId), d = h !== null && h.isPacked, f = d ? t.unpackTensor(i) : i, g = X(u) / c, m = Me({
      inputs: {
        x: f
      },
      attrs: {
        shape: [
          g,
          c
        ]
      },
      backend: t
    });
    d && ch(t, f);
    const v = HU(a), y = HU(c);
    let x = null;
    const b = () => x === null ? [
      m,
      m
    ] : [
      m,
      x
    ], w = (T, k, D) => {
      const R = b(), N = new E7e(D), A = [
        [
          c
        ],
        [
          x === null ? 1 : 0
        ],
        [
          Number.NEGATIVE_INFINITY
        ],
        [
          T
        ],
        [
          k
        ]
      ], M = x;
      x = t.runWebGLProgram(N, R, "int32", A), ch(t, M);
    };
    for (let T = 1; T < v; T *= 2) {
      const k = T * 2;
      for (let D = T; D >= 1; D /= 2) w(k, D, [
        g,
        y
      ]);
    }
    for (let T = y; T > v; T /= 2) {
      const k = b(), D = new M7e([
        g,
        T / 2
      ]), N = [
        [
          c
        ],
        [
          x === null ? 1 : 0
        ],
        [
          v
        ]
      ], E = x;
      x = t.runWebGLProgram(D, k, "int32", N), ch(t, E);
      const A = v / 2, M = A * 2;
      for (let $ = A; $ >= 1; $ /= 2) w(M, $, x.shape);
    }
    let _ = x;
    x = Fv({
      inputs: {
        x
      },
      backend: t,
      attrs: {
        begin: 0,
        size: [
          g,
          a
        ]
      }
    }), ch(t, _);
    let S = Tte({
      inputs: {
        x: m,
        indices: x
      },
      backend: t,
      attrs: {
        axis: 1,
        batchDims: 1
      }
    });
    ch(t, m);
    const I = u.slice(0, -1);
    I.push(a), _ = x, x = Me({
      inputs: {
        x
      },
      attrs: {
        shape: I
      },
      backend: t
    }), ch(t, _);
    const C = S;
    return S = Me({
      inputs: {
        x: S
      },
      attrs: {
        shape: I
      },
      backend: t
    }), ch(t, C), [
      S,
      x
    ];
  }
  const L7e = {
    kernelName: vv,
    backendName: "webgl",
    kernelFunc: P7e
  };
  let F7e = class {
    constructor(e, t, r, i, a, s) {
      this.variableNames = [
        "Image",
        "Transforms"
      ], this.outputShape = s;
      const o = r === "nearest" ? 1 : 2;
      let l;
      switch (i) {
        case "constant":
          l = 1;
          break;
        case "reflect":
          l = 2;
          break;
        case "wrap":
          l = 3;
          break;
        case "nearest":
          l = 4;
          break;
        default:
          l = 1;
          break;
      }
      this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
  };
  function O7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { image: i, transforms: a } = e, { interpolation: s, fillMode: o, fillValue: l, outputShape: u } = r, [c, h, d, f] = i.shape, [p, g] = u ?? [
      h,
      d
    ], m = [
      c,
      p,
      g,
      f
    ], v = new F7e(h, d, s, o, l, m);
    return t.runWebGLProgram(v, [
      i,
      a
    ], "float32");
  }
  const B7e = {
    kernelName: yv,
    backendName: "webgl",
    kernelFunc: O7e
  };
  function z7e(n) {
    const { inputs: e, attrs: t, backend: r } = n, { axis: i } = t, { x: a } = e;
    Gb(a, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    const s = r.readSync(a.dataId), { outputValues: o, outputShape: l, indices: u } = BHe(s, i, a.shape, a.dtype);
    return [
      r.makeTensorInfo(l, a.dtype, o),
      r.makeTensorInfo([
        u.length
      ], "int32", u)
    ];
  }
  const V7e = {
    kernelName: mI,
    backendName: "webgl",
    kernelFunc: z7e
  };
  function W7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { value: i } = e;
    let { axis: a } = r;
    a < 0 && (a += i.shape.length);
    const s = i, o = s.shape.length, l = i.shape[a], u = new Array(o - 1);
    let c = 0;
    for (let g = 0; g < o; g++) g !== a && (u[c++] = s.shape[g]);
    const h = [], d = new Array(o).fill(0), f = s.shape.slice();
    f[a] = 1;
    const p = new Array(l);
    for (let g = 0; g < p.length; g++) {
      d[a] = g;
      const m = Fv({
        inputs: {
          x: s
        },
        backend: t,
        attrs: {
          begin: d,
          size: f
        }
      }), v = Me({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: u
        }
      });
      p[g] = v, h.push(m);
    }
    return h.forEach((g) => t.disposeIntermediateTensorInfo(g)), p;
  }
  const G7e = {
    kernelName: xv,
    backendName: "webgl",
    kernelFunc: W7e
  };
  class U7e {
    constructor(e, t) {
      this.variableNames = [
        "x",
        "segmentIds"
      ];
      const r = e.windowSize, i = e.batchSize, a = e.inSize, s = e.numSegments, o = s * Math.ceil(a / r);
      this.outputShape = [
        i,
        o
      ];
      const l = "0.0", u = "sumValue", c = Math.floor(r / 4) * 4, h = r % 4, d = `
        sumValue += dot(values, segFilter);
    `;
      let f = "";
      a % r > 0 && (f = `
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);
      let p = "";
      a % r > 0 && (p = `
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `;
    }
  }
  function H7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, segmentIds: a } = e, { numSegments: s } = r, o = i.shape.length, l = [];
    let u = 0;
    const c = bn([
      u
    ], o);
    let h = i;
    c != null && (h = Li({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: c
      }
    }), l.push(h), u = gn(1, o)[0]);
    const d = VP(h.shape, u, s), f = X([
      h.shape[u]
    ]), p = Me({
      inputs: {
        x: h
      },
      backend: t,
      attrs: {
        shape: [
          -1,
          f
        ]
      }
    });
    l.push(p);
    const g = xI(i.dtype), m = (b, w, _, S, I) => {
      const C = b.shape[0], T = b.shape[1], k = SZ(T, I), D = {
        windowSize: k,
        inSize: T,
        batchSize: C,
        numSegments: I
      }, R = new U7e(D, w), N = t.compileAndRun(R, [
        b,
        _
      ], S);
      if (l.push(N), N.shape[1] === I) return N;
      const E = Mte({
        backend: t,
        attrs: {
          start: 0,
          stop: I,
          step: 1,
          dtype: "float32"
        }
      }), A = Pte({
        inputs: {
          x: E
        },
        backend: t,
        attrs: {
          reps: [
            T / k
          ]
        }
      });
      return l.push(E), l.push(A), m(N, w, A, S, I);
    }, v = m(p, "unsortedSegmentSum", a, g, s), y = Me({
      inputs: {
        x: v
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    let x = y;
    if (c != null) {
      l.push(y);
      const b = As(c);
      x = Li({
        inputs: {
          x
        },
        backend: t,
        attrs: {
          perm: b
        }
      });
    }
    return l.forEach((b) => t.disposeIntermediateTensorInfo(b)), x;
  }
  const X7e = {
    kernelName: mb,
    backendName: "webgl",
    kernelFunc: H7e
  };
  const Y7e = [
    R5e,
    N5e,
    P5e,
    O5e,
    z5e,
    G5e,
    H5e,
    Y5e,
    Z5e,
    J5e,
    n6e,
    a6e,
    l6e,
    d6e,
    g6e,
    v6e,
    x6e,
    S6e,
    I6e,
    T6e,
    $6e,
    O6e,
    z6e,
    U6e,
    X6e,
    Q6e,
    e8e,
    i8e,
    f5e,
    o8e,
    d8e,
    m8e,
    _8e,
    I8e,
    T8e,
    D8e,
    $8e,
    P8e,
    O8e,
    V8e,
    G8e,
    H8e,
    Y8e,
    K8e,
    Q8e,
    nXe,
    iXe,
    oXe,
    cXe,
    dXe,
    mXe,
    bXe,
    CXe,
    TXe,
    RXe,
    $Xe,
    EXe,
    PXe,
    FXe,
    BXe,
    VXe,
    HXe,
    qXe,
    ZXe,
    JXe,
    nYe,
    aYe,
    uYe,
    fYe,
    d5e,
    gYe,
    c8e,
    yYe,
    wYe,
    CYe,
    g5e,
    AYe,
    NYe,
    MYe,
    OYe,
    VYe,
    HYe,
    qYe,
    QYe,
    nqe,
    aqe,
    oqe,
    hqe,
    fqe,
    gqe,
    xqe,
    wqe,
    Sqe,
    Iqe,
    Tqe,
    $qe,
    Pqe,
    Bqe,
    Yqe,
    y5e,
    Zqe,
    eje,
    rje,
    sje,
    q6e,
    uje,
    hje,
    fje,
    mje,
    bje,
    v5e,
    _je,
    Cje,
    kje,
    Aje,
    Dje,
    j6e,
    Gqe,
    Nje,
    Lje,
    zje,
    b5e,
    Uje,
    Yje,
    Zje,
    eKe,
    iKe,
    sKe,
    uKe,
    dKe,
    gKe,
    yKe,
    wKe,
    CKe,
    AKe,
    $Ke,
    PKe,
    OKe,
    L6e,
    Hqe,
    VKe,
    GKe,
    HKe,
    YKe,
    jKe,
    ZKe,
    JKe,
    t7e,
    r7e,
    s7e,
    l7e,
    c7e,
    d7e,
    g7e,
    v7e,
    x7e,
    w7e,
    Uqe,
    T5e,
    C7e,
    T7e,
    D7e,
    N7e,
    L7e,
    B7e,
    A5e,
    V7e,
    G7e,
    X7e,
    cje
  ];
  for (const n of Y7e) vI(n);
  var fn;
  (function(n) {
    n[n.float32 = 0] = "float32", n[n.int32 = 1] = "int32", n[n.bool = 2] = "bool", n[n.string = 3] = "string", n[n.complex64 = 4] = "complex64";
  })(fn || (fn = {}));
  var vx;
  (function(n) {
    n[n.linear = 0] = "linear", n[n.relu = 1] = "relu", n[n.relu6 = 2] = "relu6", n[n.prelu = 3] = "prelu", n[n.leakyrelu = 4] = "leakyrelu", n[n.sigmoid = 5] = "sigmoid", n[n.elu = 6] = "elu";
  })(vx || (vx = {}));
  let Lte;
  function q7e(n) {
    Lte = n.wasm.cwrap(vd, null, [
      "number",
      "array",
      "number",
      "number",
      "array",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function j7e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { a: i, b: a, bias: s, preluActivationWeights: o } = e;
    if (i.dtype !== "float32" || a.dtype !== "float32") throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");
    const { transposeA: l, transposeB: u, activation: c, leakyreluAlpha: h } = r, d = t.dataIdMap.get(i.dataId).id, f = t.dataIdMap.get(a.dataId).id;
    let p = 0;
    if (s != null) {
      const I = t.dataIdMap.get(s.dataId);
      if (I.shape.length !== 1) throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${I.shape.length}.`);
      p = I.id;
    }
    const g = o == null ? 0 : t.dataIdMap.get(o.dataId).id, m = vx[c];
    if (m == null) throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);
    const v = l ? i.shape[2] : i.shape[1], y = u ? a.shape[1] : a.shape[2], x = ht(i.shape.slice(0, -2), a.shape.slice(0, -2)), b = t.makeOutput([
      ...x,
      v,
      y
    ], i.dtype), w = t.dataIdMap.get(b.dataId).id, _ = new Uint8Array(new Int32Array(i.shape).buffer), S = new Uint8Array(new Int32Array(a.shape).buffer);
    return Lte(d, _, i.shape.length, f, S, a.shape.length, l, u, m, p, g, h || 0, w), b;
  }
  const K7e = {
    kernelName: vd,
    backendName: "wasm",
    setupFunc: q7e,
    kernelFunc: j7e
  };
  function an(n, e) {
    let t;
    function r(a) {
      t = a.wasm.cwrap(n, null, [
        "number",
        "number",
        "number"
      ]);
    }
    function i(a) {
      const { backend: s, inputs: { x: o } } = a, l = s.dataIdMap.get(o.dataId).id, u = s.makeOutput(o.shape, e || o.dtype), c = s.dataIdMap.get(u.dataId).id;
      return X(u.shape) === 0 || t(l, fn[o.dtype], c), u;
    }
    return {
      kernelName: n,
      backendName: "wasm",
      setupFunc: r,
      kernelFunc: i
    };
  }
  const Z7e = an(Dm);
  const Q7e = an(Wd);
  const J7e = an(Gd);
  function wr(n, e, t) {
    let r;
    function i(s) {
      r = s.wasm.cwrap(n, null, [
        "number",
        "array",
        "number",
        "number",
        "array",
        "number",
        "number",
        "number"
      ]);
    }
    function a(s) {
      const { backend: o, inputs: l } = s, { a: u, b: c } = l, h = o.dataIdMap.get(u.dataId).id, d = o.dataIdMap.get(c.dataId).id, f = t ?? u.dtype, p = ht(u.shape, c.shape), g = o.makeOutput(p, f);
      if (X(p) === 0) return g;
      const m = new Uint8Array(new Int32Array(u.shape).buffer), v = new Uint8Array(new Int32Array(c.shape).buffer), y = o.dataIdMap.get(g.dataId).id;
      return r(h, m, u.shape.length, d, v, c.shape.length, fn[u.dtype], y), g;
    }
    return {
      kernelName: n,
      backendName: "wasm",
      setupFunc: i,
      kernelFunc: a
    };
  }
  const e9e = wr(xc);
  let Fte;
  function t9e(n) {
    Fte = n.wasm.cwrap(Rm, null, [
      "array",
      "number",
      "number",
      "number"
    ]);
  }
  function n9e(n) {
    const { inputs: e, backend: t } = n, r = t.makeOutput(e[0].shape, e[0].dtype);
    if (X(r.shape) === 0) return r;
    const i = e.map((o) => t.dataIdMap.get(o.dataId).id), a = new Uint8Array(new Int32Array(i).buffer), s = t.dataIdMap.get(r.dataId).id;
    return Fte(a, i.length, fn[r.dtype], s), r;
  }
  const r9e = {
    kernelName: Rm,
    backendName: "wasm",
    setupFunc: t9e,
    kernelFunc: n9e
  };
  function u2(n) {
    const { inputs: { x: e }, backend: t } = n;
    if (e.dtype === "string") return QM(t.readSync(e.dataId), e.shape, e.dtype);
    const r = t.makeOutput(e.shape, e.dtype), i = t.typedArrayFromHeap(e);
    return t.typedArrayFromHeap(r).set(i), r;
  }
  const i9e = {
    kernelName: vf,
    backendName: "wasm",
    kernelFunc: u2
  };
  let Ote;
  function a9e(n) {
    Ote = n.wasm.cwrap(Ol, null, [
      "number",
      "array",
      "number",
      "number",
      "number",
      "array",
      "number"
    ]);
  }
  function pc(n) {
    const { inputs: e, backend: t, attrs: r } = n, [i, a] = o9e(e.x.shape, r.perm);
    let s = true;
    for (let p = 0; p < a.length; p++) a[p] !== p && (s = false);
    const o = s9e(e.x.shape, r.perm), l = {
      dataId: e.x.dataId,
      shape: i,
      dtype: e.x.dtype
    };
    if (s) {
      const p = u2({
        inputs: e,
        backend: t
      });
      return p.shape = o, p;
    }
    const u = t.makeOutput(o, l.dtype), c = t.dataIdMap.get(l.dataId).id, h = t.dataIdMap.get(u.dataId).id, d = new Uint8Array(new Int32Array(a).buffer), f = new Uint8Array(new Int32Array(l.shape).buffer);
    return Ote(c, f, l.shape.length, fn[l.dtype], h, d, a.length), u;
  }
  function s9e(n, e) {
    const t = new Array(n.length);
    for (let r = 0; r < t.length; r++) t[r] = n[e[r]];
    return t;
  }
  function o9e(n, e) {
    const t = [], r = [];
    for (let i = 0; i < n.length; ++i) n[i] !== 1 && t.push(n[i]), n[e[i]] !== 1 && r.push(e[i]);
    for (let i = 0; i < r.length; ++i) {
      let a = -1;
      for (let s = 0; s < r.length; ++s) r[s] >= i && (a === -1 || r[a] > r[s]) && (a = s);
      r[a] = i;
    }
    return [
      t,
      r
    ];
  }
  const l9e = {
    kernelName: Ol,
    backendName: "wasm",
    kernelFunc: pc,
    setupFunc: a9e
  };
  function Rc(n, e, t) {
    const r = n.shape, i = n.shape.length, a = yt(e, r);
    let s = a;
    const o = bn(s, i);
    let l = null, u = false;
    if (o != null) {
      const c = new Array(i);
      for (let f = 0; f < c.length; f++) c[f] = r[o[f]];
      s = gn(s.length, i), l = pc({
        inputs: {
          x: n
        },
        attrs: {
          perm: o
        },
        backend: t
      });
      const h = t.dataIdMap.get(n.dataId).id;
      t.dataIdMap.get(l.dataId).id !== h && (u = true);
    }
    return {
      transposed: l,
      originalAxes: a,
      axes: s,
      inputWasTransposed: u
    };
  }
  let Bte;
  function u9e(n) {
    Bte = n.wasm.cwrap($m, null, [
      "number, number, number"
    ]);
  }
  function c9e(n) {
    const { backend: e, inputs: t, attrs: r } = n, { axis: i, keepDims: a } = r, { x: s } = t;
    let l = e.dataIdMap.get(s.dataId).id, u = s;
    const { transposed: c, axes: h, originalAxes: d, inputWasTransposed: f } = Rc(s, i, e);
    if (f) {
      const x = e.dataIdMap.get(c.dataId).id;
      u = c, l = x;
    }
    const p = u.shape.length;
    Tn("all", h, p);
    const [g, m] = Ln(u.shape, h), v = X(m), y = e.makeOutput(g, s.dtype);
    if (X(u.shape) !== 0) {
      const x = e.dataIdMap.get(y.dataId).id;
      Bte(l, v, x);
    }
    if (f && e.disposeData(c.dataId), a) {
      const x = Mn(y.shape, d);
      y.shape = x;
    }
    return y;
  }
  const h9e = {
    kernelName: $m,
    backendName: "wasm",
    setupFunc: u9e,
    kernelFunc: c9e
  };
  let zte;
  function d9e(n) {
    zte = n.wasm.cwrap(Nm, null, [
      "number, number, number"
    ]);
  }
  function f9e(n) {
    const { backend: e, inputs: t, attrs: r } = n, { axis: i, keepDims: a } = r, { x: s } = t;
    let l = e.dataIdMap.get(s.dataId).id, u = s;
    const { transposed: c, axes: h, originalAxes: d, inputWasTransposed: f } = Rc(s, i, e);
    if (f) {
      const x = e.dataIdMap.get(c.dataId).id;
      u = c, l = x;
    }
    const p = u.shape.length;
    Tn("any", h, p);
    const [g, m] = Ln(u.shape, h), v = X(m), y = e.makeOutput(g, s.dtype);
    if (X(u.shape) !== 0) {
      const x = e.dataIdMap.get(y.dataId).id;
      zte(l, v, x);
    }
    if (f && e.disposeData(c.dataId), a) {
      const x = Mn(y.shape, d);
      y.shape = x;
    }
    return y;
  }
  const p9e = {
    kernelName: Nm,
    backendName: "wasm",
    setupFunc: d9e,
    kernelFunc: f9e
  };
  function Vte(n) {
    let e;
    function t(i) {
      e = i.wasm.cwrap(n, null, [
        "number",
        "number",
        "number",
        "number",
        "number"
      ]);
    }
    function r(i) {
      const { backend: a, inputs: s, attrs: o } = i, { axis: l } = o, { x: u } = s, c = a.dataIdMap.get(u.dataId).id;
      let h = c, d = u;
      const { transposed: f, axes: p, inputWasTransposed: g } = Rc(u, l, a);
      if (g) {
        const w = a.dataIdMap.get(f.dataId).id;
        w !== c && (d = f, h = w);
      }
      const m = d.shape.slice(0, -1), v = a.makeOutput(m, "int32"), y = a.dataIdMap.get(v.dataId).id, x = X(v.shape), b = d.shape[p[0]];
      return e(h, fn[d.dtype], x, b, y), g && a.disposeData(f.dataId), v;
    }
    return {
      kernelName: n,
      backendName: "wasm",
      setupFunc: t,
      kernelFunc: r
    };
  }
  const g9e = Vte(Em);
  const m9e = Vte(Mm);
  const v9e = an(Ud);
  const y9e = an(Hd);
  const x9e = an(Xd);
  const b9e = wr(qd);
  const w9e = an(Yd);
  let Wte;
  function _9e(n) {
    Wte = n.wasm.cwrap(jd, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function S9e(n) {
    const { inputs: e, attrs: t, backend: r } = n, i = e.x, a = r.dataIdMap.get(i.dataId).id, { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = t, c = dr(i.shape, s, o, 1, l, u), h = c.filterHeight, d = c.filterWidth, f = c.padInfo.top, p = c.padInfo.right, g = c.padInfo.bottom, m = c.padInfo.left, v = c.strideHeight, y = c.strideWidth, x = c.inChannels;
    if (c.dataFormat !== "channelsLast") throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);
    if (c.dilationWidth !== 1 || c.dilationHeight !== 1) throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);
    const b = r.makeOutput(c.outShape, "float32"), w = r.dataIdMap.get(b.dataId).id;
    return Wte(a, i.shape[0], i.shape[1], i.shape[2], h, d, f, p, g, m, v, y, x, w), b;
  }
  const C9e = {
    kernelName: jd,
    backendName: "wasm",
    setupFunc: _9e,
    kernelFunc: S9e
  };
  let Gte;
  function I9e(n) {
    Gte = n.wasm.cwrap("AvgPool3D", null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function k9e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dimRoundingMode: l, dataFormat: u } = r, c = vi(i.shape, a, s, 1, o, l, u), h = t.makeOutput(c.outShape, i.dtype);
    return Gte(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(h.dataId).id, c.batchSize, c.inChannels, c.inDepth, c.inHeight, c.inWidth, c.outDepth, c.outHeight, c.outWidth, c.strideDepth, c.strideHeight, c.strideWidth, c.dilationDepth, c.dilationHeight, c.dilationWidth, c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.front, c.padInfo.top, c.padInfo.left), h;
  }
  const T9e = {
    kernelName: Pm,
    backendName: "wasm",
    setupFunc: I9e,
    kernelFunc: k9e
  };
  let Ute;
  function A9e(n) {
    Ute = n.wasm.cwrap("AvgPool3DGrad", null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function D9e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = r, c = vi(a.shape, s, o, 1, l, u), h = t.makeOutput(a.shape, a.dtype);
    return Ute(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(h.dataId).id, c.batchSize, c.inChannels, c.inDepth, c.inHeight, c.inWidth, c.outDepth, c.outHeight, c.outWidth, c.strideDepth, c.strideHeight, c.strideWidth, c.dilationDepth, c.dilationHeight, c.dilationWidth, c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.front, c.padInfo.top, c.padInfo.left, c.filterDepth, c.filterHeight, c.filterWidth), h;
  }
  const R9e = {
    kernelName: eb,
    backendName: "wasm",
    setupFunc: A9e,
    kernelFunc: D9e
  };
  let Hte;
  function $9e(n) {
    Hte = n.wasm.cwrap("AvgPoolGrad", null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function N9e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, { filterSize: s, strides: o, pad: l } = r, u = dr(a.shape, s, o, 1, l), c = t.makeOutput(a.shape, a.dtype);
    return Hte(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(c.dataId).id, u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.top, u.padInfo.left, u.filterHeight, u.filterWidth), c;
  }
  const E9e = {
    kernelName: Jx,
    backendName: "wasm",
    setupFunc: $9e,
    kernelFunc: N9e
  };
  function Ji(n) {
    const { inputs: e, attrs: t } = n, { x: r } = e, { shape: i } = t, a = X(r.shape), s = QC(i, a);
    return B(a === X(s), () => `new shape: ${s}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`), n.backend.incRef(r.dataId), {
      dataId: r.dataId,
      shape: s,
      dtype: r.dtype
    };
  }
  const M9e = {
    kernelName: uv,
    backendName: "wasm",
    kernelFunc: Ji
  };
  let Xte;
  function P9e(n) {
    Xte = n.wasm.cwrap(Kd, null, [
      "number",
      "array",
      "number",
      "number",
      "array",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function L9e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { a: i, b: a } = e, { transposeA: s, transposeB: o } = r;
    if (i.dtype !== "float32" || a.dtype !== "float32") throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");
    const l = i.shape.length, u = a.shape.length, c = s ? i.shape[l - 2] : i.shape[l - 1], h = o ? a.shape[u - 1] : a.shape[u - 2], d = s ? i.shape[l - 1] : i.shape[l - 2], f = o ? a.shape[u - 2] : a.shape[u - 1], p = i.shape.slice(0, -2), g = a.shape.slice(0, -2), m = X(p), v = X(g), x = ht(i.shape.slice(0, -2), a.shape.slice(0, -2)).concat([
      d,
      f
    ]);
    B(c === h, () => `Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${s} and transposeB=${o} must match.`);
    const b = s ? [
      m,
      c,
      d
    ] : [
      m,
      d,
      c
    ], w = o ? [
      v,
      f,
      h
    ] : [
      v,
      h,
      f
    ], _ = Ji({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: b
      }
    }), S = Ji({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: w
      }
    }), I = t.dataIdMap.get(_.dataId).id, C = t.dataIdMap.get(S.dataId).id, T = s ? _.shape[2] : _.shape[1], k = o ? S.shape[1] : S.shape[2], D = Math.max(m, v), R = t.makeOutput([
      D,
      T,
      k
    ], _.dtype), N = t.dataIdMap.get(R.dataId).id, E = new Uint8Array(new Int32Array(_.shape).buffer), A = new Uint8Array(new Int32Array(S.shape).buffer);
    return Xte(I, E, _.shape.length, C, A, S.shape.length, s, o, N), t.disposeData(_.dataId), t.disposeData(S.dataId), R.shape = x, R;
  }
  const F9e = {
    kernelName: Kd,
    backendName: "wasm",
    setupFunc: P9e,
    kernelFunc: L9e
  };
  function $d(n) {
    const { inputs: { x: e }, attrs: { begin: t, size: r }, backend: i } = n, [a, s] = Av(e, t, r), o = NI(e.shape, a, s), l = i.readSync(e.dataId), u = i.makeOutput(s, e.dtype), c = Be(e.shape), h = i.dataIdMap.get(u.dataId);
    if (o) {
      const p = EI(a, c);
      return e.dtype === "string" ? h.stringBytes = l.slice(p, p + X(s)) : i.typedArrayFromHeap(u).set(l.subarray(p, p + X(s))), u;
    }
    if (e.dtype === "string") {
      const p = XS(l, a, s, e.shape, e.dtype);
      return h.stringBytes = p, u;
    }
    const d = i.typedArrayFromHeap(u), f = e.shape.length;
    if (f === 2) O9e(l, c[0], d, a, s);
    else if (f === 3) B9e(l, c[0], c[1], d, a, s);
    else if (f === 4) z9e(l, c[0], c[1], c[2], d, a, s);
    else {
      const p = XS(l, a, s, e.shape, e.dtype);
      d.set(p);
    }
    return u;
  }
  function O9e(n, e, t, r, i) {
    let a = 0;
    const s = r[0], o = r[1], l = s + i[0];
    for (let u = s; u < l; u++) {
      const c = u * e + o;
      t.set(n.subarray(c, c + i[1]), a), a += i[1];
    }
  }
  function B9e(n, e, t, r, i, a) {
    let s = 0;
    const o = i[0], l = i[1], u = i[2], c = o + a[0], h = l + a[1];
    for (let d = o; d < c; d++) for (let f = l; f < h; f++) {
      const p = d * e + f * t + u;
      r.set(n.subarray(p, p + a[2]), s), s += a[2];
    }
  }
  function z9e(n, e, t, r, i, a, s) {
    let o = 0;
    const l = a[0], u = a[1], c = a[2], h = l + s[0], d = u + s[1], f = c + s[2], p = a[3];
    for (let g = l; g < h; g++) for (let m = u; m < d; m++) for (let v = c; v < f; v++) {
      const y = g * e + m * t + v * r + p;
      i.set(n.subarray(y, y + s[3]), o), o += s[3];
    }
  }
  const V9e = {
    kernelName: fv,
    backendName: "wasm",
    kernelFunc: $d
  };
  function W9e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockShape: a, crops: s } = r, o = a.reduce((v, y) => v * y), l = ou(i.shape, a, o), u = lu(l.length, a.length), c = uu(i.shape, a, o), h = Tb(s, a.length), d = Ab(c, s, a.length), f = Ji({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), p = pc({
      inputs: {
        x: f
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), g = Ji({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), m = $d({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        begin: h,
        size: d
      }
    });
    return t.disposeData(f.dataId), t.disposeData(p.dataId), t.disposeData(g.dataId), m;
  }
  const G9e = {
    kernelName: Lm,
    backendName: "wasm",
    kernelFunc: W9e
  };
  let Yte;
  function U9e(n) {
    Yte = n.wasm.cwrap(Fm, null, [
      "number",
      "number",
      "boolean",
      "number",
      "number",
      "number"
    ]);
  }
  function H9e(n) {
    const { backend: e, inputs: t, attrs: r } = n, { x: i, weights: a } = t, { size: s } = r, o = a.shape.reduce((h, d) => h * d, 1) !== 0, l = i.shape.length === 1 ? [
      s
    ] : [
      i.shape[0],
      s
    ], u = e.makeOutput(l, a.dtype);
    function c(h) {
      return e.dataIdMap.get(h.dataId).id;
    }
    return Yte(c(i), s, o, c(a), fn[a.dtype], c(u)), u;
  }
  const X9e = {
    kernelName: Fm,
    backendName: "wasm",
    setupFunc: U9e,
    kernelFunc: H9e
  };
  const Y9e = wr(JC);
  function q9e(n) {
    const { inputs: e, backend: t } = n, { s0: r, s1: i } = e, a = t.typedArrayFromHeap(r), s = t.typedArrayFromHeap(i), o = ht(Array.from(a), Array.from(s));
    return t.makeOutput([
      o.length
    ], "int32", void 0, new Int32Array(o));
  }
  const j9e = {
    kernelName: eI,
    backendName: "wasm",
    kernelFunc: q9e
  };
  function $c(n) {
    const { inputs: { x: e }, attrs: { dtype: t }, backend: r } = n, i = r.makeOutput(e.shape, t), a = r.typedArrayFromHeap(e);
    return r.typedArrayFromHeap(i).set(a), i;
  }
  const K9e = {
    kernelName: Zd,
    backendName: "wasm",
    kernelFunc: $c
  };
  const Z9e = an(Qd);
  let qte;
  function Q9e(n) {
    qte = n.wasm.cwrap(bc, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function J9e(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { clipValueMin: a, clipValueMax: s } = r, o = t.dataIdMap.get(i.dataId).id, l = t.makeOutput(i.shape, i.dtype), u = t.dataIdMap.get(l.dataId).id;
    return qte(o, a, s, u), l;
  }
  const eZe = {
    kernelName: bc,
    backendName: "wasm",
    setupFunc: Q9e,
    kernelFunc: J9e
  };
  function jte(n) {
    const { inputs: e, backend: t } = n, r = yt(n.attrs.axis, e[0].shape)[0], i = e.map((f) => f.shape);
    Ib(i, r);
    let a = ai(e.map((f) => f.shape), r);
    const s = e.filter((f) => X(f.shape) > 0);
    if (s.length === 1) return u2({
      inputs: {
        x: s[0]
      },
      backend: t
    });
    const o = t.makeOutput(a, e[0].dtype);
    if (X(a) === 0) return o;
    if (s[0].dtype === "string") {
      const f = s.map((x) => {
        const w = [
          -1,
          X(x.shape.slice(r))
        ];
        return Ji({
          inputs: {
            x
          },
          backend: t,
          attrs: {
            shape: w
          }
        });
      }), p = f.map((x) => ({
        vals: t.readSync(x.dataId),
        shape: x.shape
      }));
      a = ai(f.map((x) => x.shape), 1);
      const g = f[0].shape[0] === 1, m = fL(p, a, e[0].dtype, g), v = ai(s.map((x) => x.shape), r);
      o.shape = v;
      const y = t.dataIdMap.get(o.dataId);
      return y.stringBytes = WP(m), f.forEach((x) => t.disposeData(x.dataId)), o;
    }
    const l = X(s[0].shape.slice(0, r));
    let u = 0;
    const c = s.map((f) => {
      const p = X(f.shape.slice(r));
      return u += p, p;
    }), h = s.map((f) => t.typedArrayFromHeap(f)), d = t.typedArrayFromHeap(o);
    for (let f = 0; f < l; f++) {
      let p = f * u;
      for (let g = 0; g < h.length; g++) {
        const m = c[g], v = f * m, y = h[g].subarray(v, v + m);
        d.set(y, p), p += m;
      }
    }
    return o;
  }
  const tZe = {
    kernelName: Om,
    backendName: "wasm",
    kernelFunc: jte
  };
  let Kte;
  function nZe(n) {
    Kte = n.wasm.cwrap(Jd, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function rZe(n) {
    const { inputs: e, attrs: t, backend: r } = n, { x: i, filter: a } = e, s = r.dataIdMap.get(i.dataId).id, o = r.dataIdMap.get(a.dataId).id, { strides: l, dilations: u, pad: c, dimRoundingMode: h, dataFormat: d } = t, f = Oi(d), p = Sn(i.shape, a.shape, l, u, c, h, false, f), g = p.filterHeight, m = p.filterWidth, v = p.padInfo.top, y = p.padInfo.right, x = p.padInfo.bottom, b = p.padInfo.left, w = p.dilationHeight, _ = p.dilationWidth, S = p.strideHeight, I = p.strideWidth, C = p.inChannels, T = p.outChannels, k = p.padInfo.type === "SAME" ? 1 : 0;
    if (p.dataFormat !== "channelsLast") throw new Error(`wasm backend Conv2D does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);
    const D = r.makeOutput(p.outShape, "float32"), R = r.dataIdMap.get(D.dataId).id;
    return Kte(s, i.shape[0], i.shape[1], i.shape[2], o, g, m, v, y, x, b, k, w, _, S, I, C, T, R), D;
  }
  const iZe = {
    kernelName: Jd,
    backendName: "wasm",
    setupFunc: nZe,
    kernelFunc: rZe
  };
  let Zte;
  function aZe(n) {
    Zte = n.wasm.cwrap(ef, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function sZe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { dy: i, filter: a } = t, { strides: s, pad: o, dataFormat: l, dimRoundingMode: u, inputShape: c } = r, h = 1, d = Oi(l), f = Sn(c, a.shape, s, h, o, u, false, d), { batchSize: p, filterHeight: g, filterWidth: m, inChannels: v, inHeight: y, inWidth: x, outChannels: b, outHeight: w, outWidth: _, strideHeight: S, strideWidth: I } = f, C = g - 1 - f.padInfo.top, T = m - 1 - f.padInfo.left, k = f.dataFormat === "channelsLast", D = Be(f.inShape), R = Be(i.shape), [N, E, A] = Be(a.shape), M = D[0], $ = k ? D[1] : D[2], L = k ? D[2] : 1, F = k ? 1 : D[1], O = R[0], z = k ? R[1] : R[2], V = k ? R[2] : 1, H = k ? 1 : R[1], Y = e.makeOutput(f.inShape, "float32"), le = e.dataIdMap.get(Y.dataId).id, ve = e.dataIdMap.get(i.dataId).id, re = e.dataIdMap.get(a.dataId).id;
    return Zte(ve, re, p, g, m, y, x, v, w, _, b, S, I, C, T, N, E, A, M, $, L, F, O, z, V, H, le), Y;
  }
  const oZe = {
    kernelName: ef,
    backendName: "wasm",
    setupFunc: aZe,
    kernelFunc: sZe
  };
  let Qte;
  function lZe(n) {
    Qte = n.wasm.cwrap(tf, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function uZe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l } = r;
    if (i.dtype !== "float32") throw new Error(`Tensor x must have dtype float32, got ${i.dtype}`);
    if (a.dtype !== "float32") throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);
    const u = Ra(i.shape, a.shape, s, l, o), c = t.makeOutput(u.outShape, i.dtype);
    return Qte(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(c.dataId).id, u.batchSize, u.inDepth, u.inHeight, u.inWidth, u.inChannels, u.outDepth, u.outHeight, u.outWidth, u.outChannels, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.filterDepth, u.filterHeight, u.filterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), c;
  }
  const cZe = {
    kernelName: tf,
    backendName: "wasm",
    setupFunc: lZe,
    kernelFunc: uZe
  };
  let Jte;
  function hZe(n) {
    Jte = n.wasm.cwrap(Bm, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function dZe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, pad: o, filterShape: l } = r;
    if (i.dtype !== "float32") throw new Error(`Tensor dy must have dtype float32, got ${i.dtype}`);
    if (a.dtype !== "float32") throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);
    const u = Ra(i.shape, l, s, 1, o), c = t.makeOutput(u.filterShape, a.dtype);
    return Jte(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(c.dataId).id, u.batchSize, u.inDepth, u.inHeight, u.inWidth, u.inChannels, u.outDepth, u.outHeight, u.outWidth, u.outChannels, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.filterDepth, u.filterHeight, u.filterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), c;
  }
  const fZe = {
    kernelName: Bm,
    backendName: "wasm",
    setupFunc: hZe,
    kernelFunc: dZe
  };
  let ene;
  function pZe(n) {
    ene = n.wasm.cwrap(zm, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function gZe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { pad: s, strides: o, inputShape: l } = r;
    if (i.dtype !== "float32") throw new Error(`Tensor dy must have dtype float32, got ${i.dtype}`);
    if (a.dtype !== "float32") throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);
    const u = Ra(l, a.shape, o, 1, s), c = t.makeOutput(u.inShape, i.dtype);
    return ene(t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(c.dataId).id, u.batchSize, u.inDepth, u.inHeight, u.inWidth, u.inChannels, u.outDepth, u.outHeight, u.outWidth, u.outChannels, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.filterDepth, u.filterHeight, u.filterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), c;
  }
  const mZe = {
    kernelName: zm,
    backendName: "wasm",
    setupFunc: pZe,
    kernelFunc: gZe
  };
  const vZe = an(nf);
  const yZe = an(rf);
  var z$;
  (function(n) {
    n[n.bilinear = 0] = "bilinear", n[n.nearest = 1] = "nearest";
  })(z$ || (z$ = {}));
  let tne;
  function xZe(n) {
    tne = n.wasm.cwrap(Wm, null, [
      "number",
      "number",
      "number",
      "number",
      "array",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function bZe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { method: i, extrapolationValue: a, cropSize: s } = r, { image: o, boxes: l, boxInd: u } = t, c = l.shape[0], [h, d] = s, f = [
      c,
      h,
      d,
      o.shape[3]
    ];
    let p = e.dataIdMap.get(o.dataId), g;
    o.dtype !== "float32" && (g = $c({
      backend: e,
      inputs: {
        x: o
      },
      attrs: {
        dtype: "float32"
      }
    }), p = e.dataIdMap.get(g.dataId));
    const m = p.id, v = e.dataIdMap.get(l.dataId).id, y = e.dataIdMap.get(u.dataId).id, x = e.makeOutput(f, "float32"), b = e.dataIdMap.get(x.dataId).id, w = new Uint8Array(new Int32Array(o.shape).buffer);
    return tne(m, v, y, c, w, h, d, z$[i], a, b), g != null && e.disposeData(g.dataId), x;
  }
  const wZe = {
    kernelName: Wm,
    backendName: "wasm",
    setupFunc: xZe,
    kernelFunc: bZe
  };
  let nne;
  function _Ze(n) {
    nne = n.wasm.cwrap(Vm, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function SZe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, exclusive: s, reverse: o } = r, l = i.shape.length;
    B(i.dtype === "float32" || i.dtype === "int32", () => `cumprod does not support ${i.dtype} tensors in the WASM backend`);
    const u = bn([
      a
    ], l);
    let c = i;
    u !== null && (c = pc({
      inputs: {
        x: i
      },
      attrs: {
        perm: u
      },
      backend: t
    }));
    const h = gn(1, l)[0];
    Tn("cumprod", [
      h
    ], l);
    const d = t.makeOutput(c.shape, c.dtype), f = c.shape[h], p = t.dataIdMap.get(c.dataId).id, g = t.dataIdMap.get(d.dataId).id;
    nne(p, s ? 1 : 0, o ? 1 : 0, f, g, fn[i.dtype]);
    let m = d;
    if (u !== null) {
      const v = As(u);
      m = pc({
        inputs: {
          x: d
        },
        attrs: {
          perm: v
        },
        backend: t
      }), t.disposeData(c.dataId), t.disposeData(d.dataId);
    }
    return m;
  }
  const CZe = {
    kernelName: Vm,
    backendName: "wasm",
    setupFunc: _Ze,
    kernelFunc: SZe
  };
  let rne;
  function IZe(n) {
    rne = n.wasm.cwrap(af, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function kZe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, exclusive: s, reverse: o } = r, l = i.shape.length;
    B(i.dtype === "float32" || i.dtype === "int32", () => `cumsum does not support ${i.dtype} tensors in the WASM backend`);
    const u = bn([
      a
    ], l);
    let c = i;
    u !== null && (c = pc({
      inputs: {
        x: i
      },
      attrs: {
        perm: u
      },
      backend: t
    }));
    const h = gn(1, l)[0];
    Tn("cumsum", [
      h
    ], l);
    const d = t.makeOutput(c.shape, c.dtype), f = c.shape[h], p = t.dataIdMap.get(c.dataId).id, g = t.dataIdMap.get(d.dataId).id;
    rne(p, s ? 1 : 0, o ? 1 : 0, f, g, fn[i.dtype]);
    let m = d;
    if (u !== null) {
      const v = As(u);
      m = pc({
        inputs: {
          x: d
        },
        attrs: {
          perm: v
        },
        backend: t
      }), t.disposeData(c.dataId), t.disposeData(d.dataId);
    }
    return m;
  }
  const TZe = {
    kernelName: af,
    backendName: "wasm",
    setupFunc: IZe,
    kernelFunc: kZe
  };
  let ine;
  function AZe(n) {
    ine = n.wasm.cwrap("DenseBincount", null, [
      "number",
      "array",
      "number",
      "number",
      "boolean",
      "number",
      "number",
      "boolean",
      "number"
    ]);
  }
  function DZe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { x: i, weights: a } = t, { size: s, binaryOutput: o } = r, l = a.shape.reduce((d, f) => d * f, 1) !== 0, u = i.shape.length === 1 ? [
      s
    ] : [
      i.shape[0],
      s
    ], c = e.makeOutput(u, a.dtype);
    function h(d) {
      return e.dataIdMap.get(d.dataId).id;
    }
    return ine(h(i), new Uint8Array(new Int32Array(i.shape).buffer), i.shape.length, s, l, h(a), fn[a.dtype], o, h(c)), c;
  }
  const RZe = {
    kernelName: nb,
    backendName: "wasm",
    setupFunc: AZe,
    kernelFunc: DZe
  };
  let ane;
  function $Ze(n) {
    ane = n.wasm.cwrap(Gm, null, [
      "number",
      "number",
      "number",
      "array",
      "number",
      "array",
      "array",
      "number",
      "number"
    ]);
  }
  function NZe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { x: i } = t, { blockSize: a, dataFormat: s } = r, o = i.shape[0], l = s === "NHWC" ? i.shape[1] : i.shape[2], u = s === "NHWC" ? i.shape[2] : i.shape[3], c = s === "NHWC" ? i.shape[3] : i.shape[1], h = l * a, d = u * a, f = c / (a * a), p = s === "NHWC" ? [
      o,
      h,
      d,
      f
    ] : [
      o,
      f,
      h,
      d
    ], g = e.makeOutput(p, "float32"), v = e.dataIdMap.get(i.dataId).id, y = new Uint8Array(new Int32Array(Be(i.shape)).buffer), x = new Uint8Array(new Int32Array(p).buffer), b = new Uint8Array(new Int32Array(Be(p)).buffer), w = e.dataIdMap.get(g.dataId).id;
    return ane(v, a, s === "NHWC" ? 1 : 0, y, i.shape.length - 1, x, b, p.length, w), g;
  }
  const EZe = {
    kernelName: Gm,
    backendName: "wasm",
    setupFunc: $Ze,
    kernelFunc: NZe
  };
  let sne;
  function MZe(n) {
    sne = n.wasm.cwrap(sf, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function PZe(n) {
    const { inputs: e, attrs: t, backend: r } = n, { x: i, filter: a } = e, s = r.dataIdMap.get(i.dataId).id, o = r.dataIdMap.get(a.dataId).id, { strides: l, dilations: u, pad: c, dimRoundingMode: h } = t, d = u ?? [
      1,
      1
    ], f = Sn(i.shape, a.shape, l, d, c, h, true), p = f.filterHeight, g = f.filterWidth, m = f.padInfo.top, v = f.padInfo.right, y = f.padInfo.bottom, x = f.padInfo.left, b = f.dilationHeight, w = f.dilationWidth, _ = f.strideHeight, S = f.strideWidth, I = f.inChannels, C = f.outChannels, T = f.padInfo.type === "SAME" ? 1 : 0;
    if (f.dataFormat !== "channelsLast") throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);
    const k = r.makeOutput(f.outShape, "float32"), D = r.dataIdMap.get(k.dataId).id;
    return sne(s, i.shape[0], i.shape[1], i.shape[2], o, p, g, m, v, y, x, T, b, w, _, S, I, C, D), k;
  }
  const LZe = {
    kernelName: sf,
    backendName: "wasm",
    setupFunc: MZe,
    kernelFunc: PZe
  };
  let one;
  function FZe(n) {
    one = n.wasm.cwrap("Diag", null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function OZe(n) {
    const { inputs: e, backend: t } = n, { x: r } = e, i = X(r.shape), a = t.makeOutput([
      ...r.shape,
      ...r.shape
    ], r.dtype);
    return one(t.dataIdMap.get(r.dataId).id, fn[r.dtype], i, t.dataIdMap.get(a.dataId).id), a;
  }
  const BZe = {
    kernelName: aI,
    backendName: "wasm",
    setupFunc: FZe,
    kernelFunc: OZe
  };
  let lne;
  function zZe(n) {
    lne = n.wasm.cwrap(of, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function VZe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l } = r;
    if (i.dtype !== a.dtype) throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${i.dtype} and ${a.dtype}`);
    const u = po(i.shape, a.shape, s, o, "NHWC", l), c = t.makeOutput(u.outShape, i.dtype);
    return lne(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(c.dataId).id, fn[i.dtype], u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.filterHeight, u.filterWidth, u.padInfo.top, u.padInfo.left), c;
  }
  const WZe = {
    kernelName: of,
    backendName: "wasm",
    setupFunc: zZe,
    kernelFunc: VZe
  };
  let une;
  function GZe(n) {
    une = n.wasm.cwrap(Yg, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function UZe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, dy: s } = e, { strides: o, pad: l, dilations: u } = r;
    if (i.dtype !== a.dtype || i.dtype !== s.dtype) throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${i.dtype}, ${a.dtype}, and ${s.dtype}`);
    const c = po(i.shape, a.shape, o, l, "NHWC", u), h = t.makeOutput(a.shape, a.dtype);
    return une(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(s.dataId).id, t.dataIdMap.get(h.dataId).id, fn[i.dtype], c.batchSize, c.inChannels, c.inHeight, c.inWidth, c.outHeight, c.outWidth, c.strideHeight, c.strideWidth, c.dilationHeight, c.dilationWidth, c.filterHeight, c.filterWidth, c.padInfo.top, c.padInfo.left), h;
  }
  const HZe = {
    kernelName: Yg,
    backendName: "wasm",
    setupFunc: GZe,
    kernelFunc: UZe
  };
  let cne;
  function XZe(n) {
    cne = n.wasm.cwrap(Xg, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function YZe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, dy: s } = e, { strides: o, pad: l, dilations: u } = r;
    if (i.dtype !== a.dtype || i.dtype !== s.dtype) throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${i.dtype}, ${a.dtype}, and ${s.dtype}`);
    const c = po(i.shape, a.shape, o, l, "NHWC", u), h = t.makeOutput(i.shape, i.dtype);
    return cne(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(s.dataId).id, t.dataIdMap.get(h.dataId).id, fn[i.dtype], c.batchSize, c.inChannels, c.inHeight, c.inWidth, c.outHeight, c.outWidth, c.strideHeight, c.strideWidth, c.dilationHeight, c.dilationWidth, c.filterHeight, c.filterWidth, c.padInfo.top, c.padInfo.left), h;
  }
  const qZe = {
    kernelName: Xg,
    backendName: "wasm",
    setupFunc: XZe,
    kernelFunc: YZe
  };
  const jZe = an(uf);
  let hne;
  function KZe(n) {
    hne = n.wasm.cwrap(Um, null, [
      "number",
      "number",
      "number"
    ]);
  }
  function ZZe(n) {
    const { inputs: e, backend: t } = n, { dy: r, y: i } = e, a = t.makeOutput(i.shape, "float32"), s = (o) => t.dataIdMap.get(o.dataId).id;
    return hne(s(i), s(r), s(a)), a;
  }
  const QZe = {
    kernelName: Um,
    backendName: "wasm",
    setupFunc: KZe,
    kernelFunc: ZZe
  };
  const JZe = false, eQe = wr(Hm, JZe, "bool");
  const tQe = an(cf);
  const nQe = an(hf, "float32");
  function V$(n) {
    const { inputs: e, attrs: t, backend: r } = n, { input: i } = e, { dim: a } = t, s = i.shape.length, o = i.shape.slice();
    let l = a;
    return a < 0 && (B(-(s + 1) <= a, () => `Axis must be in the interval [${-(s + 1)}, ${s}]`), l = s + a + 1), o.splice(l, 0, 1), Ji({
      inputs: {
        x: i
      },
      backend: r,
      attrs: {
        shape: o
      }
    });
  }
  const rQe = {
    kernelName: Xm,
    backendName: "wasm",
    kernelFunc: V$
  };
  const iQe = an(df, "float32");
  function dne(n) {
    const { attrs: { shape: e, value: t }, backend: r } = n;
    let { attrs: { dtype: i } } = n;
    i = i || yc(t);
    const a = r.makeOutput(e, i);
    return r.typedArrayFromHeap(a).fill(t), a;
  }
  const aQe = {
    kernelName: rb,
    backendName: "wasm",
    kernelFunc: dne
  };
  let fne;
  function sQe(n) {
    fne = n.wasm.cwrap(Ym, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function oQe(n) {
    const { inputs: e, backend: t } = n, { image: r } = e, i = t.makeOutput(r.shape, r.dtype), a = t.dataIdMap.get(r.dataId).id, s = t.dataIdMap.get(i.dataId).id, [o, l, u, c] = r.shape;
    return fne(a, o, l, u, c, s), i;
  }
  const lQe = {
    kernelName: Ym,
    backendName: "wasm",
    kernelFunc: oQe,
    setupFunc: sQe
  };
  const uQe = an(ff);
  const cQe = wr(pf);
  let pne;
  function hQe(n) {
    pne = n.wasm.cwrap(gf, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function dQe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { varianceEpsilon: i } = r, { x: a, mean: s, variance: o, offset: l, scale: u } = t, c = e.dataIdMap.get(a.dataId).id, h = e.dataIdMap.get(s.dataId).id, d = e.dataIdMap.get(o.dataId).id, f = l != null ? e.dataIdMap.get(l.dataId).id : 0, p = u != null ? e.dataIdMap.get(u.dataId).id : 0, g = e.makeOutput(a.shape, a.dtype);
    if (X(a.shape) === 0) return g;
    const m = e.dataIdMap.get(g.dataId).id;
    return pne(c, h, d, f, p, i, m), g;
  }
  const fQe = {
    kernelName: gf,
    backendName: "wasm",
    setupFunc: hQe,
    kernelFunc: dQe
  };
  let gne;
  function pQe(n) {
    gne = n.wasm.cwrap(yd, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function gQe(n) {
    const { inputs: e, attrs: t, backend: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = e, { strides: l, pad: u, dilations: c, dataFormat: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = t, g = Sn(i.shape, a.shape, l, c, u, d), m = vx[f];
    if (m == null) throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);
    const v = r.dataIdMap.get(i.dataId).id, y = r.dataIdMap.get(a.dataId).id, x = g.outChannels;
    let b = 0;
    if (s != null) {
      const V = r.dataIdMap.get(s.dataId);
      if (V.shape.length !== 1) throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${V.shape.length}.`);
      if (V.shape[0] !== x) throw new Error(`FusedConv2D bias shape (${V.shape}) does not match the number of output channels (${x})`);
      b = V.id;
    }
    const w = g.filterHeight, _ = g.filterWidth, S = g.padInfo.top, I = g.padInfo.right, C = g.padInfo.bottom, T = g.padInfo.left, k = g.dilationHeight, D = g.dilationWidth, R = g.strideHeight, N = g.strideWidth, E = g.inChannels, A = g.padInfo.type === "SAME" ? 1 : 0, M = g.batchSize, $ = g.inHeight, L = g.inWidth;
    if (h !== "NHWC") throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);
    const F = r.makeOutput(g.outShape, "float32"), O = r.dataIdMap.get(F.dataId).id, z = o == null ? 0 : r.dataIdMap.get(o.dataId).id;
    return gne(v, M, $, L, y, w, _, b, S, I, C, T, A, k, D, R, N, E, x, m, z, p || 0, O), F;
  }
  const mQe = {
    kernelName: yd,
    backendName: "wasm",
    setupFunc: pQe,
    kernelFunc: gQe
  };
  let mne;
  function vQe(n) {
    mne = n.wasm.cwrap(vb, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function yQe(n) {
    const { inputs: e, attrs: t, backend: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = e, { strides: l, pad: u, dilations: c, dataFormat: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = t, g = Sn(i.shape, a.shape, l, c, u, d, true), m = vx[f];
    if (m == null) throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
    const v = r.dataIdMap.get(i.dataId).id, y = r.dataIdMap.get(a.dataId).id, x = g.outChannels;
    let b = 0;
    if (s != null) {
      const V = r.dataIdMap.get(s.dataId);
      if (V.shape.length !== 1) throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${V.shape.length}.`);
      if (V.shape[0] !== x) throw new Error(`FusedDepthwiseConv2D bias shape (${V.shape}) does not match the number of output channels (${x})`);
      b = V.id;
    }
    const w = g.filterHeight, _ = g.filterWidth, S = g.padInfo.top, I = g.padInfo.right, C = g.padInfo.bottom, T = g.padInfo.left, k = g.dilationHeight, D = g.dilationWidth, R = g.strideHeight, N = g.strideWidth, E = g.inChannels, A = g.padInfo.type === "SAME" ? 1 : 0, M = g.batchSize, $ = g.inHeight, L = g.inWidth;
    if (h !== "NHWC") throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);
    const F = r.makeOutput(g.outShape, "float32"), O = r.dataIdMap.get(F.dataId).id, z = o == null ? 0 : r.dataIdMap.get(o.dataId).id;
    return mne(v, M, $, L, y, w, _, b, S, I, C, T, A, k, D, R, N, E, x, m, z, p || 0, O), F;
  }
  const xQe = {
    kernelName: vb,
    backendName: "wasm",
    setupFunc: vQe,
    kernelFunc: yQe
  };
  let vne;
  function bQe(n) {
    vne = n.wasm.cwrap(ib, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "array",
      "number"
    ]);
  }
  function wQe(n) {
    const { backend: e, inputs: t } = n, { params: r, indices: i } = t, [a, s, o, l] = _b(r, i), u = e.makeOutput(a, r.dtype);
    if (s === 0) return u;
    const c = i.shape, h = c[c.length - 1], f = e.dataIdMap.get(r.dataId).id, g = e.dataIdMap.get(i.dataId).id, m = new Uint8Array(new Int32Array(l).buffer), v = e.dataIdMap.get(u.dataId).id;
    return vne(f, fn[r.dtype], g, s, h, o, m, v), u;
  }
  const _Qe = {
    kernelName: ib,
    backendName: "wasm",
    setupFunc: bQe,
    kernelFunc: wQe
  };
  let yne;
  function SQe(n) {
    yne = n.wasm.cwrap("Gather", null, [
      "number",
      "number",
      "array",
      "number",
      "number",
      "number",
      "array",
      "number"
    ]);
  }
  function CQe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { x: i, indices: a } = t, { axis: s, batchDims: o } = r, l = yt(s, i.shape)[0], u = e.readSync(a.dataId), c = i.shape[l];
    for (let C = 0; C < u.length; ++C) {
      const T = u[C];
      B(T <= c - 1 && T >= 0, () => `GatherV2: the index value ${T} is not in [0, ${c - 1}]`);
    }
    const h = Nb(i, a, l, o), d = Ji({
      inputs: {
        x: i
      },
      attrs: {
        shape: [
          h.batchSize,
          h.outerSize,
          h.dimSize,
          h.sliceSize
        ]
      },
      backend: e
    }), f = X(a.shape), p = Ji({
      inputs: {
        x: a
      },
      attrs: {
        shape: [
          h.batchSize,
          f / h.batchSize
        ]
      },
      backend: e
    }), g = [
      h.batchSize,
      h.outerSize,
      f / h.batchSize,
      h.sliceSize
    ], m = e.makeOutput(g, i.dtype);
    if (X(i.shape) === 0) return m;
    const v = d.shape.length - 1, x = e.dataIdMap.get(d.dataId).id, w = e.dataIdMap.get(p.dataId).id, _ = e.dataIdMap.get(m.dataId).id, S = new Uint8Array(new Int32Array(Be(d.shape)).buffer), I = new Uint8Array(new Int32Array(Be(g)).buffer);
    return yne(x, fn[i.dtype], S, v, w, h.batchSize, I, _), e.disposeData(d.dataId), e.disposeData(p.dataId), m.shape = h.outputShape, m;
  }
  const IQe = {
    kernelName: qm,
    backendName: "wasm",
    setupFunc: SQe,
    kernelFunc: CQe
  };
  const kQe = false, TQe = wr(jm, kQe, "bool");
  const AQe = false, DQe = wr(mf, AQe, "bool");
  const RQe = an(yf, "bool");
  const $Qe = an(xf, "bool");
  const NQe = an(bf, "bool");
  let xne;
  function EQe(n) {
    xne = n.wasm.cwrap(wf, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function MQe(n) {
    const { inputs: { x: e }, attrs: { alpha: t }, backend: r } = n, i = r.dataIdMap.get(e.dataId).id, a = r.makeOutput(e.shape, "float32");
    if (X(e.shape) !== 0) {
      const s = r.dataIdMap.get(a.dataId).id;
      xne(i, fn[e.dtype], t, s);
    }
    return a;
  }
  const PQe = {
    kernelName: wf,
    backendName: "wasm",
    setupFunc: EQe,
    kernelFunc: MQe
  };
  const LQe = false, FQe = wr(Km, LQe, "bool");
  const OQe = false, BQe = wr(Zm, OQe, "bool");
  let bne;
  function zQe(n) {
    bne = n.wasm.cwrap(ab, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function VQe(n) {
    const { attrs: e, backend: t } = n, { start: r, stop: i, num: a } = e, s = Math.floor(a), o = t.makeOutput([
      s
    ], "float32");
    return bne(t.dataIdMap.get(o.dataId).id, r, i, s), o;
  }
  const WQe = {
    kernelName: ab,
    backendName: "wasm",
    setupFunc: zQe,
    kernelFunc: VQe
  };
  const GQe = an(_f);
  const UQe = an(Sf);
  const HQe = false, XQe = wr(Qm, HQe, "bool");
  const YQe = an(Jm);
  const qQe = false, jQe = wr(ev, qQe, "bool");
  const KQe = false, ZQe = wr(uAe, KQe, "bool");
  let wne;
  function QQe(n) {
    wne = n.wasm.cwrap(Cf, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function JQe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { depthRadius: a, bias: s, alpha: o, beta: l } = r;
    if (i.dtype !== "float32") throw new Error("LRN error: x must have dtype float32");
    const u = t.makeOutput(i.shape, i.dtype);
    return wne(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(u.dataId).id, i.shape[3], a, s, o, l), u;
  }
  const eJe = {
    kernelName: Cf,
    backendName: "wasm",
    setupFunc: QQe,
    kernelFunc: JQe
  };
  let _ne;
  function tJe(n) {
    _ne = n.wasm.cwrap(tv, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function nJe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, y: a, dy: s } = e, { depthRadius: o, bias: l, alpha: u, beta: c } = r;
    if (i.dtype !== "float32" || a.dtype !== "float32" || s.dtype !== "float32") throw new Error("LRNGrad error: x, y, and dy must have dtype float32");
    const h = t.makeOutput(i.shape, i.dtype);
    return _ne(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(s.dataId).id, t.dataIdMap.get(h.dataId).id, s.shape[3], o, l, u, c), h;
  }
  const rJe = {
    kernelName: tv,
    backendName: "wasm",
    setupFunc: tJe,
    kernelFunc: nJe
  };
  let Sne;
  function iJe(n) {
    Sne = n.wasm.cwrap(If, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function aJe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { reductionIndices: i, keepDims: a } = r, { x: s } = t;
    let l = e.dataIdMap.get(s.dataId).id, u = s;
    const { transposed: c, axes: h, originalAxes: d, inputWasTransposed: f } = Rc(s, i, e);
    if (f) {
      const x = e.dataIdMap.get(c.dataId).id;
      u = c, l = x;
    }
    const p = u.shape.length;
    Tn("max", h, p);
    const [g, m] = Ln(u.shape, h), v = X(m), y = e.makeOutput(g, s.dtype);
    if (X(u.shape) !== 0) {
      const x = e.dataIdMap.get(y.dataId).id;
      Sne(l, fn[s.dtype], v, x);
    }
    if (f && e.disposeData(c.dataId), a) {
      const x = Mn(y.shape, d);
      y.shape = x;
    }
    return y;
  }
  const sJe = {
    kernelName: If,
    backendName: "wasm",
    setupFunc: iJe,
    kernelFunc: aJe
  };
  const oJe = wr(kf);
  let Cne;
  function lJe(n) {
    Cne = n.wasm.cwrap(Tf, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function uJe(n) {
    const { inputs: e, attrs: t, backend: r } = n, i = e.x, a = r.dataIdMap.get(i.dataId).id;
    B(i.dtype === "float32", () => `Error in MaxPool: only float32 input is supported. Got ${i.dtype}.`);
    const { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = t, c = dr(i.shape, s, o, 1, l, u), h = c.filterHeight, d = c.filterWidth, f = c.padInfo.top, p = c.padInfo.right, g = c.padInfo.bottom, m = c.padInfo.left, v = c.dilationHeight, y = c.dilationWidth, x = c.strideHeight, b = c.strideWidth, w = c.inChannels, _ = c.outChannels;
    if (c.dataFormat !== "channelsLast") throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);
    const S = r.makeOutput(c.outShape, "float32"), I = r.dataIdMap.get(S.dataId).id;
    return Cne(a, i.shape[0], i.shape[1], i.shape[2], h, d, f, p, g, m, v, y, x, b, w, _, I), S;
  }
  const cJe = {
    kernelName: Tf,
    backendName: "wasm",
    setupFunc: lJe,
    kernelFunc: uJe
  };
  let Ine;
  function hJe(n) {
    Ine = n.wasm.cwrap("MaxPool3D", null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function dJe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dimRoundingMode: l, dataFormat: u } = r, c = vi(i.shape, a, s, 1, o, l, u), h = t.makeOutput(c.outShape, i.dtype);
    return Ine(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(h.dataId).id, c.batchSize, c.inChannels, c.inDepth, c.inHeight, c.inWidth, c.outDepth, c.outHeight, c.outWidth, c.strideDepth, c.strideHeight, c.strideWidth, c.dilationDepth, c.dilationHeight, c.dilationWidth, c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.front, c.padInfo.top, c.padInfo.left), h;
  }
  const fJe = {
    kernelName: nv,
    backendName: "wasm",
    setupFunc: hJe,
    kernelFunc: dJe
  };
  let kne;
  function pJe(n) {
    kne = n.wasm.cwrap("MaxPool3DGrad", null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function gJe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = r, c = vi(a.shape, s, o, 1, l, u), h = t.makeOutput(a.shape, a.dtype);
    return kne(t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(h.dataId).id, c.batchSize, c.inChannels, c.inDepth, c.inHeight, c.inWidth, c.outDepth, c.outHeight, c.outWidth, c.strideDepth, c.strideHeight, c.strideWidth, c.dilationDepth, c.dilationHeight, c.dilationWidth, c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.front, c.padInfo.top, c.padInfo.left), h;
  }
  const mJe = {
    kernelName: ob,
    backendName: "wasm",
    setupFunc: pJe,
    kernelFunc: gJe
  };
  let Tne;
  function vJe(n) {
    Tne = n.wasm.cwrap("MaxPoolGrad", null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function yJe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, { filterSize: s, strides: o, pad: l, dimRoundingMode: u } = r, c = dr(a.shape, s, o, 1, l, u), h = t.makeOutput(a.shape, a.dtype);
    return Tne(t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(h.dataId).id, c.batchSize, c.inChannels, c.inHeight, c.inWidth, c.outHeight, c.outWidth, c.strideHeight, c.strideWidth, c.dilationHeight, c.dilationWidth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.top, c.padInfo.left), h;
  }
  const xJe = {
    kernelName: sb,
    backendName: "wasm",
    setupFunc: vJe,
    kernelFunc: yJe
  };
  let Ane;
  function bJe(n) {
    Ane = n.wasm.cwrap("MaxPoolWithArgmax", null, [
      "number",
      "number",
      "number",
      "number",
      "boolean",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function wJe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, includeBatchInIndex: l } = r;
    B(i.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);
    const u = [
      1,
      1
    ];
    B(Pr(s, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);
    const c = dr(i.shape, a, s, [
      1,
      1
    ], o), h = t.makeOutput(c.outShape, i.dtype), d = t.makeOutput(c.outShape, "int32");
    return Ane(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(h.dataId).id, t.dataIdMap.get(d.dataId).id, fn[i.dtype], l, c.batchSize, c.inChannels, c.inHeight, c.inWidth, c.outHeight, c.outWidth, c.strideHeight, c.strideWidth, c.dilationHeight, c.dilationWidth, c.effectiveFilterHeight, c.effectiveFilterWidth, c.padInfo.top, c.padInfo.left), [
      h,
      d
    ];
  }
  const _Je = {
    kernelName: cI,
    backendName: "wasm",
    setupFunc: bJe,
    kernelFunc: wJe
  };
  let Dne;
  function SJe(n) {
    Dne = n.wasm.cwrap(Af, null, [
      "number, number, number"
    ]);
  }
  function CJe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { axis: i, keepDims: a } = r, { x: s } = t, o = e.dataIdMap.get(s.dataId).id;
    let l = o, u = s;
    const { transposed: c, axes: h, originalAxes: d, inputWasTransposed: f } = Rc(s, i, e);
    let p = h;
    if (f) {
      const b = e.dataIdMap.get(c.dataId).id;
      b !== o && (u = c, l = b, p = gn(p.length, u.shape.length));
    }
    Tn("mean", p, u.shape.length);
    const [g, m] = Ln(u.shape, p), v = X(m);
    let y = u;
    u.dtype !== "float32" && (y = $c({
      backend: e,
      inputs: {
        x: u
      },
      attrs: {
        dtype: "float32"
      }
    }), l = e.dataIdMap.get(y.dataId).id);
    const x = e.makeOutput(g, "float32");
    if (X(u.shape) !== 0) {
      const b = e.dataIdMap.get(x.dataId).id;
      Dne(l, v, b);
    }
    if (f && e.disposeData(c.dataId), a) {
      const b = Mn(x.shape, d);
      x.shape = b;
    }
    return u.dtype !== "float32" && e.disposeData(y.dataId), x;
  }
  const IJe = {
    kernelName: Af,
    backendName: "wasm",
    setupFunc: SJe,
    kernelFunc: CJe
  };
  let Rne;
  function kJe(n) {
    Rne = n.wasm.cwrap(Df, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function TJe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { axis: i, keepDims: a } = r, { x: s } = t, o = e.dataIdMap.get(s.dataId).id;
    let l = o, u = s;
    const { transposed: c, axes: h, originalAxes: d, inputWasTransposed: f } = Rc(s, i, e);
    if (f) {
      const x = e.dataIdMap.get(c.dataId).id;
      x !== o && (u = c, l = x);
    }
    const p = u.shape.length;
    Tn("min", h, p);
    const [g, m] = Ln(u.shape, h), v = X(m), y = e.makeOutput(g, u.dtype);
    if (X(u.shape) !== 0) {
      const x = e.dataIdMap.get(y.dataId).id;
      Rne(l, fn[s.dtype], v, x);
    }
    if (f && e.disposeData(c.dataId), a) {
      const x = Mn(y.shape, d);
      y.shape = x;
    }
    return y;
  }
  const AJe = {
    kernelName: Df,
    backendName: "wasm",
    setupFunc: kJe,
    kernelFunc: TJe
  };
  const DJe = wr(Rf);
  var W$;
  (function(n) {
    n[n.reflect = 0] = "reflect", n[n.symmetric = 1] = "symmetric";
  })(W$ || (W$ = {}));
  let $ne;
  function RJe(n) {
    $ne = n.wasm.cwrap($f, null, [
      "number",
      "array",
      "number",
      "number",
      "array",
      "array",
      "number",
      "number"
    ]);
  }
  function $Je(n) {
    const { inputs: { x: e }, backend: t, attrs: { paddings: r, mode: i } } = n, a = r.map((p, g) => p[0] + e.shape[g] + p[1]), s = t.dataIdMap.get(e.dataId).id, o = t.makeOutput(a, e.dtype), l = t.dataIdMap.get(o.dataId).id, u = new Uint8Array(new Int32Array(e.shape).buffer), c = r.map((p) => p[0]), h = r.map((p) => p[1]), d = new Uint8Array(new Int32Array(c).buffer), f = new Uint8Array(new Int32Array(h).buffer);
    return $ne(s, u, e.shape.length, fn[e.dtype], d, f, W$[i], l), o;
  }
  const NJe = {
    kernelName: $f,
    backendName: "wasm",
    kernelFunc: $Je,
    setupFunc: RJe
  };
  let Nne;
  function EJe(n) {
    Nne = n.wasm.cwrap(tp, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function Ene(n) {
    const { backend: e, inputs: { logits: t }, attrs: { dim: r } } = n, i = e.dataIdMap.get(t.dataId).id, a = e.makeOutput(t.shape, t.dtype), s = e.dataIdMap.get(a.dataId).id, o = t.shape[r], l = X(t.shape) / o;
    return X(a.shape) === 0 || Nne(i, s, o, l), a;
  }
  const MJe = {
    kernelName: tp,
    backendName: "wasm",
    setupFunc: EJe,
    kernelFunc: Ene
  };
  let Mne;
  function PJe(n) {
    Mne = n.wasm.cwrap(lb, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function LJe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { logits: i } = e, { numSamples: a, seed: s, normalized: o } = r;
    if (i.dtype !== "float32") throw new Error(`Tensor logits must have dtype float32, got ${i.dtype}`);
    const l = o ? i : Ene({
      inputs: {
        logits: i
      },
      backend: t,
      attrs: {
        dim: i.shape.length - 1
      }
    }), [u, c] = l.shape, h = t.makeOutput([
      u,
      a
    ], "int32");
    return Mne(t.dataIdMap.get(l.dataId).id, u, c, a, s, t.dataIdMap.get(h.dataId).id), o || t.disposeData(l.dataId), h;
  }
  const FJe = {
    kernelName: lb,
    backendName: "wasm",
    setupFunc: PJe,
    kernelFunc: LJe
  };
  const OJe = wr(Nf);
  const BJe = wr(Ef);
  const zJe = an(rv);
  function PL(n, e) {
    const t = new Int32Array(n.wasm.HEAPU8.buffer, e, 4), r = t[0], i = t[1], a = t[2], s = t[3];
    return n.wasm._free(e), {
      pSelectedIndices: r,
      selectedSize: i,
      pSelectedScores: a,
      pValidOutputs: s
    };
  }
  let Pne;
  function VJe(n) {
    Pne = n.wasm.cwrap(av, "number", [
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function WJe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { iouThreshold: i, maxOutputSize: a, scoreThreshold: s } = r, { boxes: o, scores: l } = t, u = e.dataIdMap.get(o.dataId).id, c = e.dataIdMap.get(l.dataId).id, h = Pne(u, c, a, i, s), { pSelectedIndices: d, selectedSize: f, pSelectedScores: p, pValidOutputs: g } = PL(e, h);
    return e.wasm._free(p), e.wasm._free(g), e.makeOutput([
      f
    ], "int32", d);
  }
  const GJe = {
    kernelName: av,
    backendName: "wasm",
    setupFunc: VJe,
    kernelFunc: WJe
  };
  let Lne;
  function UJe(n) {
    Lne = n.wasm.cwrap(ub, "number", [
      "number",
      "number",
      "number",
      "number",
      "number",
      "bool"
    ]);
  }
  function HJe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { iouThreshold: i, maxOutputSize: a, scoreThreshold: s, padToMaxOutputSize: o } = r, { boxes: l, scores: u } = t, c = e.dataIdMap.get(l.dataId).id, h = e.dataIdMap.get(u.dataId).id, d = Lne(c, h, a, i, s, o), { pSelectedIndices: f, selectedSize: p, pSelectedScores: g, pValidOutputs: m } = PL(e, d);
    e.wasm._free(g);
    const v = e.makeOutput([
      p
    ], "int32", f), y = e.makeOutput([], "int32", m);
    return [
      v,
      y
    ];
  }
  const XJe = {
    kernelName: ub,
    backendName: "wasm",
    setupFunc: UJe,
    kernelFunc: HJe
  };
  let Fne;
  function YJe(n) {
    Fne = n.wasm.cwrap(sv, "number", [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function qJe(n) {
    const { backend: e, inputs: t, attrs: r } = n, { iouThreshold: i, maxOutputSize: a, scoreThreshold: s, softNmsSigma: o } = r, { boxes: l, scores: u } = t, c = e.dataIdMap.get(l.dataId).id, h = e.dataIdMap.get(u.dataId).id, d = Fne(c, h, a, i, s, o), { pSelectedIndices: f, selectedSize: p, pSelectedScores: g, pValidOutputs: m } = PL(e, d);
    e.wasm._free(m);
    const v = e.makeOutput([
      p
    ], "int32", f), y = e.makeOutput([
      p
    ], "float32", g);
    return [
      v,
      y
    ];
  }
  const jJe = {
    kernelName: sv,
    backendName: "wasm",
    setupFunc: YJe,
    kernelFunc: qJe
  };
  const KJe = false, ZJe = wr(iv, KJe, "bool");
  let One;
  function QJe(n) {
    One = n.wasm.cwrap(Mf, null, [
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function JJe(n) {
    const { inputs: e, backend: t, attrs: r } = n, { indices: i } = e, { dtype: a, depth: s, onValue: o, offValue: l } = r, u = t.makeOutput([
      ...i.shape,
      s
    ], a), c = t.dataIdMap.get(u.dataId).id, d = t.dataIdMap.get(i.dataId).id;
    return One(d, s, o, l, c), u;
  }
  const eet = {
    kernelName: Mf,
    backendName: "wasm",
    setupFunc: QJe,
    kernelFunc: JJe
  };
  function tet(n) {
    const { inputs: { x: e }, backend: t } = n, r = t.makeOutput(e.shape, e.dtype);
    return t.typedArrayFromHeap(r).fill(1), r;
  }
  const net = {
    kernelName: ov,
    backendName: "wasm",
    kernelFunc: tet
  };
  function ret(n) {
    const { inputs: e, backend: t, attrs: r } = n, { axis: i } = r;
    if (e.length === 1) return V$({
      inputs: {
        input: e[0]
      },
      backend: t,
      attrs: {
        dim: i
      }
    });
    const a = e[0].shape, s = e[0].dtype;
    e.forEach((c) => {
      Qx(a, c.shape, "All tensors passed to stack must have matching shapes"), B(s === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const o = [], l = e.map((c) => {
      const h = V$({
        inputs: {
          input: c
        },
        backend: t,
        attrs: {
          dim: i
        }
      });
      return o.push(h), h;
    }), u = jte({
      inputs: l,
      backend: t,
      attrs: {
        axis: i
      }
    });
    return o.forEach((c) => t.disposeData(c.dataId)), u;
  }
  const iet = {
    kernelName: lv,
    backendName: "wasm",
    kernelFunc: ret
  };
  let Bne;
  function aet(n) {
    Bne = n.wasm.cwrap(Pf, null, [
      "number",
      "array",
      "number",
      "number",
      "array",
      "array",
      "number",
      "number"
    ]);
  }
  function set(n) {
    const { inputs: { x: e }, backend: t, attrs: { paddings: r, constantValue: i } } = n, a = r.map((g, m) => g[0] + e.shape[m] + g[1]);
    if (X(e.shape) === 0) return dne({
      backend: t,
      attrs: {
        shape: a,
        value: i,
        dtype: e.dtype
      }
    });
    const s = t.dataIdMap.get(e.dataId).id, o = t.makeOutput(a, e.dtype), u = t.dataIdMap.get(o.dataId).id, c = new Uint8Array(new Int32Array(e.shape).buffer), h = r.map((g) => g[0]), d = r.map((g) => g[1]), f = new Uint8Array(new Int32Array(h).buffer), p = new Uint8Array(new Int32Array(d).buffer);
    return Bne(s, c, e.shape.length, fn[e.dtype], f, p, i, u), o;
  }
  const zne = {
    kernelName: Pf,
    backendName: "wasm",
    kernelFunc: set,
    setupFunc: aet
  };
  const oet = wr(Lf);
  let Vne;
  function uet(n) {
    Vne = n.wasm.cwrap(Ff, null, [
      "number",
      "number",
      "number"
    ]);
  }
  function cet(n) {
    const { inputs: e, backend: t } = n, { x: r, alpha: i } = e, a = t.dataIdMap.get(r.dataId).id, s = t.dataIdMap.get(i.dataId).id;
    let o = a;
    const l = r;
    let u = l;
    l.dtype !== "float32" && (u = $c({
      backend: t,
      inputs: {
        x: r
      },
      attrs: {
        dtype: "float32"
      }
    }), o = t.dataIdMap.get(u.dataId).id);
    const c = t.makeOutput(r.shape, "float32"), h = t.dataIdMap.get(c.dataId).id;
    return Vne(o, s, h), l.dtype !== "float32" && t.disposeData(u.dataId), c;
  }
  const het = {
    kernelName: Ff,
    backendName: "wasm",
    setupFunc: uet,
    kernelFunc: cet
  };
  let Wne;
  function det(n) {
    Wne = n.wasm.cwrap(Of, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function fet(n) {
    const { backend: e, inputs: t, attrs: r } = n, { axis: i, keepDims: a } = r, { x: s } = t, o = e.dataIdMap.get(s.dataId).id;
    let l = o, u = s;
    const { transposed: c, axes: h, originalAxes: d, inputWasTransposed: f } = Rc(s, i, e);
    let p = h;
    if (f) {
      const x = e.dataIdMap.get(c.dataId).id;
      x !== o && (u = c, l = x, p = gn(p.length, u.shape.length));
    }
    Tn("prod", p, u.shape.length);
    const [g, m] = Ln(u.shape, p), v = X(m), y = e.makeOutput(g, u.dtype);
    if (X(u.shape) !== 0) {
      const x = e.dataIdMap.get(y.dataId).id;
      Wne(l, v, fn[y.dtype], x);
    }
    if (f && e.disposeData(c.dataId), a) {
      const x = Mn(y.shape, d);
      y.shape = x;
    }
    return y;
  }
  const pet = {
    kernelName: Of,
    backendName: "wasm",
    setupFunc: det,
    kernelFunc: fet
  };
  const get = (n) => {
    const { backend: e, attrs: t } = n, { start: r, stop: i, step: a, dtype: s } = t, o = mL(r, i, a, s), l = e.makeOutput([
      o.length
    ], s);
    return e.typedArrayFromHeap(l).set(o), l;
  }, met = {
    kernelName: cb,
    backendName: "wasm",
    kernelFunc: get
  };
  const vet = wr(lf);
  const yet = an(Bf);
  const xet = an(zf);
  const bet = an(Gf);
  let Gne;
  function wet(n) {
    Gne = n.wasm.cwrap(Wf, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function _et(n) {
    const { backend: e, inputs: t, attrs: r } = n, { images: i } = t, { alignCorners: a, halfPixelCenters: s, size: o } = r, [l, u] = o, [c, h, d, f] = i.shape, p = [
      c,
      l,
      u,
      f
    ];
    let g = e.dataIdMap.get(i.dataId), m;
    g.dtype !== "float32" && (m = $c({
      backend: e,
      inputs: {
        x: i
      },
      attrs: {
        dtype: "float32"
      }
    }), g = e.dataIdMap.get(m.dataId));
    const v = g.id, y = e.makeOutput(p, "float32");
    if (X(i.shape) === 0) return y;
    const x = e.dataIdMap.get(y.dataId).id;
    return Gne(v, c, h, d, f, l, u, a ? 1 : 0, s ? 1 : 0, x), m != null && e.disposeData(m.dataId), y;
  }
  const Cet = {
    kernelName: Wf,
    backendName: "wasm",
    setupFunc: wet,
    kernelFunc: _et
  };
  let Une;
  function Iet(n) {
    Une = n.wasm.cwrap(hv, null, [
      "number",
      "number",
      "number",
      "array",
      "array",
      "boolean"
    ]);
  }
  function ket(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i, dy: a } = e, { alignCorners: s } = r, o = t.makeOutput(i.shape, "float32");
    let l = t.dataIdMap.get(i.dataId), u;
    return l.dtype !== "float32" && (u = $c({
      backend: t,
      inputs: {
        x: i
      },
      attrs: {
        dtype: "float32"
      }
    }), l = t.dataIdMap.get(u.dataId)), Une(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(o.dataId).id, new Uint8Array(new Int32Array(i.shape).buffer), new Uint8Array(new Int32Array(a.shape).buffer), s), u != null && t.disposeData(u.dataId), o;
  }
  const Tet = {
    kernelName: hv,
    backendName: "wasm",
    setupFunc: Iet,
    kernelFunc: ket
  };
  let Hne;
  function Aet(n) {
    Hne = n.wasm.cwrap(Vf, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function Det(n) {
    const { backend: e, inputs: t, attrs: r } = n, { images: i } = t, { alignCorners: a, halfPixelCenters: s, size: o } = r, [l, u] = o, [c, h, d, f] = i.shape, p = [
      c,
      l,
      u,
      f
    ], g = e.makeOutput(p, "float32");
    if (X(i.shape) === 0) return g;
    let m = e.dataIdMap.get(i.dataId), v;
    m.dtype !== "float32" && (v = $c({
      backend: e,
      inputs: {
        x: i
      },
      attrs: {
        dtype: "float32"
      }
    }), m = e.dataIdMap.get(v.dataId));
    const y = m.id, x = e.dataIdMap.get(g.dataId).id;
    return Hne(y, c, h, d, f, l, u, a ? 1 : 0, s ? 1 : 0, x), v != null && e.disposeData(v.dataId), g;
  }
  const Ret = {
    kernelName: Vf,
    backendName: "wasm",
    setupFunc: Aet,
    kernelFunc: Det
  };
  let Xne;
  function $et(n) {
    Xne = n.wasm.cwrap(cv, null, [
      "number",
      "number",
      "number",
      "array",
      "array",
      "boolean"
    ]);
  }
  function Net(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i, dy: a } = e, { alignCorners: s } = r, o = t.makeOutput(i.shape, "float32");
    let l = t.dataIdMap.get(i.dataId), u;
    return l.dtype !== "float32" && (u = $c({
      backend: t,
      inputs: {
        x: i
      },
      attrs: {
        dtype: "float32"
      }
    }), l = t.dataIdMap.get(u.dataId)), Xne(t.dataIdMap.get(i.dataId).id, t.dataIdMap.get(a.dataId).id, t.dataIdMap.get(o.dataId).id, new Uint8Array(new Int32Array(i.shape).buffer), new Uint8Array(new Int32Array(a.shape).buffer), s), u != null && t.disposeData(u.dataId), o;
  }
  const Eet = {
    kernelName: cv,
    backendName: "wasm",
    setupFunc: $et,
    kernelFunc: Net
  };
  let Yne;
  function Met(n) {
    Yne = n.wasm.cwrap(Uf, null, [
      "number",
      "array",
      "number",
      "array",
      "number",
      "number"
    ]);
  }
  function Pet(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { dims: a } = r, s = yt(a, i.shape);
    if (i.shape.length === 0) return u2({
      inputs: {
        x: i
      },
      backend: t
    });
    const o = t.makeOutput(i.shape, i.dtype), l = t.dataIdMap.get(i.dataId).id, u = t.dataIdMap.get(o.dataId).id, c = new Uint8Array(new Int32Array(s).buffer), h = new Uint8Array(new Int32Array(i.shape).buffer);
    Yne(l, c, s.length, h, i.shape.length, u);
    const d = Ji({
      inputs: {
        x: o
      },
      attrs: {
        shape: i.shape
      },
      backend: t
    });
    return t.disposeData(o.dataId), d;
  }
  const Let = {
    kernelName: Uf,
    backendName: "wasm",
    kernelFunc: Pet,
    setupFunc: Met
  };
  let qne;
  function Fet(n) {
    qne = n.wasm.cwrap(wv, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "array",
      "number",
      "number"
    ]);
  }
  function Oet(n) {
    const { inputs: e, backend: t, attrs: r } = n, { image: i } = e, { radians: a, fillValue: s, center: o } = r, l = t.makeOutput(i.shape, i.dtype), u = t.dataIdMap.get(i.dataId).id, c = t.dataIdMap.get(l.dataId).id, [h, d, f, p] = i.shape, [g, m] = kb(o, d, f), v = s === 0, y = 255, x = typeof s == "number" ? [
      s,
      s,
      s,
      v ? 0 : y
    ] : [
      ...s,
      y
    ], b = new Uint8Array(new Int32Array(x).buffer);
    return qne(u, h, d, f, p, a, g, m, b, x.length, c), l;
  }
  const Bet = {
    kernelName: wv,
    backendName: "wasm",
    kernelFunc: Oet,
    setupFunc: Fet
  };
  const zet = an(Hf);
  const Vet = an(Xf);
  let jne;
  function Wet(n) {
    jne = n.wasm.cwrap(hb, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "array",
      "number",
      "number"
    ]);
  }
  function Get(n) {
    const { backend: e, inputs: t, attrs: r } = n, { indices: i, updates: a } = t, { shape: s } = r, o = e.makeOutput(s, a.dtype);
    if (X(s) === 0) return o;
    const { sliceRank: l, numUpdates: u, sliceSize: c, strides: h, outputSize: d } = Ka(a, i, s), p = e.dataIdMap.get(i.dataId).id, m = e.dataIdMap.get(a.dataId).id, v = new Uint8Array(new Int32Array(h).buffer), y = e.dataIdMap.get(o.dataId).id;
    return jne(p, m, fn[a.dtype], l, u, c, v, d, y), o;
  }
  const Uet = {
    kernelName: hb,
    backendName: "wasm",
    setupFunc: Wet,
    kernelFunc: Get
  };
  let Kne;
  function Het(n) {
    Kne = n.wasm.cwrap(fb, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "bool",
      "number"
    ]);
  }
  function Xet(n) {
    const { inputs: e, backend: t, attrs: r } = n, { sortedSequence: i, values: a } = e, { side: s } = r;
    if (i.dtype !== a.dtype) throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${i.dtype} and ${a.dtype}`);
    const o = t.makeOutput(a.shape, "int32");
    function l(u) {
      return t.dataIdMap.get(u.dataId).id;
    }
    return Kne(l(i), l(a), i.shape[0], i.shape[1], a.shape[1], fn[i.dtype], s === "left", l(o)), o;
  }
  const Yet = {
    kernelName: fb,
    backendName: "wasm",
    setupFunc: Het,
    kernelFunc: Xet
  };
  let Zne;
  function qet(n) {
    Zne = n.wasm.cwrap("SelectV2", null, [
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function jet(n) {
    const { inputs: e, backend: t } = n, { condition: r, t: i, e: a } = e, s = t.dataIdMap.get(r.dataId).id, o = t.dataIdMap.get(i.dataId).id, l = t.dataIdMap.get(a.dataId).id, u = t.makeOutput(i.shape, i.dtype), c = t.dataIdMap.get(u.dataId).id, h = r.shape.length, d = i.shape.length, f = h === 0 || h > 1 || d === 1 ? 1 : X(i.shape.slice(1));
    return Zne(s, o, l, f, c), u;
  }
  const Ket = {
    kernelName: dv,
    backendName: "wasm",
    kernelFunc: jet,
    setupFunc: qet
  };
  const Zet = an(Yf);
  let Qne;
  function Qet(n) {
    Qne = n.wasm.cwrap(Zf, null, [
      "number",
      "number"
    ]);
  }
  function Jet(n) {
    const { backend: e, inputs: { x: t } } = n, r = e.dataIdMap.get(t.dataId).id, i = e.makeOutput(t.shape, t.dtype), a = e.dataIdMap.get(i.dataId).id;
    return X(i.shape) === 0 || Qne(r, a), i;
  }
  const ett = {
    kernelName: "Sigmoid",
    backendName: "wasm",
    setupFunc: Qet,
    kernelFunc: Jet
  };
  const ttt = an(Kf);
  const ntt = an(qf);
  const rtt = an(jf);
  const itt = an(Qf);
  function att(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockShape: a, paddings: s } = r, o = X(a), l = [
      [
        0,
        0
      ]
    ];
    l.push(...s);
    for (let _ = 1 + a.length; _ < i.shape.length; ++_) l.push([
      0,
      0
    ]);
    const u = zne.kernelFunc({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        paddings: l,
        constantValue: 0
      }
    }), c = ou(u.shape, a, o, false), h = lu(c.length, a.length, false), d = uu(u.shape, a, o, false), g = Ji({
      inputs: {
        x: u
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), y = pc({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        perm: h
      }
    }), w = Ji({
      inputs: {
        x: y
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    return t.disposeData(u.dataId), t.disposeData(g.dataId), t.disposeData(y.dataId), w;
  }
  const stt = {
    kernelName: pv,
    backendName: "wasm",
    kernelFunc: att
  };
  let Jne;
  function ott(n) {
    Jne = n.wasm.cwrap("SparseFillEmptyRows", "number", [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function ltt(n) {
    const { backend: e, inputs: t } = n, { indices: r, values: i, denseShape: a, defaultValue: s } = t, o = r.shape[0], l = r.shape[1], u = e.readSync(a.dataId)[0], c = [
      o + u,
      l
    ], h = e.dataIdMap.get(r.dataId).id, d = e.dataIdMap.get(i.dataId).id, f = e.dataIdMap.get(s.dataId).id, p = e.makeOutput(c, r.dtype), g = e.dataIdMap.get(p.dataId).id, m = e.makeOutput(c.slice(0, 1), i.dtype), v = e.dataIdMap.get(m.dataId).id, y = e.makeOutput([
      u
    ], "bool"), x = e.dataIdMap.get(y.dataId).id, b = e.makeOutput([
      o
    ], r.dtype), w = e.dataIdMap.get(b.dataId).id, _ = e.makeOutput([
      4
    ], "int32"), S = e.dataIdMap.get(_.dataId).id, I = Jne(h, d, fn[i.dtype], o, u, l, f, g, v, x, w, S), C = e.readSync(_.dataId);
    let T;
    switch (C[0]) {
      case 1: {
        T = RP(C[1]);
        break;
      }
      case 2: {
        T = $P(C[1], C[2]);
        break;
      }
      case 3:
        T = NP(C[1], C[2], C[3]);
        break;
      default:
        T = "";
    }
    if (e.disposeData(_.dataId), T) throw e.disposeData(p.dataId), e.disposeData(m.dataId), e.disposeData(y.dataId), e.disposeData(b.dataId), new Error(T);
    let k = p, D = m;
    return I !== c[0] && (k = $d({
      inputs: {
        x: p
      },
      attrs: {
        begin: 0,
        size: [
          I,
          l
        ]
      },
      backend: e
    }), D = $d({
      inputs: {
        x: m
      },
      attrs: {
        begin: 0,
        size: I
      },
      backend: e
    }), e.disposeData(p.dataId), e.disposeData(m.dataId)), [
      k,
      D,
      y,
      b
    ];
  }
  const utt = {
    kernelName: qM,
    backendName: "wasm",
    setupFunc: ott,
    kernelFunc: ltt
  };
  let ere;
  function ctt(n) {
    ere = n.wasm.cwrap(dI, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function htt(n) {
    const { backend: e, inputs: t } = n, { inputIndices: r, inputShape: i, newShape: a } = t;
    if (r.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);
    if (i.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);
    if (a.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${a.shape}`);
    const s = e.dataIdMap.get(r.dataId).id, o = e.dataIdMap.get(i.dataId).id, l = e.dataIdMap.get(a.dataId).id, u = r.shape[0], c = X(a.shape), h = e.makeOutput([
      u,
      c
    ], r.dtype), d = e.dataIdMap.get(h.dataId).id, f = e.makeOutput([
      c
    ], a.dtype), p = e.dataIdMap.get(f.dataId).id, g = e.makeOutput([
      3
    ], "int32"), m = e.dataIdMap.get(g.dataId).id;
    ere(s, o, l, u, d, p, m);
    const v = e.readSync(g.dataId);
    let y;
    switch (v[0]) {
      case 0: {
        y = EP(v[1], v[2]);
        break;
      }
      case 1: {
        y = MP(v[1], v[2]);
        break;
      }
      case 2:
        y = PP();
        break;
      case 3: {
        const x = Array.from(e.readSync(i.dataId)), b = Array.from(e.readSync(f.dataId));
        y = LP(x, b);
        break;
      }
      case 4: {
        const x = Array.from(e.readSync(i.dataId)), b = Array.from(e.readSync(f.dataId));
        y = FP(x, b);
        break;
      }
      default:
        y = "";
    }
    if (e.disposeData(g.dataId), y) throw e.disposeData(h.dataId), e.disposeData(f.dataId), new Error(y);
    return [
      h,
      f
    ];
  }
  const dtt = {
    kernelName: dI,
    backendName: "wasm",
    setupFunc: ctt,
    kernelFunc: htt
  };
  let tre;
  function nre(n) {
    tre = n.wasm.cwrap("SparseSegmentReduction", null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function rre(n, e) {
    const { backend: t, inputs: r } = n, { data: i, indices: a, segmentIds: s } = r, o = a.shape[0], l = t.readSync(s.dataId, o - 1, o)[0], c = o > 0 ? l + 1 : 0;
    if (c < 0) throw new Error(lx());
    const h = i.shape.slice();
    h[0] = c;
    const d = t.dataIdMap.get(i.dataId).id, f = t.dataIdMap.get(a.dataId).id, p = t.dataIdMap.get(s.dataId).id, g = t.makeOutput(h, i.dtype), m = t.dataIdMap.get(g.dataId).id, v = t.makeOutput([
      4
    ], "int32"), y = t.dataIdMap.get(v.dataId).id;
    tre(d, fn[i.dtype], i.shape[0], f, p, m, y, e, 0);
    const x = t.readSync(v.dataId);
    let b;
    switch (x[0]) {
      case 0: {
        b = lx();
        break;
      }
      case 1: {
        b = OP();
        break;
      }
      case 2:
        b = BP(x[1], x[2]);
        break;
      case 3:
        b = zP(x[1], x[2], x[3]);
        break;
      default:
        b = "";
    }
    if (t.disposeData(v.dataId), b) throw t.disposeData(g.dataId), new Error(b);
    return g;
  }
  function ftt(n) {
    return rre(n, true);
  }
  const ptt = {
    kernelName: fI,
    backendName: "wasm",
    setupFunc: nre,
    kernelFunc: ftt
  };
  function gtt(n) {
    return rre(n, false);
  }
  const mtt = {
    kernelName: pI,
    backendName: "wasm",
    setupFunc: nre,
    kernelFunc: gtt
  };
  let ire;
  function vtt(n) {
    ire = n.wasm.cwrap(pb, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "array",
      "number",
      "number"
    ]);
  }
  function ytt(n) {
    const { backend: e, inputs: t, attrs: r } = n, { sparseIndices: i, sparseValues: a, defaultValue: s } = t, { outputShape: o } = r, l = e.makeOutput(o, s.dtype);
    if (X(o) === 0) return l;
    const { sliceRank: u, numUpdates: c, sliceSize: h, strides: d, outputSize: f } = Ka(a, i, o), p = e.dataIdMap.get(i.dataId).id, g = e.dataIdMap.get(a.dataId).id, m = e.dataIdMap.get(s.dataId).id, v = new Uint8Array(new Int32Array(d).buffer), y = e.dataIdMap.get(l.dataId).id;
    return ire(p, g, a.shape.length, m, fn[s.dtype], u, c, h, v, f, y), l;
  }
  const xtt = {
    kernelName: pb,
    backendName: "wasm",
    setupFunc: vtt,
    kernelFunc: ytt
  };
  function btt(n) {
    const { inputs: e, attrs: t, backend: r } = n, { x: i } = e, { numOrSizeSplits: a, axis: s } = t, o = yt(s, i.shape)[0], l = $b(i, a, o), u = new Array(i.shape.length).fill(0), c = i.shape.slice();
    return l.map((h) => {
      const d = [
        ...c
      ];
      d[o] = h;
      const f = $d({
        inputs: {
          x: i
        },
        attrs: {
          begin: u,
          size: d
        },
        backend: r
      });
      return u[o] += h, f;
    });
  }
  const wtt = {
    kernelName: gv,
    backendName: "wasm",
    kernelFunc: btt
  };
  const _tt = an(Jf);
  const Stt = an(gb);
  const Ctt = wr(np);
  let are;
  function Itt(n) {
    are = n.wasm.cwrap(_c, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function ktt(n) {
    const { backend: e, inputs: t, attrs: r } = n, { alpha: i } = r, { x: a } = t, s = e.dataIdMap.get(a.dataId).id, o = e.makeOutput(a.shape, a.dtype), l = e.dataIdMap.get(o.dataId).id;
    return are(s, i, fn[a.dtype], l), o;
  }
  const Ttt = {
    kernelName: _c,
    backendName: "wasm",
    setupFunc: Itt,
    kernelFunc: ktt
  };
  let sre;
  function Att(n) {
    sre = n.wasm.cwrap(mv, null, [
      "number",
      "array",
      "number",
      "array",
      "array",
      "array",
      "array",
      "array",
      "number",
      "number"
    ]);
  }
  function Dtt(n) {
    const { backend: e, inputs: t, attrs: r } = n, { x: i } = t, { begin: a, end: s, strides: o, beginMask: l, endMask: u, ellipsisMask: c, newAxisMask: h, shrinkAxisMask: d } = r, { finalShapeSparse: f, finalShape: p, isIdentity: g, sliceDim0: m, isSimpleSlice: v, begin: y, end: x, strides: b } = Cb(i.shape, a, s, o, l, u, c, h, d);
    let w;
    if (g) w = Ji({
      inputs: {
        x: i
      },
      backend: e,
      attrs: {
        shape: p
      }
    });
    else if (m || v) {
      B(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
      const _ = Sb(y, x, b), S = $d({
        inputs: {
          x: i
        },
        backend: e,
        attrs: {
          begin: y,
          size: _
        }
      });
      w = Ji({
        inputs: {
          x: S
        },
        backend: e,
        attrs: {
          shape: p
        }
      }), e.disposeData(S.dataId);
    } else {
      const _ = e.makeOutput(f, "float32"), S = e.dataIdMap.get(i.dataId).id, I = new Uint8Array(new Int32Array(Be(i.shape)).buffer), C = new Uint8Array(new Int32Array(y).buffer), T = new Uint8Array(new Int32Array(x).buffer), k = new Uint8Array(new Int32Array(b).buffer), D = new Uint8Array(new Int32Array(f).buffer), R = new Uint8Array(new Int32Array(Be(f)).buffer), N = e.dataIdMap.get(_.dataId).id;
      sre(S, I, i.shape.length, C, T, k, D, R, f.length, N), w = Ji({
        inputs: {
          x: _
        },
        backend: e,
        attrs: {
          shape: p
        }
      }), e.disposeData(_.dataId);
    }
    return w;
  }
  const Rtt = {
    kernelName: mv,
    backendName: "wasm",
    setupFunc: Att,
    kernelFunc: Dtt
  };
  function $tt(n) {
    const { backend: e, inputs: t, attrs: r } = n, { data: i, dataSplits: a } = t, { separator: s, nGramWidths: o, leftPad: l, rightPad: u, padWidth: c, preserveShortSequences: h } = r, d = e.readSync(i.dataId), f = e.readSync(a.dataId), [p, g] = yL(d, f, s, o, l, u, c, h), m = e.makeOutput([
      p.length
    ], "string"), v = e.dataIdMap.get(m.dataId);
    v.stringBytes = p;
    const y = e.makeOutput(a.shape, "int32");
    return e.typedArrayFromHeap(y).set(g), [
      m,
      y
    ];
  }
  const Ntt = {
    kernelName: gI,
    backendName: "wasm",
    kernelFunc: $tt
  };
  function Ett(n) {
    const { backend: e, inputs: t, attrs: r } = n, { input: i, delimiter: a } = t, { skipEmpty: s } = r, o = e.readSync(i.dataId), l = e.readSync(a.dataId), [u, c, h] = xL(o, l[0], s), d = c.length, f = e.makeOutput([
      d,
      2
    ], "int32");
    e.typedArrayFromHeap(f).set(u);
    const g = e.makeOutput([
      d
    ], "string"), m = e.dataIdMap.get(g.dataId);
    m.stringBytes = c;
    const v = e.makeOutput([
      2
    ], "int32");
    return e.typedArrayFromHeap(v).set(h), [
      f,
      g,
      v
    ];
  }
  const Mtt = {
    kernelName: KM,
    backendName: "wasm",
    kernelFunc: Ett
  };
  function Ptt(n) {
    const { backend: e, inputs: t, attrs: r } = n, { input: i } = t, { numBuckets: a } = r, s = e.readSync(i.dataId), o = bL(s, a), l = e.makeOutput(i.shape, "int32");
    return e.typedArrayFromHeap(l).set(o), l;
  }
  const Ltt = {
    kernelName: ZM,
    backendName: "wasm",
    kernelFunc: Ptt
  };
  const Ftt = wr(rp);
  let ore;
  function Ott(n) {
    ore = n.wasm.cwrap(ep, null, [
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function Btt(n) {
    const { backend: e, inputs: t, attrs: r } = n, { axis: i, keepDims: a } = r, { x: s } = t, o = e.dataIdMap.get(s.dataId).id;
    let l = o, u = s;
    const { transposed: c, axes: h, originalAxes: d, inputWasTransposed: f } = Rc(s, i, e);
    let p = h;
    if (f) {
      const x = e.dataIdMap.get(c.dataId).id;
      x !== o && (u = c, l = x, p = gn(p.length, u.shape.length));
    }
    Tn("sum", p, u.shape.length);
    const [g, m] = Ln(u.shape, p), v = X(m), y = e.makeOutput(g, u.dtype);
    if (X(u.shape) !== 0) {
      const x = e.dataIdMap.get(y.dataId).id;
      ore(l, v, fn[y.dtype], x);
    }
    if (f && e.disposeData(c.dataId), a) {
      const x = Mn(y.shape, d);
      y.shape = x;
    }
    return y;
  }
  const ztt = {
    kernelName: ep,
    backendName: "wasm",
    setupFunc: Ott,
    kernelFunc: Btt
  };
  const Vtt = an(ip);
  const Wtt = an(ap);
  let lre;
  function Gtt(n) {
    lre = n.wasm.cwrap(db, null, [
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "array",
      "number",
      "number",
      "number"
    ]);
  }
  function Utt(n) {
    const { backend: e, inputs: t, attrs: r } = n, { tensor: i, indices: a, updates: s } = t, o = e.makeOutput(i.shape, i.dtype);
    if (X(i.shape) === 0) return o;
    const { sliceRank: l, numUpdates: u, sliceSize: c, strides: h, outputSize: d } = Ka(s, a, i.shape), p = e.dataIdMap.get(a.dataId).id, m = e.dataIdMap.get(s.dataId).id, y = e.dataIdMap.get(i.dataId).id, x = new Uint8Array(new Int32Array(h).buffer), b = e.dataIdMap.get(o.dataId).id;
    return lre(p, m, fn[s.dtype], l, u, c, x, d, b, y), o;
  }
  const Htt = {
    kernelName: db,
    backendName: "wasm",
    setupFunc: Gtt,
    kernelFunc: Utt
  };
  let ure;
  function Xtt(n) {
    ure = n.wasm.cwrap(wc, null, [
      "number",
      "array",
      "number",
      "array",
      "number",
      "number"
    ]);
  }
  function Ytt(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, a = t.dataIdMap.get(i.dataId).id, { reps: s } = r, o = new Array(i.shape.length);
    for (let d = 0; d < o.length; d++) o[d] = i.shape[d] * s[d];
    const l = new Uint8Array(new Int32Array(i.shape).buffer), u = new Uint8Array(new Int32Array(o).buffer), c = t.makeOutput(o, i.dtype), h = t.dataIdMap.get(c.dataId).id;
    return ure(a, l, i.shape.length, u, o.length, fn[c.dtype], h), c;
  }
  const qtt = {
    kernelName: wc,
    backendName: "wasm",
    setupFunc: Xtt,
    kernelFunc: Ytt
  };
  let cre;
  function jtt(n) {
    cre = n.wasm.cwrap(vv, null, [
      "number",
      "array",
      "number",
      "number",
      "number",
      "bool",
      "number",
      "number"
    ]);
  }
  const Ktt = ({ inputs: n, backend: e, attrs: t }) => {
    const { x: r } = n, { k: i, sorted: a } = t, s = e.dataIdMap.get(r.dataId).id, o = new Uint8Array(new Int32Array(r.shape).buffer), l = r.shape.slice();
    l[l.length - 1] = i;
    const u = e.makeOutput(l, r.dtype), c = e.dataIdMap.get(u.dataId).id, h = e.makeOutput(l, "int32"), d = e.dataIdMap.get(h.dataId).id;
    return cre(s, o, r.shape.length, fn[r.dtype], i, a, c, d), [
      u,
      h
    ];
  }, Ztt = {
    kernelName: vv,
    backendName: "wasm",
    setupFunc: jtt,
    kernelFunc: Ktt
  };
  let hre;
  function Qtt(n) {
    hre = n.wasm.cwrap(yv, null, [
      "number",
      "number",
      "bool",
      "number",
      "number",
      "number",
      "number",
      "number",
      "number",
      "array",
      "number",
      "array",
      "number",
      "number",
      "number",
      "number",
      "number"
    ]);
  }
  function Jtt(n) {
    const { backend: e, inputs: t, attrs: r } = n, { image: i, transforms: a } = t, { interpolation: s, fillMode: o, fillValue: l, outputShape: u } = r, [c, h, d, f] = i.shape, [p, g] = u ?? [
      h,
      d
    ], m = [
      c,
      p,
      g,
      f
    ], v = new Uint8Array(new Int32Array(Be(i.shape)).buffer), y = new Uint8Array(new Int32Array(Be(m)).buffer), x = e.makeOutput(m, i.dtype), b = e.dataIdMap.get(x.dataId).id, _ = e.dataIdMap.get(i.dataId).id, I = e.dataIdMap.get(a.dataId).id, C = s === "nearest" ? 1 : 2;
    let T;
    switch (o) {
      case "constant":
        T = 1;
        break;
      case "reflect":
        T = 2;
        break;
      case "wrap":
        T = 3;
        break;
      case "nearest":
        T = 4;
        break;
      default:
        T = 1;
        break;
    }
    return hre(_, I, a.shape[0] > 1, c, p, g, f, d, h, v, i.shape.length - 1, y, m.length - 1, C, T, l, b), x;
  }
  const ent = {
    kernelName: yv,
    backendName: "wasm",
    setupFunc: Qtt,
    kernelFunc: Jtt
  };
  function tnt(n) {
    const { inputs: e, attrs: t, backend: r } = n, { axis: i } = t, { x: a } = e, { outputValues: s, outputShape: o, indices: l } = _L(r.readSync(a.dataId), i, a.shape, a.dtype);
    return [
      r.makeOutput(o, a.dtype, void 0, s),
      r.makeOutput([
        l.length
      ], "int32", void 0, l)
    ];
  }
  const nnt = {
    kernelName: mI,
    backendName: "wasm",
    kernelFunc: tnt
  };
  function rnt(n) {
    const { inputs: e, backend: t, attrs: r } = n, { value: i } = e;
    let { axis: a } = r;
    a < 0 && (a += i.shape.length);
    const s = i.shape[a], o = i.shape.length, l = new Array(o - 1);
    let u = 0;
    for (let f = 0; f < o; f++) f !== a && (l[u++] = i.shape[f]);
    const c = new Array(s), h = new Array(o).fill(0), d = i.shape.slice();
    d[a] = 1;
    for (let f = 0; f < c.length; f++) h[a] = f, c[f] = $d({
      inputs: {
        x: i
      },
      attrs: {
        begin: h,
        size: d
      },
      backend: t
    });
    return c.map(({ dataId: f, dtype: p }) => ({
      dataId: f,
      dtype: p,
      shape: l
    }));
  }
  const int = {
    kernelName: xv,
    backendName: "wasm",
    kernelFunc: rnt
  };
  function ant(n) {
    const { inputs: { x: e }, backend: t } = n, r = t.makeOutput(e.shape, e.dtype);
    return t.typedArrayFromHeap(r).fill(0), r;
  }
  const snt = {
    kernelName: bv,
    backendName: "wasm",
    kernelFunc: ant
  };
  const ont = [
    K7e,
    Z7e,
    Q7e,
    J7e,
    e9e,
    r9e,
    h9e,
    p9e,
    g9e,
    m9e,
    v9e,
    y9e,
    x9e,
    b9e,
    w9e,
    C9e,
    E9e,
    T9e,
    R9e,
    F9e,
    G9e,
    X9e,
    Y9e,
    j9e,
    K9e,
    Z9e,
    eZe,
    tZe,
    iZe,
    oZe,
    cZe,
    fZe,
    mZe,
    vZe,
    yZe,
    wZe,
    CZe,
    TZe,
    RZe,
    EZe,
    LZe,
    BZe,
    WZe,
    HZe,
    qZe,
    jZe,
    QZe,
    eQe,
    tQe,
    nQe,
    rQe,
    iQe,
    aQe,
    lQe,
    uQe,
    cQe,
    fQe,
    mQe,
    xQe,
    _Qe,
    IQe,
    TQe,
    DQe,
    i9e,
    RQe,
    $Qe,
    NQe,
    PQe,
    FQe,
    BQe,
    WQe,
    UQe,
    GQe,
    XQe,
    YQe,
    jQe,
    ZQe,
    eJe,
    rJe,
    sJe,
    oJe,
    cJe,
    fJe,
    mJe,
    xJe,
    _Je,
    IJe,
    AJe,
    DJe,
    NJe,
    FJe,
    OJe,
    BJe,
    zJe,
    GJe,
    XJe,
    jJe,
    ZJe,
    eet,
    net,
    iet,
    zne,
    oet,
    het,
    pet,
    met,
    vet,
    yet,
    xet,
    bet,
    M9e,
    Cet,
    Tet,
    Ret,
    Eet,
    Let,
    Bet,
    zet,
    Vet,
    Uet,
    Yet,
    Ket,
    Zet,
    ett,
    ttt,
    ntt,
    rtt,
    V9e,
    MJe,
    itt,
    stt,
    utt,
    dtt,
    ptt,
    mtt,
    xtt,
    wtt,
    _tt,
    Stt,
    Ctt,
    Ttt,
    Rtt,
    Ntt,
    Mtt,
    Ltt,
    Ftt,
    ztt,
    Vtt,
    Wtt,
    Htt,
    qtt,
    Ztt,
    ent,
    l9e,
    nnt,
    int,
    snt
  ];
  for (const n of ont) vI(n);
  const G$ = ne();
  G$.registerFlag("WASM_HAS_SIMD_SUPPORT", async () => {
    try {
      return WebAssembly.validate(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        4,
        1,
        96,
        0,
        0,
        3,
        2,
        1,
        0,
        10,
        9,
        1,
        7,
        0,
        65,
        0,
        253,
        15,
        26,
        11
      ]));
    } catch {
      return false;
    }
  });
  G$.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT", async () => {
    if (G$.get("IS_NODE")) return false;
    try {
      return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        4,
        1,
        96,
        0,
        0,
        3,
        2,
        1,
        0,
        5,
        4,
        1,
        3,
        1,
        1,
        10,
        11,
        1,
        9,
        0,
        65,
        0,
        254,
        16,
        2,
        0,
        26,
        11
      ]));
    } catch {
      return false;
    }
  });
  var wA = {
    exports: {}
  }, XU;
  function lnt() {
    return XU || (XU = 1, function(n, e) {
      var t = (() => {
        var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
        return typeof __filename < "u" && (r = r || __filename), function(i) {
          i = i || {};
          function a() {
            return $.buffer != re && Re($.buffer), ae;
          }
          function s() {
            return $.buffer != re && Re($.buffer), fe;
          }
          function o() {
            return $.buffer != re && Re($.buffer), ce;
          }
          function l() {
            return $.buffer != re && Re($.buffer), ye;
          }
          function u() {
            return $.buffer != re && Re($.buffer), Le;
          }
          var c = typeof i < "u" ? i : {}, h, d;
          c.ready = new Promise(function(W, ie) {
            h = W, d = ie;
          });
          var f;
          typeof process < "u" && process.listeners && (f = {
            uncaughtException: process.listeners("uncaughtException"),
            unhandledRejection: process.listeners("unhandledRejection")
          });
          var p = Object.assign({}, c), g = (W, ie) => {
            throw ie;
          }, m = typeof window == "object", v = typeof importScripts == "function", y = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", x = c.ENVIRONMENT_IS_PTHREAD || false, b = "";
          function w(W) {
            return c.locateFile ? c.locateFile(W, b) : b + W;
          }
          var _, S, I;
          function C(W) {
            if (W instanceof pl) return;
            E("exiting due to exception: " + W);
          }
          if (y) {
            var T = $u, k = $u;
            v ? b = k.dirname(b) + "/" : b = __dirname + "/", _ = (ie, Te) => (ie = du(ie) ? new URL(ie) : k.normalize(ie), T.readFileSync(ie, Te ? void 0 : "utf8")), I = (ie) => {
              var Te = _(ie, true);
              return Te.buffer || (Te = new Uint8Array(Te)), Te;
            }, S = (ie, Te, xt) => {
              ie = du(ie) ? new URL(ie) : k.normalize(ie), T.readFile(ie, function(Pt, Ot) {
                Pt ? xt(Pt) : Te(Ot.buffer);
              });
            }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(ie) {
              if (!(ie instanceof pl)) throw ie;
            }), process.on("unhandledRejection", function(ie) {
              throw ie;
            }), g = (ie, Te) => {
              if (ge()) throw process.exitCode = ie, Te;
              C(Te), process.exit(ie);
            }, c.inspect = function() {
              return "[Emscripten Module object]";
            };
            let W;
            try {
              W = $u;
            } catch (ie) {
              throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), ie;
            }
            o4.Worker = W.Worker;
          } else (m || v) && (v ? b = self.location.href : typeof document < "u" && document.currentScript && (b = document.currentScript.src), typeof r < "u" && r && (b = r), b.indexOf("blob:") !== 0 ? b = b.substr(0, b.replace(/[?#].*/, "").lastIndexOf("/") + 1) : b = "", y || (_ = (W) => {
            var ie = new XMLHttpRequest();
            return ie.open("GET", W, false), ie.send(null), ie.responseText;
          }, v && (I = (W) => {
            var ie = new XMLHttpRequest();
            return ie.open("GET", W, false), ie.responseType = "arraybuffer", ie.send(null), new Uint8Array(ie.response);
          }), S = (W, ie, Te) => {
            var xt = new XMLHttpRequest();
            xt.open("GET", W, true), xt.responseType = "arraybuffer", xt.onload = () => {
              if (xt.status == 200 || xt.status == 0 && xt.response) {
                ie(xt.response);
                return;
              }
              Te();
            }, xt.onerror = Te, xt.send(null);
          }));
          y && typeof performance > "u" && (o4.performance = $u.performance);
          var D = console.log.bind(console), R = console.warn.bind(console);
          y && (D = (W) => T.writeSync(1, W + `
`), R = (W) => T.writeSync(2, W + `
`));
          var N = c.print || D, E = c.printErr || R;
          Object.assign(c, p), p = null, c.arguments && c.arguments, c.thisProgram && c.thisProgram, c.quit && (g = c.quit);
          var A;
          c.wasmBinary && (A = c.wasmBinary);
          var M = c.noExitRuntime || true;
          typeof WebAssembly != "object" && Na("no native wasm support detected");
          var $, L, F = false, O;
          function z(W, ie) {
            W || Na(ie);
          }
          var V = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
          function H(W, ie, Te) {
            ie >>>= 0;
            for (var xt = ie + Te, Pt = ie; W[Pt] && !(Pt >= xt); ) ++Pt;
            if (Pt - ie > 16 && W.buffer && V) return V.decode(W.buffer instanceof SharedArrayBuffer ? W.slice(ie, Pt) : W.subarray(ie, Pt));
            for (var Ot = ""; ie < Pt; ) {
              var Ue = W[ie++];
              if (!(Ue & 128)) {
                Ot += String.fromCharCode(Ue);
                continue;
              }
              var at = W[ie++] & 63;
              if ((Ue & 224) == 192) {
                Ot += String.fromCharCode((Ue & 31) << 6 | at);
                continue;
              }
              var er = W[ie++] & 63;
              if ((Ue & 240) == 224 ? Ue = (Ue & 15) << 12 | at << 6 | er : Ue = (Ue & 7) << 18 | at << 12 | er << 6 | W[ie++] & 63, Ue < 65536) Ot += String.fromCharCode(Ue);
              else {
                var Ma = Ue - 65536;
                Ot += String.fromCharCode(55296 | Ma >> 10, 56320 | Ma & 1023);
              }
            }
            return Ot;
          }
          function Y(W, ie) {
            return W >>>= 0, W ? H(s(), W, ie) : "";
          }
          function le(W, ie, Te, xt) {
            if (Te >>>= 0, !(xt > 0)) return 0;
            for (var Pt = Te, Ot = Te + xt - 1, Ue = 0; Ue < W.length; ++Ue) {
              var at = W.charCodeAt(Ue);
              if (at >= 55296 && at <= 57343) {
                var er = W.charCodeAt(++Ue);
                at = 65536 + ((at & 1023) << 10) | er & 1023;
              }
              if (at <= 127) {
                if (Te >= Ot) break;
                ie[Te++ >>> 0] = at;
              } else if (at <= 2047) {
                if (Te + 1 >= Ot) break;
                ie[Te++ >>> 0] = 192 | at >> 6, ie[Te++ >>> 0] = 128 | at & 63;
              } else if (at <= 65535) {
                if (Te + 2 >= Ot) break;
                ie[Te++ >>> 0] = 224 | at >> 12, ie[Te++ >>> 0] = 128 | at >> 6 & 63, ie[Te++ >>> 0] = 128 | at & 63;
              } else {
                if (Te + 3 >= Ot) break;
                ie[Te++ >>> 0] = 240 | at >> 18, ie[Te++ >>> 0] = 128 | at >> 12 & 63, ie[Te++ >>> 0] = 128 | at >> 6 & 63, ie[Te++ >>> 0] = 128 | at & 63;
              }
            }
            return ie[Te >>> 0] = 0, Te - Pt;
          }
          function ve(W, ie, Te) {
            return le(W, s(), ie, Te);
          }
          var re, ae, fe, ce, ye, Le;
          x && (re = c.buffer);
          function Re(W) {
            re = W, c.HEAP8 = ae = new Int8Array(W), c.HEAP16 = new Int16Array(W), c.HEAP32 = ce = new Int32Array(W), c.HEAPU8 = fe = new Uint8Array(W), c.HEAPU16 = new Uint16Array(W), c.HEAPU32 = ye = new Uint32Array(W), c.HEAPF32 = new Float32Array(W), c.HEAPF64 = Le = new Float64Array(W);
          }
          var be = c.INITIAL_MEMORY || 16777216;
          if (x) $ = c.wasmMemory, re = c.buffer;
          else if (c.wasmMemory) $ = c.wasmMemory;
          else if ($ = new WebAssembly.Memory({
            initial: be / 65536,
            maximum: 65536,
            shared: true
          }), !($.buffer instanceof SharedArrayBuffer)) throw E("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), y && E("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");
          $ && (re = $.buffer), be = re.byteLength, Re(re);
          var xe, ot = [], G = [], q = [];
          function ge() {
            return M;
          }
          function Fe() {
            if (c.preRun) for (typeof c.preRun == "function" && (c.preRun = [
              c.preRun
            ]); c.preRun.length; ) ue(c.preRun.shift());
            zn(ot);
          }
          function Lt() {
            x || zn(G);
          }
          function dt() {
            if (!x) {
              if (c.postRun) for (typeof c.postRun == "function" && (c.postRun = [
                c.postRun
              ]); c.postRun.length; ) Ut(c.postRun.shift());
              zn(q);
            }
          }
          function ue(W) {
            ot.unshift(W);
          }
          function Se(W) {
            G.unshift(W);
          }
          function Ut(W) {
            q.unshift(W);
          }
          var Ht = 0, Jn = null;
          function ua(W) {
            Ht++, c.monitorRunDependencies && c.monitorRunDependencies(Ht);
          }
          function ca(W) {
            if (Ht--, c.monitorRunDependencies && c.monitorRunDependencies(Ht), Ht == 0 && Jn) {
              var ie = Jn;
              Jn = null, ie();
            }
          }
          function Na(W) {
            c.onAbort && c.onAbort(W), W = "Aborted(" + W + ")", E(W), F = true, O = 1, W += ". Build with -sASSERTIONS for more info.";
            var ie = new WebAssembly.RuntimeError(W);
            throw d(ie), ie;
          }
          var bp = "data:application/octet-stream;base64,";
          function yo(W) {
            return W.startsWith(bp);
          }
          function du(W) {
            return W.startsWith("file://");
          }
          var Kr;
          Kr = "tfjs-backend-wasm-threaded-simd.wasm", yo(Kr) || (Kr = w(Kr));
          function Kb(W) {
            try {
              if (W == Kr && A) return new Uint8Array(A);
              if (I) return I(W);
              throw "both async and sync fetching of the wasm failed";
            } catch (ie) {
              Na(ie);
            }
          }
          function Zb() {
            if (!A && (m || v)) {
              if (typeof fetch == "function" && !du(Kr)) return fetch(Kr, {
                credentials: "same-origin"
              }).then(function(W) {
                if (!W.ok) throw "failed to load wasm binary file at '" + Kr + "'";
                return W.arrayBuffer();
              }).catch(function() {
                return Kb(Kr);
              });
              if (S) return new Promise(function(W, ie) {
                S(Kr, function(Te) {
                  W(new Uint8Array(Te));
                }, ie);
              });
            }
            return Promise.resolve().then(function() {
              return Kb(Kr);
            });
          }
          function Qb() {
            var W = {
              env: D3,
              wasi_snapshot_preview1: D3
            };
            function ie(Ue, at) {
              var er = Ue.exports;
              if (c.asm = er, gl(c.asm._emscripten_tls_init), xe = c.asm.__indirect_function_table, Se(c.asm.__wasm_call_ctors), L = at, !x) {
                var Ma = Oe.unusedWorkers.length;
                Oe.unusedWorkers.forEach(function(ml) {
                  Oe.loadWasmModuleToWorker(ml, function() {
                    --Ma || ca();
                  });
                });
              }
            }
            x || ua();
            function Te(Ue) {
              ie(Ue.instance, Ue.module);
            }
            function xt(Ue) {
              return Zb().then(function(at) {
                return WebAssembly.instantiate(at, W);
              }).then(function(at) {
                return at;
              }).then(Ue, function(at) {
                E("failed to asynchronously prepare wasm: " + at), Na(at);
              });
            }
            function Pt() {
              return !A && typeof WebAssembly.instantiateStreaming == "function" && !yo(Kr) && !du(Kr) && !y && typeof fetch == "function" ? fetch(Kr, {
                credentials: "same-origin"
              }).then(function(Ue) {
                var at = WebAssembly.instantiateStreaming(Ue, W);
                return at.then(Te, function(er) {
                  return E("wasm streaming compile failed: " + er), E("falling back to ArrayBuffer instantiation"), xt(Te);
                });
              }) : xt(Te);
            }
            if (c.instantiateWasm) try {
              var Ot = c.instantiateWasm(W, ie);
              return Ot;
            } catch (Ue) {
              E("Module.instantiateWasm callback failed with error: " + Ue), d(Ue);
            }
            return Pt().catch(d), {};
          }
          var Jb = {};
          function pl(W) {
            this.name = "ExitStatus", this.message = "Program terminated with exit(" + W + ")", this.status = W;
          }
          function wp(W) {
            var ie = Oe.pthreads[W];
            delete Oe.pthreads[W], ie.terminate(), I2(W), Oe.runningWorkers.splice(Oe.runningWorkers.indexOf(ie), 1), ie.pthread_ptr = 0;
          }
          function e1(W) {
            var ie = Oe.pthreads[W];
            ie.postMessage({
              cmd: "cancel"
            });
          }
          function Fc(W) {
            var ie = Oe.pthreads[W];
            z(ie), Oe.returnWorkerToPool(ie);
          }
          function Oc(W) {
            var ie = Oe.getNewWorker();
            if (!ie) return 6;
            Oe.runningWorkers.push(ie), Oe.pthreads[W.pthread_ptr] = ie, ie.pthread_ptr = W.pthread_ptr;
            var Te = {
              cmd: "run",
              start_routine: W.startRoutine,
              arg: W.arg,
              pthread_ptr: W.pthread_ptr
            };
            return ie.runPthread = () => {
              y && ie.ref(), ie.postMessage(Te, W.transferList), delete ie.runPthread;
            }, ie.loaded && ie.runPthread(), 0;
          }
          function t1(W) {
            if (x) return _p(1, 1, W);
            O = W, ge() || (Oe.terminateAllThreads(), c.onExit && c.onExit(W), F = true), g(W, new pl(W));
          }
          function pe(W, ie) {
            if (O = W, !ie && x) throw Xt(W), "unwind";
            t1(W);
          }
          var ke = pe;
          function ft(W) {
            if (W instanceof pl || W == "unwind") return O;
            g(1, W);
          }
          var Oe = {
            unusedWorkers: [],
            runningWorkers: [],
            tlsInitFunctions: [],
            pthreads: {},
            init: function() {
              x ? Oe.initWorker() : Oe.initMainThread();
            },
            initMainThread: function() {
              for (var W = 8; W--; ) Oe.allocateUnusedWorker();
            },
            initWorker: function() {
              M = false;
            },
            setExitStatus: function(W) {
              O = W;
            },
            terminateAllThreads: function() {
              for (var W of Object.values(Oe.pthreads)) Oe.returnWorkerToPool(W);
              for (var W of Oe.unusedWorkers) W.terminate();
              Oe.unusedWorkers = [];
            },
            returnWorkerToPool: function(W) {
              var ie = W.pthread_ptr;
              delete Oe.pthreads[ie], Oe.unusedWorkers.push(W), Oe.runningWorkers.splice(Oe.runningWorkers.indexOf(W), 1), W.pthread_ptr = 0, y && W.unref(), I2(ie);
            },
            receiveObjectTransfer: function(W) {
            },
            threadInitTLS: function() {
              Oe.tlsInitFunctions.forEach((W) => W());
            },
            loadWasmModuleToWorker: function(W, ie) {
              W.onmessage = (Ot) => {
                var Ue = Ot.data, at = Ue.cmd;
                if (W.pthread_ptr && (Oe.currentProxiedOperationCallerThread = W.pthread_ptr), Ue.targetThread && Ue.targetThread != a1()) {
                  var er = Oe.pthreads[Ue.targetThread];
                  er ? er.postMessage(Ue, Ue.transferList) : E('Internal error! Worker sent a message "' + at + '" to target pthread ' + Ue.targetThread + ", but that thread no longer exists!"), Oe.currentProxiedOperationCallerThread = void 0;
                  return;
                }
                at === "processProxyingQueue" ? _2(Ue.queue) : at === "spawnThread" ? Oc(Ue) : at === "cleanupThread" ? Fc(Ue.thread) : at === "killThread" ? wp(Ue.thread) : at === "cancelThread" ? e1(Ue.thread) : at === "loaded" ? (W.loaded = true, y && W.unref(), ie && ie(W), W.runPthread && W.runPthread()) : at === "print" ? N("Thread " + Ue.threadId + ": " + Ue.text) : at === "printErr" ? E("Thread " + Ue.threadId + ": " + Ue.text) : at === "alert" ? alert("Thread " + Ue.threadId + ": " + Ue.text) : Ue.target === "setimmediate" ? W.postMessage(Ue) : at === "callHandler" ? c[Ue.handler](...Ue.args) : at && E("worker sent an unknown command " + at), Oe.currentProxiedOperationCallerThread = void 0;
              }, W.onerror = (Ot) => {
                var Ue = "worker sent an error!";
                throw E(Ue + " " + Ot.filename + ":" + Ot.lineno + ": " + Ot.message), Ot;
              }, y && (W.on("message", function(Ot) {
                W.onmessage({
                  data: Ot
                });
              }), W.on("error", function(Ot) {
                W.onerror(Ot);
              }), W.on("detachedExit", function() {
              }));
              var Te = [], xt = [
                "onExit",
                "onAbort",
                "print",
                "printErr"
              ];
              for (var Pt of xt) c.hasOwnProperty(Pt) && Te.push(Pt);
              W.postMessage({
                cmd: "load",
                handlers: Te,
                urlOrBlob: c.mainScriptUrlOrBlob || r,
                wasmMemory: $,
                wasmModule: L
              });
            },
            allocateUnusedWorker: function() {
              var W, ie = w("tfjs-backend-wasm-threaded-simd.worker.js");
              W = new Worker(ie), Oe.unusedWorkers.push(W);
            },
            getNewWorker: function() {
              return Oe.unusedWorkers.length == 0 && (Oe.allocateUnusedWorker(), Oe.loadWasmModuleToWorker(Oe.unusedWorkers[0])), Oe.unusedWorkers.pop();
            }
          };
          c.PThread = Oe;
          function zn(W) {
            for (; W.length > 0; ) W.shift()(c);
          }
          function qn() {
            var W = a1(), ie = o()[W + 52 >>> 2], Te = o()[W + 56 >>> 2], xt = ie - Te;
            M3(ie, xt), s1(ie);
          }
          c.establishStackSpace = qn;
          function Xt(W) {
            if (x) return _p(2, 0, W);
            try {
              ke(W);
            } catch (ie) {
              ft(ie);
            }
          }
          var Ft = [];
          function gr(W) {
            var ie = Ft[W];
            return ie || (W >= Ft.length && (Ft.length = W + 1), Ft[W] = ie = xe.get(W)), ie;
          }
          function Ea(W, ie) {
            var Te = gr(W)(ie);
            ge() ? Oe.setExitStatus(Te) : E3(Te);
          }
          c.invokeEntryPoint = Ea;
          function gl(W) {
            Oe.tlsInitFunctions.push(W);
          }
          function n1(W) {
            R3(W, !v, 1, !m), Oe.threadInitTLS();
          }
          function Wv(W) {
            x ? postMessage({
              cmd: "cleanupThread",
              thread: W
            }) : Fc(W);
          }
          function r1(W, ie, Te, xt) {
            return x ? _p(3, 1, W, ie, Te, xt) : ui(W, ie, Te, xt);
          }
          function ui(W, ie, Te, xt) {
            if (typeof SharedArrayBuffer > "u") return E("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
            var Pt = [], Ot = 0;
            if (x && (Pt.length === 0 || Ot)) return r1(W, ie, Te, xt);
            var Ue = {
              startRoutine: Te,
              pthread_ptr: W,
              arg: xt,
              transferList: Pt
            };
            return x ? (Ue.cmd = "spawnThread", postMessage(Ue, Pt), 0) : Oc(Ue);
          }
          function fu() {
            return 65536;
          }
          var i1 = true;
          function Gae() {
            return i1;
          }
          function _2(W) {
            Atomics.store(o(), W >> 2, 1), a1() && N3(W), Atomics.compareExchange(o(), W >> 2, 1, 0);
          }
          c.executeNotifiedProxyingQueue = _2;
          function Uae(W, ie, Te, xt) {
            if (W == ie) setTimeout(() => _2(xt));
            else if (x) postMessage({
              targetThread: W,
              cmd: "processProxyingQueue",
              queue: xt
            });
            else {
              var Pt = Oe.pthreads[W];
              if (!Pt) return;
              Pt.postMessage({
                cmd: "processProxyingQueue",
                queue: xt
              });
            }
            return 1;
          }
          function Hae(W, ie, Te) {
            return -1;
          }
          function Xae() {
            Na("");
          }
          function Gv(W) {
            Gv.shown || (Gv.shown = {}), Gv.shown[W] || (Gv.shown[W] = 1, y && (W = "warning: " + W), E(W));
          }
          function Yae() {
            y || v || Gv("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
          }
          function qae() {
            return Date.now();
          }
          function C3() {
            return 4294901760;
          }
          function jae() {
            return C3();
          }
          var S2;
          y ? S2 = () => {
            var W = process.hrtime();
            return W[0] * 1e3 + W[1] / 1e6;
          } : S2 = () => performance.timeOrigin + performance.now();
          function Kae(W, ie, Te) {
            s().copyWithin(W >>> 0, ie >>> 0, ie + Te >>> 0);
          }
          function Zae() {
            return y ? $u.cpus().length : navigator.hardwareConcurrency;
          }
          function Qae(W) {
            var ie = k2(), Te = W();
            return s1(ie), Te;
          }
          function _p(W, ie) {
            var Te = arguments.length - 2, xt = arguments;
            return Qae(() => {
              for (var Pt = Te, Ot = o1(Pt * 8), Ue = Ot >> 3, at = 0; at < Te; at++) {
                var er = xt[2 + at];
                u()[Ue + at >>> 0] = er;
              }
              return $3(W, Pt, Ot, ie);
            });
          }
          var C2 = [];
          function Jae(W, ie, Te) {
            C2.length = ie;
            for (var xt = Te >> 3, Pt = 0; Pt < ie; Pt++) C2[Pt] = u()[xt + Pt >>> 0];
            var Ot = W < 0, Ue = Ot ? Jb[-W - 1] : lse[W];
            return Ue.apply(null, C2);
          }
          function ese(W) {
            try {
              return $.grow(W - re.byteLength + 65535 >>> 16), Re($.buffer), 1;
            } catch {
            }
          }
          function tse(W) {
            var ie = s().length;
            if (W = W >>> 0, W <= ie) return false;
            var Te = C3();
            if (W > Te) return false;
            let xt = (er, Ma) => er + (Ma - er % Ma) % Ma;
            for (var Pt = 1; Pt <= 4; Pt *= 2) {
              var Ot = ie * (1 + 0.2 / Pt);
              Ot = Math.min(Ot, W + 100663296);
              var Ue = Math.min(Te, xt(Math.max(W, Ot), 65536)), at = ese(Ue);
              if (at) return true;
            }
            return false;
          }
          function nse() {
            throw "unwind";
          }
          function I3(W) {
            return x ? _p(4, 1, W) : 52;
          }
          function k3(W, ie, Te, xt, Pt) {
            return x ? _p(5, 1, W, ie, Te, xt, Pt) : 70;
          }
          var rse = [
            null,
            [],
            []
          ];
          function ise(W, ie) {
            var Te = rse[W];
            ie === 0 || ie === 10 ? ((W === 1 ? N : E)(H(Te, 0)), Te.length = 0) : Te.push(ie);
          }
          function T3(W, ie, Te, xt) {
            if (x) return _p(6, 1, W, ie, Te, xt);
            for (var Pt = 0, Ot = 0; Ot < Te; Ot++) {
              var Ue = l()[ie >>> 2], at = l()[ie + 4 >>> 2];
              ie += 8;
              for (var er = 0; er < at; er++) ise(W, s()[Ue + er >>> 0]);
              Pt += at;
            }
            return l()[xt >>> 2] = Pt, 0;
          }
          function A3(W) {
            var ie = c["_" + W];
            return ie;
          }
          function ase(W, ie) {
            a().set(W, ie >>> 0);
          }
          function sse(W, ie, Te, xt, Pt) {
            var Ot = {
              string: (ha) => {
                var Sp = 0;
                if (ha != null && ha !== 0) {
                  var F3 = (ha.length << 2) + 1;
                  Sp = o1(F3), ve(ha, Sp, F3);
                }
                return Sp;
              },
              array: (ha) => {
                var Sp = o1(ha.length);
                return ase(ha, Sp), Sp;
              }
            };
            function Ue(ha) {
              return ie === "string" ? Y(ha) : ie === "boolean" ? !!ha : ha;
            }
            var at = A3(W), er = [], Ma = 0;
            if (xt) for (var ml = 0; ml < xt.length; ml++) {
              var L3 = Ot[Te[ml]];
              L3 ? (Ma === 0 && (Ma = k2()), er[ml] = L3(xt[ml])) : er[ml] = xt[ml];
            }
            var T2 = at.apply(null, er);
            function cse(ha) {
              return Ma !== 0 && s1(Ma), Ue(ha);
            }
            return T2 = cse(T2), T2;
          }
          function ose(W, ie, Te, xt) {
            Te = Te || [];
            var Pt = Te.every((Ue) => Ue === "number" || Ue === "boolean"), Ot = ie !== "string";
            return Ot && Pt && !xt ? A3(W) : function() {
              return sse(W, ie, Te, arguments);
            };
          }
          Oe.init();
          var lse = [
            null,
            t1,
            Xt,
            r1,
            I3,
            k3,
            T3
          ], D3 = {
            __emscripten_init_main_thread_js: n1,
            __emscripten_thread_cleanup: Wv,
            __pthread_create_js: ui,
            _emscripten_default_pthread_stack_size: fu,
            _emscripten_get_now_is_monotonic: Gae,
            _emscripten_notify_task_queue: Uae,
            _emscripten_set_offscreencanvas_size: Hae,
            abort: Xae,
            emscripten_check_blocking_allowed: Yae,
            emscripten_date_now: qae,
            emscripten_get_heap_max: jae,
            emscripten_get_now: S2,
            emscripten_memcpy_big: Kae,
            emscripten_num_logical_cores: Zae,
            emscripten_receive_on_main_thread_js: Jae,
            emscripten_resize_heap: tse,
            emscripten_unwind_to_js_event_loop: nse,
            exit: ke,
            fd_close: I3,
            fd_seek: k3,
            fd_write: T3,
            memory: $ || c.wasmMemory
          };
          Qb(), c.___wasm_call_ctors = function() {
            return (c.___wasm_call_ctors = c.asm.__wasm_call_ctors).apply(null, arguments);
          }, c._init = function() {
            return (c._init = c.asm.init).apply(null, arguments);
          }, c._init_with_threads_count = function() {
            return (c._init_with_threads_count = c.asm.init_with_threads_count).apply(null, arguments);
          }, c._get_threads_count = function() {
            return (c._get_threads_count = c.asm.get_threads_count).apply(null, arguments);
          }, c._register_tensor = function() {
            return (c._register_tensor = c.asm.register_tensor).apply(null, arguments);
          }, c._dispose_data = function() {
            return (c._dispose_data = c.asm.dispose_data).apply(null, arguments);
          }, c._dispose = function() {
            return (c._dispose = c.asm.dispose).apply(null, arguments);
          }, c._Abs = function() {
            return (c._Abs = c.asm.Abs).apply(null, arguments);
          }, c._Acos = function() {
            return (c._Acos = c.asm.Acos).apply(null, arguments);
          }, c._Acosh = function() {
            return (c._Acosh = c.asm.Acosh).apply(null, arguments);
          }, c._Add = function() {
            return (c._Add = c.asm.Add).apply(null, arguments);
          }, c._AddN = function() {
            return (c._AddN = c.asm.AddN).apply(null, arguments);
          }, c._All = function() {
            return (c._All = c.asm.All).apply(null, arguments);
          }, c._Any = function() {
            return (c._Any = c.asm.Any).apply(null, arguments);
          }, c._ArgMax = function() {
            return (c._ArgMax = c.asm.ArgMax).apply(null, arguments);
          }, c._ArgMin = function() {
            return (c._ArgMin = c.asm.ArgMin).apply(null, arguments);
          }, c._Asin = function() {
            return (c._Asin = c.asm.Asin).apply(null, arguments);
          }, c._Asinh = function() {
            return (c._Asinh = c.asm.Asinh).apply(null, arguments);
          }, c._Atan = function() {
            return (c._Atan = c.asm.Atan).apply(null, arguments);
          }, c._Atan2 = function() {
            return (c._Atan2 = c.asm.Atan2).apply(null, arguments);
          }, c._Atanh = function() {
            return (c._Atanh = c.asm.Atanh).apply(null, arguments);
          }, c._AvgPool = function() {
            return (c._AvgPool = c.asm.AvgPool).apply(null, arguments);
          }, c._AvgPool3D = function() {
            return (c._AvgPool3D = c.asm.AvgPool3D).apply(null, arguments);
          }, c._AvgPool3DGrad = function() {
            return (c._AvgPool3DGrad = c.asm.AvgPool3DGrad).apply(null, arguments);
          }, c._AvgPoolGrad = function() {
            return (c._AvgPoolGrad = c.asm.AvgPoolGrad).apply(null, arguments);
          }, c._BatchMatMul = function() {
            return (c._BatchMatMul = c.asm.BatchMatMul).apply(null, arguments);
          }, c._Bincount = function() {
            return (c._Bincount = c.asm.Bincount).apply(null, arguments);
          }, c._BitwiseAnd = function() {
            return (c._BitwiseAnd = c.asm.BitwiseAnd).apply(null, arguments);
          }, c._Ceil = function() {
            return (c._Ceil = c.asm.Ceil).apply(null, arguments);
          }, c._ClipByValue = function() {
            return (c._ClipByValue = c.asm.ClipByValue).apply(null, arguments);
          }, c._Conv2D = function() {
            return (c._Conv2D = c.asm.Conv2D).apply(null, arguments);
          }, c._Conv2DBackpropInput = function() {
            return (c._Conv2DBackpropInput = c.asm.Conv2DBackpropInput).apply(null, arguments);
          }, c._Conv3D = function() {
            return (c._Conv3D = c.asm.Conv3D).apply(null, arguments);
          }, c._Conv3DBackpropFilterV2 = function() {
            return (c._Conv3DBackpropFilterV2 = c.asm.Conv3DBackpropFilterV2).apply(null, arguments);
          }, c._Conv3DBackpropInputV2 = function() {
            return (c._Conv3DBackpropInputV2 = c.asm.Conv3DBackpropInputV2).apply(null, arguments);
          }, c._Cos = function() {
            return (c._Cos = c.asm.Cos).apply(null, arguments);
          }, c._Cosh = function() {
            return (c._Cosh = c.asm.Cosh).apply(null, arguments);
          }, c._CropAndResize = function() {
            return (c._CropAndResize = c.asm.CropAndResize).apply(null, arguments);
          }, c._Cumprod = function() {
            return (c._Cumprod = c.asm.Cumprod).apply(null, arguments);
          }, c._Cumsum = function() {
            return (c._Cumsum = c.asm.Cumsum).apply(null, arguments);
          }, c._DenseBincount = function() {
            return (c._DenseBincount = c.asm.DenseBincount).apply(null, arguments);
          }, c._DepthToSpace = function() {
            return (c._DepthToSpace = c.asm.DepthToSpace).apply(null, arguments);
          }, c._DepthwiseConv2dNative = function() {
            return (c._DepthwiseConv2dNative = c.asm.DepthwiseConv2dNative).apply(null, arguments);
          }, c._Diag = function() {
            return (c._Diag = c.asm.Diag).apply(null, arguments);
          }, c._Dilation2D = function() {
            return (c._Dilation2D = c.asm.Dilation2D).apply(null, arguments);
          }, c._Dilation2DBackpropFilter = function() {
            return (c._Dilation2DBackpropFilter = c.asm.Dilation2DBackpropFilter).apply(null, arguments);
          }, c._Dilation2DBackpropInput = function() {
            return (c._Dilation2DBackpropInput = c.asm.Dilation2DBackpropInput).apply(null, arguments);
          }, c._Elu = function() {
            return (c._Elu = c.asm.Elu).apply(null, arguments);
          }, c._EluGrad = function() {
            return (c._EluGrad = c.asm.EluGrad).apply(null, arguments);
          }, c._Equal = function() {
            return (c._Equal = c.asm.Equal).apply(null, arguments);
          }, c._Erf = function() {
            return (c._Erf = c.asm.Erf).apply(null, arguments);
          }, c._Exp = function() {
            return (c._Exp = c.asm.Exp).apply(null, arguments);
          }, c._Expm1 = function() {
            return (c._Expm1 = c.asm.Expm1).apply(null, arguments);
          }, c._FlipLeftRight = function() {
            return (c._FlipLeftRight = c.asm.FlipLeftRight).apply(null, arguments);
          }, c._Floor = function() {
            return (c._Floor = c.asm.Floor).apply(null, arguments);
          }, c._FloorDiv = function() {
            return (c._FloorDiv = c.asm.FloorDiv).apply(null, arguments);
          }, c._FusedBatchNorm = function() {
            return (c._FusedBatchNorm = c.asm.FusedBatchNorm).apply(null, arguments);
          }, c._FusedConv2D = function() {
            return (c._FusedConv2D = c.asm.FusedConv2D).apply(null, arguments);
          }, c._FusedDepthwiseConv2D = function() {
            return (c._FusedDepthwiseConv2D = c.asm.FusedDepthwiseConv2D).apply(null, arguments);
          }, c._Gather = function() {
            return (c._Gather = c.asm.Gather).apply(null, arguments);
          }, c._GatherNd = function() {
            return (c._GatherNd = c.asm.GatherNd).apply(null, arguments);
          }, c._Greater = function() {
            return (c._Greater = c.asm.Greater).apply(null, arguments);
          }, c._GreaterEqual = function() {
            return (c._GreaterEqual = c.asm.GreaterEqual).apply(null, arguments);
          }, c._IsFinite = function() {
            return (c._IsFinite = c.asm.IsFinite).apply(null, arguments);
          }, c._IsInf = function() {
            return (c._IsInf = c.asm.IsInf).apply(null, arguments);
          }, c._IsNan = function() {
            return (c._IsNan = c.asm.IsNan).apply(null, arguments);
          }, c._LRN = function() {
            return (c._LRN = c.asm.LRN).apply(null, arguments);
          }, c._LRNGrad = function() {
            return (c._LRNGrad = c.asm.LRNGrad).apply(null, arguments);
          }, c._LeakyRelu = function() {
            return (c._LeakyRelu = c.asm.LeakyRelu).apply(null, arguments);
          }, c._Less = function() {
            return (c._Less = c.asm.Less).apply(null, arguments);
          }, c._LessEqual = function() {
            return (c._LessEqual = c.asm.LessEqual).apply(null, arguments);
          }, c._LinSpace = function() {
            return (c._LinSpace = c.asm.LinSpace).apply(null, arguments);
          }, c._Log = function() {
            return (c._Log = c.asm.Log).apply(null, arguments);
          }, c._Log1p = function() {
            return (c._Log1p = c.asm.Log1p).apply(null, arguments);
          }, c._LogicalAnd = function() {
            return (c._LogicalAnd = c.asm.LogicalAnd).apply(null, arguments);
          }, c._LogicalNot = function() {
            return (c._LogicalNot = c.asm.LogicalNot).apply(null, arguments);
          }, c._LogicalOr = function() {
            return (c._LogicalOr = c.asm.LogicalOr).apply(null, arguments);
          }, c._LogicalXor = function() {
            return (c._LogicalXor = c.asm.LogicalXor).apply(null, arguments);
          }, c._Max = function() {
            return (c._Max = c.asm.Max).apply(null, arguments);
          }, c._MaxPool = function() {
            return (c._MaxPool = c.asm.MaxPool).apply(null, arguments);
          }, c._MaxPool3D = function() {
            return (c._MaxPool3D = c.asm.MaxPool3D).apply(null, arguments);
          }, c._MaxPool3DGrad = function() {
            return (c._MaxPool3DGrad = c.asm.MaxPool3DGrad).apply(null, arguments);
          }, c._MaxPoolGrad = function() {
            return (c._MaxPoolGrad = c.asm.MaxPoolGrad).apply(null, arguments);
          }, c._MaxPoolWithArgmax = function() {
            return (c._MaxPoolWithArgmax = c.asm.MaxPoolWithArgmax).apply(null, arguments);
          }, c._Maximum = function() {
            return (c._Maximum = c.asm.Maximum).apply(null, arguments);
          }, c._Mean = function() {
            return (c._Mean = c.asm.Mean).apply(null, arguments);
          }, c._Min = function() {
            return (c._Min = c.asm.Min).apply(null, arguments);
          }, c._Minimum = function() {
            return (c._Minimum = c.asm.Minimum).apply(null, arguments);
          }, c._MirrorPad = function() {
            return (c._MirrorPad = c.asm.MirrorPad).apply(null, arguments);
          }, c._Mod = function() {
            return (c._Mod = c.asm.Mod).apply(null, arguments);
          }, c._Multinomial = function() {
            return (c._Multinomial = c.asm.Multinomial).apply(null, arguments);
          }, c._Multiply = function() {
            return (c._Multiply = c.asm.Multiply).apply(null, arguments);
          }, c._Neg = function() {
            return (c._Neg = c.asm.Neg).apply(null, arguments);
          }, c._NonMaxSuppressionV3 = function() {
            return (c._NonMaxSuppressionV3 = c.asm.NonMaxSuppressionV3).apply(null, arguments);
          }, c._NonMaxSuppressionV4 = function() {
            return (c._NonMaxSuppressionV4 = c.asm.NonMaxSuppressionV4).apply(null, arguments);
          }, c._NonMaxSuppressionV5 = function() {
            return (c._NonMaxSuppressionV5 = c.asm.NonMaxSuppressionV5).apply(null, arguments);
          }, c._NotEqual = function() {
            return (c._NotEqual = c.asm.NotEqual).apply(null, arguments);
          }, c._OneHot = function() {
            return (c._OneHot = c.asm.OneHot).apply(null, arguments);
          }, c._PadV2 = function() {
            return (c._PadV2 = c.asm.PadV2).apply(null, arguments);
          }, c._Pow = function() {
            return (c._Pow = c.asm.Pow).apply(null, arguments);
          }, c._Prelu = function() {
            return (c._Prelu = c.asm.Prelu).apply(null, arguments);
          }, c._Prod = function() {
            return (c._Prod = c.asm.Prod).apply(null, arguments);
          }, c._RealDiv = function() {
            return (c._RealDiv = c.asm.RealDiv).apply(null, arguments);
          }, c._Reciprocal = function() {
            return (c._Reciprocal = c.asm.Reciprocal).apply(null, arguments);
          }, c._Relu = function() {
            return (c._Relu = c.asm.Relu).apply(null, arguments);
          }, c._Relu6 = function() {
            return (c._Relu6 = c.asm.Relu6).apply(null, arguments);
          }, c._ResizeBilinear = function() {
            return (c._ResizeBilinear = c.asm.ResizeBilinear).apply(null, arguments);
          }, c._ResizeBilinearGrad = function() {
            return (c._ResizeBilinearGrad = c.asm.ResizeBilinearGrad).apply(null, arguments);
          }, c._ResizeNearestNeighbor = function() {
            return (c._ResizeNearestNeighbor = c.asm.ResizeNearestNeighbor).apply(null, arguments);
          }, c._ResizeNearestNeighborGrad = function() {
            return (c._ResizeNearestNeighborGrad = c.asm.ResizeNearestNeighborGrad).apply(null, arguments);
          }, c._Reverse = function() {
            return (c._Reverse = c.asm.Reverse).apply(null, arguments);
          }, c._RotateWithOffset = function() {
            return (c._RotateWithOffset = c.asm.RotateWithOffset).apply(null, arguments);
          }, c._Round = function() {
            return (c._Round = c.asm.Round).apply(null, arguments);
          }, c._Rsqrt = function() {
            return (c._Rsqrt = c.asm.Rsqrt).apply(null, arguments);
          }, c._ScatterNd = function() {
            return (c._ScatterNd = c.asm.ScatterNd).apply(null, arguments);
          }, c._SearchSorted = function() {
            return (c._SearchSorted = c.asm.SearchSorted).apply(null, arguments);
          }, c._SelectV2 = function() {
            return (c._SelectV2 = c.asm.SelectV2).apply(null, arguments);
          }, c._Selu = function() {
            return (c._Selu = c.asm.Selu).apply(null, arguments);
          }, c._Sigmoid = function() {
            return (c._Sigmoid = c.asm.Sigmoid).apply(null, arguments);
          }, c._Sign = function() {
            return (c._Sign = c.asm.Sign).apply(null, arguments);
          }, c._Sin = function() {
            return (c._Sin = c.asm.Sin).apply(null, arguments);
          }, c._Sinh = function() {
            return (c._Sinh = c.asm.Sinh).apply(null, arguments);
          }, c._Softmax = function() {
            return (c._Softmax = c.asm.Softmax).apply(null, arguments);
          }, c._Softplus = function() {
            return (c._Softplus = c.asm.Softplus).apply(null, arguments);
          }, c._SparseFillEmptyRows = function() {
            return (c._SparseFillEmptyRows = c.asm.SparseFillEmptyRows).apply(null, arguments);
          }, c._SparseReshape = function() {
            return (c._SparseReshape = c.asm.SparseReshape).apply(null, arguments);
          }, c._SparseSegmentReduction = function() {
            return (c._SparseSegmentReduction = c.asm.SparseSegmentReduction).apply(null, arguments);
          }, c._SparseToDense = function() {
            return (c._SparseToDense = c.asm.SparseToDense).apply(null, arguments);
          }, c._Sqrt = function() {
            return (c._Sqrt = c.asm.Sqrt).apply(null, arguments);
          }, c._Square = function() {
            return (c._Square = c.asm.Square).apply(null, arguments);
          }, c._SquaredDifference = function() {
            return (c._SquaredDifference = c.asm.SquaredDifference).apply(null, arguments);
          }, c._Step = function() {
            return (c._Step = c.asm.Step).apply(null, arguments);
          }, c._StridedSlice = function() {
            return (c._StridedSlice = c.asm.StridedSlice).apply(null, arguments);
          }, c._Sub = function() {
            return (c._Sub = c.asm.Sub).apply(null, arguments);
          }, c._Sum = function() {
            return (c._Sum = c.asm.Sum).apply(null, arguments);
          }, c._Tan = function() {
            return (c._Tan = c.asm.Tan).apply(null, arguments);
          }, c._Tanh = function() {
            return (c._Tanh = c.asm.Tanh).apply(null, arguments);
          }, c._TensorScatterUpdate = function() {
            return (c._TensorScatterUpdate = c.asm.TensorScatterUpdate).apply(null, arguments);
          }, c._Tile = function() {
            return (c._Tile = c.asm.Tile).apply(null, arguments);
          }, c._TopK = function() {
            return (c._TopK = c.asm.TopK).apply(null, arguments);
          }, c._Transform = function() {
            return (c._Transform = c.asm.Transform).apply(null, arguments);
          }, c._Transpose = function() {
            return (c._Transpose = c.asm.Transpose).apply(null, arguments);
          }, c.__FusedMatMul = function() {
            return (c.__FusedMatMul = c.asm._FusedMatMul).apply(null, arguments);
          }, c._malloc = function() {
            return (c._malloc = c.asm.malloc).apply(null, arguments);
          }, c._free = function() {
            return (c._free = c.asm.free).apply(null, arguments);
          }, c.__emscripten_tls_init = function() {
            return (c.__emscripten_tls_init = c.asm._emscripten_tls_init).apply(null, arguments);
          };
          var a1 = c._pthread_self = function() {
            return (a1 = c._pthread_self = c.asm.pthread_self).apply(null, arguments);
          };
          c.___errno_location = function() {
            return (c.___errno_location = c.asm.__errno_location).apply(null, arguments);
          };
          var R3 = c.__emscripten_thread_init = function() {
            return (R3 = c.__emscripten_thread_init = c.asm._emscripten_thread_init).apply(null, arguments);
          };
          c.__emscripten_thread_crashed = function() {
            return (c.__emscripten_thread_crashed = c.asm._emscripten_thread_crashed).apply(null, arguments);
          }, c._emscripten_main_thread_process_queued_calls = function() {
            return (c._emscripten_main_thread_process_queued_calls = c.asm.emscripten_main_thread_process_queued_calls).apply(null, arguments);
          }, c._emscripten_main_browser_thread_id = function() {
            return (c._emscripten_main_browser_thread_id = c.asm.emscripten_main_browser_thread_id).apply(null, arguments);
          };
          var $3 = c._emscripten_run_in_main_runtime_thread_js = function() {
            return ($3 = c._emscripten_run_in_main_runtime_thread_js = c.asm.emscripten_run_in_main_runtime_thread_js).apply(null, arguments);
          };
          c._emscripten_dispatch_to_thread_ = function() {
            return (c._emscripten_dispatch_to_thread_ = c.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
          };
          var N3 = c.__emscripten_proxy_execute_task_queue = function() {
            return (N3 = c.__emscripten_proxy_execute_task_queue = c.asm._emscripten_proxy_execute_task_queue).apply(null, arguments);
          }, I2 = c.__emscripten_thread_free_data = function() {
            return (I2 = c.__emscripten_thread_free_data = c.asm._emscripten_thread_free_data).apply(null, arguments);
          }, E3 = c.__emscripten_thread_exit = function() {
            return (E3 = c.__emscripten_thread_exit = c.asm._emscripten_thread_exit).apply(null, arguments);
          }, M3 = c._emscripten_stack_set_limits = function() {
            return (M3 = c._emscripten_stack_set_limits = c.asm.emscripten_stack_set_limits).apply(null, arguments);
          }, k2 = c.stackSave = function() {
            return (k2 = c.stackSave = c.asm.stackSave).apply(null, arguments);
          }, s1 = c.stackRestore = function() {
            return (s1 = c.stackRestore = c.asm.stackRestore).apply(null, arguments);
          }, o1 = c.stackAlloc = function() {
            return (o1 = c.stackAlloc = c.asm.stackAlloc).apply(null, arguments);
          };
          c.dynCall_iijjiiii = function() {
            return (c.dynCall_iijjiiii = c.asm.dynCall_iijjiiii).apply(null, arguments);
          }, c.dynCall_jiji = function() {
            return (c.dynCall_jiji = c.asm.dynCall_jiji).apply(null, arguments);
          }, c.keepRuntimeAlive = ge, c.wasmMemory = $, c.cwrap = ose, c.ExitStatus = pl, c.PThread = Oe;
          var l1;
          Jn = function W() {
            l1 || P3(), l1 || (Jn = W);
          };
          function P3(W) {
            if (Ht > 0) return;
            if (x) {
              h(c), Lt(), startWorker(c);
              return;
            }
            if (Fe(), Ht > 0) return;
            function ie() {
              l1 || (l1 = true, c.calledRun = true, !F && (Lt(), h(c), c.onRuntimeInitialized && c.onRuntimeInitialized(), dt()));
            }
            c.setStatus ? (c.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                c.setStatus("");
              }, 1), ie();
            }, 1)) : ie();
          }
          if (c.preInit) for (typeof c.preInit == "function" && (c.preInit = [
            c.preInit
          ]); c.preInit.length > 0; ) c.preInit.pop()();
          P3();
          var u1;
          f && (u1 = {
            uncaughtException: process.listeners("uncaughtException").filter(function(W) {
              return !f.uncaughtException.indexOf(W) > -1;
            }),
            unhandledRejection: process.listeners("unhandledRejection").filter(function(W) {
              return !f.unhandledRejection.indexOf(W) > -1;
            })
          });
          var c1;
          if (typeof WasmBackendModule < "u") c1 = WasmBackendModule;
          else if (typeof i < "u") c1 = i;
          else throw new Error("Could not find wasm module in post.js");
          if (u1) {
            var use = c1._dispose;
            c1._dispose = function() {
              use(), u1.uncaughtException.forEach(function(W) {
                process.removeListener("uncaughtException", W);
              }), u1.unhandledRejection.forEach(function(W) {
                process.removeListener("unhandledRejection", W);
              });
            };
          }
          return i.ready;
        };
      })();
      n.exports = t;
    }(wA)), wA.exports;
  }
  var dre = lnt();
  const fre = _v(dre), unt = TN({
    __proto__: null,
    default: fre
  }, [
    dre
  ]);
  var _A = {}, YU;
  function cnt() {
    return YU || (YU = 1, _A.wasmWorkerContents = `"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`), _A;
  }
  var hnt = cnt(), SA = {
    exports: {}
  }, qU;
  function dnt() {
    return qU || (qU = 1, function(n, e) {
      var t = (() => {
        var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
        return typeof __filename < "u" && (r = r || __filename), function(i) {
          i = i || {};
          var a = typeof i < "u" ? i : {}, s, o;
          a.ready = new Promise(function(pe, ke) {
            s = pe, o = ke;
          });
          var l;
          typeof process < "u" && process.listeners && (l = {
            uncaughtException: process.listeners("uncaughtException"),
            unhandledRejection: process.listeners("unhandledRejection")
          });
          var u = Object.assign({}, a), c = typeof window == "object", h = typeof importScripts == "function", d = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", f = "";
          function p(pe) {
            return a.locateFile ? a.locateFile(pe, f) : f + pe;
          }
          var g, m, v;
          if (d) {
            var y = $u, x = $u;
            h ? f = x.dirname(f) + "/" : f = __dirname + "/", g = (pe, ke) => (pe = be(pe) ? new URL(pe) : x.normalize(pe), y.readFileSync(pe, ke ? void 0 : "utf8")), v = (pe) => {
              var ke = g(pe, true);
              return ke.buffer || (ke = new Uint8Array(ke)), ke;
            }, m = (pe, ke, ft) => {
              pe = be(pe) ? new URL(pe) : x.normalize(pe), y.readFile(pe, function(Oe, zn) {
                Oe ? ft(Oe) : ke(zn.buffer);
              });
            }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(pe) {
              if (!(pe instanceof ge)) throw pe;
            }), process.on("unhandledRejection", function(pe) {
              throw pe;
            }), a.inspect = function() {
              return "[Emscripten Module object]";
            };
          } else (c || h) && (h ? f = self.location.href : typeof document < "u" && document.currentScript && (f = document.currentScript.src), r && (f = r), f.indexOf("blob:") !== 0 ? f = f.substr(0, f.replace(/[?#].*/, "").lastIndexOf("/") + 1) : f = "", g = (pe) => {
            var ke = new XMLHttpRequest();
            return ke.open("GET", pe, false), ke.send(null), ke.responseText;
          }, h && (v = (pe) => {
            var ke = new XMLHttpRequest();
            return ke.open("GET", pe, false), ke.responseType = "arraybuffer", ke.send(null), new Uint8Array(ke.response);
          }), m = (pe, ke, ft) => {
            var Oe = new XMLHttpRequest();
            Oe.open("GET", pe, true), Oe.responseType = "arraybuffer", Oe.onload = () => {
              if (Oe.status == 200 || Oe.status == 0 && Oe.response) {
                ke(Oe.response);
                return;
              }
              ft();
            }, Oe.onerror = ft, Oe.send(null);
          });
          var b = a.print || console.log.bind(console), w = a.printErr || console.warn.bind(console);
          Object.assign(a, u), u = null, a.arguments && a.arguments, a.thisProgram && a.thisProgram, a.quit && a.quit;
          var _;
          a.wasmBinary && (_ = a.wasmBinary), a.noExitRuntime, typeof WebAssembly != "object" && ye("no native wasm support detected");
          var S, I = false, C = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
          function T(pe, ke, ft) {
            ke >>>= 0;
            for (var Oe = ke + ft, zn = ke; pe[zn] && !(zn >= Oe); ) ++zn;
            if (zn - ke > 16 && pe.buffer && C) return C.decode(pe.subarray(ke, zn));
            for (var qn = ""; ke < zn; ) {
              var Xt = pe[ke++];
              if (!(Xt & 128)) {
                qn += String.fromCharCode(Xt);
                continue;
              }
              var Ft = pe[ke++] & 63;
              if ((Xt & 224) == 192) {
                qn += String.fromCharCode((Xt & 31) << 6 | Ft);
                continue;
              }
              var gr = pe[ke++] & 63;
              if ((Xt & 240) == 224 ? Xt = (Xt & 15) << 12 | Ft << 6 | gr : Xt = (Xt & 7) << 18 | Ft << 12 | gr << 6 | pe[ke++] & 63, Xt < 65536) qn += String.fromCharCode(Xt);
              else {
                var Ea = Xt - 65536;
                qn += String.fromCharCode(55296 | Ea >> 10, 56320 | Ea & 1023);
              }
            }
            return qn;
          }
          function k(pe, ke) {
            return pe >>>= 0, pe ? T(A, pe, ke) : "";
          }
          function D(pe, ke, ft, Oe) {
            if (ft >>>= 0, !(Oe > 0)) return 0;
            for (var zn = ft, qn = ft + Oe - 1, Xt = 0; Xt < pe.length; ++Xt) {
              var Ft = pe.charCodeAt(Xt);
              if (Ft >= 55296 && Ft <= 57343) {
                var gr = pe.charCodeAt(++Xt);
                Ft = 65536 + ((Ft & 1023) << 10) | gr & 1023;
              }
              if (Ft <= 127) {
                if (ft >= qn) break;
                ke[ft++ >>> 0] = Ft;
              } else if (Ft <= 2047) {
                if (ft + 1 >= qn) break;
                ke[ft++ >>> 0] = 192 | Ft >> 6, ke[ft++ >>> 0] = 128 | Ft & 63;
              } else if (Ft <= 65535) {
                if (ft + 2 >= qn) break;
                ke[ft++ >>> 0] = 224 | Ft >> 12, ke[ft++ >>> 0] = 128 | Ft >> 6 & 63, ke[ft++ >>> 0] = 128 | Ft & 63;
              } else {
                if (ft + 3 >= qn) break;
                ke[ft++ >>> 0] = 240 | Ft >> 18, ke[ft++ >>> 0] = 128 | Ft >> 12 & 63, ke[ft++ >>> 0] = 128 | Ft >> 6 & 63, ke[ft++ >>> 0] = 128 | Ft & 63;
              }
            }
            return ke[ft >>> 0] = 0, ft - zn;
          }
          function R(pe, ke, ft) {
            return D(pe, A, ke, ft);
          }
          var N, E, A, M;
          function $(pe) {
            N = pe, a.HEAP8 = E = new Int8Array(pe), a.HEAP16 = new Int16Array(pe), a.HEAP32 = new Int32Array(pe), a.HEAPU8 = A = new Uint8Array(pe), a.HEAPU16 = new Uint16Array(pe), a.HEAPU32 = M = new Uint32Array(pe), a.HEAPF32 = new Float32Array(pe), a.HEAPF64 = new Float64Array(pe);
          }
          a.INITIAL_MEMORY;
          var L = [], F = [], O = [];
          function z() {
            if (a.preRun) for (typeof a.preRun == "function" && (a.preRun = [
              a.preRun
            ]); a.preRun.length; ) Y(a.preRun.shift());
            Fe(L);
          }
          function V() {
            Fe(F);
          }
          function H() {
            if (a.postRun) for (typeof a.postRun == "function" && (a.postRun = [
              a.postRun
            ]); a.postRun.length; ) ve(a.postRun.shift());
            Fe(O);
          }
          function Y(pe) {
            L.unshift(pe);
          }
          function le(pe) {
            F.unshift(pe);
          }
          function ve(pe) {
            O.unshift(pe);
          }
          var re = 0, ae = null;
          function fe(pe) {
            re++, a.monitorRunDependencies && a.monitorRunDependencies(re);
          }
          function ce(pe) {
            if (re--, a.monitorRunDependencies && a.monitorRunDependencies(re), re == 0 && ae) {
              var ke = ae;
              ae = null, ke();
            }
          }
          function ye(pe) {
            a.onAbort && a.onAbort(pe), pe = "Aborted(" + pe + ")", w(pe), I = true, pe += ". Build with -sASSERTIONS for more info.";
            var ke = new WebAssembly.RuntimeError(pe);
            throw o(ke), ke;
          }
          var Le = "data:application/octet-stream;base64,";
          function Re(pe) {
            return pe.startsWith(Le);
          }
          function be(pe) {
            return pe.startsWith("file://");
          }
          var xe;
          xe = "tfjs-backend-wasm.wasm", Re(xe) || (xe = p(xe));
          function ot(pe) {
            try {
              if (pe == xe && _) return new Uint8Array(_);
              if (v) return v(pe);
              throw "both async and sync fetching of the wasm failed";
            } catch (ke) {
              ye(ke);
            }
          }
          function G() {
            if (!_ && (c || h)) {
              if (typeof fetch == "function" && !be(xe)) return fetch(xe, {
                credentials: "same-origin"
              }).then(function(pe) {
                if (!pe.ok) throw "failed to load wasm binary file at '" + xe + "'";
                return pe.arrayBuffer();
              }).catch(function() {
                return ot(xe);
              });
              if (m) return new Promise(function(pe, ke) {
                m(xe, function(ft) {
                  pe(new Uint8Array(ft));
                }, ke);
              });
            }
            return Promise.resolve().then(function() {
              return ot(xe);
            });
          }
          function q() {
            var pe = {
              env: Zb,
              wasi_snapshot_preview1: Zb
            };
            function ke(Xt, Ft) {
              var gr = Xt.exports;
              a.asm = gr, S = a.asm.memory, $(S.buffer), a.asm.__indirect_function_table, le(a.asm.__wasm_call_ctors), ce();
            }
            fe();
            function ft(Xt) {
              ke(Xt.instance);
            }
            function Oe(Xt) {
              return G().then(function(Ft) {
                return WebAssembly.instantiate(Ft, pe);
              }).then(function(Ft) {
                return Ft;
              }).then(Xt, function(Ft) {
                w("failed to asynchronously prepare wasm: " + Ft), ye(Ft);
              });
            }
            function zn() {
              return !_ && typeof WebAssembly.instantiateStreaming == "function" && !Re(xe) && !be(xe) && !d && typeof fetch == "function" ? fetch(xe, {
                credentials: "same-origin"
              }).then(function(Xt) {
                var Ft = WebAssembly.instantiateStreaming(Xt, pe);
                return Ft.then(ft, function(gr) {
                  return w("wasm streaming compile failed: " + gr), w("falling back to ArrayBuffer instantiation"), Oe(ft);
                });
              }) : Oe(ft);
            }
            if (a.instantiateWasm) try {
              var qn = a.instantiateWasm(pe, ke);
              return qn;
            } catch (Xt) {
              w("Module.instantiateWasm callback failed with error: " + Xt), o(Xt);
            }
            return zn().catch(o), {};
          }
          function ge(pe) {
            this.name = "ExitStatus", this.message = "Program terminated with exit(" + pe + ")", this.status = pe;
          }
          function Fe(pe) {
            for (; pe.length > 0; ) pe.shift()(a);
          }
          function Lt() {
            ye("");
          }
          function dt() {
            return 4294901760;
          }
          function ue() {
            return dt();
          }
          function Se(pe, ke, ft) {
            A.copyWithin(pe >>> 0, ke >>> 0, ke + ft >>> 0);
          }
          function Ut(pe) {
            try {
              return S.grow(pe - N.byteLength + 65535 >>> 16), $(S.buffer), 1;
            } catch {
            }
          }
          function Ht(pe) {
            var ke = A.length;
            pe = pe >>> 0;
            var ft = dt();
            if (pe > ft) return false;
            let Oe = (gr, Ea) => gr + (Ea - gr % Ea) % Ea;
            for (var zn = 1; zn <= 4; zn *= 2) {
              var qn = ke * (1 + 0.2 / zn);
              qn = Math.min(qn, pe + 100663296);
              var Xt = Math.min(ft, Oe(Math.max(pe, qn), 65536)), Ft = Ut(Xt);
              if (Ft) return true;
            }
            return false;
          }
          function Jn(pe) {
            return 52;
          }
          function ua(pe, ke, ft, Oe, zn) {
            return 70;
          }
          var ca = [
            null,
            [],
            []
          ];
          function Na(pe, ke) {
            var ft = ca[pe];
            ke === 0 || ke === 10 ? ((pe === 1 ? b : w)(T(ft, 0)), ft.length = 0) : ft.push(ke);
          }
          function bp(pe, ke, ft, Oe) {
            for (var zn = 0, qn = 0; qn < ft; qn++) {
              var Xt = M[ke >>> 2], Ft = M[ke + 4 >>> 2];
              ke += 8;
              for (var gr = 0; gr < Ft; gr++) Na(pe, A[Xt + gr >>> 0]);
              zn += Ft;
            }
            return M[Oe >>> 2] = zn, 0;
          }
          function yo(pe) {
            var ke = a["_" + pe];
            return ke;
          }
          function du(pe, ke) {
            E.set(pe, ke >>> 0);
          }
          function Kr(pe, ke, ft, Oe, zn) {
            var qn = {
              string: (ui) => {
                var fu = 0;
                if (ui != null && ui !== 0) {
                  var i1 = (ui.length << 2) + 1;
                  fu = pl(i1), R(ui, fu, i1);
                }
                return fu;
              },
              array: (ui) => {
                var fu = pl(ui.length);
                return du(ui, fu), fu;
              }
            };
            function Xt(ui) {
              return ke === "string" ? k(ui) : ke === "boolean" ? !!ui : ui;
            }
            var Ft = yo(pe), gr = [], Ea = 0;
            if (Oe) for (var gl = 0; gl < Oe.length; gl++) {
              var n1 = qn[ft[gl]];
              n1 ? (Ea === 0 && (Ea = Qb()), gr[gl] = n1(Oe[gl])) : gr[gl] = Oe[gl];
            }
            var Wv = Ft.apply(null, gr);
            function r1(ui) {
              return Ea !== 0 && Jb(Ea), Xt(ui);
            }
            return Wv = r1(Wv), Wv;
          }
          function Kb(pe, ke, ft, Oe) {
            ft = ft || [];
            var zn = ft.every((Xt) => Xt === "number" || Xt === "boolean"), qn = ke !== "string";
            return qn && zn && !Oe ? yo(pe) : function() {
              return Kr(pe, ke, ft, arguments);
            };
          }
          var Zb = {
            abort: Lt,
            emscripten_get_heap_max: ue,
            emscripten_memcpy_big: Se,
            emscripten_resize_heap: Ht,
            fd_close: Jn,
            fd_seek: ua,
            fd_write: bp
          };
          q(), a.___wasm_call_ctors = function() {
            return (a.___wasm_call_ctors = a.asm.__wasm_call_ctors).apply(null, arguments);
          }, a._init = function() {
            return (a._init = a.asm.init).apply(null, arguments);
          }, a._init_with_threads_count = function() {
            return (a._init_with_threads_count = a.asm.init_with_threads_count).apply(null, arguments);
          }, a._get_threads_count = function() {
            return (a._get_threads_count = a.asm.get_threads_count).apply(null, arguments);
          }, a._register_tensor = function() {
            return (a._register_tensor = a.asm.register_tensor).apply(null, arguments);
          }, a._dispose_data = function() {
            return (a._dispose_data = a.asm.dispose_data).apply(null, arguments);
          }, a._dispose = function() {
            return (a._dispose = a.asm.dispose).apply(null, arguments);
          }, a._Abs = function() {
            return (a._Abs = a.asm.Abs).apply(null, arguments);
          }, a._Acos = function() {
            return (a._Acos = a.asm.Acos).apply(null, arguments);
          }, a._Acosh = function() {
            return (a._Acosh = a.asm.Acosh).apply(null, arguments);
          }, a._Add = function() {
            return (a._Add = a.asm.Add).apply(null, arguments);
          }, a._AddN = function() {
            return (a._AddN = a.asm.AddN).apply(null, arguments);
          }, a._All = function() {
            return (a._All = a.asm.All).apply(null, arguments);
          }, a._Any = function() {
            return (a._Any = a.asm.Any).apply(null, arguments);
          }, a._ArgMax = function() {
            return (a._ArgMax = a.asm.ArgMax).apply(null, arguments);
          }, a._ArgMin = function() {
            return (a._ArgMin = a.asm.ArgMin).apply(null, arguments);
          }, a._Asin = function() {
            return (a._Asin = a.asm.Asin).apply(null, arguments);
          }, a._Asinh = function() {
            return (a._Asinh = a.asm.Asinh).apply(null, arguments);
          }, a._Atan = function() {
            return (a._Atan = a.asm.Atan).apply(null, arguments);
          }, a._Atan2 = function() {
            return (a._Atan2 = a.asm.Atan2).apply(null, arguments);
          }, a._Atanh = function() {
            return (a._Atanh = a.asm.Atanh).apply(null, arguments);
          }, a._AvgPool = function() {
            return (a._AvgPool = a.asm.AvgPool).apply(null, arguments);
          }, a._AvgPool3D = function() {
            return (a._AvgPool3D = a.asm.AvgPool3D).apply(null, arguments);
          }, a._AvgPool3DGrad = function() {
            return (a._AvgPool3DGrad = a.asm.AvgPool3DGrad).apply(null, arguments);
          }, a._AvgPoolGrad = function() {
            return (a._AvgPoolGrad = a.asm.AvgPoolGrad).apply(null, arguments);
          }, a._BatchMatMul = function() {
            return (a._BatchMatMul = a.asm.BatchMatMul).apply(null, arguments);
          }, a._Bincount = function() {
            return (a._Bincount = a.asm.Bincount).apply(null, arguments);
          }, a._BitwiseAnd = function() {
            return (a._BitwiseAnd = a.asm.BitwiseAnd).apply(null, arguments);
          }, a._Ceil = function() {
            return (a._Ceil = a.asm.Ceil).apply(null, arguments);
          }, a._ClipByValue = function() {
            return (a._ClipByValue = a.asm.ClipByValue).apply(null, arguments);
          }, a._Conv2D = function() {
            return (a._Conv2D = a.asm.Conv2D).apply(null, arguments);
          }, a._Conv2DBackpropInput = function() {
            return (a._Conv2DBackpropInput = a.asm.Conv2DBackpropInput).apply(null, arguments);
          }, a._Conv3D = function() {
            return (a._Conv3D = a.asm.Conv3D).apply(null, arguments);
          }, a._Conv3DBackpropFilterV2 = function() {
            return (a._Conv3DBackpropFilterV2 = a.asm.Conv3DBackpropFilterV2).apply(null, arguments);
          }, a._Conv3DBackpropInputV2 = function() {
            return (a._Conv3DBackpropInputV2 = a.asm.Conv3DBackpropInputV2).apply(null, arguments);
          }, a._Cos = function() {
            return (a._Cos = a.asm.Cos).apply(null, arguments);
          }, a._Cosh = function() {
            return (a._Cosh = a.asm.Cosh).apply(null, arguments);
          }, a._CropAndResize = function() {
            return (a._CropAndResize = a.asm.CropAndResize).apply(null, arguments);
          }, a._Cumprod = function() {
            return (a._Cumprod = a.asm.Cumprod).apply(null, arguments);
          }, a._Cumsum = function() {
            return (a._Cumsum = a.asm.Cumsum).apply(null, arguments);
          }, a._DenseBincount = function() {
            return (a._DenseBincount = a.asm.DenseBincount).apply(null, arguments);
          }, a._DepthToSpace = function() {
            return (a._DepthToSpace = a.asm.DepthToSpace).apply(null, arguments);
          }, a._DepthwiseConv2dNative = function() {
            return (a._DepthwiseConv2dNative = a.asm.DepthwiseConv2dNative).apply(null, arguments);
          }, a._Diag = function() {
            return (a._Diag = a.asm.Diag).apply(null, arguments);
          }, a._Dilation2D = function() {
            return (a._Dilation2D = a.asm.Dilation2D).apply(null, arguments);
          }, a._Dilation2DBackpropFilter = function() {
            return (a._Dilation2DBackpropFilter = a.asm.Dilation2DBackpropFilter).apply(null, arguments);
          }, a._Dilation2DBackpropInput = function() {
            return (a._Dilation2DBackpropInput = a.asm.Dilation2DBackpropInput).apply(null, arguments);
          }, a._Elu = function() {
            return (a._Elu = a.asm.Elu).apply(null, arguments);
          }, a._EluGrad = function() {
            return (a._EluGrad = a.asm.EluGrad).apply(null, arguments);
          }, a._Equal = function() {
            return (a._Equal = a.asm.Equal).apply(null, arguments);
          }, a._Erf = function() {
            return (a._Erf = a.asm.Erf).apply(null, arguments);
          }, a._Exp = function() {
            return (a._Exp = a.asm.Exp).apply(null, arguments);
          }, a._Expm1 = function() {
            return (a._Expm1 = a.asm.Expm1).apply(null, arguments);
          }, a._FlipLeftRight = function() {
            return (a._FlipLeftRight = a.asm.FlipLeftRight).apply(null, arguments);
          }, a._Floor = function() {
            return (a._Floor = a.asm.Floor).apply(null, arguments);
          }, a._FloorDiv = function() {
            return (a._FloorDiv = a.asm.FloorDiv).apply(null, arguments);
          }, a._FusedBatchNorm = function() {
            return (a._FusedBatchNorm = a.asm.FusedBatchNorm).apply(null, arguments);
          }, a._FusedConv2D = function() {
            return (a._FusedConv2D = a.asm.FusedConv2D).apply(null, arguments);
          }, a._FusedDepthwiseConv2D = function() {
            return (a._FusedDepthwiseConv2D = a.asm.FusedDepthwiseConv2D).apply(null, arguments);
          }, a._Gather = function() {
            return (a._Gather = a.asm.Gather).apply(null, arguments);
          }, a._GatherNd = function() {
            return (a._GatherNd = a.asm.GatherNd).apply(null, arguments);
          }, a._Greater = function() {
            return (a._Greater = a.asm.Greater).apply(null, arguments);
          }, a._GreaterEqual = function() {
            return (a._GreaterEqual = a.asm.GreaterEqual).apply(null, arguments);
          }, a._IsFinite = function() {
            return (a._IsFinite = a.asm.IsFinite).apply(null, arguments);
          }, a._IsInf = function() {
            return (a._IsInf = a.asm.IsInf).apply(null, arguments);
          }, a._IsNan = function() {
            return (a._IsNan = a.asm.IsNan).apply(null, arguments);
          }, a._LRN = function() {
            return (a._LRN = a.asm.LRN).apply(null, arguments);
          }, a._LRNGrad = function() {
            return (a._LRNGrad = a.asm.LRNGrad).apply(null, arguments);
          }, a._LeakyRelu = function() {
            return (a._LeakyRelu = a.asm.LeakyRelu).apply(null, arguments);
          }, a._Less = function() {
            return (a._Less = a.asm.Less).apply(null, arguments);
          }, a._LessEqual = function() {
            return (a._LessEqual = a.asm.LessEqual).apply(null, arguments);
          }, a._LinSpace = function() {
            return (a._LinSpace = a.asm.LinSpace).apply(null, arguments);
          }, a._Log = function() {
            return (a._Log = a.asm.Log).apply(null, arguments);
          }, a._Log1p = function() {
            return (a._Log1p = a.asm.Log1p).apply(null, arguments);
          }, a._LogicalAnd = function() {
            return (a._LogicalAnd = a.asm.LogicalAnd).apply(null, arguments);
          }, a._LogicalNot = function() {
            return (a._LogicalNot = a.asm.LogicalNot).apply(null, arguments);
          }, a._LogicalOr = function() {
            return (a._LogicalOr = a.asm.LogicalOr).apply(null, arguments);
          }, a._LogicalXor = function() {
            return (a._LogicalXor = a.asm.LogicalXor).apply(null, arguments);
          }, a._Max = function() {
            return (a._Max = a.asm.Max).apply(null, arguments);
          }, a._MaxPool = function() {
            return (a._MaxPool = a.asm.MaxPool).apply(null, arguments);
          }, a._MaxPool3D = function() {
            return (a._MaxPool3D = a.asm.MaxPool3D).apply(null, arguments);
          }, a._MaxPool3DGrad = function() {
            return (a._MaxPool3DGrad = a.asm.MaxPool3DGrad).apply(null, arguments);
          }, a._MaxPoolGrad = function() {
            return (a._MaxPoolGrad = a.asm.MaxPoolGrad).apply(null, arguments);
          }, a._MaxPoolWithArgmax = function() {
            return (a._MaxPoolWithArgmax = a.asm.MaxPoolWithArgmax).apply(null, arguments);
          }, a._Maximum = function() {
            return (a._Maximum = a.asm.Maximum).apply(null, arguments);
          }, a._Mean = function() {
            return (a._Mean = a.asm.Mean).apply(null, arguments);
          }, a._Min = function() {
            return (a._Min = a.asm.Min).apply(null, arguments);
          }, a._Minimum = function() {
            return (a._Minimum = a.asm.Minimum).apply(null, arguments);
          }, a._MirrorPad = function() {
            return (a._MirrorPad = a.asm.MirrorPad).apply(null, arguments);
          }, a._Mod = function() {
            return (a._Mod = a.asm.Mod).apply(null, arguments);
          }, a._Multinomial = function() {
            return (a._Multinomial = a.asm.Multinomial).apply(null, arguments);
          }, a._Multiply = function() {
            return (a._Multiply = a.asm.Multiply).apply(null, arguments);
          }, a._Neg = function() {
            return (a._Neg = a.asm.Neg).apply(null, arguments);
          }, a._NonMaxSuppressionV3 = function() {
            return (a._NonMaxSuppressionV3 = a.asm.NonMaxSuppressionV3).apply(null, arguments);
          }, a._NonMaxSuppressionV4 = function() {
            return (a._NonMaxSuppressionV4 = a.asm.NonMaxSuppressionV4).apply(null, arguments);
          }, a._NonMaxSuppressionV5 = function() {
            return (a._NonMaxSuppressionV5 = a.asm.NonMaxSuppressionV5).apply(null, arguments);
          }, a._NotEqual = function() {
            return (a._NotEqual = a.asm.NotEqual).apply(null, arguments);
          }, a._OneHot = function() {
            return (a._OneHot = a.asm.OneHot).apply(null, arguments);
          }, a._PadV2 = function() {
            return (a._PadV2 = a.asm.PadV2).apply(null, arguments);
          }, a._Pow = function() {
            return (a._Pow = a.asm.Pow).apply(null, arguments);
          }, a._Prelu = function() {
            return (a._Prelu = a.asm.Prelu).apply(null, arguments);
          }, a._Prod = function() {
            return (a._Prod = a.asm.Prod).apply(null, arguments);
          }, a._RealDiv = function() {
            return (a._RealDiv = a.asm.RealDiv).apply(null, arguments);
          }, a._Reciprocal = function() {
            return (a._Reciprocal = a.asm.Reciprocal).apply(null, arguments);
          }, a._Relu = function() {
            return (a._Relu = a.asm.Relu).apply(null, arguments);
          }, a._Relu6 = function() {
            return (a._Relu6 = a.asm.Relu6).apply(null, arguments);
          }, a._ResizeBilinear = function() {
            return (a._ResizeBilinear = a.asm.ResizeBilinear).apply(null, arguments);
          }, a._ResizeBilinearGrad = function() {
            return (a._ResizeBilinearGrad = a.asm.ResizeBilinearGrad).apply(null, arguments);
          }, a._ResizeNearestNeighbor = function() {
            return (a._ResizeNearestNeighbor = a.asm.ResizeNearestNeighbor).apply(null, arguments);
          }, a._ResizeNearestNeighborGrad = function() {
            return (a._ResizeNearestNeighborGrad = a.asm.ResizeNearestNeighborGrad).apply(null, arguments);
          }, a._Reverse = function() {
            return (a._Reverse = a.asm.Reverse).apply(null, arguments);
          }, a._RotateWithOffset = function() {
            return (a._RotateWithOffset = a.asm.RotateWithOffset).apply(null, arguments);
          }, a._Round = function() {
            return (a._Round = a.asm.Round).apply(null, arguments);
          }, a._Rsqrt = function() {
            return (a._Rsqrt = a.asm.Rsqrt).apply(null, arguments);
          }, a._ScatterNd = function() {
            return (a._ScatterNd = a.asm.ScatterNd).apply(null, arguments);
          }, a._SearchSorted = function() {
            return (a._SearchSorted = a.asm.SearchSorted).apply(null, arguments);
          }, a._SelectV2 = function() {
            return (a._SelectV2 = a.asm.SelectV2).apply(null, arguments);
          }, a._Selu = function() {
            return (a._Selu = a.asm.Selu).apply(null, arguments);
          }, a._Sigmoid = function() {
            return (a._Sigmoid = a.asm.Sigmoid).apply(null, arguments);
          }, a._Sign = function() {
            return (a._Sign = a.asm.Sign).apply(null, arguments);
          }, a._Sin = function() {
            return (a._Sin = a.asm.Sin).apply(null, arguments);
          }, a._Sinh = function() {
            return (a._Sinh = a.asm.Sinh).apply(null, arguments);
          }, a._Softmax = function() {
            return (a._Softmax = a.asm.Softmax).apply(null, arguments);
          }, a._Softplus = function() {
            return (a._Softplus = a.asm.Softplus).apply(null, arguments);
          }, a._SparseFillEmptyRows = function() {
            return (a._SparseFillEmptyRows = a.asm.SparseFillEmptyRows).apply(null, arguments);
          }, a._SparseReshape = function() {
            return (a._SparseReshape = a.asm.SparseReshape).apply(null, arguments);
          }, a._SparseSegmentReduction = function() {
            return (a._SparseSegmentReduction = a.asm.SparseSegmentReduction).apply(null, arguments);
          }, a._SparseToDense = function() {
            return (a._SparseToDense = a.asm.SparseToDense).apply(null, arguments);
          }, a._Sqrt = function() {
            return (a._Sqrt = a.asm.Sqrt).apply(null, arguments);
          }, a._Square = function() {
            return (a._Square = a.asm.Square).apply(null, arguments);
          }, a._SquaredDifference = function() {
            return (a._SquaredDifference = a.asm.SquaredDifference).apply(null, arguments);
          }, a._Step = function() {
            return (a._Step = a.asm.Step).apply(null, arguments);
          }, a._StridedSlice = function() {
            return (a._StridedSlice = a.asm.StridedSlice).apply(null, arguments);
          }, a._Sub = function() {
            return (a._Sub = a.asm.Sub).apply(null, arguments);
          }, a._Sum = function() {
            return (a._Sum = a.asm.Sum).apply(null, arguments);
          }, a._Tan = function() {
            return (a._Tan = a.asm.Tan).apply(null, arguments);
          }, a._Tanh = function() {
            return (a._Tanh = a.asm.Tanh).apply(null, arguments);
          }, a._TensorScatterUpdate = function() {
            return (a._TensorScatterUpdate = a.asm.TensorScatterUpdate).apply(null, arguments);
          }, a._Tile = function() {
            return (a._Tile = a.asm.Tile).apply(null, arguments);
          }, a._TopK = function() {
            return (a._TopK = a.asm.TopK).apply(null, arguments);
          }, a._Transform = function() {
            return (a._Transform = a.asm.Transform).apply(null, arguments);
          }, a._Transpose = function() {
            return (a._Transpose = a.asm.Transpose).apply(null, arguments);
          }, a.__FusedMatMul = function() {
            return (a.__FusedMatMul = a.asm._FusedMatMul).apply(null, arguments);
          }, a._malloc = function() {
            return (a._malloc = a.asm.malloc).apply(null, arguments);
          }, a._free = function() {
            return (a._free = a.asm.free).apply(null, arguments);
          }, a.___errno_location = function() {
            return (a.___errno_location = a.asm.__errno_location).apply(null, arguments);
          };
          var Qb = a.stackSave = function() {
            return (Qb = a.stackSave = a.asm.stackSave).apply(null, arguments);
          }, Jb = a.stackRestore = function() {
            return (Jb = a.stackRestore = a.asm.stackRestore).apply(null, arguments);
          }, pl = a.stackAlloc = function() {
            return (pl = a.stackAlloc = a.asm.stackAlloc).apply(null, arguments);
          };
          a.dynCall_iijjiiii = function() {
            return (a.dynCall_iijjiiii = a.asm.dynCall_iijjiiii).apply(null, arguments);
          }, a.dynCall_jiji = function() {
            return (a.dynCall_jiji = a.asm.dynCall_jiji).apply(null, arguments);
          }, a.cwrap = Kb;
          var wp;
          ae = function pe() {
            wp || e1(), wp || (ae = pe);
          };
          function e1(pe) {
            if (re > 0 || (z(), re > 0)) return;
            function ke() {
              wp || (wp = true, a.calledRun = true, !I && (V(), s(a), a.onRuntimeInitialized && a.onRuntimeInitialized(), H()));
            }
            a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                a.setStatus("");
              }, 1), ke();
            }, 1)) : ke();
          }
          if (a.preInit) for (typeof a.preInit == "function" && (a.preInit = [
            a.preInit
          ]); a.preInit.length > 0; ) a.preInit.pop()();
          e1();
          var Fc;
          l && (Fc = {
            uncaughtException: process.listeners("uncaughtException").filter(function(pe) {
              return !l.uncaughtException.indexOf(pe) > -1;
            }),
            unhandledRejection: process.listeners("unhandledRejection").filter(function(pe) {
              return !l.unhandledRejection.indexOf(pe) > -1;
            })
          });
          var Oc;
          if (typeof i < "u") Oc = i;
          else if (typeof WasmBackendModuleThreadedSimd < "u") Oc = WasmBackendModuleThreadedSimd;
          else throw new Error("Could not find wasm module in post.js");
          if (Fc) {
            var t1 = Oc._dispose;
            Oc._dispose = function() {
              t1(), Fc.uncaughtException.forEach(function(pe) {
                process.removeListener("uncaughtException", pe);
              }), Fc.unhandledRejection.forEach(function(pe) {
                process.removeListener("unhandledRejection", pe);
              });
            };
          }
          return i.ready;
        };
      })();
      n.exports = t;
    }(SA)), SA.exports;
  }
  var pre = dnt();
  const gre = _v(pre), fnt = TN({
    __proto__: null,
    default: gre
  }, [
    pre
  ]);
  const jU = fre || unt, pnt = gre || fnt;
  class gnt extends Zx {
    constructor(e) {
      super(), this.wasm = e, this.dataIdNextNumber = 1, this.wasm.tfjs.initWithThreadsCount(bnt), this.wasm.tfjs.getThreadsCount(), this.dataIdMap = new ZC(this, ga());
    }
    write(e, t, r) {
      const i = {
        id: this.dataIdNextNumber++
      };
      return this.move(i, e, t, r, 1), i;
    }
    numDataIds() {
      return this.dataIdMap.numDataIds();
    }
    async time(e) {
      const t = hi();
      return e(), {
        kernelMs: hi() - t
      };
    }
    move(e, t, r, i, a) {
      const s = this.dataIdNextNumber++;
      if (i === "string") {
        const c = t;
        this.dataIdMap.set(e, {
          id: s,
          stringBytes: c,
          shape: r,
          dtype: i,
          memoryOffset: null,
          refCount: a
        });
        return;
      }
      const o = X(r), l = o * Hg(i), u = this.wasm._malloc(l) >>> 0;
      this.dataIdMap.set(e, {
        id: s,
        memoryOffset: u,
        shape: r,
        dtype: i,
        refCount: a
      }), this.wasm.tfjs.registerTensor(s, o, u), t != null && this.wasm.HEAPU8.set(new Uint8Array(t.buffer, t.byteOffset, l), u);
    }
    async read(e) {
      return this.readSync(e);
    }
    readSync(e, t, r) {
      const { memoryOffset: i, dtype: a, shape: s, stringBytes: o } = this.dataIdMap.get(e);
      if (a === "string") return (t == null || t === 0) && (r == null || r >= o.length) ? o : o.slice(t, r);
      t = t || 0, r = r || X(s);
      const l = Hg(a), u = this.wasm.HEAPU8.slice(i + t * l, i + r * l);
      return ynt(u.buffer, a);
    }
    disposeData(e, t = false) {
      if (this.dataIdMap.has(e)) {
        const r = this.dataIdMap.get(e);
        if (r.refCount--, !t && r.refCount > 0) return false;
        this.wasm._free(r.memoryOffset), this.wasm.tfjs.disposeData(r.id), this.dataIdMap.delete(e);
      }
      return true;
    }
    refCount(e) {
      return this.dataIdMap.has(e) ? this.dataIdMap.get(e).refCount : 0;
    }
    incRef(e) {
      const t = this.dataIdMap.get(e);
      t != null && t.refCount++;
    }
    floatPrecision() {
      return 32;
    }
    getMemoryOffset(e) {
      return this.dataIdMap.get(e).memoryOffset;
    }
    dispose() {
      this.wasm.tfjs.dispose(), "PThread" in this.wasm && this.wasm.PThread.terminateAllThreads(), this.wasm = null;
    }
    memory() {
      return {
        unreliable: false
      };
    }
    makeOutput(e, t, r, i) {
      let a;
      if (r == null) a = this.write(i ?? null, e, t);
      else {
        const s = this.dataIdNextNumber++;
        a = {
          id: s
        }, this.dataIdMap.set(a, {
          id: s,
          memoryOffset: r,
          shape: e,
          dtype: t,
          refCount: 1
        });
        const o = X(e);
        this.wasm.tfjs.registerTensor(s, o, r);
      }
      return {
        dataId: a,
        shape: e,
        dtype: t
      };
    }
    typedArrayFromHeap({ shape: e, dtype: t, dataId: r }) {
      const i = this.wasm.HEAPU8.buffer, { memoryOffset: a } = this.dataIdMap.get(r), s = X(e);
      switch (t) {
        case "float32":
          return new Float32Array(i, a, s);
        case "int32":
          return new Int32Array(i, a, s);
        case "bool":
          return new Uint8Array(i, a, s);
        default:
          throw new Error(`Unknown dtype ${t}`);
      }
    }
  }
  function mnt(n, e, t) {
    let r = "tfjs-backend-wasm.wasm";
    return n && e ? r = "tfjs-backend-wasm-threaded-simd.wasm" : n && (r = "tfjs-backend-wasm-simd.wasm"), CA != null && CA[r] != null ? CA[r] : t + r;
  }
  async function vnt() {
    const [n, e] = await Promise.all([
      ne().getAsync("WASM_HAS_SIMD_SUPPORT"),
      ne().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")
    ]);
    return new Promise((t, r) => {
      const i = {};
      i.locateFile = (o, l) => {
        if (o.endsWith(".worker.js")) {
          const u = hnt.wasmWorkerContents.replace(/\n/g, "\\n"), c = new Blob([
            u
          ], {
            type: "application/javascript"
          });
          return URL.createObjectURL(c);
        }
        return o.endsWith(".wasm") ? mnt(n, e, l) : l + o;
      };
      let a = false;
      i.onAbort = () => {
        if (a || IA) return;
        IA = true, r({
          message: "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"
        });
      };
      let s;
      e && n && xnt == null ? (i.mainScriptUrlOrBlob = new Blob([
        "var WasmBackendModuleThreadedSimd = " + jU.toString()
      ], {
        type: "text/javascript"
      }), s = jU(i)) : s = pnt(i), s.then((o) => {
        a = true, IA = false;
        const l = null;
        o.tfjs = {
          init: o.cwrap("init", null, []),
          initWithThreadsCount: o.cwrap("init_with_threads_count", null, [
            "number"
          ]),
          getThreadsCount: o.cwrap("get_threads_count", "number", []),
          registerTensor: o.cwrap("register_tensor", null, [
            "number",
            "number",
            "number"
          ]),
          disposeData: o.cwrap("dispose_data", l, [
            "number"
          ]),
          dispose: o.cwrap("dispose", l, [])
        }, t({
          wasm: o
        });
      }).catch(r);
    });
  }
  function ynt(n, e) {
    switch (e) {
      case "float32":
        return new Float32Array(n);
      case "int32":
        return new Int32Array(n);
      case "bool":
        return new Uint8Array(n);
      default:
        throw new Error(`Unknown dtype ${e}`);
    }
  }
  let xnt = null, CA = {}, IA = false, bnt = -1;
  const wnt = 2;
  _I("wasm", async () => {
    const { wasm: n } = await vnt();
    return new gnt(n);
  }, wnt);
  const Qa = ne();
  Qa.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", () => 15);
  Qa.registerFlag("WEBGPU_CPU_FORWARD", () => true);
  Qa.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE", () => -1);
  Qa.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE", () => true);
  Qa.registerFlag("WEBGPU_USE_LOW_POWER_GPU", () => false);
  Qa.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e3);
  Qa.registerFlag("WEBGPU_USE_PROFILE_TOOL", () => false);
  Qa.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE", () => true);
  Qa.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG", () => false);
  Qa.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL", () => -1);
  Qa.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER", () => false);
  Qa.registerFlag("WEBGPU_PRINT_SHADER", () => "");
  Qa.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY", () => false);
  class _nt {
    constructor(e) {
      e && (this.vendor = e.vendor, this.architecture = e.architecture, this.intelGPUGeneration = this.getIntelGPUGeneration());
    }
    getIntelGPUGeneration() {
      if (this.isIntel()) {
        if (this.architecture.startsWith("gen")) return Number(this.architecture.match(/\d+/));
        if (this.architecture.startsWith("xe")) return 12;
      }
      return 0;
    }
    isIntel() {
      return this.vendor === "intel";
    }
  }
  class Snt {
    constructor(e) {
      this.device = e, this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
    acquireBuffer(e, t, r = false, i = true) {
      let a;
      const s = KU(e, t);
      return i ? (this.freeBuffers.has(s) || this.freeBuffers.set(s, []), this.freeBuffers.get(s).length > 0 ? (a = this.freeBuffers.get(s).pop(), this.numFreeBuffers--) : (a = this.device.createBuffer({
        size: e,
        usage: t,
        mappedAtCreation: r
      }), this.numBytesAllocated += e)) : (a = this.device.createBuffer({
        size: e,
        usage: t,
        mappedAtCreation: r
      }), this.numBytesAllocated += e), this.usedBuffers.has(s) || this.usedBuffers.set(s, []), this.usedBuffers.get(s).push(a), this.numUsedBuffers++, this.numBytesUsed += e, a;
    }
    releaseBuffer(e, t = true) {
      if (this.freeBuffers.size === 0) return;
      const r = e.size, i = e.usage, a = KU(r, i), s = this.usedBuffers.get(a), o = s.indexOf(e);
      if (o < 0) throw new Error("Cannot find the buffer in buffer manager");
      s[o] = s[s.length - 1], s.pop(), this.numUsedBuffers--, this.numBytesUsed -= r, t ? (this.freeBuffers.get(a).push(e), this.numFreeBuffers++) : (e.destroy(), this.numBytesAllocated -= r);
    }
    getNumUsedBuffers() {
      return this.numUsedBuffers;
    }
    getNumFreeBuffers() {
      return this.numFreeBuffers;
    }
    dispose() {
      this.freeBuffers.forEach((e, t) => {
        e.forEach((r) => {
          r.destroy();
        });
      }), this.usedBuffers.forEach((e, t) => {
        e.forEach((r) => {
          r.destroy();
        });
      }), this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
  }
  function KU(n, e) {
    return `${n}_${e}`;
  }
  class Cnt {
    constructor(e) {
      this.device = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
    acquireTexture(e, t, r, i) {
      const a = QU(r), s = e * t * a, o = ZU(e, t, r, i);
      if (this.freeTextures.has(o) || this.freeTextures.set(o, []), this.usedTextures.has(o) || this.usedTextures.set(o, []), this.numBytesUsed += s, this.numUsedTextures++, this.freeTextures.get(o).length > 0) {
        this.numFreeTextures--;
        const u = this.freeTextures.get(o).shift();
        return this.usedTextures.get(o).push(u), u;
      }
      this.numBytesAllocated += s;
      const l = this.device.createTexture({
        size: [
          e,
          t
        ],
        format: r,
        usage: i
      });
      return this.usedTextures.get(o).push(l), l;
    }
    releaseTexture(e) {
      if (this.freeTextures.size === 0) return;
      const t = e.width, r = e.height, i = e.format, a = e.usage, s = ZU(t, r, i, a);
      this.freeTextures.has(s) || this.freeTextures.set(s, []), this.freeTextures.get(s).push(e), this.numFreeTextures++, this.numUsedTextures--;
      const o = this.usedTextures.get(s), l = o.indexOf(e);
      if (l < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      o.splice(l, 1);
      const u = QU(i), c = t * r * u;
      this.numBytesUsed -= c;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      this.freeTextures.forEach((e, t) => {
        e.forEach((r) => {
          r.destroy();
        });
      }), this.usedTextures.forEach((e, t) => {
        e.forEach((r) => {
          r.destroy();
        });
      }), this.freeTextures = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Map(), this.numUsedTextures = 0, this.numFreeTextures = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
  }
  function ZU(n, e, t, r) {
    return `${n}_${e}_${t}_${r}`;
  }
  function QU(n) {
    if (n === "rgba8unorm") return 16;
    throw new Error(`${n} is not supported!`);
  }
  function Int(n, e) {
    if (Math.max(...n) > 5) throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");
    const t = n.length, r = "xyzwuv", i = n.map((s) => `${e}.${r[s]}`), a = new Array(t - 1);
    a[t - 2] = i[t - 1];
    for (let s = t - 3; s >= 0; --s) a[s] = `(${a[s + 1]} * ${i[s + 1]})`;
    return a;
  }
  const Nc = (n, e, t) => t === "int32" ? `atomicAdd(${n}, bitcast<i32>(${e}));` : `
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;
  var rm;
  (function(n) {
    n[n.FROM_PIXELS = 0] = "FROM_PIXELS", n[n.DRAW = 1] = "DRAW";
  })(rm || (rm = {}));
  const knt = (n, e, t, r, i) => {
    const a = {
      dtype: r.dtype,
      shape: r.shape
    }, s = Ant(t, a, e), o = n.createShaderModule({
      code: s,
      label: e.constructor.name
    });
    let l = ne().get("WEBGPU_PRINT_SHADER");
    if (l !== "") {
      l = l.toLowerCase();
      const u = l.split(",");
      (l === "all" || u.some((c) => e.shaderKey.toLowerCase().includes(c))) && (console.group(e.shaderKey), console.debug(s), console.groupEnd());
    }
    return i ? n.createComputePipelineAsync({
      compute: {
        module: o,
        entryPoint: "_start"
      },
      label: e.constructor.name,
      layout: "auto"
    }) : n.createComputePipeline({
      compute: {
        module: o,
        entryPoint: "_start"
      },
      label: e.constructor.name,
      layout: "auto"
    });
  }, Bt = (n, e = "f32") => {
    switch (n) {
      case 1:
        return `${e}`;
      case 2:
        return `vec2<${e}>`;
      case 3:
        return `vec3<${e}>`;
      case 4:
        return `vec4<${e}>`;
      default:
        throw new Error(`${n}-component ${e} is not supported.`);
    }
  };
  function lr(n) {
    if (n <= 1) return "i32";
    if (n === 2) return "vec2<i32>";
    if (n === 3) return "vec3<i32>";
    if (n === 4) return "vec4<i32>";
    if (n === 5) return "vec5";
    if (n === 6) return "vec6";
    throw Error(`GPU for rank ${n} is not yet supported`);
  }
  function Vl(n) {
    if (n === 0) return "x";
    if (n === 1) return "y";
    if (n === 2) return "z";
    if (n === 3) return "w";
    if (n === 4) return "u";
    if (n === 5) return "v";
    throw Error(`Index ${n} is not yet supported`);
  }
  function Ne(...n) {
    let e;
    switch (n.length) {
      case 0:
        e = `
        fn main()
      `;
        break;
      case 1:
        e = `
        fn main(${n[0]} : i32)
      `;
        break;
      default:
        throw Error("Unreachable");
    }
    return e;
  }
  function JU(n, e) {
    let t;
    return t = `
     ${Tnt(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n ? "main(getGlobalIndex());" : "main();"};
      }
    `, t;
  }
  function Tnt(n) {
    return `
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`;
  }
  function Ant(n, e, t) {
    const r = [], i = t.workgroupSize[0] * t.workgroupSize[1] * t.workgroupSize[2];
    if (t.outputComponent = t.outputComponent ? t.outputComponent : 1, r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${mre(t) ? "  return i32(globalId.x);" : `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +
                localIndex);
        `}
      }
    `), t.pixelsOpType != null) {
      const p = t.pixelsOpType === rm.FROM_PIXELS ? `@group(0) @binding(0) var<storage, read_write> result: array<${Mh(e.dtype, t.outputComponent)}>;` : `@group(0) @binding(1) var<storage, read> inBuf : array<${Mh(n[0].dtype, t.outputComponent)}>;`, g = e.shape.length === 3 ? "vec2<i32>" : "i32";
      r.push(`
        struct Uniform {
          outShapeStrides : ${g},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${p}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);
      const m = tH(t);
      return [
        eH,
        r.join(`
`),
        I_(e.shape),
        t.getUserCode(),
        JU(m, t)
      ].join(`
`);
    }
    let a, s, o = "struct Uniforms { NAN : f32, INFINITY : f32, ";
    t.variableNames.forEach((p, g) => {
      const m = lr(n[g].shape.length);
      o += `${p.charAt(0).toLowerCase() + p.slice(1)}Shape : ${m}, `, a = n[g].shape.length - 1, s = lr(a), o += `${p.charAt(0).toLowerCase() + p.slice(1)}ShapeStrides: ${s}, `;
    });
    const l = lr(e.shape.length);
    o += `outShape : ${l}, `, a = e.shape.length - 1, s = lr(a), o += `
         outShapeStrides: ${s}, `, t.size && (o += "size : i32, "), t.uniforms && (o += t.uniforms), o += "};", o = Fnt(o), r.push(o), t.atomic ? r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `) : r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Mh(e.dtype, t.outputComponent)}>;
    `), t.variableNames.forEach((p, g) => {
      r.push(`
      @group(0) @binding(${1 + g}) var<storage, read> ${p}: array<${t.variableComponents ? Mh(n[g].dtype, t.variableComponents[g]) : Mh(n[g].dtype, t.outputComponent)}>;
        `);
    }), o !== "" && r.push(`
      @group(0) @binding(${1 + t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);
    const u = Mnt(e.shape, t.dispatchLayout), c = [
      eH,
      r.join(`
`) + Rnt,
      I_(e.shape),
      u,
      Pnt(e.shape.length)
    ];
    t.atomic || c.push(Lnt(e.shape, e.dtype, t.outputComponent)), t.variableNames.forEach((p, g) => {
      c.push(`${I_(n[g].shape, p)}`);
    });
    const h = n.map((p, g) => Ent(p, e.shape, t.variableComponents ? t.variableComponents[g] : t.outputComponent, t.dispatchLayout.x.length === e.shape.length)).join(`
`);
    c.push(h), c.push(t.getUserCode());
    const d = tH(t);
    return c.push(JU(d, t)), c.join(`
`);
  }
  function Dnt(n, e, t) {
    let r = n.shaderKey;
    if (n.pixelsOpType != null) return r;
    const i = [], a = [];
    e.forEach((c) => {
      i.push(c.shape), a.push(c.dtype);
    }), i.push(t.shape), a.push(t.dtype);
    const s = e.map((c) => lc(c.shape, t.shape)), o = e.map((c) => Jt(c.shape, t.shape)).join("_"), l = s.map((c) => c.join("_")).join(";"), u = mre(n) ? "flatDispatch" : "";
    return r += "_" + (n.workgroupSize ? n.workgroupSize.join(",") : "") + i.map((c) => c.length).join(",") + a.join(",") + n.variableNames.join(",") + l + o + u, r;
  }
  const eH = `
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`, Rnt = `
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;
  function I_(n, e = "") {
    const t = n.length, r = e !== "" ? `get${e.charAt(0).toUpperCase() + e.slice(1)}CoordsFromIndex` : "getCoordsFromIndex", i = e !== "" ? `${e.charAt(0).toLowerCase() + e.slice(1)}ShapeStrides` : "outShapeStrides";
    if (t <= 1) return `fn ${r}(index : i32) -> i32 { return index; }`;
    const a = Be(n), s = lr(t), o = [];
    for (let u = 0; u < t; u++) o.push(`d${u}`);
    if (a.length === 1) return `    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`;
    let l;
    return l = "var index2 = index;" + a.map((u, c) => {
      const h = `let ${o[c]} = index2 / uniforms.${i}.${Vl(c)}`, d = c === a.length - 1 ? `let ${o[c + 1]} = index2 - ${o[c]} * uniforms.${i}.${Vl(c)}` : `index2 = index2 - ${o[c]} * uniforms.${i}.${Vl(c)}`;
      return `${h}; ${d};`;
    }).join(""), `
    fn ${r}(index : i32) -> ${s} {
      ${l}
      return ${s}(${o.join(",")});
    }
  `;
  }
  function $nt(n, e) {
    const t = n.name, r = n.shape.length, i = lr(r), a = "get" + t.charAt(0).toUpperCase() + t.slice(1), s = [
      "d0",
      "d1",
      "d2",
      "d3",
      "d4",
      "d5"
    ].slice(0, r), o = s.map((c) => `${c} : i32`).join(", ");
    if (r < 1) return `
      fn ${a}() -> ${Bt(e)} {
        return ${Bt(e)}(${t}[0]);
      }
    `;
    const l = `uniforms.${t.charAt(0).toLowerCase() + t.slice(1)}Shape`;
    let u = `${r}D`;
    return r === 0 && (u = "1D"), `
    fn ${a}(${o}) -> ${Bt(e)} {
      return ${Bt(e)}(${t}[getIndexFromCoords${u}(${i}(${s.join(",")}),
        ${l})${e === 1 ? "" : ` / ${e}`}]);
    }
   `;
  }
  function Nnt(n, e, t, r) {
    const i = n.name, a = i.charAt(0).toUpperCase() + i.slice(1), s = "get" + a + "ByOutput", o = n.shape.length, l = e.length, u = lr(l);
    if (Jt(n.shape, e) && r) return `
    fn ${s}Index(globalIndex : i32) -> ${Bt(t)} {
      return ${Bt(t)}(${i}[globalIndex]);
    }

    fn ${s}Coords(coords : ${u}) -> ${Bt(t)} {
      return ${Bt(t)}(${i}[${l > 1 ? "getOutputIndexFromCoords(coords)" : "coords"}${t === 1 ? "" : ` / ${t}`}]);
    }
    `;
    const c = lc(n.shape, e), h = l - o;
    let d = "";
    if (o === 0) return `
    fn ${s}Index(globalIndex : i32) -> ${Bt(t)}{
      return get${a}();
    }

    fn ${s}Coords(coords : ${u}) -> ${Bt(t)}{
      return get${a}();
    }
  `;
    l < 2 && c.length >= 1 ? d = "coords = 0;" : d = c.map((m) => `coords.${Vl(m + h)} = 0;`).join(`
`);
    let f = "";
    if (l < 2 && o > 0) f = "coords";
    else if (l > 1) {
      const m = lr(o), v = n.shape.map((y, x) => `coords.${Vl(x + h)}`).join(", ");
      f = `${m}(${v})`;
    } else f = "coords";
    const p = `uniforms.${i.charAt(0).toLowerCase() + i.slice(1)}Shape`, g = `${o}D`;
    return `
  fn ${s}Index(globalIndex : i32) -> ${Bt(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${d}
    return ${Bt(t)}(${i}[getIndexFromCoords${g}(${f}, ${p})${t === 1 ? "" : ` / ${t}`}]);
  }

  fn ${s}Coords(coordsIn : ${u}) -> ${Bt(t)} {
    var coords = coordsIn;
    ${d}
    return ${Bt(t)}(${i}[getIndexFromCoords${g}(${f}, ${p})${t === 1 ? "" : ` / ${t}`}]);
  }
`;
  }
  function Ent(n, e, t, r) {
    let i = $nt(n, t);
    return n.shape.length <= e.length && (i += Nnt(n, e, t, r)), i;
  }
  function Mnt(n, e) {
    const { x: t, y: r = [], z: i = [] } = e, a = n.length, s = t.length + r.length + i.length;
    if (s !== a) return "";
    if (t.length === a) return `fn getOutputCoords() -> ${lr(a)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;
    let o = "";
    const l = [
      t,
      r,
      i
    ];
    for (let d = 0; d < l.length; d++) {
      const f = l[d];
      if (f.length !== 0) if (f.length === 1) o += `let d${f[0]} = i32(globalId[${d}]);`;
      else {
        const p = Int(f, "uniforms.outShape");
        o += `var index${d} = i32(globalId[${d}]);`;
        for (let g = 0; g < p.length; g++) o += `let d${f[g]} = index${d} / ${p[g]};`, g === p.length - 1 ? o += `let d${f[g + 1]} = index${d} - d${f[g]} * ${p[g]};` : o += `index${d} = index${d} - d${f[g]} * ${p[g]};`;
      }
    }
    const u = [];
    for (let d = 0; d < s; d++) u.push(`d${d}`);
    const c = lr(s);
    let h = `fn getOutputCoords() -> ${c} {
  ${o}
`;
    return u.length === 0 ? h += `return ${c}(0); }` : h += `return ${c}(${u.join(",")}); }`, h;
  }
  function Pnt(n) {
    let e = "";
    switch (n) {
      case 0:
      case 1:
        e += `
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;
        break;
      case 2:
        e += `
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;
        break;
      case 3:
        e += `
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;
        break;
      case 4:
        e += `
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;
        break;
      case 5:
        e += `
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;
        break;
      case 6:
        e += `
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;
        break;
      default:
        B(false, () => `Unsupported ${n}D shape`);
        break;
    }
    return e;
  }
  function mre(n) {
    return n.dispatch[1] === 1 && n.dispatch[2] === 1;
  }
  function Mh(n, e = 1) {
    if (n === "float32") return Bt(e, "f32");
    if (n === "int32" || n === "bool") return Bt(e, "i32");
    throw new Error(`type ${n} is not supported.`);
  }
  function Lnt(n, e, t) {
    const r = n.length, i = Mh(e, t);
    let a = `fn setOutputAtIndex(flatIndex : i32, value : ${Bt(t)}) {
      result[flatIndex] = ${i}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Bt(t, "i32")}) {
      result[flatIndex] = ${i}(value);
    }
    `;
    if (r >= 2) {
      const s = [
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5"
      ].slice(0, r), o = lr(r);
      a += `
      fn setOutputAtCoords(${s.map((l) => `${l} : i32`).join(", ")}, value : ${Bt(t)}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${s.join(", ")}));
        setOutputAtIndex(flatIndex${t === 1 ? "" : ` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${s.map((l) => `${l} : i32`).join(", ")}, value : ${Bt(t, "i32")}) {
        let flatIndex = getOutputIndexFromCoords(${o}(${s.join(", ")}));
        setOutputAtIndexI32(flatIndex${t === 1 ? "" : ` / ${t}`}, value);
      }
    `;
    }
    return a;
  }
  function Fnt(n) {
    const e = /(\w+)\s*:\s*vec(5|6)/g;
    n = n.replace(e, (r) => "@align(16) " + r);
    const t = /vec(5|6)\s*,\s*(\w+)/g;
    return n = n.replace(t, (r, i, a) => `vec${i}, @align(16) ${a}`), n;
  }
  function tH(n) {
    return !(n.dispatchLayout.hasOwnProperty("y") && n.dispatchLayout.y.length !== 0 || n.dispatchLayout.hasOwnProperty("z") && n.dispatchLayout.z.length !== 0);
  }
  const od = (n) => {
    let e = 1;
    for (let t = 0; t < n.length; t++) e *= n[t];
    return e;
  };
  function Ee(n, e, t = [
    1,
    1,
    1
  ], r = [
    1,
    1,
    1
  ]) {
    const [i, a, s] = [
      Math.ceil(od(n.x.map((o) => e[o])) / (t[0] * r[0])),
      n.y ? Math.ceil(od(n.y.map((o) => e[o])) / (t[1] * r[1])) : 1,
      n.z ? Math.ceil(od(n.z.map((o) => e[o])) / (t[2] * r[2])) : 1
    ];
    return [
      i,
      a,
      s
    ];
  }
  function Ont(n, e, t, r = false) {
    const i = [
      8,
      8,
      1
    ], a = [
      4,
      4,
      1
    ];
    return r || (n <= 8 && (a[1] = 1), e <= 16 && t <= 16 && (i[0] = 4)), {
      workgroupSize: i,
      elementsPerThread: a
    };
  }
  function vre(n, e, t = false) {
    if (t) return [
      8,
      8,
      1
    ];
    const r = od(n.x.map((a) => e[a])), i = od(n.y.map((a) => e[a]));
    return r <= 4 ? [
      4,
      16,
      1
    ] : i <= 4 ? [
      16,
      4,
      1
    ] : [
      16,
      16,
      1
    ];
  }
  function yre(n, e, t = false) {
    if (t) return [
      4,
      4,
      1
    ];
    const r = od(n.x.map((a) => e[a])), i = od(n.y.map((a) => e[a]));
    return r <= 4 ? [
      1,
      2,
      1
    ] : i <= 4 ? [
      2,
      1,
      1
    ] : [
      2,
      2,
      1
    ];
  }
  function We(n) {
    return {
      x: n.map((e, t) => t)
    };
  }
  function nH(n) {
    if (n === "float32" || n === "int32" || n === "bool" || n === "string") return 4;
    if (n === "complex64") return 8;
    throw new Error(`Unknown dtype ${n}`);
  }
  function xre() {
    return !!(typeof globalThis < "u" && globalThis.navigator && globalThis.navigator.gpu);
  }
  function bre(n, e) {
    Array.isArray(n) || (n = [
      n
    ]), n.forEach((t) => {
      t != null && B(t.dtype !== "complex64", () => `${e} does not support complex64 tensors in the WebGPU backend.`);
    });
  }
  var Ro;
  (function(n) {
    n[n.MatMulReduceProgram = 0] = "MatMulReduceProgram", n[n.MatMulSplitKProgram = 1] = "MatMulSplitKProgram", n[n.MatMulSmallOutputSizeProgram = 2] = "MatMulSmallOutputSizeProgram", n[n.MatMulPackedProgram = 3] = "MatMulPackedProgram", n[n.MatMulMax = 4] = "MatMulMax";
  })(Ro || (Ro = {}));
  const Bnt = ne().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"), znt = (n, e) => {
    const t = n.limits.maxComputeWorkgroupsPerDimension, r = e.dispatchLayout, i = e.dispatch;
    if (i.every((s) => s <= t)) return i;
    B(i[0] > t && r.y === void 0 && r.z === void 0, () => "Dispatch size exceeds WebGPU limits in Y or Z dimension.");
    let a = Math.ceil(Math.sqrt(i[0]));
    return a > t ? (a = Math.ceil(Math.cbrt(i[0])), B(a <= t, () => "Total dispatch size exceeds WebGPU maximum."), [
      a,
      a,
      a
    ]) : [
      a,
      a,
      1
    ];
  };
  class c2 extends Zx {
    nextDataId() {
      return c2.nextDataId++;
    }
    constructor(e, t) {
      if (super(), this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.dispatchCountInPass = 0, this.disposed = false, this.downloadWaitMs = 0, this.tensorDataPendingDisposal = [], this.queryResolveBuffer = null, this.querySet = null, this.querySetCount = 2, this.stagingPendingDisposal = [], this.uniformPendingDisposal = [], this.uploadWaitMs = 0, this.hasReadSyncWarned = false, this.hasTimestampQueryWarned = false, !xre()) throw new Error("WebGPU is not supported on this device");
      this.pipelineCache = {}, this.device = e, this.queue = e.queue, this.commandEncoder = null, this.computePassEncoder = null, this.adapterInfo = new _nt(t), this.supportTimestampQuery = this.device.features.has("timestamp-query"), this.thresholdToIncreaseWorkgroups = this.adapterInfo.intelGPUGeneration >= 12 ? 16 : 8, this.bufferManager = new Snt(this.device), this.textureManager = new Cnt(this.device), this.tensorMap = new ZC(this, ga()), ne().getBool("WEBGPU_USE_PROFILE_TOOL") && (this.dummyCanvas = document.createElement("canvas"), this.dummyCanvas.width = 1, this.dummyCanvas.height = 1, this.dummyContext = this.dummyCanvas.getContext("webgpu"), this.dummyContext.configure({
        device: e,
        format: "bgra8unorm"
      }), document.body.appendChild(this.dummyCanvas));
    }
    floatPrecision() {
      return 32;
    }
    disposeData(e, t = false) {
      if (!this.tensorMap.has(e)) return true;
      const r = this.tensorMap.get(e);
      return t ? r.refCount = 0 : r.refCount--, r.refCount > 0 ? false : (r.complexTensorInfos != null && (this.disposeData(r.complexTensorInfos.real.dataId), this.disposeData(r.complexTensorInfos.imag.dataId)), this.commandQueueOwnedIds.has(e) ? (this.tensorDataPendingDisposal.push(e), true) : (this.releaseResource(e), this.tensorMap.delete(e), true));
    }
    memory() {
      return {
        numBytesInGPU: this.bufferManager.numBytesUsed,
        numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated,
        unreliable: false
      };
    }
    releaseResource(e) {
      const t = this.tensorMap.get(e);
      if (!(!t || !t.resource)) {
        if (t.external) {
          t.resource = null;
          return;
        }
        t.resource instanceof GPUBuffer ? this.bufferManager.releaseBuffer(t.resource) : t.resource instanceof GPUTexture && this.textureManager.releaseTexture(t.resource), t.resource = null;
      }
    }
    refCount(e) {
      return this.tensorMap.has(e) ? this.tensorMap.get(e).refCount : 0;
    }
    incRef(e) {
      const t = this.tensorMap.get(e);
      t.refCount++;
    }
    decRef(e) {
      if (this.tensorMap.has(e)) {
        const t = this.tensorMap.get(e);
        t.refCount--;
      }
    }
    write(e, t, r) {
      if (r === "complex64" && e != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      const i = {
        id: this.nextDataId()
      };
      return this.tensorMap.set(i, {
        dtype: r,
        shape: t,
        values: e,
        refCount: 1
      }), i;
    }
    move(e, t, r, i, a) {
      if (i === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
      this.tensorMap.set(e, {
        dtype: i,
        shape: r,
        values: t,
        refCount: a
      });
    }
    submitQueue() {
      this.queue.submit([
        this.commandEncoder.finish()
      ]), this.commandEncoder = null, this.dispatchCountInPass = 0, this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.tensorDataPendingDisposal.forEach((e) => {
        this.releaseResource(e), this.tensorMap.delete(e);
      }), this.uniformPendingDisposal.forEach((e) => this.bufferManager.releaseBuffer(e)), this.stagingPendingDisposal.forEach((e) => this.bufferManager.releaseBuffer(e, false)), this.tensorDataPendingDisposal = [], this.uniformPendingDisposal = [], this.stagingPendingDisposal = [];
    }
    ensureCommandEncoderReady() {
      this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder());
    }
    endComputePassEncoder() {
      this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);
    }
    async checkCompileCompletionAsync() {
      let e;
      try {
        e = await Promise.all(Object.values(this.pipelineCache));
      } catch (t) {
        throw new Error(t.message);
      }
      Object.keys(this.pipelineCache).map((t, r) => {
        this.pipelineCache[t] = e[r];
      });
    }
    async getBufferData(e) {
      if (ne().getBool("WEBGPU_ENGINE_COMPILE_ONLY")) return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"), null;
      const t = e.size, r = this.bufferManager.acquireBuffer(t, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
      this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e, 0, r, 0, t), this.submitQueue(), await r.mapAsync(GPUMapMode.READ);
      const i = r.getMappedRange().slice(0);
      return r.unmap(), r != null && this.bufferManager.releaseBuffer(r), ne().getBool("WEBGPU_USE_PROFILE_TOOL") && (B(this.dummyContext !== void 0, () => "Fail to get context for profiling tool"), this.dummyContext.getCurrentTexture()), i;
    }
    convertAndCacheOnCPU(e, t) {
      const r = this.tensorMap.get(e);
      return r.values = t, r.values;
    }
    readSync(e) {
      const t = this.tensorMap.get(e), { values: r, complexTensorInfos: i } = t;
      if (r != null || t.dtype === "string") return r;
      if (t.dtype === "complex64") {
        const g = this.readSync(i.real.dataId), m = this.readSync(i.imag.dataId), v = g_(ao(g, m).buffer, "float32");
        return this.convertAndCacheOnCPU(e, v), v;
      }
      this.hasReadSyncWarned || (this.hasReadSyncWarned = true, console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));
      const a = [
        "opaque",
        "premultiplied"
      ], s = t.resource, o = s.size;
      B(o % 4 === 0, () => "Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");
      const l = o / 4, u = new ArrayBuffer(o), c = 256, h = 256, d = a.map((g) => new OffscreenCanvas(c, h)), f = new OffscreenCanvas(c, h);
      this.endComputePassEncoder(), d.map((g, m) => {
        const v = g.getContext("webgpu");
        return v.configure({
          device: this.device,
          format: "bgra8unorm",
          usage: GPUTextureUsage.COPY_DST,
          alphaMode: a[m]
        }), v.getCurrentTexture();
      }).map((g, m) => {
        const v = c * 4, y = (I, C, T) => {
          this.ensureCommandEncoderReady(), this.commandEncoder.copyBufferToTexture({
            buffer: s,
            bytesPerRow: v,
            offset: T
          }, {
            texture: g
          }, {
            width: I,
            height: C
          }), this.submitQueue();
          const k = f.getContext("2d", {
            willReadFrequently: true
          });
          k.clearRect(0, 0, I, C), k.drawImage(d[m], 0, 0);
          const D = k.getImageData(0, 0, I, C).data, R = a[m], N = new Uint8ClampedArray(u, T, I * C * 4);
          for (let E = 0; E < N.length; E += 4) if (R === "premultiplied") N[E + 3] = D[E + 3];
          else {
            const A = D[E];
            N[E] = D[E + 2], N[E + 1] = D[E + 1], N[E + 2] = A;
          }
        }, x = Math.floor(l / (c * h));
        let b = c, w = h, _ = 0;
        for (let I = 0; I < x; I++) y(b, w, _), _ += c * h * 4;
        const S = l % (c * h);
        w = Math.floor(S / c), w > 0 && (y(b, w, _), _ += w * (c * 4)), b = S % c, b > 0 && y(b, 1, _);
      });
      const p = g_(u, t.dtype);
      return this.convertAndCacheOnCPU(e, p), p;
    }
    async read(e) {
      if (!this.tensorMap.has(e)) throw new Error(`Tensor ${e} was not registered!`);
      const t = this.tensorMap.get(e), { values: r } = t;
      if (r != null) return r;
      let i;
      if (t.dtype === "complex64") {
        const a = await Promise.all([
          this.read(t.complexTensorInfos.real.dataId),
          this.read(t.complexTensorInfos.imag.dataId)
        ]), s = a[0], o = a[1];
        i = ao(s, o);
      } else {
        const a = await this.getBufferData(t.resource);
        i = g_(a, t.dtype);
      }
      return this.convertAndCacheOnCPU(e, i), i;
    }
    copyBuffer(e) {
      const t = e.size, r = e.usage, i = this.bufferManager.acquireBuffer(t, r);
      return this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e, 0, i, 0, t), this.submitQueue(), i;
    }
    createTensorFromGPUData(e, t, r) {
      let i = e.buffer;
      if (r === "complex64") throw new Error("Cannot write to a complex64 dtype. ");
      const a = {
        id: this.nextDataId()
      };
      this.tensorMap.set(a, {
        dtype: r,
        shape: t,
        values: null,
        refCount: 1,
        external: e.zeroCopy
      });
      const s = this.tensorMap.get(a), o = nH(s.dtype) * X(s.shape);
      if (e.buffer.size < o) throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${o})!`);
      if ((e.buffer.usage & (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) !== (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");
      return e.zeroCopy !== true && (i = this.copyBuffer(i)), s.resource = i, ga().makeTensorFromDataId(a, t, r, this);
    }
    readToGPU(e) {
      const t = this.tensorMap.get(e), { values: r, dtype: i, shape: a, resource: s } = t;
      if (i === "complex64") throw new Error("Does not support reading buffer for complex64 dtype.");
      if (s == null) throw r != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
      const o = s, l = o.size, u = o.usage, c = this.bufferManager.acquireBuffer(l, u);
      this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(s, 0, c, 0, l), this.submitQueue();
      const h = this.makeTensorInfo(a, i), d = ga().makeTensorFromTensorInfo(h), f = this.tensorMap.get(h.dataId);
      return f.resource = c, {
        tensorRef: d,
        buffer: c
      };
    }
    bufferSync(e) {
      const t = this.readSync(e.dataId);
      if (e.dtype === "string") try {
        const r = t.map((i) => io(i));
        return Nt(e.shape, e.dtype, r);
      } catch {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
      return Nt(e.shape, e.dtype, t);
    }
    async time(e) {
      !this.supportTimestampQuery && !this.hasTimestampQueryWarned && (console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."), this.hasTimestampQueryWarned = true);
      const t = this.activeTimers, r = [];
      let i = false;
      this.programTimersStack == null ? (this.programTimersStack = r, i = true) : this.activeTimers.push(r), this.activeTimers = r, e();
      const a = Jl(this.activeTimers.map((u) => u.query)).filter((u) => u != null), s = Jl(this.activeTimers.map((u) => u.name)).filter((u) => u != null);
      this.activeTimers = t, i && (this.programTimersStack = null);
      const o = {
        uploadWaitMs: this.uploadWaitMs,
        downloadWaitMs: this.downloadWaitMs,
        kernelMs: null,
        wallMs: null
      }, l = await Promise.all(a);
      return o.kernelMs = z7(l), o.getExtraProfileInfo = () => l.map((u, c) => ({
        name: s[c],
        ms: u
      })).map((u) => `${u.name}: ${u.ms}`).join(", "), this.uploadWaitMs = 0, this.downloadWaitMs = 0, o;
    }
    makeTensorInfo(e, t, r) {
      return t === "string" && r != null && r.length > 0 && Tm(r[0]) && (r = r.map((a) => Bl(a))), {
        dataId: this.write(r, e, t),
        shape: e,
        dtype: t
      };
    }
    tensorToBinding(e) {
      if (!e) return null;
      const r = this.tensorMap.get(e.dataId).resource;
      return r instanceof GPUBuffer ? {
        buffer: r
      } : r instanceof GPUTexture ? r.createView() : r;
    }
    uploadToGPU(e) {
      const t = this.tensorMap.get(e);
      if (t.resource != null) return;
      const r = nH(t.dtype) * X(t.shape);
      let i;
      const a = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
      if (t.values) {
        if (i = this.bufferManager.acquireBuffer(r, a, true), i.mapState === "unmapped") {
          const s = this.bufferManager.acquireBuffer(r, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, true, false), o = s.getMappedRange();
          t.dtype === "int32" || t.dtype === "bool" ? new Int32Array(o).set(t.values) : new Float32Array(o).set(t.values), s.unmap(), this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(s, 0, i, 0, r), this.stagingPendingDisposal.push(s);
        } else {
          const s = i.getMappedRange();
          t.dtype === "int32" || t.dtype === "bool" ? new Int32Array(s).set(t.values) : new Float32Array(s).set(t.values), i.unmap();
        }
        t.values = null;
      } else i = this.bufferManager.acquireBuffer(r, a);
      t.resource = i;
    }
    makeUniforms(e) {
      let t = 0, r = 0;
      const i = [];
      let a = 1;
      e.forEach((l) => {
        l.data.length === 0 && (l.data = [
          1
        ]);
        let u;
        switch (l.data.length) {
          case 1:
            u = 4;
            break;
          case 2:
            u = 8;
            break;
          case 3:
            u = 16;
            break;
          case 4:
            u = 16;
            break;
          case 5:
            u = 16;
            break;
          case 6:
            u = 16;
            break;
          default:
            B(false, () => `Unsupported ${l.data.length}D shape`);
        }
        (r === 5 || r === 6) && (u = 16), u > a && (a = u), t = Math.ceil(t / u) * u, r = l.data.length, i.push(t), t += l.data.length * 4;
      }), t = Math.ceil(t / a) * a;
      const s = new ArrayBuffer(t);
      e.forEach((l, u) => {
        const c = i[u];
        l.type === "int32" ? new Int32Array(s, c, l.data.length).set(l.data) : l.type === "uint32" ? new Uint32Array(s, c, l.data.length).set(l.data) : new Float32Array(s, c, l.data.length).set(l.data);
      });
      const o = this.bufferManager.acquireBuffer(t, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
      return this.queue.writeBuffer(o, 0, s, 0, t), this.uniformPendingDisposal.push(o), {
        offset: 0,
        size: t,
        buffer: o
      };
    }
    runWebGPUProgram(e, t, r, i, a) {
      if (a || (a = this.makeTensorInfo(e.outputShape, r)), X(a.shape) === 0) return this.tensorMap.get(a.dataId).values = Yr(a.dtype, 0), a;
      this.uploadToGPU(a.dataId), e.dispatch = znt(this.device, e);
      const s = t.map((l, u) => {
        if (l.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
        return this.uploadToGPU(l.dataId), {
          dtype: this.tensorMap.get(l.dataId).dtype,
          shape: l.shape,
          name: e.variableNames[u]
        };
      });
      e.shaderKey = Dnt(e, s, a);
      const o = ne().getBool("WEBGPU_ENGINE_COMPILE_ONLY");
      return e.shaderKey in this.pipelineCache || (this.pipelineCache[e.shaderKey] = knt(this.device, e, s, a, o)), e.pipeline = this.pipelineCache[e.shaderKey], o || this.recordAndSubmit(e, a, t, i), a;
    }
    recordAndSubmit(e, t, r, i) {
      if (e.pipeline instanceof Promise) throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");
      let a = [], s = [];
      const o = "int32";
      if (e.pixelsOpType == null) {
        a.push({
          type: "float32",
          data: [
            NaN
          ]
        }, {
          type: "float32",
          data: [
            1 / 0
          ]
        }), s = r.concat(t).map((f) => f.shape);
        const d = "int32";
        s.map((f) => {
          a.push({
            type: d,
            data: f
          });
          const p = Be(f);
          a.push({
            type: d,
            data: p
          });
        });
      } else {
        const d = Be(t.shape);
        a.push({
          type: o,
          data: d
        });
      }
      if (e.size) {
        const d = X(e.outputShape);
        a.push({
          type: o,
          data: [
            e.outputComponent ? d / e.outputComponent : d
          ]
        });
      }
      i && (a = [
        ...a,
        ...i
      ]);
      const l = [
        this.tensorToBinding(t),
        ...r.map((d) => this.tensorToBinding(d)),
        this.makeUniforms(a)
      ];
      r.forEach((d) => {
        this.commandQueueOwnedIds.add(d.dataId);
      }), this.commandQueueOwnedIds.add(t.dataId);
      const u = this.device.createBindGroup({
        layout: e.pipeline.getBindGroupLayout(0),
        entries: l.map((d, f) => ({
          binding: f,
          resource: d
        }))
      }), c = this.activeTimers != null;
      this.ensureCommandEncoderReady();
      const h = {};
      c && this.supportTimestampQuery ? (this.endComputePassEncoder(), this.querySet == null && (this.querySet = this.device.createQuerySet({
        type: "timestamp",
        count: this.querySetCount
      })), h.timestampWrites = {
        querySet: this.querySet,
        beginningOfPassWriteIndex: 0,
        endOfPassWriteIndex: 1
      }, this.computePassEncoder = this.commandEncoder.beginComputePass(h)) : this.computePassEncoder || (this.computePassEncoder = this.commandEncoder.beginComputePass(h)), this.computePassEncoder.setPipeline(e.pipeline), this.computePassEncoder.setBindGroup(0, u), this.computePassEncoder.dispatchWorkgroups(e.dispatch[0], e.dispatch[1], e.dispatch[2]), this.dispatchCountInPass++, (c || ne().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE") <= this.dispatchCountInPass || e.pixelsOpType === rm.DRAW) && (this.endComputePassEncoder(), c ? this.activeTimers.push({
        name: e.constructor.name,
        query: this.getQueryTime()
      }) : this.submitQueue());
    }
    async getQueryTime() {
      if (!this.supportTimestampQuery) return 0;
      this.queryResolveBuffer == null && (this.queryResolveBuffer = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.QUERY_RESOLVE)), this.commandEncoder.resolveQuerySet(this.querySet, 0, this.querySetCount, this.queryResolveBuffer, 0);
      const e = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, e, 0, this.querySetCount * 8), this.submitQueue(), await e.mapAsync(GPUMapMode.READ);
      const t = new BigUint64Array(e.getMappedRange()), r = Number(t[1] - t[0]) / 1e6;
      return e.unmap(), this.bufferManager.releaseBuffer(e), r;
    }
    shouldExecuteOnCPU(e, t = Bnt) {
      return ne().getBool("WEBGPU_CPU_FORWARD") && e.every((r) => this.tensorMap.get(r.dataId).resource == null && X(r.shape) < t);
    }
    numDataIds() {
      return this.tensorMap.numDataIds() - this.tensorDataPendingDisposal.length;
    }
    dispose() {
      this.disposed || (this.querySet != null && this.querySet.destroy(), this.bufferManager.dispose(), this.textureManager.dispose(), this.disposed = true);
    }
  }
  c2.nextDataId = 0;
  xre() && _I("webgpu", async () => {
    const n = {
      powerPreference: ne().get("WEBGPU_USE_LOW_POWER_GPU") ? "low-power" : "high-performance"
    }, e = await navigator.gpu.requestAdapter(n), t = {}, r = [];
    e.features.has("timestamp-query") && r.push("timestamp-query"), e.features.has("bgra8unorm-storage") && r.push([
      "bgra8unorm-storage"
    ]), t.requiredFeatures = r;
    const i = e.limits;
    t.requiredLimits = {
      maxComputeWorkgroupStorageSize: i.maxComputeWorkgroupStorageSize,
      maxComputeWorkgroupsPerDimension: i.maxComputeWorkgroupsPerDimension,
      maxStorageBufferBindingSize: i.maxStorageBufferBindingSize,
      maxBufferSize: i.maxBufferSize,
      maxComputeWorkgroupSizeX: i.maxComputeWorkgroupSizeX,
      maxComputeInvocationsPerWorkgroup: i.maxComputeInvocationsPerWorkgroup
    };
    const a = await e.requestDevice(t), s = "info" in e ? e.info : "requestAdapterInfo" in e ? await e.requestAdapterInfo() : void 0;
    return new c2(a, s);
  }, 3);
  var _t;
  (function(n) {
    n[n.ADD = 0] = "ADD", n[n.ATAN2 = 1] = "ATAN2", n[n.COMPLEX_MULTIPLY_IMAG = 2] = "COMPLEX_MULTIPLY_IMAG", n[n.COMPLEX_MULTIPLY_REAL = 3] = "COMPLEX_MULTIPLY_REAL", n[n.DIV = 4] = "DIV", n[n.ELU_DER = 5] = "ELU_DER", n[n.EQUAL = 6] = "EQUAL", n[n.FLOOR_DIV = 7] = "FLOOR_DIV", n[n.GREATER = 8] = "GREATER", n[n.GREATER_EQUAL = 9] = "GREATER_EQUAL", n[n.LESS = 10] = "LESS", n[n.LESS_EQUAL = 11] = "LESS_EQUAL", n[n.LOGICAL_AND = 12] = "LOGICAL_AND", n[n.LOGICAL_OR = 13] = "LOGICAL_OR", n[n.MAX = 14] = "MAX", n[n.MIN = 15] = "MIN", n[n.MOD = 16] = "MOD", n[n.MUL = 17] = "MUL", n[n.NOT_EQUAL = 18] = "NOT_EQUAL", n[n.POW = 19] = "POW", n[n.PRELU = 20] = "PRELU", n[n.SQUARED_DIFFERENCE = 21] = "SQUARED_DIFFERENCE", n[n.SUB = 22] = "SUB";
  })(_t || (_t = {}));
  const Vnt = "let resultTemp = a + b;", Wnt = "let resultTemp = atan2(a, b);", Gnt = "let resultTemp = areal * breal - aimag * bimag;", Unt = "let resultTemp = areal * bimag + aimag * breal;", Hnt = "let resultTemp = a / b;", Xnt = "let resultTemp = select(a * (b + 1.0), a, b >= b - b);", Ynt = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`, qnt = `
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`, jnt = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`, Knt = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`, Znt = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`, Qnt = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`, Jnt = "return f32(a >= 1.0 && b >= 1.0);", ert = `return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`, trt = "return f32(a >= 1.0 || b >= 1.0);", nrt = `return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`, rrt = "let resultTemp = max(a, b);", irt = "let resultTemp = min(a, b);", art = `
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`, srt = `
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`, ort = "let resultTemp = a * b;", lrt = `
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`, urt = `
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`, crt = `
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`, hrt = `
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`, drt = "if (a < 0.0) { return b * a; }  return a;", frt = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`, prt = "let resultTemp = (a - b) * (a - b);", grt = "let resultTemp = a - b;";
  function LL(n, e) {
    let t;
    do {
      switch (n) {
        case _t.ATAN2:
          t = Wnt;
          break;
        case _t.MAX:
          t = rrt;
          break;
        case _t.MIN:
          t = irt;
          break;
        case _t.MOD:
          t = e ? srt : art;
          break;
        case _t.NOT_EQUAL:
          t = e ? urt : lrt;
          break;
        case _t.POW:
          t = e ? hrt : crt;
          break;
        default:
          continue;
      }
      let r, i, a;
      return e ? (r = "isnanVec4", i = "vec4<f32>", a = "vec4<bool>") : (r = "isnan", i = "f32", a = "bool"), `
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${i}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${i}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${i}(valueForNaN),
            ${a}(isNaN) | aIsNaN | bIsNaN);
      }
    `;
    } while (false);
    switch (n) {
      case _t.ADD:
        t = Vnt;
        break;
      case _t.COMPLEX_MULTIPLY_IMAG:
        t = Unt;
        break;
      case _t.COMPLEX_MULTIPLY_REAL:
        t = Gnt;
        break;
      case _t.DIV:
        t = Hnt;
        break;
      case _t.ELU_DER:
        t = Xnt;
        break;
      case _t.EQUAL:
        t = Ynt;
        break;
      case _t.FLOOR_DIV:
        t = qnt;
        break;
      case _t.GREATER:
        t = jnt;
        break;
      case _t.GREATER_EQUAL:
        t = Knt;
        break;
      case _t.LESS:
        t = Znt;
        break;
      case _t.LESS_EQUAL:
        t = Qnt;
        break;
      case _t.LOGICAL_AND:
        return e ? ert : Jnt;
      case _t.LOGICAL_OR:
        return e ? nrt : trt;
      case _t.MUL:
        t = ort;
        break;
      case _t.PRELU:
        return e ? frt : drt;
      case _t.SQUARED_DIFFERENCE:
        t = prt;
        break;
      case _t.SUB:
        t = grt;
        break;
    }
    return `
    ${t}
    return resultTemp;
  `;
  }
  var De;
  (function(n) {
    n[n.ABS = 0] = "ABS", n[n.ACOS = 1] = "ACOS", n[n.ACOSH = 2] = "ACOSH", n[n.ASIN = 3] = "ASIN", n[n.ASINH = 4] = "ASINH", n[n.ATAN = 5] = "ATAN", n[n.ATANH = 6] = "ATANH", n[n.CEIL = 7] = "CEIL", n[n.COS = 8] = "COS", n[n.COSH = 9] = "COSH", n[n.ELU = 10] = "ELU", n[n.ERF = 11] = "ERF", n[n.EXP = 12] = "EXP", n[n.EXPM1 = 13] = "EXPM1", n[n.FLOOR = 14] = "FLOOR", n[n.IS_FINITE = 15] = "IS_FINITE", n[n.IS_INF = 16] = "IS_INF", n[n.IS_NAN = 17] = "IS_NAN", n[n.LINEAR = 18] = "LINEAR", n[n.LOG = 19] = "LOG", n[n.LOG1P = 20] = "LOG1P", n[n.LOGICAL_NOT = 21] = "LOGICAL_NOT", n[n.NEG = 22] = "NEG", n[n.RELU = 23] = "RELU", n[n.RELU6 = 24] = "RELU6", n[n.LEAKYRELU = 25] = "LEAKYRELU", n[n.RECIPROCAL = 26] = "RECIPROCAL", n[n.ROUND = 27] = "ROUND", n[n.RSQRT = 28] = "RSQRT", n[n.SELU = 29] = "SELU", n[n.SIGMOID = 30] = "SIGMOID", n[n.SIGN = 31] = "SIGN", n[n.SIN = 32] = "SIN", n[n.SINH = 33] = "SINH", n[n.SOFTPLUS = 34] = "SOFTPLUS", n[n.SQRT = 35] = "SQRT", n[n.SQUARE = 36] = "SQUARE", n[n.STEP = 37] = "STEP", n[n.TAN = 38] = "TAN", n[n.TANH = 39] = "TANH", n[n.TO_INT = 40] = "TO_INT";
  })(De || (De = {}));
  const mrt = "return abs(a);", vrt = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`, yrt = `
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`, xrt = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`, brt = "return asinh(a);", wrt = `
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`, _rt = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`, Srt = "return ceil(a);", Crt = "return cos(a);", Irt = `
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`, krt = "return exp(a) - 1.0;", Trt = "if (a >= 0.0) { return a; }  return (exp(a) - 1.0);", Art = `
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`, Drt = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${PI};
  let a1 = ${LI};
  let a2 = ${FI};
  let a3 = ${OI};
  let a4 = ${BI};
  let a5 = ${zI};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`, Rrt = "return exp(a);", $rt = "return floor(a);", Nrt = "return f32(!isnan(a) && !isinf(a));", Ert = "return f32(isinf(a));", Mrt = "return f32(isnan(a));", Prt = "return a;", Lrt = `if (a < 0.0) { return uniforms.NAN; }
  return log(a);`, Frt = `
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`, Ort = "return f32(!(a >= 1.0));", Brt = "return -a;", zrt = "if (a < 0.0) { return uniforms.alpha * a; } return a;", Vrt = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`, Wrt = "return 1.0 / a;", Grt = "return select(a, 0.0, a < 0.0);", Urt = "return clamp(a, 0.0, 6.0);", Hrt = "return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));", Xrt = `
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`, Yrt = "return round(a);", qrt = "return inverseSqrt(a);", jrt = `
  if (a >= 0.0) {
    return ${Rb} * a;
  } else {
    return ${Db} * (exp(a) - 1.0);
  }
`, Krt = "return 1.0 / (1.0 + exp(-1.0 * a));", Zrt = "return sign(a);", Qrt = "return sin(a);", Jrt = `
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`, eit = `
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`, tit = "return sqrt(a);", nit = "return a * a;", rit = `
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`, iit = "return tan(a);", ait = `
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`, sit = "return f32(i32((a)));";
  function _h(n, e) {
    switch (n) {
      case De.ABS:
        return mrt;
      case De.ACOS:
        return vrt;
      case De.ACOSH:
        return yrt;
      case De.ASIN:
        return xrt;
      case De.ASINH:
        return brt;
      case De.ATAN:
        return wrt;
      case De.ATANH:
        return _rt;
      case De.COS:
        return Crt;
      case De.COSH:
        return Irt;
      case De.CEIL:
        return Srt;
      case De.ELU:
        return e ? Art : Trt;
      case De.ERF:
        return Drt;
      case De.EXP:
        return Rrt;
      case De.EXPM1:
        return krt;
      case De.FLOOR:
        return $rt;
      case De.IS_FINITE:
        return Nrt;
      case De.IS_INF:
        return Ert;
      case De.IS_NAN:
        return Mrt;
      case De.LINEAR:
        return Prt;
      case De.LOG:
        return Lrt;
      case De.LOG1P:
        return Frt;
      case De.LOGICAL_NOT:
        return Ort;
      case De.NEG:
        return Brt;
      case De.LEAKYRELU:
        return e ? Vrt : zrt;
      case De.RECIPROCAL:
        return Wrt;
      case De.RELU:
        return e ? Xrt : Grt;
      case De.RELU6:
        return e ? Hrt : Urt;
      case De.ROUND:
        return Yrt;
      case De.RSQRT:
        return qrt;
      case De.SELU:
        return jrt;
      case De.SIGMOID:
        return Krt;
      case De.SIGN:
        return Zrt;
      case De.SIN:
        return Qrt;
      case De.SINH:
        return Jrt;
      case De.SOFTPLUS:
        return eit;
      case De.SQRT:
        return tit;
      case De.SQUARE:
        return nit;
      case De.STEP:
        return rit;
      case De.TAN:
        return iit;
      case De.TANH:
        return ait;
      case De.TO_INT:
        return sit;
      default:
        throw new Error(`BinaryType ${n} is not implemented!`);
    }
  }
  function hu(n, e = false, t = false, r = 3) {
    if (n === null) return "";
    let i = "";
    if (n === "linear") i = _h(De.LINEAR);
    else if (n === "relu") i = _h(De.RELU, t);
    else if (n === "elu") i = _h(De.ELU, t);
    else if (n === "relu6") i = _h(De.RELU6, t);
    else if (n === "prelu") i = LL(_t.PRELU, t);
    else if (n === "sigmoid") i = _h(De.SIGMOID, t);
    else if (n === "leakyrelu") i = _h(De.LEAKYRELU, t);
    else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);
    const s = Bt(t ? 4 : 1);
    let o = "";
    return e ? o = `
      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }` : o = `
      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {
        ${i}
      }`, o;
  }
  function gp(n, e) {
    return `
      ${n ? "value = value + getBiasByOutputCoords(coords);" : ""}
      ${e ? "value = activation(value, coords);" : ""}
      `;
  }
  function wre(n, e, t = false, r = false, i = false, a = 1) {
    B(n && a === 1 || !n, () => `transposeA ${n} is not compatible with component size ${a}`);
    const s = `
      ${n ? "value = getA(batch, col, row);" : "value = getA(batch, row, col);"}

    `, o = e ? "value = getB(batch, col, row);" : "value = getB(batch, row, col);";
    return `
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Bt(a)} {
    var value = ${Bt(a)}(0.0);
    ${t && i ? s : `
    ${n ? "if(row < uniforms.dimAOuter && col < uniforms.dimInner)" : "if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${s}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Bt(a)} {
    var value = ${Bt(a)}(0.0);
    ${o}
    return value;
  }
  `;
  }
  function FL(n, e, t, r, i = false, a = false, s = false, o = 1) {
    return `
  ${wre(t, r, i, a, s, o)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Bt(o)}) {
    ${i && a ? "" : "if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${gp(n, e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `;
  }
  const oit = (n, e) => n ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `, lit = (n, e, t, r) => {
    if (n) return `
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;
    {
      let i = "", a = "";
      for (let s = 0; s < e; s++) i += `let BCached${s} = mm_Bsub[k * ${e} + ${s}][tileCol];`, a += `acc[i] = fma(BCached${s}, vec4<f32>(ACached[${s}]), acc[i]);`;
      return `
      for (var k = 0; k < ${r / e}; k++) {
        ${i}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${a}
        }
      }`;
    }
  };
  function h2(n, e, t = false, r = 32, i = false, a = 32, s = false) {
    const o = e[1] * n[1], l = e[0] * n[0], u = t ? o : r, c = t ? r : o, h = u / e[0], d = r / e[1], f = n[1], p = n[0];
    return B((t && h === 4 && n[1] === 4 || !t && (h === 3 || h === 4)) && u % e[0] === 0 && r % e[1] === 0 && n[0] === 4, () => `If transposeA ${t} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`), `
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${u / h}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l / n[0]}>, ${r}>;

  ${Ne()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${f};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${f};
    let globalCol = i32(globalId.x) * ${p};
    let batch = ${i ? "0" : "i32(globalId.z)"};
    let batchA = ${i || !s ? "batch" : "batch % uniforms.aShape[0]"};
    let batchB = ${i || !s ? "batch" : "batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${o};

    let numTiles = ${i ? `${Math.ceil(a / r)}` : `(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${i ? `i32(globalId.z) * ${a}` : "0"};

    var acc: array<vec4<f32>, ${f}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${oit(t, h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${lit(t, h, f, r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`;
  }
  const rH = (n) => n ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `, uit = (n) => n ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
  function d2(n, e, t = false, r = 32, i = false, a = 32, s = false, o = false) {
    const l = n[1] * e[1], u = n[0] * e[0], c = t ? l : r, h = t ? r : l;
    B(h % e[1] === 0 && c % e[0] === 0 && r % e[1] === 0, () => `tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);
    const d = h / e[1], f = c / e[0], p = r / e[1], g = n[1], m = n[0], v = s ? `
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            ${rH(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${m}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${m}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let ACached = ${t ? `mm_Asub[k][localRow + innerRow * ${e[1]}];` : `mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${m}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      ` : `
  let tileRow = i32(localId.y) * ${g};
  let tileCol = i32(localId.x) * ${m};

  let globalRow = i32(globalId.y) * ${g};
  let globalCol = i32(globalId.x) * ${m};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${f};
  let tileRowB = i32(localId.y) * ${p};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${f}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${rH(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${m}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${m}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${m}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        ${uit(t)}
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${g}; innerRow++) {
    for (var innerCol = 0; innerCol < ${m}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;
    return `
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${r}>;

    ${Ne()} {
      let batch = ${i ? "0" : "i32(globalId.z)"};
      let batchA = ${i || !o ? "batch" : "batch % uniforms.aShape[0]"};
      let batchB = ${i || !o ? "batch" : "batch % uniforms.bShape[0]"};
      let numTiles = ${i ? `${Math.ceil(a / r)}` : `(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${i ? `i32(globalId.z) * ${a}` : "0"};

      var acc : array<array<f32, ${m}>, ${g}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        for (var innerCol = 0; innerCol < ${m}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${v}
    }
  `;
  }
  const cit = (n) => n ? `
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  ` : `
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;
  function hit(n, e = false) {
    B(n[1] === 1 && n[2] === 1, () => `A linear work group size is required. But got ${n}.`);
    const t = n[0] * 4;
    return `
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${Ne()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${cit(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t / 4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `;
  }
  class dit {
    constructor(e, t, r = false, i = false, a = null, s = null, o = null, l = false) {
      this.variableNames = [
        "A",
        "B"
      ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = t, this.dispatchLayout = {
        x: [
          2
        ],
        y: [
          1
        ],
        z: [
          0
        ]
      };
      const u = r ? e[1] : e[2];
      if (this.isVec4 = (u % 4 === 0 && !r || t[1] % 4 === 0 && r) && t[2] % 4 === 0 && !i, this.outputComponent = this.isVec4 ? 4 : 1, this.isVectorA = t[1] === 1 && !r, !this.isVec4 && this.isVectorA) this.elementsPerThread = [
        1,
        1,
        1
      ], this.workgroupSize = [
        32,
        1,
        1
      ];
      else {
        const d = Ont(t[1], u, t[2], r);
        this.workgroupSize = d.workgroupSize, this.elementsPerThread = d.elementsPerThread;
      }
      this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);
      const c = a != null, h = o != null;
      c && this.variableNames.push("bias"), h && this.variableNames.push("preluActivationWeights"), this.sequentialAccessByThreads = l, this.transposeA = r, this.transposeB = i, this.addBias = c, this.activation = s, this.hasPreluActivationWeights = h, [this.fitAOuter, this.fitBOuter, this.fitInner] = this.getShapeFit(t[1], t[2], u), this.shaderKey = `matMulPacked_${this.elementsPerThread}_${r}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`;
    }
    getShapeFit(e, t, r) {
      const i = this.workgroupSize[1] * this.elementsPerThread[1], a = this.workgroupSize[0] * this.elementsPerThread[0];
      !this.isVec4 && this.isVectorA ? this.tileInner = this.workgroupSize[0] * 4 : this.tileInner = a;
      const s = e % i === 0, o = t % a === 0, l = r % this.tileInner === 0;
      return [
        s,
        o,
        l
      ];
    }
    getUserCode() {
      return `
      ${hu(this.activation, this.hasPreluActivationWeights, this.isVec4)}
      ${FL(this.addBias, this.activation, false, this.transposeB, this.fitAOuter, this.fitBOuter, this.fitInner, this.isVec4 ? 4 : 1)}
      ${this.isVec4 ? h2(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, true) : this.isVectorA ? hit(this.workgroupSize, this.transposeA) : d2(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, this.sequentialAccessByThreads, true)}
    `;
    }
  }
  function fit(n) {
    return `
    var<workgroup> sumValues : array<f32, ${n}>;
    ${Ne()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n / 2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `;
  }
  class pit {
    constructor(e, t = false, r = false, i = null, a = null, s = null) {
      this.variableNames = [
        "A",
        "B"
      ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [
        256,
        1,
        1
      ], this.outputShape = e, this.dispatchLayout = {
        x: [],
        y: [
          1,
          2
        ],
        z: [
          0
        ]
      }, this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize);
      const o = i != null, l = s != null;
      o && this.variableNames.push("bias"), l && this.variableNames.push("preluActivationWeights"), this.transposeA = t, this.transposeB = r, this.addBias = o, this.activation = a, this.hasPreluActivationWeights = l, this.shaderKey = `matMulReduce_${this.activation}_${t}_${r}`;
    }
    getUserCode() {
      return `
      ${hu(this.activation, this.hasPreluActivationWeights)}
      ${FL(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${fit(this.workgroupSize[0])}
    `;
    }
  }
  function git(n) {
    const e = n[1], t = n[0], r = e > t ? e : t;
    return `
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ne()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `;
  }
  class mit {
    constructor(e, t, r, i = false, a = false, s = null, o = null, l = null) {
      this.variableNames = [
        "A",
        "B"
      ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [
        16,
        8,
        1
      ], this.outputShape = r, this.dispatchLayout = {
        x: [
          2
        ],
        y: [
          1
        ],
        z: [
          0
        ]
      }, this.dispatch = [
        Math.ceil(r[2] / this.workgroupSize[0]),
        Math.ceil(r[1] / this.workgroupSize[1]),
        r[0]
      ];
      const u = s != null;
      u && this.variableNames.push("bias");
      const c = l != null;
      c && this.variableNames.push("preluActivationWeights"), this.transposeA = i, this.transposeB = a, this.addBias = u, this.activation = o, this.hasPreluActivationWeights = c, this.shaderKey = `matMulSmallOutputSize_${this.activation}_${i}_${a}`;
    }
    getUserCode() {
      return `
      ${hu(this.activation, this.hasPreluActivationWeights)}
      ${FL(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${git(this.workgroupSize)}
    `;
    }
  }
  class vit {
    constructor(e, t, r = false, i = false) {
      this.variableNames = [
        "A",
        "B"
      ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [
        8,
        8,
        1
      ], this.atomic = true, this.splitedDimInner = 128, B(e[0] === 1, () => "MatMulSplitKProgram only supports batch = 1."), this.outputShape = e, this.dispatchLayout = {
        x: [
          2
        ],
        y: [
          1
        ],
        z: [
          0,
          3
        ]
      };
      const a = (r && this.outputShape[1] % 4 === 0 || !r && t % 4 === 0) && this.outputShape[2] % 4 === 0;
      this.elementsPerThread = [
        4,
        4,
        this.splitedDimInner
      ], this.outputComponent = a ? 4 : 1, a || (this.outputShape[1] < 16 && (this.elementsPerThread[1] = 1), this.outputShape[2] < 16 && (this.elementsPerThread[0] = 1)), this.dispatch = Ee(this.dispatchLayout, [
        this.outputShape[0],
        this.outputShape[1],
        this.outputShape[2],
        t
      ], this.workgroupSize, this.elementsPerThread), this.transposeA = r, this.transposeB = i, this.shaderKey = `matMulSplitK_${r}_${i}_${this.elementsPerThread}_${this.outputComponent}`;
    }
    getUserCode() {
      const e = this.outputComponent;
      return `
      ${wre(false, this.transposeB, false, false, false, e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Bt(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Nc("&result[flatIndex + i]", `${e > 1 ? "value[i]" : "value"}`, "float32")}
          }
        }
      }
      ${e === 4 ? h2(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) : d2(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner)}
    `;
    }
  }
  class yit {
    constructor(e, t = null, r = null, i = null) {
      this.uniforms = "", this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.addBias = t != null, this.hasPreluActivationWeights = i != null, this.activation = r, this.addBias && this.variableNames.push("bias"), this.hasPreluActivationWeights && this.variableNames.push("preluActivationWeights"), this.shaderKey = `biasActivation_${r}`;
    }
    getUserCode() {
      return `
    ${hu(this.activation, this.hasPreluActivationWeights)}
    ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${gp(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
    }
  }
  class xit {
    constructor(e) {
      this.variableNames = [], this.outputShape = [], this.uniforms = "value : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "fill";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `;
    }
  }
  function ea(n) {
    const { backend: e, attrs: t } = n, { shape: r, value: i } = t;
    let { dtype: a } = t;
    if (a = a || yc(i), a === "string") {
      const s = ir(a, X(r));
      return s.fill(i), e.makeTensorInfo(r, a, s);
    } else {
      const s = new xit(r), o = [
        {
          type: "float32",
          data: [
            i
          ]
        }
      ];
      return e.runWebGPUProgram(s, [], a, o);
    }
  }
  const bit = {
    kernelName: rb,
    backendName: "webgpu",
    kernelFunc: ea
  };
  function Je(n) {
    const { inputs: e, attrs: t } = n, { x: r } = e, { shape: i } = t, a = X(r.shape), s = QC(i, a), o = X(s);
    return B(a === o, () => `The new shape (${s}) has ${o} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`), n.backend.incRef(r.dataId), {
      dataId: r.dataId,
      shape: s,
      dtype: r.dtype
    };
  }
  const wit = {
    kernelName: uv,
    backendName: "webgpu",
    kernelFunc: Je
  };
  function f2({ a: n, b: e, transposeA: t, transposeB: r, backend: i, bias: a = null, preluActivationWeights: s = null, leakyreluAlpha: o = 0, activation: l = null }) {
    const u = n.shape.length, c = e.shape.length, h = t ? n.shape[u - 2] : n.shape[u - 1], d = r ? e.shape[c - 1] : e.shape[c - 2], f = t ? n.shape[u - 1] : n.shape[u - 2], p = r ? e.shape[c - 2] : e.shape[c - 1], g = n.shape.slice(0, -2), m = e.shape.slice(0, -2), v = X(g), y = X(m), b = ht(n.shape.slice(0, -2), e.shape.slice(0, -2)).concat([
      f,
      p
    ]);
    B(h === d, () => `Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);
    const w = t ? [
      v,
      h,
      f
    ] : [
      v,
      f,
      h
    ], _ = r ? [
      y,
      p,
      d
    ] : [
      y,
      d,
      p
    ], S = Je({
      inputs: {
        x: n
      },
      backend: i,
      attrs: {
        shape: w
      }
    }), I = Je({
      inputs: {
        x: e
      },
      backend: i,
      attrs: {
        shape: _
      }
    }), C = [
      S,
      I
    ], T = Math.max(v, y), k = [
      S,
      I
    ], D = [
      {
        type: "int32",
        data: [
          f
        ]
      },
      {
        type: "int32",
        data: [
          p
        ]
      },
      {
        type: "int32",
        data: [
          h
        ]
      }
    ];
    let R, N;
    const E = [
      T,
      f,
      p
    ];
    let A = ne().get("WEBGPU_MATMUL_PROGRAM_TYPE");
    if (A < 0) {
      const $ = ne().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), L = $ > 0 ? $ : i.thresholdToIncreaseWorkgroups, F = T * Math.ceil(f / 32) * Math.ceil(p / 32);
      F <= L || f <= 8 && F <= L * 2 ? T * f * p <= 128 ? A = Ro.MatMulReduceProgram : T === 1 && d >= 2e3 ? A = Ro.MatMulSplitKProgram : A = Ro.MatMulSmallOutputSizeProgram : A = Ro.MatMulPackedProgram;
    }
    switch (A) {
      case Ro.MatMulReduceProgram:
        R = new pit(E, t, r, a, l, s);
        break;
      case Ro.MatMulSplitKProgram: {
        if (N = ea({
          backend: i,
          attrs: {
            shape: E,
            value: 0,
            dtype: n.dtype
          }
        }), R = new vit(E, d, t, r), a || l) {
          N = i.runWebGPUProgram(R, k, n.dtype, D, N);
          const L = new yit(N.shape, a, l, s);
          let F = null;
          const O = [
            N
          ];
          a && O.push(a), s && O.push(s), l === "leakyrelu" && (F = [
            {
              type: "float32",
              data: [
                o
              ]
            }
          ], L.uniforms += " alpha : f32,");
          const z = i.runWebGPUProgram(L, O, N.dtype, F);
          C.push(N);
          const V = Je({
            inputs: {
              x: z
            },
            backend: i,
            attrs: {
              shape: b
            }
          });
          C.push(z);
          for (const H of C) i.disposeData(H.dataId);
          return V;
        }
        break;
      }
      case Ro.MatMulSmallOutputSizeProgram:
        R = new mit(w, _, E, t, r, a, l, s);
        break;
      case Ro.MatMulPackedProgram:
        const $ = i.adapterInfo.isIntel();
        R = new dit(w, E, t, r, a, l, s, $);
        break;
      default:
        throw new Error(`Unsupported MatMulProgramType ${A}.`);
    }
    a && k.push(a), s && k.push(s), l === "leakyrelu" && (D.push({
      type: "float32",
      data: [
        o
      ]
    }), R.uniforms += " alpha : f32,"), N = i.runWebGPUProgram(R, k, n.dtype, D, N);
    const M = Je({
      inputs: {
        x: N
      },
      backend: i,
      attrs: {
        shape: b
      }
    });
    C.push(N);
    for (const $ of C) i.disposeData($.dataId);
    return M;
  }
  function _it(n) {
    const { inputs: e, backend: t, attrs: r } = n, { a: i, b: a, bias: s, preluActivationWeights: o } = e, { transposeA: l, transposeB: u, activation: c, leakyreluAlpha: h } = r;
    return f2({
      a: i,
      b: a,
      transposeA: l,
      transposeB: u,
      backend: t,
      bias: s,
      preluActivationWeights: o,
      leakyreluAlpha: h,
      activation: c
    });
  }
  const Sit = {
    kernelName: vd,
    backendName: "webgpu",
    kernelFunc: _it
  };
  class iH {
    constructor(e, t, r) {
      this.variableNames = [
        "AReal",
        "AImag",
        "BReal",
        "BImag"
      ], this.workgroupSize = [
        128,
        1,
        1
      ], this.size = true, this.outputShape = ht(t, r), this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `binaryOpComplex_${e}`, this.op = e;
    }
    getUserCode() {
      return `
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${LL(this.op, false)}
      }

      ${Ne("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;
    }
  }
  class eC {
    constructor(e, t, r) {
      if (this.size = true, this.variableNames = [
        "A",
        "B"
      ], this.outputShape = ht(t, r), this.dispatchLayout = We(this.outputShape), this.op = e, this.useSharedMemoryWithA = t.length <= 1 && r.length > 1 && t[0] < 128, this.useSharedMemoryWithB = r.length <= 1 && t.length > 1 && r[0] < 128, this.useSharedMemoryWithA || this.useSharedMemoryWithB) this.outputComponent = 1, this.variableComponents = [
        1,
        1
      ], this.lastDimensionSize = this.useSharedMemoryWithB ? r[0] : t[0], this.shaderKey = `binary_${e}_${this.lastDimensionSize}`, this.type = "shared", this.workgroupSize = [
        256,
        1,
        1
      ];
      else {
        const i = t.length > 0 && t[t.length - 1] % 4 === 0, a = r.length > 0 && r[r.length - 1] % 4 === 0;
        i && a ? (this.outputComponent = 4, this.variableComponents = [
          4,
          4
        ]) : i && (t4(r) || r[r.length - 1] === 1) || a && (t4(t) || t[t.length - 1] === 1) ? (this.outputComponent = 4, this.variableComponents = i ? [
          4,
          1
        ] : [
          1,
          4
        ]) : (this.outputComponent = 1, this.variableComponents = [
          1,
          1
        ]), this.type = "nonshared", this.shaderKey = `binary_${e}_${this.variableComponents}`, this.workgroupSize = [
          128,
          1,
          1
        ];
      }
      this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.outputComponent,
        1,
        1
      ]);
    }
    getUserCode() {
      let e;
      const t = this.outputComponent === 4 ? "vec4<f32>" : "f32", r = `
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${LL(this.op, this.outputComponent === 4)}
    };
    `;
      if (this.type === "shared") {
        const i = this.lastDimensionSize > 1 ? `coords[${this.outputShape.length - 1}]` : "0", a = this.useSharedMemoryWithB ? `let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];` : `let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;
        e = `
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ne("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? "B" : "A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${a}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `;
      } else e = `
       ${r}
       ${Ne("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;
      return e;
    }
  }
  function Aa(n) {
    const { inputs: e } = n, { x: t } = e;
    return n.backend.incRef(t.dataId), {
      dataId: t.dataId,
      shape: t.shape,
      dtype: t.dtype
    };
  }
  const Cit = {
    kernelName: vf,
    backendName: "webgpu",
    kernelFunc: Aa
  };
  function mp(n) {
    const { inputs: e, backend: t } = n, { real: r, imag: i } = e, a = t.makeTensorInfo(r.shape, "complex64"), s = t.tensorMap.get(a.dataId), o = Aa({
      inputs: {
        x: r
      },
      backend: t
    }), l = Aa({
      inputs: {
        x: i
      },
      backend: t
    });
    return s.complexTensorInfos = {
      real: o,
      imag: l
    }, a;
  }
  const Iit = {
    kernelName: tI,
    backendName: "webgpu",
    kernelFunc: mp
  };
  class Ov {
    constructor(e, t, r = "") {
      this.variableNames = [
        "A"
      ], this.size = true;
      const i = 128;
      this.workgroupSize = [
        i,
        1,
        1
      ], this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.op = t, r !== "" && (this.uniforms = r), this.shaderKey = `unary_${t}`;
    }
    getUserCode() {
      return `
      fn unaryOperation(a : f32) -> f32 {
        ${_h(this.op, false)}
      }
      ${Ne("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `;
    }
  }
  function hn({ opType: n, cpuKernelImpl: e, dtype: t }) {
    return ({ inputs: r, backend: i }) => {
      const { x: a } = r, s = i, o = t || a.dtype;
      if (s.shouldExecuteOnCPU([
        a
      ]) && e != null) {
        const u = s.tensorMap.get(a.dataId), c = e(u.values, o);
        return s.makeTensorInfo(a.shape, o, c);
      }
      const l = new Ov(a.shape, n);
      return s.runWebGPUProgram(l, [
        a
      ], o);
    };
  }
  function jr({ opType: n, cpuKernelImpl: e, supportsComplex: t = false, dtype: r }) {
    return ({ inputs: i, backend: a }) => {
      const { a: s, b: o } = i, l = a;
      if (t && s.dtype === "complex64") {
        const h = l.tensorMap.get(s.dataId), d = l.tensorMap.get(o.dataId);
        let f, p;
        if (n !== _t.MUL) [f, p] = [
          [
            h.complexTensorInfos.real,
            d.complexTensorInfos.real
          ],
          [
            h.complexTensorInfos.imag,
            d.complexTensorInfos.imag
          ]
        ].map((m) => {
          const [v, y] = m, x = {
            dataId: v.dataId,
            dtype: v.dtype,
            shape: s.shape
          }, b = {
            dataId: y.dataId,
            dtype: y.dtype,
            shape: o.shape
          }, w = new eC(n, s.shape, o.shape);
          return l.runWebGPUProgram(w, [
            x,
            b
          ], qr(v.dtype, y.dtype));
        });
        else {
          const m = new iH(_t.COMPLEX_MULTIPLY_REAL, s.shape, o.shape), v = new iH(_t.COMPLEX_MULTIPLY_IMAG, s.shape, o.shape), y = [
            {
              dataId: h.complexTensorInfos.real.dataId,
              dtype: h.complexTensorInfos.real.dtype,
              shape: s.shape
            },
            {
              dataId: h.complexTensorInfos.imag.dataId,
              dtype: h.complexTensorInfos.imag.dtype,
              shape: s.shape
            },
            {
              dataId: d.complexTensorInfos.real.dataId,
              dtype: d.complexTensorInfos.real.dtype,
              shape: o.shape
            },
            {
              dataId: d.complexTensorInfos.imag.dataId,
              dtype: d.complexTensorInfos.imag.dtype,
              shape: o.shape
            }
          ];
          f = l.runWebGPUProgram(m, y, "float32"), p = l.runWebGPUProgram(v, y, "float32");
        }
        const g = mp({
          inputs: {
            real: f,
            imag: p
          },
          backend: l
        });
        return l.disposeData(f.dataId), l.disposeData(p.dataId), g;
      }
      const u = r || qr(s.dtype, o.dtype);
      if ((s.dtype === "string" || o.dtype === "string" || l.shouldExecuteOnCPU([
        s,
        o
      ])) && e != null) {
        const h = l.tensorMap.get(s.dataId).values, d = l.tensorMap.get(o.dataId).values, f = s.dtype === "string" ? so(h) : h, p = s.dtype === "string" ? so(d) : d, [g, m] = e(s.shape, o.shape, f, p, u);
        return l.makeTensorInfo(m, u, g);
      }
      const c = new eC(n, s.shape, o.shape);
      return l.runWebGPUProgram(c, [
        s,
        o
      ], u);
    };
  }
  const { addImpl: kit, castImpl: Tit, ceilImpl: Ait, concatImpl: Dit, equalImpl: Rit, expImpl: $it, expm1Impl: Nit, floorImpl: Eit, floorDivImpl: Mit, gatherNdImpl: Pit, gatherV2Impl: Lit, greaterEqualImpl: Fit, greaterImpl: Oit, lessEqualImpl: Bit, lessImpl: zit, logImpl: Vit, maxImpl: Wit, maximumImpl: Git, minimumImpl: Uit, multiplyImpl: Hit, negImpl: Xit, notEqualImpl: Yit, prodImpl: qit, rangeImpl: jit, rsqrtImpl: Kit, scatterImpl: Zit, simpleAbsImpl: Qit, sliceImpl: Jit, stridedSliceImpl: eat, stringNGramsImpl: tat, subImpl: nat, tileImpl: rat, topKImpl: iat, transposeImpl: aat } = Aee;
  const sat = hn({
    opType: De.ABS,
    cpuKernelImpl: Qit
  }), oat = {
    kernelName: Dm,
    backendName: "webgpu",
    kernelFunc: sat
  };
  const lat = hn({
    opType: De.ACOS
  }), uat = {
    kernelName: Wd,
    backendName: "webgpu",
    kernelFunc: lat
  };
  const cat = hn({
    opType: De.ACOSH
  }), hat = {
    kernelName: Gd,
    backendName: "webgpu",
    kernelFunc: cat
  };
  const dat = jr({
    opType: _t.ADD,
    cpuKernelImpl: kit,
    supportsComplex: true
  }), fat = {
    kernelName: xc,
    backendName: "webgpu",
    kernelFunc: dat
  };
  class pat {
    constructor(e) {
      this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e[0], this.variableNames = e.map((t, r) => `T${r}`), this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.shaderKey = "addN";
    }
    getUserCode() {
      const e = [];
      this.variableNames.forEach((i) => {
        e.push(`let v${i} = get${i}ByOutputCoords(coords);`);
      });
      const t = this.variableNames.map((i) => `v${i}`).join(" + ");
      return `
      ${Ne("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `;
    }
  }
  function gat(n) {
    const { inputs: e, backend: t } = n, r = e;
    if (r.length === 1) return Aa({
      inputs: {
        x: r[0]
      },
      backend: t
    });
    const i = r.map((o) => o.dtype).reduce((o, l) => qr(o, l)), a = r.map((o) => o.shape), s = new pat(a);
    return t.runWebGPUProgram(s, r, i);
  }
  const mat = {
    kernelName: Rm,
    backendName: "webgpu",
    kernelFunc: gat
  };
  class vat {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.workgroupSize = [
        16,
        16,
        1
      ];
      const r = new Array(e.length);
      for (let i = 0; i < r.length; i++) r[i] = e[t[i]];
      this.outputShape = r, this.dispatchLayout = {
        x: [
          0
        ],
        y: [
          1
        ]
      }, this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        1,
        1,
        1
      ]), this.shaderKey = "transposeShared";
    }
    getUserCode() {
      B(this.workgroupSize[0] === this.workgroupSize[1], () => `Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);
      const e = this.workgroupSize[0];
      return `
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0] + 1}>, ${this.workgroupSize[0]}>;
      ${Ne()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;
    }
  }
  class yat {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true;
      const r = new Array(e.length);
      for (let i = 0; i < r.length; i++) r[i] = e[t[i]];
      this.outputShape = r, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.newDim = t, this.shaderKey = `transpose_${t}`;
    }
    getUserCode() {
      const e = lr(this.outputShape.length), t = _re(this.newDim);
      return `
      ${Ne("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `;
    }
  }
  function _re(n) {
    const e = n.length;
    if (e > 6) throw Error(`Transpose for rank ${e} is not yet supported`);
    const t = new Array(e);
    for (let r = 0; r < n.length; r++) t[n[r]] = `coords.${Vl(r)}`;
    return t.join();
  }
  function ll(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { perm: a } = r, s = t, o = i.shape.length, l = new Array(o);
    for (let c = 0; c < l.length; c++) l[c] = i.shape[a[c]];
    if (t.shouldExecuteOnCPU([
      i
    ])) {
      const h = s.tensorMap.get(i.dataId).values, d = aat(h, i.shape, i.dtype, a, l);
      return t.makeTensorInfo(l, i.dtype, d);
    }
    if (i.shape.length === 2 && Jt(a, [
      1,
      0
    ])) {
      const c = new vat(i.shape, a);
      return s.runWebGPUProgram(c, [
        i
      ], i.dtype);
    }
    const u = new yat(i.shape, a);
    return s.runWebGPUProgram(u, [
      i
    ], i.dtype);
  }
  const xat = {
    kernelName: Ol,
    backendName: "webgpu",
    kernelFunc: ll
  };
  class bat {
    constructor(e, t, r) {
      this.variableNames = [
        "x"
      ], this.uniforms = "reduceSize : i32,", this.size = true, this.inputShape = [
        e.batchSize,
        e.inSize
      ];
      const [i] = Ln(this.inputShape, [
        1
      ]);
      this.outputShape = i.length === 0 ? [
        1
      ] : i, e.inSize >= 32768 && r >= 512 ? this.workgroupSize = [
        512,
        1,
        1
      ] : e.inSize >= 4096 ? this.workgroupSize = [
        256,
        1,
        1
      ] : this.workgroupSize = [
        64,
        1,
        1
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, [
        1,
        1,
        1
      ]), this.reduceType = t, this.shaderKey = `reduce_${t}`;
    }
    getUserCode() {
      let e = "", t = "0.0";
      const r = this.workgroupSize[0];
      this.reduceType === "min" || this.reduceType === "max" ? (e = `
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType === "min" ? "<" : ">"} bestValue)
           {  bestValue = candidate; }`, t = "f32(x[offset])") : this.reduceType === "sum" || this.reduceType === "mean" ? e = " bestValue = bestValue + candidate; " : this.reduceType === "prod" ? (e = " bestValue = bestValue * candidate; ", t = "1.0") : this.reduceType === "all" ? (e = " bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ", t = "1.0") : this.reduceType === "any" && (e = " bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ", t = "0.0");
      const i = this.reduceType === "mean" ? "setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));" : "setOutputAtIndex(outputIndex, bestValue);";
      return `
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length === 1 ? "outputCoords" : "outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ne("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `;
    }
  }
  const wat = {
    mean: "float32",
    all: "bool",
    any: "bool"
  };
  function vp(n, e, t, r, i) {
    const a = n.shape.length, s = [], o = yt(e, n.shape);
    let l = o;
    const u = bn(l, a);
    let c = n;
    u != null && (c = ll({
      inputs: {
        x: n
      },
      attrs: {
        perm: u
      },
      backend: i
    }), l = gn(l.length, a), s.push(c)), Tn(r, l, a);
    const [h, d] = Ln(c.shape, l);
    let f = h;
    t && (f = Mn(h, o));
    let p;
    if ((r === "max" || r === "prod") && i.shouldExecuteOnCPU([
      c
    ])) {
      const g = i.tensorMap.get(c.dataId).values;
      switch (r) {
        case "max":
          const m = Wit(g, X(d), f, n.dtype);
          p = i.makeTensorInfo(f, n.dtype, m);
          break;
        case "prod":
          const { outVals: v, outShape: y, outDtype: x } = qit(c.shape, c.dtype, g, l);
          p = i.makeTensorInfo(y, x, v);
          break;
        default:
          throw new Error(`${r} CPU implementation is not yet supported.`);
      }
    } else {
      const g = X(d), v = X(c.shape) / g, y = {
        windowSize: g,
        inSize: g,
        batchSize: v,
        outSize: 1
      }, x = wat[r] || xI(n.dtype), b = [
        {
          type: "int32",
          data: [
            g
          ]
        }
      ], w = new bat(y, r, i.device.limits.maxComputeWorkgroupSizeX), _ = i.runWebGPUProgram(w, [
        c
      ], x, b);
      s.push(_), p = Je({
        inputs: {
          x: _
        },
        attrs: {
          shape: f
        },
        backend: i
      });
    }
    return s.forEach((g) => i.disposeData(g.dataId)), p;
  }
  function _at(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { keepDims: a, axis: s } = r;
    return vp(i, s, a, "all", t);
  }
  const Sat = {
    kernelName: $m,
    backendName: "webgpu",
    kernelFunc: _at
  };
  function Cat(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { keepDims: a, axis: s } = r;
    return vp(i, s, a, "any", t);
  }
  const Iat = {
    kernelName: Nm,
    backendName: "webgpu",
    kernelFunc: Cat
  };
  class Sre {
    constructor(e, t, r) {
      this.workgroupSize = [
        64,
        1,
        1
      ], this.variableNames = [
        "x"
      ], this.uniforms = "infinityValue : f32,", this.size = true;
      const i = [
        t
      ];
      this.op = r === "min" ? "<" : ">";
      const [a, s] = Ln(e, i);
      this.outputShape = a.length === 0 ? [
        1
      ] : a, this.dispatchLayout = We(this.outputShape), X(s) < 32 ? (this.type = "plain", this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize)) : (this.type = "shared", this.dispatch = Ee(this.dispatchLayout, this.outputShape, [
        1,
        1,
        1
      ])), this.inputShape = e, this.shaderKey = `argMinMax_${this.op}_${this.type}`;
    }
    getUserCode() {
      const e = this.workgroupSize[0], t = () => this.inputShape.length === 1 ? "uniforms.xShape" : `uniforms.xShape.${Vl(this.inputShape.length - 1)}`, r = () => {
        let i = "";
        if (this.outputShape.length === 1) this.inputShape.length !== 1 && (i += "outputCoords,");
        else for (let a = 0; a < this.outputShape.length; a++) i += `outputCoords.${Vl(a)},`;
        return i;
      };
      return this.type === "shared" ? `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Ne("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    ` : `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;
    }
  }
  function kat(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a } = r;
    let s = yt(a, i.shape);
    const o = bn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = ll({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: o
      }
    }), u.push(l), s = gn(s.length, l.shape.length)), Tn("argMax", [
      s[0]
    ], l.shape.length);
    const c = new Sre(l.shape, s[0], "max"), h = [
      {
        type: "float32",
        data: [
          Number.NEGATIVE_INFINITY
        ]
      }
    ], d = t.runWebGPUProgram(c, [
      l
    ], "int32", h);
    return u.forEach((f) => t.disposeData(f.dataId)), d;
  }
  const Tat = {
    kernelName: Em,
    backendName: "webgpu",
    kernelFunc: kat
  };
  function Aat(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a } = r;
    let s = yt(a, i.shape);
    const o = bn(s, i.shape.length);
    let l = i;
    const u = [];
    o != null && (l = ll({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: o
      }
    }), u.push(l), s = gn(s.length, l.shape.length)), Tn("argMin", [
      s[0]
    ], l.shape.length);
    const c = new Sre(l.shape, s[0], "min"), h = [
      {
        type: "float32",
        data: [
          Number.POSITIVE_INFINITY
        ]
      }
    ], d = t.runWebGPUProgram(c, [
      l
    ], "int32", h);
    return u.forEach((f) => t.disposeData(f.dataId)), d;
  }
  const Dat = {
    kernelName: Mm,
    backendName: "webgpu",
    kernelFunc: Aat
  };
  const Rat = hn({
    opType: De.ASIN
  }), $at = {
    kernelName: Ud,
    backendName: "webgpu",
    kernelFunc: Rat
  };
  const Nat = hn({
    opType: De.ASINH
  }), Eat = {
    kernelName: Hd,
    backendName: "webgpu",
    kernelFunc: Nat
  };
  const Mat = hn({
    opType: De.ATAN
  }), Pat = {
    kernelName: Xd,
    backendName: "webgpu",
    kernelFunc: Mat
  };
  const Lat = jr({
    opType: _t.ATAN2
  }), Fat = {
    kernelName: qd,
    backendName: "webgpu",
    kernelFunc: Lat
  };
  const Oat = hn({
    opType: De.ATANH
  }), Bat = {
    kernelName: Yd,
    backendName: "webgpu",
    kernelFunc: Oat
  };
  class zat {
    constructor(e) {
      this.variableNames = [
        "x"
      ], this.uniforms = "strides : vec2<i32>,", this.workgroupSize = [
        256,
        1,
        1
      ], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "poolWithFilterSizeEqualsOne";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `;
    }
  }
  class yx {
    constructor(e, t, r = false, i = false, a = false) {
      if (this.variableNames = [
        "x"
      ], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,", this.workgroupSize = [
        128,
        1,
        1
      ], this.size = true, t === "avg" && r) throw new Error("Cannot compute positions for average pool.");
      this.outputShape = e.outShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.poolType = t, this.computePositions = r, this.flattenPositions = i, this.includeBatchIndex = a, this.shaderKey = `pool2D_${t}_${r}_${i}_${a}`;
    }
    getUserCode() {
      let e;
      this.poolType === "avg" ? e = "resultValue = resultValue + value; count = count + 1.0;" : this.computePositions ? e = `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "wR * uniforms.filterDims.y + wC"};
      }` : e = "resultValue = max(value, resultValue);";
      let t = "resultValue";
      return this.poolType === "avg" && (t = "resultValue / max(count, 1.0)"), `
      ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t});`}
        }
      }
    `;
    }
  }
  class OL {
    constructor(e, t, r = false, i = false, a = false) {
      if (this.variableNames = [
        "x"
      ], this.uniforms = "strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,", this.workgroupSize = [
        128,
        1,
        1
      ], this.size = true, t === "avg" && r) throw new Error("Cannot compute positions for average pool.");
      this.outputShape = e.outShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.poolType = t, this.computePositions = r, this.flattenPositions = i, this.includeBatchIndex = a, this.shaderKey = `pool3D_${t}_${r}_${i}_${a}`;
    }
    getUserCode() {
      let e;
      this.poolType === "avg" ? e = "resultValue += value; count += 1.0;" : this.computePositions ? e = `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }` : e = "resultValue = max(value, resultValue);";
      let t = "resultValue";
      return this.poolType === "avg" && (t = "resultValue / max(count, 1.0)"), `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t});`}
        }
      }
    `;
    }
  }
  function Cre(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { reductionIndices: a, keepDims: s } = r;
    return vp(i, a, s, "max", t);
  }
  const Vat = {
    kernelName: If,
    backendName: "webgpu",
    kernelFunc: Cre
  };
  function Ire(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { keepDims: a, axis: s } = r;
    return vp(i, s, a, "mean", t);
  }
  const Wat = {
    kernelName: Af,
    backendName: "webgpu",
    kernelFunc: Ire
  };
  function kre(n, e, t, r) {
    if (e.filterWidth === 1 && e.filterHeight === 1 && Jt(e.inShape, e.outShape)) return Aa({
      inputs: {
        x: n
      },
      backend: r
    });
    if (e.filterWidth === e.inWidth && e.filterHeight === e.inHeight && e.batchSize === 1 && e.padInfo.type === "VALID") {
      const s = n.shape.length, o = Je({
        inputs: {
          x: n
        },
        backend: r,
        attrs: {
          shape: [
            n.shape[s - 3] * n.shape[s - 2],
            n.shape[s - 1]
          ]
        }
      });
      let l;
      t === "avg" ? l = Ire({
        inputs: {
          x: o
        },
        backend: r,
        attrs: {
          axis: 0,
          keepDims: false
        }
      }) : (B(t === "max", () => `Invalid pool type ${t}`), l = Cre({
        inputs: {
          x: o
        },
        backend: r,
        attrs: {
          reductionIndices: 0,
          keepDims: false
        }
      }));
      const u = Je({
        inputs: {
          x: l
        },
        backend: r,
        attrs: {
          shape: e.outShape
        }
      });
      return r.disposeData(o.dataId), r.disposeData(l.dataId), u;
    }
    let i;
    const a = [
      {
        type: "int32",
        data: [
          e.strideHeight,
          e.strideWidth
        ]
      }
    ];
    return e.filterHeight === 1 && e.filterWidth === 1 ? i = new zat(e) : (t === "avg" ? i = new yx(e, "avg") : (B(t === "max", () => `Invalid pool type ${t}`), i = new yx(e, "max")), a.push({
      type: "int32",
      data: [
        e.padInfo.top,
        e.padInfo.left
      ]
    }, {
      type: "int32",
      data: [
        e.dilationHeight,
        e.dilationWidth
      ]
    }, {
      type: "int32",
      data: [
        e.inHeight,
        e.inWidth
      ]
    }, {
      type: "int32",
      data: [
        e.effectiveFilterHeight,
        e.effectiveFilterWidth
      ]
    })), r.runWebGPUProgram(i, [
      n
    ], n.dtype, a);
  }
  function Gat(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, c = dr(i.shape, a, s, 1, o, l);
    return kre(i, c, "avg", t);
  }
  const Uat = {
    kernelName: jd,
    backendName: "webgpu",
    kernelFunc: Gat
  };
  function Hat(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dataFormat: l, dimRoundingMode: u } = r, c = [
      1,
      1,
      1
    ], h = vi(i.shape, a, s, c, o, u, l), d = new OL(h, "avg"), f = [
      {
        type: "int32",
        data: [
          h.strideDepth,
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.padInfo.front,
          h.padInfo.top,
          h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.inDepth,
          h.inHeight,
          h.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.effectiveFilterDepth,
          h.effectiveFilterHeight,
          h.effectiveFilterWidth
        ]
      }
    ];
    return t.runWebGPUProgram(d, [
      i
    ], i.dtype, f);
  }
  const Xat = {
    kernelName: Pm,
    backendName: "webgpu",
    kernelFunc: Hat
  };
  class Yat {
    constructor(e) {
      this.variableNames = [
        "dy"
      ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "avgPool2DBackprop";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  class qat {
    constructor(e) {
      this.variableNames = [
        "dy"
      ], this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "avgPool3DBackprop";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  function jat(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, s = a, { filterSize: o, strides: l, pad: u, dimRoundingMode: c } = r, h = vi(s.shape, o, l, 1, u, c), d = new qat(h), f = 1 / (h.filterDepth * h.filterHeight * h.filterWidth), p = [
      {
        type: "int32",
        data: [
          h.strideDepth,
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.effectiveFilterDepth - 1 - h.padInfo.front,
          h.effectiveFilterHeight - 1 - h.padInfo.top,
          h.effectiveFilterWidth - 1 - h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.effectiveFilterDepth,
          h.effectiveFilterHeight,
          h.effectiveFilterWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.outDepth
        ]
      },
      {
        type: "int32",
        data: [
          h.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          h.outWidth
        ]
      },
      {
        type: "float32",
        data: [
          f
        ]
      }
    ];
    return t.runWebGPUProgram(d, [
      i
    ], s.dtype, p);
  }
  const Kat = {
    kernelName: eb,
    backendName: "webgpu",
    kernelFunc: jat
  };
  function Zat(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, s = a;
    bre([
      i,
      a
    ], "avgPoolGrad");
    const { filterSize: o, strides: l, pad: u } = r, c = dr(s.shape, o, l, 1, u), h = new Yat(c), d = 1 / (c.filterHeight * c.filterWidth), f = [
      {
        type: "int32",
        data: [
          c.strideHeight,
          c.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.effectiveFilterHeight - 1 - c.padInfo.top,
          c.effectiveFilterWidth - 1 - c.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          c.dilationHeight,
          c.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.effectiveFilterHeight,
          c.effectiveFilterWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          c.outWidth
        ]
      },
      {
        type: "float32",
        data: [
          d
        ]
      }
    ];
    return t.runWebGPUProgram(h, [
      i
    ], s.dtype, f);
  }
  const Qat = {
    kernelName: Jx,
    backendName: "webgpu",
    kernelFunc: Zat
  };
  function Jat(n) {
    const { inputs: e, backend: t, attrs: r } = n, { a: i, b: a } = e, { transposeA: s, transposeB: o } = r;
    return f2({
      a: i,
      b: a,
      transposeA: s,
      transposeB: o,
      backend: t
    });
  }
  const est = {
    kernelName: Kd,
    backendName: "webgpu",
    kernelFunc: Jat
  };
  class tst {
    constructor(e, t) {
      this.variableNames = [
        "source"
      ], this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t, this.rank = t.length, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.start = e, this.uniforms = `start : ${lr(e.length)}, `, this.shaderKey = "slice";
    }
    getUserCode() {
      const e = lr(this.rank), t = nst(this.rank);
      let r;
      return this.start.length === 1 ? r = this.outputShape.map((a, s) => "sourceLoc = uniforms.start + coords;") : r = this.outputShape.map((a, s) => `sourceLoc.${U$[s]} = uniforms.start.${Vl(s)} + coords.${U$[s]};`), `
      ${Ne("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `;
    }
  }
  const U$ = [
    "x",
    "y",
    "z",
    "w",
    "u",
    "v"
  ];
  function nst(n) {
    if (n === 1) return "sourceLoc";
    if (n <= 6) return U$.slice(0, n).map((e) => `sourceLoc.${e}`).join(",");
    throw Error(`Slicing for rank ${n} is not yet supported`);
  }
  function Bv(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { begin: a, size: s } = r, [o, l] = Av(i, a, s);
    if ($I(i, o, l), t.shouldExecuteOnCPU([
      i
    ]) || i.dtype === "string") {
      const h = t.tensorMap.get(i.dataId), d = Jit(h.values, o, l, i.shape, i.dtype);
      return t.makeTensorInfo(l, i.dtype, d);
    }
    if (X(l) === 0) return t.makeTensorInfo(l, i.dtype, []);
    const u = new tst(o, l), c = [
      {
        type: "int32",
        data: o
      }
    ];
    return t.runWebGPUProgram(u, [
      i
    ], i.dtype, c);
  }
  const rst = {
    kernelName: fv,
    backendName: "webgpu",
    kernelFunc: Bv
  };
  const ist = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockShape: a, crops: s } = r;
    B(i.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");
    const o = a.reduce((y, x) => y * x), l = ou(i.shape, a, o), u = lu(l.length, a.length), c = uu(i.shape, a, o), h = Tb(s, a.length), d = Ab(c, s, a.length), f = [], p = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), g = ll({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        perm: u
      }
    }), m = Je({
      inputs: {
        x: g
      },
      backend: t,
      attrs: {
        shape: c
      }
    }), v = Bv({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        begin: h,
        size: d
      }
    });
    return f.push(p), f.push(g), f.push(m), f.forEach((y) => t.disposeData(y.dataId)), v;
  }, ast = {
    kernelName: Lm,
    backendName: "webgpu",
    kernelFunc: ist
  };
  const sst = `
  fn bincount_write(index: i32, value: f32) {
    ${Nc("&result[index]", "value", "float32")}
  }
`, ost = `
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;
  class Tre {
    constructor(e, t, r = false) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.uniforms = "binCountSize : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.hasWeights = true, this.binaryOutput = false, this.outputShape = e, this.rank = e.length, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.binaryOutput = r, r && (this.atomic = false), this.hasWeights = t, this.hasWeights && this.variableNames.push("w"), this.shaderKey = `bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`;
    }
    getUserCode() {
      return `
    ${this.binaryOutput ? ost : sst}
  ${Ne("index")} {
    ${this.rank === 1 ? `if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(index)" : "1."};
        bincount_write(indexVal, value);
      }
    }` : `let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(coord[0], coord[1])" : "1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `;
    }
  }
  function lst(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, weights: a } = e, { size: s } = r, o = X(i.shape), u = X(a.shape) > 0, c = [
      s
    ], h = a.dtype, d = ea({
      backend: t,
      attrs: {
        shape: c,
        value: 0,
        dtype: h
      }
    }), f = new Tre([
      o
    ], u), p = [
      {
        type: "int32",
        data: [
          s
        ]
      }
    ], g = u ? [
      i,
      a
    ] : [
      i
    ];
    return t.runWebGPUProgram(f, g, h, p, d);
  }
  const ust = {
    kernelName: Fm,
    backendName: "webgpu",
    kernelFunc: lst
  };
  class cst {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "s0",
        "s1"
      ], this.uniforms = "s0Size : i32, s1Size : i32, ", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "broadcastArgs";
    }
    getUserCode() {
      return `
  ${Ne("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `;
    }
  }
  function hst(n) {
    const { inputs: e, backend: t } = n, { s0: r, s1: i } = e;
    if (t.shouldExecuteOnCPU([
      r,
      i
    ])) {
      const c = t.tensorMap.get(r.dataId), h = t.tensorMap.get(i.dataId), d = c.values, f = h.values, p = ht(Array.from(d), Array.from(f));
      return t.makeTensorInfo([
        p.length
      ], "int32", Int32Array.from(p));
    }
    const a = X(r.shape), s = X(i.shape), o = Math.max(a, s), l = new cst(o), u = [
      {
        type: "int32",
        data: [
          a
        ]
      },
      {
        type: "int32",
        data: [
          s
        ]
      }
    ];
    return t.runWebGPUProgram(l, [
      r,
      i
    ], "int32", u);
  }
  const dst = {
    kernelName: eI,
    backendName: "webgpu",
    kernelFunc: hst
  };
  const Are = jr({
    opType: _t.NOT_EQUAL,
    dtype: "bool",
    cpuKernelImpl: Yit
  }), fst = {
    kernelName: iv,
    backendName: "webgpu",
    kernelFunc: Are
  };
  function Yb(n) {
    const { inputs: e, backend: t } = n, { input: r } = e, i = t.tensorMap.get(r.dataId);
    return Aa({
      inputs: {
        x: i.complexTensorInfos.real
      },
      backend: t
    });
  }
  const pst = {
    kernelName: hI,
    backendName: "webgpu",
    kernelFunc: Yb
  };
  function gst(n, e) {
    const t = new Ov(n.shape, De.TO_INT), r = e.runWebGPUProgram(t, [
      n
    ], "int32");
    return {
      dataId: r.dataId,
      shape: r.shape,
      dtype: r.dtype
    };
  }
  function H$(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { dtype: a } = r;
    if (a === "complex64") {
      if (i.dtype === "complex64") return Aa({
        inputs: {
          x: i
        },
        backend: t
      });
      const s = Cr(i.shape), o = H$({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          dtype: "float32"
        }
      }), l = mp({
        inputs: {
          real: o,
          imag: s
        },
        backend: t
      });
      return s.dispose(), t.disposeData(o.dataId), l;
    }
    if (i.dtype === "complex64") {
      const s = Yb({
        inputs: {
          input: i
        },
        backend: t
      }), o = H$({
        inputs: {
          x: s
        },
        backend: t,
        attrs: {
          dtype: a
        }
      });
      return t.disposeData(s.dataId), o;
    }
    if (!UM(i.dtype, a)) {
      const s = Aa({
        inputs: {
          x: i
        },
        backend: t
      });
      return {
        dataId: s.dataId,
        shape: s.shape,
        dtype: a
      };
    }
    if (t.shouldExecuteOnCPU([
      i
    ])) {
      const s = t.tensorMap.get(i.dataId).values, [o, l, u] = Tit(s, i.shape, i.dtype, a);
      return t.makeTensorInfo(o, l, u);
    }
    if (a === "int32") return gst(i, t);
    if (a === "bool") {
      const s = t.makeTensorInfo([], "bool", Yr("bool", 1)), l = Are({
        inputs: {
          a: i,
          b: s
        },
        backend: t
      });
      return t.disposeData(s.dataId), l;
    }
    throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`);
  }
  const mst = {
    kernelName: Zd,
    backendName: "webgpu",
    kernelFunc: H$
  };
  const vst = hn({
    opType: De.CEIL,
    cpuKernelImpl: Ait
  }), yst = {
    kernelName: Qd,
    backendName: "webgpu",
    kernelFunc: vst
  };
  class xst {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.uniforms = "minVal : f32, maxVal : f32,", this.workPerThread = 4, this.workgroupSize = [
        64,
        1,
        1
      ], this.outputComponent = 4, this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.shaderKey = "clipVec4";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `;
    }
  }
  class bst {
    constructor(e) {
      this.variableNames = [
        "A"
      ], this.uniforms = "minVal : f32, maxVal : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "clip";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;
    }
  }
  function wst(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { clipValueMin: a, clipValueMax: s } = r;
    let o;
    const l = [
      {
        type: "float32",
        data: [
          a
        ]
      },
      {
        type: "float32",
        data: [
          s
        ]
      }
    ];
    return X(i.shape) % 4 === 0 ? o = new xst(i.shape) : o = new bst(i.shape), t.runWebGPUProgram(o, [
      i
    ], i.dtype, l);
  }
  const _st = {
    kernelName: bc,
    backendName: "webgpu",
    kernelFunc: wst
  };
  class Sst {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "real",
        "imag"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "complexAbs";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `;
    }
  }
  function aH(n, e) {
    return {
      dataId: e.dataId,
      dtype: e.dtype,
      shape: n.shape
    };
  }
  function Cst(n) {
    const { inputs: e, backend: t } = n, { x: r } = e, i = t.tensorMap.get(r.dataId), a = new Sst(r.shape), s = [
      aH(r, i.complexTensorInfos.real),
      aH(r, i.complexTensorInfos.imag)
    ];
    return t.runWebGPUProgram(a, s, s[0].dtype);
  }
  const Ist = {
    kernelName: tb,
    backendName: "webgpu",
    kernelFunc: Cst
  };
  class kst {
    constructor(e) {
      this.uniforms = "", this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = ai(e, 1), this.variableNames = e.map((t, r) => `T${r}`), this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]), this.offsetLength = e.length - 1;
      for (let t = 0; t < this.offsetLength; t++) this.uniforms += `offset${t} : i32,`;
      this.shaderKey = "concat";
    }
    getUserCode() {
      const e = [];
      if (this.offsetLength > 0) {
        e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");
        for (let a = 1; a < this.offsetLength; a++) e.push(`else if (yC < uniforms.offset${[
          a
        ]}){ setOutputAtCoords(coords.x, coords.y, getT${a}(yR, yC - uniforms.offset${a - 1})); }`);
        const r = this.offsetLength, i = this.offsetLength - 1;
        e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${i})); }`);
      } else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");
      return `
      ${Ne("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `;
    }
  }
  function p2(n) {
    const { inputs: e, backend: t } = n, { input: r } = e, i = t.tensorMap.get(r.dataId);
    return Aa({
      inputs: {
        x: i.complexTensorInfos.imag
      },
      backend: t
    });
  }
  const Tst = {
    kernelName: uI,
    backendName: "webgpu",
    kernelFunc: p2
  };
  function qy(n, e, t) {
    const r = n[0].dtype;
    if (r === "complex64") {
      const p = n.map((x) => Yb({
        inputs: {
          input: x
        },
        backend: t
      })), g = n.map((x) => p2({
        inputs: {
          input: x
        },
        backend: t
      })), m = qy(p, e, t), v = qy(g, e, t), y = mp({
        inputs: {
          real: m,
          imag: v
        },
        backend: t
      });
      return p.forEach((x) => t.disposeData(x.dataId)), g.forEach((x) => t.disposeData(x.dataId)), t.disposeData(m.dataId), t.disposeData(v.dataId), y;
    }
    let i = t.shouldExecuteOnCPU(n);
    if (r === "string" && (i = true), i) {
      const p = n.map((w) => {
        const S = [
          -1,
          X(w.shape.slice(e))
        ];
        return Je({
          inputs: {
            x: w
          },
          backend: t,
          attrs: {
            shape: S
          }
        });
      }), g = p.map((w) => ({
        vals: t.readSync(w.dataId),
        shape: w.shape
      })), m = ai(p.map((w) => w.shape), 1), v = p[0].shape[0] === 1, y = Dit(g, m, r, v), x = ai(n.map((w) => w.shape), e), b = t.makeTensorInfo(x, r, y);
      return p.forEach((w) => t.disposeData(w.dataId)), b;
    }
    const a = t.device.limits.maxStorageBuffersPerShaderStage - 1;
    if (n.length > a) {
      const p = [];
      for (let m = 0; m < n.length; m += a) {
        const v = n.slice(m, m + a);
        p.push(qy(v, e, t));
      }
      const g = qy(p, e, t);
      for (const m of p) t.disposeData(m.dataId);
      return g;
    }
    const { tensors2D: s, outShape: o } = Ast(n, e, t), l = s.map((p) => p.shape), u = new kst(l), c = [], h = new Array(l.length - 1);
    if (h.length > 0) {
      h[0] = l[0][1], c.push({
        type: "int32",
        data: [
          h[0]
        ]
      });
      for (let p = 1; p < h.length; p++) h[p] = h[p - 1] + l[p][1], c.push({
        type: "int32",
        data: [
          h[p]
        ]
      });
    }
    const d = t.runWebGPUProgram(u, s, s[0].dtype, c);
    s.forEach((p) => t.disposeData(p.dataId));
    const f = Je({
      inputs: {
        x: d
      },
      backend: t,
      attrs: {
        shape: o
      }
    });
    return t.disposeData(d.dataId), f;
  }
  function Ast(n, e, t) {
    const r = ai(n.map((a) => a.shape), e);
    return {
      tensors2D: n.map((a) => Je({
        inputs: {
          x: a
        },
        backend: t,
        attrs: {
          shape: [
            X(a.shape.slice(0, e)),
            X(a.shape.slice(e))
          ]
        }
      })),
      outShape: r
    };
  }
  function Dre(n) {
    const { inputs: e, backend: t, attrs: r } = n, { axis: i } = r, a = yt(i, e[0].shape)[0], s = e.map((u) => u.shape);
    Ib(s, a);
    const o = ai(e.map((u) => u.shape), a);
    if (X(o) === 0) return t.makeTensorInfo(o, e[0].dtype, []);
    const l = e.filter((u) => X(u.shape) > 0);
    return l.length === 1 ? Aa({
      inputs: {
        x: l[0]
      },
      backend: t
    }) : qy(l, a, t);
  }
  const Dst = {
    kernelName: Om,
    backendName: "webgpu",
    kernelFunc: Dre
  };
  function Rst(n, e, t, r, i = false, a = null, s = false, o = 4, l = 4, u = 4) {
    const c = (C) => {
      switch (C) {
        case 1:
          return "resData = f32(x[xIndex]);";
        case 3:
          return "resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";
        case 4:
          return "resData = vec4<f32>(x[xIndex / 4]);";
        default:
          throw new Error(`innerElementSize ${C} is not supported.`);
      }
    }, h = (C) => {
      switch (C) {
        case 1:
          return "return f32(W[row * uniforms.wShape[3] + col]);";
        case 4:
          return "return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";
        default:
          throw new Error(`innerElementSize ${C} is not supported.`);
      }
    }, d = n ? `
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `, f = n ? `
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      ` : `
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `, p = n ? "uniforms.xShape[1]" : "uniforms.xShape[2]", g = n ? "uniforms.xShape[2]" : "uniforms.xShape[3]", m = n ? "row" : "col", v = n ? "col" : "row", y = `
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
      let outRow = ${m} / outWidth;
      let outCol = ${m} % outWidth;

      let WRow = ${v} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${v} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${v} % inChannels;
      var resData = ${Bt(o)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${g}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(o)}
      }
      return resData;`, x = n ? e && r ? `
      ${y}` : `
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${y}
      }
      return ${Bt(o)}(0.0);` : r && t ? `
      ${y}` : `
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${y}
      }
      return ${Bt(o)}(0.0);`, b = `${h(l)}`, w = Bt(u), _ = Bt(n ? o : l), S = Bt(n ? l : o);
    return `
      ${hu(a, s, u === 4, 4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${_} {
        ${n ? x : b}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${S} {
        ${n ? b : x}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${w}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
        ${f}
        ${gp(i, a)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`;
  }
  class $st {
    constructor(e, t, r, i, a = false, s = null, o = false, l = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = e.outShape, this.isChannelsLast = e.dataFormat === "channelsLast", this.isVec4 = ((e.inChannels % 4 === 0 || e.inChannels % 3 === 0) && this.isChannelsLast || e.outWidth % 4 === 0 && !this.isChannelsLast) && e.outChannels % 4 === 0, this.dispatchLayout = this.isChannelsLast ? {
        x: [
          3
        ],
        y: [
          1,
          2
        ],
        z: [
          0
        ]
      } : {
        x: [
          2,
          3
        ],
        y: [
          1
        ],
        z: [
          0
        ]
      }, this.workgroupSize = vre(this.dispatchLayout, this.outputShape, this.isVec4), this.elementsPerThread = yre(this.dispatchLayout, this.outputShape, this.isVec4), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), this.isVec4 ? (this.outputComponent = 4, this.isChannelsLast && e.inChannels % 4 !== 0 ? (this.innerElementSize = 3, this.variableComponents = [
        1,
        4
      ]) : (this.innerElementSize = 4, this.variableComponents = [
        4,
        4
      ]), a && (this.variableNames.push("bias"), this.variableComponents.push(4)), o && (this.variableNames.push("preluActivationWeights"), this.variableComponents.push(4))) : (this.innerElementSize = this.elementsPerThread[0], a && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights")), this.sequentialAccessByThreads = l, this.addBias = a, this.activation = s, this.hasPreluActivationWeights = o, this.tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1], this.tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0], this.tileInner = Math.max(this.workgroupSize[0] * this.innerElementSize, this.workgroupSize[1]), this.fitAOuter = t % this.tileAOuter === 0, this.fitBOuter = r % this.tileBOuter === 0, this.fitInner = i % this.tileInner === 0, this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`;
    }
    getUserCode() {
      const e = this.isVec4 ? h2(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner) : d2(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner, false, null, this.sequentialAccessByThreads), t = this.isVec4 ? [
        this.innerElementSize,
        4,
        4
      ] : [
        1,
        1,
        1
      ];
      return `
    ${Rst(this.isChannelsLast, this.fitAOuter, this.fitBOuter, this.fitInner, this.addBias, this.activation, this.hasPreluActivationWeights, t[0], t[1], t[2])}
    ${e}
  `;
    }
  }
  class Nst {
    constructor(e, t = false, r = null, i = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,", this.workgroupSize = [
        4,
        4,
        8
      ], this.outputShape = e.outShape, this.isChannelsLast = e.dataFormat === "channelsLast", this.dispatchLayout = this.isChannelsLast ? {
        x: [
          2
        ],
        y: [
          1
        ],
        z: [
          0,
          3
        ]
      } : {
        x: [
          3
        ],
        y: [
          2
        ],
        z: [
          0,
          1
        ]
      }, this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.addBias = t, this.activation = r, this.hasPreluActivationWeights = i, t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.shaderKey = `conv2dnaive_${this.activation}_${this.isChannelsLast}`;
    }
    getUserCode() {
      return `
       ${hu(this.activation, this.hasPreluActivationWeights, false, 4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast ? "vec4<i32>(batch, row, col, chan);" : "vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${gp(this.addBias, this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Ne("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast ? "coords[3];" : "coords[1];"}
         let outRow = ${this.isChannelsLast ? "coords[1];" : "coords[2];"}
         let outCol = ${this.isChannelsLast ? "coords[2];" : "coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast ? "uniforms.xShape[3];" : "uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast ? "let v = readInp(batch, xRow, xCol, xChannel);" : "let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `;
    }
  }
  class Est {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.uniforms = `pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = t, this.shaderKey = `im2col_${this.isChannelsLast}`;
    }
    getUserCode() {
      const e = this.isChannelsLast ? 1 : 2, t = this.isChannelsLast ? 2 : 3, r = this.isChannelsLast ? "coords[1]" : "coords[2]", i = this.isChannelsLast ? "coords[2]" : "coords[1]", a = this.isChannelsLast ? "getX(batch, xRow, xCol, ch)" : "getX(batch, ch, xRow, xCol)";
      return `
    ${Ne("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${a};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `;
    }
  }
  function tC(n, e) {
    const t = n.length;
    return t >= 3 ? e ? [
      ...n.slice(0, -3),
      n[t - 3] * n[t - 2],
      n[t - 1]
    ] : [
      ...n.slice(0, -3),
      n[t - 3],
      n[t - 2] * n[t - 1]
    ] : !e && t === 1 && n[0] > 1 ? [
      n[0],
      1
    ] : null;
  }
  function Mst({ x: n, filter: e, convInfo: t, backend: r, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: s = 0, activation: o = null }) {
    const l = t.dataFormat === "channelsLast", u = !l, c = false, h = l && t.filterHeight === t.inHeight && t.filterWidth === t.inWidth && t.padInfo.type === "VALID", d = [];
    let f, p;
    if (h) {
      const v = t.inHeight * t.inWidth * t.inChannels;
      f = Je({
        inputs: {
          x: n
        },
        backend: r,
        attrs: {
          shape: [
            1,
            t.batchSize,
            v
          ]
        }
      }), p = Je({
        inputs: {
          x: e
        },
        backend: r,
        attrs: {
          shape: [
            1,
            v,
            t.outChannels
          ]
        }
      });
    } else f = Je({
      inputs: {
        x: n
      },
      backend: r,
      attrs: {
        shape: l ? [
          t.batchSize,
          t.inHeight * t.inWidth,
          t.inChannels
        ] : [
          t.batchSize,
          t.inChannels,
          t.inHeight * t.inWidth
        ]
      }
    }), p = Je({
      inputs: {
        x: e
      },
      backend: r,
      attrs: {
        shape: [
          1,
          t.inChannels,
          t.outChannels
        ]
      }
    });
    if (d.push(f), d.push(p), a != null) {
      const v = tC(a.shape, l);
      v != null && (a = Je({
        inputs: {
          x: a
        },
        backend: r,
        attrs: {
          shape: v
        }
      }), d.push(a));
    }
    if (i != null) {
      const v = tC(i.shape, l);
      v != null && (i = Je({
        inputs: {
          x: i
        },
        backend: r,
        attrs: {
          shape: v
        }
      }), d.push(i));
    }
    const g = f2({
      a: l ? f : p,
      b: l ? p : f,
      transposeA: u,
      transposeB: c,
      backend: r,
      bias: i,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: s
    }), m = Je({
      inputs: {
        x: g
      },
      backend: r,
      attrs: {
        shape: t.outShape
      }
    });
    d.push(g);
    for (const v of d) r.disposeData(v.dataId);
    return m;
  }
  function Pst({ x: n, filter: e, convInfo: t, backend: r, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: s = 0, activation: o = null }) {
    const { filterWidth: l, filterHeight: u, inChannels: c, strideWidth: h, strideHeight: d, padInfo: f, outWidth: p, outHeight: g, dilationWidth: m, dilationHeight: v, dataFormat: y } = t, x = y === "channelsLast", b = l * u * c, w = g * p, _ = x ? [
      t.batchSize,
      w,
      b
    ] : [
      t.batchSize,
      b,
      w
    ], S = new Est(_, x), I = [
      {
        type: "int32",
        data: [
          f.top,
          f.left
        ]
      },
      {
        type: "int32",
        data: [
          d,
          h
        ]
      },
      {
        type: "int32",
        data: [
          v,
          m
        ]
      },
      {
        type: "int32",
        data: [
          p
        ]
      },
      {
        type: "int32",
        data: [
          c * l
        ]
      },
      {
        type: "int32",
        data: [
          c
        ]
      }
    ], C = r.runWebGPUProgram(S, [
      n
    ], n.dtype, I), T = [];
    T.push(C);
    const k = Je({
      inputs: {
        x: e
      },
      backend: r,
      attrs: {
        shape: [
          1,
          b,
          -1
        ]
      }
    });
    if (T.push(k), a != null) {
      const A = tC(a.shape, x);
      A != null && (a = Je({
        inputs: {
          x: a
        },
        backend: r,
        attrs: {
          shape: A
        }
      }), T.push(a));
    }
    if (i != null) {
      const A = tC(i.shape, x);
      A != null && (i = Je({
        inputs: {
          x: i
        },
        backend: r,
        attrs: {
          shape: A
        }
      }), T.push(i));
    }
    const N = f2({
      a: x ? C : k,
      b: x ? k : C,
      transposeA: !x,
      transposeB: false,
      backend: r,
      bias: i,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: s
    }), E = Je({
      inputs: {
        x: N
      },
      backend: r,
      attrs: {
        shape: t.outShape
      }
    });
    T.push(N);
    for (const A of T) r.disposeData(A.dataId);
    return E;
  }
  function Rre({ x: n, filter: e, convInfo: t, backend: r, bias: i = null, preluActivationWeights: a = null, leakyreluAlpha: s = 0, activation: o = null }) {
    const l = i != null, u = a != null, c = t.dataFormat === "channelsLast", h = c && t.filterHeight === t.inHeight && t.filterWidth === t.inWidth && t.padInfo.type === "VALID", d = ne().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");
    if (!d && (h || t.filterHeight === 1 && t.filterWidth === 1 && t.dilationHeight === 1 && t.dilationWidth === 1 && t.strideHeight === 1 && t.strideWidth === 1 && (t.padInfo.type === "SAME" || t.padInfo.type === "VALID"))) return Mst({
      x: n,
      filter: e,
      convInfo: t,
      backend: r,
      bias: i,
      activation: o,
      preluActivationWeights: a,
      leakyreluAlpha: s
    });
    const f = ne().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), p = f > -1 ? f : r.thresholdToIncreaseWorkgroups, g = t.batchSize * Math.ceil(t.outHeight * t.outWidth / 32) * Math.ceil(t.outChannels / 32);
    if (ne().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER") || g <= p) return Pst({
      x: n,
      filter: e,
      convInfo: t,
      backend: r,
      bias: i,
      preluActivationWeights: a,
      leakyreluAlpha: s,
      activation: o
    });
    let m;
    const v = [
      t.padInfo.top,
      t.padInfo.left
    ], y = [
      {
        type: "int32",
        data: [
          t.filterHeight,
          t.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          ...v
        ]
      },
      {
        type: "int32",
        data: [
          t.strideHeight,
          t.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          t.dilationHeight,
          t.dilationWidth
        ]
      }
    ];
    if (d) m = new Nst(t, l, o, u);
    else {
      const _ = c ? t.outHeight * t.outWidth : t.outChannels, S = c ? t.outChannels : t.outHeight * t.outWidth, I = t.filterHeight * t.filterWidth * t.inChannels;
      y.push({
        type: "int32",
        data: [
          _
        ]
      }, {
        type: "int32",
        data: [
          S
        ]
      }, {
        type: "int32",
        data: [
          I
        ]
      });
      const C = r.adapterInfo.isIntel();
      m = new $st(t, _, S, I, l, o, u, C);
    }
    const x = [], b = [
      n,
      e
    ];
    l && (!c && i.shape.length === 1 && (i = Je({
      inputs: {
        x: i
      },
      backend: r,
      attrs: {
        shape: [
          i.shape[0],
          1,
          1
        ]
      }
    }), x.push(i)), b.push(i)), u && (!c && a.shape.length === 1 && (a = Je({
      inputs: {
        x: a
      },
      backend: r,
      attrs: {
        shape: [
          a.shape[0],
          1,
          1
        ]
      }
    }), x.push(a)), b.push(a)), o === "leakyrelu" && (y.push({
      type: "float32",
      data: [
        s
      ]
    }), m.uniforms += " alpha : f32,");
    const w = r.runWebGPUProgram(m, b, n.dtype, y);
    for (const _ of x) r.disposeData(_.dataId);
    return w;
  }
  function Lst(n) {
    const { inputs: e, attrs: t, backend: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dataFormat: l, dilations: u, dimRoundingMode: c } = t, h = Oi(l), d = Sn(i.shape, a.shape, s, u, o, c, false, h);
    return Rre({
      x: i,
      filter: a,
      convInfo: d,
      backend: r
    });
  }
  const Fst = {
    kernelName: Jd,
    backendName: "webgpu",
    kernelFunc: Lst
  };
  class Ost {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = false, this.isVec4 = false, this.workPerThread = 1, this.outputShape = e.inShape, this.isChannelsLast = e.dataFormat === "channelsLast", this.isVec4 = this.isChannelsLast && e.outChannels % 4 === 0 && e.inChannels % 4 === 0, this.isVec4 ? (this.workPerThread = 2, this.outputComponent = 4, this.workgroupSize = [
        4,
        4,
        4
      ], this.dispatchLayout = {
        x: [
          3
        ],
        y: [
          2
        ],
        z: [
          0,
          1
        ]
      }, this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        4,
        this.workPerThread,
        1
      ])) : (this.size = true, this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize)), this.shaderKey = `conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`;
    }
    getUserCode() {
      const e = this.isChannelsLast ? 1 : 2, t = this.isChannelsLast ? 2 : 3, r = this.isChannelsLast ? 3 : 1, i = `
    ${Ne()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;
      return this.isVec4 ? `
    ${i}
    ` : `
    ${Ne("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast ? "getDy(batch, idyR, idyC, d2)" : "getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  }
  class Bst {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.uniforms = "pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.filterShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = e.dataFormat === "channelsLast", this.shaderKey = `conv2DDerFilter_${this.isChannelsLast}`;
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  }
  class zst {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.uniforms = `pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.filterShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3DDerFilter";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  }
  class Vst {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.uniforms = `filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3DDerInput";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
  }
  function Wst(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, pad: o, dataFormat: l, dimRoundingMode: u, filterShape: c } = r, h = Oi(l), d = Sn(i.shape, c, s, 1, o, u, false, h), f = new Bst(d), p = [
      {
        type: "int32",
        data: [
          d.padInfo.top,
          d.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          d.strideHeight,
          d.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.batchSize
        ]
      },
      {
        type: "int32",
        data: [
          d.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          d.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.inHeight
        ]
      },
      {
        type: "int32",
        data: [
          d.inWidth
        ]
      }
    ];
    return t.runWebGPUProgram(f, [
      i,
      a
    ], i.dtype, p);
  }
  const Gst = {
    kernelName: nI,
    backendName: "webgpu",
    kernelFunc: Wst
  };
  function Ust(n = 4) {
    const e = (a) => {
      switch (a) {
        case 1:
          return "return W[getIndexFromCoords4D(coord, uniforms.wShape)];";
        case 4:
          return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;
        default:
          throw new Error(`innerElementSize ${a} is not supported.`);
      }
    }, r = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Bt(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Bt(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Bt(n)}(0.0);`;
    return `
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Bt(n)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Bt(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${Bt(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Bt(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`;
  }
  class Hst {
    constructor(e) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = e.inShape, B(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), this.isVec4 = e.inChannels % 4 === 0 && e.outChannels % 4 === 0, this.dispatchLayout = {
        x: [
          3
        ],
        y: [
          1,
          2
        ],
        z: [
          0
        ]
      }, this.workgroupSize = vre(this.dispatchLayout, this.outputShape, this.isVec4), this.elementsPerThread = yre(this.dispatchLayout, this.outputShape, this.isVec4), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), this.isVec4 && (this.outputComponent = 4, this.variableComponents = [
        4,
        1
      ]), this.shaderKey = `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;
    }
    getUserCode() {
      const e = this.isVec4 ? h2(this.elementsPerThread, this.workgroupSize) : d2(this.elementsPerThread, this.workgroupSize);
      return `
    ${Ust(this.isVec4 ? 4 : 1)}
    ${e}
    `;
    }
  }
  function Xst(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { inputShape: s, strides: o, pad: l, dataFormat: u, dimRoundingMode: c } = r, h = Oi(u), d = Sn(s, a.shape, o, 1, l, c, false, h), f = [
      {
        type: "int32",
        data: [
          d.filterHeight,
          d.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.filterHeight - 1 - d.padInfo.top,
          d.filterWidth - 1 - d.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          d.strideHeight,
          d.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.batchSize,
          d.outHeight,
          d.outWidth,
          d.outChannels
        ]
      }
    ];
    let p;
    if (ne().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE") || d.dataFormat !== "channelsLast") p = new Ost(d);
    else {
      p = new Hst(d);
      const g = d.inHeight * d.inWidth, m = d.inChannels, v = d.filterHeight * d.filterWidth * d.outChannels;
      f.push({
        type: "uint32",
        data: [
          g
        ]
      }, {
        type: "uint32",
        data: [
          m
        ]
      }, {
        type: "uint32",
        data: [
          v
        ]
      });
    }
    return t.runWebGPUProgram(p, [
      i,
      a
    ], "float32", f);
  }
  const Yst = {
    kernelName: ef,
    backendName: "webgpu",
    kernelFunc: Xst
  };
  class qst {
    constructor(e) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3dnaive";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`;
    }
  }
  function jst(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l } = r, u = Ra(i.shape, a.shape, s, l, o), c = [
      u.padInfo.front,
      u.padInfo.top,
      u.padInfo.left
    ], h = [
      {
        type: "int32",
        data: [
          u.filterDepth,
          u.filterHeight,
          u.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          ...c
        ]
      },
      {
        type: "int32",
        data: [
          u.strideDepth,
          u.strideHeight,
          u.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.dilationDepth,
          u.dilationHeight,
          u.dilationWidth
        ]
      }
    ], d = new qst(u), f = qr(i.dtype, a.dtype);
    return t.runWebGPUProgram(d, [
      i,
      a
    ], f, h);
  }
  const Kst = {
    kernelName: tf,
    backendName: "webgpu",
    kernelFunc: jst
  };
  function Zst(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, pad: o, filterShape: l } = r, u = Ra(i.shape, l, s, 1, o), c = new zst(u), h = [
      {
        type: "int32",
        data: [
          u.padInfo.front,
          u.padInfo.top,
          u.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          u.strideDepth,
          u.strideHeight,
          u.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.batchSize
        ]
      },
      {
        type: "int32",
        data: [
          u.outDepth
        ]
      },
      {
        type: "int32",
        data: [
          u.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          u.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.inDepth
        ]
      },
      {
        type: "int32",
        data: [
          u.inHeight
        ]
      },
      {
        type: "int32",
        data: [
          u.inWidth
        ]
      }
    ];
    return t.runWebGPUProgram(c, [
      i,
      a
    ], a.dtype, h);
  }
  const Qst = {
    kernelName: Bm,
    backendName: "webgpu",
    kernelFunc: Zst
  };
  function Jst(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { strides: s, pad: o, inputShape: l } = r, u = Ra(l, a.shape, s, 1, o), c = new Vst(u), h = [
      {
        type: "int32",
        data: [
          u.filterDepth,
          u.filterHeight,
          u.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.filterDepth - 1 - u.padInfo.front,
          u.filterHeight - 1 - u.padInfo.top,
          u.filterWidth - 1 - u.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          u.strideDepth,
          u.strideHeight,
          u.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.outDepth
        ]
      },
      {
        type: "int32",
        data: [
          u.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          u.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.outChannels
        ]
      }
    ];
    return t.runWebGPUProgram(c, [
      i,
      a
    ], i.dtype, h);
  }
  const eot = {
    kernelName: zm,
    backendName: "webgpu",
    kernelFunc: Jst
  };
  const tot = hn({
    opType: De.COS
  }), not = {
    kernelName: nf,
    backendName: "webgpu",
    kernelFunc: tot
  };
  const rot = hn({
    opType: De.COSH
  }), iot = {
    kernelName: rf,
    backendName: "webgpu",
    kernelFunc: rot
  };
  class aot {
    constructor(e, t, r, i) {
      this.variableNames = [
        "Image",
        "Boxes",
        "BoxInd"
      ], this.uniforms = "extrapolationValue : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true;
      const [a] = t;
      this.outputShape = [
        a,
        r[0],
        r[1],
        e
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.methodId = i === "bilinear" ? 1 : 0, this.cropHeightBiggerThan1 = this.outputShape[1] > 1, this.cropWidthBiggerThan1 = this.outputShape[2] > 1, this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;
    }
    getUserCode() {
      const [e, t] = [
        "f32(uniforms.imageShape[1] - 1)",
        "f32(uniforms.imageShape[2] - 1)"
      ], [r, i, a] = this.cropHeightBiggerThan1 ? [
        `(${e} / f32(uniforms.outShape[1] - 1))`,
        "(y2-y1) * height_ratio",
        `y1*${e} + f32(y)*(height_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (y1+y2) * ${e}`
      ], [s, o, l] = this.cropWidthBiggerThan1 ? [
        `(${t} / f32(uniforms.outShape[2] - 1))`,
        "(x2-x1) * width_ratio",
        `x1*${t} + f32(x)*(width_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (x1+x2) * ${t}`
      ];
      return `
    ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${s});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${o};
        let in_y = ${a};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `;
    }
  }
  const sot = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { image: i, boxes: a, boxInd: s } = e, { cropSize: o, method: l, extrapolationValue: u } = r, c = new aot(i.shape[3], a.shape, o, l), h = [
      {
        type: "float32",
        data: [
          u
        ]
      }
    ];
    return t.runWebGPUProgram(c, [
      i,
      a,
      s
    ], "float32", h);
  }, oot = {
    kernelName: Wm,
    backendName: "webgpu",
    kernelFunc: sot
  };
  var xx;
  (function(n) {
    n.Prod = "*", n.Sum = "+";
  })(xx || (xx = {}));
  class sH {
    constructor(e, t, r, i) {
      this.variableNames = [
        "x"
      ], this.uniforms = "index : f32,", this.size = true, this.workgroupSize = [
        128,
        1,
        1
      ], this.outputShape = t, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.exclusive = r, this.reverse = i, this.op = e, this.shaderKey = `cum_${this.op}_${this.exclusive}_${this.reverse}`;
    }
    getUserCode() {
      const e = this.outputShape.length, t = this.op === xx.Prod ? "1.0" : "0.0", r = this.exclusive ? t : `getX(${oH(e, "coords", this.op)})`, i = this.outputShape[this.outputShape.length - 1];
      let a = "", s = "";
      return this.exclusive ? (a = this.reverse ? `end != ${i - 1}` : "end != 0", s = this.reverse ? "end + 1" : "end - 1") : (a = this.reverse ? `end + pow2 < ${i}` : "end >= pow2", s = this.reverse ? "end + pow2" : "end - pow2"), `
      ${Ne("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${lH(e, "coords", this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${a}) {
           let idx = ${s};
           ${lH(e, "coords", this.op)} = idx;
           val ${this.op}= getX(${oH(e, "coords", this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `;
    }
  }
  function oH(n, e, t) {
    if (n === 1) return `${e}`;
    if (n === 2) return `${e}.x, ${e}.y`;
    if (n === 3) return `${e}.x, ${e}.y, ${e}.z`;
    if (n === 4) return `${e}.x, ${e}.y, ${e}.z, ${e}.w`;
    throw Error(`Cumulative ${t} for rank ${n} is not yet supported`);
  }
  function lH(n, e, t) {
    if (n === 1) return `${e}`;
    if (n === 2) return `${e}.y`;
    if (n === 3) return `${e}.z`;
    if (n === 4) return `${e}.w`;
    throw Error(`Cumulative ${t} for rank ${n} is not yet supported`);
  }
  function $re(n, e, t, r, i, a) {
    const s = e.shape.length, o = bn([
      r
    ], s);
    let l = e;
    o != null && (l = ll({
      inputs: {
        x: e
      },
      backend: t,
      attrs: {
        perm: o
      }
    }));
    const u = gn(1, s)[0];
    if (u !== s - 1) throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length - 1} but got axis=${r}`);
    const c = l.shape[u];
    let h = Aa({
      inputs: {
        x: l
      },
      backend: t
    });
    for (let d = 0; d <= Math.ceil(Math.log2(c)) - 1; d++) {
      const f = new sH(n, l.shape, false, a), p = h, g = [
        {
          type: "float32",
          data: [
            d
          ]
        }
      ];
      h = t.runWebGPUProgram(f, [
        h
      ], h.dtype, g), t.disposeData(p.dataId);
    }
    if (i) {
      const d = new sH(n, l.shape, i, a), f = h, p = [
        {
          type: "float32",
          data: [
            0
          ]
        }
      ];
      h = t.runWebGPUProgram(d, [
        h
      ], h.dtype, p), t.disposeData(f.dataId);
    }
    if (o != null) {
      const d = As(o), f = ll({
        inputs: {
          x: h
        },
        backend: t,
        attrs: {
          perm: d
        }
      });
      return t.disposeData(h.dataId), t.disposeData(l.dataId), f;
    }
    return h;
  }
  function lot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, exclusive: s, reverse: o } = r;
    return $re(xx.Prod, i, t, a, s, o);
  }
  const uot = {
    kernelName: Vm,
    backendName: "webgpu",
    kernelFunc: lot
  };
  function cot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, exclusive: s, reverse: o } = r;
    return $re(xx.Sum, i, t, a, s, o);
  }
  const hot = {
    kernelName: af,
    backendName: "webgpu",
    kernelFunc: cot
  };
  function dot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, weights: a } = e, { size: s, binaryOutput: o } = r, l = i.shape.length === 1, c = X(a.shape) > 0, h = a.dtype, d = l ? [
      i.shape[0]
    ] : [
      i.shape[0],
      i.shape[1]
    ], f = l ? [
      s
    ] : [
      i.shape[0],
      s
    ], p = ea({
      backend: t,
      attrs: {
        shape: f,
        value: 0,
        dtype: h
      }
    }), g = new Tre(d, c, o), m = [
      {
        type: "int32",
        data: [
          s
        ]
      }
    ], v = c ? [
      i,
      a
    ] : [
      i
    ];
    return t.runWebGPUProgram(g, v, h, m, p);
  }
  const fot = {
    kernelName: nb,
    backendName: "webgpu",
    kernelFunc: dot
  };
  class pot {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.uniforms = "blockSize : i32,", this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `depthToSpace_${t}`, this.dataFormat = t;
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`;
    }
    getHeightCoordString() {
      return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
      return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
      return this.dataFormat === "NHWC" ? "uniforms.outShape[3]" : "uniforms.outShape[1]";
    }
    getInputSamplingString() {
      return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
  }
  function got(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockSize: a, dataFormat: s } = r, o = i.shape[0], l = s === "NHWC" ? i.shape[1] : i.shape[2], u = s === "NHWC" ? i.shape[2] : i.shape[3], c = s === "NHWC" ? i.shape[3] : i.shape[1], h = l * a, d = u * a, f = c / (a * a), p = s === "NHWC" ? [
      o,
      h,
      d,
      f
    ] : [
      o,
      f,
      h,
      d
    ], g = [
      {
        type: "int32",
        data: [
          a
        ]
      }
    ], m = new pot(p, s);
    return t.runWebGPUProgram(m, [
      i
    ], i.dtype, g);
  }
  const mot = {
    kernelName: Gm,
    backendName: "webgpu",
    kernelFunc: got
  };
  class vot {
    constructor(e, t, r, i = false, a = null, s = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>,", this.workgroupSize = [
        16,
        16,
        1
      ], this.outputShape = e, this.dispatchLayout = {
        x: [
          3
        ],
        y: [
          2
        ],
        z: [
          0,
          1
        ]
      }, this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), i && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), this.addBias = i, this.activation = a, this.hasPreluActivation = s, this.filterHeight = t, this.filterWidth = r, this.shaderKey = `depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`;
    }
    getUserCode() {
      const e = this.filterWidth * this.filterHeight, t = this.workgroupSize[0] * this.workgroupSize[1] * this.workgroupSize[2], r = this.workgroupSize[1] + this.filterHeight - 1, i = this.workgroupSize[0] + this.filterWidth - 1;
      return `
      ${hu(this.activation, this.hasPreluActivation, false, 4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ne()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e < t ? `if (wIndex < ${e})` : `for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${gp(this.addBias, this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    }
  }
  class Nre {
    constructor(e, t = false, r = null, i = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.workPerThread = 4, this.outputComponent = 4, this.outputShape = e.outShape, this.virtualWidth = Math.ceil(this.outputShape[2] / this.workPerThread) * this.workPerThread;
      const a = [
        this.outputShape[0],
        this.outputShape[1],
        this.virtualWidth,
        this.outputShape[3]
      ];
      this.dispatchLayout = We(a), this.dispatch = Ee(this.dispatchLayout, a, this.workgroupSize, [
        this.outputComponent * this.workPerThread,
        1,
        1
      ]), B(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.convInfo = e, this.addBias = t, this.activation = r, this.hasPreluActivation = i, this.shaderKey = `depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`;
    }
    getUserCode() {
      const e = (this.workPerThread - 1) * this.convInfo.strideWidth + this.convInfo.filterWidth, t = this.convInfo.strideHeight, r = this.convInfo.strideWidth;
      return `
      ${hu(this.activation, this.hasPreluActivation, true, 4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Ne("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${gp(this.addBias, this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `;
    }
  }
  class Ere {
    constructor(e, t = false, r = null, i = false) {
      this.variableNames = [
        "x",
        "W"
      ], this.uniforms = `pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`, this.workgroupSize = [
        256,
        1,
        1
      ], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = e.dataFormat === "channelsLast", t && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.convInfo = e, this.addBias = t, this.activation = r, this.hasPreluActivation = i, this.shaderKey = `depthwise_${this.activation}_${this.isChannelsLast}`;
    }
    getUserCode() {
      const e = this.isChannelsLast ? "getX(batch, xR, xC, d1);" : "getX(batch, d1, xR, xC);";
      return `
      ${hu(this.activation, this.hasPreluActivation, false, 4)}

      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast ? "yz" : "zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast ? 3 : 1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${gp(this.addBias, this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    }
  }
  function yot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dataFormat: l, dilations: u, dimRoundingMode: c } = r, h = Oi(l);
    let d = u;
    d == null && (d = [
      1,
      1
    ]);
    const f = Sn(i.shape, a.shape, s, d, o, c, true, h), p = [
      {
        type: "int32",
        data: [
          f.padInfo.top,
          f.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          f.inHeight,
          f.inWidth
        ]
      }
    ], g = f.dataFormat === "channelsLast";
    let m;
    return !g && f.inHeight > 16 && f.inWidth > 16 && f.strideHeight === 1 && f.strideWidth === 1 && f.dilationWidth === 1 && f.dilationHeight === 1 && f.inChannels === f.outChannels ? m = new vot(f.outShape, f.filterHeight, f.filterWidth) : g && f.outHeight > 4 && f.outWidth > 4 && f.strideWidth <= 2 && f.inChannels === f.outChannels && f.dilationHeight === 1 && f.dilationWidth === 1 && f.inChannels % 4 === 0 ? (m = new Nre(f), p.push({
      type: "int32",
      data: [
        m.virtualWidth
      ]
    })) : (m = new Ere(f), p.push({
      type: "int32",
      data: [
        f.filterHeight
      ]
    }, {
      type: "int32",
      data: [
        f.filterWidth
      ]
    }, {
      type: "int32",
      data: [
        f.strideHeight,
        f.strideWidth
      ]
    }, {
      type: "int32",
      data: [
        f.dilationHeight,
        f.dilationWidth
      ]
    })), t.runWebGPUProgram(m, [
      i,
      a
    ], i.dtype, p);
  }
  const xot = {
    kernelName: sf,
    backendName: "webgpu",
    kernelFunc: yot
  };
  class bot {
    constructor(e) {
      this.variableNames = [
        "x",
        "dy"
      ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.filterShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthwise_conv2d_backprop_filter";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  class wot {
    constructor(e) {
      this.variableNames = [
        "dy",
        "W"
      ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthwise_conv2d_backprop_input";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  function _ot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, dy: a } = e, { strides: s, dilations: o, pad: l, dimRoundingMode: u, filterShape: c } = r, h = Sn(i.shape, c, s, o, l, u, true), d = new bot(h), f = [
      {
        type: "int32",
        data: [
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.padInfo.top,
          h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.filterHeight,
          h.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          h.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.inHeight
        ]
      },
      {
        type: "int32",
        data: [
          h.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.batchSize
        ]
      },
      {
        type: "int32",
        data: [
          h.outChannels / h.inChannels
        ]
      }
    ];
    return t.runWebGPUProgram(d, [
      i,
      a
    ], "float32", f);
  }
  const Sot = {
    kernelName: rI,
    backendName: "webgpu",
    kernelFunc: _ot
  };
  function Cot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, filter: a } = e, { strides: s, dilations: o, pad: l, dimRoundingMode: u, inputShape: c } = r, h = Sn(c, a.shape, s, o, l, u, true), d = new wot(h), f = [
      {
        type: "int32",
        data: [
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.filterHeight - 1 - h.padInfo.top,
          h.filterWidth - 1 - h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.filterHeight,
          h.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          h.outWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.outChannels / h.inChannels
        ]
      }
    ];
    return t.runWebGPUProgram(d, [
      i,
      a
    ], i.dtype, f);
  }
  const Iot = {
    kernelName: iI,
    backendName: "webgpu",
    kernelFunc: Cot
  };
  class kot {
    constructor(e) {
      this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e,
        e
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "diag";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `;
    }
  }
  function Tot(n) {
    const { inputs: e, backend: t } = n, { x: r } = e, i = [
      ...r.shape,
      ...r.shape
    ], a = X(r.shape), s = Je({
      inputs: {
        x: r
      },
      backend: t,
      attrs: {
        shape: [
          a
        ]
      }
    }), o = new kot(a), l = t.runWebGPUProgram(o, [
      s
    ], s.dtype), u = Je({
      inputs: {
        x: l
      },
      backend: t,
      attrs: {
        shape: i
      }
    });
    return t.disposeData(s.dataId), t.disposeData(l.dataId), u;
  }
  const Aot = {
    kernelName: aI,
    backendName: "webgpu",
    kernelFunc: Tot
  };
  class Dot {
    constructor(e) {
      this.variableNames = [
        "x",
        "w"
      ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.outShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "dilation2d";
    }
    getUserCode() {
      return `
       ${Ne("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `;
    }
  }
  function Rot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a } = e, { strides: s, pad: o, dilations: l } = r, u = po(i.shape, a.shape, s, o, "NHWC", l), c = [
      u.padInfo.top,
      u.padInfo.left
    ], h = [
      {
        type: "int32",
        data: [
          u.filterHeight,
          u.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          ...c
        ]
      },
      {
        type: "int32",
        data: [
          u.strideHeight,
          u.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          u.dilationHeight,
          u.dilationWidth
        ]
      }
    ], d = new Dot(u);
    return t.runWebGPUProgram(d, [
      i,
      a
    ], i.dtype, h);
  }
  const $ot = {
    kernelName: of,
    backendName: "webgpu",
    kernelFunc: Rot
  };
  class Not {
    constructor(e, t) {
      if (this.variableNames = [
        "x",
        "w",
        "dy"
      ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = e.inShape, this.dispatchLayout = We(e.outShape), this.dispatch = Ee(this.dispatchLayout, e.outShape, this.workgroupSize), t !== "float32" && t !== "int32") throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);
      this.type = t, this.shaderKey = "dilation2DBackpropInput";
    }
    getUserCode() {
      return `
       ${Ne("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Nc("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    }
  }
  class Eot {
    constructor(e, t, r) {
      if (this.variableNames = [
        "x",
        "w",
        "dy"
      ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = e.filterShape, this.dispatchLayout = We(e.outShape), this.dispatch = Ee(this.dispatchLayout, e.outShape, this.workgroupSize), r !== "float32" && r !== "int32") throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);
      this.type = r, this.shaderKey = "dilation2DBackpropFilter";
    }
    getUserCode() {
      return `
       ${Ne("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Nc("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    }
  }
  function Mot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, dy: s } = e, { strides: o, pad: l, dilations: u } = r, c = po(i.shape, a.shape, o, l, "NHWC", u), h = a.dtype, d = new Eot(c, a.shape, h), f = [
      {
        type: "int32",
        data: [
          c.filterHeight,
          c.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.padInfo.top,
          c.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          c.strideHeight,
          c.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.dilationHeight,
          c.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          X(c.outShape)
        ]
      }
    ], p = ea({
      backend: t,
      attrs: {
        shape: a.shape,
        value: 0,
        dtype: h
      }
    });
    return t.runWebGPUProgram(d, [
      i,
      a,
      s
    ], h, f, p);
  }
  const Pot = {
    kernelName: Yg,
    backendName: "webgpu",
    kernelFunc: Mot
  };
  function Lot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, dy: s } = e, { strides: o, pad: l, dilations: u } = r, c = po(i.shape, a.shape, o, l, "NHWC", u), h = i.dtype, d = new Not(c, h), f = [
      {
        type: "int32",
        data: [
          c.filterHeight,
          c.filterWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.padInfo.top,
          c.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          c.strideHeight,
          c.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.dilationHeight,
          c.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          X(c.outShape)
        ]
      }
    ], p = ea({
      backend: t,
      attrs: {
        shape: c.inShape,
        value: 0,
        dtype: h
      }
    });
    return t.runWebGPUProgram(d, [
      i,
      a,
      s
    ], h, f, p);
  }
  const Fot = {
    kernelName: Xg,
    backendName: "webgpu",
    kernelFunc: Lot
  };
  class Oot {
    constructor(e, t, r) {
      this.variableNames = [
        "Image"
      ], this.uniforms = "alpha: f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.pixelsOpType = rm.DRAW, this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.type = t, this.textureFormat = r, this.shaderKey = `draw_${t}_${r}`;
    }
    getUserCode() {
      let e;
      const t = this.type === "float32" ? "value" : "value / 255.0";
      return e = `
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`, `
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Ne("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `;
    }
  }
  function Bot(n) {
    const { inputs: e, backend: t, attrs: r } = n, { image: i } = e, { canvas: a, options: s } = r, [o, l] = i.shape.slice(0, 2), { imageOptions: u } = s || {}, c = (u == null ? void 0 : u.alpha) || 1, h = t.device.features.has("bgra8unorm-storage") ? "bgra8unorm" : "rgba8unorm", d = [
      o,
      l
    ], f = new Oot(d, i.dtype, h);
    a.width = l, a.height = o;
    const p = "webgpu";
    let g = a.getContext(p), m;
    g || (m = new OffscreenCanvas(l, o), g = m.getContext(p));
    const v = i.shape.length === 3 ? i.shape[2] : 1;
    g.configure({
      device: t.device,
      format: h,
      usage: GPUTextureUsage.STORAGE_BINDING,
      alphaMode: "premultiplied"
    });
    const y = "int32", x = t.makeTensorInfo(d, y), b = t.tensorMap.get(x.dataId);
    b.resource = g.getCurrentTexture(), b.external = true;
    const w = [
      {
        type: "uint32",
        data: [
          v
        ]
      },
      {
        type: "float32",
        data: [
          c
        ]
      }
    ];
    if (t.runWebGPUProgram(f, [
      i
    ], y, w, x), m) {
      const _ = a.getContext("2d");
      if (!_) throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");
      _.drawImage(m, 0, 0);
    }
    return t.disposeData(x.dataId), i;
  }
  const zot = {
    kernelName: X7,
    backendName: "webgpu",
    kernelFunc: Bot
  };
  const Mre = jr({
    opType: _t.MUL,
    cpuKernelImpl: Hit,
    supportsComplex: true
  }), Vot = {
    kernelName: Ef,
    backendName: "webgpu",
    kernelFunc: Mre
  };
  function Pre(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    return vp(i, a, s, "sum", t);
  }
  const Wot = {
    kernelName: ep,
    backendName: "webgpu",
    kernelFunc: Pre
  };
  function Got(n) {
    const { inputs: e, backend: t, attrs: r } = n, { equation: i } = r, a = e, { allDims: s, summedDims: o, idDims: l } = VI(i, a.length);
    GI(s.length, l, a);
    const { path: u, steps: c } = UI(o, l), h = c.length;
    let d = null, f = s.length;
    const p = [];
    for (let g = 0; g < h; ++g) {
      for (const m of c[g]) {
        const { permutationIndices: v, expandDims: y } = WI(f, l[m]);
        let x;
        HI(v) ? x = a[m] : (x = ll({
          inputs: {
            x: a[m]
          },
          backend: t,
          attrs: {
            perm: v
          }
        }), p.push(x));
        const b = x.shape.slice();
        for (let w = 0; w < y.length; ++w) b.splice(y[w], 0, 1);
        Jt(x.shape, b) || (x = Je({
          inputs: {
            x
          },
          backend: t,
          attrs: {
            shape: b
          }
        }), p.push(x)), d === null ? d = x : (d = Mre({
          inputs: {
            a: x,
            b: d
          },
          backend: t
        }), p.push(d));
      }
      g < h - 1 && (u[g] >= 0 && (d = Pre({
        inputs: {
          x: d
        },
        backend: t,
        attrs: {
          axis: u[g] - (s.length - f),
          keepDims: false
        }
      }), p.push(d)), f--);
    }
    for (const g of p) g !== d && t.disposeData(g.dataId);
    return d;
  }
  const Uot = {
    kernelName: sI,
    backendName: "webgpu",
    kernelFunc: Got
  };
  const Hot = hn({
    opType: De.ELU
  }), Xot = {
    kernelName: uf,
    backendName: "webgpu",
    kernelFunc: Hot
  };
  const Yot = (n) => {
    const { inputs: e, backend: t } = n, { dy: r, y: i } = e, a = new eC(_t.ELU_DER, r.shape, i.shape);
    return t.runWebGPUProgram(a, [
      r,
      i
    ], r.dtype);
  }, qot = {
    kernelName: Um,
    backendName: "webgpu",
    kernelFunc: Yot
  };
  const jot = jr({
    opType: _t.EQUAL,
    dtype: "bool",
    cpuKernelImpl: Rit
  }), Kot = {
    kernelName: Hm,
    backendName: "webgpu",
    kernelFunc: jot
  };
  const Zot = hn({
    opType: De.ERF
  }), Qot = {
    kernelName: cf,
    backendName: "webgpu",
    kernelFunc: Zot
  };
  const Jot = hn({
    opType: De.EXP,
    cpuKernelImpl: $it,
    dtype: "float32"
  }), elt = {
    kernelName: hf,
    backendName: "webgpu",
    kernelFunc: Jot
  };
  function X$(n) {
    const { inputs: e, attrs: t, backend: r } = n, { dim: i } = t, { input: a } = e, s = a.shape.length, o = a.shape.slice();
    let l = i;
    return i < 0 && (B(-(s + 1) <= i, () => `Axis must be in the interval [${-(s + 1)}, ${s}]`), l = s + i + 1), o.splice(l, 0, 1), Je({
      inputs: {
        x: a
      },
      backend: r,
      attrs: {
        shape: o
      }
    });
  }
  const tlt = {
    kernelName: Xm,
    backendName: "webgpu",
    kernelFunc: X$
  };
  const nlt = hn({
    opType: De.EXPM1,
    cpuKernelImpl: Nit
  }), rlt = {
    kernelName: df,
    backendName: "webgpu",
    kernelFunc: nlt
  };
  class uH {
    constructor(e, t) {
      this.variableNames = [
        "real",
        "imag"
      ], this.outputShape = [], this.uniforms = "exponentMultiplier : f32, denominator: f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.component = e, this.shaderKey = `fft_${e}`;
    }
    getUserCode() {
      return `
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component === "real" ? "return real * expR - imag * expI;" : "return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `;
    }
  }
  function Lre(n, e, t) {
    const r = t.tensorMap.get(n.dataId), i = X(n.shape), a = n.shape[n.shape.length - 1], s = i / a, o = [], l = Je({
      inputs: {
        x: n
      },
      backend: t,
      attrs: {
        shape: [
          s,
          a
        ]
      }
    });
    o.push(l);
    const u = l.shape, c = new uH("real", u), h = new uH("imag", u), d = [
      {
        dataId: r.complexTensorInfos.real.dataId,
        dtype: r.complexTensorInfos.real.dtype,
        shape: u
      },
      {
        dataId: r.complexTensorInfos.imag.dataId,
        dtype: r.complexTensorInfos.imag.dtype,
        shape: u
      }
    ], f = e ? 2 * Math.PI : -2 * Math.PI, p = e ? u[1] : 1, g = [
      {
        type: "float32",
        data: [
          f
        ]
      },
      {
        type: "float32",
        data: [
          p
        ]
      }
    ], m = t.runWebGPUProgram(c, d, "float32", g);
    o.push(m);
    const v = t.runWebGPUProgram(h, d, "float32", g);
    o.push(v);
    const y = mp({
      inputs: {
        real: m,
        imag: v
      },
      backend: t
    });
    o.push(y);
    const x = Je({
      inputs: {
        x: y
      },
      backend: t,
      attrs: {
        shape: n.shape
      }
    });
    return o.forEach((b) => t.disposeData(b.dataId)), x;
  }
  function ilt(n) {
    const { inputs: e, backend: t } = n, { input: r } = e;
    return Lre(r, false, t);
  }
  const alt = {
    kernelName: oI,
    backendName: "webgpu",
    kernelFunc: ilt
  };
  class slt {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "flipLeftRight";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `;
    }
  }
  const olt = {
    kernelName: Ym,
    backendName: "webgpu",
    kernelFunc: ({ inputs: n, backend: e }) => {
      const { image: t } = n, r = e, i = new slt(t.shape);
      return r.runWebGPUProgram(i, [
        t
      ], t.dtype);
    }
  };
  const llt = hn({
    opType: De.FLOOR,
    cpuKernelImpl: Eit
  }), ult = {
    kernelName: ff,
    backendName: "webgpu",
    kernelFunc: llt
  };
  const clt = jr({
    opType: _t.FLOOR_DIV,
    cpuKernelImpl: Mit,
    dtype: "int32"
  }), hlt = {
    kernelName: pf,
    backendName: "webgpu",
    kernelFunc: clt
  };
  class dlt {
    constructor(e, t, r = false) {
      this.pixelsOpType = rm.FROM_PIXELS, this.outputShape = [
        0
      ], this.variableNames = [], this.workgroupSize = [
        256,
        1,
        1
      ], this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        t,
        1,
        1
      ]), this.importVideo = r, this.shaderKey = `fromPixels_${this.importVideo}`;
    }
    getUserCode() {
      const e = this.importVideo ? "textureLoad(src, vec2<i32>(coords.yx));" : "textureLoad(src, vec2<i32>(coords.yx), 0)";
      return `
      @binding(1) @group(0) var src: ${this.importVideo ? "texture_external" : "texture_2d<f32>"};
      ${Ne("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `;
    }
  }
  const flt = {
    kernelName: K7,
    backendName: "webgpu",
    kernelFunc: plt
  };
  let Kp, kA = ne().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
  function plt(n) {
    const { inputs: e, backend: t, attrs: r } = n;
    let { pixels: i } = e;
    const { numChannels: a } = r;
    if (i == null) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    const s = typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement, o = typeof HTMLImageElement < "u" && i instanceof HTMLImageElement, l = typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas, u = typeof ImageBitmap < "u" && i instanceof ImageBitmap, [c, h] = s ? [
      i.videoWidth,
      i.videoHeight
    ] : [
      i.width,
      i.height
    ], d = [
      h,
      c,
      a
    ], f = ne().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE") && s, p = s || o;
    if (u || l || p) {
      let y;
      if (f) y = t.device.importExternalTexture({
        source: i
      });
      else {
        if (p) {
          const R = ne().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
          (Kp == null || R !== kA) && (kA = R, Kp = document.createElement("canvas").getContext("2d", {
            willReadFrequently: kA
          })), Kp.canvas.width = c, Kp.canvas.height = h, Kp.drawImage(i, 0, 0, c, h), i = Kp.canvas;
        }
        const T = GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, D = t.textureManager.acquireTexture(d[1], d[0], "rgba8unorm", T);
        t.queue.copyExternalImageToTexture({
          source: i
        }, {
          texture: D
        }, [
          d[1],
          d[0]
        ]), y = D;
      }
      const x = X(d), b = Be(d), w = new dlt(d, a, f), _ = [
        {
          type: "uint32",
          data: [
            x
          ]
        },
        {
          type: "uint32",
          data: [
            a
          ]
        },
        {
          type: "uint32",
          data: [
            ...b
          ]
        }
      ], S = t.makeTensorInfo([
        h,
        c
      ], "int32"), I = t.tensorMap.get(S.dataId);
      I.resource = y;
      const C = t.runWebGPUProgram(w, [
        S
      ], "int32", _);
      return t.disposeData(S.dataId), C;
    }
    const g = i.data;
    let m = g;
    if (a != null && a !== 4) {
      m = new Uint8Array(i.width * i.height * a);
      const y = g.length;
      let x = 0;
      for (let b = 0; b < y; b++) b % 4 < a && (m[x++] = g[b]);
    }
    const v = t.makeTensorInfo(d, "int32", new Int32Array(m));
    return t.uploadToGPU(v.dataId), v;
  }
  class glt {
    constructor(e, t, r, i, a) {
      this.uniforms = "varianceEpsilon : f32,", this.workgroupSize = [
        128,
        1,
        1
      ], this.size = true, this.variableNames = [
        "x",
        "mean",
        "variance"
      ], ht(e, t), ht(e, r), this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), i != null && (ht(e, i), this.variableNames.push("offset")), a != null && (ht(e, a), this.variableNames.push("scale")), this.offsetShape = i, this.scaleShape = a, this.shaderKey = "batchNorm";
    }
    getUserCode() {
      let e = "0.0";
      this.offsetShape != null && (e = "getOffsetByOutputIndex(index)");
      let t = "1.0";
      return this.scaleShape != null && (t = "getScaleByOutputIndex(index)"), `
      ${Ne("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `;
    }
  }
  const mlt = {
    kernelName: gf,
    backendName: "webgpu",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { x: r, scale: i, offset: a, mean: s, variance: o } = n, { varianceEpsilon: l } = e, u = t, c = [
        r,
        s,
        o
      ];
      let h = null;
      a != null && (h = a.shape, c.push(a));
      let d = null;
      i != null && (d = i.shape, c.push(i));
      const f = new glt(r.shape, s.shape, o.shape, h, d), p = [
        {
          type: "float32",
          data: [
            l
          ]
        }
      ];
      return u.runWebGPUProgram(f, c, r.dtype, p);
    }
  };
  function vlt(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = e, { strides: l, pad: u, dataFormat: c, dilations: h, dimRoundingMode: d, activation: f, leakyreluAlpha: p } = r, g = Oi(c), m = Sn(i.shape, a.shape, l, h, u, d, false, g);
    return Rre({
      x: i,
      filter: a,
      convInfo: m,
      backend: t,
      bias: s,
      preluActivationWeights: o,
      leakyreluAlpha: p,
      activation: f
    });
  }
  const ylt = {
    kernelName: yd,
    backendName: "webgpu",
    kernelFunc: vlt
  };
  function xlt(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, filter: a, bias: s, preluActivationWeights: o } = e, { strides: l, pad: u, dilations: c, dimRoundingMode: h, activation: d, leakyreluAlpha: f } = r;
    let p = c;
    p == null && (p = [
      1,
      1
    ]), B(Pr(l, p), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${p}'`);
    const g = Sn(i.shape, a.shape, l, p, u, h, true), m = [
      i,
      a
    ], v = s != null, y = o != null;
    v && m.push(s), y && m.push(o);
    const x = [
      {
        type: "int32",
        data: [
          g.padInfo.top,
          g.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          g.inHeight,
          g.inWidth
        ]
      }
    ];
    let b;
    return g.outHeight > 4 && g.outWidth > 4 && g.strideWidth <= 2 && g.inChannels === g.outChannels && g.dilationHeight === 1 && g.dilationWidth === 1 && g.inChannels % 4 === 0 ? (b = new Nre(g, v, d, y), x.push({
      type: "int32",
      data: [
        b.virtualWidth
      ]
    })) : (b = new Ere(g, v, d, y), x.push({
      type: "int32",
      data: [
        g.filterHeight
      ]
    }, {
      type: "int32",
      data: [
        g.filterWidth
      ]
    }, {
      type: "int32",
      data: [
        g.strideHeight,
        g.strideWidth
      ]
    }, {
      type: "int32",
      data: [
        g.dilationHeight,
        g.dilationWidth
      ]
    })), d === "leakyrelu" && (x.push({
      type: "float32",
      data: [
        f
      ]
    }), b.uniforms += " alpha : f32,"), t.runWebGPUProgram(b, m, "float32", x);
  }
  const blt = {
    kernelName: vb,
    backendName: "webgpu",
    kernelFunc: xlt
  };
  class wlt {
    constructor(e, t) {
      this.variableNames = [
        "A",
        "indices"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = `gathernd_${e}`, this.sliceDim = e, this.uniforms = `sliceDim : i32, strides : ${lr(e)},`;
    }
    getUserCode() {
      let e;
      return this.sliceDim > 1 ? e = "uniforms.strides[j]" : e = "uniforms.strides", `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `;
    }
  }
  function _lt(n) {
    const { inputs: e, backend: t } = n, { params: r, indices: i } = e, a = i.shape, s = a[a.length - 1], o = X(r.shape), [l, u, c, h] = _b(r, i), d = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u,
          s
        ]
      }
    }), f = Je({
      inputs: {
        x: r
      },
      backend: t,
      attrs: {
        shape: [
          X(r.shape) / c,
          c
        ]
      }
    });
    if (t.shouldExecuteOnCPU([
      r,
      i
    ]) || r.dtype === "string") {
      const y = t.readSync(i.dataId), x = t.bufferSync(r), b = Pit(y, x, r.dtype, u, s, c, h, r.shape, o);
      return t.makeTensorInfo(l, r.dtype, b.values);
    }
    const p = new wlt(s, [
      u,
      c
    ]), g = [
      {
        type: "int32",
        data: [
          s
        ]
      },
      {
        type: "int32",
        data: h
      }
    ], m = t.runWebGPUProgram(p, [
      f,
      d
    ], f.dtype, g), v = Je({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        shape: l
      }
    });
    return t.disposeData(d.dataId), t.disposeData(f.dataId), t.disposeData(m.dataId), v;
  }
  const Slt = {
    kernelName: ib,
    backendName: "webgpu",
    kernelFunc: _lt
  };
  class Clt {
    constructor(e, t) {
      this.variableNames = [
        "A",
        "indices"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.slice(), this.aShape = e, this.outputShape = t, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "gather";
    }
    getUserCode() {
      const e = Ilt(this.aShape);
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `;
    }
  }
  function Ilt(n) {
    const e = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w"
    ], t = [];
    for (let r = 0; r < n.length; r++) r === 2 ? t.push("indexZ") : t.push(`${e[r]}`);
    return t.join();
  }
  function Fre(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, indices: a } = e, { axis: s, batchDims: o } = r, l = yt(s, i.shape)[0], u = Nb(i, a, l, o), c = X(a.shape), h = [], d = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u.batchSize,
          u.outerSize,
          u.dimSize,
          u.sliceSize
        ]
      }
    }), f = Je({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          u.batchSize,
          c / u.batchSize
        ]
      }
    });
    h.push(d), h.push(f);
    const p = [
      u.batchSize,
      u.outerSize,
      c / u.batchSize,
      u.sliceSize
    ];
    if (t.shouldExecuteOnCPU([
      i,
      a
    ])) {
      const x = t.tensorMap.get(f.dataId).values, b = Nt(f.shape, f.dtype, x), _ = t.tensorMap.get(d.dataId).values, S = Nt(d.shape, d.dtype, _), I = Lit(S, b, p);
      return h.forEach((C) => t.disposeData(C.dataId)), t.makeTensorInfo(u.outputShape, I.dtype, I.values);
    }
    const g = new Clt(d.shape, p), m = t.runWebGPUProgram(g, [
      d,
      f
    ], d.dtype);
    h.push(m);
    const v = Je({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        shape: u.outputShape
      }
    });
    return h.forEach((y) => t.disposeData(y.dataId)), v;
  }
  const klt = {
    kernelName: qm,
    backendName: "webgpu",
    kernelFunc: Fre
  };
  const Tlt = jr({
    opType: _t.GREATER,
    cpuKernelImpl: Oit,
    dtype: "bool"
  }), Alt = {
    kernelName: jm,
    backendName: "webgpu",
    kernelFunc: Tlt
  };
  const Dlt = jr({
    opType: _t.GREATER_EQUAL,
    dtype: "bool",
    cpuKernelImpl: Fit
  }), Rlt = {
    kernelName: mf,
    backendName: "webgpu",
    kernelFunc: Dlt
  };
  function $lt(n) {
    const { inputs: e, backend: t } = n, { input: r } = e;
    return Lre(r, true, t);
  }
  const Nlt = {
    kernelName: lI,
    backendName: "webgpu",
    kernelFunc: $lt
  };
  const Elt = hn({
    opType: De.IS_FINITE,
    dtype: "bool"
  }), Mlt = {
    kernelName: yf,
    backendName: "webgpu",
    kernelFunc: Elt
  };
  const Plt = hn({
    opType: De.IS_INF,
    dtype: "bool"
  }), Llt = {
    kernelName: xf,
    backendName: "webgpu",
    kernelFunc: Plt
  };
  const Flt = hn({
    opType: De.IS_NAN,
    dtype: "bool"
  }), Olt = {
    kernelName: bf,
    backendName: "webgpu",
    kernelFunc: Flt
  };
  function Blt(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { alpha: a } = r, s = [
      {
        type: "float32",
        data: [
          a
        ]
      }
    ], o = new Ov(i.shape, De.LEAKYRELU, "alpha : f32,");
    return t.runWebGPUProgram(o, [
      i
    ], "float32", s);
  }
  const zlt = {
    kernelName: wf,
    backendName: "webgpu",
    kernelFunc: Blt
  };
  const Vlt = jr({
    opType: _t.LESS,
    dtype: "bool",
    cpuKernelImpl: zit
  }), Wlt = {
    kernelName: Km,
    backendName: "webgpu",
    kernelFunc: Vlt
  };
  const Glt = jr({
    opType: _t.LESS_EQUAL,
    dtype: "bool",
    cpuKernelImpl: Bit
  }), Ult = {
    kernelName: Zm,
    backendName: "webgpu",
    kernelFunc: Glt
  };
  class Hlt {
    constructor(e) {
      this.variableNames = [], this.outputShape = [], this.uniforms = "start : f32, step : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "linSpace";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `;
    }
  }
  function Xlt(n) {
    const { backend: e, attrs: t } = n, { start: r, stop: i, num: a } = t, s = (i - r) / (a - 1), o = new Hlt(a), l = [
      {
        type: "float32",
        data: [
          r
        ]
      },
      {
        type: "float32",
        data: [
          s
        ]
      }
    ];
    return e.runWebGPUProgram(o, [], "float32", l);
  }
  const Ylt = {
    kernelName: ab,
    backendName: "webgpu",
    kernelFunc: Xlt
  };
  const qlt = hn({
    opType: De.LOG,
    cpuKernelImpl: Vit
  }), jlt = {
    kernelName: _f,
    backendName: "webgpu",
    kernelFunc: qlt
  };
  const Klt = hn({
    opType: De.LOG1P
  }), Zlt = {
    kernelName: Sf,
    backendName: "webgpu",
    kernelFunc: Klt
  };
  const Qlt = jr({
    opType: _t.LOGICAL_AND,
    dtype: "bool"
  }), Jlt = {
    kernelName: Qm,
    backendName: "webgpu",
    kernelFunc: Qlt
  };
  const eut = hn({
    opType: De.LOGICAL_NOT
  }), tut = {
    kernelName: Jm,
    backendName: "webgpu",
    kernelFunc: eut
  };
  const nut = jr({
    opType: _t.LOGICAL_OR
  }), rut = {
    kernelName: ev,
    backendName: "webgpu",
    kernelFunc: nut
  };
  const Ore = `
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;
  class iut {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "lrn";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${Ore}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `;
    }
  }
  class aut {
    constructor(e, t) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [
        256,
        1,
        1
      ], this.maxAllowRadius = 16, B(t <= this.maxAllowRadius, () => `Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`), this.outputShape = e, this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius, this.dispatchLayout = {
        x: [
          3
        ],
        y: [
          2
        ],
        z: [
          0,
          1
        ]
      }, this.dispatch = Ee(this.dispatchLayout, this.outputShape, [
        this.elementsPerWorkgroup,
        this.workgroupSize[1],
        this.workgroupSize[2]
      ]), this.shaderKey = "lrn_shared";
    }
    getUserCode() {
      return `
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Ne()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${Ore}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `;
    }
  }
  function sut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { depthRadius: a, bias: s, alpha: o, beta: l } = r;
    let u;
    a > 16 ? u = new iut(i.shape) : u = new aut(i.shape, a);
    const c = [
      {
        type: "int32",
        data: [
          a
        ]
      },
      {
        type: "float32",
        data: [
          s
        ]
      },
      {
        type: "float32",
        data: [
          o
        ]
      },
      {
        type: "float32",
        data: [
          l
        ]
      }
    ];
    return t.runWebGPUProgram(u, [
      i
    ], i.dtype, c);
  }
  const out = {
    kernelName: Cf,
    backendName: "webgpu",
    kernelFunc: sut
  };
  class lut {
    constructor(e) {
      this.outputShape = [], this.variableNames = [
        "inputImage",
        "outputImage",
        "dy"
      ], this.uniforms = "depthRadius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "lrn_grad";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `;
    }
  }
  function uut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, y: a, dy: s } = e, { depthRadius: o, bias: l, alpha: u, beta: c } = r, h = new lut(i.shape), d = [
      {
        type: "int32",
        data: [
          o
        ]
      },
      {
        type: "float32",
        data: [
          l
        ]
      },
      {
        type: "float32",
        data: [
          u
        ]
      },
      {
        type: "float32",
        data: [
          c
        ]
      }
    ];
    return t.runWebGPUProgram(h, [
      i,
      a,
      s
    ], i.dtype, d);
  }
  const cut = {
    kernelName: tv,
    backendName: "webgpu",
    kernelFunc: uut
  };
  const hut = jr({
    opType: _t.MAX,
    cpuKernelImpl: Git
  }), dut = {
    kernelName: kf,
    backendName: "webgpu",
    kernelFunc: hut
  };
  function fut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dimRoundingMode: l } = r, c = dr(i.shape, a, s, 1, o, l);
    return kre(i, c, "max", t);
  }
  const put = {
    kernelName: Tf,
    backendName: "webgpu",
    kernelFunc: fut
  };
  function gut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { filterSize: a, strides: s, pad: o, dataFormat: l, dimRoundingMode: u } = r, c = [
      1,
      1,
      1
    ], h = vi(i.shape, a, s, c, o, u, l), d = new OL(h, "max"), f = [
      {
        type: "int32",
        data: [
          h.strideDepth,
          h.strideHeight,
          h.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.padInfo.front,
          h.padInfo.top,
          h.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          h.inDepth,
          h.inHeight,
          h.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          h.effectiveFilterDepth,
          h.effectiveFilterHeight,
          h.effectiveFilterWidth
        ]
      }
    ];
    return t.runWebGPUProgram(d, [
      i
    ], i.dtype, f);
  }
  const mut = {
    kernelName: nv,
    backendName: "webgpu",
    kernelFunc: gut
  };
  class vut {
    constructor(e) {
      this.variableNames = [
        "dy",
        "maxPos"
      ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "maxPool2DBackprop";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  class yut {
    constructor(e) {
      this.variableNames = [
        "dy",
        "maxPos"
      ], this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e.inShape, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "maxPool3DBackprop";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
  }
  function xut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a } = e, s = a, { filterSize: o, strides: l, pad: u, dimRoundingMode: c } = r, h = [
      1,
      1,
      1
    ], d = vi(s.shape, o, l, h, u, c), f = new OL(d, "max", true);
    let p = [
      {
        type: "int32",
        data: [
          d.strideDepth,
          d.strideHeight,
          d.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.padInfo.front,
          d.padInfo.top,
          d.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          d.inDepth,
          d.inHeight,
          d.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.effectiveFilterDepth,
          d.effectiveFilterHeight,
          d.effectiveFilterWidth
        ]
      }
    ];
    const g = t.runWebGPUProgram(f, [
      s
    ], "int32", p), m = new yut(d);
    p = [
      {
        type: "int32",
        data: [
          d.strideDepth,
          d.strideHeight,
          d.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.effectiveFilterDepth - 1 - d.padInfo.front,
          d.effectiveFilterHeight - 1 - d.padInfo.top,
          d.effectiveFilterWidth - 1 - d.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          d.effectiveFilterDepth,
          d.effectiveFilterHeight,
          d.effectiveFilterWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.outDepth
        ]
      },
      {
        type: "int32",
        data: [
          d.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          d.outWidth
        ]
      }
    ];
    const v = t.runWebGPUProgram(m, [
      i,
      g
    ], s.dtype, p);
    return t.disposeData(g.dataId), v;
  }
  const but = {
    kernelName: ob,
    backendName: "webgpu",
    kernelFunc: xut
  };
  function wut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { dy: i, input: a, output: s } = e, o = a;
    bre([
      a,
      s
    ], "maxPoolGrad");
    const { filterSize: l, strides: u, pad: c, dimRoundingMode: h } = r, d = dr(o.shape, l, u, 1, c, h), f = new yx(d, "max", true);
    let p = [
      {
        type: "int32",
        data: [
          d.strideHeight,
          d.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.padInfo.top,
          d.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          d.dilationHeight,
          d.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.inHeight,
          d.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.effectiveFilterHeight,
          d.effectiveFilterWidth
        ]
      }
    ];
    const g = t.runWebGPUProgram(f, [
      o
    ], "int32", p), m = new vut(d);
    p = [
      {
        type: "int32",
        data: [
          d.strideHeight,
          d.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.effectiveFilterHeight - 1 - d.padInfo.top,
          d.effectiveFilterWidth - 1 - d.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          d.dilationHeight,
          d.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.effectiveFilterHeight,
          d.effectiveFilterWidth
        ]
      },
      {
        type: "int32",
        data: [
          d.outHeight
        ]
      },
      {
        type: "int32",
        data: [
          d.outWidth
        ]
      }
    ];
    const v = t.runWebGPUProgram(m, [
      i,
      g
    ], o.dtype, p);
    return t.disposeData(g.dataId), v;
  }
  const _ut = {
    kernelName: sb,
    backendName: "webgpu",
    kernelFunc: wut
  };
  function Sut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { filterSize: i, strides: a, pad: s, includeBatchInIndex: o } = r, { x: l } = e;
    B(l.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);
    const u = [
      1,
      1
    ];
    B(Pr(a, u), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);
    const c = dr(l.shape, i, a, u, s), h = [
      {
        type: "int32",
        data: [
          c.strideHeight,
          c.strideWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.padInfo.top,
          c.padInfo.left
        ]
      },
      {
        type: "int32",
        data: [
          c.dilationHeight,
          c.dilationWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.inHeight,
          c.inWidth
        ]
      },
      {
        type: "int32",
        data: [
          c.effectiveFilterHeight,
          c.effectiveFilterWidth
        ]
      }
    ];
    let d = new yx(c, "max", false);
    const f = t.runWebGPUProgram(d, [
      l
    ], l.dtype, h);
    d = new yx(c, "max", true, true, o);
    const p = t.runWebGPUProgram(d, [
      l
    ], "int32", h);
    return [
      f,
      p
    ];
  }
  const Cut = {
    kernelName: cI,
    backendName: "webgpu",
    kernelFunc: Sut
  };
  function Iut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    return vp(i, a, s, "min", t);
  }
  const kut = {
    kernelName: Df,
    backendName: "webgpu",
    kernelFunc: Iut
  };
  const Tut = jr({
    opType: _t.MIN,
    cpuKernelImpl: Uit
  }), Aut = {
    kernelName: Rf,
    backendName: "webgpu",
    kernelFunc: Tut
  };
  class Dut {
    constructor(e, t, r) {
      this.uniforms = "", this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t.map((i, a) => i[0] + e[a] + i[1]), this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.xShape = e, t.map((i, a) => {
        this.uniforms += ` pad${a} : vec2<i32>,`;
      }), this.offset = r === "reflect" ? 0 : 1, this.shaderKey = `mirrorPad_${r}`;
    }
    getUserCode() {
      const e = this.xShape.length, t = this.xShape.map((u, c) => `uniforms.pad${c}[0]`).join(","), r = this.xShape.map((u, c) => `uniforms.pad${c}[0] + uniforms.xShape${e > 1 ? `[${c}]` : ""}`).join(","), i = e === 1 ? "start" : "start[i]", a = e === 1 ? "end" : "end[i]", s = e === 1 ? "outC" : "outC[i]", o = lr(e), l = e > 1 ? [
        "coords[0]",
        "coords[1]",
        "coords[2]",
        "coords[3]"
      ].slice(0, e) : "coords";
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let start = ${o}(${t});
          let end = ${o}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${s} < ${i}) {
              ${s} = ${i} * 2 - ${s} - ${this.offset};
            } else if(${s} >= ${a}) {
              ${s} = (${a} - 1) * 2 - ${s} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `;
    }
  }
  const Rut = {
    kernelName: $f,
    backendName: "webgpu",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { x: r } = n, { paddings: i, mode: a } = e, s = t, o = i.map((c) => ({
        type: "int32",
        data: [
          c[0],
          c[1]
        ]
      })), l = new Dut(r.shape, i, a);
      return s.runWebGPUProgram(l, [
        r
      ], r.dtype, o);
    }
  };
  const $ut = jr({
    opType: _t.MOD
  }), Nut = {
    kernelName: Nf,
    backendName: "webgpu",
    kernelFunc: $ut
  };
  class Eut {
    constructor(e, t) {
      this.variableNames = [
        "probs"
      ], this.outputShape = [], this.uniforms = "seed : f32, numOutcomes: i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e,
        t
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "multinomial";
    }
    getUserCode() {
      return `
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ne("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `;
    }
  }
  class Mut {
    constructor(e) {
      this.variableNames = [
        "logits"
      ], this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = [
        this.outputShape[0],
        1,
        1
      ], this.outputShape[1] >= 4096 ? this.workgroupSize = [
        256,
        1,
        1
      ] : this.workgroupSize = [
        64,
        1,
        1
      ], this.shaderKey = "softmax";
    }
    getUserCode() {
      return `
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Ne("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `;
    }
  }
  function Bre(n) {
    const { inputs: e, backend: t, attrs: r } = n, { logits: i } = e, { dim: a } = r, s = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          X(i.shape) / i.shape[a],
          i.shape[a]
        ]
      }
    }), o = new Mut(s.shape), l = t.runWebGPUProgram(o, [
      s
    ], i.dtype), u = Je({
      inputs: {
        x: l
      },
      backend: t,
      attrs: {
        shape: i.shape
      }
    });
    return t.disposeData(s.dataId), t.disposeData(l.dataId), u;
  }
  const Put = {
    kernelName: tp,
    backendName: "webgpu",
    kernelFunc: Bre
  };
  function Lut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { logits: i } = e, { numSamples: a, seed: s, normalized: o } = r, l = o ? i : Bre({
      inputs: {
        logits: i
      },
      backend: t,
      attrs: {
        dim: i.shape.length - 1
      }
    }), u = l.shape[0], c = l.shape[1], h = new Eut(u, a), d = [
      {
        type: "float32",
        data: [
          s
        ]
      },
      {
        type: "int32",
        data: [
          c
        ]
      }
    ], f = t.runWebGPUProgram(h, [
      l
    ], "int32", d);
    return o || t.disposeData(l.dataId), f;
  }
  const Fut = {
    kernelName: lb,
    backendName: "webgpu",
    kernelFunc: Lut
  };
  function Out(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (t.shouldExecuteOnCPU([
      r
    ])) {
      const a = t.tensorMap.get(r.dataId), [s, o] = Xit(a.values, r.shape, r.dtype);
      return t.makeTensorInfo(o, r.dtype, s);
    }
    const i = new Ov(r.shape, De.NEG);
    return t.runWebGPUProgram(i, [
      r
    ], r.dtype);
  }
  const But = {
    kernelName: rv,
    backendName: "webgpu",
    kernelFunc: Out
  };
  function zut(n) {
    console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: e, backend: t, attrs: r } = n, { boxes: i, scores: a } = e, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l } = r, u = t.readSync(i.dataId), c = t.readSync(a.dataId), { selectedIndices: h } = DI(u, c, s, o, l);
    return t.makeTensorInfo([
      h.length
    ], "int32", new Int32Array(h));
  }
  const Vut = {
    kernelName: av,
    backendName: "webgpu",
    kernelFunc: zut
  };
  function Wut(n) {
    console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: e, backend: t, attrs: r } = n, { boxes: i, scores: a } = e, { maxOutputSize: s, iouThreshold: o, scoreThreshold: l, softNmsSigma: u } = r, c = t.readSync(i.dataId), h = t.readSync(a.dataId), d = s, f = o, p = l, g = u, { selectedIndices: m, selectedScores: v } = RI(c, h, d, f, p, g);
    return [
      t.makeTensorInfo([
        m.length
      ], "int32", new Int32Array(m)),
      t.makeTensorInfo([
        v.length
      ], "float32", new Float32Array(v))
    ];
  }
  const Gut = {
    kernelName: sv,
    backendName: "webgpu",
    kernelFunc: Wut
  };
  class Uut {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.uniforms = "onValue : f32, offValue : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e,
        t
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "onehot";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `;
    }
  }
  function Hut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { indices: i } = e, { dtype: a, depth: s, onValue: o, offValue: l } = r, u = X(i.shape), c = new Uut(u, s), h = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u
        ]
      }
    }), d = [
      {
        type: "float32",
        data: [
          o
        ]
      },
      {
        type: "float32",
        data: [
          l
        ]
      }
    ], f = t.runWebGPUProgram(c, [
      h
    ], a, d);
    t.disposeData(h.dataId);
    const p = [
      ...i.shape,
      s
    ], g = Je({
      inputs: {
        x: f
      },
      backend: t,
      attrs: {
        shape: p
      }
    });
    return t.disposeData(f.dataId), g;
  }
  const Xut = {
    kernelName: Mf,
    backendName: "webgpu",
    kernelFunc: Hut
  };
  function nC(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (r.dtype === "complex64") {
      const i = Yb({
        inputs: {
          input: r
        },
        backend: t
      }), a = nC({
        inputs: {
          x: i
        },
        backend: t
      }), s = p2({
        inputs: {
          input: r
        },
        backend: t
      }), o = nC({
        inputs: {
          x: s
        },
        backend: t
      }), l = mp({
        inputs: {
          real: a,
          imag: o
        },
        backend: t
      });
      return t.disposeData(i.dataId), t.disposeData(a.dataId), t.disposeData(s.dataId), t.disposeData(o.dataId), l;
    } else return ea({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: r.dtype === "string" ? "" : 0
      },
      backend: t
    });
  }
  const Yut = {
    kernelName: bv,
    backendName: "webgpu",
    kernelFunc: nC
  };
  function zre(n) {
    const { inputs: e, backend: t } = n, { x: r } = e;
    if (r.dtype === "string") throw new Error("onesLike is not supported under string dtype");
    if (r.dtype === "complex64") {
      const i = Yb({
        inputs: {
          input: r
        },
        backend: t
      }), a = zre({
        inputs: {
          x: i
        },
        backend: t
      }), s = p2({
        inputs: {
          input: r
        },
        backend: t
      }), o = nC({
        inputs: {
          x: s
        },
        backend: t
      }), l = mp({
        inputs: {
          real: a,
          imag: o
        },
        backend: t
      });
      return t.disposeData(i.dataId), t.disposeData(a.dataId), t.disposeData(s.dataId), t.disposeData(o.dataId), l;
    } else return ea({
      attrs: {
        shape: r.shape,
        dtype: r.dtype,
        value: 1
      },
      backend: t
    });
  }
  const qut = {
    kernelName: ov,
    backendName: "webgpu",
    kernelFunc: zre
  };
  function jut(n) {
    const { inputs: e, backend: t, attrs: r } = n, { axis: i } = r;
    if (e.length === 1) return X$({
      inputs: {
        input: e[0]
      },
      backend: t,
      attrs: {
        dim: i
      }
    });
    const a = e[0].shape, s = e[0].dtype;
    e.forEach((c) => {
      Qx(a, c.shape, "All tensors passed to stack must have matching shapes"), B(s === c.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const o = [], l = e.map((c) => {
      const h = X$({
        inputs: {
          input: c
        },
        backend: t,
        attrs: {
          dim: i
        }
      });
      return o.push(h), h;
    }), u = Dre({
      inputs: l,
      backend: t,
      attrs: {
        axis: i
      }
    });
    return o.forEach((c) => t.disposeData(c.dataId)), u;
  }
  const Kut = {
    kernelName: lv,
    backendName: "webgpu",
    kernelFunc: jut
  };
  function Vre(n, e = false) {
    const t = n.length, r = lr(t), i = n.map((h, d) => `uniforms.pad${d}[0]`).join(","), a = n.map((h, d) => `uniforms.pad${d}[0] + uniforms.xShape${t > 1 ? `[${d}]` : ""}`).join(","), s = t > 1 ? `${r}(${i})` : `${i}`, o = t > 1 ? `${r}(${a})` : `${a}`, l = t > 1 ? "any(paddedCoords < start)" : "paddedCoords < start", u = t > 1 ? "any(paddedCoords >= end)" : "paddedCoords >= end", c = t > 1 ? [
      "coords[0]",
      "coords[1]",
      "coords[2]",
      "coords[3]"
    ].slice(0, t) : "coords";
    return `
        let start = ${s};
        let end = ${o};
        if (${l} || ${u}) {
          setOutputAtIndex(index, ${e ? 0 : "uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `;
  }
  class Zut {
    constructor(e, t) {
      this.variableNames = [
        "x"
      ], this.uniforms = "constantValue : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t.map((r, i) => r[0] + e[i] + r[1]), this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), t.map((r, i) => {
        this.uniforms += ` pad${i} : vec2<i32>,`;
      }), this.xShape = e, this.shaderKey = "pad";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${Vre(this.xShape)}
        }
      }
    `;
    }
  }
  const Qut = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { paddings: a, constantValue: s } = r;
    if (a.every((u) => Jt(u, [
      0,
      0
    ]))) return Aa({
      inputs: {
        x: i
      },
      backend: t
    });
    if (X(i.shape) === 0) {
      const u = a.map((c, h) => c[0] + i.shape[h] + c[1]);
      return ea({
        backend: t,
        attrs: {
          shape: u,
          value: s,
          dtype: i.dtype
        }
      });
    }
    const o = [
      {
        type: "float32",
        data: [
          s
        ]
      }
    ];
    a.map((u) => o.push({
      type: "int32",
      data: [
        u[0],
        u[1]
      ]
    }));
    const l = new Zut(i.shape, a);
    return t.runWebGPUProgram(l, [
      i
    ], i.dtype, o);
  }, Jut = {
    kernelName: Pf,
    backendName: "webgpu",
    kernelFunc: Qut
  };
  const ect = jr({
    opType: _t.POW
  }), tct = {
    kernelName: Lf,
    backendName: "webgpu",
    kernelFunc: ect
  };
  function nct(n) {
    const { inputs: e, backend: t } = n, { x: r, alpha: i } = e, a = new eC(_t.PRELU, r.shape, i.shape);
    return t.runWebGPUProgram(a, [
      r,
      i
    ], "float32");
  }
  const rct = {
    kernelName: Ff,
    backendName: "webgpu",
    kernelFunc: nct
  };
  function ict(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { axis: a, keepDims: s } = r;
    return vp(i, a, s, "prod", t);
  }
  const act = {
    kernelName: Of,
    backendName: "webgpu",
    kernelFunc: ict
  };
  const sct = (n) => {
    const { backend: e, attrs: t } = n, { start: r, stop: i, step: a, dtype: s } = t, o = jit(r, i, a, s);
    return e.makeTensorInfo([
      o.length
    ], s, o);
  }, oct = {
    kernelName: cb,
    backendName: "webgpu",
    kernelFunc: sct
  };
  const lct = jr({
    opType: _t.DIV
  }), uct = {
    kernelName: lf,
    backendName: "webgpu",
    kernelFunc: lct
  };
  const cct = hn({
    opType: De.RECIPROCAL
  }), hct = {
    kernelName: Bf,
    backendName: "webgpu",
    kernelFunc: cct
  };
  const dct = hn({
    opType: De.RELU
  }), fct = {
    kernelName: zf,
    backendName: "webgpu",
    kernelFunc: dct
  };
  const pct = hn({
    opType: De.RELU6
  }), gct = {
    kernelName: Gf,
    backendName: "webgpu",
    kernelFunc: pct
  };
  class mct {
    constructor(e, t, r) {
      this.variableNames = [
        "x"
      ], this.uniforms = "adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e[0],
        t,
        r,
        e[3]
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "resizeBilinear";
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    }
  }
  function vct(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i } = e, { alignCorners: a, size: s, halfPixelCenters: o } = r, [l, u] = s, c = a && l > 1 ? 1 : 0, h = a && u > 1 ? 1 : 0, f = [
      {
        type: "float32",
        data: [
          c,
          h
        ]
      },
      {
        type: "float32",
        data: [
          o ? 0.5 : 0
        ]
      }
    ], p = new mct(i.shape, l, u);
    return t.runWebGPUProgram(p, [
      i
    ], "float32", f);
  }
  const yct = {
    kernelName: Wf,
    backendName: "webgpu",
    kernelFunc: vct
  };
  class xct {
    constructor(e, t) {
      this.variableNames = [
        "dy"
      ], this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.alignCorners = t, this.shaderKey = `resizeBilinearBackprop_${t}`;
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    }
  }
  function bct(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i, dy: a } = e, { alignCorners: s } = r, [, o, l] = i.shape, [, u, c] = a.shape, h = [
      s && u > 1 ? o - 1 : o,
      s && c > 1 ? l - 1 : l
    ], d = [
      s && u > 1 ? u - 1 : u,
      s && c > 1 ? c - 1 : c
    ], f = h[0] / d[0], p = h[1] / d[1], g = 1 / f, m = 1 / p, v = Math.ceil(g) * 2 + 2, y = Math.ceil(m) * 2 + 2, x = new xct(i.shape, s), b = [
      {
        type: "int32",
        data: h
      },
      {
        type: "int32",
        data: d
      },
      {
        type: "float32",
        data: [
          f
        ]
      },
      {
        type: "float32",
        data: [
          p
        ]
      },
      {
        type: "float32",
        data: [
          g
        ]
      },
      {
        type: "float32",
        data: [
          m
        ]
      },
      {
        type: "int32",
        data: [
          v
        ]
      },
      {
        type: "int32",
        data: [
          y
        ]
      }
    ];
    return t.runWebGPUProgram(x, [
      a
    ], a.dtype, b);
  }
  const wct = {
    kernelName: hv,
    backendName: "webgpu",
    kernelFunc: bct
  };
  class _ct {
    constructor(e, t, r, i) {
      this.variableNames = [
        "x"
      ], this.uniforms = "adjustHeightWidth : vec2<f32>, roundBase : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = [
        e[0],
        t,
        r,
        e[3]
      ], this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.halfPixelCenters = i, this.shaderKey = `resizeNearest_${i}`;
    }
    getUserCode() {
      let e;
      return this.halfPixelCenters ? e = "max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))" : e = "vec2<f32>(rc) * effectiveInputOverOutputRatioRC", `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    }
  }
  function Sct(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i } = e, { alignCorners: a, halfPixelCenters: s, size: o } = r, [l, u] = o, c = a && l > 1 ? 1 : 0, h = a && u > 1 ? 1 : 0, f = [
      {
        type: "float32",
        data: [
          c,
          h
        ]
      },
      {
        type: "float32",
        data: [
          a ? 0.5 : 0
        ]
      }
    ], p = new _ct(i.shape, l, u, s);
    return t.runWebGPUProgram(p, [
      i
    ], i.dtype, f);
  }
  const Cct = {
    kernelName: Vf,
    backendName: "webgpu",
    kernelFunc: Sct
  };
  class Ict {
    constructor(e, t) {
      this.variableNames = [
        "dy"
      ], this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.alignCorners = t, this.shaderKey = `resizeNearestNeigborBackprop_${t}`;
    }
    getUserCode() {
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners ? "floor(sourceFracRow + 0.5)" : "floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners ? "floor(sourceFracCol + 0.5)" : "floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    }
  }
  function kct(n) {
    const { inputs: e, backend: t, attrs: r } = n, { images: i, dy: a } = e, { alignCorners: s } = r, [, o, l] = i.shape, [, u, c] = a.shape, h = [
      s && u > 1 ? o - 1 : o,
      s && c > 1 ? l - 1 : l
    ], d = [
      s && u > 1 ? u - 1 : u,
      s && c > 1 ? c - 1 : c
    ], f = h[0] / d[0], p = h[1] / d[1], g = 1 / f, m = 1 / p, v = Math.ceil(g) * 2 + 2, y = Math.ceil(m) * 2 + 2, x = new Ict(i.shape, s), b = [
      {
        type: "int32",
        data: h
      },
      {
        type: "int32",
        data: d
      },
      {
        type: "float32",
        data: [
          g
        ]
      },
      {
        type: "float32",
        data: [
          m
        ]
      },
      {
        type: "int32",
        data: [
          v
        ]
      },
      {
        type: "int32",
        data: [
          y
        ]
      }
    ];
    return t.runWebGPUProgram(x, [
      a
    ], a.dtype, b);
  }
  const Tct = {
    kernelName: cv,
    backendName: "webgpu",
    kernelFunc: kct
  };
  class Act {
    constructor(e) {
      this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = " axis : vec4<i32>,", this.shaderKey = "reverse";
    }
    getUserCode() {
      return `
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `;
    }
  }
  function Dct(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { dims: a } = r, s = i.shape.length;
    if (s === 0) return Aa({
      inputs: {
        x: i
      },
      backend: t
    });
    const o = i.shape, l = [
      1,
      1,
      1,
      1
    ];
    o.forEach((m, v) => {
      const y = v + 4 - s;
      l[y] = m;
    });
    const u = yt(a, i.shape), c = [
      0,
      0,
      0,
      0
    ];
    u.forEach((m) => {
      const v = m + 4 - s;
      c[v] = 1;
    });
    const h = [
      {
        type: "int32",
        data: c
      }
    ], d = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: l
      }
    }), f = new Act(l), p = t.runWebGPUProgram(f, [
      d
    ], d.dtype, h);
    t.disposeData(d.dataId);
    const g = Je({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        shape: o
      }
    });
    return t.disposeData(p.dataId), g;
  }
  const Rct = {
    kernelName: Uf,
    backendName: "webgpu",
    kernelFunc: Dct
  };
  class $ct {
    constructor(e, t) {
      this.outputShape = [], this.variableNames = [
        "x"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = `centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`, this.shaderKey = "rotate", this.outputShape = e, typeof t == "number" ? (this.uniforms += " fillValue : f32,", this.fillSnippet = "var outputValue = uniforms.fillValue;", this.shaderKey += "_float") : (this.uniforms += " fillValue : vec3<f32>,", this.fillSnippet = "var outputValue = uniforms.fillValue[coords[3]];", this.shaderKey += "_vec3");
    }
    getUserCode() {
      return `
        ${Ne("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `;
    }
  }
  const Nct = {
    kernelName: wv,
    backendName: "webgpu",
    kernelFunc: ({ inputs: n, attrs: e, backend: t }) => {
      const { image: r } = n, { radians: i, fillValue: a, center: s } = e, o = t, l = new $ct(r.shape, a), [u, c] = kb(s, r.shape[1], r.shape[2]), h = [
        {
          type: "float32",
          data: [
            u
          ]
        },
        {
          type: "float32",
          data: [
            c
          ]
        },
        {
          type: "float32",
          data: [
            Math.sin(i)
          ]
        },
        {
          type: "float32",
          data: [
            Math.cos(i)
          ]
        }
      ];
      return typeof a == "number" ? h.push({
        type: "float32",
        data: [
          Number.parseFloat(a.toFixed(2))
        ]
      }) : h.push({
        type: "float32",
        data: a
      }), o.runWebGPUProgram(l, [
        r
      ], r.dtype, h);
    }
  };
  const Ect = hn({
    opType: De.ROUND
  }), Mct = {
    kernelName: Hf,
    backendName: "webgpu",
    kernelFunc: Ect
  };
  const Pct = hn({
    opType: De.RSQRT,
    cpuKernelImpl: Kit
  }), Lct = {
    kernelName: Xf,
    backendName: "webgpu",
    kernelFunc: Pct
  };
  class v0 {
    constructor(e, t, r, i, a, s, o, l = true) {
      this.variableNames = [
        "updates",
        "indices"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = s, this.type = o, this.sumDupeIndices = l, this.dispatchLayout = We(e), this.dispatch = Ee(this.dispatchLayout, e, this.workgroupSize), this.sliceDimGreaterThanOne = t > 1, this.shaderKey = `scatter_${r}_${i}_${this.sliceDimGreaterThanOne}_${o}_${l}_${a.length}`;
      const u = lr(a.length);
      this.uniforms = `sliceDim : i32, strides: ${u}, updatesSize: i32,`, this.updatesRank = i, this.indicesRank = r;
    }
    getUserCode() {
      let e = "";
      this.indicesRank === 1 ? e = "coords[0]" : this.indicesRank === 2 && (e = "coords[0], j");
      const t = `getIndices(${e})`, r = this.sliceDimGreaterThanOne ? "uniforms.strides[j]" : "uniforms.strides";
      let i = "", a = "";
      this.dispatchLayout.x.length === 1 ? (i = "flattenedIndex", a = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `) : this.dispatchLayout.x.length === 2 && (i = "vec2<i32>(flattenedIndex, coords[1])", a = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);
      const o = `getUpdates(${Array.from({
        length: this.updatesRank
      }, (u, c) => `coords[${c}]`).join(", ")})`;
      return `
    ${a}
      ${Ne("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${Mh(this.type)}(${o});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices ? Nc("&result[flatIndex]", "updateValue", this.type) : "atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`;
    }
  }
  function Fct(n) {
    const { inputs: e, backend: t, attrs: r } = n, { indices: i, updates: a } = e, { shape: s } = r, { sliceRank: o, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Ka(a, i, s), d = [
      h / u,
      u
    ];
    if (h === 0) return t.makeTensorInfo(s, i.dtype);
    const f = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          l,
          o
        ]
      }
    }), p = Je({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          l,
          u
        ]
      }
    }), g = p.dtype, m = ea({
      backend: t,
      attrs: {
        shape: d,
        value: 0,
        dtype: g
      }
    }), v = X(p.shape), y = [
      {
        type: "int32",
        data: [
          o
        ]
      },
      {
        type: "int32",
        data: c
      },
      {
        type: "int32",
        data: [
          v
        ]
      }
    ], x = new v0(p.shape, o, f.shape.length, p.shape.length, c, d, g), b = t.runWebGPUProgram(x, [
      p,
      f
    ], g, y, m), w = Je({
      inputs: {
        x: b
      },
      backend: t,
      attrs: {
        shape: s
      }
    });
    return t.disposeData(f.dataId), t.disposeData(p.dataId), t.disposeData(b.dataId), w;
  }
  const Oct = {
    kernelName: hb,
    backendName: "webgpu",
    kernelFunc: Fct
  };
  class Bct {
    constructor(e, t) {
      this.outputShape = [], this.variableNames = [
        "sortedSequence",
        "values"
      ], this.uniforms = "numInputs : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.side = t, this.shaderKey = `search_sorted_${t}`;
    }
    getUserCode() {
      return `
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side === "left" ? "<" : "<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Ne("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `;
    }
  }
  function zct(n) {
    const { inputs: e, backend: t, attrs: r } = n, { sortedSequence: i, values: a } = e, { side: s } = r, o = new Bct([
      a.shape[0],
      a.shape[1]
    ], s), l = [
      {
        type: "int32",
        data: [
          i.shape[1]
        ]
      }
    ];
    return t.runWebGPUProgram(o, [
      i,
      a
    ], "int32", l);
  }
  const Vct = {
    kernelName: fb,
    backendName: "webgpu",
    kernelFunc: zct
  };
  class Wct {
    constructor(e, t, r) {
      this.variableNames = [
        "c",
        "a",
        "b"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = t, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.cRank = e, this.rank = r, this.shaderKey = "select";
    }
    getUserCode() {
      let e, t;
      if (this.rank > 4) throw Error(`Where for rank ${this.rank} is not yet supported`);
      if (this.rank === 1) t = "resRC", e = "resRC";
      else {
        const i = [
          "resRC.x",
          "resRC.y",
          "resRC.z",
          "resRC.w"
        ], a = [], s = [];
        for (let o = 0; o < this.outputShape.length; o++) s.push(`${i[o]}`), o < this.cRank && a.push(`${i[o]}`);
        e = a.join(), t = s.join();
      }
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `;
    }
  }
  function Gct(n) {
    const { inputs: e, backend: t } = n, { condition: r, t: i, e: a } = e, s = new Wct(r.shape.length, i.shape, i.shape.length);
    return t.runWebGPUProgram(s, [
      r,
      i,
      a
    ], qr(i.dtype, a.dtype));
  }
  const Uct = {
    kernelName: dv,
    backendName: "webgpu",
    kernelFunc: Gct
  };
  const Hct = hn({
    opType: De.SELU
  }), Xct = {
    kernelName: Yf,
    backendName: "webgpu",
    kernelFunc: Hct
  };
  const Yct = hn({
    opType: De.SIGMOID
  }), qct = {
    kernelName: Zf,
    backendName: "webgpu",
    kernelFunc: Yct
  };
  const jct = hn({
    opType: De.SIGN
  }), Kct = {
    kernelName: Kf,
    backendName: "webgpu",
    kernelFunc: jct
  };
  const Zct = hn({
    opType: De.SIN
  }), Qct = {
    kernelName: qf,
    backendName: "webgpu",
    kernelFunc: Zct
  };
  const Jct = hn({
    opType: De.SINH
  }), eht = {
    kernelName: jf,
    backendName: "webgpu",
    kernelFunc: Jct
  };
  const tht = hn({
    opType: De.SOFTPLUS
  }), nht = {
    kernelName: Qf,
    backendName: "webgpu",
    kernelFunc: tht
  };
  class rht {
    constructor(e, t, r, i, a, s) {
      this.variableNames = [
        "x"
      ], this.outputShape = [], this.uniforms = "", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true;
      const o = new Array(i.length);
      for (let l = 0; l < o.length; l++) o[l] = i[a[l]];
      this.outputShape = o, this.newDim = a, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.xShape = e, this.paddedXShape = t, this.uniforms += `reshapedPaddedXShape : ${lr(i.length)}, paddedXShapeStrides : ${lr(s)}, `, r.map((l, u) => {
        this.uniforms += ` pad${u} : vec2<i32>,`;
      }), this.shaderKey = `spaceToBatchND_${a}`;
    }
    getUserCode() {
      const e = lr(this.outputShape.length), t = _re(this.newDim);
      return `
      ${I_(this.paddedXShape, "PaddedX")}
      ${Ne("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${Vre(this.xShape, true)}
        }
      }
    `;
    }
  }
  const iht = (n) => {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { blockShape: a, paddings: s } = r;
    B(i.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");
    const o = a.reduce((y, x) => y * x), l = [
      [
        0,
        0
      ]
    ];
    l.push(...s);
    for (let y = 1 + a.length; y < i.shape.length; ++y) l.push([
      0,
      0
    ]);
    const u = l.map((y, x) => y[0] + i.shape[x] + y[1]), c = ou(u, a, o, false), h = lu(c.length, a.length, false), d = uu(u, a, o, false), f = Be(u), p = new rht(i.shape, u, l, c, h, f.length), g = [
      {
        type: "int32",
        data: c
      },
      {
        type: "int32",
        data: f
      }
    ];
    l.map((y) => g.push({
      type: "int32",
      data: [
        y[0],
        y[1]
      ]
    }));
    const m = t.runWebGPUProgram(p, [
      i
    ], i.dtype, g), v = Je({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    return t.disposeData(m.dataId), v;
  }, aht = {
    kernelName: pv,
    backendName: "webgpu",
    kernelFunc: iht
  };
  class sht {
    constructor(e, t, r) {
      this.variableNames = [
        "input",
        "indices",
        "segmentIds"
      ], this.outputShape = [], this.uniforms = "segmentSize : i32, sparseSize : i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = e, this.type = r, this.dispatchLayout = We([
        t
      ]), this.dispatch = Ee(this.dispatchLayout, [
        t
      ], this.workgroupSize), this.shaderKey = "sparseSegmentSum";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Nc("&result[outIndex]", "value", this.type)}
      }
    }
  `;
    }
  }
  class oht {
    constructor(e, t) {
      this.variableNames = [
        "segmentIds"
      ], this.outputShape = [], this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = [
        e
      ], this.dispatchLayout = We(t), this.dispatch = Ee(this.dispatchLayout, t, this.workgroupSize), this.shaderKey = "sparseSegmentIdCountProgram";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Nc("&result[segmentId]", "1", "int32")}
      }
    }
  `;
    }
  }
  class lht {
    constructor(e, t) {
      this.variableNames = [
        "segmentSum",
        "sameSegmentIdCount"
      ], this.outputShape = [], this.uniforms = "segmentSize : i32", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.type = t, this.dispatchLayout = We(e), this.dispatch = Ee(this.dispatchLayout, e, this.workgroupSize), this.shaderKey = "sparseSegmentMean";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type === "float32" ? "setOutputAtIndex(index, segmentSum[index] / f32(count));" : "setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `;
    }
  }
  function Wre(n, e, t, r = false, i) {
    const s = X(n.shape) / n.shape[0], o = n.dtype, l = X(e.shape), u = i.readSync(t.dataId), h = l > 0 ? u[l - 1] + 1 : 0;
    let d;
    const f = n.shape.slice();
    f[0] = h;
    const p = l * s, g = ea({
      backend: i,
      attrs: {
        shape: f,
        value: 0,
        dtype: o
      }
    });
    d = new sht(f, p, o);
    let m = [
      {
        type: "int32",
        data: [
          s
        ]
      },
      {
        type: "int32",
        data: [
          p
        ]
      }
    ];
    const v = i.runWebGPUProgram(d, [
      n,
      e,
      t
    ], o, m, g);
    if (r) return v;
    const y = ea({
      backend: i,
      attrs: {
        shape: [
          h
        ],
        value: 0,
        dtype: "int32"
      }
    });
    d = new oht(h, t.shape);
    const x = i.runWebGPUProgram(d, [
      t
    ], "int32", null, y), b = ea({
      backend: i,
      attrs: {
        shape: f,
        value: 0,
        dtype: o
      }
    });
    d = new lht(f, o), m = [
      {
        type: "int32",
        data: [
          s
        ]
      }
    ];
    const w = i.runWebGPUProgram(d, [
      v,
      x
    ], o, m, b);
    return i.disposeData(v.dataId), i.disposeData(x.dataId), w;
  }
  function uht(n) {
    const { inputs: e, backend: t } = n, { data: r, indices: i, segmentIds: a } = e;
    return Wre(r, i, a, false, t);
  }
  const cht = {
    kernelName: fI,
    backendName: "webgpu",
    kernelFunc: uht
  };
  function hht(n) {
    const { inputs: e, backend: t } = n, { data: r, indices: i, segmentIds: a } = e;
    return Wre(r, i, a, true, t);
  }
  const dht = {
    kernelName: pI,
    backendName: "webgpu",
    kernelFunc: hht
  };
  class fht {
    constructor(e, t) {
      this.variableNames = [
        "A"
      ], this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true;
      const r = new Array(e.length);
      for (let i = 0; i < r.length; i++) r[i] = e[i] * t[i];
      this.outputShape = r, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.rank = this.outputShape.length, this.shaderKey = "tile";
    }
    getUserCode() {
      const e = pht(this.rank, "uniforms.");
      return `
      ${Ne("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `;
    }
  }
  function pht(n, e = "") {
    if (n >= 5) throw Error(`Tile for rank ${n} is not yet supported`);
    if (n === 1) return `(resRC % ${e}aShape)`;
    const t = [
      "resRC.x",
      "resRC.y",
      "resRC.z",
      "resRC.w"
    ], r = [];
    for (let i = 0; i < n; i++) r.push(`(${t[i]} % ${e}aShape[${i}])`);
    return r.join();
  }
  function BL(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { reps: a } = r;
    if (t.shouldExecuteOnCPU([
      i
    ]) || i.dtype === "string" || i.shape.length >= 5) {
      const l = t.readSync(i.dataId), u = i.dtype === "string" ? l.map((d) => io(d)) : l, c = Nt(i.shape, i.dtype, u), h = rat(c, a);
      return t.makeTensorInfo(h.shape, h.dtype, h.values);
    }
    const s = new fht(i.shape, a);
    return t.runWebGPUProgram(s, [
      i
    ], i.dtype);
  }
  const ght = {
    kernelName: wc,
    backendName: "webgpu",
    kernelFunc: BL
  };
  function mht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { sparseIndices: i, sparseValues: a, defaultValue: s } = e, { outputShape: o } = r, { sliceRank: l, numUpdates: u, sliceSize: c, strides: h, outputSize: d } = Ka(a, i, o), f = false;
    if (a.dtype === "string") {
      const I = t.bufferSync(i), C = t.bufferSync(a), T = io(t.readSync(s.dataId)[0]), k = Zit(I, C, o, d, c, u, l, h, T, f);
      return t.makeTensorInfo(o, k.dtype, k.values);
    }
    const p = [
      d / c,
      c
    ], g = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: [
          u,
          l
        ]
      }
    }), m = a.shape.length ? Je({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          u,
          c
        ]
      }
    }) : Aa({
      inputs: {
        x: a
      },
      backend: t
    }), v = m.dtype, y = t.makeTensorInfo([], v, si(1, v)), x = Je({
      inputs: {
        x: s
      },
      backend: t,
      attrs: {
        shape: Array(p.length).fill(1)
      }
    }), b = BL({
      inputs: {
        x
      },
      backend: t,
      attrs: {
        reps: p
      }
    }), w = X([
      u,
      c
    ]), _ = [
      {
        type: "int32",
        data: [
          l
        ]
      },
      {
        type: "int32",
        data: h
      },
      {
        type: "int32",
        data: [
          w
        ]
      }
    ];
    switch (u) {
      case 0:
        break;
      case 1:
        {
          const I = new v0([
            u,
            c
          ], l, g.shape.length, m.shape.length, h, p, v, f);
          t.runWebGPUProgram(I, [
            m,
            g
          ], v, _, b);
        }
        break;
      default:
        {
          const I = new v0([
            u,
            c
          ], l, g.shape.length, y.shape.length, h, p, v, f);
          t.runWebGPUProgram(I, [
            y,
            g
          ], v, _, b);
        }
        {
          const I = new v0([
            u,
            c
          ], l, g.shape.length, m.shape.length, h, p, v);
          t.runWebGPUProgram(I, [
            m,
            g
          ], v, _, b);
        }
    }
    const S = Je({
      inputs: {
        x: b
      },
      backend: t,
      attrs: {
        shape: o
      }
    });
    return t.disposeData(g.dataId), t.disposeData(m.dataId), t.disposeData(x.dataId), t.disposeData(y.dataId), t.disposeData(b.dataId), S;
  }
  const vht = {
    kernelName: pb,
    backendName: "webgpu",
    kernelFunc: mht
  };
  function yht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { numOrSizeSplits: a, axis: s } = r, o = yt(s, i.shape)[0], l = $b(i, a, o), u = i.shape.length, c = new Array(u).fill(0), h = i.shape.slice();
    return l.map((d) => {
      const f = [
        ...h
      ];
      f[o] = d;
      const p = Bv({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: c,
          size: f
        }
      });
      return c[o] += d, p;
    });
  }
  const xht = {
    kernelName: gv,
    backendName: "webgpu",
    kernelFunc: yht
  };
  const bht = hn({
    opType: De.SQRT
  }), wht = {
    kernelName: Jf,
    backendName: "webgpu",
    kernelFunc: bht
  };
  const _ht = {
    kernelName: gb,
    backendName: "webgpu",
    kernelFunc: ({ inputs: n, backend: e }) => {
      const { x: t } = n, r = e, i = new Ov(t.shape, De.SQUARE);
      return r.runWebGPUProgram(i, [
        t
      ], t.dtype);
    }
  };
  const Sht = jr({
    opType: _t.SQUARED_DIFFERENCE
  }), Cht = {
    kernelName: np,
    backendName: "webgpu",
    kernelFunc: Sht
  };
  function Iht({ inputs: n, attrs: e, backend: t }) {
    const { x: r } = n, i = new Ov(r.shape, De.STEP, "stepAlpha : f32,"), a = [
      {
        type: "float32",
        data: [
          e.alpha
        ]
      }
    ];
    return t.runWebGPUProgram(i, [
      r
    ], r.dtype, a);
  }
  const kht = {
    kernelName: _c,
    backendName: "webgpu",
    kernelFunc: Iht
  };
  class Tht {
    constructor(e) {
      this.variableNames = [
        "x"
      ], this.workPerThread = 1, this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize, [
        this.workPerThread,
        1,
        1
      ]);
      const t = lr(this.outputShape.length);
      this.uniforms = `begin : ${t},  strides : ${t}, `, this.shaderKey = "stridedSlice";
    }
    getUserCode() {
      const e = this.outputShape.length;
      let t = "";
      if (e === 1) t = "coords * uniforms.strides + uniforms.begin";
      else {
        let i = 0;
        t = this.outputShape.map((a, s) => (i++, this.outputShape.length === 1 ? `coords * uniforms.strides[${s}] + uniforms.begin[${s}]` : `coords[${i - 1}] * uniforms.strides[${s}] + uniforms.begin[${s}]`)).join(",");
      }
      return `
       ${Ne("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `;
    }
  }
  function Aht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { begin: a, end: s, strides: o, beginMask: l, endMask: u, ellipsisMask: c, newAxisMask: h, shrinkAxisMask: d } = r, { finalShapeSparse: f, finalShape: p, isIdentity: g, sliceDim0: m, isSimpleSlice: v, begin: y, end: x, strides: b } = Cb(i.shape, a, s, o, l, u, c, h, d);
    let w;
    if (g) w = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: p
      }
    });
    else if (m || v) {
      B(i.shape.length >= 1, () => `Input must have rank at least 1, got: ${i.shape.length}`);
      const _ = Sb(y, x, b), S = Bv({
        inputs: {
          x: i
        },
        backend: t,
        attrs: {
          begin: y,
          size: _
        }
      });
      w = Je({
        inputs: {
          x: S
        },
        backend: t,
        attrs: {
          shape: p
        }
      }), t.disposeData(S.dataId);
    } else if (t.shouldExecuteOnCPU([
      i
    ])) {
      const S = t.readSync(i.dataId), I = Nt(i.shape, i.dtype, S), C = eat(f, I, b, y);
      w = t.makeTensorInfo(p, i.dtype, C.values);
    } else {
      const S = new Tht(f), I = [
        {
          type: "int32",
          data: y
        },
        {
          type: "int32",
          data: b
        }
      ], C = t.runWebGPUProgram(S, [
        i
      ], i.dtype, I);
      w = Je({
        inputs: {
          x: C
        },
        backend: t,
        attrs: {
          shape: p
        }
      }), t.disposeData(C.dataId);
    }
    return w;
  }
  const Dht = {
    kernelName: mv,
    backendName: "webgpu",
    kernelFunc: Aht
  };
  function Rht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { separator: i, nGramWidths: a, leftPad: s, rightPad: o, padWidth: l, preserveShortSequences: u } = r, { data: c, dataSplits: h } = e, d = t.readSync(c.dataId), f = t.readSync(h.dataId), [p, g] = tat(d, f, i, a, s, o, l, u);
    return [
      t.makeTensorInfo([
        p.length
      ], "string", p),
      t.makeTensorInfo(h.shape, "int32", g)
    ];
  }
  const $ht = {
    kernelName: gI,
    backendName: "webgpu",
    kernelFunc: Rht
  };
  const Nht = jr({
    opType: _t.SUB,
    cpuKernelImpl: nat,
    supportsComplex: true
  }), Eht = {
    kernelName: rp,
    backendName: "webgpu",
    kernelFunc: Nht
  };
  const Mht = hn({
    opType: De.TAN
  }), Pht = {
    kernelName: ip,
    backendName: "webgpu",
    kernelFunc: Mht
  };
  const Lht = hn({
    opType: De.TANH
  }), Fht = {
    kernelName: ap,
    backendName: "webgpu",
    kernelFunc: Lht
  };
  function Oht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { tensor: i, indices: a, updates: s } = e, { sliceRank: o, numUpdates: l, sliceSize: u, strides: c, outputSize: h } = Ka(s, a, i.shape), d = [
      h / u,
      u
    ];
    if (h === 0) return t.makeTensorInfo(i.shape, a.dtype);
    const f = [], p = Je({
      inputs: {
        x: a
      },
      backend: t,
      attrs: {
        shape: [
          l,
          o
        ]
      }
    });
    f.push(p);
    const g = Je({
      inputs: {
        x: s
      },
      backend: t,
      attrs: {
        shape: [
          l,
          u
        ]
      }
    });
    f.push(g);
    const m = Je({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    f.push(m);
    const v = BL({
      inputs: {
        x: m
      },
      backend: t,
      attrs: {
        reps: Array(d.length).fill(1)
      }
    }), y = new v0([
      l,
      u
    ], o, p.shape.length, g.shape.length, c, d, i.dtype, false), x = X([
      l,
      u
    ]), b = [
      {
        type: "int32",
        data: [
          o
        ]
      },
      {
        type: "int32",
        data: c
      },
      {
        type: "int32",
        data: [
          x
        ]
      }
    ], w = t.runWebGPUProgram(y, [
      g,
      p
    ], m.dtype, b, v);
    f.push(w);
    const _ = Je({
      inputs: {
        x: w
      },
      backend: t,
      attrs: {
        shape: i.shape
      }
    });
    return f.forEach((S) => t.disposeData(S.dataId)), _;
  }
  const Bht = {
    kernelName: db,
    backendName: "webgpu",
    kernelFunc: Oht
  };
  class zht {
    constructor(e) {
      this.variableNames = [
        "x",
        "indices"
      ], this.workgroupSize = [
        256,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = `inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`, this.shaderKey = "swap";
    }
    getUserCode() {
      return `
        ${Ne("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    }
  }
  class Vht {
    constructor(e) {
      this.variableNames = [
        "x",
        "indices"
      ], this.workgroupSize = [
        256,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = "inputSize : i32, firstPass : i32, k : i32,", this.shaderKey = "merge";
    }
    getUserCode() {
      return `
        ${Ne("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    }
  }
  function Zp(n, e) {
    e !== null && n.disposeData(e.dataId);
  }
  function cH(n) {
    let e = 1;
    for (; e < n; ) e *= 2;
    return e;
  }
  function Wht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i } = e, { k: a, sorted: s } = r, o = i.shape, l = o[o.length - 1];
    if (t.shouldExecuteOnCPU([
      i
    ])) {
      const w = t.readSync(i.dataId), [_, S] = iat(w, o, i.dtype, a, s);
      return [
        t.makeTensorInfo(_.shape, _.dtype, _.values),
        t.makeTensorInfo(S.shape, S.dtype, S.values)
      ];
    }
    if (a === 0) return o[o.length - 1] = 0, [
      t.makeTensorInfo(o, i.dtype, []),
      t.makeTensorInfo(o, "int32", [])
    ];
    if (l === 1) return [
      i,
      ea({
        attrs: {
          shape: o,
          dtype: "int32",
          value: 0
        },
        backend: t
      })
    ];
    const c = X(o) / l, h = Je({
      inputs: {
        x: i
      },
      attrs: {
        shape: [
          c,
          l
        ]
      },
      backend: t
    }), d = cH(a), f = cH(l);
    let p = null;
    const g = () => p === null ? [
      h,
      h
    ] : [
      h,
      p
    ], m = (w, _, S) => {
      const I = g(), C = new zht(S), k = [
        {
          type: "int32",
          data: [
            l
          ]
        },
        {
          type: "int32",
          data: [
            p === null ? 1 : 0
          ]
        },
        {
          type: "float32",
          data: [
            Number.NEGATIVE_INFINITY
          ]
        },
        {
          type: "int32",
          data: [
            w
          ]
        },
        {
          type: "int32",
          data: [
            _
          ]
        }
      ], D = p;
      p = t.runWebGPUProgram(C, I, "int32", k), Zp(t, D);
    };
    for (let w = 1; w < d; w *= 2) {
      const _ = w * 2;
      for (let S = w; S >= 1; S /= 2) m(_, S, [
        c,
        f
      ]);
    }
    for (let w = f; w > d; w /= 2) {
      const _ = g(), S = new Vht([
        c,
        w / 2
      ]), C = [
        {
          type: "int32",
          data: [
            l
          ]
        },
        {
          type: "int32",
          data: [
            p === null ? 1 : 0
          ]
        },
        {
          type: "int32",
          data: [
            d
          ]
        }
      ], T = p;
      p = t.runWebGPUProgram(S, _, "int32", C), Zp(t, T);
      const k = d / 2, D = k * 2;
      for (let R = k; R >= 1; R /= 2) m(D, R, p.shape);
    }
    let v = p;
    p = Bv({
      inputs: {
        x: p
      },
      backend: t,
      attrs: {
        begin: 0,
        size: [
          c,
          a
        ]
      }
    }), Zp(t, v);
    let y = Fre({
      inputs: {
        x: h,
        indices: p
      },
      backend: t,
      attrs: {
        axis: 1,
        batchDims: 1
      }
    });
    Zp(t, h);
    const x = o.slice(0, -1);
    x.push(a), v = p, p = Je({
      inputs: {
        x: p
      },
      attrs: {
        shape: x
      },
      backend: t
    }), Zp(t, v);
    const b = y;
    return y = Je({
      inputs: {
        x: y
      },
      attrs: {
        shape: x
      },
      backend: t
    }), Zp(t, b), [
      y,
      p
    ];
  }
  const Ght = {
    kernelName: vv,
    backendName: "webgpu",
    kernelFunc: Wht
  };
  class Uht {
    constructor(e) {
      this.variableNames = [
        "Image",
        "Transforms"
      ], this.uniforms = "interpolationModeId : i32, fillModeId : i32, fillValue : f32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.size = true, this.outputShape = e, this.dispatchLayout = We(this.outputShape), this.dispatch = Ee(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "transform";
    }
    getUserCode() {
      return `
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ne("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `;
    }
  }
  function Hht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { image: i, transforms: a } = e, { interpolation: s, fillMode: o, fillValue: l, outputShape: u } = r, [c, h, d, f] = i.shape, [p, g] = u ?? [
      h,
      d
    ], m = [
      c,
      p,
      g,
      f
    ], v = new Uht(m), y = s === "nearest" ? 1 : 2;
    let x;
    switch (o) {
      case "constant":
        x = 1;
        break;
      case "reflect":
        x = 2;
        break;
      case "wrap":
        x = 3;
        break;
      case "nearest":
        x = 4;
        break;
      default:
        x = 1;
        break;
    }
    const b = [
      {
        type: "int32",
        data: [
          y
        ]
      },
      {
        type: "int32",
        data: [
          x
        ]
      },
      {
        type: "float32",
        data: [
          l
        ]
      }
    ];
    return t.runWebGPUProgram(v, [
      i,
      a
    ], "float32", b);
  }
  const Xht = {
    kernelName: yv,
    backendName: "webgpu",
    kernelFunc: Hht
  };
  function Yht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { value: i } = e;
    let { axis: a } = r;
    a < 0 && (a += i.shape.length);
    const s = i, o = s.shape.length, l = i.shape[a], u = new Array(o - 1);
    let c = 0;
    for (let g = 0; g < o; g++) g !== a && (u[c++] = s.shape[g]);
    const h = [], d = new Array(o).fill(0), f = s.shape.slice();
    f[a] = 1;
    const p = new Array(l);
    for (let g = 0; g < p.length; g++) {
      d[a] = g;
      const m = Bv({
        inputs: {
          x: s
        },
        backend: t,
        attrs: {
          begin: d,
          size: f
        }
      }), v = Je({
        inputs: {
          x: m
        },
        backend: t,
        attrs: {
          shape: u
        }
      });
      p[g] = v, h.push(m);
    }
    return h.forEach((g) => t.disposeData(g.dataId)), p;
  }
  const qht = {
    kernelName: xv,
    backendName: "webgpu",
    kernelFunc: Yht
  };
  class jht {
    constructor(e, t, r) {
      if (this.outputShape = [], this.variableNames = [
        "x",
        "segmentIds"
      ], this.uniforms = "numSegments : i32, xSize: i32,", this.workgroupSize = [
        64,
        1,
        1
      ], this.atomic = true, this.outputShape = t, this.dispatchLayout = We(e), this.dispatch = Ee(this.dispatchLayout, e, this.workgroupSize), r !== "float32" && r !== "int32") throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);
      this.type = r, this.shaderKey = "unsortedSegmentSum";
    }
    getUserCode() {
      return `
    ${Ne("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Nc("&result[flatIndex]", "value", this.type)}
        }
      }
    }
  `;
    }
  }
  function Kht(n) {
    const { inputs: e, backend: t, attrs: r } = n, { x: i, segmentIds: a } = e, { numSegments: s } = r, o = i.shape.length, l = [];
    let u = 0;
    const c = bn([
      u
    ], o);
    let h = i;
    c != null && (h = ll({
      inputs: {
        x: i
      },
      backend: t,
      attrs: {
        perm: c
      }
    }), l.push(h), u = gn(1, o)[0]);
    const d = VP(h.shape, u, s), f = X([
      h.shape[u]
    ]), p = Je({
      inputs: {
        x: h
      },
      backend: t,
      attrs: {
        shape: [
          -1,
          f
        ]
      }
    });
    l.push(p);
    const g = i.dtype, m = [
      p.shape[0],
      s
    ], v = ea({
      backend: t,
      attrs: {
        shape: m,
        value: 0,
        dtype: g
      }
    }), y = new jht(p.shape, m, g), x = [
      {
        type: "int32",
        data: [
          s
        ]
      },
      {
        type: "int32",
        data: [
          X(p.shape)
        ]
      }
    ], b = t.runWebGPUProgram(y, [
      p,
      a
    ], g, x, v), w = Je({
      inputs: {
        x: b
      },
      backend: t,
      attrs: {
        shape: d
      }
    });
    l.push(b);
    let _ = w;
    if (c != null) {
      l.push(w);
      const S = As(c);
      _ = ll({
        inputs: {
          x: _
        },
        backend: t,
        attrs: {
          perm: S
        }
      });
    }
    return l.forEach((S) => t.disposeData(S.dataId)), _;
  }
  const Zht = {
    kernelName: mb,
    backendName: "webgpu",
    kernelFunc: Kht
  };
  const Qht = [
    Sit,
    oat,
    uat,
    hat,
    fat,
    mat,
    Sat,
    Iat,
    Tat,
    Dat,
    $at,
    Eat,
    Pat,
    Fat,
    Bat,
    Uat,
    Xat,
    Kat,
    Qat,
    est,
    ast,
    ust,
    dst,
    mst,
    yst,
    _st,
    Iit,
    Ist,
    Dst,
    Fst,
    Gst,
    Yst,
    Kst,
    Qst,
    eot,
    not,
    iot,
    oot,
    uot,
    hot,
    fot,
    mot,
    Sot,
    Iot,
    xot,
    Aot,
    $ot,
    Pot,
    Fot,
    zot,
    Uot,
    Xot,
    qot,
    Kot,
    Qot,
    elt,
    tlt,
    rlt,
    alt,
    bit,
    olt,
    flt,
    ult,
    hlt,
    mlt,
    ylt,
    blt,
    Slt,
    klt,
    Alt,
    Rlt,
    Cit,
    Nlt,
    Tst,
    Mlt,
    Llt,
    Olt,
    zlt,
    Wlt,
    Ult,
    Ylt,
    Zlt,
    jlt,
    Jlt,
    tut,
    rut,
    out,
    cut,
    Vat,
    dut,
    put,
    _ut,
    mut,
    but,
    Cut,
    Wat,
    kut,
    Aut,
    Rut,
    Nut,
    Fut,
    Vot,
    But,
    Vut,
    Gut,
    fst,
    Xut,
    qut,
    Kut,
    Jut,
    tct,
    rct,
    act,
    oct,
    pst,
    uct,
    hct,
    fct,
    gct,
    wit,
    yct,
    wct,
    Cct,
    Tct,
    Rct,
    Nct,
    Mct,
    Lct,
    Oct,
    Vct,
    Uct,
    Xct,
    qct,
    Kct,
    Qct,
    eht,
    rst,
    kht,
    Dht,
    $ht,
    Put,
    nht,
    aht,
    cht,
    dht,
    vht,
    xht,
    wht,
    _ht,
    Cht,
    Eht,
    Wot,
    Pht,
    Fht,
    Bht,
    ght,
    Ght,
    Xht,
    xat,
    qht,
    Zht,
    Yut
  ];
  for (const n of Qht) vI(n);
  function Jht(n) {
    return new Worker("/tfjs_model_tester/assets/detect.worker-CxeD56_M.js", {
      name: n == null ? void 0 : n.name
    });
  }
  var jy = ((n) => (n.detect = "detect", n.stop = "stop", n.loadModel = "loadModel", n.disposeModel = "disposeModel", n.testRun = "testRun", n))(jy || {});
  class Gre {
    constructor(e) {
      __publicField(this, "_canvas");
      __publicField(this, "onSelect");
      this._canvas = e;
    }
  }
  class hH {
    constructor() {
      __publicField(this, "palette");
      __publicField(this, "n");
      __publicField(this, "get", (e) => this.palette[Math.floor(e) % this.n]);
      this.palette = [
        "#FF3838",
        "#FF9D97",
        "#FF701F",
        "#FFB21D",
        "#CFD231",
        "#48F90A",
        "#92CC17",
        "#3DDB86",
        "#1A9334",
        "#00D4BB",
        "#2C99A8",
        "#00C2FF",
        "#344593",
        "#6473FF",
        "#0018EC",
        "#8438FF",
        "#520085",
        "#CB38FF",
        "#FF95C8",
        "#FF37C7"
      ], this.n = this.palette.length;
    }
  }
  __publicField(hH, "hexToRgba", (e, t) => {
    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return r ? `rgba(${[
      parseInt(r[1], 16),
      parseInt(r[2], 16),
      parseInt(r[3], 16)
    ].join(", ")}, ${t})` : null;
  });
  class edt extends Gre {
    init() {
      throw new Error("Method not implemented.");
    }
    render(e, t, r, i, a) {
      throw new Error("Method not implemented.");
    }
    clear() {
      throw new Error("Method not implemented.");
    }
    dispose() {
      throw new Error("Method not implemented.");
    }
    capture(e) {
      throw new Error("Method not implemented.");
    }
  }
  Nn = ((n) => (n.Application = "application", n.WebGLPipes = "webgl-pipes", n.WebGLPipesAdaptor = "webgl-pipes-adaptor", n.WebGLSystem = "webgl-system", n.WebGPUPipes = "webgpu-pipes", n.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", n.WebGPUSystem = "webgpu-system", n.CanvasSystem = "canvas-system", n.CanvasPipesAdaptor = "canvas-pipes-adaptor", n.CanvasPipes = "canvas-pipes", n.Asset = "asset", n.LoadParser = "load-parser", n.ResolveParser = "resolve-parser", n.CacheParser = "cache-parser", n.DetectionParser = "detection-parser", n.MaskEffect = "mask-effect", n.BlendMode = "blend-mode", n.TextureSource = "texture-source", n.Environment = "environment", n.ShapeBuilder = "shape-builder", n.Batcher = "batcher", n))(Nn || {});
  let Y$, Tw, tdt, ndt;
  Y$ = (n) => {
    if (typeof n == "function" || typeof n == "object" && n.extension) {
      if (!n.extension) throw new Error("Extension class must have an extension object");
      n = {
        ...typeof n.extension != "object" ? {
          type: n.extension
        } : n.extension,
        ref: n
      };
    }
    if (typeof n == "object") n = {
      ...n
    };
    else throw new Error("Invalid extension type");
    return typeof n.type == "string" && (n.type = [
      n.type
    ]), n;
  };
  Tw = (n, e) => Y$(n).priority ?? e;
  $s = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...n) {
      return n.map(Y$).forEach((e) => {
        e.type.forEach((t) => {
          var _a2, _b2;
          return (_b2 = (_a2 = this._removeHandlers)[t]) == null ? void 0 : _b2.call(_a2, e);
        });
      }), this;
    },
    add(...n) {
      return n.map(Y$).forEach((e) => {
        e.type.forEach((t) => {
          var _a2, _b2;
          const r = this._addHandlers, i = this._queue;
          r[t] ? (_a2 = r[t]) == null ? void 0 : _a2.call(r, e) : (i[t] = i[t] || [], (_b2 = i[t]) == null ? void 0 : _b2.push(e));
        });
      }), this;
    },
    handle(n, e, t) {
      var _a2;
      const r = this._addHandlers, i = this._removeHandlers;
      if (r[n] || i[n]) throw new Error(`Extension type ${n} already has a handler`);
      r[n] = e, i[n] = t;
      const a = this._queue;
      return a[n] && ((_a2 = a[n]) == null ? void 0 : _a2.forEach((s) => e(s)), delete a[n]), this;
    },
    handleByMap(n, e) {
      return this.handle(n, (t) => {
        t.name && (e[t.name] = t.ref);
      }, (t) => {
        t.name && delete e[t.name];
      });
    },
    handleByNamedList(n, e, t = -1) {
      return this.handle(n, (r) => {
        e.findIndex((a) => a.name === r.name) >= 0 || (e.push({
          name: r.name,
          value: r.ref
        }), e.sort((a, s) => Tw(s.value, t) - Tw(a.value, t)));
      }, (r) => {
        const i = e.findIndex((a) => a.name === r.name);
        i !== -1 && e.splice(i, 1);
      });
    },
    handleByList(n, e, t = -1) {
      return this.handle(n, (r) => {
        e.includes(r.ref) || (e.push(r.ref), e.sort((i, a) => Tw(a, t) - Tw(i, t)));
      }, (r) => {
        const i = e.indexOf(r.ref);
        i !== -1 && e.splice(i, 1);
      });
    },
    mixin(n, ...e) {
      for (const t of e) Object.defineProperties(n.prototype, Object.getOwnPropertyDescriptors(t));
    }
  };
  tdt = {
    extension: {
      type: Nn.Environment,
      name: "browser",
      priority: -1
    },
    test: () => true,
    load: async () => {
      await $g(() => import("./browserAll-C1Im70F6.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([0,1,2,3,4,5]));
    }
  };
  ndt = {
    extension: {
      type: Nn.Environment,
      name: "webworker",
      priority: 0
    },
    test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
    load: async () => {
      await $g(() => import("./webworkerAll-Dv7AH6DU.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([1,2,3,4,5]));
    }
  };
  class ma {
    constructor(e, t, r) {
      this._x = t || 0, this._y = r || 0, this._observer = e;
    }
    clone(e) {
      return new ma(e ?? this._observer, this._x, this._y);
    }
    set(e = 0, t = e) {
      return (this._x !== e || this._y !== t) && (this._x = e, this._y = t, this._observer._onUpdate(this)), this;
    }
    copyFrom(e) {
      return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this;
    }
    copyTo(e) {
      return e.set(this._x, this._y), e;
    }
    equals(e) {
      return e.x === this._x && e.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x !== e && (this._x = e, this._observer._onUpdate(this));
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y !== e && (this._y = e, this._observer._onUpdate(this));
    }
  }
  var TA = {
    exports: {}
  }, dH;
  function rdt() {
    return dH || (dH = 1, function(n) {
      var e = Object.prototype.hasOwnProperty, t = "~";
      function r() {
      }
      Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = false));
      function i(l, u, c) {
        this.fn = l, this.context = u, this.once = c || false;
      }
      function a(l, u, c, h, d) {
        if (typeof c != "function") throw new TypeError("The listener must be a function");
        var f = new i(c, h || l, d), p = t ? t + u : u;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [
          l._events[p],
          f
        ] : l._events[p].push(f) : (l._events[p] = f, l._eventsCount++), l;
      }
      function s(l, u) {
        --l._eventsCount === 0 ? l._events = new r() : delete l._events[u];
      }
      function o() {
        this._events = new r(), this._eventsCount = 0;
      }
      o.prototype.eventNames = function() {
        var u = [], c, h;
        if (this._eventsCount === 0) return u;
        for (h in c = this._events) e.call(c, h) && u.push(t ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u;
      }, o.prototype.listeners = function(u) {
        var c = t ? t + u : u, h = this._events[c];
        if (!h) return [];
        if (h.fn) return [
          h.fn
        ];
        for (var d = 0, f = h.length, p = new Array(f); d < f; d++) p[d] = h[d].fn;
        return p;
      }, o.prototype.listenerCount = function(u) {
        var c = t ? t + u : u, h = this._events[c];
        return h ? h.fn ? 1 : h.length : 0;
      }, o.prototype.emit = function(u, c, h, d, f, p) {
        var g = t ? t + u : u;
        if (!this._events[g]) return false;
        var m = this._events[g], v = arguments.length, y, x;
        if (m.fn) {
          switch (m.once && this.removeListener(u, m.fn, void 0, true), v) {
            case 1:
              return m.fn.call(m.context), true;
            case 2:
              return m.fn.call(m.context, c), true;
            case 3:
              return m.fn.call(m.context, c, h), true;
            case 4:
              return m.fn.call(m.context, c, h, d), true;
            case 5:
              return m.fn.call(m.context, c, h, d, f), true;
            case 6:
              return m.fn.call(m.context, c, h, d, f, p), true;
          }
          for (x = 1, y = new Array(v - 1); x < v; x++) y[x - 1] = arguments[x];
          m.fn.apply(m.context, y);
        } else {
          var b = m.length, w;
          for (x = 0; x < b; x++) switch (m[x].once && this.removeListener(u, m[x].fn, void 0, true), v) {
            case 1:
              m[x].fn.call(m[x].context);
              break;
            case 2:
              m[x].fn.call(m[x].context, c);
              break;
            case 3:
              m[x].fn.call(m[x].context, c, h);
              break;
            case 4:
              m[x].fn.call(m[x].context, c, h, d);
              break;
            default:
              if (!y) for (w = 1, y = new Array(v - 1); w < v; w++) y[w - 1] = arguments[w];
              m[x].fn.apply(m[x].context, y);
          }
        }
        return true;
      }, o.prototype.on = function(u, c, h) {
        return a(this, u, c, h, false);
      }, o.prototype.once = function(u, c, h) {
        return a(this, u, c, h, true);
      }, o.prototype.removeListener = function(u, c, h, d) {
        var f = t ? t + u : u;
        if (!this._events[f]) return this;
        if (!c) return s(this, f), this;
        var p = this._events[f];
        if (p.fn) p.fn === c && (!d || p.once) && (!h || p.context === h) && s(this, f);
        else {
          for (var g = 0, m = [], v = p.length; g < v; g++) (p[g].fn !== c || d && !p[g].once || h && p[g].context !== h) && m.push(p[g]);
          m.length ? this._events[f] = m.length === 1 ? m[0] : m : s(this, f);
        }
        return this;
      }, o.prototype.removeAllListeners = function(u) {
        var c;
        return u ? (c = t ? t + u : u, this._events[c] && s(this, c)) : (this._events = new r(), this._eventsCount = 0), this;
      }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, n.exports = o;
    }(TA)), TA.exports;
  }
  var idt = rdt();
  let adt, sdt, odt;
  fl = _v(idt);
  adt = Math.PI * 2;
  sdt = 180 / Math.PI;
  odt = Math.PI / 180;
  Ri = class {
    constructor(e = 0, t = 0) {
      this.x = 0, this.y = 0, this.x = e, this.y = t;
    }
    clone() {
      return new Ri(this.x, this.y);
    }
    copyFrom(e) {
      return this.set(e.x, e.y), this;
    }
    copyTo(e) {
      return e.set(this.x, this.y), e;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    set(e = 0, t = e) {
      return this.x = e, this.y = t, this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
      return AA.x = 0, AA.y = 0, AA;
    }
  };
  const AA = new Ri();
  pn = class {
    constructor(e = 1, t = 0, r = 0, i = 1, a = 0, s = 0) {
      this.array = null, this.a = e, this.b = t, this.c = r, this.d = i, this.tx = a, this.ty = s;
    }
    fromArray(e) {
      this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
    }
    set(e, t, r, i, a, s) {
      return this.a = e, this.b = t, this.c = r, this.d = i, this.tx = a, this.ty = s, this;
    }
    toArray(e, t) {
      this.array || (this.array = new Float32Array(9));
      const r = t || this.array;
      return e ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
    }
    apply(e, t) {
      t = t || new Ri();
      const r = e.x, i = e.y;
      return t.x = this.a * r + this.c * i + this.tx, t.y = this.b * r + this.d * i + this.ty, t;
    }
    applyInverse(e, t) {
      t = t || new Ri();
      const r = this.a, i = this.b, a = this.c, s = this.d, o = this.tx, l = this.ty, u = 1 / (r * s + a * -i), c = e.x, h = e.y;
      return t.x = s * u * c + -a * u * h + (l * a - o * s) * u, t.y = r * u * h + -i * u * c + (-l * r + o * i) * u, t;
    }
    translate(e, t) {
      return this.tx += e, this.ty += t, this;
    }
    scale(e, t) {
      return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this;
    }
    rotate(e) {
      const t = Math.cos(e), r = Math.sin(e), i = this.a, a = this.c, s = this.tx;
      return this.a = i * t - this.b * r, this.b = i * r + this.b * t, this.c = a * t - this.d * r, this.d = a * r + this.d * t, this.tx = s * t - this.ty * r, this.ty = s * r + this.ty * t, this;
    }
    append(e) {
      const t = this.a, r = this.b, i = this.c, a = this.d;
      return this.a = e.a * t + e.b * i, this.b = e.a * r + e.b * a, this.c = e.c * t + e.d * i, this.d = e.c * r + e.d * a, this.tx = e.tx * t + e.ty * i + this.tx, this.ty = e.tx * r + e.ty * a + this.ty, this;
    }
    appendFrom(e, t) {
      const r = e.a, i = e.b, a = e.c, s = e.d, o = e.tx, l = e.ty, u = t.a, c = t.b, h = t.c, d = t.d;
      return this.a = r * u + i * h, this.b = r * c + i * d, this.c = a * u + s * h, this.d = a * c + s * d, this.tx = o * u + l * h + t.tx, this.ty = o * c + l * d + t.ty, this;
    }
    setTransform(e, t, r, i, a, s, o, l, u) {
      return this.a = Math.cos(o + u) * a, this.b = Math.sin(o + u) * a, this.c = -Math.sin(o - l) * s, this.d = Math.cos(o - l) * s, this.tx = e - (r * this.a + i * this.c), this.ty = t - (r * this.b + i * this.d), this;
    }
    prepend(e) {
      const t = this.tx;
      if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
        const r = this.a, i = this.c;
        this.a = r * e.a + this.b * e.c, this.b = r * e.b + this.b * e.d, this.c = i * e.a + this.d * e.c, this.d = i * e.b + this.d * e.d;
      }
      return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this;
    }
    decompose(e) {
      const t = this.a, r = this.b, i = this.c, a = this.d, s = e.pivot, o = -Math.atan2(-i, a), l = Math.atan2(r, t), u = Math.abs(o + l);
      return u < 1e-5 || Math.abs(adt - u) < 1e-5 ? (e.rotation = l, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = o, e.skew.y = l), e.scale.x = Math.sqrt(t * t + r * r), e.scale.y = Math.sqrt(i * i + a * a), e.position.x = this.tx + (s.x * t + s.y * i), e.position.y = this.ty + (s.x * r + s.y * a), e;
    }
    invert() {
      const e = this.a, t = this.b, r = this.c, i = this.d, a = this.tx, s = e * i - t * r;
      return this.a = i / s, this.b = -t / s, this.c = -r / s, this.d = e / s, this.tx = (r * this.ty - i * a) / s, this.ty = -(e * this.ty - t * a) / s, this;
    }
    isIdentity() {
      return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
    }
    identity() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }
    clone() {
      const e = new pn();
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }
    copyTo(e) {
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }
    copyFrom(e) {
      return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
    }
    equals(e) {
      return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return udt.identity();
    }
    static get shared() {
      return ldt.identity();
    }
  };
  const ldt = new pn(), udt = new pn(), Sh = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1
  ], Ch = [
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], Ih = [
    0,
    -1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    -1,
    -1,
    -1
  ], kh = [
    1,
    1,
    0,
    -1,
    -1,
    -1,
    0,
    1,
    -1,
    -1,
    0,
    1,
    1,
    1,
    0,
    -1
  ], q$ = [], Ure = [], Aw = Math.sign;
  function cdt() {
    for (let n = 0; n < 16; n++) {
      const e = [];
      q$.push(e);
      for (let t = 0; t < 16; t++) {
        const r = Aw(Sh[n] * Sh[t] + Ih[n] * Ch[t]), i = Aw(Ch[n] * Sh[t] + kh[n] * Ch[t]), a = Aw(Sh[n] * Ih[t] + Ih[n] * kh[t]), s = Aw(Ch[n] * Ih[t] + kh[n] * kh[t]);
        for (let o = 0; o < 16; o++) if (Sh[o] === r && Ch[o] === i && Ih[o] === a && kh[o] === s) {
          e.push(o);
          break;
        }
      }
    }
    for (let n = 0; n < 16; n++) {
      const e = new pn();
      e.set(Sh[n], Ch[n], Ih[n], kh[n], 0, 0), Ure.push(e);
    }
  }
  cdt();
  const nr = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (n) => Sh[n],
    uY: (n) => Ch[n],
    vX: (n) => Ih[n],
    vY: (n) => kh[n],
    inv: (n) => n & 8 ? n & 15 : -n & 7,
    add: (n, e) => q$[n][e],
    sub: (n, e) => q$[n][nr.inv(e)],
    rotate180: (n) => n ^ 4,
    isVertical: (n) => (n & 3) === 2,
    byDirection: (n, e) => Math.abs(n) * 2 <= Math.abs(e) ? e >= 0 ? nr.S : nr.N : Math.abs(e) * 2 <= Math.abs(n) ? n > 0 ? nr.E : nr.W : e > 0 ? n > 0 ? nr.SE : nr.SW : n > 0 ? nr.NE : nr.NW,
    matrixAppendRotationInv: (n, e, t = 0, r = 0) => {
      const i = Ure[nr.inv(e)];
      i.tx = t, i.ty = r, n.append(i);
    }
  }, Dw = [
    new Ri(),
    new Ri(),
    new Ri(),
    new Ri()
  ];
  ri = class {
    constructor(e = 0, t = 0, r = 0, i = 0) {
      this.type = "rectangle", this.x = Number(e), this.y = Number(t), this.width = Number(r), this.height = Number(i);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new ri(0, 0, 0, 0);
    }
    clone() {
      return new ri(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(e) {
      return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    contains(e, t) {
      return this.width <= 0 || this.height <= 0 ? false : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
    }
    strokeContains(e, t, r, i = 0.5) {
      const { width: a, height: s } = this;
      if (a <= 0 || s <= 0) return false;
      const o = this.x, l = this.y, u = r * (1 - i), c = r - u, h = o - u, d = o + a + u, f = l - u, p = l + s + u, g = o + c, m = o + a - c, v = l + c, y = l + s - c;
      return e >= h && e <= d && t >= f && t <= p && !(e > g && e < m && t > v && t < y);
    }
    intersects(e, t) {
      if (!t) {
        const I = this.x < e.x ? e.x : this.x;
        if ((this.right > e.right ? e.right : this.right) <= I) return false;
        const T = this.y < e.y ? e.y : this.y;
        return (this.bottom > e.bottom ? e.bottom : this.bottom) > T;
      }
      const r = this.left, i = this.right, a = this.top, s = this.bottom;
      if (i <= r || s <= a) return false;
      const o = Dw[0].set(e.left, e.top), l = Dw[1].set(e.left, e.bottom), u = Dw[2].set(e.right, e.top), c = Dw[3].set(e.right, e.bottom);
      if (u.x <= o.x || l.y <= o.y) return false;
      const h = Math.sign(t.a * t.d - t.b * t.c);
      if (h === 0 || (t.apply(o, o), t.apply(l, l), t.apply(u, u), t.apply(c, c), Math.max(o.x, l.x, u.x, c.x) <= r || Math.min(o.x, l.x, u.x, c.x) >= i || Math.max(o.y, l.y, u.y, c.y) <= a || Math.min(o.y, l.y, u.y, c.y) >= s)) return false;
      const d = h * (l.y - o.y), f = h * (o.x - l.x), p = d * r + f * a, g = d * i + f * a, m = d * r + f * s, v = d * i + f * s;
      if (Math.max(p, g, m, v) <= d * o.x + f * o.y || Math.min(p, g, m, v) >= d * c.x + f * c.y) return false;
      const y = h * (o.y - u.y), x = h * (u.x - o.x), b = y * r + x * a, w = y * i + x * a, _ = y * r + x * s, S = y * i + x * s;
      return !(Math.max(b, w, _, S) <= y * o.x + x * o.y || Math.min(b, w, _, S) >= y * c.x + x * c.y);
    }
    pad(e = 0, t = e) {
      return this.x -= e, this.y -= t, this.width += e * 2, this.height += t * 2, this;
    }
    fit(e) {
      const t = Math.max(this.x, e.x), r = Math.min(this.x + this.width, e.x + e.width), i = Math.max(this.y, e.y), a = Math.min(this.y + this.height, e.y + e.height);
      return this.x = t, this.width = Math.max(r - t, 0), this.y = i, this.height = Math.max(a - i, 0), this;
    }
    ceil(e = 1, t = 1e-3) {
      const r = Math.ceil((this.x + this.width - t) * e) / e, i = Math.ceil((this.y + this.height - t) * e) / e;
      return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = r - this.x, this.height = i - this.y, this;
    }
    enlarge(e) {
      const t = Math.min(this.x, e.x), r = Math.max(this.x + this.width, e.x + e.width), i = Math.min(this.y, e.y), a = Math.max(this.y + this.height, e.y + e.height);
      return this.x = t, this.width = r - t, this.y = i, this.height = a - i, this;
    }
    getBounds(e) {
      return e || (e = new ri()), e.copyFrom(this), e;
    }
    containsRect(e) {
      if (this.width <= 0 || this.height <= 0) return false;
      const t = e.x, r = e.y, i = e.x + e.width, a = e.y + e.height;
      return t >= this.x && t < this.x + this.width && r >= this.y && r < this.y + this.height && i >= this.x && i < this.x + this.width && a >= this.y && a < this.y + this.height;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  };
  const DA = {
    default: -1
  };
  Dr = function(n = "default") {
    return DA[n] === void 0 && (DA[n] = -1), ++DA[n];
  };
  let fH, hdt;
  fH = {};
  or = "8.0.0";
  hdt = "8.3.4";
  Gn = function(n, e, t = 3) {
    if (fH[e]) return;
    let r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${n}`) : (r = r.split(`
`).splice(t).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${n}`), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${n}`), console.warn(r))), fH[e] = true;
  };
  const Hre = () => {
  };
  pH = function(n) {
    return n += n === 0 ? 1 : 0, --n, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n + 1;
  };
  function gH(n) {
    return !(n & n - 1) && !!n;
  }
  function Xre(n) {
    const e = {};
    for (const t in n) n[t] !== void 0 && (e[t] = n[t]);
    return e;
  }
  const mH = /* @__PURE__ */ Object.create(null);
  function ddt(n) {
    const e = mH[n];
    return e === void 0 && (mH[n] = Dr("resource")), e;
  }
  const Yre = class qre extends fl {
    constructor(e = {}) {
      super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = false, e = {
        ...qre.defaultOptions,
        ...e
      }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ?? this.addressModeU, this.addressModeV = e.addressModeV ?? this.addressModeV, this.addressModeW = e.addressModeW ?? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ?? this.magFilter, this.minFilter = e.minFilter ?? this.minFilter, this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ?? 1;
    }
    set addressMode(e) {
      this.addressModeU = e, this.addressModeV = e, this.addressModeW = e;
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(e) {
      Gn(or, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e;
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(e) {
      this.magFilter = e, this.minFilter = e, this.mipmapFilter = e;
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(e) {
      this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this), this._sharedResourceId = null;
    }
    _generateResourceId() {
      const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      return this._sharedResourceId = ddt(e), this._resourceId;
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
    }
  };
  Yre.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
  };
  fdt = Yre;
  const jre = class Kre extends fl {
    constructor(e = {}) {
      super(), this.options = e, this.uid = Dr("textureSource"), this._resourceType = "textureSource", this._resourceId = Dr("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = false, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = false, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = {
        ...Kre.defaultOptions,
        ...e
      }, this.label = e.label ?? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new fdt(Xre(e)), this.destroyed = false, this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(e) {
      var _a2, _b2;
      this.style !== e && ((_a2 = this._style) == null ? void 0 : _a2.off("change", this._onStyleChange, this), this._style = e, (_b2 = this._style) == null ? void 0 : _b2.on("change", this._onStyleChange, this), this._onStyleChange());
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(e) {
      this._style.addressMode = e;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(e) {
      this._style.addressMode = e;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(e) {
      this._style.magFilter = e;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(e) {
      this._style.minFilter = e;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(e) {
      this._style.mipmapFilter = e;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(e) {
      this._style.lodMinClamp = e;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(e) {
      this._style.lodMaxClamp = e;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const e = this._resolution;
        if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return;
      }
      this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
    }
    unload() {
      this._resourceId = Dr("resource"), this.emit("change", this), this.emit("unload", this);
    }
    get resourceWidth() {
      const { resource: e } = this;
      return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
    }
    get resourceHeight() {
      const { resource: e } = this;
      return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e);
    }
    resize(e, t, r) {
      r || (r = this._resolution), e || (e = this.width), t || (t = this.height);
      const i = Math.round(e * r), a = Math.round(t * r);
      return this.width = i / r, this.height = a / r, this._resolution = r, this.pixelWidth === i && this.pixelHeight === a ? false : (this._refreshPOT(), this.pixelWidth = i, this.pixelHeight = a, this.emit("resize", this), this._resourceId = Dr("resource"), this.emit("change", this), true);
    }
    updateMipmaps() {
      this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
    }
    set wrapMode(e) {
      this._style.wrapMode = e;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(e) {
      this._style.scaleMode = e;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = gH(this.pixelWidth) && gH(this.pixelHeight);
    }
    static test(e) {
      throw new Error("Unimplemented");
    }
  };
  jre.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: false,
    sampleCount: 1,
    antialias: false,
    autoGarbageCollect: false
  };
  mo = jre;
  class zL extends mo {
    constructor(e) {
      const t = e.resource || new Float32Array(e.width * e.height * 4);
      let r = e.format;
      r || (t instanceof Float32Array ? r = "rgba32float" : t instanceof Int32Array || t instanceof Uint32Array ? r = "rgba32uint" : t instanceof Int16Array || t instanceof Uint16Array ? r = "rgba16uint" : (t instanceof Int8Array, r = "bgra8unorm")), super({
        ...e,
        resource: t,
        format: r
      }), this.uploadMethodId = "buffer";
    }
    static test(e) {
      return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array;
    }
  }
  zL.extension = Nn.TextureSource;
  const vH = new pn();
  pdt = class {
    constructor(e, t) {
      this.mapCoord = new pn(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof t > "u" ? this.clampMargin = e.width < 10 ? 0 : 0.5 : this.clampMargin = t, this.isSimple = false, this.texture = e;
    }
    get texture() {
      return this._texture;
    }
    set texture(e) {
      var _a2;
      this.texture !== e && ((_a2 = this._texture) == null ? void 0 : _a2.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update());
    }
    multiplyUvs(e, t) {
      t === void 0 && (t = e);
      const r = this.mapCoord;
      for (let i = 0; i < e.length; i += 2) {
        const a = e[i], s = e[i + 1];
        t[i] = a * r.a + s * r.c + r.tx, t[i + 1] = a * r.b + s * r.d + r.ty;
      }
      return t;
    }
    update() {
      const e = this._texture;
      this._updateID++;
      const t = e.uvs;
      this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0);
      const r = e.orig, i = e.trim;
      i && (vH.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(vH));
      const a = e.source, s = this.uClampFrame, o = this.clampMargin / a._resolution, l = this.clampOffset / a._resolution;
      return s[0] = (e.frame.x + o + l) / a.width, s[1] = (e.frame.y + o + l) / a.height, s[2] = (e.frame.x + e.frame.width - o + l) / a.width, s[3] = (e.frame.y + e.frame.height - o + l) / a.height, this.uClampOffset[0] = this.clampOffset / a.pixelWidth, this.uClampOffset[1] = this.clampOffset / a.pixelHeight, this.isSimple = e.frame.width === a.width && e.frame.height === a.height && e.rotate === 0, true;
    }
  };
  Fn = class extends fl {
    constructor({ source: e, label: t, frame: r, orig: i, trim: a, defaultAnchor: s, defaultBorders: o, rotate: l, dynamic: u } = {}) {
      if (super(), this.uid = Dr("texture"), this.uvs = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        x3: 0,
        y3: 0
      }, this.frame = new ri(), this.noFrame = false, this.dynamic = false, this.isTexture = true, this.label = t, this.source = (e == null ? void 0 : e.source) ?? new mo(), this.noFrame = !r, r) this.frame.copyFrom(r);
      else {
        const { width: c, height: h } = this._source;
        this.frame.width = c, this.frame.height = h;
      }
      this.orig = i || this.frame, this.trim = a, this.rotate = l ?? 0, this.defaultAnchor = s, this.defaultBorders = o, this.destroyed = false, this.dynamic = u || false, this.updateUvs();
    }
    set source(e) {
      this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      return this._textureMatrix || (this._textureMatrix = new pdt(this)), this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const { uvs: e, frame: t } = this, { width: r, height: i } = this._source, a = t.x / r, s = t.y / i, o = t.width / r, l = t.height / i;
      let u = this.rotate;
      if (u) {
        const c = o / 2, h = l / 2, d = a + c, f = s + h;
        u = nr.add(u, nr.NW), e.x0 = d + c * nr.uX(u), e.y0 = f + h * nr.uY(u), u = nr.add(u, 2), e.x1 = d + c * nr.uX(u), e.y1 = f + h * nr.uY(u), u = nr.add(u, 2), e.x2 = d + c * nr.uX(u), e.y2 = f + h * nr.uY(u), u = nr.add(u, 2), e.x3 = d + c * nr.uX(u), e.y3 = f + h * nr.uY(u);
      } else e.x0 = a, e.y0 = s, e.x1 = a + o, e.y1 = s, e.x2 = a + o, e.y2 = s + l, e.x3 = a, e.y3 = s + l;
    }
    destroy(e = false) {
      this._source && e && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = true, this.emit("destroy", this), this.removeAllListeners();
    }
    update() {
      this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
    }
    get baseTexture() {
      return Gn(or, "Texture.baseTexture is now Texture.source"), this._source;
    }
  };
  Fn.EMPTY = new Fn({
    label: "EMPTY",
    source: new mo({
      label: "EMPTY"
    })
  });
  Fn.EMPTY.destroy = Hre;
  Fn.WHITE = new Fn({
    source: new zL({
      resource: new Uint8Array([
        255,
        255,
        255,
        255
      ]),
      width: 1,
      height: 1,
      alphaMode: "premultiply-alpha-on-upload",
      label: "WHITE"
    }),
    label: "WHITE"
  });
  Fn.WHITE.destroy = Hre;
  gdt = function(n, e, t) {
    const { width: r, height: i } = t.orig, a = t.trim;
    if (a) {
      const s = a.width, o = a.height;
      n.minX = a.x - e._x * r, n.maxX = n.minX + s, n.minY = a.y - e._y * i, n.maxY = n.minY + o;
    } else n.minX = -e._x * r, n.maxX = n.minX + r, n.minY = -e._y * i, n.maxY = n.minY + i;
  };
  const yH = new pn();
  co = class {
    constructor(e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0) {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = yH, this.minX = e, this.minY = t, this.maxX = r, this.maxY = i;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      this._rectangle || (this._rectangle = new ri());
      const e = this._rectangle;
      return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e;
    }
    clear() {
      return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = yH, this;
    }
    set(e, t, r, i) {
      this.minX = e, this.minY = t, this.maxX = r, this.maxY = i;
    }
    addFrame(e, t, r, i, a) {
      a || (a = this.matrix);
      const s = a.a, o = a.b, l = a.c, u = a.d, c = a.tx, h = a.ty;
      let d = this.minX, f = this.minY, p = this.maxX, g = this.maxY, m = s * e + l * t + c, v = o * e + u * t + h;
      m < d && (d = m), v < f && (f = v), m > p && (p = m), v > g && (g = v), m = s * r + l * t + c, v = o * r + u * t + h, m < d && (d = m), v < f && (f = v), m > p && (p = m), v > g && (g = v), m = s * e + l * i + c, v = o * e + u * i + h, m < d && (d = m), v < f && (f = v), m > p && (p = m), v > g && (g = v), m = s * r + l * i + c, v = o * r + u * i + h, m < d && (d = m), v < f && (f = v), m > p && (p = m), v > g && (g = v), this.minX = d, this.minY = f, this.maxX = p, this.maxY = g;
    }
    addRect(e, t) {
      this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t);
    }
    addBounds(e, t) {
      this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t);
    }
    addBoundsMask(e) {
      this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY;
    }
    applyMatrix(e) {
      const t = this.minX, r = this.minY, i = this.maxX, a = this.maxY, { a: s, b: o, c: l, d: u, tx: c, ty: h } = e;
      let d = s * t + l * r + c, f = o * t + u * r + h;
      this.minX = d, this.minY = f, this.maxX = d, this.maxY = f, d = s * i + l * r + c, f = o * i + u * r + h, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = s * t + l * a + c, f = o * t + u * a + h, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = s * i + l * a + c, f = o * i + u * a + h, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY;
    }
    fit(e) {
      return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this;
    }
    fitBounds(e, t, r, i) {
      return this.minX < e && (this.minX = e), this.maxX > t && (this.maxX = t), this.minY < r && (this.minY = r), this.maxY > i && (this.maxY = i), this;
    }
    pad(e, t = e) {
      return this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t, this;
    }
    ceil() {
      return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
    }
    clone() {
      return new co(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(e, t = e) {
      return this.minX *= e, this.minY *= t, this.maxX *= e, this.maxY *= t, this;
    }
    get x() {
      return this.minX;
    }
    set x(e) {
      const t = this.maxX - this.minX;
      this.minX = e, this.maxX = e + t;
    }
    get y() {
      return this.minY;
    }
    set y(e) {
      const t = this.maxY - this.minY;
      this.minY = e, this.maxY = e + t;
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(e) {
      this.maxX = this.minX + e;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(e) {
      this.maxY = this.minY + e;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== 1 / 0;
    }
    addVertexData(e, t, r, i) {
      let a = this.minX, s = this.minY, o = this.maxX, l = this.maxY;
      i || (i = this.matrix);
      const u = i.a, c = i.b, h = i.c, d = i.d, f = i.tx, p = i.ty;
      for (let g = t; g < r; g += 2) {
        const m = e[g], v = e[g + 1], y = u * m + h * v + f, x = c * m + d * v + p;
        a = y < a ? y : a, s = x < s ? x : s, o = y > o ? y : o, l = x > l ? x : l;
      }
      this.minX = a, this.minY = s, this.maxX = o, this.maxY = l;
    }
    containsPoint(e, t) {
      return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    copyFrom(e) {
      return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this;
    }
  };
  var mdt = {
    grad: 0.9,
    turn: 360,
    rad: 360 / (2 * Math.PI)
  }, bl = function(n) {
    return typeof n == "string" ? n.length > 0 : typeof n == "number";
  }, ei = function(n, e, t) {
    return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * n) / t + 0;
  }, bs = function(n, e, t) {
    return e === void 0 && (e = 0), t === void 0 && (t = 1), n > t ? t : n > e ? n : e;
  }, Zre = function(n) {
    return (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360;
  }, xH = function(n) {
    return {
      r: bs(n.r, 0, 255),
      g: bs(n.g, 0, 255),
      b: bs(n.b, 0, 255),
      a: bs(n.a)
    };
  }, RA = function(n) {
    return {
      r: ei(n.r),
      g: ei(n.g),
      b: ei(n.b),
      a: ei(n.a, 3)
    };
  }, vdt = /^#([0-9a-f]{3,8})$/i, Rw = function(n) {
    var e = n.toString(16);
    return e.length < 2 ? "0" + e : e;
  }, Qre = function(n) {
    var e = n.r, t = n.g, r = n.b, i = n.a, a = Math.max(e, t, r), s = a - Math.min(e, t, r), o = s ? a === e ? (t - r) / s : a === t ? 2 + (r - e) / s : 4 + (e - t) / s : 0;
    return {
      h: 60 * (o < 0 ? o + 6 : o),
      s: a ? s / a * 100 : 0,
      v: a / 255 * 100,
      a: i
    };
  }, Jre = function(n) {
    var e = n.h, t = n.s, r = n.v, i = n.a;
    e = e / 360 * 6, t /= 100, r /= 100;
    var a = Math.floor(e), s = r * (1 - t), o = r * (1 - (e - a) * t), l = r * (1 - (1 - e + a) * t), u = a % 6;
    return {
      r: 255 * [
        r,
        o,
        s,
        s,
        l,
        r
      ][u],
      g: 255 * [
        l,
        r,
        r,
        o,
        s,
        s
      ][u],
      b: 255 * [
        s,
        s,
        l,
        r,
        r,
        o
      ][u],
      a: i
    };
  }, bH = function(n) {
    return {
      h: Zre(n.h),
      s: bs(n.s, 0, 100),
      l: bs(n.l, 0, 100),
      a: bs(n.a)
    };
  }, wH = function(n) {
    return {
      h: ei(n.h),
      s: ei(n.s),
      l: ei(n.l),
      a: ei(n.a, 3)
    };
  }, _H = function(n) {
    return Jre((t = (e = n).s, {
      h: e.h,
      s: (t *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * t / (r + t) * 100 : 0,
      v: r + t,
      a: e.a
    }));
    var e, t, r;
  }, y0 = function(n) {
    return {
      h: (e = Qre(n)).h,
      s: (i = (200 - (t = e.s)) * (r = e.v) / 100) > 0 && i < 200 ? t * r / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
      l: i / 2,
      a: e.a
    };
    var e, t, r, i;
  }, ydt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, xdt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, bdt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, wdt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, j$ = {
    string: [
      [
        function(n) {
          var e = vdt.exec(n);
          return e ? (n = e[1]).length <= 4 ? {
            r: parseInt(n[0] + n[0], 16),
            g: parseInt(n[1] + n[1], 16),
            b: parseInt(n[2] + n[2], 16),
            a: n.length === 4 ? ei(parseInt(n[3] + n[3], 16) / 255, 2) : 1
          } : n.length === 6 || n.length === 8 ? {
            r: parseInt(n.substr(0, 2), 16),
            g: parseInt(n.substr(2, 2), 16),
            b: parseInt(n.substr(4, 2), 16),
            a: n.length === 8 ? ei(parseInt(n.substr(6, 2), 16) / 255, 2) : 1
          } : null : null;
        },
        "hex"
      ],
      [
        function(n) {
          var e = bdt.exec(n) || wdt.exec(n);
          return e ? e[2] !== e[4] || e[4] !== e[6] ? null : xH({
            r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
            g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
            b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
            a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
          }) : null;
        },
        "rgb"
      ],
      [
        function(n) {
          var e = ydt.exec(n) || xdt.exec(n);
          if (!e) return null;
          var t, r, i = bH({
            h: (t = e[1], r = e[2], r === void 0 && (r = "deg"), Number(t) * (mdt[r] || 1)),
            s: Number(e[3]),
            l: Number(e[4]),
            a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
          });
          return _H(i);
        },
        "hsl"
      ]
    ],
    object: [
      [
        function(n) {
          var e = n.r, t = n.g, r = n.b, i = n.a, a = i === void 0 ? 1 : i;
          return bl(e) && bl(t) && bl(r) ? xH({
            r: Number(e),
            g: Number(t),
            b: Number(r),
            a: Number(a)
          }) : null;
        },
        "rgb"
      ],
      [
        function(n) {
          var e = n.h, t = n.s, r = n.l, i = n.a, a = i === void 0 ? 1 : i;
          if (!bl(e) || !bl(t) || !bl(r)) return null;
          var s = bH({
            h: Number(e),
            s: Number(t),
            l: Number(r),
            a: Number(a)
          });
          return _H(s);
        },
        "hsl"
      ],
      [
        function(n) {
          var e = n.h, t = n.s, r = n.v, i = n.a, a = i === void 0 ? 1 : i;
          if (!bl(e) || !bl(t) || !bl(r)) return null;
          var s = function(o) {
            return {
              h: Zre(o.h),
              s: bs(o.s, 0, 100),
              v: bs(o.v, 0, 100),
              a: bs(o.a)
            };
          }({
            h: Number(e),
            s: Number(t),
            v: Number(r),
            a: Number(a)
          });
          return Jre(s);
        },
        "hsv"
      ]
    ]
  }, SH = function(n, e) {
    for (var t = 0; t < e.length; t++) {
      var r = e[t][0](n);
      if (r) return [
        r,
        e[t][1]
      ];
    }
    return [
      null,
      void 0
    ];
  }, _dt = function(n) {
    return typeof n == "string" ? SH(n.trim(), j$.string) : typeof n == "object" && n !== null ? SH(n, j$.object) : [
      null,
      void 0
    ];
  }, $A = function(n, e) {
    var t = y0(n);
    return {
      h: t.h,
      s: bs(t.s + 100 * e, 0, 100),
      l: t.l,
      a: t.a
    };
  }, NA = function(n) {
    return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3 / 255;
  }, CH = function(n, e) {
    var t = y0(n);
    return {
      h: t.h,
      s: t.s,
      l: bs(t.l + 100 * e, 0, 100),
      a: t.a
    };
  }, K$ = function() {
    function n(e) {
      this.parsed = _dt(e)[0], this.rgba = this.parsed || {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      };
    }
    return n.prototype.isValid = function() {
      return this.parsed !== null;
    }, n.prototype.brightness = function() {
      return ei(NA(this.rgba), 2);
    }, n.prototype.isDark = function() {
      return NA(this.rgba) < 0.5;
    }, n.prototype.isLight = function() {
      return NA(this.rgba) >= 0.5;
    }, n.prototype.toHex = function() {
      return e = RA(this.rgba), t = e.r, r = e.g, i = e.b, s = (a = e.a) < 1 ? Rw(ei(255 * a)) : "", "#" + Rw(t) + Rw(r) + Rw(i) + s;
      var e, t, r, i, a, s;
    }, n.prototype.toRgb = function() {
      return RA(this.rgba);
    }, n.prototype.toRgbString = function() {
      return e = RA(this.rgba), t = e.r, r = e.g, i = e.b, (a = e.a) < 1 ? "rgba(" + t + ", " + r + ", " + i + ", " + a + ")" : "rgb(" + t + ", " + r + ", " + i + ")";
      var e, t, r, i, a;
    }, n.prototype.toHsl = function() {
      return wH(y0(this.rgba));
    }, n.prototype.toHslString = function() {
      return e = wH(y0(this.rgba)), t = e.h, r = e.s, i = e.l, (a = e.a) < 1 ? "hsla(" + t + ", " + r + "%, " + i + "%, " + a + ")" : "hsl(" + t + ", " + r + "%, " + i + "%)";
      var e, t, r, i, a;
    }, n.prototype.toHsv = function() {
      return e = Qre(this.rgba), {
        h: ei(e.h),
        s: ei(e.s),
        v: ei(e.v),
        a: ei(e.a, 3)
      };
      var e;
    }, n.prototype.invert = function() {
      return Ao({
        r: 255 - (e = this.rgba).r,
        g: 255 - e.g,
        b: 255 - e.b,
        a: e.a
      });
      var e;
    }, n.prototype.saturate = function(e) {
      return e === void 0 && (e = 0.1), Ao($A(this.rgba, e));
    }, n.prototype.desaturate = function(e) {
      return e === void 0 && (e = 0.1), Ao($A(this.rgba, -e));
    }, n.prototype.grayscale = function() {
      return Ao($A(this.rgba, -1));
    }, n.prototype.lighten = function(e) {
      return e === void 0 && (e = 0.1), Ao(CH(this.rgba, e));
    }, n.prototype.darken = function(e) {
      return e === void 0 && (e = 0.1), Ao(CH(this.rgba, -e));
    }, n.prototype.rotate = function(e) {
      return e === void 0 && (e = 15), this.hue(this.hue() + e);
    }, n.prototype.alpha = function(e) {
      return typeof e == "number" ? Ao({
        r: (t = this.rgba).r,
        g: t.g,
        b: t.b,
        a: e
      }) : ei(this.rgba.a, 3);
      var t;
    }, n.prototype.hue = function(e) {
      var t = y0(this.rgba);
      return typeof e == "number" ? Ao({
        h: e,
        s: t.s,
        l: t.l,
        a: t.a
      }) : ei(t.h);
    }, n.prototype.isEqual = function(e) {
      return this.toHex() === Ao(e).toHex();
    }, n;
  }(), Ao = function(n) {
    return n instanceof K$ ? n : new K$(n);
  }, IH = [], Sdt = function(n) {
    n.forEach(function(e) {
      IH.indexOf(e) < 0 && (e(K$, j$), IH.push(e));
    });
  };
  function Cdt(n, e) {
    var t = {
      white: "#ffffff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000"
    }, r = {};
    for (var i in t) r[t[i]] = i;
    var a = {};
    n.prototype.toName = function(s) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var o, l, u = r[this.toHex()];
      if (u) return u;
      if (s == null ? void 0 : s.closest) {
        var c = this.toRgb(), h = 1 / 0, d = "black";
        if (!a.length) for (var f in t) a[f] = new n(t[f]).toRgb();
        for (var p in t) {
          var g = (o = c, l = a[p], Math.pow(o.r - l.r, 2) + Math.pow(o.g - l.g, 2) + Math.pow(o.b - l.b, 2));
          g < h && (h = g, d = p);
        }
        return d;
      }
    }, e.string.push([
      function(s) {
        var o = s.toLowerCase(), l = o === "transparent" ? "#0000" : t[o];
        return l ? new n(l).toRgb() : null;
      },
      "name"
    ]);
  }
  Sdt([
    Cdt
  ]);
  const im = class Ky {
    constructor(e = 16777215) {
      this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e;
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(e) {
      return this.value = e, this;
    }
    set value(e) {
      if (e instanceof Ky) this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components);
      else {
        if (e === null) throw new Error("Cannot set Color#value to null");
        (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value));
      }
    }
    get value() {
      return this._value;
    }
    _cloneSource(e) {
      return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? {
        ...e
      } : e;
    }
    _isSourceEqual(e, t) {
      const r = typeof e;
      if (r !== typeof t) return false;
      if (r === "number" || r === "string" || e instanceof Number) return e === t;
      if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) return e.length !== t.length ? false : e.every((a, s) => a === t[s]);
      if (e !== null && t !== null) {
        const a = Object.keys(e), s = Object.keys(t);
        return a.length !== s.length ? false : a.every((o) => e[o] === t[o]);
      }
      return e === t;
    }
    toRgba() {
      const [e, t, r, i] = this._components;
      return {
        r: e,
        g: t,
        b: r,
        a: i
      };
    }
    toRgb() {
      const [e, t, r] = this._components;
      return {
        r: e,
        g: t,
        b: r
      };
    }
    toRgbaString() {
      const [e, t, r] = this.toUint8RgbArray();
      return `rgba(${e},${t},${r},${this.alpha})`;
    }
    toUint8RgbArray(e) {
      const [t, r, i] = this._components;
      return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(t * 255), e[1] = Math.round(r * 255), e[2] = Math.round(i * 255), e;
    }
    toArray(e) {
      this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
      const [t, r, i, a] = this._components;
      return e[0] = t, e[1] = r, e[2] = i, e[3] = a, e;
    }
    toRgbArray(e) {
      this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
      const [t, r, i] = this._components;
      return e[0] = t, e[1] = r, e[2] = i, e;
    }
    toNumber() {
      return this._int;
    }
    toBgrNumber() {
      const [e, t, r] = this.toUint8RgbArray();
      return (r << 16) + (t << 8) + e;
    }
    toLittleEndianNumber() {
      const e = this._int;
      return (e >> 16) + (e & 65280) + ((e & 255) << 16);
    }
    multiply(e) {
      const [t, r, i, a] = Ky._temp.setValue(e)._components;
      return this._components[0] *= t, this._components[1] *= r, this._components[2] *= i, this._components[3] *= a, this._refreshInt(), this._value = null, this;
    }
    premultiply(e, t = true) {
      return t && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this;
    }
    toPremultiplied(e, t = true) {
      if (e === 1) return (255 << 24) + this._int;
      if (e === 0) return t ? 0 : this._int;
      let r = this._int >> 16 & 255, i = this._int >> 8 & 255, a = this._int & 255;
      return t && (r = r * e + 0.5 | 0, i = i * e + 0.5 | 0, a = a * e + 0.5 | 0), (e * 255 << 24) + (r << 16) + (i << 8) + a;
    }
    toHex() {
      const e = this._int.toString(16);
      return `#${"000000".substring(0, 6 - e.length) + e}`;
    }
    toHexa() {
      const t = Math.round(this._components[3] * 255).toString(16);
      return this.toHex() + "00".substring(0, 2 - t.length) + t;
    }
    setAlpha(e) {
      return this._components[3] = this._clamp(e), this;
    }
    _normalize(e) {
      let t, r, i, a;
      if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
        const s = e;
        t = (s >> 16 & 255) / 255, r = (s >> 8 & 255) / 255, i = (s & 255) / 255, a = 1;
      } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [t, r, i, a = 1] = e;
      else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [t, r, i, a = 255] = e, t /= 255, r /= 255, i /= 255, a /= 255;
      else if (typeof e == "string" || typeof e == "object") {
        if (typeof e == "string") {
          const o = Ky.HEX_PATTERN.exec(e);
          o && (e = `#${o[2]}`);
        }
        const s = Ao(e);
        s.isValid() && ({ r: t, g: r, b: i, a } = s.rgba, t /= 255, r /= 255, i /= 255);
      }
      if (t !== void 0) this._components[0] = t, this._components[1] = r, this._components[2] = i, this._components[3] = a, this._refreshInt();
      else throw new Error(`Unable to convert color ${e}`);
    }
    _refreshInt() {
      this._clamp(this._components);
      const [e, t, r] = this._components;
      this._int = (e * 255 << 16) + (t * 255 << 8) + (r * 255 | 0);
    }
    _clamp(e, t = 0, r = 1) {
      return typeof e == "number" ? Math.min(Math.max(e, t), r) : (e.forEach((i, a) => {
        e[a] = Math.min(Math.max(i, t), r);
      }), e);
    }
    static isColorLike(e) {
      return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof Ky || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0;
    }
  };
  im.shared = new im();
  im._temp = new im();
  im.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  Ei = im;
  const Idt = {
    cullArea: null,
    cullable: false,
    cullableChildren: true
  };
  class VL {
    constructor(e, t) {
      this._pool = [], this._count = 0, this._index = 0, this._classType = e, t && this.prepopulate(t);
    }
    prepopulate(e) {
      for (let t = 0; t < e; t++) this._pool[this._index++] = new this._classType();
      this._count += e;
    }
    get(e) {
      var _a2;
      let t;
      return this._index > 0 ? t = this._pool[--this._index] : t = new this._classType(), (_a2 = t.init) == null ? void 0 : _a2.call(t, e), t;
    }
    return(e) {
      var _a2;
      (_a2 = e.reset) == null ? void 0 : _a2.call(e), this._pool[this._index++] = e;
    }
    get totalSize() {
      return this._count;
    }
    get totalFree() {
      return this._index;
    }
    get totalUsed() {
      return this._count - this._index;
    }
    clear() {
      this._pool.length = 0, this._index = 0;
    }
  }
  class kdt {
    constructor() {
      this._poolsByClass = /* @__PURE__ */ new Map();
    }
    prepopulate(e, t) {
      this.getPool(e).prepopulate(t);
    }
    get(e, t) {
      return this.getPool(e).get(t);
    }
    return(e) {
      this.getPool(e.constructor).return(e);
    }
    getPool(e) {
      return this._poolsByClass.has(e) || this._poolsByClass.set(e, new VL(e)), this._poolsByClass.get(e);
    }
    stats() {
      const e = {};
      return this._poolsByClass.forEach((t) => {
        const r = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name;
        e[r] = {
          free: t.totalFree,
          used: t.totalUsed,
          size: t.totalSize
        };
      }), e;
    }
  }
  let Tdt;
  Wl = new kdt();
  Tdt = {
    get isCachedAsTexture() {
      var _a2;
      return !!((_a2 = this.renderGroup) == null ? void 0 : _a2.isCachedAsTexture);
    },
    cacheAsTexture(n) {
      typeof n == "boolean" && n === false ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(n === true ? {} : n));
    },
    updateCacheTexture() {
      var _a2;
      (_a2 = this.renderGroup) == null ? void 0 : _a2.updateCacheTexture();
    },
    get cacheAsBitmap() {
      return this.isCachedAsTexture;
    },
    set cacheAsBitmap(n) {
      Gn("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(n);
    }
  };
  Adt = function(n, e, t) {
    const r = n.length;
    let i;
    if (e >= r || t === 0) return;
    t = e + t > r ? r - e : t;
    const a = r - t;
    for (i = e; i < a; ++i) n[i] = n[i + t];
    n.length = a;
  };
  const Ddt = {
    allowChildren: true,
    removeChildren(n = 0, e) {
      const t = e ?? this.children.length, r = t - n, i = [];
      if (r > 0 && r <= t) {
        for (let s = t - 1; s >= n; s--) {
          const o = this.children[s];
          o && (i.push(o), o.parent = null);
        }
        Adt(this.children, n, t);
        const a = this.renderGroup || this.parentRenderGroup;
        a && a.removeChildren(i);
        for (let s = 0; s < i.length; ++s) this.emit("childRemoved", i[s], this, s), i[s].emit("removed", this);
        return i.length > 0 && this._didViewChangeTick++, i;
      } else if (r === 0 && this.children.length === 0) return i;
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    },
    removeChildAt(n) {
      const e = this.getChildAt(n);
      return this.removeChild(e);
    },
    getChildAt(n) {
      if (n < 0 || n >= this.children.length) throw new Error(`getChildAt: Index (${n}) does not exist.`);
      return this.children[n];
    },
    setChildIndex(n, e) {
      if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
      this.getChildIndex(n), this.addChildAt(n, e);
    },
    getChildIndex(n) {
      const e = this.children.indexOf(n);
      if (e === -1) throw new Error("The supplied Container must be a child of the caller");
      return e;
    },
    addChildAt(n, e) {
      this.allowChildren || Gn(or, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
      const { children: t } = this;
      if (e < 0 || e > t.length) throw new Error(`${n}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);
      if (n.parent) {
        const i = n.parent.children.indexOf(n);
        if (n.parent === this && i === e) return n;
        i !== -1 && n.parent.children.splice(i, 1);
      }
      e === t.length ? t.push(n) : t.splice(e, 0, n), n.parent = this, n.didChange = true, n._updateFlags = 15;
      const r = this.renderGroup || this.parentRenderGroup;
      return r && r.addChild(n), this.sortableChildren && (this.sortDirty = true), this.emit("childAdded", n, this, e), n.emit("added", this), n;
    },
    swapChildren(n, e) {
      if (n === e) return;
      const t = this.getChildIndex(n), r = this.getChildIndex(e);
      this.children[t] = e, this.children[r] = n;
      const i = this.renderGroup || this.parentRenderGroup;
      i && (i.structureDidChange = true), this._didContainerChangeTick++;
    },
    removeFromParent() {
      var _a2;
      (_a2 = this.parent) == null ? void 0 : _a2.removeChild(this);
    },
    reparentChild(...n) {
      return n.length === 1 ? this.reparentChildAt(n[0], this.children.length) : (n.forEach((e) => this.reparentChildAt(e, this.children.length)), n[0]);
    },
    reparentChildAt(n, e) {
      if (n.parent === this) return this.setChildIndex(n, e), n;
      const t = n.worldTransform.clone();
      n.removeFromParent(), this.addChildAt(n, e);
      const r = this.worldTransform.clone();
      return r.invert(), t.prepend(r), n.setFromMatrix(t), n;
    }
  }, Rdt = {
    collectRenderables(n, e, t) {
      this.parentRenderLayer && this.parentRenderLayer !== t || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(n, e, t) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, n) : this.collectRenderablesWithEffects(n, e, t));
    },
    collectRenderablesSimple(n, e, t) {
      const r = this.children, i = r.length;
      for (let a = 0; a < i; a++) r[a].collectRenderables(n, e, t);
    },
    collectRenderablesWithEffects(n, e, t) {
      const { renderPipes: r } = e;
      for (let i = 0; i < this.effects.length; i++) {
        const a = this.effects[i];
        r[a.pipe].push(a, this, n);
      }
      this.collectRenderablesSimple(n, e, t);
      for (let i = this.effects.length - 1; i >= 0; i--) {
        const a = this.effects[i];
        r[a.pipe].pop(a, this, n);
      }
    }
  };
  kH = class {
    constructor() {
      this.pipe = "filter", this.priority = 1;
    }
    destroy() {
      for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy();
      this.filters = null, this.filterArea = null;
    }
  };
  class $dt {
    constructor() {
      this._effectClasses = [], this._tests = [], this._initialized = false;
    }
    init() {
      this._initialized || (this._initialized = true, this._effectClasses.forEach((e) => {
        this.add({
          test: e.test,
          maskClass: e
        });
      }));
    }
    add(e) {
      this._tests.push(e);
    }
    getMaskEffect(e) {
      this._initialized || this.init();
      for (let t = 0; t < this._tests.length; t++) {
        const r = this._tests[t];
        if (r.test(e)) return Wl.get(r.maskClass, e);
      }
      return e;
    }
    returnMaskEffect(e) {
      Wl.return(e);
    }
  }
  const Z$ = new $dt();
  $s.handleByList(Nn.MaskEffect, Z$._effectClasses);
  const Ndt = {
    _maskEffect: null,
    _maskOptions: {
      inverse: false
    },
    _filterEffect: null,
    effects: [],
    _markStructureAsChanged() {
      const n = this.renderGroup || this.parentRenderGroup;
      n && (n.structureDidChange = true);
    },
    addEffect(n) {
      this.effects.indexOf(n) === -1 && (this.effects.push(n), this.effects.sort((t, r) => t.priority - r.priority), this._markStructureAsChanged(), this._updateIsSimple());
    },
    removeEffect(n) {
      const e = this.effects.indexOf(n);
      e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple());
    },
    set mask(n) {
      const e = this._maskEffect;
      (e == null ? void 0 : e.mask) !== n && (e && (this.removeEffect(e), Z$.returnMaskEffect(e), this._maskEffect = null), n != null && (this._maskEffect = Z$.getMaskEffect(n), this.addEffect(this._maskEffect)));
    },
    setMask(n) {
      this._maskOptions = {
        ...this._maskOptions,
        ...n
      }, n.mask && (this.mask = n.mask), this._markStructureAsChanged();
    },
    get mask() {
      var _a2;
      return (_a2 = this._maskEffect) == null ? void 0 : _a2.mask;
    },
    set filters(n) {
      var _a2;
      !Array.isArray(n) && n && (n = [
        n
      ]);
      const e = this._filterEffect || (this._filterEffect = new kH());
      n = n;
      const t = (n == null ? void 0 : n.length) > 0, r = ((_a2 = e.filters) == null ? void 0 : _a2.length) > 0, i = t !== r;
      n = Array.isArray(n) ? n.slice(0) : n, e.filters = Object.freeze(n), i && (t ? this.addEffect(e) : (this.removeEffect(e), e.filters = n ?? null));
    },
    get filters() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filters;
    },
    set filterArea(n) {
      this._filterEffect || (this._filterEffect = new kH()), this._filterEffect.filterArea = n;
    },
    get filterArea() {
      var _a2;
      return (_a2 = this._filterEffect) == null ? void 0 : _a2.filterArea;
    }
  }, Edt = {
    label: null,
    get name() {
      return Gn(or, "Container.name property has been removed, use Container.label instead"), this.label;
    },
    set name(n) {
      Gn(or, "Container.name property has been removed, use Container.label instead"), this.label = n;
    },
    getChildByName(n, e = false) {
      return this.getChildByLabel(n, e);
    },
    getChildByLabel(n, e = false) {
      const t = this.children;
      for (let r = 0; r < t.length; r++) {
        const i = t[r];
        if (i.label === n || n instanceof RegExp && n.test(i.label)) return i;
      }
      if (e) for (let r = 0; r < t.length; r++) {
        const a = t[r].getChildByLabel(n, true);
        if (a) return a;
      }
      return null;
    },
    getChildrenByLabel(n, e = false, t = []) {
      const r = this.children;
      for (let i = 0; i < r.length; i++) {
        const a = r[i];
        (a.label === n || n instanceof RegExp && n.test(a.label)) && t.push(a);
      }
      if (e) for (let i = 0; i < r.length; i++) r[i].getChildrenByLabel(n, true, t);
      return t;
    }
  }, ji = new VL(pn), Gl = new VL(co), Mdt = new pn(), Pdt = {
    getFastGlobalBounds(n, e) {
      e || (e = new co()), e.clear(), this._getGlobalBoundsRecursive(!!n, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0);
      const t = this.renderGroup || this.parentRenderGroup;
      return e.applyMatrix(t.worldTransform), e;
    },
    _getGlobalBoundsRecursive(n, e, t) {
      let r = e;
      if (n && this.parentRenderLayer && this.parentRenderLayer !== t || this.localDisplayStatus !== 7 || !this.measurable) return;
      const i = !!this.effects.length;
      if ((this.renderGroup || i) && (r = Gl.get().clear()), this.boundsArea) e.addRect(this.boundsArea, this.worldTransform);
      else {
        if (this.renderPipeId) {
          const s = this.bounds;
          r.addFrame(s.minX, s.minY, s.maxX, s.maxY, this.groupTransform);
        }
        const a = this.children;
        for (let s = 0; s < a.length; s++) a[s]._getGlobalBoundsRecursive(n, r, t);
      }
      if (i) {
        let a = false;
        const s = this.renderGroup || this.parentRenderGroup;
        for (let o = 0; o < this.effects.length; o++) this.effects[o].addBounds && (a || (a = true, r.applyMatrix(s.worldTransform)), this.effects[o].addBounds(r, true));
        a && (r.applyMatrix(s.worldTransform.copyTo(Mdt).invert()), e.addBounds(r, this.relativeGroupTransform)), e.addBounds(r), Gl.return(r);
      } else this.renderGroup && (e.addBounds(r, this.relativeGroupTransform), Gl.return(r));
    }
  };
  eie = function(n, e, t) {
    t.clear();
    let r, i;
    return n.parent ? e ? r = n.parent.worldTransform : (i = ji.get().identity(), r = WL(n, i)) : r = pn.IDENTITY, tie(n, t, r, e), i && ji.return(i), t.isValid || t.set(0, 0, 0, 0), t;
  };
  function tie(n, e, t, r) {
    var _a2, _b2;
    if (!n.visible || !n.measurable) return;
    let i;
    r ? i = n.worldTransform : (n.updateLocalTransform(), i = ji.get(), i.appendFrom(n.localTransform, t));
    const a = e, s = !!n.effects.length;
    if (s && (e = Gl.get().clear()), n.boundsArea) e.addRect(n.boundsArea, i);
    else {
      n.bounds && (e.matrix = i, e.addBounds(n.bounds));
      for (let o = 0; o < n.children.length; o++) tie(n.children[o], e, i, r);
    }
    if (s) {
      for (let o = 0; o < n.effects.length; o++) (_b2 = (_a2 = n.effects[o]).addBounds) == null ? void 0 : _b2.call(_a2, e);
      a.addBounds(e, pn.IDENTITY), Gl.return(e);
    }
    r || ji.return(i);
  }
  function WL(n, e) {
    const t = n.parent;
    return t && (WL(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e;
  }
  function nie(n, e) {
    if (n === 16777215 || !e) return e;
    if (e === 16777215 || !n) return n;
    const t = n >> 16 & 255, r = n >> 8 & 255, i = n & 255, a = e >> 16 & 255, s = e >> 8 & 255, o = e & 255, l = t * a / 255 | 0, u = r * s / 255 | 0, c = i * o / 255 | 0;
    return (l << 16) + (u << 8) + c;
  }
  const TH = 16777215;
  AH = function(n, e) {
    return n === TH ? e : e === TH ? n : nie(n, e);
  };
  function k_(n) {
    return ((n & 255) << 16) + (n & 65280) + (n >> 16 & 255);
  }
  const Ldt = {
    getGlobalAlpha(n) {
      if (n) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
      let e = this.alpha, t = this.parent;
      for (; t; ) e *= t.alpha, t = t.parent;
      return e;
    },
    getGlobalTransform(n, e) {
      if (e) return n.copyFrom(this.worldTransform);
      this.updateLocalTransform();
      const t = WL(this, ji.get().identity());
      return n.appendFrom(this.localTransform, t), ji.return(t), n;
    },
    getGlobalTint(n) {
      if (n) return this.renderGroup ? k_(this.renderGroup.worldColor) : this.parentRenderGroup ? k_(AH(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
      let e = this.localColor, t = this.parent;
      for (; t; ) e = AH(e, t.localColor), t = t.parent;
      return k_(e);
    }
  };
  let EA = 0;
  const DH = 500;
  Ua = function(...n) {
    EA !== DH && (EA++, EA === DH ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...n));
  };
  rie = function(n, e, t) {
    return e.clear(), t || (t = pn.IDENTITY), iie(n, e, t, n, true), e.isValid || e.set(0, 0, 0, 0), e;
  };
  function iie(n, e, t, r, i) {
    var _a2, _b2;
    let a;
    if (i) a = ji.get(), a = t.copyTo(a);
    else {
      if (!n.visible || !n.measurable) return;
      n.updateLocalTransform();
      const l = n.localTransform;
      a = ji.get(), a.appendFrom(l, t);
    }
    const s = e, o = !!n.effects.length;
    if (o && (e = Gl.get().clear()), n.boundsArea) e.addRect(n.boundsArea, a);
    else {
      n.renderPipeId && (e.matrix = a, e.addBounds(n.bounds));
      const l = n.children;
      for (let u = 0; u < l.length; u++) iie(l[u], e, a, r, false);
    }
    if (o) {
      for (let l = 0; l < n.effects.length; l++) (_b2 = (_a2 = n.effects[l]).addLocalBounds) == null ? void 0 : _b2.call(_a2, e, r);
      s.addBounds(e, pn.IDENTITY), Gl.return(e);
    }
    ji.return(a);
  }
  function aie(n, e) {
    const t = n.children;
    for (let r = 0; r < t.length; r++) {
      const i = t[r], a = i.uid, s = (i._didViewChangeTick & 65535) << 16 | i._didContainerChangeTick & 65535, o = e.index;
      (e.data[o] !== a || e.data[o + 1] !== s) && (e.data[e.index] = a, e.data[e.index + 1] = s, e.didChange = true), e.index = o + 2, i.children.length && aie(i, e);
    }
    return e.didChange;
  }
  const Fdt = new pn(), Odt = {
    _localBoundsCacheId: -1,
    _localBoundsCacheData: null,
    _setWidth(n, e) {
      const t = Math.sign(this.scale.x) || 1;
      e !== 0 ? this.scale.x = n / e * t : this.scale.x = t;
    },
    _setHeight(n, e) {
      const t = Math.sign(this.scale.y) || 1;
      e !== 0 ? this.scale.y = n / e * t : this.scale.y = t;
    },
    getLocalBounds() {
      this._localBoundsCacheData || (this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new co()
      });
      const n = this._localBoundsCacheData;
      return n.index = 1, n.didChange = false, n.data[0] !== this._didViewChangeTick && (n.didChange = true, n.data[0] = this._didViewChangeTick), aie(this, n), n.didChange && rie(this, n.localBounds, Fdt), n.localBounds;
    },
    getBounds(n, e) {
      return eie(this, n, e || new co());
    }
  }, Bdt = {
    _onRender: null,
    set onRender(n) {
      const e = this.renderGroup || this.parentRenderGroup;
      if (!n) {
        this._onRender && (e == null ? void 0 : e.removeOnRender(this)), this._onRender = null;
        return;
      }
      this._onRender || (e == null ? void 0 : e.addOnRender(this)), this._onRender = n;
    },
    get onRender() {
      return this._onRender;
    }
  }, zdt = {
    _zIndex: 0,
    sortDirty: false,
    sortableChildren: false,
    get zIndex() {
      return this._zIndex;
    },
    set zIndex(n) {
      this._zIndex !== n && (this._zIndex = n, this.depthOfChildModified());
    },
    depthOfChildModified() {
      this.parent && (this.parent.sortableChildren = true, this.parent.sortDirty = true), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true);
    },
    sortChildren() {
      this.sortDirty && (this.sortDirty = false, this.children.sort(Vdt));
    }
  };
  function Vdt(n, e) {
    return n._zIndex - e._zIndex;
  }
  const Wdt = {
    getGlobalPosition(n = new Ri(), e = false) {
      return this.parent ? this.parent.toGlobal(this._position, n, e) : (n.x = this._position.x, n.y = this._position.y), n;
    },
    toGlobal(n, e, t = false) {
      const r = this.getGlobalTransform(ji.get(), t);
      return e = r.apply(n, e), ji.return(r), e;
    },
    toLocal(n, e, t, r) {
      e && (n = e.toGlobal(n, t, r));
      const i = this.getGlobalTransform(ji.get(), r);
      return t = i.applyInverse(n, t), ji.return(i), t;
    }
  };
  class sie {
    constructor() {
      this.uid = Dr("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
    }
    reset() {
      this.instructionSize = 0;
    }
    add(e) {
      this.instructions[this.instructionSize++] = e;
    }
    log() {
      this.instructions.length = this.instructionSize, console.table(this.instructions, [
        "type",
        "action"
      ]);
    }
  }
  let Gdt = 0;
  class Udt {
    constructor(e) {
      this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = false;
    }
    createTexture(e, t, r) {
      const i = new mo({
        ...this.textureOptions,
        width: e,
        height: t,
        resolution: 1,
        antialias: r,
        autoGarbageCollect: false
      });
      return new Fn({
        source: i,
        label: `texturePool_${Gdt++}`
      });
    }
    getOptimalTexture(e, t, r = 1, i) {
      let a = Math.ceil(e * r - 1e-6), s = Math.ceil(t * r - 1e-6);
      a = pH(a), s = pH(s);
      const o = (a << 17) + (s << 1) + (i ? 1 : 0);
      this._texturePool[o] || (this._texturePool[o] = []);
      let l = this._texturePool[o].pop();
      return l || (l = this.createTexture(a, s, i)), l.source._resolution = r, l.source.width = a / r, l.source.height = s / r, l.source.pixelWidth = a, l.source.pixelHeight = s, l.frame.x = 0, l.frame.y = 0, l.frame.width = e, l.frame.height = t, l.updateUvs(), this._poolKeyHash[l.uid] = o, l;
    }
    getSameSizeTexture(e, t = false) {
      const r = e.source;
      return this.getOptimalTexture(e.width, e.height, r._resolution, t);
    }
    returnTexture(e) {
      const t = this._poolKeyHash[e.uid];
      this._texturePool[t].push(e);
    }
    clear(e) {
      if (e = e !== false, e) for (const t in this._texturePool) {
        const r = this._texturePool[t];
        if (r) for (let i = 0; i < r.length; i++) r[i].destroy(true);
      }
      this._texturePool = {};
    }
  }
  Hdt = new Udt();
  class Xdt {
    constructor() {
      this.renderPipeId = "renderGroup", this.root = null, this.canBundle = false, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new pn(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
        list: [],
        index: 0
      }, this.structureDidChange = true, this.instructionSet = new sie(), this._onRenderContainers = [], this.textureNeedsUpdate = true, this.isCachedAsTexture = false, this._matrixDirty = 7;
    }
    init(e) {
      this.root = e, e._onRender && this.addOnRender(e), e.didChange = true;
      const t = e.children;
      for (let r = 0; r < t.length; r++) {
        const i = t[r];
        i._updateFlags = 15, this.addChild(i);
      }
    }
    enableCacheAsTexture(e = {}) {
      this.textureOptions = e, this.isCachedAsTexture = true, this.textureNeedsUpdate = true;
    }
    disableCacheAsTexture() {
      this.isCachedAsTexture = false, this.texture && (Hdt.returnTexture(this.texture), this.texture = null);
    }
    updateCacheTexture() {
      this.textureNeedsUpdate = true;
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const e in this.childrenToUpdate) {
        const t = this.childrenToUpdate[e];
        t.list.fill(null), t.index = 0;
      }
      this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = true, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(e) {
      e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e);
    }
    _removeRenderGroupChild(e) {
      const t = this.renderGroupChildren.indexOf(e);
      t > -1 && this.renderGroupChildren.splice(t, 1), e.renderGroupParent = null;
    }
    addChild(e) {
      if (this.structureDidChange = true, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = true, this.onChildUpdate(e), e.renderGroup) {
        this.addRenderGroupChild(e.renderGroup);
        return;
      }
      e._onRender && this.addOnRender(e);
      const t = e.children;
      for (let r = 0; r < t.length; r++) this.addChild(t[r]);
    }
    removeChild(e) {
      if (this.structureDidChange = true, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) {
        this._removeRenderGroupChild(e.renderGroup);
        return;
      }
      const t = e.children;
      for (let r = 0; r < t.length; r++) this.removeChild(t[r]);
    }
    removeChildren(e) {
      for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
    }
    onChildUpdate(e) {
      let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
      t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      }), t.list[t.index++] = e;
    }
    updateRenderable(e) {
      e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = false);
    }
    onChildViewUpdate(e) {
      this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e;
    }
    get isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(e) {
      this._onRenderContainers.push(e);
    }
    removeOnRender(e) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
    }
    runOnRender(e) {
      for (let t = 0; t < this._onRenderContainers.length; t++) this._onRenderContainers[t]._onRender(e);
    }
    destroy() {
      this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
    }
    getChildren(e = []) {
      const t = this.root.children;
      for (let r = 0; r < t.length; r++) this._getChildren(t[r], e);
      return e;
    }
    _getChildren(e, t = []) {
      if (t.push(e), e.renderGroup) return t;
      const r = e.children;
      for (let i = 0; i < r.length; i++) this._getChildren(r[i], t);
      return t;
    }
    invalidateMatrices() {
      this._matrixDirty = 7;
    }
    get inverseWorldTransform() {
      return this._matrixDirty & 1 ? (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new pn()), this._inverseWorldTransform.copyFrom(this.worldTransform).invert()) : this._inverseWorldTransform;
    }
    get textureOffsetInverseTransform() {
      return this._matrixDirty & 2 ? (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new pn()), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y)) : this._textureOffsetInverseTransform;
    }
    get inverseParentTextureTransform() {
      if (!(this._matrixDirty & 4)) return this._inverseParentTextureTransform;
      this._matrixDirty &= -5;
      const e = this._parentCacheAsTextureRenderGroup;
      return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new pn()), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform;
    }
    get cacheToLocalTransform() {
      return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
    }
  }
  function Ydt(n, e, t = {}) {
    for (const r in e) !t[r] && e[r] !== void 0 && (n[r] = e[r]);
  }
  let MA, PA, LA;
  MA = new ma(null);
  PA = new ma(null);
  LA = new ma(null, 1, 1);
  RH = 1;
  qdt = 2;
  FA = 4;
  yp = class extends fl {
    constructor(e = {}) {
      var _a2, _b2;
      super(), this.uid = Dr("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = false, this.didViewUpdate = false, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = true, this.measurable = true, this.isSimple = true, this.updateTick = -1, this.localTransform = new pn(), this.relativeGroupTransform = new pn(), this.groupTransform = this.relativeGroupTransform, this.destroyed = false, this._position = new ma(this, 0, 0), this._scale = LA, this._pivot = PA, this._skew = MA, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], Ydt(this, e, {
        children: true,
        parent: true,
        effects: true
      }), (_a2 = e.children) == null ? void 0 : _a2.forEach((t) => this.addChild(t)), (_b2 = e.parent) == null ? void 0 : _b2.addChild(this);
    }
    static mixin(e) {
      Gn("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), $s.mixin(yp, e);
    }
    set _didChangeId(e) {
      this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095;
    }
    get _didChangeId() {
      return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
    }
    addChild(...e) {
      if (this.allowChildren || Gn(or, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) {
        for (let i = 0; i < e.length; i++) this.addChild(e[i]);
        return e[0];
      }
      const t = e[0], r = this.renderGroup || this.parentRenderGroup;
      return t.parent === this ? (this.children.splice(this.children.indexOf(t), 1), this.children.push(t), r && (r.structureDidChange = true), t) : (t.parent && t.parent.removeChild(t), this.children.push(t), this.sortableChildren && (this.sortDirty = true), t.parent = this, t.didChange = true, t._updateFlags = 15, r && r.addChild(t), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this), this._didViewChangeTick++, t._zIndex !== 0 && t.depthOfChildModified(), t);
    }
    removeChild(...e) {
      if (e.length > 1) {
        for (let i = 0; i < e.length; i++) this.removeChild(e[i]);
        return e[0];
      }
      const t = e[0], r = this.children.indexOf(t);
      return r > -1 && (this._didViewChangeTick++, this.children.splice(r, 1), this.renderGroup ? this.renderGroup.removeChild(t) : this.parentRenderGroup && this.parentRenderGroup.removeChild(t), t.parentRenderLayer && t.parentRenderLayer.detach(t), t.parent = null, this.emit("childRemoved", t, this, r), t.emit("removed", this)), t;
    }
    _onUpdate(e) {
      e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = true, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
    }
    set isRenderGroup(e) {
      !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup());
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup) return;
      const e = this.parentRenderGroup;
      e == null ? void 0 : e.removeChild(this), this.renderGroup = Wl.get(Xdt, this), this.groupTransform = pn.IDENTITY, e == null ? void 0 : e.addChild(this), this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup) return;
      const e = this.parentRenderGroup;
      e == null ? void 0 : e.removeChild(this), Wl.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e == null ? void 0 : e.addChild(this), this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      return this._worldTransform || (this._worldTransform = new pn()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
    }
    get x() {
      return this._position.x;
    }
    set x(e) {
      this._position.x = e;
    }
    get y() {
      return this._position.y;
    }
    set y(e) {
      this._position.y = e;
    }
    get position() {
      return this._position;
    }
    set position(e) {
      this._position.copyFrom(e);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(e) {
      this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew));
    }
    get angle() {
      return this.rotation * sdt;
    }
    set angle(e) {
      this.rotation = e * odt;
    }
    get pivot() {
      return this._pivot === PA && (this._pivot = new ma(this, 0, 0)), this._pivot;
    }
    set pivot(e) {
      this._pivot === PA && (this._pivot = new ma(this, 0, 0)), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e);
    }
    get skew() {
      return this._skew === MA && (this._skew = new ma(this, 0, 0)), this._skew;
    }
    set skew(e) {
      this._skew === MA && (this._skew = new ma(this, 0, 0)), this._skew.copyFrom(e);
    }
    get scale() {
      return this._scale === LA && (this._scale = new ma(this, 1, 1)), this._scale;
    }
    set scale(e) {
      this._scale === LA && (this._scale = new ma(this, 0, 0)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(e) {
      const t = this.getLocalBounds().width;
      this._setWidth(e, t);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(e) {
      const t = this.getLocalBounds().height;
      this._setHeight(e, t);
    }
    getSize(e) {
      e || (e = {});
      const t = this.getLocalBounds();
      return e.width = Math.abs(this.scale.x * t.width), e.height = Math.abs(this.scale.y * t.height), e;
    }
    setSize(e, t) {
      const r = this.getLocalBounds();
      typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, r.width), t !== void 0 && this._setHeight(t, r.height);
    }
    _updateSkew() {
      const e = this._rotation, t = this._skew;
      this._cx = Math.cos(e + t._y), this._sx = Math.sin(e + t._y), this._cy = -Math.sin(e - t._x), this._sy = Math.cos(e - t._x);
    }
    updateTransform(e) {
      return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y), this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y), this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y), this;
    }
    setFromMatrix(e) {
      e.decompose(this);
    }
    updateLocalTransform() {
      const e = this._didContainerChangeTick;
      if (this._didLocalTransformChangeId === e) return;
      this._didLocalTransformChangeId = e;
      const t = this.localTransform, r = this._scale, i = this._pivot, a = this._position, s = r._x, o = r._y, l = i._x, u = i._y;
      t.a = this._cx * s, t.b = this._sx * s, t.c = this._cy * o, t.d = this._sy * o, t.tx = a._x - (l * t.a + u * t.c), t.ty = a._y - (l * t.b + u * t.d);
    }
    set alpha(e) {
      e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= RH, this._onUpdate());
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(e) {
      const r = Ei.shared.setValue(e ?? 16777215).toBgrNumber();
      r !== this.localColor && (this.localColor = r, this._updateFlags |= RH, this._onUpdate());
    }
    get tint() {
      return k_(this.localColor);
    }
    set blendMode(e) {
      this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= qdt, this.localBlendMode = e, this._onUpdate());
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(e) {
      const t = e ? 2 : 0;
      (this.localDisplayStatus & 2) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= FA, this.localDisplayStatus ^= 2, this._onUpdate());
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(e) {
      const t = e ? 0 : 4;
      (this.localDisplayStatus & 4) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._updateFlags |= FA, this.localDisplayStatus ^= 4, this._onUpdate());
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(e) {
      const t = e ? 1 : 0;
      (this.localDisplayStatus & 1) !== t && (this._updateFlags |= FA, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = true), this._onUpdate());
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(e = false) {
      var _a2;
      if (this.destroyed) return;
      this.destroyed = true;
      let t;
      if (this.children.length && (t = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e == null ? void 0 : e.children) && t) for (let i = 0; i < t.length; ++i) t[i].destroy(e);
      (_a2 = this.renderGroup) == null ? void 0 : _a2.destroy(), this.renderGroup = null;
    }
  };
  $s.mixin(yp, Ddt, Pdt, Wdt, Bdt, Odt, Ndt, Edt, zdt, Idt, Tdt, Ldt, Rdt);
  class GL extends yp {
    constructor(e) {
      super(e), this.canBundle = true, this.allowChildren = false, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new co(0, 1, 0, 0), this._boundsDirty = true;
    }
    get bounds() {
      return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = false, this._bounds) : this._bounds;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(e) {
      this._roundPixels = e ? 1 : 0;
    }
    containsPoint(e) {
      const t = this.bounds, { x: r, y: i } = e;
      return r >= t.minX && r <= t.maxX && i >= t.minY && i <= t.maxY;
    }
    onViewUpdate() {
      if (this._didViewChangeTick++, this._boundsDirty = true, this.didViewUpdate) return;
      this.didViewUpdate = true;
      const e = this.renderGroup || this.parentRenderGroup;
      e && e.onChildViewUpdate(this);
    }
    destroy(e) {
      super.destroy(e), this._bounds = null;
    }
    collectRenderablesSimple(e, t, r) {
      const { renderPipes: i, renderableGC: a } = t;
      i.blendMode.setBlendMode(this, this.groupBlendMode, e), i[this.renderPipeId].addRenderable(this, e), a.addRenderable(this), this.didViewUpdate = false;
      const o = this.children, l = o.length;
      for (let u = 0; u < l; u++) o[u].collectRenderables(e, t, r);
    }
  }
  am = class extends GL {
    constructor(e = Fn.EMPTY) {
      e instanceof Fn && (e = {
        texture: e
      });
      const { texture: t = Fn.EMPTY, anchor: r, roundPixels: i, width: a, height: s, ...o } = e;
      super({
        label: "Sprite",
        ...o
      }), this.renderPipeId = "sprite", this.batched = true, this._visualBounds = {
        minX: 0,
        maxX: 1,
        minY: 0,
        maxY: 0
      }, this._anchor = new ma({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), r ? this.anchor = r : t.defaultAnchor && (this.anchor = t.defaultAnchor), this.texture = t, this.allowChildren = false, this.roundPixels = i ?? false, a !== void 0 && (this.width = a), s !== void 0 && (this.height = s);
    }
    static from(e, t = false) {
      return e instanceof Fn ? new am(e) : new am(Fn.from(e, t));
    }
    set texture(e) {
      e || (e = Fn.EMPTY);
      const t = this._texture;
      t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get visualBounds() {
      return gdt(this._visualBounds, this._anchor, this._texture), this._visualBounds;
    }
    get sourceBounds() {
      return Gn("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
    }
    updateBounds() {
      const e = this._anchor, t = this._texture, r = this._bounds, { width: i, height: a } = t.orig;
      r.minX = -e._x * i, r.maxX = r.minX + i, r.minY = -e._y * a, r.maxY = r.minY + a;
    }
    destroy(e = false) {
      if (super.destroy(e), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        this._texture.destroy(r);
      }
      this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(e) {
      this._setWidth(e, this._texture.orig.width), this._width = e;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(e) {
      this._setHeight(e, this._texture.orig.height), this._height = e;
    }
    getSize(e) {
      return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e;
    }
    setSize(e, t) {
      typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), t !== void 0 && this._setHeight(t, this._texture.orig.height);
    }
  };
  const jdt = new co();
  function oie(n, e, t) {
    const r = jdt;
    n.measurable = true, eie(n, t, r), e.addBoundsMask(r), n.measurable = false;
  }
  function lie(n, e, t) {
    const r = Gl.get();
    n.measurable = true;
    const i = ji.get().identity(), a = uie(n, t, i);
    rie(n, r, a), n.measurable = false, e.addBoundsMask(r), ji.return(i), Gl.return(r);
  }
  function uie(n, e, t) {
    return n ? (n !== e && (uie(n.parent, e, t), n.updateLocalTransform(), t.append(n.localTransform)), t) : (Ua("Mask bounds, renderable is not inside the root container"), t);
  }
  class cie {
    constructor(e) {
      this.priority = 0, this.inverse = false, this.pipe = "alphaMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e, this.renderMaskToTexture = !(e instanceof am), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask = null;
    }
    addBounds(e, t) {
      this.inverse || oie(this.mask, e, t);
    }
    addLocalBounds(e, t) {
      lie(this.mask, e, t);
    }
    containsPoint(e, t) {
      const r = this.mask;
      return t(r, e);
    }
    destroy() {
      this.reset();
    }
    static test(e) {
      return e instanceof am;
    }
  }
  cie.extension = Nn.MaskEffect;
  class hie {
    constructor(e) {
      this.priority = 0, this.pipe = "colorMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e;
    }
    destroy() {
    }
    static test(e) {
      return typeof e == "number";
    }
  }
  hie.extension = Nn.MaskEffect;
  class die {
    constructor(e) {
      this.priority = 0, this.pipe = "stencilMask", (e == null ? void 0 : e.mask) && this.init(e.mask);
    }
    init(e) {
      this.mask = e, this.mask.includeInBuild = false, this.mask.measurable = false;
    }
    reset() {
      this.mask.measurable = true, this.mask.includeInBuild = true, this.mask = null;
    }
    addBounds(e, t) {
      oie(this.mask, e, t);
    }
    addLocalBounds(e, t) {
      lie(this.mask, e, t);
    }
    containsPoint(e, t) {
      const r = this.mask;
      return t(r, e);
    }
    destroy() {
      this.reset();
    }
    static test(e) {
      return e instanceof yp;
    }
  }
  die.extension = Nn.MaskEffect;
  const Kdt = {
    createCanvas: (n, e) => {
      const t = document.createElement("canvas");
      return t.width = n, t.height = e, t;
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (n, e) => fetch(n, e),
    parseXML: (n) => new DOMParser().parseFromString(n, "text/xml")
  };
  let $H = Kdt;
  to = {
    get() {
      return $H;
    },
    set(n) {
      $H = n;
    }
  };
  fie = class extends mo {
    constructor(e) {
      e.resource || (e.resource = to.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent;
    }
    resizeCanvas() {
      this.autoDensity && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
    }
    resize(e = this.width, t = this.height, r = this._resolution) {
      const i = super.resize(e, t, r);
      return i && this.resizeCanvas(), i;
    }
    static test(e) {
      return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas;
    }
    get context2D() {
      return this._context2D || (this._context2D = this.resource.getContext("2d"));
    }
  };
  fie.extension = Nn.TextureSource;
  rC = class extends mo {
    constructor(e) {
      if (e.resource && globalThis.HTMLImageElement && e.resource instanceof HTMLImageElement) {
        const t = to.get().createCanvas(e.resource.width, e.resource.height);
        t.getContext("2d").drawImage(e.resource, 0, 0, e.resource.width, e.resource.height), e.resource = t, Ua("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
      }
      super(e), this.uploadMethodId = "image", this.autoGarbageCollect = true;
    }
    static test(e) {
      return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame;
    }
  };
  rC.extension = Nn.TextureSource;
  Q$ = ((n) => (n[n.INTERACTION = 50] = "INTERACTION", n[n.HIGH = 25] = "HIGH", n[n.NORMAL = 0] = "NORMAL", n[n.LOW = -25] = "LOW", n[n.UTILITY = -50] = "UTILITY", n))(Q$ || {});
  class OA {
    constructor(e, t = null, r = 0, i = false) {
      this.next = null, this.previous = null, this._destroyed = false, this._fn = e, this._context = t, this.priority = r, this._once = i;
    }
    match(e, t = null) {
      return this._fn === e && this._context === t;
    }
    emit(e) {
      this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
      const t = this.next;
      return this._once && this.destroy(true), this._destroyed && (this.next = null), t;
    }
    connect(e) {
      this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
    }
    destroy(e = false) {
      this._destroyed = true, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      const t = this.next;
      return this.next = e ? null : t, this.previous = null, t;
    }
  }
  const pie = class La {
    constructor() {
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new OA(null, null, 1 / 0), this.deltaMS = 1 / La.targetFPMS, this.elapsedMS = 1 / La.targetFPMS, this._tick = (e) => {
        this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
      };
    }
    _requestIfNeeded() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }
    _cancelIfNeeded() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(e, t, r = Q$.NORMAL) {
      return this._addListener(new OA(e, t, r));
    }
    addOnce(e, t, r = Q$.NORMAL) {
      return this._addListener(new OA(e, t, r, true));
    }
    _addListener(e) {
      let t = this._head.next, r = this._head;
      if (!t) e.connect(r);
      else {
        for (; t; ) {
          if (e.priority > t.priority) {
            e.connect(r);
            break;
          }
          r = t, t = t.next;
        }
        e.previous || e.connect(r);
      }
      return this._startIfPossible(), this;
    }
    remove(e, t) {
      let r = this._head.next;
      for (; r; ) r.match(e, t) ? r = r.destroy() : r = r.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) return 0;
      let e = 0, t = this._head;
      for (; t = t.next; ) e++;
      return e;
    }
    start() {
      this.started || (this.started = true, this._requestIfNeeded());
    }
    stop() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let e = this._head.next;
        for (; e; ) e = e.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }
    update(e = performance.now()) {
      let t;
      if (e > this.lastTime) {
        if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
          const a = e - this._lastFrame | 0;
          if (a < this._minElapsedMS) return;
          this._lastFrame = e - a % this._minElapsedMS;
        }
        this.deltaMS = t, this.deltaTime = this.deltaMS * La.targetFPMS;
        const r = this._head;
        let i = r.next;
        for (; i; ) i = i.emit(this);
        r.next || this._cancelIfNeeded();
      } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = e;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(e) {
      const t = Math.min(this.maxFPS, e), r = Math.min(Math.max(0, t) / 1e3, La.targetFPMS);
      this._maxElapsedMS = 1 / r;
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(e) {
      if (e === 0) this._minElapsedMS = 0;
      else {
        const t = Math.max(this.minFPS, e);
        this._minElapsedMS = 1 / (t / 1e3);
      }
    }
    static get shared() {
      if (!La._shared) {
        const e = La._shared = new La();
        e.autoStart = true, e._protected = true;
      }
      return La._shared;
    }
    static get system() {
      if (!La._system) {
        const e = La._system = new La();
        e.autoStart = true, e._protected = true;
      }
      return La._system;
    }
  };
  pie.targetFPMS = 0.06;
  let BA;
  $w = pie;
  async function Zdt() {
    return BA ?? (BA = (async () => {
      var _a2;
      const e = document.createElement("canvas").getContext("webgl");
      if (!e) return "premultiply-alpha-on-upload";
      const t = await new Promise((s) => {
        const o = document.createElement("video");
        o.onloadeddata = () => s(o), o.onerror = () => s(null), o.autoplay = false, o.crossOrigin = "anonymous", o.preload = "auto", o.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", o.load();
      });
      if (!t) return "premultiply-alpha-on-upload";
      const r = e.createTexture();
      e.bindTexture(e.TEXTURE_2D, r);
      const i = e.createFramebuffer();
      e.bindFramebuffer(e.FRAMEBUFFER, i), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
      const a = new Uint8Array(4);
      return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, a), e.deleteFramebuffer(i), e.deleteTexture(r), (_a2 = e.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), a[0] <= a[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
    })()), BA;
  }
  const g2 = class gie extends mo {
    constructor(e) {
      super(e), this.isReady = false, this.uploadMethodId = "video", e = {
        ...gie.defaultOptions,
        ...e
      }, this._autoUpdate = true, this._isConnectedToTicker = false, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== false, this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== false && this.load();
    }
    updateFrame() {
      if (!this.destroyed) {
        if (this._updateFPS) {
          const e = $w.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
        }
        (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) return this._load;
      const e = this.resource, t = this.options;
      return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = true), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (t.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, true)), this.alphaMode = await Zdt(), this._load = new Promise((r, i) => {
        this.isValid ? r(this) : (this._resolve = r, this._reject = i, t.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
          this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`));
        })), e.load());
      }), this._load;
    }
    _onError(e) {
      this.resource.removeEventListener("error", this._onError, true), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null);
    }
    _isSourcePlaying() {
      const e = this.resource;
      return !e.paused && !e.ended;
    }
    _isSourceReady() {
      return this.resource.readyState > 2;
    }
    _onPlayStart() {
      this.isValid || this._mediaReady(), this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
    }
    _onCanPlay() {
      this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
    }
    _onCanPlayThrough() {
      this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
    }
    _mediaReady() {
      const e = this.resource;
      this.isValid && (this.isReady = true, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
    }
    destroy() {
      this._configureAutoUpdate();
      const e = this.resource;
      e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, true), e.pause(), e.src = "", e.load()), super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(e) {
      e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && ($w.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || ($w.shared.add(this.updateFrame, this), this._isConnectedToTicker = true, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && ($w.shared.remove(this.updateFrame, this), this._isConnectedToTicker = false, this._msToNextUpdate = 0));
    }
    static test(e) {
      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
    }
  };
  g2.extension = Nn.TextureSource;
  g2.defaultOptions = {
    ...mo.defaultOptions,
    autoLoad: true,
    autoPlay: true,
    updateFPS: 0,
    crossorigin: true,
    loop: false,
    muted: true,
    playsinline: true,
    preload: false
  };
  g2.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  let Qdt = g2;
  const hg = (n, e, t = false) => (Array.isArray(n) || (n = [
    n
  ]), e ? n.map((r) => typeof r == "string" || t ? e(r) : r) : n);
  class Jdt {
    constructor() {
      this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
    }
    reset() {
      this._cacheMap.clear(), this._cache.clear();
    }
    has(e) {
      return this._cache.has(e);
    }
    get(e) {
      const t = this._cache.get(e);
      return t || Ua(`[Assets] Asset id ${e} was not found in the Cache`), t;
    }
    set(e, t) {
      const r = hg(e);
      let i;
      for (let l = 0; l < this.parsers.length; l++) {
        const u = this.parsers[l];
        if (u.test(t)) {
          i = u.getCacheableAssets(r, t);
          break;
        }
      }
      const a = new Map(Object.entries(i || {}));
      i || r.forEach((l) => {
        a.set(l, t);
      });
      const s = [
        ...a.keys()
      ], o = {
        cacheKeys: s,
        keys: r
      };
      r.forEach((l) => {
        this._cacheMap.set(l, o);
      }), s.forEach((l) => {
        const u = i ? i[l] : t;
        this._cache.has(l) && this._cache.get(l) !== u && Ua("[Cache] already has key:", l), this._cache.set(l, a.get(l));
      });
    }
    remove(e) {
      if (!this._cacheMap.has(e)) {
        Ua(`[Assets] Asset id ${e} was not found in the Cache`);
        return;
      }
      const t = this._cacheMap.get(e);
      t.cacheKeys.forEach((i) => {
        this._cache.delete(i);
      }), t.keys.forEach((i) => {
        this._cacheMap.delete(i);
      });
    }
    get parsers() {
      return this._parsers;
    }
  }
  let J$;
  dg = new Jdt();
  J$ = [];
  $s.handleByList(Nn.TextureSource, J$);
  function mie(n = {}) {
    const e = n && n.resource, t = e ? n.resource : n, r = e ? n : {
      resource: n
    };
    for (let i = 0; i < J$.length; i++) {
      const a = J$[i];
      if (a.test(t)) return new a(r);
    }
    throw new Error(`Could not find a source type for resource: ${r.resource}`);
  }
  function eft(n = {}, e = false) {
    const t = n && n.resource, r = t ? n.resource : n, i = t ? n : {
      resource: n
    };
    if (!e && dg.has(r)) return dg.get(r);
    const a = new Fn({
      source: mie(i)
    });
    return a.on("destroy", () => {
      dg.has(r) && dg.remove(r);
    }), e || dg.set(r, a), a;
  }
  function tft(n, e = false) {
    return typeof n == "string" ? dg.get(n) : n instanceof mo ? new Fn({
      source: n
    }) : eft(n, e);
  }
  Fn.from = tft;
  mo.from = mie;
  $s.add(cie, hie, die, Qdt, rC, fie, zL);
  var vie = ((n) => (n[n.Low = 0] = "Low", n[n.Normal = 1] = "Normal", n[n.High = 2] = "High", n))(vie || {});
  function Ls(n) {
    if (typeof n != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(n)}`);
  }
  function Sy(n) {
    return n.split("?")[0].split("#")[0];
  }
  function nft(n) {
    return n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function rft(n, e, t) {
    return n.replace(new RegExp(nft(e), "g"), t);
  }
  function ift(n, e) {
    let t = "", r = 0, i = -1, a = 0, s = -1;
    for (let o = 0; o <= n.length; ++o) {
      if (o < n.length) s = n.charCodeAt(o);
      else {
        if (s === 47) break;
        s = 47;
      }
      if (s === 47) {
        if (!(i === o - 1 || a === 1)) if (i !== o - 1 && a === 2) {
          if (t.length < 2 || r !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
            if (t.length > 2) {
              const l = t.lastIndexOf("/");
              if (l !== t.length - 1) {
                l === -1 ? (t = "", r = 0) : (t = t.slice(0, l), r = t.length - 1 - t.lastIndexOf("/")), i = o, a = 0;
                continue;
              }
            } else if (t.length === 2 || t.length === 1) {
              t = "", r = 0, i = o, a = 0;
              continue;
            }
          }
        } else t.length > 0 ? t += `/${n.slice(i + 1, o)}` : t = n.slice(i + 1, o), r = o - i - 1;
        i = o, a = 0;
      } else s === 46 && a !== -1 ? ++a : a = -1;
    }
    return t;
  }
  const bx = {
    toPosix(n) {
      return rft(n, "\\", "/");
    },
    isUrl(n) {
      return /^https?:/.test(this.toPosix(n));
    },
    isDataUrl(n) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(n);
    },
    isBlobUrl(n) {
      return n.startsWith("blob:");
    },
    hasProtocol(n) {
      return /^[^/:]+:/.test(this.toPosix(n));
    },
    getProtocol(n) {
      Ls(n), n = this.toPosix(n);
      const e = /^file:\/\/\//.exec(n);
      if (e) return e[0];
      const t = /^[^/:]+:\/{0,2}/.exec(n);
      return t ? t[0] : "";
    },
    toAbsolute(n, e, t) {
      if (Ls(n), this.isDataUrl(n) || this.isBlobUrl(n)) return n;
      const r = Sy(this.toPosix(e ?? to.get().getBaseUrl())), i = Sy(this.toPosix(t ?? this.rootname(r)));
      return n = this.toPosix(n), n.startsWith("/") ? bx.join(i, n.slice(1)) : this.isAbsolute(n) ? n : this.join(r, n);
    },
    normalize(n) {
      if (Ls(n), n.length === 0) return ".";
      if (this.isDataUrl(n) || this.isBlobUrl(n)) return n;
      n = this.toPosix(n);
      let e = "";
      const t = n.startsWith("/");
      this.hasProtocol(n) && (e = this.rootname(n), n = n.slice(e.length));
      const r = n.endsWith("/");
      return n = ift(n), n.length > 0 && r && (n += "/"), t ? `/${n}` : e + n;
    },
    isAbsolute(n) {
      return Ls(n), n = this.toPosix(n), this.hasProtocol(n) ? true : n.startsWith("/");
    },
    join(...n) {
      if (n.length === 0) return ".";
      let e;
      for (let t = 0; t < n.length; ++t) {
        const r = n[t];
        if (Ls(r), r.length > 0) if (e === void 0) e = r;
        else {
          const i = n[t - 1] ?? "";
          this.joinExtensions.includes(this.extname(i).toLowerCase()) ? e += `/../${r}` : e += `/${r}`;
        }
      }
      return e === void 0 ? "." : this.normalize(e);
    },
    dirname(n) {
      if (Ls(n), n.length === 0) return ".";
      n = this.toPosix(n);
      let e = n.charCodeAt(0);
      const t = e === 47;
      let r = -1, i = true;
      const a = this.getProtocol(n), s = n;
      n = n.slice(a.length);
      for (let o = n.length - 1; o >= 1; --o) if (e = n.charCodeAt(o), e === 47) {
        if (!i) {
          r = o;
          break;
        }
      } else i = false;
      return r === -1 ? t ? "/" : this.isUrl(s) ? a + n : a : t && r === 1 ? "//" : a + n.slice(0, r);
    },
    rootname(n) {
      Ls(n), n = this.toPosix(n);
      let e = "";
      if (n.startsWith("/") ? e = "/" : e = this.getProtocol(n), this.isUrl(n)) {
        const t = n.indexOf("/", e.length);
        t !== -1 ? e = n.slice(0, t) : e = n, e.endsWith("/") || (e += "/");
      }
      return e;
    },
    basename(n, e) {
      Ls(n), e && Ls(e), n = Sy(this.toPosix(n));
      let t = 0, r = -1, i = true, a;
      if (e !== void 0 && e.length > 0 && e.length <= n.length) {
        if (e.length === n.length && e === n) return "";
        let s = e.length - 1, o = -1;
        for (a = n.length - 1; a >= 0; --a) {
          const l = n.charCodeAt(a);
          if (l === 47) {
            if (!i) {
              t = a + 1;
              break;
            }
          } else o === -1 && (i = false, o = a + 1), s >= 0 && (l === e.charCodeAt(s) ? --s === -1 && (r = a) : (s = -1, r = o));
        }
        return t === r ? r = o : r === -1 && (r = n.length), n.slice(t, r);
      }
      for (a = n.length - 1; a >= 0; --a) if (n.charCodeAt(a) === 47) {
        if (!i) {
          t = a + 1;
          break;
        }
      } else r === -1 && (i = false, r = a + 1);
      return r === -1 ? "" : n.slice(t, r);
    },
    extname(n) {
      Ls(n), n = Sy(this.toPosix(n));
      let e = -1, t = 0, r = -1, i = true, a = 0;
      for (let s = n.length - 1; s >= 0; --s) {
        const o = n.charCodeAt(s);
        if (o === 47) {
          if (!i) {
            t = s + 1;
            break;
          }
          continue;
        }
        r === -1 && (i = false, r = s + 1), o === 46 ? e === -1 ? e = s : a !== 1 && (a = 1) : e !== -1 && (a = -1);
      }
      return e === -1 || r === -1 || a === 0 || a === 1 && e === r - 1 && e === t + 1 ? "" : n.slice(e, r);
    },
    parse(n) {
      Ls(n);
      const e = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (n.length === 0) return e;
      n = Sy(this.toPosix(n));
      let t = n.charCodeAt(0);
      const r = this.isAbsolute(n);
      let i;
      e.root = this.rootname(n), r || this.hasProtocol(n) ? i = 1 : i = 0;
      let a = -1, s = 0, o = -1, l = true, u = n.length - 1, c = 0;
      for (; u >= i; --u) {
        if (t = n.charCodeAt(u), t === 47) {
          if (!l) {
            s = u + 1;
            break;
          }
          continue;
        }
        o === -1 && (l = false, o = u + 1), t === 46 ? a === -1 ? a = u : c !== 1 && (c = 1) : a !== -1 && (c = -1);
      }
      return a === -1 || o === -1 || c === 0 || c === 1 && a === o - 1 && a === s + 1 ? o !== -1 && (s === 0 && r ? e.base = e.name = n.slice(1, o) : e.base = e.name = n.slice(s, o)) : (s === 0 && r ? (e.name = n.slice(1, a), e.base = n.slice(1, o)) : (e.name = n.slice(s, a), e.base = n.slice(s, o)), e.ext = n.slice(a, o)), e.dir = this.dirname(n), e;
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [
      ".html"
    ]
  };
  function yie(n, e, t, r, i) {
    const a = e[t];
    for (let s = 0; s < a.length; s++) {
      const o = a[s];
      t < e.length - 1 ? yie(n.replace(r[t], o), e, t + 1, r, i) : i.push(n.replace(r[t], o));
    }
  }
  function aft(n) {
    const e = /\{(.*?)\}/g, t = n.match(e), r = [];
    if (t) {
      const i = [];
      t.forEach((a) => {
        const s = a.substring(1, a.length - 1).split(",");
        i.push(s);
      }), yie(n, i, 0, t, r);
    } else r.push(n);
    return r;
  }
  const NH = (n) => !Array.isArray(n);
  class xie {
    constructor() {
      this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
        extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, "")
      }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
    }
    setBundleIdentifier(e) {
      if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
    prefer(...e) {
      e.forEach((t) => {
        this._preferredOrder.push(t), t.priority || (t.priority = Object.keys(t.params));
      }), this._resolverHash = {};
    }
    set basePath(e) {
      this._basePath = e;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(e) {
      this._rootPath = e;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
    }
    setDefaultSearchParams(e) {
      if (typeof e == "string") this._defaultSearchParams = e;
      else {
        const t = e;
        this._defaultSearchParams = Object.keys(t).map((r) => `${encodeURIComponent(r)}=${encodeURIComponent(t[r])}`).join("&");
      }
    }
    getAlias(e) {
      const { alias: t, src: r } = e;
      return hg(t || r, (a) => typeof a == "string" ? a : Array.isArray(a) ? a.map((s) => (s == null ? void 0 : s.src) ?? s) : (a == null ? void 0 : a.src) ? a.src : a, true);
    }
    addManifest(e) {
      this._manifest && Ua("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach((t) => {
        this.addBundle(t.name, t.assets);
      });
    }
    addBundle(e, t) {
      const r = [];
      let i = t;
      Array.isArray(t) || (i = Object.entries(t).map(([a, s]) => typeof s == "string" || Array.isArray(s) ? {
        alias: a,
        src: s
      } : {
        alias: a,
        ...s
      })), i.forEach((a) => {
        const s = a.src, o = a.alias;
        let l;
        if (typeof o == "string") {
          const u = this._createBundleAssetId(e, o);
          r.push(u), l = [
            o,
            u
          ];
        } else {
          const u = o.map((c) => this._createBundleAssetId(e, c));
          r.push(...u), l = [
            ...o,
            ...u
          ];
        }
        this.add({
          ...a,
          alias: l,
          src: s
        });
      }), this._bundles[e] = r;
    }
    add(e) {
      const t = [];
      Array.isArray(e) ? t.push(...e) : t.push(e);
      let r;
      r = (a) => {
        this.hasKey(a) && Ua(`[Resolver] already has key: ${a} overwriting`);
      }, hg(t).forEach((a) => {
        const { src: s } = a;
        let { data: o, format: l, loadParser: u } = a;
        const c = hg(s).map((f) => typeof f == "string" ? aft(f) : Array.isArray(f) ? f : [
          f
        ]), h = this.getAlias(a);
        Array.isArray(h) ? h.forEach(r) : r(h);
        const d = [];
        c.forEach((f) => {
          f.forEach((p) => {
            let g = {};
            if (typeof p != "object") {
              g.src = p;
              for (let m = 0; m < this._parsers.length; m++) {
                const v = this._parsers[m];
                if (v.test(p)) {
                  g = v.parse(p);
                  break;
                }
              }
            } else o = p.data ?? o, l = p.format ?? l, u = p.loadParser ?? u, g = {
              ...g,
              ...p
            };
            if (!h) throw new Error(`[Resolver] alias is undefined for this asset: ${g.src}`);
            g = this._buildResolvedAsset(g, {
              aliases: h,
              data: o,
              format: l,
              loadParser: u
            }), d.push(g);
          });
        }), h.forEach((f) => {
          this._assetMap[f] = d;
        });
      });
    }
    resolveBundle(e) {
      const t = NH(e);
      e = hg(e);
      const r = {};
      return e.forEach((i) => {
        const a = this._bundles[i];
        if (a) {
          const s = this.resolve(a), o = {};
          for (const l in s) {
            const u = s[l];
            o[this._extractAssetIdFromBundle(i, l)] = u;
          }
          r[i] = o;
        }
      }), t ? r[e[0]] : r;
    }
    resolveUrl(e) {
      const t = this.resolve(e);
      if (typeof e != "string") {
        const r = {};
        for (const i in t) r[i] = t[i].src;
        return r;
      }
      return t.src;
    }
    resolve(e) {
      const t = NH(e);
      e = hg(e);
      const r = {};
      return e.forEach((i) => {
        if (!this._resolverHash[i]) if (this._assetMap[i]) {
          let a = this._assetMap[i];
          const s = this._getPreferredOrder(a);
          s == null ? void 0 : s.priority.forEach((o) => {
            s.params[o].forEach((l) => {
              const u = a.filter((c) => c[o] ? c[o] === l : false);
              u.length && (a = u);
            });
          }), this._resolverHash[i] = a[0];
        } else this._resolverHash[i] = this._buildResolvedAsset({
          alias: [
            i
          ],
          src: i
        }, {});
        r[i] = this._resolverHash[i];
      }), t ? r[e[0]] : r;
    }
    hasKey(e) {
      return !!this._assetMap[e];
    }
    hasBundle(e) {
      return !!this._bundles[e];
    }
    _getPreferredOrder(e) {
      for (let t = 0; t < e.length; t++) {
        const r = e[t], i = this._preferredOrder.find((a) => a.params.format.includes(r.format));
        if (i) return i;
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(e) {
      if (!this._defaultSearchParams) return e;
      const t = /\?/.test(e) ? "&" : "?";
      return `${e}${t}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(e, t) {
      const { aliases: r, data: i, loadParser: a, format: s } = t;
      return (this._basePath || this._rootPath) && (e.src = bx.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = r ?? e.alias ?? [
        e.src
      ], e.src = this._appendDefaultSearchParams(e.src), e.data = {
        ...i || {},
        ...e.data
      }, e.loadParser = a ?? e.loadParser, e.format = s ?? e.format ?? sft(e.src), e;
    }
  }
  xie.RETINA_PREFIX = /@([0-9\.]+)x/;
  function sft(n) {
    return n.split(".").pop().split("?").shift().split("#").shift();
  }
  const EH = (n, e) => {
    const t = e.split("?")[1];
    return t && (n += `?${t}`), n;
  }, bie = class Zy {
    constructor(e, t) {
      this.linkedSheets = [], this._texture = e instanceof Fn ? e : null, this.textureSource = e.source, this.textures = {}, this.animations = {}, this.data = t;
      const r = parseFloat(t.meta.scale);
      r ? (this.resolution = r, e.source.resolution = this.resolution) : this.resolution = e.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    parse() {
      return new Promise((e) => {
        this._callback = e, this._batchIndex = 0, this._frameKeys.length <= Zy.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
      });
    }
    _processFrames(e) {
      let t = e;
      const r = Zy.BATCH_SIZE;
      for (; t - e < r && t < this._frameKeys.length; ) {
        const i = this._frameKeys[t], a = this._frames[i], s = a.frame;
        if (s) {
          let o = null, l = null;
          const u = a.trimmed !== false && a.sourceSize ? a.sourceSize : a.frame, c = new ri(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution);
          a.rotated ? o = new ri(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : o = new ri(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), a.trimmed !== false && a.spriteSourceSize && (l = new ri(Math.floor(a.spriteSourceSize.x) / this.resolution, Math.floor(a.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[i] = new Fn({
            source: this.textureSource,
            frame: o,
            orig: c,
            trim: l,
            rotate: a.rotated ? 2 : 0,
            defaultAnchor: a.anchor,
            defaultBorders: a.borders,
            label: i.toString()
          });
        }
        t++;
      }
    }
    _processAnimations() {
      const e = this.data.animations || {};
      for (const t in e) {
        this.animations[t] = [];
        for (let r = 0; r < e[t].length; r++) {
          const i = e[t][r];
          this.animations[t].push(this.textures[i]);
        }
      }
    }
    _parseComplete() {
      const e = this._callback;
      this._callback = null, this._batchIndex = 0, e.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * Zy.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
        this._batchIndex * Zy.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(e = false) {
      var _a2;
      for (const t in this.textures) this.textures[t].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((_a2 = this._texture) == null ? void 0 : _a2.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
    }
  };
  bie.BATCH_SIZE = 1e3;
  let MH = bie;
  const oft = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc"
  ];
  function wie(n, e, t) {
    const r = {};
    if (n.forEach((i) => {
      r[i] = e;
    }), Object.keys(e.textures).forEach((i) => {
      r[i] = e.textures[i];
    }), !t) {
      const i = bx.dirname(n[0]);
      e.linkedSheets.forEach((a, s) => {
        const o = wie([
          `${i}/${e.data.meta.related_multi_packs[s]}`
        ], a, true);
        Object.assign(r, o);
      });
    }
    return r;
  }
  const lft = {
    extension: Nn.Asset,
    cache: {
      test: (n) => n instanceof MH,
      getCacheableAssets: (n, e) => wie(n, e, false)
    },
    resolver: {
      extension: {
        type: Nn.ResolveParser,
        name: "resolveSpritesheet"
      },
      test: (n) => {
        const t = n.split("?")[0].split("."), r = t.pop(), i = t.pop();
        return r === "json" && oft.includes(i);
      },
      parse: (n) => {
        var _a2;
        const e = n.split(".");
        return {
          resolution: parseFloat(((_a2 = xie.RETINA_PREFIX.exec(n)) == null ? void 0 : _a2[1]) ?? "1"),
          format: e[e.length - 2],
          src: n
        };
      }
    },
    loader: {
      name: "spritesheetLoader",
      extension: {
        type: Nn.LoadParser,
        priority: vie.Normal,
        name: "spritesheetLoader"
      },
      async testParse(n, e) {
        return bx.extname(e.src).toLowerCase() === ".json" && !!n.frames;
      },
      async parse(n, e, t) {
        var _a2, _b2;
        const { texture: r, imageFilename: i, textureOptions: a } = (e == null ? void 0 : e.data) ?? {};
        let s = bx.dirname(e.src);
        s && s.lastIndexOf("/") !== s.length - 1 && (s += "/");
        let o;
        if (r instanceof Fn) o = r;
        else {
          const c = EH(s + (i ?? n.meta.image), e.src);
          o = (await t.load([
            {
              src: c,
              data: a
            }
          ]))[c];
        }
        const l = new MH(o.source, n);
        await l.parse();
        const u = (_a2 = n == null ? void 0 : n.meta) == null ? void 0 : _a2.related_multi_packs;
        if (Array.isArray(u)) {
          const c = [];
          for (const d of u) {
            if (typeof d != "string") continue;
            let f = s + d;
            ((_b2 = e.data) == null ? void 0 : _b2.ignoreMultiPack) || (f = EH(f, e.src), c.push(t.load({
              src: f,
              data: {
                textureOptions: a,
                ignoreMultiPack: true
              }
            })));
          }
          const h = await Promise.all(c);
          l.linkedSheets = h, h.forEach((d) => {
            d.linkedSheets = [
              l
            ].concat(l.linkedSheets.filter((f) => f !== d));
          });
        }
        return l;
      },
      async unload(n, e, t) {
        await t.unload(n.textureSource._sourceOrigin), n.destroy(false);
      }
    }
  };
  $s.add(lft);
  const zA = /* @__PURE__ */ Object.create(null), PH = /* @__PURE__ */ Object.create(null);
  UL = function(n, e) {
    let t = PH[n];
    return t === void 0 && (zA[e] === void 0 && (zA[e] = 1), PH[n] = t = zA[e]++), t;
  };
  let Nw;
  function _ie() {
    return (!Nw || (Nw == null ? void 0 : Nw.isContextLost())) && (Nw = to.get().createCanvas().getContext("webgl", {})), Nw;
  }
  let Ew;
  function uft() {
    if (!Ew) {
      Ew = "mediump";
      const n = _ie();
      n && n.getShaderPrecisionFormat && (Ew = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision ? "highp" : "mediump");
    }
    return Ew;
  }
  function cft(n, e, t) {
    return e ? n : t ? (n = n.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${n}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${n}
        `;
  }
  function hft(n, e, t) {
    const r = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
    if (n.substring(0, 9) !== "precision") {
      let i = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
      return i === "highp" && r !== "highp" && (i = "mediump"), `precision ${i} float;
${n}`;
    } else if (r !== "highp" && n.substring(0, 15) === "precision highp") return n.replace("precision highp", "precision mediump");
    return n;
  }
  function dft(n, e) {
    return e ? `#version 300 es
${n}` : n;
  }
  const fft = {}, pft = {};
  function gft(n, { name: e = "pixi-program" }, t = true) {
    e = e.replace(/\s+/g, "-"), e += t ? "-fragment" : "-vertex";
    const r = t ? fft : pft;
    return r[e] ? (r[e]++, e += `-${r[e]}`) : r[e] = 1, n.indexOf("#define SHADER_NAME") !== -1 ? n : `${`#define SHADER_NAME ${e}`}
${n}`;
  }
  function mft(n, e) {
    return e ? n.replace("#version 300 es", "") : n;
  }
  const VA = {
    stripVersion: mft,
    ensurePrecision: hft,
    addProgramDefines: cft,
    setProgramName: gft,
    insertVersion: dft
  }, WA = /* @__PURE__ */ Object.create(null), Sie = class eN {
    constructor(e) {
      e = {
        ...eN.defaultOptions,
        ...e
      };
      const t = e.fragment.indexOf("#version 300 es") !== -1, r = {
        stripVersion: t,
        ensurePrecision: {
          requestedFragmentPrecision: e.preferredFragmentPrecision,
          requestedVertexPrecision: e.preferredVertexPrecision,
          maxSupportedVertexPrecision: "highp",
          maxSupportedFragmentPrecision: uft()
        },
        setProgramName: {
          name: e.name
        },
        addProgramDefines: t,
        insertVersion: t
      };
      let i = e.fragment, a = e.vertex;
      Object.keys(VA).forEach((s) => {
        const o = r[s];
        i = VA[s](i, o, true), a = VA[s](a, o, false);
      }), this.fragment = i, this.vertex = a, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = UL(`${this.vertex}:${this.fragment}`, "gl-program");
    }
    destroy() {
      this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null;
    }
    static from(e) {
      const t = `${e.vertex}:${e.fragment}`;
      return WA[t] || (WA[t] = new eN(e)), WA[t];
    }
  };
  Sie.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
  };
  Cie = Sie;
  const LH = {
    uint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    uint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    sint8x2: {
      size: 2,
      stride: 2,
      normalised: false
    },
    sint8x4: {
      size: 4,
      stride: 4,
      normalised: false
    },
    unorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    unorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    snorm8x2: {
      size: 2,
      stride: 2,
      normalised: true
    },
    snorm8x4: {
      size: 4,
      stride: 4,
      normalised: true
    },
    uint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    uint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    sint16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    sint16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    unorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    unorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    snorm16x2: {
      size: 2,
      stride: 4,
      normalised: true
    },
    snorm16x4: {
      size: 4,
      stride: 8,
      normalised: true
    },
    float16x2: {
      size: 2,
      stride: 4,
      normalised: false
    },
    float16x4: {
      size: 4,
      stride: 8,
      normalised: false
    },
    float32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    float32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    float32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    float32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    uint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    uint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    uint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    uint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    },
    sint32: {
      size: 1,
      stride: 4,
      normalised: false
    },
    sint32x2: {
      size: 2,
      stride: 8,
      normalised: false
    },
    sint32x3: {
      size: 3,
      stride: 12,
      normalised: false
    },
    sint32x4: {
      size: 4,
      stride: 16,
      normalised: false
    }
  };
  vft = function(n) {
    return LH[n] ?? LH.float32;
  };
  const yft = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
  };
  function xft({ source: n, entryPoint: e }) {
    const t = {}, r = n.indexOf(`fn ${e}`);
    if (r !== -1) {
      const i = n.indexOf("->", r);
      if (i !== -1) {
        const a = n.substring(r, i), s = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let o;
        for (; (o = s.exec(a)) !== null; ) {
          const l = yft[o[3]] ?? "float32";
          t[o[2]] = {
            location: parseInt(o[1], 10),
            format: l,
            stride: vft(l).stride,
            offset: 0,
            instance: false,
            start: 0
          };
        }
      }
    }
    return t;
  }
  function GA(n) {
    var _a2, _b2;
    const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, t = /@group\((\d+)\)/, r = /@binding\((\d+)\)/, i = /var(<[^>]+>)? (\w+)/, a = /:\s*(\w+)/, s = /struct\s+(\w+)\s*{([^}]+)}/g, o = /(\w+)\s*:\s*([\w\<\>]+)/g, l = /struct\s+(\w+)/, u = (_a2 = n.match(e)) == null ? void 0 : _a2.map((h) => ({
      group: parseInt(h.match(t)[1], 10),
      binding: parseInt(h.match(r)[1], 10),
      name: h.match(i)[2],
      isUniform: h.match(i)[1] === "<uniform>",
      type: h.match(a)[1]
    }));
    if (!u) return {
      groups: [],
      structs: []
    };
    const c = ((_b2 = n.match(s)) == null ? void 0 : _b2.map((h) => {
      const d = h.match(l)[1], f = h.match(o).reduce((p, g) => {
        const [m, v] = g.split(":");
        return p[m.trim()] = v.trim(), p;
      }, {});
      return f ? {
        name: d,
        members: f
      } : null;
    }).filter(({ name: h }) => u.some((d) => d.type === h))) ?? [];
    return {
      groups: u,
      structs: c
    };
  }
  var Qy = ((n) => (n[n.VERTEX = 1] = "VERTEX", n[n.FRAGMENT = 2] = "FRAGMENT", n[n.COMPUTE = 4] = "COMPUTE", n))(Qy || {});
  function bft({ groups: n }) {
    const e = [];
    for (let t = 0; t < n.length; t++) {
      const r = n[t];
      e[r.group] || (e[r.group] = []), r.isUniform ? e[r.group].push({
        binding: r.binding,
        visibility: Qy.VERTEX | Qy.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      }) : r.type === "sampler" ? e[r.group].push({
        binding: r.binding,
        visibility: Qy.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      }) : r.type === "texture_2d" && e[r.group].push({
        binding: r.binding,
        visibility: Qy.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
    return e;
  }
  function wft({ groups: n }) {
    const e = [];
    for (let t = 0; t < n.length; t++) {
      const r = n[t];
      e[r.group] || (e[r.group] = {}), e[r.group][r.name] = r.binding;
    }
    return e;
  }
  function _ft(n, e) {
    const t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), i = [
      ...n.structs,
      ...e.structs
    ].filter((s) => t.has(s.name) ? false : (t.add(s.name), true)), a = [
      ...n.groups,
      ...e.groups
    ].filter((s) => {
      const o = `${s.name}-${s.binding}`;
      return r.has(o) ? false : (r.add(o), true);
    });
    return {
      structs: i,
      groups: a
    };
  }
  const UA = /* @__PURE__ */ Object.create(null);
  m2 = class {
    constructor(e) {
      var _a2, _b2;
      this._layoutKey = 0, this._attributeLocationsKey = 0;
      const { fragment: t, vertex: r, layout: i, gpuLayout: a, name: s } = e;
      if (this.name = s, this.fragment = t, this.vertex = r, t.source === r.source) {
        const o = GA(t.source);
        this.structsAndGroups = o;
      } else {
        const o = GA(r.source), l = GA(t.source);
        this.structsAndGroups = _ft(o, l);
      }
      this.layout = i ?? wft(this.structsAndGroups), this.gpuLayout = a ?? bft(this.structsAndGroups), this.autoAssignGlobalUniforms = ((_a2 = this.layout[0]) == null ? void 0 : _a2.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((_b2 = this.layout[1]) == null ? void 0 : _b2.localUniforms) !== void 0, this._generateProgramKey();
    }
    _generateProgramKey() {
      const { vertex: e, fragment: t } = this, r = e.source + t.source + e.entryPoint + t.entryPoint;
      this._layoutKey = UL(r, "program");
    }
    get attributeData() {
      return this._attributeData ?? (this._attributeData = xft(this.vertex)), this._attributeData;
    }
    destroy() {
      this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null;
    }
    static from(e) {
      const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
      return UA[t] || (UA[t] = new m2(e)), UA[t];
    }
  };
  const Iie = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>",
    "vec2<i32>",
    "vec3<i32>",
    "vec4<i32>"
  ], Sft = Iie.reduce((n, e) => (n[e] = true, n), {});
  function Cft(n, e) {
    switch (n) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * e);
      case "vec3<f32>":
        return new Float32Array(3 * e);
      case "vec4<f32>":
        return new Float32Array(4 * e);
      case "mat2x2<f32>":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3x3<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4x4<f32>":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
    return null;
  }
  const kie = class Tie {
    constructor(e, t) {
      this._touched = 0, this.uid = Dr("uniform"), this._resourceType = "uniformGroup", this._resourceId = Dr("resource"), this.isUniformGroup = true, this._dirtyId = 0, this.destroyed = false, t = {
        ...Tie.defaultOptions,
        ...t
      }, this.uniformStructures = e;
      const r = {};
      for (const i in e) {
        const a = e[i];
        if (a.name = i, a.size = a.size ?? 1, !Sft[a.type]) throw new Error(`Uniform type ${a.type} is not supported. Supported uniform types are: ${Iie.join(", ")}`);
        a.value ?? (a.value = Cft(a.type, a.size)), r[i] = a.value;
      }
      this.uniforms = r, this._dirtyId = 1, this.ubo = t.ubo, this.isStatic = t.isStatic, this._signature = UL(Object.keys(r).map((i) => `${i}-${e[i].type}`).join("-"), "uniform-group");
    }
    update() {
      this._dirtyId++;
    }
  };
  kie.defaultOptions = {
    ubo: false,
    isStatic: false
  };
  Aie = kie;
  T_ = class {
    constructor(e) {
      this.resources = /* @__PURE__ */ Object.create(null), this._dirty = true;
      let t = 0;
      for (const r in e) {
        const i = e[r];
        this.setResource(i, t++);
      }
      this._updateKey();
    }
    _updateKey() {
      if (!this._dirty) return;
      this._dirty = false;
      const e = [];
      let t = 0;
      for (const r in this.resources) e[t++] = this.resources[r]._resourceId;
      this._key = e.join("|");
    }
    setResource(e, t) {
      var _a2, _b2;
      const r = this.resources[t];
      e !== r && (r && ((_a2 = e.off) == null ? void 0 : _a2.call(e, "change", this.onResourceChange, this)), (_b2 = e.on) == null ? void 0 : _b2.call(e, "change", this.onResourceChange, this), this.resources[t] = e, this._dirty = true);
    }
    getResource(e) {
      return this.resources[e];
    }
    _touch(e) {
      const t = this.resources;
      for (const r in t) t[r]._touched = e;
    }
    destroy() {
      var _a2, _b2;
      const e = this.resources;
      for (const t in e) (_b2 = (_a2 = e[t]).off) == null ? void 0 : _b2.call(_a2, "change", this.onResourceChange, this);
      this.resources = null;
    }
    onResourceChange(e) {
      if (this._dirty = true, e.destroyed) {
        const t = this.resources;
        for (const r in t) t[r] === e && (t[r] = null);
      } else this._updateKey();
    }
  };
  tN = ((n) => (n[n.WEBGL = 1] = "WEBGL", n[n.WEBGPU = 2] = "WEBGPU", n[n.BOTH = 3] = "BOTH", n))(tN || {});
  HL = class extends fl {
    constructor(e) {
      super(), this.uid = Dr("shader"), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [];
      let { gpuProgram: t, glProgram: r, groups: i, resources: a, compatibleRenderers: s, groupMap: o } = e;
      this.gpuProgram = t, this.glProgram = r, s === void 0 && (s = 0, t && (s |= tN.WEBGPU), r && (s |= tN.WEBGL)), this.compatibleRenderers = s;
      const l = {};
      if (!a && !i && (a = {}), a && i) throw new Error("[Shader] Cannot have both resources and groups");
      if (!t && i && !o) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      if (!t && i && o) for (const u in o) for (const c in o[u]) {
        const h = o[u][c];
        l[h] = {
          group: u,
          binding: c,
          name: h
        };
      }
      else if (t && i && !o) {
        const u = t.structsAndGroups.groups;
        o = {}, u.forEach((c) => {
          o[c.group] = o[c.group] || {}, o[c.group][c.binding] = c.name, l[c.name] = c;
        });
      } else if (a) {
        i = {}, o = {}, t && t.structsAndGroups.groups.forEach((h) => {
          o[h.group] = o[h.group] || {}, o[h.group][h.binding] = h.name, l[h.name] = h;
        });
        let u = 0;
        for (const c in a) l[c] || (i[99] || (i[99] = new T_(), this._ownedBindGroups.push(i[99])), l[c] = {
          group: 99,
          binding: u,
          name: c
        }, o[99] = o[99] || {}, o[99][u] = c, u++);
        for (const c in a) {
          const h = c;
          let d = a[c];
          !d.source && !d._resourceType && (d = new Aie(d));
          const f = l[h];
          f && (i[f.group] || (i[f.group] = new T_(), this._ownedBindGroups.push(i[f.group])), i[f.group].setResource(d, f.binding));
        }
      }
      this.groups = i, this._uniformBindMap = o, this.resources = this._buildResourceAccessor(i, l);
    }
    addResource(e, t, r) {
      var i, a;
      (i = this._uniformBindMap)[t] || (i[t] = {}), (a = this._uniformBindMap[t])[r] || (a[r] = e), this.groups[t] || (this.groups[t] = new T_(), this._ownedBindGroups.push(this.groups[t]));
    }
    _buildResourceAccessor(e, t) {
      const r = {};
      for (const i in t) {
        const a = t[i];
        Object.defineProperty(r, a.name, {
          get() {
            return e[a.group].getResource(a.binding);
          },
          set(s) {
            e[a.group].setResource(s, a.binding);
          }
        });
      }
      return r;
    }
    destroy(e = false) {
      var _a2, _b2;
      this.emit("destroy", this), e && ((_a2 = this.gpuProgram) == null ? void 0 : _a2.destroy(), (_b2 = this.glProgram) == null ? void 0 : _b2.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((t) => {
        t.destroy();
      }), this._ownedBindGroups = null, this.resources = null, this.groups = null;
    }
    static from(e) {
      const { gpu: t, gl: r, ...i } = e;
      let a, s;
      return t && (a = m2.from(t)), r && (s = Cie.from(r)), new HL({
        gpuProgram: a,
        glProgram: s,
        ...i
      });
    }
  };
  const nN = [];
  $s.handleByNamedList(Nn.Environment, nN);
  async function Ift(n) {
    if (!n) for (let e = 0; e < nN.length; e++) {
      const t = nN[e];
      if (t.value.test()) {
        await t.value.load();
        return;
      }
    }
  }
  let Cy;
  kft = function() {
    if (typeof Cy == "boolean") return Cy;
    try {
      Cy = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
        a: "b"
      }, "a", "b") === true;
    } catch {
      Cy = false;
    }
    return Cy;
  };
  var Mw = {
    exports: {}
  }, FH;
  function Tft() {
    if (FH) return Mw.exports;
    FH = 1, Mw.exports = n, Mw.exports.default = n;
    function n(A, M, $) {
      $ = $ || 2;
      var L = M && M.length, F = L ? M[0] * $ : A.length, O = e(A, 0, F, $, true), z = [];
      if (!O || O.next === O.prev) return z;
      var V, H, Y, le, ve, re, ae;
      if (L && (O = l(A, M, O, $)), A.length > 80 * $) {
        V = Y = A[0], H = le = A[1];
        for (var fe = $; fe < F; fe += $) ve = A[fe], re = A[fe + 1], ve < V && (V = ve), re < H && (H = re), ve > Y && (Y = ve), re > le && (le = re);
        ae = Math.max(Y - V, le - H), ae = ae !== 0 ? 32767 / ae : 0;
      }
      return r(O, z, $, V, H, ae, 0), z;
    }
    function e(A, M, $, L, F) {
      var O, z;
      if (F === E(A, M, $, L) > 0) for (O = M; O < $; O += L) z = D(O, A[O], A[O + 1], z);
      else for (O = $ - L; O >= M; O -= L) z = D(O, A[O], A[O + 1], z);
      return z && b(z, z.next) && (R(z), z = z.next), z;
    }
    function t(A, M) {
      if (!A) return A;
      M || (M = A);
      var $ = A, L;
      do
        if (L = false, !$.steiner && (b($, $.next) || x($.prev, $, $.next) === 0)) {
          if (R($), $ = M = $.prev, $ === $.next) break;
          L = true;
        } else $ = $.next;
      while (L || $ !== M);
      return M;
    }
    function r(A, M, $, L, F, O, z) {
      if (A) {
        !z && O && f(A, L, F, O);
        for (var V = A, H, Y; A.prev !== A.next; ) {
          if (H = A.prev, Y = A.next, O ? a(A, L, F, O) : i(A)) {
            M.push(H.i / $ | 0), M.push(A.i / $ | 0), M.push(Y.i / $ | 0), R(A), A = Y.next, V = Y.next;
            continue;
          }
          if (A = Y, A === V) {
            z ? z === 1 ? (A = s(t(A), M, $), r(A, M, $, L, F, O, 2)) : z === 2 && o(A, M, $, L, F, O) : r(t(A), M, $, L, F, O, 1);
            break;
          }
        }
      }
    }
    function i(A) {
      var M = A.prev, $ = A, L = A.next;
      if (x(M, $, L) >= 0) return false;
      for (var F = M.x, O = $.x, z = L.x, V = M.y, H = $.y, Y = L.y, le = F < O ? F < z ? F : z : O < z ? O : z, ve = V < H ? V < Y ? V : Y : H < Y ? H : Y, re = F > O ? F > z ? F : z : O > z ? O : z, ae = V > H ? V > Y ? V : Y : H > Y ? H : Y, fe = L.next; fe !== M; ) {
        if (fe.x >= le && fe.x <= re && fe.y >= ve && fe.y <= ae && v(F, V, O, H, z, Y, fe.x, fe.y) && x(fe.prev, fe, fe.next) >= 0) return false;
        fe = fe.next;
      }
      return true;
    }
    function a(A, M, $, L) {
      var F = A.prev, O = A, z = A.next;
      if (x(F, O, z) >= 0) return false;
      for (var V = F.x, H = O.x, Y = z.x, le = F.y, ve = O.y, re = z.y, ae = V < H ? V < Y ? V : Y : H < Y ? H : Y, fe = le < ve ? le < re ? le : re : ve < re ? ve : re, ce = V > H ? V > Y ? V : Y : H > Y ? H : Y, ye = le > ve ? le > re ? le : re : ve > re ? ve : re, Le = g(ae, fe, M, $, L), Re = g(ce, ye, M, $, L), be = A.prevZ, xe = A.nextZ; be && be.z >= Le && xe && xe.z <= Re; ) {
        if (be.x >= ae && be.x <= ce && be.y >= fe && be.y <= ye && be !== F && be !== z && v(V, le, H, ve, Y, re, be.x, be.y) && x(be.prev, be, be.next) >= 0 || (be = be.prevZ, xe.x >= ae && xe.x <= ce && xe.y >= fe && xe.y <= ye && xe !== F && xe !== z && v(V, le, H, ve, Y, re, xe.x, xe.y) && x(xe.prev, xe, xe.next) >= 0)) return false;
        xe = xe.nextZ;
      }
      for (; be && be.z >= Le; ) {
        if (be.x >= ae && be.x <= ce && be.y >= fe && be.y <= ye && be !== F && be !== z && v(V, le, H, ve, Y, re, be.x, be.y) && x(be.prev, be, be.next) >= 0) return false;
        be = be.prevZ;
      }
      for (; xe && xe.z <= Re; ) {
        if (xe.x >= ae && xe.x <= ce && xe.y >= fe && xe.y <= ye && xe !== F && xe !== z && v(V, le, H, ve, Y, re, xe.x, xe.y) && x(xe.prev, xe, xe.next) >= 0) return false;
        xe = xe.nextZ;
      }
      return true;
    }
    function s(A, M, $) {
      var L = A;
      do {
        var F = L.prev, O = L.next.next;
        !b(F, O) && w(F, L, L.next, O) && C(F, O) && C(O, F) && (M.push(F.i / $ | 0), M.push(L.i / $ | 0), M.push(O.i / $ | 0), R(L), R(L.next), L = A = O), L = L.next;
      } while (L !== A);
      return t(L);
    }
    function o(A, M, $, L, F, O) {
      var z = A;
      do {
        for (var V = z.next.next; V !== z.prev; ) {
          if (z.i !== V.i && y(z, V)) {
            var H = k(z, V);
            z = t(z, z.next), H = t(H, H.next), r(z, M, $, L, F, O, 0), r(H, M, $, L, F, O, 0);
            return;
          }
          V = V.next;
        }
        z = z.next;
      } while (z !== A);
    }
    function l(A, M, $, L) {
      var F = [], O, z, V, H, Y;
      for (O = 0, z = M.length; O < z; O++) V = M[O] * L, H = O < z - 1 ? M[O + 1] * L : A.length, Y = e(A, V, H, L, false), Y === Y.next && (Y.steiner = true), F.push(m(Y));
      for (F.sort(u), O = 0; O < F.length; O++) $ = c(F[O], $);
      return $;
    }
    function u(A, M) {
      return A.x - M.x;
    }
    function c(A, M) {
      var $ = h(A, M);
      if (!$) return M;
      var L = k($, A);
      return t(L, L.next), t($, $.next);
    }
    function h(A, M) {
      var $ = M, L = A.x, F = A.y, O = -1 / 0, z;
      do {
        if (F <= $.y && F >= $.next.y && $.next.y !== $.y) {
          var V = $.x + (F - $.y) * ($.next.x - $.x) / ($.next.y - $.y);
          if (V <= L && V > O && (O = V, z = $.x < $.next.x ? $ : $.next, V === L)) return z;
        }
        $ = $.next;
      } while ($ !== M);
      if (!z) return null;
      var H = z, Y = z.x, le = z.y, ve = 1 / 0, re;
      $ = z;
      do
        L >= $.x && $.x >= Y && L !== $.x && v(F < le ? L : O, F, Y, le, F < le ? O : L, F, $.x, $.y) && (re = Math.abs(F - $.y) / (L - $.x), C($, A) && (re < ve || re === ve && ($.x > z.x || $.x === z.x && d(z, $))) && (z = $, ve = re)), $ = $.next;
      while ($ !== H);
      return z;
    }
    function d(A, M) {
      return x(A.prev, A, M.prev) < 0 && x(M.next, A, A.next) < 0;
    }
    function f(A, M, $, L) {
      var F = A;
      do
        F.z === 0 && (F.z = g(F.x, F.y, M, $, L)), F.prevZ = F.prev, F.nextZ = F.next, F = F.next;
      while (F !== A);
      F.prevZ.nextZ = null, F.prevZ = null, p(F);
    }
    function p(A) {
      var M, $, L, F, O, z, V, H, Y = 1;
      do {
        for ($ = A, A = null, O = null, z = 0; $; ) {
          for (z++, L = $, V = 0, M = 0; M < Y && (V++, L = L.nextZ, !!L); M++) ;
          for (H = Y; V > 0 || H > 0 && L; ) V !== 0 && (H === 0 || !L || $.z <= L.z) ? (F = $, $ = $.nextZ, V--) : (F = L, L = L.nextZ, H--), O ? O.nextZ = F : A = F, F.prevZ = O, O = F;
          $ = L;
        }
        O.nextZ = null, Y *= 2;
      } while (z > 1);
      return A;
    }
    function g(A, M, $, L, F) {
      return A = (A - $) * F | 0, M = (M - L) * F | 0, A = (A | A << 8) & 16711935, A = (A | A << 4) & 252645135, A = (A | A << 2) & 858993459, A = (A | A << 1) & 1431655765, M = (M | M << 8) & 16711935, M = (M | M << 4) & 252645135, M = (M | M << 2) & 858993459, M = (M | M << 1) & 1431655765, A | M << 1;
    }
    function m(A) {
      var M = A, $ = A;
      do
        (M.x < $.x || M.x === $.x && M.y < $.y) && ($ = M), M = M.next;
      while (M !== A);
      return $;
    }
    function v(A, M, $, L, F, O, z, V) {
      return (F - z) * (M - V) >= (A - z) * (O - V) && (A - z) * (L - V) >= ($ - z) * (M - V) && ($ - z) * (O - V) >= (F - z) * (L - V);
    }
    function y(A, M) {
      return A.next.i !== M.i && A.prev.i !== M.i && !I(A, M) && (C(A, M) && C(M, A) && T(A, M) && (x(A.prev, A, M.prev) || x(A, M.prev, M)) || b(A, M) && x(A.prev, A, A.next) > 0 && x(M.prev, M, M.next) > 0);
    }
    function x(A, M, $) {
      return (M.y - A.y) * ($.x - M.x) - (M.x - A.x) * ($.y - M.y);
    }
    function b(A, M) {
      return A.x === M.x && A.y === M.y;
    }
    function w(A, M, $, L) {
      var F = S(x(A, M, $)), O = S(x(A, M, L)), z = S(x($, L, A)), V = S(x($, L, M));
      return !!(F !== O && z !== V || F === 0 && _(A, $, M) || O === 0 && _(A, L, M) || z === 0 && _($, A, L) || V === 0 && _($, M, L));
    }
    function _(A, M, $) {
      return M.x <= Math.max(A.x, $.x) && M.x >= Math.min(A.x, $.x) && M.y <= Math.max(A.y, $.y) && M.y >= Math.min(A.y, $.y);
    }
    function S(A) {
      return A > 0 ? 1 : A < 0 ? -1 : 0;
    }
    function I(A, M) {
      var $ = A;
      do {
        if ($.i !== A.i && $.next.i !== A.i && $.i !== M.i && $.next.i !== M.i && w($, $.next, A, M)) return true;
        $ = $.next;
      } while ($ !== A);
      return false;
    }
    function C(A, M) {
      return x(A.prev, A, A.next) < 0 ? x(A, M, A.next) >= 0 && x(A, A.prev, M) >= 0 : x(A, M, A.prev) < 0 || x(A, A.next, M) < 0;
    }
    function T(A, M) {
      var $ = A, L = false, F = (A.x + M.x) / 2, O = (A.y + M.y) / 2;
      do
        $.y > O != $.next.y > O && $.next.y !== $.y && F < ($.next.x - $.x) * (O - $.y) / ($.next.y - $.y) + $.x && (L = !L), $ = $.next;
      while ($ !== A);
      return L;
    }
    function k(A, M) {
      var $ = new N(A.i, A.x, A.y), L = new N(M.i, M.x, M.y), F = A.next, O = M.prev;
      return A.next = M, M.prev = A, $.next = F, F.prev = $, L.next = $, $.prev = L, O.next = L, L.prev = O, L;
    }
    function D(A, M, $, L) {
      var F = new N(A, M, $);
      return L ? (F.next = L.next, F.prev = L, L.next.prev = F, L.next = F) : (F.prev = F, F.next = F), F;
    }
    function R(A) {
      A.next.prev = A.prev, A.prev.next = A.next, A.prevZ && (A.prevZ.nextZ = A.nextZ), A.nextZ && (A.nextZ.prevZ = A.prevZ);
    }
    function N(A, M, $) {
      this.i = A, this.x = M, this.y = $, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    n.deviation = function(A, M, $, L) {
      var F = M && M.length, O = F ? M[0] * $ : A.length, z = Math.abs(E(A, 0, O, $));
      if (F) for (var V = 0, H = M.length; V < H; V++) {
        var Y = M[V] * $, le = V < H - 1 ? M[V + 1] * $ : A.length;
        z -= Math.abs(E(A, Y, le, $));
      }
      var ve = 0;
      for (V = 0; V < L.length; V += 3) {
        var re = L[V] * $, ae = L[V + 1] * $, fe = L[V + 2] * $;
        ve += Math.abs((A[re] - A[fe]) * (A[ae + 1] - A[re + 1]) - (A[re] - A[ae]) * (A[fe + 1] - A[re + 1]));
      }
      return z === 0 && ve === 0 ? 0 : Math.abs((ve - z) / z);
    };
    function E(A, M, $, L) {
      for (var F = 0, O = M, z = $ - L; O < $; O += L) F += (A[z] - A[O]) * (A[O + 1] + A[z + 1]), z = O;
      return F;
    }
    return n.flatten = function(A) {
      for (var M = A[0][0].length, $ = {
        vertices: [],
        holes: [],
        dimensions: M
      }, L = 0, F = 0; F < A.length; F++) {
        for (var O = 0; O < A[F].length; O++) for (var z = 0; z < M; z++) $.vertices.push(A[F][O][z]);
        F > 0 && (L += A[F - 1].length, $.holes.push(L));
      }
      return $;
    }, Mw.exports;
  }
  var Aft = Tft();
  const Dft = _v(Aft);
  Die = ((n) => (n[n.NONE = 0] = "NONE", n[n.COLOR = 16384] = "COLOR", n[n.STENCIL = 1024] = "STENCIL", n[n.DEPTH = 256] = "DEPTH", n[n.COLOR_DEPTH = 16640] = "COLOR_DEPTH", n[n.COLOR_STENCIL = 17408] = "COLOR_STENCIL", n[n.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", n[n.ALL = 17664] = "ALL", n))(Die || {});
  Rft = class {
    constructor(e) {
      this.items = [], this._name = e;
    }
    emit(e, t, r, i, a, s, o, l) {
      const { name: u, items: c } = this;
      for (let h = 0, d = c.length; h < d; h++) c[h][u](e, t, r, i, a, s, o, l);
      return this;
    }
    add(e) {
      return e[this._name] && (this.remove(e), this.items.push(e)), this;
    }
    remove(e) {
      const t = this.items.indexOf(e);
      return t !== -1 && this.items.splice(t, 1), this;
    }
    contains(e) {
      return this.items.indexOf(e) !== -1;
    }
    removeAll() {
      return this.items.length = 0, this;
    }
    destroy() {
      this.removeAll(), this.items = null, this._name = null;
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  };
  const $ft = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "resetState",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender"
  ], Rie = class $ie extends fl {
    constructor(e) {
      super(), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = e.type, this.name = e.name, this.config = e;
      const t = [
        ...$ft,
        ...this.config.runners ?? []
      ];
      this._addRunners(...t), this._unsafeEvalCheck();
    }
    async init(e = {}) {
      const t = e.skipExtensionImports === true ? true : e.manageImports === false;
      await Ift(t), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (const r in this._systemsHash) e = {
        ...this._systemsHash[r].constructor.defaultOptions,
        ...e
      };
      e = {
        ...$ie.defaultOptions,
        ...e
      }, this._roundPixels = e.roundPixels ? 1 : 0;
      for (let r = 0; r < this.runners.init.items.length; r++) await this.runners.init.items[r].init(e);
      this._initOptions = e;
    }
    render(e, t) {
      let r = e;
      if (r instanceof yp && (r = {
        container: r
      }, t && (Gn(or, "passing a second argument is deprecated, please use render options instead"), r.target = t.renderTexture)), r.target || (r.target = this.view.renderTarget), r.target === this.view.renderTarget && (this._lastObjectRendered = r.container, r.clearColor ?? (r.clearColor = this.background.colorRgba), r.clear ?? (r.clear = this.background.clearBeforeRender)), r.clearColor) {
        const i = Array.isArray(r.clearColor) && r.clearColor.length === 4;
        r.clearColor = i ? r.clearColor : Ei.shared.setValue(r.clearColor).toArray();
      }
      r.transform || (r.container.updateLocalTransform(), r.transform = r.container.localTransform), r.container.enableRenderGroup(), this.runners.prerender.emit(r), this.runners.renderStart.emit(r), this.runners.render.emit(r), this.runners.renderEnd.emit(r), this.runners.postrender.emit(r);
    }
    resize(e, t, r) {
      const i = this.view.resolution;
      this.view.resize(e, t, r), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), r !== void 0 && r !== i && this.runners.resolutionChange.emit(r);
    }
    clear(e = {}) {
      const t = this;
      e.target || (e.target = t.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ?? (e.clear = Die.ALL);
      const { clear: r, clearColor: i, target: a } = e;
      Ei.shared.setValue(i ?? this.background.colorRgba), t.renderTarget.clear(a, r, Ei.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(e) {
      this.view.resolution = e, this.runners.resolutionChange.emit(e);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      return this.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...e) {
      e.forEach((t) => {
        this.runners[t] = new Rft(t);
      });
    }
    _addSystems(e) {
      let t;
      for (t in e) {
        const r = e[t];
        this._addSystem(r.value, r.name);
      }
    }
    _addSystem(e, t) {
      const r = new e(this);
      if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
      this[t] = r, this._systemsHash[t] = r;
      for (const i in this.runners) this.runners[i].add(r);
      return this;
    }
    _addPipes(e, t) {
      const r = t.reduce((i, a) => (i[a.name] = a.value, i), {});
      e.forEach((i) => {
        const a = i.value, s = i.name, o = r[s];
        this.renderPipes[s] = new a(this, o ? new o() : null);
      });
    }
    destroy(e = false) {
      this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), Object.values(this.runners).forEach((t) => {
        t.destroy();
      }), this._systemsHash = null, this.renderPipes = null;
    }
    generateTexture(e) {
      return this.textureGenerator.generateTexture(e);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!kft()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
    resetState() {
      this.runners.resetState.emit();
    }
  };
  Rie.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: false,
    roundPixels: false
  };
  let Pw;
  Nie = Rie;
  function Nft(n) {
    return Pw !== void 0 || (Pw = (() => {
      var _a2;
      const e = {
        stencil: true,
        failIfMajorPerformanceCaveat: n ?? Nie.defaultOptions.failIfMajorPerformanceCaveat
      };
      try {
        if (!to.get().getWebGLRenderingContext()) return false;
        let r = to.get().createCanvas().getContext("webgl", e);
        const i = !!((_a2 = r == null ? void 0 : r.getContextAttributes()) == null ? void 0 : _a2.stencil);
        if (r) {
          const a = r.getExtension("WEBGL_lose_context");
          a && a.loseContext();
        }
        return r = null, i;
      } catch {
        return false;
      }
    })()), Pw;
  }
  let Lw;
  async function Eft(n = {}) {
    return Lw !== void 0 || (Lw = await (async () => {
      const e = to.get().getNavigator().gpu;
      if (!e) return false;
      try {
        return await (await e.requestAdapter(n)).requestDevice(), true;
      } catch {
        return false;
      }
    })()), Lw;
  }
  const OH = [
    "webgl",
    "webgpu",
    "canvas"
  ];
  async function Mft(n) {
    let e = [];
    n.preference ? (e.push(n.preference), OH.forEach((a) => {
      a !== n.preference && e.push(a);
    })) : e = OH.slice();
    let t, r = {};
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      if (s === "webgpu" && await Eft()) {
        const { WebGPURenderer: o } = await $g(async () => {
          const { WebGPURenderer: l } = await import("./WebGPURenderer-DgUAOQ9Y.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            WebGPURenderer: l
          };
        }, __vite__mapDeps([6,2,7,3,4,5]));
        t = o, r = {
          ...n,
          ...n.webgpu
        };
        break;
      } else if (s === "webgl" && Nft(n.failIfMajorPerformanceCaveat ?? Nie.defaultOptions.failIfMajorPerformanceCaveat)) {
        const { WebGLRenderer: o } = await $g(async () => {
          const { WebGLRenderer: l } = await import("./WebGLRenderer-Cn8uWgK9.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            WebGLRenderer: l
          };
        }, __vite__mapDeps([8,2,7,4,5]));
        t = o, r = {
          ...n,
          ...n.webgl
        };
        break;
      } else if (s === "canvas") throw r = {
        ...n
      }, new Error("CanvasRenderer is not yet implemented");
    }
    if (delete r.webgpu, delete r.webgl, !t) throw new Error("No available renderer for the current environment");
    const i = new t();
    return await i.init(r), i;
  }
  Eie = "8.8.0";
  class Mie {
    static init() {
      var _a2;
      (_a2 = globalThis.__PIXI_APP_INIT__) == null ? void 0 : _a2.call(globalThis, this, Eie);
    }
    static destroy() {
    }
  }
  Mie.extension = Nn.Application;
  Pft = class {
    constructor(e) {
      this._renderer = e;
    }
    init() {
      var _a2;
      (_a2 = globalThis.__PIXI_RENDERER_INIT__) == null ? void 0 : _a2.call(globalThis, this._renderer, Eie);
    }
    destroy() {
      this._renderer = null;
    }
  };
  Pft.extension = {
    type: [
      Nn.WebGLSystem,
      Nn.WebGPUSystem
    ],
    name: "initHook",
    priority: -10
  };
  const Pie = class rN {
    constructor(...e) {
      this.stage = new yp(), e[0] !== void 0 && Gn(or, "Application constructor options are deprecated, please use Application.init() instead.");
    }
    async init(e) {
      e = {
        ...e
      }, this.renderer = await Mft(e), rN._plugins.forEach((t) => {
        t.init.call(this, e);
      });
    }
    render() {
      this.renderer.render({
        container: this.stage
      });
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      return Gn(or, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(e = false, t = false) {
      const r = rN._plugins.slice(0);
      r.reverse(), r.forEach((i) => {
        i.destroy.call(this);
      }), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null;
    }
  };
  Pie._plugins = [];
  let Lie = Pie;
  $s.handleByList(Nn.Application, Lie._plugins);
  $s.add(Mie);
  const BH = [
    {
      offset: 0,
      color: "white"
    },
    {
      offset: 1,
      color: "black"
    }
  ], XL = class iN {
    constructor(...e) {
      this.uid = Dr("fillGradient"), this.type = "linear", this.colorStops = [];
      let t = Lft(e);
      t = {
        ...t.type === "radial" ? iN.defaultRadialOptions : iN.defaultLinearOptions,
        ...Xre(t)
      }, this._textureSize = t.textureSize, t.type === "radial" ? (this.center = t.center, this.outerCenter = t.outerCenter ?? this.center, this.innerRadius = t.innerRadius, this.outerRadius = t.outerRadius, this.scale = t.scale, this.rotation = t.rotation) : (this.start = t.start, this.end = t.end), this.textureSpace = t.textureSpace, this.type = t.type, t.colorStops.forEach((i) => {
        this.addColorStop(i.offset, i.color);
      });
    }
    addColorStop(e, t) {
      return this.colorStops.push({
        offset: e,
        color: Ei.shared.setValue(t).toHexa()
      }), this;
    }
    buildLinearGradient() {
      if (this.texture) return;
      const e = this.colorStops.length ? this.colorStops : BH, t = this._textureSize, { canvas: r, context: i } = VH(t, 1), a = i.createLinearGradient(0, 0, this._textureSize, 0);
      zH(a, e), i.fillStyle = a, i.fillRect(0, 0, t, 1), this.texture = new Fn({
        source: new rC({
          resource: r
        })
      });
      const { x: s, y: o } = this.start, { x: l, y: u } = this.end, c = new pn(), h = l - s, d = u - o, f = Math.sqrt(h * h + d * d), p = Math.atan2(d, h);
      c.scale(f / t, 1), c.rotate(p), c.translate(s, o), this.textureSpace === "local" && c.scale(t, t), this.transform = c;
    }
    buildGradient() {
      this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
    }
    buildRadialGradient() {
      if (this.texture) return;
      const e = this.colorStops.length ? this.colorStops : BH, t = this._textureSize, { canvas: r, context: i } = VH(t, t), { x: a, y: s } = this.center, { x: o, y: l } = this.outerCenter, u = this.innerRadius, c = this.outerRadius, h = o - c, d = l - c, f = t / (c * 2), p = (a - h) * f, g = (s - d) * f, m = i.createRadialGradient(p, g, u * f, (o - h) * f, (l - d) * f, c * f);
      zH(m, e), i.fillStyle = e[e.length - 1].color, i.fillRect(0, 0, t, t), i.fillStyle = m, i.translate(p, g), i.rotate(this.rotation), i.scale(1, this.scale), i.translate(-p, -g), i.fillRect(0, 0, t, t), this.texture = new Fn({
        source: new rC({
          resource: r,
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        })
      });
      const v = new pn();
      v.scale(1 / f, 1 / f), v.translate(h, d), this.textureSpace === "local" && v.scale(t, t), this.transform = v;
    }
    get styleKey() {
      return this.uid;
    }
    destroy() {
      var _a2;
      (_a2 = this.texture) == null ? void 0 : _a2.destroy(true), this.texture = null;
    }
  };
  XL.defaultLinearOptions = {
    start: {
      x: 0,
      y: 0
    },
    end: {
      x: 0,
      y: 1
    },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256
  };
  XL.defaultRadialOptions = {
    center: {
      x: 0.5,
      y: 0.5
    },
    innerRadius: 0,
    outerRadius: 0.5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256
  };
  Nd = XL;
  function zH(n, e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      n.addColorStop(r.offset, r.color);
    }
  }
  function VH(n, e) {
    const t = to.get().createCanvas(n, e), r = t.getContext("2d");
    return {
      canvas: t,
      context: r
    };
  }
  function Lft(n) {
    let e = n[0] ?? {};
    return (typeof e == "number" || n[1]) && (Gn("8.5.2", "use options object instead"), e = {
      type: "linear",
      start: {
        x: n[0],
        y: n[1]
      },
      end: {
        x: n[2],
        y: n[3]
      },
      textureSpace: n[4],
      textureSize: n[5] ?? Nd.defaultLinearOptions.textureSize
    }), e;
  }
  const WH = {
    repeat: {
      addressModeU: "repeat",
      addressModeV: "repeat"
    },
    "repeat-x": {
      addressModeU: "repeat",
      addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
      addressModeU: "clamp-to-edge",
      addressModeV: "repeat"
    },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  YL = class {
    constructor(e, t) {
      this.uid = Dr("fillPattern"), this.transform = new pn(), this._styleKey = null, this.texture = e, this.transform.scale(1 / e.frame.width, 1 / e.frame.height), t && (e.source.style.addressModeU = WH[t].addressModeU, e.source.style.addressModeV = WH[t].addressModeV);
    }
    setTransform(e) {
      const t = this.texture;
      this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(1 / t.frame.width, 1 / t.frame.height), this._styleKey = null;
    }
    get styleKey() {
      return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey);
    }
  };
  var HA, GH;
  function Fft() {
    if (GH) return HA;
    GH = 1, HA = t;
    var n = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0
    }, e = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function t(a) {
      var s = [];
      return a.replace(e, function(o, l, u) {
        var c = l.toLowerCase();
        for (u = i(u), c == "m" && u.length > 2 && (s.push([
          l
        ].concat(u.splice(0, 2))), c = "l", l = l == "m" ? "l" : "L"); ; ) {
          if (u.length == n[c]) return u.unshift(l), s.push(u);
          if (u.length < n[c]) throw new Error("malformed path data");
          s.push([
            l
          ].concat(u.splice(0, n[c])));
        }
      }), s;
    }
    var r = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function i(a) {
      var s = a.match(r);
      return s ? s.map(Number) : [];
    }
    return HA;
  }
  var Oft = Fft();
  const Bft = _v(Oft);
  function zft(n, e) {
    const t = Bft(n), r = [];
    let i = null, a = 0, s = 0;
    for (let o = 0; o < t.length; o++) {
      const l = t[o], u = l[0], c = l;
      switch (u) {
        case "M":
          a = c[1], s = c[2], e.moveTo(a, s);
          break;
        case "m":
          a += c[1], s += c[2], e.moveTo(a, s);
          break;
        case "H":
          a = c[1], e.lineTo(a, s);
          break;
        case "h":
          a += c[1], e.lineTo(a, s);
          break;
        case "V":
          s = c[1], e.lineTo(a, s);
          break;
        case "v":
          s += c[1], e.lineTo(a, s);
          break;
        case "L":
          a = c[1], s = c[2], e.lineTo(a, s);
          break;
        case "l":
          a += c[1], s += c[2], e.lineTo(a, s);
          break;
        case "C":
          a = c[5], s = c[6], e.bezierCurveTo(c[1], c[2], c[3], c[4], a, s);
          break;
        case "c":
          e.bezierCurveTo(a + c[1], s + c[2], a + c[3], s + c[4], a + c[5], s + c[6]), a += c[5], s += c[6];
          break;
        case "S":
          a = c[3], s = c[4], e.bezierCurveToShort(c[1], c[2], a, s);
          break;
        case "s":
          e.bezierCurveToShort(a + c[1], s + c[2], a + c[3], s + c[4]), a += c[3], s += c[4];
          break;
        case "Q":
          a = c[3], s = c[4], e.quadraticCurveTo(c[1], c[2], a, s);
          break;
        case "q":
          e.quadraticCurveTo(a + c[1], s + c[2], a + c[3], s + c[4]), a += c[3], s += c[4];
          break;
        case "T":
          a = c[1], s = c[2], e.quadraticCurveToShort(a, s);
          break;
        case "t":
          a += c[1], s += c[2], e.quadraticCurveToShort(a, s);
          break;
        case "A":
          a = c[6], s = c[7], e.arcToSvg(c[1], c[2], c[3], c[4], c[5], a, s);
          break;
        case "a":
          a += c[6], s += c[7], e.arcToSvg(c[1], c[2], c[3], c[4], c[5], a, s);
          break;
        case "Z":
        case "z":
          e.closePath(), r.length > 0 && (i = r.pop(), i ? (a = i.startX, s = i.startY) : (a = 0, s = 0)), i = null;
          break;
        default:
          Ua(`Unknown SVG path command: ${u}`);
      }
      u !== "Z" && u !== "z" && i === null && (i = {
        startX: a,
        startY: s
      }, r.push(i));
    }
    return e;
  }
  class qL {
    constructor(e = 0, t = 0, r = 0) {
      this.type = "circle", this.x = e, this.y = t, this.radius = r;
    }
    clone() {
      return new qL(this.x, this.y, this.radius);
    }
    contains(e, t) {
      if (this.radius <= 0) return false;
      const r = this.radius * this.radius;
      let i = this.x - e, a = this.y - t;
      return i *= i, a *= a, i + a <= r;
    }
    strokeContains(e, t, r, i = 0.5) {
      if (this.radius === 0) return false;
      const a = this.x - e, s = this.y - t, o = this.radius, l = (1 - i) * r, u = Math.sqrt(a * a + s * s);
      return u <= o + l && u > o - (r - l);
    }
    getBounds(e) {
      return e || (e = new ri()), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.radius = e.radius, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  }
  class jL {
    constructor(e = 0, t = 0, r = 0, i = 0) {
      this.type = "ellipse", this.x = e, this.y = t, this.halfWidth = r, this.halfHeight = i;
    }
    clone() {
      return new jL(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(e, t) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;
      let r = (e - this.x) / this.halfWidth, i = (t - this.y) / this.halfHeight;
      return r *= r, i *= i, r + i <= 1;
    }
    strokeContains(e, t, r, i = 0.5) {
      const { halfWidth: a, halfHeight: s } = this;
      if (a <= 0 || s <= 0) return false;
      const o = r * (1 - i), l = r - o, u = a - l, c = s - l, h = a + o, d = s + o, f = e - this.x, p = t - this.y, g = f * f / (u * u) + p * p / (c * c), m = f * f / (h * h) + p * p / (d * d);
      return g > 1 && m <= 1;
    }
    getBounds(e) {
      return e || (e = new ri()), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e;
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  }
  function Vft(n, e, t, r, i, a) {
    const s = n - t, o = e - r, l = i - t, u = a - r, c = s * l + o * u, h = l * l + u * u;
    let d = -1;
    h !== 0 && (d = c / h);
    let f, p;
    d < 0 ? (f = t, p = r) : d > 1 ? (f = i, p = a) : (f = t + d * l, p = r + d * u);
    const g = n - f, m = e - p;
    return g * g + m * m;
  }
  let Wft, Gft;
  class x0 {
    constructor(...e) {
      this.type = "polygon";
      let t = Array.isArray(e[0]) ? e[0] : e;
      if (typeof t[0] != "number") {
        const r = [];
        for (let i = 0, a = t.length; i < a; i++) r.push(t[i].x, t[i].y);
        t = r;
      }
      this.points = t, this.closePath = true;
    }
    isClockwise() {
      let e = 0;
      const t = this.points, r = t.length;
      for (let i = 0; i < r; i += 2) {
        const a = t[i], s = t[i + 1], o = t[(i + 2) % r], l = t[(i + 3) % r];
        e += (o - a) * (l + s);
      }
      return e < 0;
    }
    containsPolygon(e) {
      const t = this.getBounds(Wft), r = e.getBounds(Gft);
      if (!t.containsRect(r)) return false;
      const i = e.points;
      for (let a = 0; a < i.length; a += 2) {
        const s = i[a], o = i[a + 1];
        if (!this.contains(s, o)) return false;
      }
      return true;
    }
    clone() {
      const e = this.points.slice(), t = new x0(e);
      return t.closePath = this.closePath, t;
    }
    contains(e, t) {
      let r = false;
      const i = this.points.length / 2;
      for (let a = 0, s = i - 1; a < i; s = a++) {
        const o = this.points[a * 2], l = this.points[a * 2 + 1], u = this.points[s * 2], c = this.points[s * 2 + 1];
        l > t != c > t && e < (u - o) * ((t - l) / (c - l)) + o && (r = !r);
      }
      return r;
    }
    strokeContains(e, t, r, i = 0.5) {
      const a = r * r, s = a * (1 - i), o = a - s, { points: l } = this, u = l.length - (this.closePath ? 0 : 2);
      for (let c = 0; c < u; c += 2) {
        const h = l[c], d = l[c + 1], f = l[(c + 2) % l.length], p = l[(c + 3) % l.length], g = Vft(e, t, h, d, f, p), m = Math.sign((f - h) * (t - d) - (p - d) * (e - h));
        if (g <= (m < 0 ? o : s)) return true;
      }
      return false;
    }
    getBounds(e) {
      e || (e = new ri());
      const t = this.points;
      let r = 1 / 0, i = -1 / 0, a = 1 / 0, s = -1 / 0;
      for (let o = 0, l = t.length; o < l; o += 2) {
        const u = t[o], c = t[o + 1];
        r = u < r ? u : r, i = u > i ? u : i, a = c < a ? c : a, s = c > s ? c : s;
      }
      return e.x = r, e.width = i - r, e.y = a, e.height = s - a, e;
    }
    copyFrom(e) {
      return this.points = e.points.slice(), this.closePath = e.closePath, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, t) => `${e}, ${t}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      return this.points[this.points.length - 2];
    }
    get y() {
      return this.points[this.points.length - 1];
    }
  }
  const Fw = (n, e, t, r, i, a, s) => {
    const o = n - t, l = e - r, u = Math.sqrt(o * o + l * l);
    return u >= i - a && u <= i + s;
  };
  class KL {
    constructor(e = 0, t = 0, r = 0, i = 0, a = 20) {
      this.type = "roundedRectangle", this.x = e, this.y = t, this.width = r, this.height = i, this.radius = a;
    }
    getBounds(e) {
      return e || (e = new ri()), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
    }
    clone() {
      return new KL(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(e) {
      return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    contains(e, t) {
      if (this.width <= 0 || this.height <= 0) return false;
      if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
        const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (t >= this.y + r && t <= this.y + this.height - r || e >= this.x + r && e <= this.x + this.width - r) return true;
        let i = e - (this.x + r), a = t - (this.y + r);
        const s = r * r;
        if (i * i + a * a <= s || (i = e - (this.x + this.width - r), i * i + a * a <= s) || (a = t - (this.y + this.height - r), i * i + a * a <= s) || (i = e - (this.x + r), i * i + a * a <= s)) return true;
      }
      return false;
    }
    strokeContains(e, t, r, i = 0.5) {
      const { x: a, y: s, width: o, height: l, radius: u } = this, c = r * (1 - i), h = r - c, d = a + u, f = s + u, p = o - u * 2, g = l - u * 2, m = a + o, v = s + l;
      return (e >= a - c && e <= a + h || e >= m - h && e <= m + c) && t >= f && t <= f + g || (t >= s - c && t <= s + h || t >= v - h && t <= v + c) && e >= d && e <= d + p ? true : e < d && t < f && Fw(e, t, d, f, u, h, c) || e > m - u && t < f && Fw(e, t, m - u, f, u, h, c) || e > m - u && t > v - u && Fw(e, t, m - u, v - u, u, h, c) || e < d && t > v - u && Fw(e, t, d, v - u, u, h, c);
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }
  const Uft = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}"
  ].join(`
`);
  function Hft(n) {
    let e = "";
    for (let t = 0; t < n; ++t) t > 0 && (e += `
else `), t < n - 1 && (e += `if(test == ${t}.0){}`);
    return e;
  }
  function Xft(n, e) {
    if (n === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const t = e.createShader(e.FRAGMENT_SHADER);
    try {
      for (; ; ) {
        const r = Uft.replace(/%forloop%/gi, Hft(n));
        if (e.shaderSource(t, r), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS)) n = n / 2 | 0;
        else break;
      }
    } finally {
      e.deleteShader(t);
    }
    return n;
  }
  let Qp = null;
  Fie = function() {
    var _a2;
    if (Qp) return Qp;
    const n = _ie();
    return Qp = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), Qp = Xft(Qp, n), (_a2 = n.getExtension("WEBGL_lose_context")) == null ? void 0 : _a2.loseContext(), Qp;
  };
  const Oie = {};
  Yft = function(n, e) {
    let t = 2166136261;
    for (let r = 0; r < e; r++) t ^= n[r].uid, t = Math.imul(t, 16777619), t >>>= 0;
    return Oie[t] || qft(n, e, t);
  };
  let XA = 0;
  function qft(n, e, t) {
    const r = {};
    let i = 0;
    XA || (XA = Fie());
    for (let s = 0; s < XA; s++) {
      const o = s < e ? n[s] : Fn.EMPTY.source;
      r[i++] = o.source, r[i++] = o.style;
    }
    const a = new T_(r);
    return Oie[t] = a, a;
  }
  UH = class {
    constructor(e) {
      typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
    }
    get int8View() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    }
    get uint8View() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    }
    get int16View() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    }
    get int32View() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    }
    get float64View() {
      return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
    }
    get bigUint64View() {
      return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
    }
    view(e) {
      return this[`${e}View`];
    }
    destroy() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }
    static sizeOf(e) {
      switch (e) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${e} isn't a valid view type`);
      }
    }
  };
  HH = function(n, e) {
    const t = n.byteLength / 8 | 0, r = new Float64Array(n, 0, t);
    new Float64Array(e, 0, t).set(r);
    const a = n.byteLength - t * 8;
    if (a > 0) {
      const s = new Uint8Array(n, t * 8, a);
      new Uint8Array(e, t * 8, a).set(s);
    }
  };
  const jft = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
  };
  Kft = ((n) => (n[n.DISABLED = 0] = "DISABLED", n[n.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", n[n.MASK_ACTIVE = 2] = "MASK_ACTIVE", n[n.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", n[n.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", n[n.NONE = 5] = "NONE", n))(Kft || {});
  XH = function(n, e) {
    return e.alphaMode === "no-premultiply-alpha" && jft[n] || n;
  };
  class Zft {
    constructor() {
      this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
    }
    clear() {
      for (let e = 0; e < this.count; e++) {
        const t = this.textures[e];
        this.textures[e] = null, this.ids[t.uid] = null;
      }
      this.count = 0;
    }
  }
  class Qft {
    constructor() {
      this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new Zft(), this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = true;
    }
    destroy() {
      this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
    }
  }
  const Bie = [];
  let aN = 0;
  function YH() {
    return aN > 0 ? Bie[--aN] : new Qft();
  }
  function qH(n) {
    Bie[aN++] = n;
  }
  let Iy = 0;
  const zie = class A_ {
    constructor(e = {}) {
      this.uid = Dr("batcher"), this.dirty = true, this.batchIndex = 0, this.batches = [], this._elements = [], A_.defaultOptions.maxTextures = A_.defaultOptions.maxTextures ?? Fie(), e = {
        ...A_.defaultOptions,
        ...e
      };
      const { maxTextures: t, attributesInitialSize: r, indicesInitialSize: i } = e;
      this.attributeBuffer = new UH(r * 4), this.indexBuffer = new Uint16Array(i), this.maxTextures = t;
    }
    begin() {
      this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
      for (let e = 0; e < this.batchIndex; e++) qH(this.batches[e]);
      this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = true;
    }
    add(e) {
      this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize;
    }
    checkAndUpdateTexture(e, t) {
      const r = e._batch.textures.ids[t._source.uid];
      return !r && r !== 0 ? false : (e._textureId = r, e.texture = t, true);
    }
    updateElement(e) {
      this.dirty = true;
      const t = this.attributeBuffer;
      e.packAsQuad ? this.packQuadAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId);
    }
    break(e) {
      const t = this._elements;
      if (!t[this.elementStart]) return;
      let r = YH(), i = r.textures;
      i.clear();
      const a = t[this.elementStart];
      let s = XH(a.blendMode, a.texture._source), o = a.topology;
      this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
      const l = this.attributeBuffer.float32View, u = this.attributeBuffer.uint32View, c = this.indexBuffer;
      let h = this._batchIndexSize, d = this._batchIndexStart, f = "startBatch";
      const p = this.maxTextures;
      for (let g = this.elementStart; g < this.elementSize; ++g) {
        const m = t[g];
        t[g] = null;
        const y = m.texture._source, x = XH(m.blendMode, y), b = s !== x || o !== m.topology;
        if (y._batchTick === Iy && !b) {
          m._textureId = y._textureBindLocation, h += m.indexSize, m.packAsQuad ? (this.packQuadAttributes(m, l, u, m._attributeStart, m._textureId), this.packQuadIndex(c, m._indexStart, m._attributeStart / this.vertexSize)) : (this.packAttributes(m, l, u, m._attributeStart, m._textureId), this.packIndex(m, c, m._indexStart, m._attributeStart / this.vertexSize)), m._batch = r;
          continue;
        }
        y._batchTick = Iy, (i.count >= p || b) && (this._finishBatch(r, d, h - d, i, s, o, e, f), f = "renderBatch", d = h, s = x, o = m.topology, r = YH(), i = r.textures, i.clear(), ++Iy), m._textureId = y._textureBindLocation = i.count, i.ids[y.uid] = i.count, i.textures[i.count++] = y, m._batch = r, h += m.indexSize, m.packAsQuad ? (this.packQuadAttributes(m, l, u, m._attributeStart, m._textureId), this.packQuadIndex(c, m._indexStart, m._attributeStart / this.vertexSize)) : (this.packAttributes(m, l, u, m._attributeStart, m._textureId), this.packIndex(m, c, m._indexStart, m._attributeStart / this.vertexSize));
      }
      i.count > 0 && (this._finishBatch(r, d, h - d, i, s, o, e, f), d = h, ++Iy), this.elementStart = this.elementSize, this._batchIndexStart = d, this._batchIndexSize = h;
    }
    _finishBatch(e, t, r, i, a, s, o, l) {
      e.gpuBindGroup = null, e.bindGroup = null, e.action = l, e.batcher = this, e.textures = i, e.blendMode = a, e.topology = s, e.start = t, e.size = r, ++Iy, this.batches[this.batchIndex++] = e, o.add(e);
    }
    finish(e) {
      this.break(e);
    }
    ensureAttributeBuffer(e) {
      e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4);
    }
    ensureIndexBuffer(e) {
      e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
    }
    _resizeAttributeBuffer(e) {
      const t = Math.max(e, this.attributeBuffer.size * 2), r = new UH(t);
      HH(this.attributeBuffer.rawBinaryData, r.rawBinaryData), this.attributeBuffer = r;
    }
    _resizeIndexBuffer(e) {
      const t = this.indexBuffer;
      let r = Math.max(e, t.length * 1.5);
      r += r % 2;
      const i = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
      if (i.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT) for (let a = 0; a < t.length; a++) i[a] = t[a];
      else HH(t.buffer, i.buffer);
      this.indexBuffer = i;
    }
    packQuadIndex(e, t, r) {
      e[t] = r + 0, e[t + 1] = r + 1, e[t + 2] = r + 2, e[t + 3] = r + 0, e[t + 4] = r + 2, e[t + 5] = r + 3;
    }
    packIndex(e, t, r, i) {
      const a = e.indices, s = e.indexSize, o = e.indexOffset, l = e.attributeOffset;
      for (let u = 0; u < s; u++) t[r++] = i + a[u + o] - l;
    }
    destroy() {
      for (let e = 0; e < this.batches.length; e++) qH(this.batches[e]);
      this.batches = null;
      for (let e = 0; e < this._elements.length; e++) this._elements[e]._batch = null;
      this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
    }
  };
  zie.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6
  };
  let Jft = zie;
  xa = ((n) => (n[n.MAP_READ = 1] = "MAP_READ", n[n.MAP_WRITE = 2] = "MAP_WRITE", n[n.COPY_SRC = 4] = "COPY_SRC", n[n.COPY_DST = 8] = "COPY_DST", n[n.INDEX = 16] = "INDEX", n[n.VERTEX = 32] = "VERTEX", n[n.UNIFORM = 64] = "UNIFORM", n[n.STORAGE = 128] = "STORAGE", n[n.INDIRECT = 256] = "INDIRECT", n[n.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", n[n.STATIC = 1024] = "STATIC", n))(xa || {});
  _x = class extends fl {
    constructor(e) {
      let { data: t, size: r } = e;
      const { usage: i, label: a, shrinkToFit: s } = e;
      super(), this.uid = Dr("buffer"), this._resourceType = "buffer", this._resourceId = Dr("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = true, this.destroyed = false, t instanceof Array && (t = new Float32Array(t)), this._data = t, r ?? (r = t == null ? void 0 : t.byteLength);
      const o = !!t;
      this.descriptor = {
        size: r,
        usage: i,
        mappedAtCreation: o,
        label: a
      }, this.shrinkToFit = s ?? true;
    }
    get data() {
      return this._data;
    }
    set data(e) {
      this.setDataWithSize(e, e.length, true);
    }
    get dataInt32() {
      return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
    }
    get static() {
      return !!(this.descriptor.usage & xa.STATIC);
    }
    set static(e) {
      e ? this.descriptor.usage |= xa.STATIC : this.descriptor.usage &= ~xa.STATIC;
    }
    setDataWithSize(e, t, r) {
      if (this._updateID++, this._updateSize = t * e.BYTES_PER_ELEMENT, this._data === e) {
        r && this.emit("update", this);
        return;
      }
      const i = this._data;
      if (this._data = e, this._dataInt32 = null, !i || i.length !== e.length) {
        !this.shrinkToFit && i && e.byteLength < i.byteLength ? r && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = Dr("resource"), this.emit("change", this));
        return;
      }
      r && this.emit("update", this);
    }
    update(e) {
      this._updateSize = e ?? this._updateSize, this._updateID++, this.emit("update", this);
    }
    destroy() {
      this.destroyed = true, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
    }
  };
  function Vie(n, e) {
    if (!(n instanceof _x)) {
      let t = e ? xa.INDEX : xa.VERTEX;
      n instanceof Array && (e ? (n = new Uint32Array(n), t = xa.INDEX | xa.COPY_DST) : (n = new Float32Array(n), t = xa.VERTEX | xa.COPY_DST)), n = new _x({
        data: n,
        label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
        usage: t
      });
    }
    return n;
  }
  function ept(n, e, t) {
    const r = n.getAttribute(e);
    if (!r) return t.minX = 0, t.minY = 0, t.maxX = 0, t.maxY = 0, t;
    const i = r.buffer.data;
    let a = 1 / 0, s = 1 / 0, o = -1 / 0, l = -1 / 0;
    const u = i.BYTES_PER_ELEMENT, c = (r.offset || 0) / u, h = (r.stride || 2 * 4) / u;
    for (let d = c; d < i.length; d += h) {
      const f = i[d], p = i[d + 1];
      f > o && (o = f), p > l && (l = p), f < a && (a = f), p < s && (s = p);
    }
    return t.minX = a, t.minY = s, t.maxX = o, t.maxY = l, t;
  }
  function tpt(n) {
    return (n instanceof _x || Array.isArray(n) || n.BYTES_PER_ELEMENT) && (n = {
      buffer: n
    }), n.buffer = Vie(n.buffer, false), n;
  }
  npt = class extends fl {
    constructor(e = {}) {
      super(), this.uid = Dr("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new co(), this._boundsDirty = true;
      const { attributes: t, indexBuffer: r, topology: i } = e;
      if (this.buffers = [], this.attributes = {}, t) for (const a in t) this.addAttribute(a, t[a]);
      this.instanceCount = e.instanceCount ?? 1, r && this.addIndex(r), this.topology = i || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = true, this.emit("update", this);
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(e) {
      return this.getAttribute(e).buffer;
    }
    getSize() {
      for (const e in this.attributes) {
        const t = this.attributes[e];
        return t.buffer.data.length / (t.stride / 4 || t.size);
      }
      return 0;
    }
    addAttribute(e, t) {
      const r = tpt(t);
      this.buffers.indexOf(r.buffer) === -1 && (this.buffers.push(r.buffer), r.buffer.on("update", this.onBufferUpdate, this), r.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = r;
    }
    addIndex(e) {
      this.indexBuffer = Vie(e, true), this.buffers.push(this.indexBuffer);
    }
    get bounds() {
      return this._boundsDirty ? (this._boundsDirty = false, ept(this, "aPosition", this._bounds)) : this._bounds;
    }
    destroy(e = false) {
      this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach((t) => t.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
    }
  };
  const rpt = new Float32Array(1), ipt = new Uint32Array(1);
  class apt extends npt {
    constructor() {
      const t = new _x({
        data: rpt,
        label: "attribute-batch-buffer",
        usage: xa.VERTEX | xa.COPY_DST,
        shrinkToFit: false
      }), r = new _x({
        data: ipt,
        label: "index-batch-buffer",
        usage: xa.INDEX | xa.COPY_DST,
        shrinkToFit: false
      }), i = 6 * 4;
      super({
        attributes: {
          aPosition: {
            buffer: t,
            format: "float32x2",
            stride: i,
            offset: 0
          },
          aUV: {
            buffer: t,
            format: "float32x2",
            stride: i,
            offset: 2 * 4
          },
          aColor: {
            buffer: t,
            format: "unorm8x4",
            stride: i,
            offset: 4 * 4
          },
          aTextureIdAndRound: {
            buffer: t,
            format: "uint16x2",
            stride: i,
            offset: 5 * 4
          }
        },
        indexBuffer: r
      });
    }
  }
  function jH(n, e, t) {
    if (n) for (const r in n) {
      const i = r.toLocaleLowerCase(), a = e[i];
      if (a) {
        let s = n[r];
        r === "header" && (s = s.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), t && a.push(`//----${t}----//`), a.push(s);
      } else Ua(`${r} placement hook does not exist in shader`);
    }
  }
  const spt = /\{\{(.*?)\}\}/g;
  function KH(n) {
    var _a2;
    const e = {};
    return (((_a2 = n.match(spt)) == null ? void 0 : _a2.map((r) => r.replace(/[{()}]/g, ""))) ?? []).forEach((r) => {
      e[r] = [];
    }), e;
  }
  function ZH(n, e) {
    let t;
    const r = /@in\s+([^;]+);/g;
    for (; (t = r.exec(n)) !== null; ) e.push(t[1]);
  }
  function QH(n, e, t = false) {
    const r = [];
    ZH(e, r), n.forEach((o) => {
      o.header && ZH(o.header, r);
    });
    const i = r;
    t && i.sort();
    const a = i.map((o, l) => `       @location(${l}) ${o},`).join(`
`);
    let s = e.replace(/@in\s+[^;]+;\s*/g, "");
    return s = s.replace("{{in}}", `
${a}
`), s;
  }
  function JH(n, e) {
    let t;
    const r = /@out\s+([^;]+);/g;
    for (; (t = r.exec(n)) !== null; ) e.push(t[1]);
  }
  function opt(n) {
    const t = /\b(\w+)\s*:/g.exec(n);
    return t ? t[1] : "";
  }
  function lpt(n) {
    const e = /@.*?\s+/g;
    return n.replace(e, "");
  }
  function upt(n, e) {
    const t = [];
    JH(e, t), n.forEach((l) => {
      l.header && JH(l.header, t);
    });
    let r = 0;
    const i = t.sort().map((l) => l.indexOf("builtin") > -1 ? l : `@location(${r++}) ${l}`).join(`,
`), a = t.sort().map((l) => `       var ${lpt(l)};`).join(`
`), s = `return VSOutput(
            ${t.sort().map((l) => ` ${opt(l)}`).join(`,
`)});`;
    let o = e.replace(/@out\s+[^;]+;\s*/g, "");
    return o = o.replace("{{struct}}", `
${i}
`), o = o.replace("{{start}}", `
${a}
`), o = o.replace("{{return}}", `
${s}
`), o;
  }
  function e5(n, e) {
    let t = n;
    for (const r in e) {
      const i = e[r];
      i.join(`
`).length ? t = t.replace(`{{${r}}}`, `//-----${r} START-----//
${i.join(`
`)}
//----${r} FINISH----//`) : t = t.replace(`{{${r}}}`, "");
    }
    return t;
  }
  const Uu = /* @__PURE__ */ Object.create(null), YA = /* @__PURE__ */ new Map();
  let cpt = 0;
  function hpt({ template: n, bits: e }) {
    const t = Wie(n, e);
    if (Uu[t]) return Uu[t];
    const { vertex: r, fragment: i } = fpt(n, e);
    return Uu[t] = Gie(r, i, e), Uu[t];
  }
  function dpt({ template: n, bits: e }) {
    const t = Wie(n, e);
    return Uu[t] || (Uu[t] = Gie(n.vertex, n.fragment, e)), Uu[t];
  }
  function fpt(n, e) {
    const t = e.map((s) => s.vertex).filter((s) => !!s), r = e.map((s) => s.fragment).filter((s) => !!s);
    let i = QH(t, n.vertex, true);
    i = upt(t, i);
    const a = QH(r, n.fragment, true);
    return {
      vertex: i,
      fragment: a
    };
  }
  function Wie(n, e) {
    return e.map((t) => (YA.has(t) || YA.set(t, cpt++), YA.get(t))).sort((t, r) => t - r).join("-") + n.vertex + n.fragment;
  }
  function Gie(n, e, t) {
    const r = KH(n), i = KH(e);
    return t.forEach((a) => {
      jH(a.vertex, r, a.name), jH(a.fragment, i, a.name);
    }), {
      vertex: e5(n, r),
      fragment: e5(e, i)
    };
  }
  const ppt = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, gpt = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, mpt = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, vpt = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`, ypt = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    }
  }, xpt = {
    name: "global-uniforms-bit",
    vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    }
  };
  bpt = function({ bits: n, name: e }) {
    const t = hpt({
      template: {
        fragment: gpt,
        vertex: ppt
      },
      bits: [
        ypt,
        ...n
      ]
    });
    return m2.from({
      name: e,
      vertex: {
        source: t.vertex,
        entryPoint: "main"
      },
      fragment: {
        source: t.fragment,
        entryPoint: "main"
      }
    });
  };
  wpt = function({ bits: n, name: e }) {
    return new Cie({
      name: e,
      ...dpt({
        template: {
          vertex: mpt,
          fragment: vpt
        },
        bits: [
          xpt,
          ...n
        ]
      })
    });
  };
  let qA;
  _pt = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  Spt = {
    name: "color-bit",
    vertex: {
      header: `
            in vec4 aColor;
        `,
      main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    }
  };
  qA = {};
  function Cpt(n) {
    const e = [];
    if (n === 1) e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
      let t = 0;
      for (let r = 0; r < n; r++) e.push(`@group(1) @binding(${t++}) var textureSource${r + 1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${t++}) var textureSampler${r + 1}: sampler;`);
    }
    return e.join(`
`);
  }
  function Ipt(n) {
    const e = [];
    if (n === 1) e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
      e.push("switch vTextureId {");
      for (let t = 0; t < n; t++) t === n - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`), e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`), e.push("      break;}");
      e.push("}");
    }
    return e.join(`
`);
  }
  kpt = function(n) {
    return qA[n] || (qA[n] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${Cpt(n)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${Ipt(n)}
            `
      }
    }), qA[n];
  };
  const jA = {};
  function Tpt(n) {
    const e = [];
    for (let t = 0; t < n; t++) t > 0 && e.push("else"), t < n - 1 && e.push(`if(vTextureId < ${t}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${t}], vUV);`), e.push("}");
    return e.join(`
`);
  }
  Apt = function(n) {
    return jA[n] || (jA[n] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${n}];

            `,
        main: `

                ${Tpt(n)}
            `
      }
    }), jA[n];
  };
  let t5;
  Dpt = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  Rpt = {
    name: "round-pixels-bit",
    vertex: {
      header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    }
  };
  t5 = {};
  $pt = function(n) {
    let e = t5[n];
    if (e) return e;
    const t = new Int32Array(n);
    for (let r = 0; r < n; r++) t[r] = r;
    return e = t5[n] = new Aie({
      uTextures: {
        value: t,
        type: "i32",
        size: n
      }
    }, {
      isStatic: true
    }), e;
  };
  class Npt extends HL {
    constructor(e) {
      const t = wpt({
        name: "batch",
        bits: [
          Spt,
          Apt(e),
          Rpt
        ]
      }), r = bpt({
        name: "batch",
        bits: [
          _pt,
          kpt(e),
          Dpt
        ]
      });
      super({
        glProgram: t,
        gpuProgram: r,
        resources: {
          batchSamplers: $pt(e)
        }
      });
    }
  }
  let n5 = null;
  const Uie = class Hie extends Jft {
    constructor() {
      super(...arguments), this.geometry = new apt(), this.shader = n5 || (n5 = new Npt(this.maxTextures)), this.name = Hie.extension.name, this.vertexSize = 6;
    }
    packAttributes(e, t, r, i, a) {
      const s = a << 16 | e.roundPixels & 65535, o = e.transform, l = o.a, u = o.b, c = o.c, h = o.d, d = o.tx, f = o.ty, { positions: p, uvs: g } = e, m = e.color, v = e.attributeOffset, y = v + e.attributeSize;
      for (let x = v; x < y; x++) {
        const b = x * 2, w = p[b], _ = p[b + 1];
        t[i++] = l * w + c * _ + d, t[i++] = h * _ + u * w + f, t[i++] = g[b], t[i++] = g[b + 1], r[i++] = m, r[i++] = s;
      }
    }
    packQuadAttributes(e, t, r, i, a) {
      const s = e.texture, o = e.transform, l = o.a, u = o.b, c = o.c, h = o.d, d = o.tx, f = o.ty, p = e.bounds, g = p.maxX, m = p.minX, v = p.maxY, y = p.minY, x = s.uvs, b = e.color, w = a << 16 | e.roundPixels & 65535;
      t[i + 0] = l * m + c * y + d, t[i + 1] = h * y + u * m + f, t[i + 2] = x.x0, t[i + 3] = x.y0, r[i + 4] = b, r[i + 5] = w, t[i + 6] = l * g + c * y + d, t[i + 7] = h * y + u * g + f, t[i + 8] = x.x1, t[i + 9] = x.y1, r[i + 10] = b, r[i + 11] = w, t[i + 12] = l * g + c * v + d, t[i + 13] = h * v + u * g + f, t[i + 14] = x.x2, t[i + 15] = x.y2, r[i + 16] = b, r[i + 17] = w, t[i + 18] = l * m + c * v + d, t[i + 19] = h * v + u * m + f, t[i + 20] = x.x3, t[i + 21] = x.y3, r[i + 22] = b, r[i + 23] = w;
    }
  };
  Uie.extension = {
    type: [
      Nn.Batcher
    ],
    name: "default"
  };
  Ept = Uie;
  function Mpt(n, e, t, r, i, a, s, o = null) {
    let l = 0;
    t *= e, i *= a;
    const u = o.a, c = o.b, h = o.c, d = o.d, f = o.tx, p = o.ty;
    for (; l < s; ) {
      const g = n[t], m = n[t + 1];
      r[i] = u * g + h * m + f, r[i + 1] = c * g + d * m + p, i += a, t += e, l++;
    }
  }
  function Ppt(n, e, t, r) {
    let i = 0;
    for (e *= t; i < r; ) n[e] = 0, n[e + 1] = 0, e += t, i++;
  }
  function Xie(n, e, t, r, i) {
    const a = e.a, s = e.b, o = e.c, l = e.d, u = e.tx, c = e.ty;
    t || (t = 0), r || (r = 2), i || (i = n.length / r - t);
    let h = t * r;
    for (let d = 0; d < i; d++) {
      const f = n[h], p = n[h + 1];
      n[h] = a * f + o * p + u, n[h + 1] = s * f + l * p + c, h += r;
    }
  }
  const Lpt = new pn();
  Yie = class {
    constructor() {
      this.packAsQuad = false, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = true, this.roundPixels = 0, this._batcher = null, this._batch = null;
    }
    get uvs() {
      return this.geometryData.uvs;
    }
    get positions() {
      return this.geometryData.vertices;
    }
    get indices() {
      return this.geometryData.indices;
    }
    get blendMode() {
      return this.applyTransform ? this.renderable.groupBlendMode : "normal";
    }
    get color() {
      const e = this.baseColor, t = e >> 16 | e & 65280 | (e & 255) << 16, r = this.renderable;
      return r ? nie(t, r.groupColor) + (this.alpha * r.groupAlpha * 255 << 24) : t + (this.alpha * 255 << 24);
    }
    get transform() {
      var _a2;
      return ((_a2 = this.renderable) == null ? void 0 : _a2.groupTransform) || Lpt;
    }
    copyTo(e) {
      e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology;
    }
    reset() {
      this.applyTransform = true, this.renderable = null, this.topology = "triangle-list";
    }
  };
  const Sx = {
    extension: {
      type: Nn.ShapeBuilder,
      name: "circle"
    },
    build(n, e) {
      let t, r, i, a, s, o;
      if (n.type === "circle") {
        const b = n;
        t = b.x, r = b.y, s = o = b.radius, i = a = 0;
      } else if (n.type === "ellipse") {
        const b = n;
        t = b.x, r = b.y, s = b.halfWidth, o = b.halfHeight, i = a = 0;
      } else {
        const b = n, w = b.width / 2, _ = b.height / 2;
        t = b.x + w, r = b.y + _, s = o = Math.max(0, Math.min(b.radius, Math.min(w, _))), i = w - s, a = _ - o;
      }
      if (!(s >= 0 && o >= 0 && i >= 0 && a >= 0)) return e;
      const l = Math.ceil(2.3 * Math.sqrt(s + o)), u = l * 8 + (i ? 4 : 0) + (a ? 4 : 0);
      if (u === 0) return e;
      if (l === 0) return e[0] = e[6] = t + i, e[1] = e[3] = r + a, e[2] = e[4] = t - i, e[5] = e[7] = r - a, e;
      let c = 0, h = l * 4 + (i ? 2 : 0) + 2, d = h, f = u, p = i + s, g = a, m = t + p, v = t - p, y = r + g;
      if (e[c++] = m, e[c++] = y, e[--h] = y, e[--h] = v, a) {
        const b = r - g;
        e[d++] = v, e[d++] = b, e[--f] = b, e[--f] = m;
      }
      for (let b = 1; b < l; b++) {
        const w = Math.PI / 2 * (b / l), _ = i + Math.cos(w) * s, S = a + Math.sin(w) * o, I = t + _, C = t - _, T = r + S, k = r - S;
        e[c++] = I, e[c++] = T, e[--h] = T, e[--h] = C, e[d++] = C, e[d++] = k, e[--f] = k, e[--f] = I;
      }
      p = i, g = a + o, m = t + p, v = t - p, y = r + g;
      const x = r - g;
      return e[c++] = m, e[c++] = y, e[--f] = x, e[--f] = m, i && (e[c++] = v, e[c++] = y, e[--f] = x, e[--f] = v), e;
    },
    triangulate(n, e, t, r, i, a) {
      if (n.length === 0) return;
      let s = 0, o = 0;
      for (let c = 0; c < n.length; c += 2) s += n[c], o += n[c + 1];
      s /= n.length / 2, o /= n.length / 2;
      let l = r;
      e[l * t] = s, e[l * t + 1] = o;
      const u = l++;
      for (let c = 0; c < n.length; c += 2) e[l * t] = n[c], e[l * t + 1] = n[c + 1], c > 0 && (i[a++] = l, i[a++] = u, i[a++] = l - 1), l++;
      i[a++] = u + 1, i[a++] = u, i[a++] = l - 1;
    }
  }, Fpt = {
    ...Sx,
    extension: {
      ...Sx.extension,
      name: "ellipse"
    }
  }, Opt = {
    ...Sx,
    extension: {
      ...Sx.extension,
      name: "roundedRectangle"
    }
  }, qie = 1e-4, r5 = 1e-4;
  function Bpt(n) {
    const e = n.length;
    if (e < 6) return 1;
    let t = 0;
    for (let r = 0, i = n[e - 2], a = n[e - 1]; r < e; r += 2) {
      const s = n[r], o = n[r + 1];
      t += (s - i) * (o + a), i = s, a = o;
    }
    return t < 0 ? -1 : 1;
  }
  function i5(n, e, t, r, i, a, s, o) {
    const l = n - t * i, u = e - r * i, c = n + t * a, h = e + r * a;
    let d, f;
    s ? (d = r, f = -t) : (d = -r, f = t);
    const p = l + d, g = u + f, m = c + d, v = h + f;
    return o.push(p, g), o.push(m, v), 2;
  }
  function hh(n, e, t, r, i, a, s, o) {
    const l = t - n, u = r - e;
    let c = Math.atan2(l, u), h = Math.atan2(i - n, a - e);
    o && c < h ? c += Math.PI * 2 : !o && c > h && (h += Math.PI * 2);
    let d = c;
    const f = h - c, p = Math.abs(f), g = Math.sqrt(l * l + u * u), m = (15 * p * Math.sqrt(g) / Math.PI >> 0) + 1, v = f / m;
    if (d += v, o) {
      s.push(n, e), s.push(t, r);
      for (let y = 1, x = d; y < m; y++, x += v) s.push(n, e), s.push(n + Math.sin(x) * g, e + Math.cos(x) * g);
      s.push(n, e), s.push(i, a);
    } else {
      s.push(t, r), s.push(n, e);
      for (let y = 1, x = d; y < m; y++, x += v) s.push(n + Math.sin(x) * g, e + Math.cos(x) * g), s.push(n, e);
      s.push(i, a), s.push(n, e);
    }
    return m * 2;
  }
  function zpt(n, e, t, r, i, a) {
    const s = qie;
    if (n.length === 0) return;
    const o = e;
    let l = o.alignment;
    if (e.alignment !== 0.5) {
      let L = Bpt(n);
      l = (l - 0.5) * L + 0.5;
    }
    const u = new Ri(n[0], n[1]), c = new Ri(n[n.length - 2], n[n.length - 1]), h = r, d = Math.abs(u.x - c.x) < s && Math.abs(u.y - c.y) < s;
    if (h) {
      n = n.slice(), d && (n.pop(), n.pop(), c.set(n[n.length - 2], n[n.length - 1]));
      const L = (u.x + c.x) * 0.5, F = (c.y + u.y) * 0.5;
      n.unshift(L, F), n.push(L, F);
    }
    const f = i, p = n.length / 2;
    let g = n.length;
    const m = f.length / 2, v = o.width / 2, y = v * v, x = o.miterLimit * o.miterLimit;
    let b = n[0], w = n[1], _ = n[2], S = n[3], I = 0, C = 0, T = -(w - S), k = b - _, D = 0, R = 0, N = Math.sqrt(T * T + k * k);
    T /= N, k /= N, T *= v, k *= v;
    const E = l, A = (1 - E) * 2, M = E * 2;
    h || (o.cap === "round" ? g += hh(b - T * (A - M) * 0.5, w - k * (A - M) * 0.5, b - T * A, w - k * A, b + T * M, w + k * M, f, true) + 2 : o.cap === "square" && (g += i5(b, w, T, k, A, M, true, f))), f.push(b - T * A, w - k * A), f.push(b + T * M, w + k * M);
    for (let L = 1; L < p - 1; ++L) {
      b = n[(L - 1) * 2], w = n[(L - 1) * 2 + 1], _ = n[L * 2], S = n[L * 2 + 1], I = n[(L + 1) * 2], C = n[(L + 1) * 2 + 1], T = -(w - S), k = b - _, N = Math.sqrt(T * T + k * k), T /= N, k /= N, T *= v, k *= v, D = -(S - C), R = _ - I, N = Math.sqrt(D * D + R * R), D /= N, R /= N, D *= v, R *= v;
      const F = _ - b, O = w - S, z = _ - I, V = C - S, H = F * z + O * V, Y = O * z - V * F, le = Y < 0;
      if (Math.abs(Y) < 1e-3 * Math.abs(H)) {
        f.push(_ - T * A, S - k * A), f.push(_ + T * M, S + k * M), H >= 0 && (o.join === "round" ? g += hh(_, S, _ - T * A, S - k * A, _ - D * A, S - R * A, f, false) + 4 : g += 2, f.push(_ - D * M, S - R * M), f.push(_ + D * A, S + R * A));
        continue;
      }
      const ve = (-T + b) * (-k + S) - (-T + _) * (-k + w), re = (-D + I) * (-R + S) - (-D + _) * (-R + C), ae = (F * re - z * ve) / Y, fe = (V * ve - O * re) / Y, ce = (ae - _) * (ae - _) + (fe - S) * (fe - S), ye = _ + (ae - _) * A, Le = S + (fe - S) * A, Re = _ - (ae - _) * M, be = S - (fe - S) * M, xe = Math.min(F * F + O * O, z * z + V * V), ot = le ? A : M, G = xe + ot * ot * y;
      ce <= G ? o.join === "bevel" || ce / y > x ? (le ? (f.push(ye, Le), f.push(_ + T * M, S + k * M), f.push(ye, Le), f.push(_ + D * M, S + R * M)) : (f.push(_ - T * A, S - k * A), f.push(Re, be), f.push(_ - D * A, S - R * A), f.push(Re, be)), g += 2) : o.join === "round" ? le ? (f.push(ye, Le), f.push(_ + T * M, S + k * M), g += hh(_, S, _ + T * M, S + k * M, _ + D * M, S + R * M, f, true) + 4, f.push(ye, Le), f.push(_ + D * M, S + R * M)) : (f.push(_ - T * A, S - k * A), f.push(Re, be), g += hh(_, S, _ - T * A, S - k * A, _ - D * A, S - R * A, f, false) + 4, f.push(_ - D * A, S - R * A), f.push(Re, be)) : (f.push(ye, Le), f.push(Re, be)) : (f.push(_ - T * A, S - k * A), f.push(_ + T * M, S + k * M), o.join === "round" ? le ? g += hh(_, S, _ + T * M, S + k * M, _ + D * M, S + R * M, f, true) + 2 : g += hh(_, S, _ - T * A, S - k * A, _ - D * A, S - R * A, f, false) + 2 : o.join === "miter" && ce / y <= x && (le ? (f.push(Re, be), f.push(Re, be)) : (f.push(ye, Le), f.push(ye, Le)), g += 2), f.push(_ - D * A, S - R * A), f.push(_ + D * M, S + R * M), g += 2);
    }
    b = n[(p - 2) * 2], w = n[(p - 2) * 2 + 1], _ = n[(p - 1) * 2], S = n[(p - 1) * 2 + 1], T = -(w - S), k = b - _, N = Math.sqrt(T * T + k * k), T /= N, k /= N, T *= v, k *= v, f.push(_ - T * A, S - k * A), f.push(_ + T * M, S + k * M), h || (o.cap === "round" ? g += hh(_ - T * (A - M) * 0.5, S - k * (A - M) * 0.5, _ - T * A, S - k * A, _ + T * M, S + k * M, f, false) + 2 : o.cap === "square" && (g += i5(_, S, T, k, A, M, false, f)));
    const $ = r5 * r5;
    for (let L = m; L < g + m - 2; ++L) b = f[L * 2], w = f[L * 2 + 1], _ = f[(L + 1) * 2], S = f[(L + 1) * 2 + 1], I = f[(L + 2) * 2], C = f[(L + 2) * 2 + 1], !(Math.abs(b * (S - C) + _ * (C - w) + I * (w - S)) < $) && a.push(L, L + 1, L + 2);
  }
  function Vpt(n, e, t, r) {
    const i = qie;
    if (n.length === 0) return;
    const a = n[0], s = n[1], o = n[n.length - 2], l = n[n.length - 1], u = e || Math.abs(a - o) < i && Math.abs(s - l) < i, c = t, h = n.length / 2, d = c.length / 2;
    for (let f = 0; f < h; f++) c.push(n[f * 2]), c.push(n[f * 2 + 1]);
    for (let f = 0; f < h - 1; f++) r.push(d + f, d + f + 1);
    u && r.push(d + h - 1, d);
  }
  function jie(n, e, t, r, i, a, s) {
    const o = Dft(n, e, 2);
    if (!o) return;
    for (let u = 0; u < o.length; u += 3) a[s++] = o[u] + i, a[s++] = o[u + 1] + i, a[s++] = o[u + 2] + i;
    let l = i * r;
    for (let u = 0; u < n.length; u += 2) t[l] = n[u], t[l + 1] = n[u + 1], l += r;
  }
  const Wpt = [], Gpt = {
    extension: {
      type: Nn.ShapeBuilder,
      name: "polygon"
    },
    build(n, e) {
      for (let t = 0; t < n.points.length; t++) e[t] = n.points[t];
      return e;
    },
    triangulate(n, e, t, r, i, a) {
      jie(n, Wpt, e, t, r, i, a);
    }
  }, Upt = {
    extension: {
      type: Nn.ShapeBuilder,
      name: "rectangle"
    },
    build(n, e) {
      const t = n, r = t.x, i = t.y, a = t.width, s = t.height;
      return a >= 0 && s >= 0 && (e[0] = r, e[1] = i, e[2] = r + a, e[3] = i, e[4] = r + a, e[5] = i + s, e[6] = r, e[7] = i + s), e;
    },
    triangulate(n, e, t, r, i, a) {
      let s = 0;
      r *= t, e[r + s] = n[0], e[r + s + 1] = n[1], s += t, e[r + s] = n[2], e[r + s + 1] = n[3], s += t, e[r + s] = n[6], e[r + s + 1] = n[7], s += t, e[r + s] = n[4], e[r + s + 1] = n[5], s += t;
      const o = r / t;
      i[a++] = o, i[a++] = o + 1, i[a++] = o + 2, i[a++] = o + 1, i[a++] = o + 3, i[a++] = o + 2;
    }
  }, Hpt = {
    extension: {
      type: Nn.ShapeBuilder,
      name: "triangle"
    },
    build(n, e) {
      return e[0] = n.x, e[1] = n.y, e[2] = n.x2, e[3] = n.y2, e[4] = n.x3, e[5] = n.y3, e;
    },
    triangulate(n, e, t, r, i, a) {
      let s = 0;
      r *= t, e[r + s] = n[0], e[r + s + 1] = n[1], s += t, e[r + s] = n[2], e[r + s + 1] = n[3], s += t, e[r + s] = n[4], e[r + s + 1] = n[5];
      const o = r / t;
      i[a++] = o, i[a++] = o + 1, i[a++] = o + 2;
    }
  }, Xpt = new pn(), Ypt = new ri();
  function qpt(n, e, t, r) {
    const i = e.matrix ? n.copyFrom(e.matrix).invert() : n.identity();
    if (e.textureSpace === "local") {
      const a = t.getBounds(Ypt);
      i.translate(-a.x, -a.y), i.scale(1 / a.width, 1 / a.height);
    } else {
      i.translate(e.texture.frame.x, e.texture.frame.y), i.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
      const a = e.texture.source.style;
      a.addressMode === "clamp-to-edge" && (a.addressMode = "repeat", a.update());
    }
    return r && i.append(Xpt.copyFrom(r).invert()), i;
  }
  const v2 = {};
  $s.handleByMap(Nn.ShapeBuilder, v2);
  $s.add(Upt, Gpt, Hpt, Sx, Fpt, Opt);
  const jpt = new ri(), Kpt = new pn();
  function Zpt(n, e) {
    const { geometryData: t, batches: r } = e;
    r.length = 0, t.indices.length = 0, t.vertices.length = 0, t.uvs.length = 0;
    for (let i = 0; i < n.instructions.length; i++) {
      const a = n.instructions[i];
      if (a.action === "texture") Qpt(a.data, r, t);
      else if (a.action === "fill" || a.action === "stroke") {
        const s = a.action === "stroke", o = a.data.path.shapePath, l = a.data.style, u = a.data.hole;
        s && u && a5(u.shapePath, l, true, r, t), u && (o.shapePrimitives[o.shapePrimitives.length - 1].holes = u.shapePath.shapePrimitives), a5(o, l, s, r, t);
      }
    }
  }
  function Qpt(n, e, t) {
    const { vertices: r, uvs: i, indices: a } = t, s = a.length, o = r.length / 2, l = [], u = v2.rectangle, c = jpt, h = n.image;
    c.x = n.dx, c.y = n.dy, c.width = n.dw, c.height = n.dh;
    const d = n.transform;
    u.build(c, l), d && Xie(l, d), u.triangulate(l, r, 2, o, a, s);
    const f = h.uvs;
    i.push(f.x0, f.y0, f.x1, f.y1, f.x3, f.y3, f.x2, f.y2);
    const p = Wl.get(Yie);
    p.indexOffset = s, p.indexSize = a.length - s, p.attributeOffset = o, p.attributeSize = r.length / 2 - o, p.baseColor = n.style, p.alpha = n.alpha, p.texture = h, p.geometryData = t, e.push(p);
  }
  function a5(n, e, t, r, i) {
    const { vertices: a, uvs: s, indices: o } = i;
    n.shapePrimitives.forEach(({ shape: l, transform: u, holes: c }) => {
      const h = o.length, d = a.length / 2, f = [], p = v2[l.type];
      let g = "triangle-list";
      if (p.build(l, f), u && Xie(f, u), t) {
        const x = l.closePath ?? true, b = e;
        b.pixelLine ? (Vpt(f, x, a, o), g = "line-list") : zpt(f, b, false, x, a, o);
      } else if (c) {
        const x = [], b = f.slice();
        Jpt(c).forEach((_) => {
          x.push(b.length / 2), b.push(..._);
        }), jie(b, x, a, 2, d, o, h);
      } else p.triangulate(f, a, 2, d, o, h);
      const m = s.length / 2, v = e.texture;
      if (v !== Fn.WHITE) {
        const x = qpt(Kpt, e, l, u);
        Mpt(a, 2, d, s, m, 2, a.length / 2 - d, x);
      } else Ppt(s, m, 2, a.length / 2 - d);
      const y = Wl.get(Yie);
      y.indexOffset = h, y.indexSize = o.length - h, y.attributeOffset = d, y.attributeSize = a.length / 2 - d, y.baseColor = e.color, y.alpha = e.alpha, y.texture = v, y.geometryData = i, y.topology = g, r.push(y);
    });
  }
  function Jpt(n) {
    const e = [];
    for (let t = 0; t < n.length; t++) {
      const r = n[t].shape, i = [];
      v2[r.type].build(r, i), e.push(i);
    }
    return e;
  }
  class egt {
    constructor() {
      this.batches = [], this.geometryData = {
        vertices: [],
        uvs: [],
        indices: []
      };
    }
  }
  class tgt {
    constructor() {
      this.batcher = new Ept(), this.instructions = new sie();
    }
    init() {
      this.instructions.reset();
    }
    get geometry() {
      return Gn(hdt, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
    }
  }
  const ZL = class sN {
    constructor(e) {
      this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
    }
    init(e) {
      sN.defaultOptions.bezierSmoothness = (e == null ? void 0 : e.bezierSmoothness) ?? sN.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(e) {
      return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e);
    }
    updateGpuContext(e) {
      let t = this._gpuContextHash[e.uid] || this._initContext(e);
      if (e.dirty) {
        t ? this._cleanGraphicsContextData(e) : t = this._initContext(e), Zpt(e, t);
        const r = e.batchMode;
        e.customShader || r === "no-batch" ? t.isBatchable = false : r === "auto" && (t.isBatchable = t.geometryData.vertices.length < 400), e.dirty = false;
      }
      return t;
    }
    getGpuContext(e) {
      return this._gpuContextHash[e.uid] || this._initContext(e);
    }
    _initContextRenderData(e) {
      const t = Wl.get(tgt), { batches: r, geometryData: i } = this._gpuContextHash[e.uid], a = i.vertices.length, s = i.indices.length;
      for (let c = 0; c < r.length; c++) r[c].applyTransform = false;
      const o = t.batcher;
      o.ensureAttributeBuffer(a), o.ensureIndexBuffer(s), o.begin();
      for (let c = 0; c < r.length; c++) {
        const h = r[c];
        o.add(h);
      }
      o.finish(t.instructions);
      const l = o.geometry;
      l.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, true), l.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, true);
      const u = o.batches;
      for (let c = 0; c < u.length; c++) {
        const h = u[c];
        h.bindGroup = Yft(h.textures.textures, h.textures.count);
      }
      return this._graphicsDataContextHash[e.uid] = t, t;
    }
    _initContext(e) {
      const t = new egt();
      return t.context = e, this._gpuContextHash[e.uid] = t, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid];
    }
    onGraphicsContextDestroy(e) {
      this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null;
    }
    _cleanGraphicsContextData(e) {
      const t = this._gpuContextHash[e.uid];
      t.isBatchable || this._graphicsDataContextHash[e.uid] && (Wl.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), t.batches && t.batches.forEach((r) => {
        Wl.return(r);
      });
    }
    destroy() {
      for (const e in this._gpuContextHash) this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
    }
  };
  ZL.extension = {
    type: [
      Nn.WebGLSystem,
      Nn.WebGPUSystem,
      Nn.CanvasSystem
    ],
    name: "graphicsContext"
  };
  ZL.defaultOptions = {
    bezierSmoothness: 0.5
  };
  Kie = ZL;
  const ngt = 8, Ow = 11920929e-14, rgt = 1;
  function Zie(n, e, t, r, i, a, s, o, l, u) {
    const h = Math.min(0.99, Math.max(0, u ?? Kie.defaultOptions.bezierSmoothness));
    let d = (rgt - h) / 1;
    return d *= d, igt(e, t, r, i, a, s, o, l, n, d), n;
  }
  function igt(n, e, t, r, i, a, s, o, l, u) {
    oN(n, e, t, r, i, a, s, o, l, u, 0), l.push(s, o);
  }
  function oN(n, e, t, r, i, a, s, o, l, u, c) {
    if (c > ngt) return;
    const h = (n + t) / 2, d = (e + r) / 2, f = (t + i) / 2, p = (r + a) / 2, g = (i + s) / 2, m = (a + o) / 2, v = (h + f) / 2, y = (d + p) / 2, x = (f + g) / 2, b = (p + m) / 2, w = (v + x) / 2, _ = (y + b) / 2;
    if (c > 0) {
      let S = s - n, I = o - e;
      const C = Math.abs((t - s) * I - (r - o) * S), T = Math.abs((i - s) * I - (a - o) * S);
      if (C > Ow && T > Ow) {
        if ((C + T) * (C + T) <= u * (S * S + I * I)) {
          l.push(w, _);
          return;
        }
      } else if (C > Ow) {
        if (C * C <= u * (S * S + I * I)) {
          l.push(w, _);
          return;
        }
      } else if (T > Ow) {
        if (T * T <= u * (S * S + I * I)) {
          l.push(w, _);
          return;
        }
      } else if (S = w - (n + s) / 2, I = _ - (e + o) / 2, S * S + I * I <= u) {
        l.push(w, _);
        return;
      }
    }
    oN(n, e, h, d, v, y, w, _, l, u, c + 1), oN(w, _, x, b, g, m, s, o, l, u, c + 1);
  }
  const agt = 8, sgt = 11920929e-14, ogt = 1;
  function lgt(n, e, t, r, i, a, s, o) {
    const u = Math.min(0.99, Math.max(0, o ?? Kie.defaultOptions.bezierSmoothness));
    let c = (ogt - u) / 1;
    return c *= c, ugt(e, t, r, i, a, s, n, c), n;
  }
  function ugt(n, e, t, r, i, a, s, o) {
    lN(s, n, e, t, r, i, a, o, 0), s.push(i, a);
  }
  function lN(n, e, t, r, i, a, s, o, l) {
    if (l > agt) return;
    const u = (e + r) / 2, c = (t + i) / 2, h = (r + a) / 2, d = (i + s) / 2, f = (u + h) / 2, p = (c + d) / 2;
    let g = a - e, m = s - t;
    const v = Math.abs((r - a) * m - (i - s) * g);
    if (v > sgt) {
      if (v * v <= o * (g * g + m * m)) {
        n.push(f, p);
        return;
      }
    } else if (g = f - (e + a) / 2, m = p - (t + s) / 2, g * g + m * m <= o) {
      n.push(f, p);
      return;
    }
    lN(n, e, t, u, c, f, p, o, l + 1), lN(n, f, p, h, d, a, s, o, l + 1);
  }
  function Qie(n, e, t, r, i, a, s, o) {
    let l = Math.abs(i - a);
    (!s && i > a || s && a > i) && (l = 2 * Math.PI - l), o || (o = Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (l / Math.PI)))), o = Math.max(o, 3);
    let u = l / o, c = i;
    u *= s ? -1 : 1;
    for (let h = 0; h < o + 1; h++) {
      const d = Math.cos(c), f = Math.sin(c), p = e + d * r, g = t + f * r;
      n.push(p, g), c += u;
    }
  }
  function cgt(n, e, t, r, i, a) {
    const s = n[n.length - 2], l = n[n.length - 1] - t, u = s - e, c = i - t, h = r - e, d = Math.abs(l * h - u * c);
    if (d < 1e-8 || a === 0) {
      (n[n.length - 2] !== e || n[n.length - 1] !== t) && n.push(e, t);
      return;
    }
    const f = l * l + u * u, p = c * c + h * h, g = l * c + u * h, m = a * Math.sqrt(f) / d, v = a * Math.sqrt(p) / d, y = m * g / f, x = v * g / p, b = m * h + v * u, w = m * c + v * l, _ = u * (v + y), S = l * (v + y), I = h * (m + x), C = c * (m + x), T = Math.atan2(S - w, _ - b), k = Math.atan2(C - w, I - b);
    Qie(n, b + e, w + t, a, T, k, u * c > h * l);
  }
  const b0 = Math.PI * 2, KA = {
    centerX: 0,
    centerY: 0,
    ang1: 0,
    ang2: 0
  }, ZA = ({ x: n, y: e }, t, r, i, a, s, o, l) => {
    n *= t, e *= r;
    const u = i * n - a * e, c = a * n + i * e;
    return l.x = u + s, l.y = c + o, l;
  };
  function hgt(n, e) {
    const t = e === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(e / 4), r = e === 1.5707963267948966 ? 0.551915024494 : t, i = Math.cos(n), a = Math.sin(n), s = Math.cos(n + e), o = Math.sin(n + e);
    return [
      {
        x: i - a * r,
        y: a + i * r
      },
      {
        x: s + o * r,
        y: o - s * r
      },
      {
        x: s,
        y: o
      }
    ];
  }
  const s5 = (n, e, t, r) => {
    const i = n * r - e * t < 0 ? -1 : 1;
    let a = n * t + e * r;
    return a > 1 && (a = 1), a < -1 && (a = -1), i * Math.acos(a);
  }, dgt = (n, e, t, r, i, a, s, o, l, u, c, h, d) => {
    const f = Math.pow(i, 2), p = Math.pow(a, 2), g = Math.pow(c, 2), m = Math.pow(h, 2);
    let v = f * p - f * m - p * g;
    v < 0 && (v = 0), v /= f * m + p * g, v = Math.sqrt(v) * (s === o ? -1 : 1);
    const y = v * i / a * h, x = v * -a / i * c, b = u * y - l * x + (n + t) / 2, w = l * y + u * x + (e + r) / 2, _ = (c - y) / i, S = (h - x) / a, I = (-c - y) / i, C = (-h - x) / a, T = s5(1, 0, _, S);
    let k = s5(_, S, I, C);
    o === 0 && k > 0 && (k -= b0), o === 1 && k < 0 && (k += b0), d.centerX = b, d.centerY = w, d.ang1 = T, d.ang2 = k;
  };
  function fgt(n, e, t, r, i, a, s, o = 0, l = 0, u = 0) {
    if (a === 0 || s === 0) return;
    const c = Math.sin(o * b0 / 360), h = Math.cos(o * b0 / 360), d = h * (e - r) / 2 + c * (t - i) / 2, f = -c * (e - r) / 2 + h * (t - i) / 2;
    if (d === 0 && f === 0) return;
    a = Math.abs(a), s = Math.abs(s);
    const p = Math.pow(d, 2) / Math.pow(a, 2) + Math.pow(f, 2) / Math.pow(s, 2);
    p > 1 && (a *= Math.sqrt(p), s *= Math.sqrt(p)), dgt(e, t, r, i, a, s, l, u, c, h, d, f, KA);
    let { ang1: g, ang2: m } = KA;
    const { centerX: v, centerY: y } = KA;
    let x = Math.abs(m) / (b0 / 4);
    Math.abs(1 - x) < 1e-7 && (x = 1);
    const b = Math.max(Math.ceil(x), 1);
    m /= b;
    let w = n[n.length - 2], _ = n[n.length - 1];
    const S = {
      x: 0,
      y: 0
    };
    for (let I = 0; I < b; I++) {
      const C = hgt(g, m), { x: T, y: k } = ZA(C[0], a, s, h, c, v, y, S), { x: D, y: R } = ZA(C[1], a, s, h, c, v, y, S), { x: N, y: E } = ZA(C[2], a, s, h, c, v, y, S);
      Zie(n, w, _, T, k, D, R, N, E), w = N, _ = E, g += m;
    }
  }
  function pgt(n, e, t) {
    const r = (s, o) => {
      const l = o.x - s.x, u = o.y - s.y, c = Math.sqrt(l * l + u * u), h = l / c, d = u / c;
      return {
        len: c,
        nx: h,
        ny: d
      };
    }, i = (s, o) => {
      s === 0 ? n.moveTo(o.x, o.y) : n.lineTo(o.x, o.y);
    };
    let a = e[e.length - 1];
    for (let s = 0; s < e.length; s++) {
      const o = e[s % e.length], l = o.radius ?? t;
      if (l <= 0) {
        i(s, o), a = o;
        continue;
      }
      const u = e[(s + 1) % e.length], c = r(o, a), h = r(o, u);
      if (c.len < 1e-4 || h.len < 1e-4) {
        i(s, o), a = o;
        continue;
      }
      let d = Math.asin(c.nx * h.ny - c.ny * h.nx), f = 1, p = false;
      c.nx * h.nx - c.ny * -h.ny < 0 ? d < 0 ? d = Math.PI + d : (d = Math.PI - d, f = -1, p = true) : d > 0 && (f = -1, p = true);
      const g = d / 2;
      let m, v = Math.abs(Math.cos(g) * l / Math.sin(g));
      v > Math.min(c.len / 2, h.len / 2) ? (v = Math.min(c.len / 2, h.len / 2), m = Math.abs(v * Math.sin(g) / Math.cos(g))) : m = l;
      const y = o.x + h.nx * v + -h.ny * m * f, x = o.y + h.ny * v + h.nx * m * f, b = Math.atan2(c.ny, c.nx) + Math.PI / 2 * f, w = Math.atan2(h.ny, h.nx) - Math.PI / 2 * f;
      s === 0 && n.moveTo(y + Math.cos(b) * m, x + Math.sin(b) * m), n.arc(y, x, m, b, w, p), a = o;
    }
  }
  function ggt(n, e, t, r) {
    const i = (o, l) => Math.sqrt((o.x - l.x) ** 2 + (o.y - l.y) ** 2), a = (o, l, u) => ({
      x: o.x + (l.x - o.x) * u,
      y: o.y + (l.y - o.y) * u
    }), s = e.length;
    for (let o = 0; o < s; o++) {
      const l = e[(o + 1) % s], u = l.radius ?? t;
      if (u <= 0) {
        o === 0 ? n.moveTo(l.x, l.y) : n.lineTo(l.x, l.y);
        continue;
      }
      const c = e[o], h = e[(o + 2) % s], d = i(c, l);
      let f;
      if (d < 1e-4) f = l;
      else {
        const m = Math.min(d / 2, u);
        f = a(l, c, m / d);
      }
      const p = i(h, l);
      let g;
      if (p < 1e-4) g = l;
      else {
        const m = Math.min(p / 2, u);
        g = a(l, h, m / p);
      }
      o === 0 ? n.moveTo(f.x, f.y) : n.lineTo(f.x, f.y), n.quadraticCurveTo(l.x, l.y, g.x, g.y, r);
    }
  }
  const mgt = new ri();
  class vgt {
    constructor(e) {
      this.shapePrimitives = [], this._currentPoly = null, this._bounds = new co(), this._graphicsPath2D = e, this.signed = e.checkForHoles;
    }
    moveTo(e, t) {
      return this.startPoly(e, t), this;
    }
    lineTo(e, t) {
      this._ensurePoly();
      const r = this._currentPoly.points, i = r[r.length - 2], a = r[r.length - 1];
      return (i !== e || a !== t) && r.push(e, t), this;
    }
    arc(e, t, r, i, a, s) {
      this._ensurePoly(false);
      const o = this._currentPoly.points;
      return Qie(o, e, t, r, i, a, s), this;
    }
    arcTo(e, t, r, i, a) {
      this._ensurePoly();
      const s = this._currentPoly.points;
      return cgt(s, e, t, r, i, a), this;
    }
    arcToSvg(e, t, r, i, a, s, o) {
      const l = this._currentPoly.points;
      return fgt(l, this._currentPoly.lastX, this._currentPoly.lastY, s, o, e, t, r, i, a), this;
    }
    bezierCurveTo(e, t, r, i, a, s, o) {
      this._ensurePoly();
      const l = this._currentPoly;
      return Zie(this._currentPoly.points, l.lastX, l.lastY, e, t, r, i, a, s, o), this;
    }
    quadraticCurveTo(e, t, r, i, a) {
      this._ensurePoly();
      const s = this._currentPoly;
      return lgt(this._currentPoly.points, s.lastX, s.lastY, e, t, r, i, a), this;
    }
    closePath() {
      return this.endPoly(true), this;
    }
    addPath(e, t) {
      this.endPoly(), t && !t.isIdentity() && (e = e.clone(true), e.transform(t));
      const r = this.shapePrimitives, i = r.length;
      for (let a = 0; a < e.instructions.length; a++) {
        const s = e.instructions[a];
        this[s.action](...s.data);
      }
      if (e.checkForHoles && r.length - i > 1) {
        let a = null;
        for (let s = i; s < r.length; s++) {
          const o = r[s];
          if (o.shape.type === "polygon") {
            const l = o.shape, u = a == null ? void 0 : a.shape;
            u && u.containsPolygon(l) ? (a.holes || (a.holes = []), a.holes.push(o), r.copyWithin(s, s + 1), r.length--, s--) : a = o;
          }
        }
      }
      return this;
    }
    finish(e = false) {
      this.endPoly(e);
    }
    rect(e, t, r, i, a) {
      return this.drawShape(new ri(e, t, r, i), a), this;
    }
    circle(e, t, r, i) {
      return this.drawShape(new qL(e, t, r), i), this;
    }
    poly(e, t, r) {
      const i = new x0(e);
      return i.closePath = t, this.drawShape(i, r), this;
    }
    regularPoly(e, t, r, i, a = 0, s) {
      i = Math.max(i | 0, 3);
      const o = -1 * Math.PI / 2 + a, l = Math.PI * 2 / i, u = [];
      for (let c = 0; c < i; c++) {
        const h = o - c * l;
        u.push(e + r * Math.cos(h), t + r * Math.sin(h));
      }
      return this.poly(u, true, s), this;
    }
    roundPoly(e, t, r, i, a, s = 0, o) {
      if (i = Math.max(i | 0, 3), a <= 0) return this.regularPoly(e, t, r, i, s);
      const l = r * Math.sin(Math.PI / i) - 1e-3;
      a = Math.min(a, l);
      const u = -1 * Math.PI / 2 + s, c = Math.PI * 2 / i, h = (i - 2) * Math.PI / i / 2;
      for (let d = 0; d < i; d++) {
        const f = d * c + u, p = e + r * Math.cos(f), g = t + r * Math.sin(f), m = f + Math.PI + h, v = f - Math.PI - h, y = p + a * Math.cos(m), x = g + a * Math.sin(m), b = p + a * Math.cos(v), w = g + a * Math.sin(v);
        d === 0 ? this.moveTo(y, x) : this.lineTo(y, x), this.quadraticCurveTo(p, g, b, w, o);
      }
      return this.closePath();
    }
    roundShape(e, t, r = false, i) {
      return e.length < 3 ? this : (r ? ggt(this, e, t, i) : pgt(this, e, t), this.closePath());
    }
    filletRect(e, t, r, i, a) {
      if (a === 0) return this.rect(e, t, r, i);
      const s = Math.min(r, i) / 2, o = Math.min(s, Math.max(-s, a)), l = e + r, u = t + i, c = o < 0 ? -o : 0, h = Math.abs(o);
      return this.moveTo(e, t + h).arcTo(e + c, t + c, e + h, t, h).lineTo(l - h, t).arcTo(l - c, t + c, l, t + h, h).lineTo(l, u - h).arcTo(l - c, u - c, e + r - h, u, h).lineTo(e + h, u).arcTo(e + c, u - c, e, u - h, h).closePath();
    }
    chamferRect(e, t, r, i, a, s) {
      if (a <= 0) return this.rect(e, t, r, i);
      const o = Math.min(a, Math.min(r, i) / 2), l = e + r, u = t + i, c = [
        e + o,
        t,
        l - o,
        t,
        l,
        t + o,
        l,
        u - o,
        l - o,
        u,
        e + o,
        u,
        e,
        u - o,
        e,
        t + o
      ];
      for (let h = c.length - 1; h >= 2; h -= 2) c[h] === c[h - 2] && c[h - 1] === c[h - 3] && c.splice(h - 1, 2);
      return this.poly(c, true, s);
    }
    ellipse(e, t, r, i, a) {
      return this.drawShape(new jL(e, t, r, i), a), this;
    }
    roundRect(e, t, r, i, a, s) {
      return this.drawShape(new KL(e, t, r, i, a), s), this;
    }
    drawShape(e, t) {
      return this.endPoly(), this.shapePrimitives.push({
        shape: e,
        transform: t
      }), this;
    }
    startPoly(e, t) {
      let r = this._currentPoly;
      return r && this.endPoly(), r = new x0(), r.points.push(e, t), this._currentPoly = r, this;
    }
    endPoly(e = false) {
      const t = this._currentPoly;
      return t && t.points.length > 2 && (t.closePath = e, this.shapePrimitives.push({
        shape: t
      })), this._currentPoly = null, this;
    }
    _ensurePoly(e = true) {
      if (!this._currentPoly && (this._currentPoly = new x0(), e)) {
        const t = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (t) {
          let r = t.shape.x, i = t.shape.y;
          if (t.transform && !t.transform.isIdentity()) {
            const a = t.transform, s = r;
            r = a.a * r + a.c * i + a.tx, i = a.b * s + a.d * i + a.ty;
          }
          this._currentPoly.points.push(r, i);
        } else this._currentPoly.points.push(0, 0);
      }
    }
    buildPath() {
      const e = this._graphicsPath2D;
      this.shapePrimitives.length = 0, this._currentPoly = null;
      for (let t = 0; t < e.instructions.length; t++) {
        const r = e.instructions[t];
        this[r.action](...r.data);
      }
      this.finish();
    }
    get bounds() {
      const e = this._bounds;
      e.clear();
      const t = this.shapePrimitives;
      for (let r = 0; r < t.length; r++) {
        const i = t[r], a = i.shape.getBounds(mgt);
        i.transform ? e.addRect(a, i.transform) : e.addRect(a);
      }
      return e;
    }
  }
  class sm {
    constructor(e, t = false) {
      this.instructions = [], this.uid = Dr("graphicsPath"), this._dirty = true, this.checkForHoles = t, typeof e == "string" ? zft(e, this) : this.instructions = (e == null ? void 0 : e.slice()) ?? [];
    }
    get shapePath() {
      return this._shapePath || (this._shapePath = new vgt(this)), this._dirty && (this._dirty = false, this._shapePath.buildPath()), this._shapePath;
    }
    addPath(e, t) {
      return e = e.clone(), this.instructions.push({
        action: "addPath",
        data: [
          e,
          t
        ]
      }), this._dirty = true, this;
    }
    arc(...e) {
      return this.instructions.push({
        action: "arc",
        data: e
      }), this._dirty = true, this;
    }
    arcTo(...e) {
      return this.instructions.push({
        action: "arcTo",
        data: e
      }), this._dirty = true, this;
    }
    arcToSvg(...e) {
      return this.instructions.push({
        action: "arcToSvg",
        data: e
      }), this._dirty = true, this;
    }
    bezierCurveTo(...e) {
      return this.instructions.push({
        action: "bezierCurveTo",
        data: e
      }), this._dirty = true, this;
    }
    bezierCurveToShort(e, t, r, i, a) {
      const s = this.instructions[this.instructions.length - 1], o = this.getLastPoint(Ri.shared);
      let l = 0, u = 0;
      if (!s || s.action !== "bezierCurveTo") l = o.x, u = o.y;
      else {
        l = s.data[2], u = s.data[3];
        const c = o.x, h = o.y;
        l = c + (c - l), u = h + (h - u);
      }
      return this.instructions.push({
        action: "bezierCurveTo",
        data: [
          l,
          u,
          e,
          t,
          r,
          i,
          a
        ]
      }), this._dirty = true, this;
    }
    closePath() {
      return this.instructions.push({
        action: "closePath",
        data: []
      }), this._dirty = true, this;
    }
    ellipse(...e) {
      return this.instructions.push({
        action: "ellipse",
        data: e
      }), this._dirty = true, this;
    }
    lineTo(...e) {
      return this.instructions.push({
        action: "lineTo",
        data: e
      }), this._dirty = true, this;
    }
    moveTo(...e) {
      return this.instructions.push({
        action: "moveTo",
        data: e
      }), this;
    }
    quadraticCurveTo(...e) {
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: e
      }), this._dirty = true, this;
    }
    quadraticCurveToShort(e, t, r) {
      const i = this.instructions[this.instructions.length - 1], a = this.getLastPoint(Ri.shared);
      let s = 0, o = 0;
      if (!i || i.action !== "quadraticCurveTo") s = a.x, o = a.y;
      else {
        s = i.data[0], o = i.data[1];
        const l = a.x, u = a.y;
        s = l + (l - s), o = u + (u - o);
      }
      return this.instructions.push({
        action: "quadraticCurveTo",
        data: [
          s,
          o,
          e,
          t,
          r
        ]
      }), this._dirty = true, this;
    }
    rect(e, t, r, i, a) {
      return this.instructions.push({
        action: "rect",
        data: [
          e,
          t,
          r,
          i,
          a
        ]
      }), this._dirty = true, this;
    }
    circle(e, t, r, i) {
      return this.instructions.push({
        action: "circle",
        data: [
          e,
          t,
          r,
          i
        ]
      }), this._dirty = true, this;
    }
    roundRect(...e) {
      return this.instructions.push({
        action: "roundRect",
        data: e
      }), this._dirty = true, this;
    }
    poly(...e) {
      return this.instructions.push({
        action: "poly",
        data: e
      }), this._dirty = true, this;
    }
    regularPoly(...e) {
      return this.instructions.push({
        action: "regularPoly",
        data: e
      }), this._dirty = true, this;
    }
    roundPoly(...e) {
      return this.instructions.push({
        action: "roundPoly",
        data: e
      }), this._dirty = true, this;
    }
    roundShape(...e) {
      return this.instructions.push({
        action: "roundShape",
        data: e
      }), this._dirty = true, this;
    }
    filletRect(...e) {
      return this.instructions.push({
        action: "filletRect",
        data: e
      }), this._dirty = true, this;
    }
    chamferRect(...e) {
      return this.instructions.push({
        action: "chamferRect",
        data: e
      }), this._dirty = true, this;
    }
    star(e, t, r, i, a, s, o) {
      a || (a = i / 2);
      const l = -1 * Math.PI / 2 + s, u = r * 2, c = Math.PI * 2 / u, h = [];
      for (let d = 0; d < u; d++) {
        const f = d % 2 ? a : i, p = d * c + l;
        h.push(e + f * Math.cos(p), t + f * Math.sin(p));
      }
      return this.poly(h, true, o), this;
    }
    clone(e = false) {
      const t = new sm();
      if (t.checkForHoles = this.checkForHoles, !e) t.instructions = this.instructions.slice();
      else for (let r = 0; r < this.instructions.length; r++) {
        const i = this.instructions[r];
        t.instructions.push({
          action: i.action,
          data: i.data.slice()
        });
      }
      return t;
    }
    clear() {
      return this.instructions.length = 0, this._dirty = true, this;
    }
    transform(e) {
      if (e.isIdentity()) return this;
      const t = e.a, r = e.b, i = e.c, a = e.d, s = e.tx, o = e.ty;
      let l = 0, u = 0, c = 0, h = 0, d = 0, f = 0, p = 0, g = 0;
      for (let m = 0; m < this.instructions.length; m++) {
        const v = this.instructions[m], y = v.data;
        switch (v.action) {
          case "moveTo":
          case "lineTo":
            l = y[0], u = y[1], y[0] = t * l + i * u + s, y[1] = r * l + a * u + o;
            break;
          case "bezierCurveTo":
            c = y[0], h = y[1], d = y[2], f = y[3], l = y[4], u = y[5], y[0] = t * c + i * h + s, y[1] = r * c + a * h + o, y[2] = t * d + i * f + s, y[3] = r * d + a * f + o, y[4] = t * l + i * u + s, y[5] = r * l + a * u + o;
            break;
          case "quadraticCurveTo":
            c = y[0], h = y[1], l = y[2], u = y[3], y[0] = t * c + i * h + s, y[1] = r * c + a * h + o, y[2] = t * l + i * u + s, y[3] = r * l + a * u + o;
            break;
          case "arcToSvg":
            l = y[5], u = y[6], p = y[0], g = y[1], y[0] = t * p + i * g, y[1] = r * p + a * g, y[5] = t * l + i * u + s, y[6] = r * l + a * u + o;
            break;
          case "circle":
            y[4] = ky(y[3], e);
            break;
          case "rect":
            y[4] = ky(y[4], e);
            break;
          case "ellipse":
            y[8] = ky(y[8], e);
            break;
          case "roundRect":
            y[5] = ky(y[5], e);
            break;
          case "addPath":
            y[0].transform(e);
            break;
          case "poly":
            y[2] = ky(y[2], e);
            break;
          default:
            Ua("unknown transform action", v.action);
            break;
        }
      }
      return this._dirty = true, this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(e) {
      let t = this.instructions.length - 1, r = this.instructions[t];
      if (!r) return e.x = 0, e.y = 0, e;
      for (; r.action === "closePath"; ) {
        if (t--, t < 0) return e.x = 0, e.y = 0, e;
        r = this.instructions[t];
      }
      switch (r.action) {
        case "moveTo":
        case "lineTo":
          e.x = r.data[0], e.y = r.data[1];
          break;
        case "quadraticCurveTo":
          e.x = r.data[2], e.y = r.data[3];
          break;
        case "bezierCurveTo":
          e.x = r.data[4], e.y = r.data[5];
          break;
        case "arc":
        case "arcToSvg":
          e.x = r.data[5], e.y = r.data[6];
          break;
        case "addPath":
          r.data[0].getLastPoint(e);
          break;
      }
      return e;
    }
  }
  function ky(n, e) {
    return n ? n.prepend(e) : e.clone();
  }
  function ar(n, e, t) {
    const r = n.getAttribute(e);
    return r ? Number(r) : t;
  }
  function ygt(n, e) {
    const t = n.querySelectorAll("defs");
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      for (let a = 0; a < i.children.length; a++) {
        const s = i.children[a];
        switch (s.nodeName.toLowerCase()) {
          case "lineargradient":
            e.defs[s.id] = xgt(s);
            break;
          case "radialgradient":
            e.defs[s.id] = bgt();
            break;
        }
      }
    }
  }
  function xgt(n) {
    const e = ar(n, "x1", 0), t = ar(n, "y1", 0), r = ar(n, "x2", 1), i = ar(n, "y2", 0), a = n.getAttribute("gradientUnits") || "objectBoundingBox", s = new Nd(e, t, r, i, a === "objectBoundingBox" ? "local" : "global");
    for (let o = 0; o < n.children.length; o++) {
      const l = n.children[o], u = ar(l, "offset", 0), c = Ei.shared.setValue(l.getAttribute("stop-color")).toNumber();
      s.addColorStop(u, c);
    }
    return s;
  }
  function bgt(n) {
    return Ua("[SVG Parser] Radial gradients are not yet supported"), new Nd(0, 0, 1, 0);
  }
  function o5(n) {
    const e = n.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return e ? e[1] : "";
  }
  const l5 = {
    fill: {
      type: "paint",
      default: 0
    },
    "fill-opacity": {
      type: "number",
      default: 1
    },
    stroke: {
      type: "paint",
      default: 0
    },
    "stroke-width": {
      type: "number",
      default: 1
    },
    "stroke-opacity": {
      type: "number",
      default: 1
    },
    "stroke-linecap": {
      type: "string",
      default: "butt"
    },
    "stroke-linejoin": {
      type: "string",
      default: "miter"
    },
    "stroke-miterlimit": {
      type: "number",
      default: 10
    },
    "stroke-dasharray": {
      type: "string",
      default: "none"
    },
    "stroke-dashoffset": {
      type: "number",
      default: 0
    },
    opacity: {
      type: "number",
      default: 1
    }
  };
  function Jie(n, e) {
    const t = n.getAttribute("style"), r = {}, i = {}, a = {
      strokeStyle: r,
      fillStyle: i,
      useFill: false,
      useStroke: false
    };
    for (const s in l5) {
      const o = n.getAttribute(s);
      o && u5(e, a, s, o.trim());
    }
    if (t) {
      const s = t.split(";");
      for (let o = 0; o < s.length; o++) {
        const l = s[o].trim(), [u, c] = l.split(":");
        l5[u] && u5(e, a, u, c.trim());
      }
    }
    return {
      strokeStyle: a.useStroke ? r : null,
      fillStyle: a.useFill ? i : null,
      useFill: a.useFill,
      useStroke: a.useStroke
    };
  }
  function u5(n, e, t, r) {
    switch (t) {
      case "stroke":
        if (r !== "none") {
          if (r.startsWith("url(")) {
            const i = o5(r);
            e.strokeStyle.fill = n.defs[i];
          } else e.strokeStyle.color = Ei.shared.setValue(r).toNumber();
          e.useStroke = true;
        }
        break;
      case "stroke-width":
        e.strokeStyle.width = Number(r);
        break;
      case "fill":
        if (r !== "none") {
          if (r.startsWith("url(")) {
            const i = o5(r);
            e.fillStyle.fill = n.defs[i];
          } else e.fillStyle.color = Ei.shared.setValue(r).toNumber();
          e.useFill = true;
        }
        break;
      case "fill-opacity":
        e.fillStyle.alpha = Number(r);
        break;
      case "stroke-opacity":
        e.strokeStyle.alpha = Number(r);
        break;
      case "opacity":
        e.fillStyle.alpha = Number(r), e.strokeStyle.alpha = Number(r);
        break;
    }
  }
  function wgt(n, e) {
    if (typeof n == "string") {
      const s = document.createElement("div");
      s.innerHTML = n.trim(), n = s.querySelector("svg");
    }
    const t = {
      context: e,
      defs: {},
      path: new sm()
    };
    ygt(n, t);
    const r = n.children, { fillStyle: i, strokeStyle: a } = Jie(n, t);
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      o.nodeName.toLowerCase() !== "defs" && eae(o, t, i, a);
    }
    return e;
  }
  function eae(n, e, t, r) {
    const i = n.children, { fillStyle: a, strokeStyle: s } = Jie(n, e);
    a && t ? t = {
      ...t,
      ...a
    } : a && (t = a), s && r ? r = {
      ...r,
      ...s
    } : s && (r = s);
    const o = !t && !r;
    o && (t = {
      color: 0
    });
    let l, u, c, h, d, f, p, g, m, v, y, x, b, w, _, S, I;
    switch (n.nodeName.toLowerCase()) {
      case "path":
        w = n.getAttribute("d"), n.getAttribute("fill-rule") === "evenodd" && Ua("SVG Evenodd fill rule not supported, your svg may render incorrectly"), _ = new sm(w, true), e.context.path(_), t && e.context.fill(t), r && e.context.stroke(r);
        break;
      case "circle":
        p = ar(n, "cx", 0), g = ar(n, "cy", 0), m = ar(n, "r", 0), e.context.ellipse(p, g, m, m), t && e.context.fill(t), r && e.context.stroke(r);
        break;
      case "rect":
        l = ar(n, "x", 0), u = ar(n, "y", 0), S = ar(n, "width", 0), I = ar(n, "height", 0), v = ar(n, "rx", 0), y = ar(n, "ry", 0), v || y ? e.context.roundRect(l, u, S, I, v || y) : e.context.rect(l, u, S, I), t && e.context.fill(t), r && e.context.stroke(r);
        break;
      case "ellipse":
        p = ar(n, "cx", 0), g = ar(n, "cy", 0), v = ar(n, "rx", 0), y = ar(n, "ry", 0), e.context.beginPath(), e.context.ellipse(p, g, v, y), t && e.context.fill(t), r && e.context.stroke(r);
        break;
      case "line":
        c = ar(n, "x1", 0), h = ar(n, "y1", 0), d = ar(n, "x2", 0), f = ar(n, "y2", 0), e.context.beginPath(), e.context.moveTo(c, h), e.context.lineTo(d, f), r && e.context.stroke(r);
        break;
      case "polygon":
        b = n.getAttribute("points"), x = b.match(/\d+/g).map((C) => parseInt(C, 10)), e.context.poly(x, true), t && e.context.fill(t), r && e.context.stroke(r);
        break;
      case "polyline":
        b = n.getAttribute("points"), x = b.match(/\d+/g).map((C) => parseInt(C, 10)), e.context.poly(x, false), r && e.context.stroke(r);
        break;
      case "g":
      case "svg":
        break;
      default: {
        Ua(`[SVG parser] <${n.nodeName}> elements unsupported`);
        break;
      }
    }
    o && (t = null);
    for (let C = 0; C < i.length; C++) eae(i[C], e, t, r);
  }
  function _gt(n) {
    return Ei.isColorLike(n);
  }
  function c5(n) {
    return n instanceof YL;
  }
  function h5(n) {
    return n instanceof Nd;
  }
  function Sgt(n) {
    return n instanceof Fn;
  }
  function Cgt(n, e, t) {
    const r = Ei.shared.setValue(e ?? 0);
    return n.color = r.toNumber(), n.alpha = r.alpha === 1 ? t.alpha : r.alpha, n.texture = Fn.WHITE, {
      ...t,
      ...n
    };
  }
  function Igt(n, e, t) {
    return n.texture = e, {
      ...t,
      ...n
    };
  }
  function d5(n, e, t) {
    return n.fill = e, n.color = 16777215, n.texture = e.texture, n.matrix = e.transform, {
      ...t,
      ...n
    };
  }
  function f5(n, e, t) {
    return e.buildGradient(), n.fill = e, n.color = 16777215, n.texture = e.texture, n.matrix = e.transform, n.textureSpace = e.textureSpace, {
      ...t,
      ...n
    };
  }
  function kgt(n, e) {
    const t = {
      ...e,
      ...n
    }, r = Ei.shared.setValue(t.color);
    return t.alpha *= r.alpha, t.color = r.toNumber(), t;
  }
  function Hh(n, e) {
    if (n == null) return null;
    const t = {}, r = n;
    return _gt(n) ? Cgt(t, n, e) : Sgt(n) ? Igt(t, n, e) : c5(n) ? d5(t, n, e) : h5(n) ? f5(t, n, e) : r.fill && c5(r.fill) ? d5(r, r.fill, e) : r.fill && h5(r.fill) ? f5(r, r.fill, e) : kgt(r, e);
  }
  function iC(n, e) {
    const { width: t, alignment: r, miterLimit: i, cap: a, join: s, pixelLine: o, ...l } = e, u = Hh(n, l);
    return u ? {
      width: t,
      alignment: r,
      miterLimit: i,
      cap: a,
      join: s,
      pixelLine: o,
      ...u
    } : null;
  }
  const Tgt = new Ri(), p5 = new pn(), QL = class Do extends fl {
    constructor() {
      super(...arguments), this.uid = Dr("graphicsContext"), this.dirty = true, this.batchMode = "auto", this.instructions = [], this._activePath = new sm(), this._transform = new pn(), this._fillStyle = {
        ...Do.defaultFillStyle
      }, this._strokeStyle = {
        ...Do.defaultStrokeStyle
      }, this._stateStack = [], this._tick = 0, this._bounds = new co(), this._boundsDirty = true;
    }
    clone() {
      const e = new Do();
      return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = {
        ...this._fillStyle
      }, e._strokeStyle = {
        ...this._strokeStyle
      }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = true, e;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(e) {
      this._fillStyle = Hh(e, Do.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(e) {
      this._strokeStyle = iC(e, Do.defaultStrokeStyle);
    }
    setFillStyle(e) {
      return this._fillStyle = Hh(e, Do.defaultFillStyle), this;
    }
    setStrokeStyle(e) {
      return this._strokeStyle = Hh(e, Do.defaultStrokeStyle), this;
    }
    texture(e, t, r, i, a, s) {
      return this.instructions.push({
        action: "texture",
        data: {
          image: e,
          dx: r || 0,
          dy: i || 0,
          dw: a || e.frame.width,
          dh: s || e.frame.height,
          transform: this._transform.clone(),
          alpha: this._fillStyle.alpha,
          style: t ? Ei.shared.setValue(t).toNumber() : 16777215
        }
      }), this.onUpdate(), this;
    }
    beginPath() {
      return this._activePath = new sm(), this;
    }
    fill(e, t) {
      let r;
      const i = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && i && i.action === "stroke" ? r = i.data.path : r = this._activePath.clone(), r ? (e != null && (t !== void 0 && typeof e == "number" && (Gn(or, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = {
        color: e,
        alpha: t
      }), this._fillStyle = Hh(e, Do.defaultFillStyle)), this.instructions.push({
        action: "fill",
        data: {
          style: this.fillStyle,
          path: r
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    _initNextPathLocation() {
      const { x: e, y: t } = this._activePath.getLastPoint(Ri.shared);
      this._activePath.clear(), this._activePath.moveTo(e, t);
    }
    stroke(e) {
      let t;
      const r = this.instructions[this.instructions.length - 1];
      return this._tick === 0 && r && r.action === "fill" ? t = r.data.path : t = this._activePath.clone(), t ? (e != null && (this._strokeStyle = iC(e, Do.defaultStrokeStyle)), this.instructions.push({
        action: "stroke",
        data: {
          style: this.strokeStyle,
          path: t
        }
      }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
    }
    cut() {
      for (let e = 0; e < 2; e++) {
        const t = this.instructions[this.instructions.length - 1 - e], r = this._activePath.clone();
        if (t && (t.action === "stroke" || t.action === "fill")) if (t.data.hole) t.data.hole.addPath(r);
        else {
          t.data.hole = r;
          break;
        }
      }
      return this._initNextPathLocation(), this;
    }
    arc(e, t, r, i, a, s) {
      this._tick++;
      const o = this._transform;
      return this._activePath.arc(o.a * e + o.c * t + o.tx, o.b * e + o.d * t + o.ty, r, i, a, s), this;
    }
    arcTo(e, t, r, i, a) {
      this._tick++;
      const s = this._transform;
      return this._activePath.arcTo(s.a * e + s.c * t + s.tx, s.b * e + s.d * t + s.ty, s.a * r + s.c * i + s.tx, s.b * r + s.d * i + s.ty, a), this;
    }
    arcToSvg(e, t, r, i, a, s, o) {
      this._tick++;
      const l = this._transform;
      return this._activePath.arcToSvg(e, t, r, i, a, l.a * s + l.c * o + l.tx, l.b * s + l.d * o + l.ty), this;
    }
    bezierCurveTo(e, t, r, i, a, s, o) {
      this._tick++;
      const l = this._transform;
      return this._activePath.bezierCurveTo(l.a * e + l.c * t + l.tx, l.b * e + l.d * t + l.ty, l.a * r + l.c * i + l.tx, l.b * r + l.d * i + l.ty, l.a * a + l.c * s + l.tx, l.b * a + l.d * s + l.ty, o), this;
    }
    closePath() {
      var _a2;
      return this._tick++, (_a2 = this._activePath) == null ? void 0 : _a2.closePath(), this;
    }
    ellipse(e, t, r, i) {
      return this._tick++, this._activePath.ellipse(e, t, r, i, this._transform.clone()), this;
    }
    circle(e, t, r) {
      return this._tick++, this._activePath.circle(e, t, r, this._transform.clone()), this;
    }
    path(e) {
      return this._tick++, this._activePath.addPath(e, this._transform.clone()), this;
    }
    lineTo(e, t) {
      this._tick++;
      const r = this._transform;
      return this._activePath.lineTo(r.a * e + r.c * t + r.tx, r.b * e + r.d * t + r.ty), this;
    }
    moveTo(e, t) {
      this._tick++;
      const r = this._transform, i = this._activePath.instructions, a = r.a * e + r.c * t + r.tx, s = r.b * e + r.d * t + r.ty;
      return i.length === 1 && i[0].action === "moveTo" ? (i[0].data[0] = a, i[0].data[1] = s, this) : (this._activePath.moveTo(a, s), this);
    }
    quadraticCurveTo(e, t, r, i, a) {
      this._tick++;
      const s = this._transform;
      return this._activePath.quadraticCurveTo(s.a * e + s.c * t + s.tx, s.b * e + s.d * t + s.ty, s.a * r + s.c * i + s.tx, s.b * r + s.d * i + s.ty, a), this;
    }
    rect(e, t, r, i) {
      return this._tick++, this._activePath.rect(e, t, r, i, this._transform.clone()), this;
    }
    roundRect(e, t, r, i, a) {
      return this._tick++, this._activePath.roundRect(e, t, r, i, a, this._transform.clone()), this;
    }
    poly(e, t) {
      return this._tick++, this._activePath.poly(e, t, this._transform.clone()), this;
    }
    regularPoly(e, t, r, i, a = 0, s) {
      return this._tick++, this._activePath.regularPoly(e, t, r, i, a, s), this;
    }
    roundPoly(e, t, r, i, a, s) {
      return this._tick++, this._activePath.roundPoly(e, t, r, i, a, s), this;
    }
    roundShape(e, t, r, i) {
      return this._tick++, this._activePath.roundShape(e, t, r, i), this;
    }
    filletRect(e, t, r, i, a) {
      return this._tick++, this._activePath.filletRect(e, t, r, i, a), this;
    }
    chamferRect(e, t, r, i, a, s) {
      return this._tick++, this._activePath.chamferRect(e, t, r, i, a, s), this;
    }
    star(e, t, r, i, a = 0, s = 0) {
      return this._tick++, this._activePath.star(e, t, r, i, a, s, this._transform.clone()), this;
    }
    svg(e) {
      return this._tick++, wgt(e, this), this;
    }
    restore() {
      const e = this._stateStack.pop();
      return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this;
    }
    save() {
      return this._stateStack.push({
        transform: this._transform.clone(),
        fillStyle: {
          ...this._fillStyle
        },
        strokeStyle: {
          ...this._strokeStyle
        }
      }), this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      return this._transform.identity(), this;
    }
    rotate(e) {
      return this._transform.rotate(e), this;
    }
    scale(e, t = e) {
      return this._transform.scale(e, t), this;
    }
    setTransform(e, t, r, i, a, s) {
      return e instanceof pn ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, t, r, i, a, s), this);
    }
    transform(e, t, r, i, a, s) {
      return e instanceof pn ? (this._transform.append(e), this) : (p5.set(e, t, r, i, a, s), this._transform.append(p5), this);
    }
    translate(e, t = e) {
      return this._transform.translate(e, t), this;
    }
    clear() {
      return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
    }
    onUpdate() {
      this.dirty || (this.emit("update", this, 16), this.dirty = true, this._boundsDirty = true);
    }
    get bounds() {
      if (!this._boundsDirty) return this._bounds;
      const e = this._bounds;
      e.clear();
      for (let t = 0; t < this.instructions.length; t++) {
        const r = this.instructions[t], i = r.action;
        if (i === "fill") {
          const a = r.data;
          e.addBounds(a.path.bounds);
        } else if (i === "texture") {
          const a = r.data;
          e.addFrame(a.dx, a.dy, a.dx + a.dw, a.dy + a.dh, a.transform);
        }
        if (i === "stroke") {
          const a = r.data, s = a.style.alignment, o = a.style.width * (1 - s), l = a.path.bounds;
          e.addFrame(l.minX - o, l.minY - o, l.maxX + o, l.maxY + o);
        }
      }
      return e;
    }
    containsPoint(e) {
      var _a2;
      if (!this.bounds.containsPoint(e.x, e.y)) return false;
      const t = this.instructions;
      let r = false;
      for (let i = 0; i < t.length; i++) {
        const a = t[i], s = a.data, o = s.path;
        if (!a.action || !o) continue;
        const l = s.style, u = o.shapePath.shapePrimitives;
        for (let c = 0; c < u.length; c++) {
          const h = u[c].shape;
          if (!l || !h) continue;
          const d = u[c].transform, f = d ? d.applyInverse(e, Tgt) : e;
          if (a.action === "fill") r = h.contains(f.x, f.y);
          else {
            const g = l;
            r = h.strokeContains(f.x, f.y, g.width, g.alignment);
          }
          const p = s.hole;
          if (p) {
            const g = (_a2 = p.shapePath) == null ? void 0 : _a2.shapePrimitives;
            if (g) for (let m = 0; m < g.length; m++) g[m].shape.contains(f.x, f.y) && (r = false);
          }
          if (r) return true;
        }
      }
      return r;
    }
    destroy(e = false) {
      if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        this._fillStyle.texture && this._fillStyle.texture.destroy(r), this._strokeStyle.texture && this._strokeStyle.texture.destroy(r);
      }
      this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
    }
  };
  QL.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: Fn.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local"
  };
  QL.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: 0.5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: Fn.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: false
  };
  let Us = QL;
  const g5 = [
    "align",
    "breakWords",
    "cssOverrides",
    "fontVariant",
    "fontWeight",
    "leading",
    "letterSpacing",
    "lineHeight",
    "padding",
    "textBaseline",
    "trim",
    "whiteSpace",
    "wordWrap",
    "wordWrapWidth",
    "fontFamily",
    "fontStyle",
    "fontSize"
  ];
  Agt = function(n) {
    const e = [];
    let t = 0;
    for (let r = 0; r < g5.length; r++) {
      const i = `_${g5[r]}`;
      e[t++] = n[i];
    }
    return t = tae(n._fill, e, t), t = Dgt(n._stroke, e, t), t = Rgt(n.dropShadow, e, t), e.join("-");
  };
  function tae(n, e, t) {
    var _a2;
    return n && (e[t++] = n.color, e[t++] = n.alpha, e[t++] = (_a2 = n.fill) == null ? void 0 : _a2.styleKey), t;
  }
  function Dgt(n, e, t) {
    return n && (t = tae(n, e, t), e[t++] = n.width, e[t++] = n.alignment, e[t++] = n.cap, e[t++] = n.join, e[t++] = n.miterLimit), t;
  }
  function Rgt(n, e, t) {
    return n && (e[t++] = n.alpha, e[t++] = n.angle, e[t++] = n.blur, e[t++] = n.distance, e[t++] = Ei.shared.setValue(n.color).toNumber()), t;
  }
  const JL = class fg extends fl {
    constructor(e = {}) {
      super(), $gt(e);
      const t = {
        ...fg.defaultTextStyle,
        ...e
      };
      for (const r in t) {
        const i = r;
        this[i] = t[r];
      }
      this.update();
    }
    get align() {
      return this._align;
    }
    set align(e) {
      this._align = e, this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(e) {
      this._breakWords = e, this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(e) {
      e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({
        ...fg.defaultDropShadow,
        ...e
      }) : this._dropShadow = e ? this._createProxy({
        ...fg.defaultDropShadow
      }) : null, this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(e) {
      this._fontFamily = e, this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(e) {
      typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(e) {
      this._fontStyle = e.toLowerCase(), this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(e) {
      this._fontVariant = e, this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(e) {
      this._fontWeight = e, this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(e) {
      this._leading = e, this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(e) {
      this._letterSpacing = e, this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(e) {
      this._lineHeight = e, this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(e) {
      this._padding = e, this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(e) {
      this._trim = e, this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(e) {
      this._textBaseline = e, this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(e) {
      this._whiteSpace = e, this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(e) {
      this._wordWrap = e, this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(e) {
      this._wordWrapWidth = e, this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(e) {
      e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({
        ...Us.defaultFillStyle,
        ...e
      }, () => {
        this._fill = Hh({
          ...this._originalFill
        }, Us.defaultFillStyle);
      })), this._fill = Hh(e === 0 ? "black" : e, Us.defaultFillStyle), this.update());
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(e) {
      e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({
        ...Us.defaultStrokeStyle,
        ...e
      }, () => {
        this._stroke = iC({
          ...this._originalStroke
        }, Us.defaultStrokeStyle);
      })), this._stroke = iC(e, Us.defaultStrokeStyle), this.update());
    }
    _generateKey() {
      return this._styleKey = Agt(this), this._styleKey;
    }
    update() {
      this._styleKey = null, this.emit("update", this);
    }
    reset() {
      const e = fg.defaultTextStyle;
      for (const t in e) this[t] = e[t];
    }
    get styleKey() {
      return this._styleKey || this._generateKey();
    }
    clone() {
      return new fg({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? {
          ...this._dropShadow
        } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth
      });
    }
    destroy(e = false) {
      var _a2, _b2, _c2, _d2;
      if (this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
        const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
        ((_a2 = this._fill) == null ? void 0 : _a2.texture) && this._fill.texture.destroy(r), ((_b2 = this._originalFill) == null ? void 0 : _b2.texture) && this._originalFill.texture.destroy(r), ((_c2 = this._stroke) == null ? void 0 : _c2.texture) && this._stroke.texture.destroy(r), ((_d2 = this._originalStroke) == null ? void 0 : _d2.texture) && this._originalStroke.texture.destroy(r);
      }
      this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
    }
    _createProxy(e, t) {
      return new Proxy(e, {
        set: (r, i, a) => (r[i] = a, t == null ? void 0 : t(i, a), this.update(), true)
      });
    }
    _isFillStyle(e) {
      return (e ?? null) !== null && !(Ei.isColorLike(e) || e instanceof Nd || e instanceof YL);
    }
  };
  JL.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
  };
  JL.defaultTextStyle = {
    align: "left",
    breakWords: false,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100
  };
  uN = JL;
  function $gt(n) {
    const e = n;
    if (typeof e.dropShadow == "boolean" && e.dropShadow) {
      const t = uN.defaultDropShadow;
      n.dropShadow = {
        alpha: e.dropShadowAlpha ?? t.alpha,
        angle: e.dropShadowAngle ?? t.angle,
        blur: e.dropShadowBlur ?? t.blur,
        color: e.dropShadowColor ?? t.color,
        distance: e.dropShadowDistance ?? t.distance
      };
    }
    if (e.strokeThickness !== void 0) {
      Gn(or, "strokeThickness is now a part of stroke");
      const t = e.stroke;
      let r = {};
      if (Ei.isColorLike(t)) r.color = t;
      else if (t instanceof Nd || t instanceof YL) r.fill = t;
      else if (Object.hasOwnProperty.call(t, "color") || Object.hasOwnProperty.call(t, "fill")) r = t;
      else throw new Error("Invalid stroke value.");
      n.stroke = {
        ...r,
        width: e.strokeThickness
      };
    }
    if (Array.isArray(e.fillGradientStops)) {
      Gn(or, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let t;
      n.fontSize == null ? n.fontSize = uN.defaultTextStyle.fontSize : typeof n.fontSize == "string" ? t = parseInt(n.fontSize, 10) : t = n.fontSize;
      const r = new Nd({
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0,
          y: (t || 0) * 1.7
        }
      }), i = e.fillGradientStops.map((a) => Ei.shared.setValue(a).toNumber());
      i.forEach((a, s) => {
        const o = s / (i.length - 1);
        r.addColorStop(o, a);
      }), n.fill = {
        fill: r
      };
    }
  }
  const Ngt = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  Egt = function(n) {
    const e = typeof n.fontSize == "number" ? `${n.fontSize}px` : n.fontSize;
    let t = n.fontFamily;
    Array.isArray(n.fontFamily) || (t = n.fontFamily.split(","));
    for (let r = t.length - 1; r >= 0; r--) {
      let i = t[r].trim();
      !/([\"\'])[^\'\"]+\1/.test(i) && !Ngt.includes(i) && (i = `"${i}"`), t[r] = i;
    }
    return `${n.fontStyle} ${n.fontVariant} ${n.fontWeight} ${e} ${t.join(",")}`;
  };
  const QA = {
    willReadFrequently: true
  }, vo = class st {
    static get experimentalLetterSpacingSupported() {
      let e = st._experimentalLetterSpacingSupported;
      if (e !== void 0) {
        const t = to.get().getCanvasRenderingContext2D().prototype;
        e = st._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t;
      }
      return e;
    }
    constructor(e, t, r, i, a, s, o, l, u) {
      this.text = e, this.style = t, this.width = r, this.height = i, this.lines = a, this.lineWidths = s, this.lineHeight = o, this.maxLineWidth = l, this.fontProperties = u;
    }
    static measureText(e = " ", t, r = st._canvas, i = t.wordWrap) {
      var _a2;
      const a = `${e}:${t.styleKey}`;
      if (st._measurementCache[a]) return st._measurementCache[a];
      const s = Egt(t), o = st.measureFont(s);
      o.fontSize === 0 && (o.fontSize = t.fontSize, o.ascent = t.fontSize);
      const l = st.__context;
      l.font = s;
      const c = (i ? st._wordWrap(e, t, r) : e).split(/(?:\r\n|\r|\n)/), h = new Array(c.length);
      let d = 0;
      for (let y = 0; y < c.length; y++) {
        const x = st._measureText(c[y], t.letterSpacing, l);
        h[y] = x, d = Math.max(d, x);
      }
      const f = ((_a2 = t._stroke) == null ? void 0 : _a2.width) || 0;
      let p = d + f;
      t.dropShadow && (p += t.dropShadow.distance);
      const g = t.lineHeight || o.fontSize;
      let m = Math.max(g, o.fontSize + f) + (c.length - 1) * (g + t.leading);
      return t.dropShadow && (m += t.dropShadow.distance), new st(e, t, p, m, c, h, g + t.leading, d, o);
    }
    static _measureText(e, t, r) {
      let i = false;
      st.experimentalLetterSpacingSupported && (st.experimentalLetterSpacing ? (r.letterSpacing = `${t}px`, r.textLetterSpacing = `${t}px`, i = true) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
      const a = r.measureText(e);
      let s = a.width;
      const o = -a.actualBoundingBoxLeft;
      let u = a.actualBoundingBoxRight - o;
      if (s > 0) if (i) s -= t, u -= t;
      else {
        const c = (st.graphemeSegmenter(e).length - 1) * t;
        s += c, u += c;
      }
      return Math.max(s, u);
    }
    static _wordWrap(e, t, r = st._canvas) {
      const i = r.getContext("2d", QA);
      let a = 0, s = "", o = "";
      const l = /* @__PURE__ */ Object.create(null), { letterSpacing: u, whiteSpace: c } = t, h = st._collapseSpaces(c), d = st._collapseNewlines(c);
      let f = !h;
      const p = t.wordWrapWidth + u, g = st._tokenize(e);
      for (let m = 0; m < g.length; m++) {
        let v = g[m];
        if (st._isNewline(v)) {
          if (!d) {
            o += st._addLine(s), f = !h, s = "", a = 0;
            continue;
          }
          v = " ";
        }
        if (h) {
          const x = st.isBreakingSpace(v), b = st.isBreakingSpace(s[s.length - 1]);
          if (x && b) continue;
        }
        const y = st._getFromCache(v, u, l, i);
        if (y > p) if (s !== "" && (o += st._addLine(s), s = "", a = 0), st.canBreakWords(v, t.breakWords)) {
          const x = st.wordWrapSplit(v);
          for (let b = 0; b < x.length; b++) {
            let w = x[b], _ = w, S = 1;
            for (; x[b + S]; ) {
              const C = x[b + S];
              if (!st.canBreakChars(_, C, v, b, t.breakWords)) w += C;
              else break;
              _ = C, S++;
            }
            b += S - 1;
            const I = st._getFromCache(w, u, l, i);
            I + a > p && (o += st._addLine(s), f = false, s = "", a = 0), s += w, a += I;
          }
        } else {
          s.length > 0 && (o += st._addLine(s), s = "", a = 0);
          const x = m === g.length - 1;
          o += st._addLine(v, !x), f = false, s = "", a = 0;
        }
        else y + a > p && (f = false, o += st._addLine(s), s = "", a = 0), (s.length > 0 || !st.isBreakingSpace(v) || f) && (s += v, a += y);
      }
      return o += st._addLine(s, false), o;
    }
    static _addLine(e, t = true) {
      return e = st._trimRight(e), e = t ? `${e}
` : e, e;
    }
    static _getFromCache(e, t, r, i) {
      let a = r[e];
      return typeof a != "number" && (a = st._measureText(e, t, i) + t, r[e] = a), a;
    }
    static _collapseSpaces(e) {
      return e === "normal" || e === "pre-line";
    }
    static _collapseNewlines(e) {
      return e === "normal";
    }
    static _trimRight(e) {
      if (typeof e != "string") return "";
      for (let t = e.length - 1; t >= 0; t--) {
        const r = e[t];
        if (!st.isBreakingSpace(r)) break;
        e = e.slice(0, -1);
      }
      return e;
    }
    static _isNewline(e) {
      return typeof e != "string" ? false : st._newlines.includes(e.charCodeAt(0));
    }
    static isBreakingSpace(e, t) {
      return typeof e != "string" ? false : st._breakingSpaces.includes(e.charCodeAt(0));
    }
    static _tokenize(e) {
      const t = [];
      let r = "";
      if (typeof e != "string") return t;
      for (let i = 0; i < e.length; i++) {
        const a = e[i], s = e[i + 1];
        if (st.isBreakingSpace(a, s) || st._isNewline(a)) {
          r !== "" && (t.push(r), r = ""), t.push(a);
          continue;
        }
        r += a;
      }
      return r !== "" && t.push(r), t;
    }
    static canBreakWords(e, t) {
      return t;
    }
    static canBreakChars(e, t, r, i, a) {
      return true;
    }
    static wordWrapSplit(e) {
      return st.graphemeSegmenter(e);
    }
    static measureFont(e) {
      if (st._fonts[e]) return st._fonts[e];
      const t = st._context;
      t.font = e;
      const r = t.measureText(st.METRICS_STRING + st.BASELINE_SYMBOL), i = {
        ascent: r.actualBoundingBoxAscent,
        descent: r.actualBoundingBoxDescent,
        fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
      };
      return st._fonts[e] = i, i;
    }
    static clearMetrics(e = "") {
      e ? delete st._fonts[e] : st._fonts = {};
    }
    static get _canvas() {
      var _a2;
      if (!st.__canvas) {
        let e;
        try {
          const t = new OffscreenCanvas(0, 0);
          if ((_a2 = t.getContext("2d", QA)) == null ? void 0 : _a2.measureText) return st.__canvas = t, t;
          e = to.get().createCanvas();
        } catch {
          e = to.get().createCanvas();
        }
        e.width = e.height = 10, st.__canvas = e;
      }
      return st.__canvas;
    }
    static get _context() {
      return st.__context || (st.__context = st._canvas.getContext("2d", QA)), st.__context;
    }
  };
  vo.METRICS_STRING = "|\xC9q\xC5";
  vo.BASELINE_SYMBOL = "M";
  vo.BASELINE_MULTIPLIER = 1.4;
  vo.HEIGHT_MULTIPLIER = 2;
  vo.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
      const n = new Intl.Segmenter();
      return (e) => [
        ...n.segment(e)
      ].map((t) => t.segment);
    }
    return (n) => [
      ...n
    ];
  })();
  vo.experimentalLetterSpacing = false;
  vo._fonts = {};
  vo._newlines = [
    10,
    13
  ];
  vo._breakingSpaces = [
    9,
    32,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8200,
    8201,
    8202,
    8287,
    12288
  ];
  vo._measurementCache = {};
  Mgt = vo;
  aC = class extends GL {
    constructor(e) {
      e instanceof Us && (e = {
        context: e
      });
      const { context: t, roundPixels: r, ...i } = e || {};
      super({
        label: "Graphics",
        ...i
      }), this.renderPipeId = "graphics", t ? this._context = t : this._context = this._ownedContext = new Us(), this._context.on("update", this.onViewUpdate, this), this.allowChildren = false, this.roundPixels = r ?? false;
    }
    set context(e) {
      e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    updateBounds() {
    }
    containsPoint(e) {
      return this._context.containsPoint(e);
    }
    destroy(e) {
      this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === true || (e == null ? void 0 : e.context) === true) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e);
    }
    _callContextMethod(e, t) {
      return this.context[e](...t), this;
    }
    setFillStyle(...e) {
      return this._callContextMethod("setFillStyle", e);
    }
    setStrokeStyle(...e) {
      return this._callContextMethod("setStrokeStyle", e);
    }
    fill(...e) {
      return this._callContextMethod("fill", e);
    }
    stroke(...e) {
      return this._callContextMethod("stroke", e);
    }
    texture(...e) {
      return this._callContextMethod("texture", e);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...e) {
      return this._callContextMethod("arc", e);
    }
    arcTo(...e) {
      return this._callContextMethod("arcTo", e);
    }
    arcToSvg(...e) {
      return this._callContextMethod("arcToSvg", e);
    }
    bezierCurveTo(...e) {
      return this._callContextMethod("bezierCurveTo", e);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...e) {
      return this._callContextMethod("ellipse", e);
    }
    circle(...e) {
      return this._callContextMethod("circle", e);
    }
    path(...e) {
      return this._callContextMethod("path", e);
    }
    lineTo(...e) {
      return this._callContextMethod("lineTo", e);
    }
    moveTo(...e) {
      return this._callContextMethod("moveTo", e);
    }
    quadraticCurveTo(...e) {
      return this._callContextMethod("quadraticCurveTo", e);
    }
    rect(...e) {
      return this._callContextMethod("rect", e);
    }
    roundRect(...e) {
      return this._callContextMethod("roundRect", e);
    }
    poly(...e) {
      return this._callContextMethod("poly", e);
    }
    regularPoly(...e) {
      return this._callContextMethod("regularPoly", e);
    }
    roundPoly(...e) {
      return this._callContextMethod("roundPoly", e);
    }
    roundShape(...e) {
      return this._callContextMethod("roundShape", e);
    }
    filletRect(...e) {
      return this._callContextMethod("filletRect", e);
    }
    chamferRect(...e) {
      return this._callContextMethod("chamferRect", e);
    }
    star(...e) {
      return this._callContextMethod("star", e);
    }
    svg(...e) {
      return this._callContextMethod("svg", e);
    }
    restore(...e) {
      return this._callContextMethod("restore", e);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...e) {
      return this._callContextMethod("rotate", e);
    }
    scaleTransform(...e) {
      return this._callContextMethod("scale", e);
    }
    setTransform(...e) {
      return this._callContextMethod("setTransform", e);
    }
    transform(...e) {
      return this._callContextMethod("transform", e);
    }
    translateTransform(...e) {
      return this._callContextMethod("translate", e);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(e) {
      this._context.fillStyle = e;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(e) {
      this._context.strokeStyle = e;
    }
    clone(e = false) {
      return e ? new aC(this._context.clone()) : (this._ownedContext = null, new aC(this._context));
    }
    lineStyle(e, t, r) {
      Gn(or, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
      const i = {};
      return e && (i.width = e), t && (i.color = t), r && (i.alpha = r), this.context.strokeStyle = i, this;
    }
    beginFill(e, t) {
      Gn(or, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
      const r = {};
      return e !== void 0 && (r.color = e), t !== void 0 && (r.alpha = t), this.context.fillStyle = r, this;
    }
    endFill() {
      Gn(or, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
      const e = this.context.strokeStyle;
      return (e.width !== Us.defaultStrokeStyle.width || e.color !== Us.defaultStrokeStyle.color || e.alpha !== Us.defaultStrokeStyle.alpha) && this.context.stroke(), this;
    }
    drawCircle(...e) {
      return Gn(or, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e);
    }
    drawEllipse(...e) {
      return Gn(or, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e);
    }
    drawPolygon(...e) {
      return Gn(or, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e);
    }
    drawRect(...e) {
      return Gn(or, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e);
    }
    drawRoundedRect(...e) {
      return Gn(or, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e);
    }
    drawStar(...e) {
      return Gn(or, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e);
    }
  };
  class Pgt extends GL {
    constructor(e, t) {
      const { text: r, resolution: i, style: a, anchor: s, width: o, height: l, roundPixels: u, ...c } = e;
      super({
        ...c
      }), this.batched = true, this._resolution = null, this._autoResolution = true, this._didTextUpdate = true, this._styleClass = t, this.text = r ?? "", this.style = a, this.resolution = i ?? null, this.allowChildren = false, this._anchor = new ma({
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }), s && (this.anchor = s), this.roundPixels = u ?? false, o !== void 0 && (this.width = o), l !== void 0 && (this.height = l);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    set text(e) {
      e = e.toString(), this._text !== e && (this._text = e, this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(e) {
      this._autoResolution = e === null, this._resolution = e, this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(e) {
      var _a2;
      e || (e = {}), (_a2 = this._style) == null ? void 0 : _a2.off("update", this.onViewUpdate, this), e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(e) {
      this._setWidth(e, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(e) {
      this._setHeight(e, this.bounds.height);
    }
    getSize(e) {
      return e || (e = {}), e.width = Math.abs(this.scale.x) * this.bounds.width, e.height = Math.abs(this.scale.y) * this.bounds.height, e;
    }
    setSize(e, t) {
      typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this.bounds.width), t !== void 0 && this._setHeight(t, this.bounds.height);
    }
    containsPoint(e) {
      const t = this.bounds.width, r = this.bounds.height, i = -t * this.anchor.x;
      let a = 0;
      return e.x >= i && e.x <= i + t && (a = -r * this.anchor.y, e.y >= a && e.y <= a + r);
    }
    onViewUpdate() {
      this.didViewUpdate || (this._didTextUpdate = true), super.onViewUpdate();
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    destroy(e = false) {
      super.destroy(e), this.owner = null, this._bounds = null, this._anchor = null, (typeof e == "boolean" ? e : e == null ? void 0 : e.style) && this._style.destroy(e), this._style = null, this._text = null;
    }
  }
  function Lgt(n, e) {
    let t = n[0] ?? {};
    return (typeof t == "string" || n[1]) && (Gn(or, `use new ${e}({ text: "hi!", style }) instead`), t = {
      text: t,
      style: n[1]
    }), t;
  }
  class Fgt extends Pgt {
    constructor(...e) {
      const t = Lgt(e, "Text");
      super(t, uN), this.renderPipeId = "text";
    }
    updateBounds() {
      const e = this._bounds, t = this._anchor, r = Mgt.measureText(this._text, this._style), { width: i, height: a } = r;
      e.minX = -t._x * i, e.maxX = e.minX + i, e.minY = -t._y * a, e.maxY = e.minY + a;
    }
  }
  e3 = class extends Fn {
    static create(e) {
      return new e3({
        source: new mo(e)
      });
    }
    resize(e, t, r) {
      return this.source.resize(e, t, r), this;
    }
  };
  $s.add(tdt, ndt);
  class Ogt extends Gre {
    constructor(e) {
      super(e);
      __publicField(this, "app");
      __publicField(this, "graphicsList", []);
      this.app = new Lie();
    }
    async init() {
      await this.app.init({
        canvas: this._canvas,
        width: this._canvas.width,
        height: this._canvas.height,
        backgroundAlpha: 0
      });
    }
    render(e, t, r, i, a, s = 0.6) {
      this.clear();
      const o = this.app.renderer.width, l = this.app.renderer.height, u = new hH(), c = Math.max(Math.round(Math.max(o, l) / 40), 14);
      for (let h = 0; h < r.length; ++h) {
        if (r[h] < s) continue;
        const d = t[i[h]], f = u.get(i[h]), p = (r[h] * 100).toFixed(1);
        let [g, m, v, y] = e.slice(h * 4, (h + 1) * 4);
        [m, y] = [
          m * a[0],
          y * a[0]
        ], [g, v] = [
          g * a[1],
          v * a[1]
        ];
        const x = y - m, b = v - g, w = new aC();
        w.rect(m, g, x, b).stroke({
          color: f,
          width: 2
        }).fill({
          color: hH.hexToRgba(f, 0.2)
        });
        const _ = new Fgt({
          text: `${d} - ${p}%`,
          style: {
            fontFamily: "Arial",
            fontSize: c,
            fill: "#ffffff"
          }
        }), S = _.width, I = _.height, C = g - (I + 2);
        w.fill({
          color: parseInt(f.slice(1), 16)
        }).rect(m - 1, C < 0 ? 0 : C, S + 2, I + 2).fill(), _.x = m - 1, _.y = C < 0 ? 0 : C, w.addChild(_), w.eventMode = "static", w.cursor = "pointer", w.on("mousedown", (T) => {
          var _a2;
          (_a2 = this.onSelect) == null ? void 0 : _a2.call(this, T, {
            boxes: e,
            labels: t,
            scores: r,
            classes: i,
            ratios: a,
            canvas: this.app.canvas
          });
        }), this.app.stage.addChild(w), this.graphicsList.push(w);
      }
    }
    capture(e) {
      const t = e.getContext("2d");
      return new Promise((r) => {
        const i = e3.create({
          width: this.app.canvas.width,
          height: this.app.canvas.height
        });
        this.app.ticker.addOnce(() => {
          this.app.renderer.render(this.app.stage, {
            renderTexture: i
          });
          const a = new am(i);
          t.drawImage(this.app.renderer.extract.canvas(a), 0, 0, e.width, e.height), r();
        });
      });
    }
    clear() {
      this.app.stage.removeChildren(), this.graphicsList.length = 0;
    }
    dispose() {
      this.clear(), this.app.destroy(true, {
        children: true,
        texture: true
      });
    }
  }
  function m5(n, e) {
    switch (n) {
      case "fabric":
        return new edt(e);
      case "pixi":
        return new Ogt(e);
      default:
        throw new Error(`Unsupported renderer type: ${n}`);
    }
  }
  const dh = new Jht();
  class Bgt {
    constructor(e, t) {
      __publicField(this, "labels");
      __publicField(this, "modelJson");
      __publicField(this, "loaded", false);
      __publicField(this, "inputShape");
      __publicField(this, "frameRate");
      __publicField(this, "renderer");
      __publicField(this, "detectState", false);
      this.labels = e.labels, this.modelJson = e.modelJson, (t == null ? void 0 : t.outputCanvas) && (this.renderer = m5("pixi", t.outputCanvas));
    }
    get numClass() {
      return this.labels.length;
    }
    async setRenderer(e, t, r) {
      const i = m5("pixi", t);
      await i.init(), this.renderer = i, this.renderer.onSelect = async (a, s) => {
        const [o, l, u] = this.inputShape, { canvas: c, ...h } = s, d = await this.capture(e, c);
        r({
          image: d,
          ...h,
          modelSize: [
            l,
            u
          ]
        });
      };
    }
    async capture(e, t) {
      var _a2;
      const r = document.createElement("canvas"), i = r.getContext("2d");
      return r.width = t.width, r.height = t.height, i.drawImage(e, 0, 0, r.width, r.height), await ((_a2 = this.renderer) == null ? void 0 : _a2.capture(r)), r.toDataURL();
    }
    async loadModel(e) {
      return new Promise((t, r) => {
        dh.postMessage({
          cmd: jy.loadModel,
          data: {
            model: this.modelJson,
            labels: this.labels
          }
        }), dh.onmessage = (i) => {
          var _a2;
          i.data.cmd === "loadModel" && ((_a2 = e == null ? void 0 : e.onProgress) == null ? void 0 : _a2.call(e, i.data.percent), i.data.percent === 100 && i.data.inputShape && (this.inputShape = i.data.inputShape, this.loaded = true, t(true)));
        };
      });
    }
    async detect(e, t) {
      return new Promise((r, i) => {
        dh.postMessage({
          cmd: jy.detect,
          data: {
            source: e,
            options: t
          }
        }), dh.onmessage = (a) => {
          r(a.data);
        };
      });
    }
    testRun() {
      return new Promise((e, t) => {
        this.inputShape && (dh.postMessage({
          cmd: jy.testRun
        }), dh.onmessage = (r) => {
          r.data ? e(r.data) : t(new Error("Test run failed"));
        });
      });
    }
    detectVideo(e, t = {
      once: false,
      scoreThreshold: 0.6
    }) {
      const r = async () => {
        var _a2, _b2, _c2, _d2, _e2, _f2;
        if (!this.detectState || this.loaded == null) {
          (_a2 = this.renderer) == null ? void 0 : _a2.clear();
          return;
        }
        if (e instanceof HTMLVideoElement && e.videoWidth === 0 && e.srcObject === null) {
          (_b2 = this.renderer) == null ? void 0 : _b2.clear();
          return;
        }
        if (e instanceof HTMLCanvasElement && e.width === 0) {
          (_c2 = this.renderer) == null ? void 0 : _c2.clear();
          return;
        }
        const [i, a] = this.getSourceSize(e), s = this.inputShape[2], o = Math.min(a, s) / a, l = parseInt((a * o).toString(), 10), u = parseInt((i * o).toString(), 10), c = await createImageBitmap(e, {
          resizeWidth: l,
          resizeHeight: u
        }), h = await this.detect(c, {
          scoreThreshold: t.scoreThreshold
        }), [d, f] = h.ratios;
        if (h.ratios = [
          d / o,
          f / o
        ], (_d2 = this.renderer) == null ? void 0 : _d2.render(h.boxes, h.labels, h.scores, h.classes, h.ratios, t.scoreThreshold), h.boxes.length && ((_e2 = t.onOutput) == null ? void 0 : _e2.call(t, h)), t.once && h.boxes.length) {
          (_f2 = this.renderer) == null ? void 0 : _f2.clear();
          return;
        }
        this.frameRate !== void 0 && this.frameRate !== 0 ? setTimeout(r, 1e3 / this.frameRate) : requestAnimationFrame(r);
      };
      this.detectState = true, r();
    }
    stop() {
      this.detectState = false;
    }
    dispose() {
      var _a2;
      dh.postMessage({
        cmd: jy.disposeModel
      }), (_a2 = this.renderer) == null ? void 0 : _a2.dispose();
    }
    getSourceSize(e) {
      return e instanceof HTMLVideoElement ? [
        e.videoHeight,
        e.videoWidth
      ] : [
        e.height,
        e.width
      ];
    }
  }
  const _Xh = class _Xh {
    constructor() {
      __publicField(this, "ready", false);
      __publicField(this, "model");
      __publicField(this, "modelName", "");
      __publicField(this, "loadingModel", false);
      __publicField(this, "loadingModelProgress", 0);
    }
    static getInstance() {
      return _Xh._instance || (_Xh._instance = new _Xh()), _Xh._instance;
    }
    async init(e = "webgl") {
      if (this.ready) return iA() !== e && (await g4(e), await m4(), console.log(e, iA())), true;
      try {
        return await g4(e), console.log(e, iA()), await m4(), this.ready = true, true;
      } catch (t) {
        return console.error("Failed to initialize backend:", t), false;
      }
    }
    async loadGraphModel(e, t, r = "webgl") {
      await this.init(r), this.model && (this.model.dispose(), this.model = null);
      const i = `${e}/model.json`, a = `${e}/metadata.yaml`, s = await (await fetch(a)).text(), o = qTe.load(s), l = Object.values(o.names);
      if (!l) {
        console.error("No Labels Fetched");
        return;
      }
      return this.model = new Bgt({
        modelJson: i,
        labels: l
      }), await this.model.loadModel({
        onProgress: (u) => {
          this.loadingModel = true, this.loadingModelProgress = Math.round(u), t(this.loadingModelProgress);
        }
      }), this.loadingModel = false, this.loadingModelProgress = 100, t(this.loadingModelProgress), this.modelName = e, this.model;
    }
    testRun() {
      var _a2;
      return (_a2 = this.model) == null ? void 0 : _a2.testRun();
    }
  };
  __publicField(_Xh, "_instance");
  let Xh = _Xh;
  const v5 = Xh.getInstance(), zgt = h6("video-detect", {
    state: () => ({
      backend: "webgl",
      loadedModel: "",
      loadState: {
        loading: false,
        progress: 0
      }
    }),
    actions: {
      async setBackend(n = "webgl") {
        this.backend = n;
      },
      async loadModel(n) {
        await v5.loadGraphModel(n, (e) => {
          e === 100 ? this.loadState.progress = e : (this.loadState.loading = true, this.loadState.progress = e);
        }, this.backend), await v5.testRun(), this.loadState.loading = false, this.loadedModel = n;
      }
    }
  }), Vgt = (n, e, t) => {
    const r = n[e];
    return r ? typeof r == "function" ? r() : Promise.resolve(r) : new Promise((i, a) => {
      (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(a.bind(null, new Error("Unknown variable dynamic import: " + e + (e.split("/").length !== t ? ". Note that variables only represent file names one level deep." : ""))));
    });
  };
  const sC = typeof window < "u", Ec = (n, e = false) => e ? Symbol.for(n) : Symbol(n), Wgt = (n, e, t) => Ggt({
    l: n,
    k: e,
    s: t
  }), Ggt = (n) => JSON.stringify(n).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), Ir = (n) => typeof n == "number" && isFinite(n), Ugt = (n) => t3(n) === "[object Date]", om = (n) => t3(n) === "[object RegExp]", y2 = (n) => en(n) && Object.keys(n).length === 0, Ur = Object.assign, Hgt = Object.create, Bn = (n = null) => Hgt(n);
  let y5;
  const Yh = () => y5 || (y5 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : Bn());
  function x5(n) {
    return n.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const Xgt = Object.prototype.hasOwnProperty;
  function qs(n, e) {
    return Xgt.call(n, e);
  }
  const Rr = Array.isArray, jn = (n) => typeof n == "function", Ke = (n) => typeof n == "string", vn = (n) => typeof n == "boolean", wn = (n) => n !== null && typeof n == "object", Ygt = (n) => wn(n) && jn(n.then) && jn(n.catch), nae = Object.prototype.toString, t3 = (n) => nae.call(n), en = (n) => t3(n) === "[object Object]", qgt = (n) => n == null ? "" : Rr(n) || en(n) && n.toString === nae ? JSON.stringify(n, null, 2) : String(n);
  function n3(n, e = "") {
    return n.reduce((t, r, i) => i === 0 ? t + r : t + e + r, "");
  }
  function jgt(n, e) {
    typeof console < "u" && (console.warn("[intlify] " + n), e && console.warn(e.stack));
  }
  const Bw = (n) => !wn(n) || Rr(n);
  function D_(n, e) {
    if (Bw(n) || Bw(e)) throw new Error("Invalid value");
    const t = [
      {
        src: n,
        des: e
      }
    ];
    for (; t.length; ) {
      const { src: r, des: i } = t.pop();
      Object.keys(r).forEach((a) => {
        a !== "__proto__" && (wn(r[a]) && !wn(i[a]) && (i[a] = Array.isArray(r[a]) ? [] : Bn()), Bw(i[a]) || Bw(r[a]) ? i[a] = r[a] : t.push({
          src: r[a],
          des: i[a]
        }));
      });
    }
  }
  function Kgt(n, e, t) {
    return {
      line: n,
      column: e,
      offset: t
    };
  }
  function cN(n, e, t) {
    return {
      start: n,
      end: e
    };
  }
  const Dn = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14
  }, Zgt = 17;
  function x2(n, e, t = {}) {
    const { domain: r, messages: i, args: a } = t, s = n, o = new SyntaxError(String(s));
    return o.code = n, e && (o.location = e), o.domain = r, o;
  }
  function Qgt(n) {
    throw n;
  }
  const wl = " ", Jgt = "\r", Vi = `
`, emt = "\u2028", tmt = "\u2029";
  function nmt(n) {
    const e = n;
    let t = 0, r = 1, i = 1, a = 0;
    const s = (S) => e[S] === Jgt && e[S + 1] === Vi, o = (S) => e[S] === Vi, l = (S) => e[S] === tmt, u = (S) => e[S] === emt, c = (S) => s(S) || o(S) || l(S) || u(S), h = () => t, d = () => r, f = () => i, p = () => a, g = (S) => s(S) || l(S) || u(S) ? Vi : e[S], m = () => g(t), v = () => g(t + a);
    function y() {
      return a = 0, c(t) && (r++, i = 0), s(t) && t++, t++, i++, e[t];
    }
    function x() {
      return s(t + a) && a++, a++, e[t + a];
    }
    function b() {
      t = 0, r = 1, i = 1, a = 0;
    }
    function w(S = 0) {
      a = S;
    }
    function _() {
      const S = t + a;
      for (; S !== t; ) y();
      a = 0;
    }
    return {
      index: h,
      line: d,
      column: f,
      peekOffset: p,
      charAt: g,
      currentChar: m,
      currentPeek: v,
      next: y,
      peek: x,
      reset: b,
      resetPeek: w,
      skipToPeek: _
    };
  }
  const Su = void 0, rmt = ".", b5 = "'", imt = "tokenizer";
  function amt(n, e = {}) {
    const t = e.location !== false, r = nmt(n), i = () => r.index(), a = () => Kgt(r.line(), r.column(), r.index()), s = a(), o = i(), l = {
      currentType: 13,
      offset: o,
      startLoc: s,
      endLoc: s,
      lastType: 13,
      lastOffset: o,
      lastStartLoc: s,
      lastEndLoc: s,
      braceNest: 0,
      inLinked: false,
      text: ""
    }, u = () => l, { onError: c } = e;
    function h(G, q, ge, ...Fe) {
      const Lt = u();
      if (q.column += ge, q.offset += ge, c) {
        const dt = t ? cN(Lt.startLoc, q) : null, ue = x2(G, dt, {
          domain: imt,
          args: Fe
        });
        c(ue);
      }
    }
    function d(G, q, ge) {
      G.endLoc = a(), G.currentType = q;
      const Fe = {
        type: q
      };
      return t && (Fe.loc = cN(G.startLoc, G.endLoc)), ge != null && (Fe.value = ge), Fe;
    }
    const f = (G) => d(G, 13);
    function p(G, q) {
      return G.currentChar() === q ? (G.next(), q) : (h(Dn.EXPECTED_TOKEN, a(), 0, q), "");
    }
    function g(G) {
      let q = "";
      for (; G.currentPeek() === wl || G.currentPeek() === Vi; ) q += G.currentPeek(), G.peek();
      return q;
    }
    function m(G) {
      const q = g(G);
      return G.skipToPeek(), q;
    }
    function v(G) {
      if (G === Su) return false;
      const q = G.charCodeAt(0);
      return q >= 97 && q <= 122 || q >= 65 && q <= 90 || q === 95;
    }
    function y(G) {
      if (G === Su) return false;
      const q = G.charCodeAt(0);
      return q >= 48 && q <= 57;
    }
    function x(G, q) {
      const { currentType: ge } = q;
      if (ge !== 2) return false;
      g(G);
      const Fe = v(G.currentPeek());
      return G.resetPeek(), Fe;
    }
    function b(G, q) {
      const { currentType: ge } = q;
      if (ge !== 2) return false;
      g(G);
      const Fe = G.currentPeek() === "-" ? G.peek() : G.currentPeek(), Lt = y(Fe);
      return G.resetPeek(), Lt;
    }
    function w(G, q) {
      const { currentType: ge } = q;
      if (ge !== 2) return false;
      g(G);
      const Fe = G.currentPeek() === b5;
      return G.resetPeek(), Fe;
    }
    function _(G, q) {
      const { currentType: ge } = q;
      if (ge !== 7) return false;
      g(G);
      const Fe = G.currentPeek() === ".";
      return G.resetPeek(), Fe;
    }
    function S(G, q) {
      const { currentType: ge } = q;
      if (ge !== 8) return false;
      g(G);
      const Fe = v(G.currentPeek());
      return G.resetPeek(), Fe;
    }
    function I(G, q) {
      const { currentType: ge } = q;
      if (!(ge === 7 || ge === 11)) return false;
      g(G);
      const Fe = G.currentPeek() === ":";
      return G.resetPeek(), Fe;
    }
    function C(G, q) {
      const { currentType: ge } = q;
      if (ge !== 9) return false;
      const Fe = () => {
        const dt = G.currentPeek();
        return dt === "{" ? v(G.peek()) : dt === "@" || dt === "|" || dt === ":" || dt === "." || dt === wl || !dt ? false : dt === Vi ? (G.peek(), Fe()) : k(G, false);
      }, Lt = Fe();
      return G.resetPeek(), Lt;
    }
    function T(G) {
      g(G);
      const q = G.currentPeek() === "|";
      return G.resetPeek(), q;
    }
    function k(G, q = true) {
      const ge = (Lt = false, dt = "") => {
        const ue = G.currentPeek();
        return ue === "{" || ue === "@" || !ue ? Lt : ue === "|" ? !(dt === wl || dt === Vi) : ue === wl ? (G.peek(), ge(true, wl)) : ue === Vi ? (G.peek(), ge(true, Vi)) : true;
      }, Fe = ge();
      return q && G.resetPeek(), Fe;
    }
    function D(G, q) {
      const ge = G.currentChar();
      return ge === Su ? Su : q(ge) ? (G.next(), ge) : null;
    }
    function R(G) {
      const q = G.charCodeAt(0);
      return q >= 97 && q <= 122 || q >= 65 && q <= 90 || q >= 48 && q <= 57 || q === 95 || q === 36;
    }
    function N(G) {
      return D(G, R);
    }
    function E(G) {
      const q = G.charCodeAt(0);
      return q >= 97 && q <= 122 || q >= 65 && q <= 90 || q >= 48 && q <= 57 || q === 95 || q === 36 || q === 45;
    }
    function A(G) {
      return D(G, E);
    }
    function M(G) {
      const q = G.charCodeAt(0);
      return q >= 48 && q <= 57;
    }
    function $(G) {
      return D(G, M);
    }
    function L(G) {
      const q = G.charCodeAt(0);
      return q >= 48 && q <= 57 || q >= 65 && q <= 70 || q >= 97 && q <= 102;
    }
    function F(G) {
      return D(G, L);
    }
    function O(G) {
      let q = "", ge = "";
      for (; q = $(G); ) ge += q;
      return ge;
    }
    function z(G) {
      let q = "";
      for (; ; ) {
        const ge = G.currentChar();
        if (ge === "{" || ge === "}" || ge === "@" || ge === "|" || !ge) break;
        if (ge === wl || ge === Vi) if (k(G)) q += ge, G.next();
        else {
          if (T(G)) break;
          q += ge, G.next();
        }
        else q += ge, G.next();
      }
      return q;
    }
    function V(G) {
      m(G);
      let q = "", ge = "";
      for (; q = A(G); ) ge += q;
      return G.currentChar() === Su && h(Dn.UNTERMINATED_CLOSING_BRACE, a(), 0), ge;
    }
    function H(G) {
      m(G);
      let q = "";
      return G.currentChar() === "-" ? (G.next(), q += `-${O(G)}`) : q += O(G), G.currentChar() === Su && h(Dn.UNTERMINATED_CLOSING_BRACE, a(), 0), q;
    }
    function Y(G) {
      return G !== b5 && G !== Vi;
    }
    function le(G) {
      m(G), p(G, "'");
      let q = "", ge = "";
      for (; q = D(G, Y); ) q === "\\" ? ge += ve(G) : ge += q;
      const Fe = G.currentChar();
      return Fe === Vi || Fe === Su ? (h(Dn.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, a(), 0), Fe === Vi && (G.next(), p(G, "'")), ge) : (p(G, "'"), ge);
    }
    function ve(G) {
      const q = G.currentChar();
      switch (q) {
        case "\\":
        case "'":
          return G.next(), `\\${q}`;
        case "u":
          return re(G, q, 4);
        case "U":
          return re(G, q, 6);
        default:
          return h(Dn.UNKNOWN_ESCAPE_SEQUENCE, a(), 0, q), "";
      }
    }
    function re(G, q, ge) {
      p(G, q);
      let Fe = "";
      for (let Lt = 0; Lt < ge; Lt++) {
        const dt = F(G);
        if (!dt) {
          h(Dn.INVALID_UNICODE_ESCAPE_SEQUENCE, a(), 0, `\\${q}${Fe}${G.currentChar()}`);
          break;
        }
        Fe += dt;
      }
      return `\\${q}${Fe}`;
    }
    function ae(G) {
      return G !== "{" && G !== "}" && G !== wl && G !== Vi;
    }
    function fe(G) {
      m(G);
      let q = "", ge = "";
      for (; q = D(G, ae); ) ge += q;
      return ge;
    }
    function ce(G) {
      let q = "", ge = "";
      for (; q = N(G); ) ge += q;
      return ge;
    }
    function ye(G) {
      const q = (ge) => {
        const Fe = G.currentChar();
        return Fe === "{" || Fe === "@" || Fe === "|" || Fe === "(" || Fe === ")" || !Fe || Fe === wl ? ge : (ge += Fe, G.next(), q(ge));
      };
      return q("");
    }
    function Le(G) {
      m(G);
      const q = p(G, "|");
      return m(G), q;
    }
    function Re(G, q) {
      let ge = null;
      switch (G.currentChar()) {
        case "{":
          return q.braceNest >= 1 && h(Dn.NOT_ALLOW_NEST_PLACEHOLDER, a(), 0), G.next(), ge = d(q, 2, "{"), m(G), q.braceNest++, ge;
        case "}":
          return q.braceNest > 0 && q.currentType === 2 && h(Dn.EMPTY_PLACEHOLDER, a(), 0), G.next(), ge = d(q, 3, "}"), q.braceNest--, q.braceNest > 0 && m(G), q.inLinked && q.braceNest === 0 && (q.inLinked = false), ge;
        case "@":
          return q.braceNest > 0 && h(Dn.UNTERMINATED_CLOSING_BRACE, a(), 0), ge = be(G, q) || f(q), q.braceNest = 0, ge;
        default: {
          let Lt = true, dt = true, ue = true;
          if (T(G)) return q.braceNest > 0 && h(Dn.UNTERMINATED_CLOSING_BRACE, a(), 0), ge = d(q, 1, Le(G)), q.braceNest = 0, q.inLinked = false, ge;
          if (q.braceNest > 0 && (q.currentType === 4 || q.currentType === 5 || q.currentType === 6)) return h(Dn.UNTERMINATED_CLOSING_BRACE, a(), 0), q.braceNest = 0, xe(G, q);
          if (Lt = x(G, q)) return ge = d(q, 4, V(G)), m(G), ge;
          if (dt = b(G, q)) return ge = d(q, 5, H(G)), m(G), ge;
          if (ue = w(G, q)) return ge = d(q, 6, le(G)), m(G), ge;
          if (!Lt && !dt && !ue) return ge = d(q, 12, fe(G)), h(Dn.INVALID_TOKEN_IN_PLACEHOLDER, a(), 0, ge.value), m(G), ge;
          break;
        }
      }
      return ge;
    }
    function be(G, q) {
      const { currentType: ge } = q;
      let Fe = null;
      const Lt = G.currentChar();
      switch ((ge === 7 || ge === 8 || ge === 11 || ge === 9) && (Lt === Vi || Lt === wl) && h(Dn.INVALID_LINKED_FORMAT, a(), 0), Lt) {
        case "@":
          return G.next(), Fe = d(q, 7, "@"), q.inLinked = true, Fe;
        case ".":
          return m(G), G.next(), d(q, 8, ".");
        case ":":
          return m(G), G.next(), d(q, 9, ":");
        default:
          return T(G) ? (Fe = d(q, 1, Le(G)), q.braceNest = 0, q.inLinked = false, Fe) : _(G, q) || I(G, q) ? (m(G), be(G, q)) : S(G, q) ? (m(G), d(q, 11, ce(G))) : C(G, q) ? (m(G), Lt === "{" ? Re(G, q) || Fe : d(q, 10, ye(G))) : (ge === 7 && h(Dn.INVALID_LINKED_FORMAT, a(), 0), q.braceNest = 0, q.inLinked = false, xe(G, q));
      }
    }
    function xe(G, q) {
      let ge = {
        type: 13
      };
      if (q.braceNest > 0) return Re(G, q) || f(q);
      if (q.inLinked) return be(G, q) || f(q);
      switch (G.currentChar()) {
        case "{":
          return Re(G, q) || f(q);
        case "}":
          return h(Dn.UNBALANCED_CLOSING_BRACE, a(), 0), G.next(), d(q, 3, "}");
        case "@":
          return be(G, q) || f(q);
        default: {
          if (T(G)) return ge = d(q, 1, Le(G)), q.braceNest = 0, q.inLinked = false, ge;
          if (k(G)) return d(q, 0, z(G));
          break;
        }
      }
      return ge;
    }
    function ot() {
      const { currentType: G, offset: q, startLoc: ge, endLoc: Fe } = l;
      return l.lastType = G, l.lastOffset = q, l.lastStartLoc = ge, l.lastEndLoc = Fe, l.offset = i(), l.startLoc = a(), r.currentChar() === Su ? d(l, 13) : xe(r, l);
    }
    return {
      nextToken: ot,
      currentOffset: i,
      currentPosition: a,
      context: u
    };
  }
  const smt = "parser", omt = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function lmt(n, e, t) {
    switch (n) {
      case "\\\\":
        return "\\";
      case "\\'":
        return "'";
      default: {
        const r = parseInt(e || t, 16);
        return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "\uFFFD";
      }
    }
  }
  function umt(n = {}) {
    const e = n.location !== false, { onError: t } = n;
    function r(v, y, x, b, ...w) {
      const _ = v.currentPosition();
      if (_.offset += b, _.column += b, t) {
        const S = e ? cN(x, _) : null, I = x2(y, S, {
          domain: smt,
          args: w
        });
        t(I);
      }
    }
    function i(v, y, x) {
      const b = {
        type: v
      };
      return e && (b.start = y, b.end = y, b.loc = {
        start: x,
        end: x
      }), b;
    }
    function a(v, y, x, b) {
      e && (v.end = y, v.loc && (v.loc.end = x));
    }
    function s(v, y) {
      const x = v.context(), b = i(3, x.offset, x.startLoc);
      return b.value = y, a(b, v.currentOffset(), v.currentPosition()), b;
    }
    function o(v, y) {
      const x = v.context(), { lastOffset: b, lastStartLoc: w } = x, _ = i(5, b, w);
      return _.index = parseInt(y, 10), v.nextToken(), a(_, v.currentOffset(), v.currentPosition()), _;
    }
    function l(v, y) {
      const x = v.context(), { lastOffset: b, lastStartLoc: w } = x, _ = i(4, b, w);
      return _.key = y, v.nextToken(), a(_, v.currentOffset(), v.currentPosition()), _;
    }
    function u(v, y) {
      const x = v.context(), { lastOffset: b, lastStartLoc: w } = x, _ = i(9, b, w);
      return _.value = y.replace(omt, lmt), v.nextToken(), a(_, v.currentOffset(), v.currentPosition()), _;
    }
    function c(v) {
      const y = v.nextToken(), x = v.context(), { lastOffset: b, lastStartLoc: w } = x, _ = i(8, b, w);
      return y.type !== 11 ? (r(v, Dn.UNEXPECTED_EMPTY_LINKED_MODIFIER, x.lastStartLoc, 0), _.value = "", a(_, b, w), {
        nextConsumeToken: y,
        node: _
      }) : (y.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, Co(y)), _.value = y.value || "", a(_, v.currentOffset(), v.currentPosition()), {
        node: _
      });
    }
    function h(v, y) {
      const x = v.context(), b = i(7, x.offset, x.startLoc);
      return b.value = y, a(b, v.currentOffset(), v.currentPosition()), b;
    }
    function d(v) {
      const y = v.context(), x = i(6, y.offset, y.startLoc);
      let b = v.nextToken();
      if (b.type === 8) {
        const w = c(v);
        x.modifier = w.node, b = w.nextConsumeToken || v.nextToken();
      }
      switch (b.type !== 9 && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(b)), b = v.nextToken(), b.type === 2 && (b = v.nextToken()), b.type) {
        case 10:
          b.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(b)), x.key = h(v, b.value || "");
          break;
        case 4:
          b.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(b)), x.key = l(v, b.value || "");
          break;
        case 5:
          b.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(b)), x.key = o(v, b.value || "");
          break;
        case 6:
          b.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(b)), x.key = u(v, b.value || "");
          break;
        default: {
          r(v, Dn.UNEXPECTED_EMPTY_LINKED_KEY, y.lastStartLoc, 0);
          const w = v.context(), _ = i(7, w.offset, w.startLoc);
          return _.value = "", a(_, w.offset, w.startLoc), x.key = _, a(x, w.offset, w.startLoc), {
            nextConsumeToken: b,
            node: x
          };
        }
      }
      return a(x, v.currentOffset(), v.currentPosition()), {
        node: x
      };
    }
    function f(v) {
      const y = v.context(), x = y.currentType === 1 ? v.currentOffset() : y.offset, b = y.currentType === 1 ? y.endLoc : y.startLoc, w = i(2, x, b);
      w.items = [];
      let _ = null;
      do {
        const C = _ || v.nextToken();
        switch (_ = null, C.type) {
          case 0:
            C.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(C)), w.items.push(s(v, C.value || ""));
            break;
          case 5:
            C.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(C)), w.items.push(o(v, C.value || ""));
            break;
          case 4:
            C.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(C)), w.items.push(l(v, C.value || ""));
            break;
          case 6:
            C.value == null && r(v, Dn.UNEXPECTED_LEXICAL_ANALYSIS, y.lastStartLoc, 0, Co(C)), w.items.push(u(v, C.value || ""));
            break;
          case 7: {
            const T = d(v);
            w.items.push(T.node), _ = T.nextConsumeToken || null;
            break;
          }
        }
      } while (y.currentType !== 13 && y.currentType !== 1);
      const S = y.currentType === 1 ? y.lastOffset : v.currentOffset(), I = y.currentType === 1 ? y.lastEndLoc : v.currentPosition();
      return a(w, S, I), w;
    }
    function p(v, y, x, b) {
      const w = v.context();
      let _ = b.items.length === 0;
      const S = i(1, y, x);
      S.cases = [], S.cases.push(b);
      do {
        const I = f(v);
        _ || (_ = I.items.length === 0), S.cases.push(I);
      } while (w.currentType !== 13);
      return _ && r(v, Dn.MUST_HAVE_MESSAGES_IN_PLURAL, x, 0), a(S, v.currentOffset(), v.currentPosition()), S;
    }
    function g(v) {
      const y = v.context(), { offset: x, startLoc: b } = y, w = f(v);
      return y.currentType === 13 ? w : p(v, x, b, w);
    }
    function m(v) {
      const y = amt(v, Ur({}, n)), x = y.context(), b = i(0, x.offset, x.startLoc);
      return e && b.loc && (b.loc.source = v), b.body = g(y), n.onCacheKey && (b.cacheKey = n.onCacheKey(v)), x.currentType !== 13 && r(y, Dn.UNEXPECTED_LEXICAL_ANALYSIS, x.lastStartLoc, 0, v[x.offset] || ""), a(b, y.currentOffset(), y.currentPosition()), b;
    }
    return {
      parse: m
    };
  }
  function Co(n) {
    if (n.type === 13) return "EOF";
    const e = (n.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "\u2026" : e;
  }
  function cmt(n, e = {}) {
    const t = {
      ast: n,
      helpers: /* @__PURE__ */ new Set()
    };
    return {
      context: () => t,
      helper: (a) => (t.helpers.add(a), a)
    };
  }
  function w5(n, e) {
    for (let t = 0; t < n.length; t++) r3(n[t], e);
  }
  function r3(n, e) {
    switch (n.type) {
      case 1:
        w5(n.cases, e), e.helper("plural");
        break;
      case 2:
        w5(n.items, e);
        break;
      case 6: {
        r3(n.key, e), e.helper("linked"), e.helper("type");
        break;
      }
      case 5:
        e.helper("interpolate"), e.helper("list");
        break;
      case 4:
        e.helper("interpolate"), e.helper("named");
        break;
    }
  }
  function hmt(n, e = {}) {
    const t = cmt(n);
    t.helper("normalize"), n.body && r3(n.body, t);
    const r = t.context();
    n.helpers = Array.from(r.helpers);
  }
  function dmt(n) {
    const e = n.body;
    return e.type === 2 ? _5(e) : e.cases.forEach((t) => _5(t)), n;
  }
  function _5(n) {
    if (n.items.length === 1) {
      const e = n.items[0];
      (e.type === 3 || e.type === 9) && (n.static = e.value, delete e.value);
    } else {
      const e = [];
      for (let t = 0; t < n.items.length; t++) {
        const r = n.items[t];
        if (!(r.type === 3 || r.type === 9) || r.value == null) break;
        e.push(r.value);
      }
      if (e.length === n.items.length) {
        n.static = n3(e);
        for (let t = 0; t < n.items.length; t++) {
          const r = n.items[t];
          (r.type === 3 || r.type === 9) && delete r.value;
        }
      }
    }
  }
  function pg(n) {
    switch (n.t = n.type, n.type) {
      case 0: {
        const e = n;
        pg(e.body), e.b = e.body, delete e.body;
        break;
      }
      case 1: {
        const e = n, t = e.cases;
        for (let r = 0; r < t.length; r++) pg(t[r]);
        e.c = t, delete e.cases;
        break;
      }
      case 2: {
        const e = n, t = e.items;
        for (let r = 0; r < t.length; r++) pg(t[r]);
        e.i = t, delete e.items, e.static && (e.s = e.static, delete e.static);
        break;
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const e = n;
        e.value && (e.v = e.value, delete e.value);
        break;
      }
      case 6: {
        const e = n;
        pg(e.key), e.k = e.key, delete e.key, e.modifier && (pg(e.modifier), e.m = e.modifier, delete e.modifier);
        break;
      }
      case 5: {
        const e = n;
        e.i = e.index, delete e.index;
        break;
      }
      case 4: {
        const e = n;
        e.k = e.key, delete e.key;
        break;
      }
    }
    delete n.type;
  }
  function fmt(n, e) {
    const { filename: t, breakLineCode: r, needIndent: i } = e, a = e.location !== false, s = {
      filename: t,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: r,
      needIndent: i,
      indentLevel: 0
    };
    a && n.loc && (s.source = n.loc.source);
    const o = () => s;
    function l(g, m) {
      s.code += g;
    }
    function u(g, m = true) {
      const v = m ? r : "";
      l(i ? v + "  ".repeat(g) : v);
    }
    function c(g = true) {
      const m = ++s.indentLevel;
      g && u(m);
    }
    function h(g = true) {
      const m = --s.indentLevel;
      g && u(m);
    }
    function d() {
      u(s.indentLevel);
    }
    return {
      context: o,
      push: l,
      indent: c,
      deindent: h,
      newline: d,
      helper: (g) => `_${g}`,
      needIndent: () => s.needIndent
    };
  }
  function pmt(n, e) {
    const { helper: t } = n;
    n.push(`${t("linked")}(`), lm(n, e.key), e.modifier ? (n.push(", "), lm(n, e.modifier), n.push(", _type")) : n.push(", undefined, _type"), n.push(")");
  }
  function gmt(n, e) {
    const { helper: t, needIndent: r } = n;
    n.push(`${t("normalize")}([`), n.indent(r());
    const i = e.items.length;
    for (let a = 0; a < i && (lm(n, e.items[a]), a !== i - 1); a++) n.push(", ");
    n.deindent(r()), n.push("])");
  }
  function mmt(n, e) {
    const { helper: t, needIndent: r } = n;
    if (e.cases.length > 1) {
      n.push(`${t("plural")}([`), n.indent(r());
      const i = e.cases.length;
      for (let a = 0; a < i && (lm(n, e.cases[a]), a !== i - 1); a++) n.push(", ");
      n.deindent(r()), n.push("])");
    }
  }
  function vmt(n, e) {
    e.body ? lm(n, e.body) : n.push("null");
  }
  function lm(n, e) {
    const { helper: t } = n;
    switch (e.type) {
      case 0:
        vmt(n, e);
        break;
      case 1:
        mmt(n, e);
        break;
      case 2:
        gmt(n, e);
        break;
      case 6:
        pmt(n, e);
        break;
      case 8:
        n.push(JSON.stringify(e.value), e);
        break;
      case 7:
        n.push(JSON.stringify(e.value), e);
        break;
      case 5:
        n.push(`${t("interpolate")}(${t("list")}(${e.index}))`, e);
        break;
      case 4:
        n.push(`${t("interpolate")}(${t("named")}(${JSON.stringify(e.key)}))`, e);
        break;
      case 9:
        n.push(JSON.stringify(e.value), e);
        break;
      case 3:
        n.push(JSON.stringify(e.value), e);
        break;
    }
  }
  const ymt = (n, e = {}) => {
    const t = Ke(e.mode) ? e.mode : "normal", r = Ke(e.filename) ? e.filename : "message.intl";
    e.sourceMap;
    const i = e.breakLineCode != null ? e.breakLineCode : t === "arrow" ? ";" : `
`, a = e.needIndent ? e.needIndent : t !== "arrow", s = n.helpers || [], o = fmt(n, {
      filename: r,
      breakLineCode: i,
      needIndent: a
    });
    o.push(t === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), o.indent(a), s.length > 0 && (o.push(`const { ${n3(s.map((c) => `${c}: _${c}`), ", ")} } = ctx`), o.newline()), o.push("return "), lm(o, n), o.deindent(a), o.push("}"), delete n.helpers;
    const { code: l, map: u } = o.context();
    return {
      ast: n,
      code: l,
      map: u ? u.toJSON() : void 0
    };
  };
  function xmt(n, e = {}) {
    const t = Ur({}, e), r = !!t.jit, i = !!t.minify, a = t.optimize == null ? true : t.optimize, o = umt(t).parse(n);
    return r ? (a && dmt(o), i && pg(o), {
      ast: o,
      code: ""
    }) : (hmt(o, t), ymt(o, t));
  }
  function bmt() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Yh().__INTLIFY_PROD_DEVTOOLS__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Yh().__INTLIFY_DROP_MESSAGE_COMPILER__ = false);
  }
  function JA(n) {
    return (t) => wmt(t, n);
  }
  function wmt(n, e) {
    const t = Smt(e);
    if (t == null) throw Cx(0);
    if (i3(t) === 1) {
      const a = Imt(t);
      return n.plural(a.reduce((s, o) => [
        ...s,
        S5(n, o)
      ], []));
    } else return S5(n, t);
  }
  const _mt = [
    "b",
    "body"
  ];
  function Smt(n) {
    return Mc(n, _mt);
  }
  const Cmt = [
    "c",
    "cases"
  ];
  function Imt(n) {
    return Mc(n, Cmt, []);
  }
  function S5(n, e) {
    const t = Tmt(e);
    if (t != null) return n.type === "text" ? t : n.normalize([
      t
    ]);
    {
      const r = Dmt(e).reduce((i, a) => [
        ...i,
        hN(n, a)
      ], []);
      return n.normalize(r);
    }
  }
  const kmt = [
    "s",
    "static"
  ];
  function Tmt(n) {
    return Mc(n, kmt);
  }
  const Amt = [
    "i",
    "items"
  ];
  function Dmt(n) {
    return Mc(n, Amt, []);
  }
  function hN(n, e) {
    const t = i3(e);
    switch (t) {
      case 3:
        return zw(e, t);
      case 9:
        return zw(e, t);
      case 4: {
        const r = e;
        if (qs(r, "k") && r.k) return n.interpolate(n.named(r.k));
        if (qs(r, "key") && r.key) return n.interpolate(n.named(r.key));
        throw Cx(t);
      }
      case 5: {
        const r = e;
        if (qs(r, "i") && Ir(r.i)) return n.interpolate(n.list(r.i));
        if (qs(r, "index") && Ir(r.index)) return n.interpolate(n.list(r.index));
        throw Cx(t);
      }
      case 6: {
        const r = e, i = Emt(r), a = Pmt(r);
        return n.linked(hN(n, a), i ? hN(n, i) : void 0, n.type);
      }
      case 7:
        return zw(e, t);
      case 8:
        return zw(e, t);
      default:
        throw new Error(`unhandled node on format message part: ${t}`);
    }
  }
  const Rmt = [
    "t",
    "type"
  ];
  function i3(n) {
    return Mc(n, Rmt);
  }
  const $mt = [
    "v",
    "value"
  ];
  function zw(n, e) {
    const t = Mc(n, $mt);
    if (t) return t;
    throw Cx(e);
  }
  const Nmt = [
    "m",
    "modifier"
  ];
  function Emt(n) {
    return Mc(n, Nmt);
  }
  const Mmt = [
    "k",
    "key"
  ];
  function Pmt(n) {
    const e = Mc(n, Mmt);
    if (e) return e;
    throw Cx(6);
  }
  function Mc(n, e, t) {
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      if (qs(n, i) && n[i] != null) return n[i];
    }
    return t;
  }
  function Cx(n) {
    return new Error(`unhandled node type: ${n}`);
  }
  const Lmt = (n) => n;
  let Vw = Bn();
  function um(n) {
    return wn(n) && i3(n) === 0 && (qs(n, "b") || qs(n, "body"));
  }
  function Fmt(n, e = {}) {
    let t = false;
    const r = e.onError || Qgt;
    return e.onError = (i) => {
      t = true, r(i);
    }, {
      ...xmt(n, e),
      detectError: t
    };
  }
  function Omt(n, e) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && Ke(n)) {
      vn(e.warnHtmlMessage) && e.warnHtmlMessage;
      const r = (e.onCacheKey || Lmt)(n), i = Vw[r];
      if (i) return i;
      const { ast: a, detectError: s } = Fmt(n, {
        ...e,
        location: false,
        jit: true
      }), o = JA(a);
      return s ? o : Vw[r] = o;
    } else {
      const t = n.cacheKey;
      if (t) {
        const r = Vw[t];
        return r || (Vw[t] = JA(n));
      } else return JA(n);
    }
  }
  let Ix = null;
  function Bmt(n) {
    Ix = n;
  }
  function zmt(n, e, t) {
    Ix && Ix.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: n,
      version: e,
      meta: t
    });
  }
  const Vmt = Wmt("function:translate");
  function Wmt(n) {
    return (e) => Ix && Ix.emit(n, e);
  }
  const Rl = {
    INVALID_ARGUMENT: Zgt,
    INVALID_DATE_ARGUMENT: 18,
    INVALID_ISO_DATE_ARGUMENT: 19,
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
    NOT_SUPPORT_LOCALE_TYPE: 23
  }, Gmt = 24;
  function $l(n) {
    return x2(n, null, void 0);
  }
  function a3(n, e) {
    return e.locale != null ? C5(e.locale) : C5(n.locale);
  }
  let eD;
  function C5(n) {
    if (Ke(n)) return n;
    if (jn(n)) {
      if (n.resolvedOnce && eD != null) return eD;
      if (n.constructor.name === "Function") {
        const e = n();
        if (Ygt(e)) throw $l(Rl.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        return eD = e;
      } else throw $l(Rl.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
    } else throw $l(Rl.NOT_SUPPORT_LOCALE_TYPE);
  }
  function Umt(n, e, t) {
    return [
      .../* @__PURE__ */ new Set([
        t,
        ...Rr(e) ? e : wn(e) ? Object.keys(e) : Ke(e) ? [
          e
        ] : [
          t
        ]
      ])
    ];
  }
  function rae(n, e, t) {
    const r = Ke(t) ? t : kx, i = n;
    i.__localeChainCache || (i.__localeChainCache = /* @__PURE__ */ new Map());
    let a = i.__localeChainCache.get(r);
    if (!a) {
      a = [];
      let s = [
        t
      ];
      for (; Rr(s); ) s = I5(a, s, e);
      const o = Rr(e) || !en(e) ? e : e.default ? e.default : null;
      s = Ke(o) ? [
        o
      ] : o, Rr(s) && I5(a, s, false), i.__localeChainCache.set(r, a);
    }
    return a;
  }
  function I5(n, e, t) {
    let r = true;
    for (let i = 0; i < e.length && vn(r); i++) {
      const a = e[i];
      Ke(a) && (r = Hmt(n, e[i], t));
    }
    return r;
  }
  function Hmt(n, e, t) {
    let r;
    const i = e.split("-");
    do {
      const a = i.join("-");
      r = Xmt(n, a, t), i.splice(-1, 1);
    } while (i.length && r === true);
    return r;
  }
  function Xmt(n, e, t) {
    let r = false;
    if (!n.includes(e) && (r = true, e)) {
      r = e[e.length - 1] !== "!";
      const i = e.replace(/!/g, "");
      n.push(i), (Rr(t) || en(t)) && t[i] && (r = t[i]);
    }
    return r;
  }
  const Pc = [];
  Pc[0] = {
    w: [
      0
    ],
    i: [
      3,
      0
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  Pc[1] = {
    w: [
      1
    ],
    ".": [
      2
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  Pc[2] = {
    w: [
      2
    ],
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ]
  };
  Pc[3] = {
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ],
    w: [
      1,
      1
    ],
    ".": [
      2,
      1
    ],
    "[": [
      4,
      1
    ],
    o: [
      7,
      1
    ]
  };
  Pc[4] = {
    "'": [
      5,
      0
    ],
    '"': [
      6,
      0
    ],
    "[": [
      4,
      2
    ],
    "]": [
      1,
      3
    ],
    o: 8,
    l: [
      4,
      0
    ]
  };
  Pc[5] = {
    "'": [
      4,
      0
    ],
    o: 8,
    l: [
      5,
      0
    ]
  };
  Pc[6] = {
    '"': [
      4,
      0
    ],
    o: 8,
    l: [
      6,
      0
    ]
  };
  const Ymt = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function qmt(n) {
    return Ymt.test(n);
  }
  function jmt(n) {
    const e = n.charCodeAt(0), t = n.charCodeAt(n.length - 1);
    return e === t && (e === 34 || e === 39) ? n.slice(1, -1) : n;
  }
  function Kmt(n) {
    if (n == null) return "o";
    switch (n.charCodeAt(0)) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return n;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function Zmt(n) {
    const e = n.trim();
    return n.charAt(0) === "0" && isNaN(parseInt(n)) ? false : qmt(e) ? jmt(e) : "*" + e;
  }
  function Qmt(n) {
    const e = [];
    let t = -1, r = 0, i = 0, a, s, o, l, u, c, h;
    const d = [];
    d[0] = () => {
      s === void 0 ? s = o : s += o;
    }, d[1] = () => {
      s !== void 0 && (e.push(s), s = void 0);
    }, d[2] = () => {
      d[0](), i++;
    }, d[3] = () => {
      if (i > 0) i--, r = 4, d[0]();
      else {
        if (i = 0, s === void 0 || (s = Zmt(s), s === false)) return false;
        d[1]();
      }
    };
    function f() {
      const p = n[t + 1];
      if (r === 5 && p === "'" || r === 6 && p === '"') return t++, o = "\\" + p, d[0](), true;
    }
    for (; r !== null; ) if (t++, a = n[t], !(a === "\\" && f())) {
      if (l = Kmt(a), h = Pc[r], u = h[l] || h.l || 8, u === 8 || (r = u[0], u[1] !== void 0 && (c = d[u[1]], c && (o = a, c() === false)))) return;
      if (r === 7) return e;
    }
  }
  const k5 = /* @__PURE__ */ new Map();
  function Jmt(n, e) {
    return wn(n) ? n[e] : null;
  }
  function evt(n, e) {
    if (!wn(n)) return null;
    let t = k5.get(e);
    if (t || (t = Qmt(e), t && k5.set(e, t)), !t) return null;
    const r = t.length;
    let i = n, a = 0;
    for (; a < r; ) {
      const s = i[t[a]];
      if (s === void 0 || jn(i)) return null;
      i = s, a++;
    }
    return i;
  }
  const tvt = "11.1.1", b2 = -1, kx = "en-US", T5 = "", A5 = (n) => `${n.charAt(0).toLocaleUpperCase()}${n.substr(1)}`;
  function nvt() {
    return {
      upper: (n, e) => e === "text" && Ke(n) ? n.toUpperCase() : e === "vnode" && wn(n) && "__v_isVNode" in n ? n.children.toUpperCase() : n,
      lower: (n, e) => e === "text" && Ke(n) ? n.toLowerCase() : e === "vnode" && wn(n) && "__v_isVNode" in n ? n.children.toLowerCase() : n,
      capitalize: (n, e) => e === "text" && Ke(n) ? A5(n) : e === "vnode" && wn(n) && "__v_isVNode" in n ? A5(n.children) : n
    };
  }
  let iae;
  function rvt(n) {
    iae = n;
  }
  let aae;
  function ivt(n) {
    aae = n;
  }
  let sae;
  function avt(n) {
    sae = n;
  }
  let oae = null;
  const svt = (n) => {
    oae = n;
  }, ovt = () => oae;
  let lae = null;
  const D5 = (n) => {
    lae = n;
  }, lvt = () => lae;
  let R5 = 0;
  function uvt(n = {}) {
    const e = jn(n.onWarn) ? n.onWarn : jgt, t = Ke(n.version) ? n.version : tvt, r = Ke(n.locale) || jn(n.locale) ? n.locale : kx, i = jn(r) ? kx : r, a = Rr(n.fallbackLocale) || en(n.fallbackLocale) || Ke(n.fallbackLocale) || n.fallbackLocale === false ? n.fallbackLocale : i, s = en(n.messages) ? n.messages : tD(i), o = en(n.datetimeFormats) ? n.datetimeFormats : tD(i), l = en(n.numberFormats) ? n.numberFormats : tD(i), u = Ur(Bn(), n.modifiers, nvt()), c = n.pluralRules || Bn(), h = jn(n.missing) ? n.missing : null, d = vn(n.missingWarn) || om(n.missingWarn) ? n.missingWarn : true, f = vn(n.fallbackWarn) || om(n.fallbackWarn) ? n.fallbackWarn : true, p = !!n.fallbackFormat, g = !!n.unresolving, m = jn(n.postTranslation) ? n.postTranslation : null, v = en(n.processor) ? n.processor : null, y = vn(n.warnHtmlMessage) ? n.warnHtmlMessage : true, x = !!n.escapeParameter, b = jn(n.messageCompiler) ? n.messageCompiler : iae, w = jn(n.messageResolver) ? n.messageResolver : aae || Jmt, _ = jn(n.localeFallbacker) ? n.localeFallbacker : sae || Umt, S = wn(n.fallbackContext) ? n.fallbackContext : void 0, I = n, C = wn(I.__datetimeFormatters) ? I.__datetimeFormatters : /* @__PURE__ */ new Map(), T = wn(I.__numberFormatters) ? I.__numberFormatters : /* @__PURE__ */ new Map(), k = wn(I.__meta) ? I.__meta : {};
    R5++;
    const D = {
      version: t,
      cid: R5,
      locale: r,
      fallbackLocale: a,
      messages: s,
      modifiers: u,
      pluralRules: c,
      missing: h,
      missingWarn: d,
      fallbackWarn: f,
      fallbackFormat: p,
      unresolving: g,
      postTranslation: m,
      processor: v,
      warnHtmlMessage: y,
      escapeParameter: x,
      messageCompiler: b,
      messageResolver: w,
      localeFallbacker: _,
      fallbackContext: S,
      onWarn: e,
      __meta: k
    };
    return D.datetimeFormats = o, D.numberFormats = l, D.__datetimeFormatters = C, D.__numberFormatters = T, __INTLIFY_PROD_DEVTOOLS__ && zmt(D, t, k), D;
  }
  const tD = (n) => ({
    [n]: Bn()
  });
  function s3(n, e, t, r, i) {
    const { missing: a, onWarn: s } = n;
    if (a !== null) {
      const o = a(n, t, e, i);
      return Ke(o) ? o : e;
    } else return e;
  }
  function Ty(n, e, t) {
    const r = n;
    r.__localeChainCache = /* @__PURE__ */ new Map(), n.localeFallbacker(n, t, e);
  }
  function cvt(n, e) {
    return n === e ? false : n.split("-")[0] === e.split("-")[0];
  }
  function hvt(n, e) {
    const t = e.indexOf(n);
    if (t === -1) return false;
    for (let r = t + 1; r < e.length; r++) if (cvt(n, e[r])) return true;
    return false;
  }
  function $5(n, ...e) {
    const { datetimeFormats: t, unresolving: r, fallbackLocale: i, onWarn: a, localeFallbacker: s } = n, { __datetimeFormatters: o } = n, [l, u, c, h] = dN(...e), d = vn(c.missingWarn) ? c.missingWarn : n.missingWarn;
    vn(c.fallbackWarn) ? c.fallbackWarn : n.fallbackWarn;
    const f = !!c.part, p = a3(n, c), g = s(n, i, p);
    if (!Ke(l) || l === "") return new Intl.DateTimeFormat(p, h).format(u);
    let m = {}, v, y = null;
    const x = "datetime format";
    for (let _ = 0; _ < g.length && (v = g[_], m = t[v] || {}, y = m[l], !en(y)); _++) s3(n, l, v, d, x);
    if (!en(y) || !Ke(v)) return r ? b2 : l;
    let b = `${v}__${l}`;
    y2(h) || (b = `${b}__${JSON.stringify(h)}`);
    let w = o.get(b);
    return w || (w = new Intl.DateTimeFormat(v, Ur({}, y, h)), o.set(b, w)), f ? w.formatToParts(u) : w.format(u);
  }
  const uae = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function dN(...n) {
    const [e, t, r, i] = n, a = Bn();
    let s = Bn(), o;
    if (Ke(e)) {
      const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!l) throw $l(Rl.INVALID_ISO_DATE_ARGUMENT);
      const u = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
      o = new Date(u);
      try {
        o.toISOString();
      } catch {
        throw $l(Rl.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (Ugt(e)) {
      if (isNaN(e.getTime())) throw $l(Rl.INVALID_DATE_ARGUMENT);
      o = e;
    } else if (Ir(e)) o = e;
    else throw $l(Rl.INVALID_ARGUMENT);
    return Ke(t) ? a.key = t : en(t) && Object.keys(t).forEach((l) => {
      uae.includes(l) ? s[l] = t[l] : a[l] = t[l];
    }), Ke(r) ? a.locale = r : en(r) && (s = r), en(i) && (s = i), [
      a.key || "",
      o,
      a,
      s
    ];
  }
  function N5(n, e, t) {
    const r = n;
    for (const i in t) {
      const a = `${e}__${i}`;
      r.__datetimeFormatters.has(a) && r.__datetimeFormatters.delete(a);
    }
  }
  function E5(n, ...e) {
    const { numberFormats: t, unresolving: r, fallbackLocale: i, onWarn: a, localeFallbacker: s } = n, { __numberFormatters: o } = n, [l, u, c, h] = fN(...e), d = vn(c.missingWarn) ? c.missingWarn : n.missingWarn;
    vn(c.fallbackWarn) ? c.fallbackWarn : n.fallbackWarn;
    const f = !!c.part, p = a3(n, c), g = s(n, i, p);
    if (!Ke(l) || l === "") return new Intl.NumberFormat(p, h).format(u);
    let m = {}, v, y = null;
    const x = "number format";
    for (let _ = 0; _ < g.length && (v = g[_], m = t[v] || {}, y = m[l], !en(y)); _++) s3(n, l, v, d, x);
    if (!en(y) || !Ke(v)) return r ? b2 : l;
    let b = `${v}__${l}`;
    y2(h) || (b = `${b}__${JSON.stringify(h)}`);
    let w = o.get(b);
    return w || (w = new Intl.NumberFormat(v, Ur({}, y, h)), o.set(b, w)), f ? w.formatToParts(u) : w.format(u);
  }
  const cae = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function fN(...n) {
    const [e, t, r, i] = n, a = Bn();
    let s = Bn();
    if (!Ir(e)) throw $l(Rl.INVALID_ARGUMENT);
    const o = e;
    return Ke(t) ? a.key = t : en(t) && Object.keys(t).forEach((l) => {
      cae.includes(l) ? s[l] = t[l] : a[l] = t[l];
    }), Ke(r) ? a.locale = r : en(r) && (s = r), en(i) && (s = i), [
      a.key || "",
      o,
      a,
      s
    ];
  }
  function M5(n, e, t) {
    const r = n;
    for (const i in t) {
      const a = `${e}__${i}`;
      r.__numberFormatters.has(a) && r.__numberFormatters.delete(a);
    }
  }
  const dvt = (n) => n, fvt = (n) => "", pvt = "text", gvt = (n) => n.length === 0 ? "" : n3(n), mvt = qgt;
  function P5(n, e) {
    return n = Math.abs(n), e === 2 ? n ? n > 1 ? 1 : 0 : 1 : n ? Math.min(n, 2) : 0;
  }
  function vvt(n) {
    const e = Ir(n.pluralIndex) ? n.pluralIndex : -1;
    return n.named && (Ir(n.named.count) || Ir(n.named.n)) ? Ir(n.named.count) ? n.named.count : Ir(n.named.n) ? n.named.n : e : e;
  }
  function yvt(n, e) {
    e.count || (e.count = n), e.n || (e.n = n);
  }
  function xvt(n = {}) {
    const e = n.locale, t = vvt(n), r = wn(n.pluralRules) && Ke(e) && jn(n.pluralRules[e]) ? n.pluralRules[e] : P5, i = wn(n.pluralRules) && Ke(e) && jn(n.pluralRules[e]) ? P5 : void 0, a = (v) => v[r(t, v.length, i)], s = n.list || [], o = (v) => s[v], l = n.named || Bn();
    Ir(n.pluralIndex) && yvt(t, l);
    const u = (v) => l[v];
    function c(v, y) {
      const x = jn(n.messages) ? n.messages(v, !!y) : wn(n.messages) ? n.messages[v] : false;
      return x || (n.parent ? n.parent.message(v) : fvt);
    }
    const h = (v) => n.modifiers ? n.modifiers[v] : dvt, d = en(n.processor) && jn(n.processor.normalize) ? n.processor.normalize : gvt, f = en(n.processor) && jn(n.processor.interpolate) ? n.processor.interpolate : mvt, p = en(n.processor) && Ke(n.processor.type) ? n.processor.type : pvt, m = {
      list: o,
      named: u,
      plural: a,
      linked: (v, ...y) => {
        const [x, b] = y;
        let w = "text", _ = "";
        y.length === 1 ? wn(x) ? (_ = x.modifier || _, w = x.type || w) : Ke(x) && (_ = x || _) : y.length === 2 && (Ke(x) && (_ = x || _), Ke(b) && (w = b || w));
        const S = c(v, true)(m), I = w === "vnode" && Rr(S) && _ ? S[0] : S;
        return _ ? h(_)(I, w) : I;
      },
      message: c,
      type: p,
      interpolate: f,
      normalize: d,
      values: Ur(Bn(), s, l)
    };
    return m;
  }
  const L5 = () => "", fs = (n) => jn(n);
  function F5(n, ...e) {
    const { fallbackFormat: t, postTranslation: r, unresolving: i, messageCompiler: a, fallbackLocale: s, messages: o } = n, [l, u] = pN(...e), c = vn(u.missingWarn) ? u.missingWarn : n.missingWarn, h = vn(u.fallbackWarn) ? u.fallbackWarn : n.fallbackWarn, d = vn(u.escapeParameter) ? u.escapeParameter : n.escapeParameter, f = !!u.resolvedMessage, p = Ke(u.default) || vn(u.default) ? vn(u.default) ? a ? l : () => l : u.default : t ? a ? l : () => l : null, g = t || p != null && (Ke(p) || jn(p)), m = a3(n, u);
    d && bvt(u);
    let [v, y, x] = f ? [
      l,
      m,
      o[m] || Bn()
    ] : hae(n, l, m, s, h, c), b = v, w = l;
    if (!f && !(Ke(b) || um(b) || fs(b)) && g && (b = p, w = b), !f && (!(Ke(b) || um(b) || fs(b)) || !Ke(y))) return i ? b2 : l;
    let _ = false;
    const S = () => {
      _ = true;
    }, I = fs(b) ? b : dae(n, l, y, b, w, S);
    if (_) return b;
    const C = Svt(n, y, x, u), T = xvt(C), k = wvt(n, I, T), D = r ? r(k, l) : k;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const R = {
        timestamp: Date.now(),
        key: Ke(l) ? l : fs(b) ? b.key : "",
        locale: y || (fs(b) ? b.locale : ""),
        format: Ke(b) ? b : fs(b) ? b.source : "",
        message: D
      };
      R.meta = Ur({}, n.__meta, ovt() || {}), Vmt(R);
    }
    return D;
  }
  function bvt(n) {
    Rr(n.list) ? n.list = n.list.map((e) => Ke(e) ? x5(e) : e) : wn(n.named) && Object.keys(n.named).forEach((e) => {
      Ke(n.named[e]) && (n.named[e] = x5(n.named[e]));
    });
  }
  function hae(n, e, t, r, i, a) {
    const { messages: s, onWarn: o, messageResolver: l, localeFallbacker: u } = n, c = u(n, r, t);
    let h = Bn(), d, f = null;
    const p = "translate";
    for (let g = 0; g < c.length && (d = c[g], h = s[d] || Bn(), (f = l(h, e)) === null && (f = h[e]), !(Ke(f) || um(f) || fs(f))); g++) if (!hvt(d, c)) {
      const m = s3(n, e, d, a, p);
      m !== e && (f = m);
    }
    return [
      f,
      d,
      h
    ];
  }
  function dae(n, e, t, r, i, a) {
    const { messageCompiler: s, warnHtmlMessage: o } = n;
    if (fs(r)) {
      const u = r;
      return u.locale = u.locale || t, u.key = u.key || e, u;
    }
    if (s == null) {
      const u = () => r;
      return u.locale = t, u.key = e, u;
    }
    const l = s(r, _vt(n, t, i, r, o, a));
    return l.locale = t, l.key = e, l.source = r, l;
  }
  function wvt(n, e, t) {
    return e(t);
  }
  function pN(...n) {
    const [e, t, r] = n, i = Bn();
    if (!Ke(e) && !Ir(e) && !fs(e) && !um(e)) throw $l(Rl.INVALID_ARGUMENT);
    const a = Ir(e) ? String(e) : (fs(e), e);
    return Ir(t) ? i.plural = t : Ke(t) ? i.default = t : en(t) && !y2(t) ? i.named = t : Rr(t) && (i.list = t), Ir(r) ? i.plural = r : Ke(r) ? i.default = r : en(r) && Ur(i, r), [
      a,
      i
    ];
  }
  function _vt(n, e, t, r, i, a) {
    return {
      locale: e,
      key: t,
      warnHtmlMessage: i,
      onError: (s) => {
        throw a && a(s), s;
      },
      onCacheKey: (s) => Wgt(e, t, s)
    };
  }
  function Svt(n, e, t, r) {
    const { modifiers: i, pluralRules: a, messageResolver: s, fallbackLocale: o, fallbackWarn: l, missingWarn: u, fallbackContext: c } = n, d = {
      locale: e,
      modifiers: i,
      pluralRules: a,
      messages: (f, p) => {
        let g = s(t, f);
        if (g == null && (c || p)) {
          const [, , m] = hae(c || n, f, e, o, l, u);
          g = s(m, f);
        }
        if (Ke(g) || um(g)) {
          let m = false;
          const y = dae(n, f, e, g, f, () => {
            m = true;
          });
          return m ? L5 : y;
        } else return fs(g) ? g : L5;
      }
    };
    return n.processor && (d.processor = n.processor), r.list && (d.list = r.list), r.named && (d.named = r.named), Ir(r.plural) && (d.pluralIndex = r.plural), d;
  }
  bmt();
  const Cvt = "11.1.1";
  function Ivt() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Yh().__VUE_I18N_FULL_INSTALL__ = true), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Yh().__VUE_I18N_LEGACY_API__ = true), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Yh().__INTLIFY_DROP_MESSAGE_COMPILER__ = false), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Yh().__INTLIFY_PROD_DEVTOOLS__ = false);
  }
  const Da = {
    UNEXPECTED_RETURN_TYPE: Gmt,
    INVALID_ARGUMENT: 25,
    MUST_BE_CALL_SETUP_TOP: 26,
    NOT_INSTALLED: 27,
    REQUIRED_VALUE: 28,
    INVALID_VALUE: 29,
    NOT_INSTALLED_WITH_PROVIDE: 31,
    UNEXPECTED_ERROR: 32
  };
  function Ya(n, ...e) {
    return x2(n, null, void 0);
  }
  const gN = Ec("__translateVNode"), mN = Ec("__datetimeParts"), vN = Ec("__numberParts"), fae = Ec("__setPluralRules"), pae = Ec("__injectWithOption"), yN = Ec("__dispose");
  function Tx(n) {
    if (!wn(n)) return n;
    for (const e in n) if (qs(n, e)) if (!e.includes(".")) wn(n[e]) && Tx(n[e]);
    else {
      const t = e.split("."), r = t.length - 1;
      let i = n, a = false;
      for (let s = 0; s < r; s++) {
        if (t[s] in i || (i[t[s]] = Bn()), !wn(i[t[s]])) {
          a = true;
          break;
        }
        i = i[t[s]];
      }
      a || (i[t[r]] = n[e], delete n[e]), wn(i[t[r]]) && Tx(i[t[r]]);
    }
    return n;
  }
  function o3(n, e) {
    const { messages: t, __i18n: r, messageResolver: i, flatJson: a } = e, s = en(t) ? t : Rr(r) ? Bn() : {
      [n]: Bn()
    };
    if (Rr(r) && r.forEach((o) => {
      if ("locale" in o && "resource" in o) {
        const { locale: l, resource: u } = o;
        l ? (s[l] = s[l] || Bn(), D_(u, s[l])) : D_(u, s);
      } else Ke(o) && D_(JSON.parse(o), s);
    }), i == null && a) for (const o in s) qs(s, o) && Tx(s[o]);
    return s;
  }
  function gae(n) {
    return n.type;
  }
  function mae(n, e, t) {
    let r = wn(e.messages) ? e.messages : Bn();
    "__i18nGlobal" in t && (r = o3(n.locale.value, {
      messages: r,
      __i18n: t.__i18nGlobal
    }));
    const i = Object.keys(r);
    i.length && i.forEach((a) => {
      n.mergeLocaleMessage(a, r[a]);
    });
    {
      if (wn(e.datetimeFormats)) {
        const a = Object.keys(e.datetimeFormats);
        a.length && a.forEach((s) => {
          n.mergeDateTimeFormat(s, e.datetimeFormats[s]);
        });
      }
      if (wn(e.numberFormats)) {
        const a = Object.keys(e.numberFormats);
        a.length && a.forEach((s) => {
          n.mergeNumberFormat(s, e.numberFormats[s]);
        });
      }
    }
  }
  function O5(n) {
    return kt(fse, null, n, 0);
  }
  const B5 = "__INTLIFY_META__", z5 = () => [], kvt = () => false;
  let V5 = 0;
  function W5(n) {
    return (e, t, r, i) => n(t, r, Ha() || void 0, i);
  }
  const Tvt = () => {
    const n = Ha();
    let e = null;
    return n && (e = gae(n)[B5]) ? {
      [B5]: e
    } : null;
  };
  function l3(n = {}) {
    const { __root: e, __injectWithOption: t } = n, r = e === void 0, i = n.flatJson, a = sC ? Tt : dse;
    let s = vn(n.inheritLocale) ? n.inheritLocale : true;
    const o = a(e && s ? e.locale.value : Ke(n.locale) ? n.locale : kx), l = a(e && s ? e.fallbackLocale.value : Ke(n.fallbackLocale) || Rr(n.fallbackLocale) || en(n.fallbackLocale) || n.fallbackLocale === false ? n.fallbackLocale : o.value), u = a(o3(o.value, n)), c = a(en(n.datetimeFormats) ? n.datetimeFormats : {
      [o.value]: {}
    }), h = a(en(n.numberFormats) ? n.numberFormats : {
      [o.value]: {}
    });
    let d = e ? e.missingWarn : vn(n.missingWarn) || om(n.missingWarn) ? n.missingWarn : true, f = e ? e.fallbackWarn : vn(n.fallbackWarn) || om(n.fallbackWarn) ? n.fallbackWarn : true, p = e ? e.fallbackRoot : vn(n.fallbackRoot) ? n.fallbackRoot : true, g = !!n.fallbackFormat, m = jn(n.missing) ? n.missing : null, v = jn(n.missing) ? W5(n.missing) : null, y = jn(n.postTranslation) ? n.postTranslation : null, x = e ? e.warnHtmlMessage : vn(n.warnHtmlMessage) ? n.warnHtmlMessage : true, b = !!n.escapeParameter;
    const w = e ? e.modifiers : en(n.modifiers) ? n.modifiers : {};
    let _ = n.pluralRules || e && e.pluralRules, S;
    S = (() => {
      r && D5(null);
      const ue = {
        version: Cvt,
        locale: o.value,
        fallbackLocale: l.value,
        messages: u.value,
        modifiers: w,
        pluralRules: _,
        missing: v === null ? void 0 : v,
        missingWarn: d,
        fallbackWarn: f,
        fallbackFormat: g,
        unresolving: true,
        postTranslation: y === null ? void 0 : y,
        warnHtmlMessage: x,
        escapeParameter: b,
        messageResolver: n.messageResolver,
        messageCompiler: n.messageCompiler,
        __meta: {
          framework: "vue"
        }
      };
      ue.datetimeFormats = c.value, ue.numberFormats = h.value, ue.__datetimeFormatters = en(S) ? S.__datetimeFormatters : void 0, ue.__numberFormatters = en(S) ? S.__numberFormatters : void 0;
      const Se = uvt(ue);
      return r && D5(Se), Se;
    })(), Ty(S, o.value, l.value);
    function C() {
      return [
        o.value,
        l.value,
        u.value,
        c.value,
        h.value
      ];
    }
    const T = Zt({
      get: () => o.value,
      set: (ue) => {
        S.locale = ue, o.value = ue;
      }
    }), k = Zt({
      get: () => l.value,
      set: (ue) => {
        S.fallbackLocale = ue, l.value = ue, Ty(S, o.value, ue);
      }
    }), D = Zt(() => u.value), R = Zt(() => c.value), N = Zt(() => h.value);
    function E() {
      return jn(y) ? y : null;
    }
    function A(ue) {
      y = ue, S.postTranslation = ue;
    }
    function M() {
      return m;
    }
    function $(ue) {
      ue !== null && (v = W5(ue)), m = ue, S.missing = v;
    }
    const L = (ue, Se, Ut, Ht, Jn, ua) => {
      C();
      let ca;
      try {
        __INTLIFY_PROD_DEVTOOLS__, r || (S.fallbackContext = e ? lvt() : void 0), ca = ue(S);
      } finally {
        __INTLIFY_PROD_DEVTOOLS__, r || (S.fallbackContext = void 0);
      }
      if (Ut !== "translate exists" && Ir(ca) && ca === b2 || Ut === "translate exists" && !ca) {
        const [Na, bp] = Se();
        return e && p ? Ht(e) : Jn(Na);
      } else {
        if (ua(ca)) return ca;
        throw Ya(Da.UNEXPECTED_RETURN_TYPE);
      }
    };
    function F(...ue) {
      return L((Se) => Reflect.apply(F5, null, [
        Se,
        ...ue
      ]), () => pN(...ue), "translate", (Se) => Reflect.apply(Se.t, Se, [
        ...ue
      ]), (Se) => Se, (Se) => Ke(Se));
    }
    function O(...ue) {
      const [Se, Ut, Ht] = ue;
      if (Ht && !wn(Ht)) throw Ya(Da.INVALID_ARGUMENT);
      return F(Se, Ut, Ur({
        resolvedMessage: true
      }, Ht || {}));
    }
    function z(...ue) {
      return L((Se) => Reflect.apply($5, null, [
        Se,
        ...ue
      ]), () => dN(...ue), "datetime format", (Se) => Reflect.apply(Se.d, Se, [
        ...ue
      ]), () => T5, (Se) => Ke(Se));
    }
    function V(...ue) {
      return L((Se) => Reflect.apply(E5, null, [
        Se,
        ...ue
      ]), () => fN(...ue), "number format", (Se) => Reflect.apply(Se.n, Se, [
        ...ue
      ]), () => T5, (Se) => Ke(Se));
    }
    function H(ue) {
      return ue.map((Se) => Ke(Se) || Ir(Se) || vn(Se) ? O5(String(Se)) : Se);
    }
    const le = {
      normalize: H,
      interpolate: (ue) => ue,
      type: "vnode"
    };
    function ve(...ue) {
      return L((Se) => {
        let Ut;
        const Ht = Se;
        try {
          Ht.processor = le, Ut = Reflect.apply(F5, null, [
            Ht,
            ...ue
          ]);
        } finally {
          Ht.processor = null;
        }
        return Ut;
      }, () => pN(...ue), "translate", (Se) => Se[gN](...ue), (Se) => [
        O5(Se)
      ], (Se) => Rr(Se));
    }
    function re(...ue) {
      return L((Se) => Reflect.apply(E5, null, [
        Se,
        ...ue
      ]), () => fN(...ue), "number format", (Se) => Se[vN](...ue), z5, (Se) => Ke(Se) || Rr(Se));
    }
    function ae(...ue) {
      return L((Se) => Reflect.apply($5, null, [
        Se,
        ...ue
      ]), () => dN(...ue), "datetime format", (Se) => Se[mN](...ue), z5, (Se) => Ke(Se) || Rr(Se));
    }
    function fe(ue) {
      _ = ue, S.pluralRules = _;
    }
    function ce(ue, Se) {
      return L(() => {
        if (!ue) return false;
        const Ut = Ke(Se) ? Se : o.value, Ht = Re(Ut), Jn = S.messageResolver(Ht, ue);
        return um(Jn) || fs(Jn) || Ke(Jn);
      }, () => [
        ue
      ], "translate exists", (Ut) => Reflect.apply(Ut.te, Ut, [
        ue,
        Se
      ]), kvt, (Ut) => vn(Ut));
    }
    function ye(ue) {
      let Se = null;
      const Ut = rae(S, l.value, o.value);
      for (let Ht = 0; Ht < Ut.length; Ht++) {
        const Jn = u.value[Ut[Ht]] || {}, ua = S.messageResolver(Jn, ue);
        if (ua != null) {
          Se = ua;
          break;
        }
      }
      return Se;
    }
    function Le(ue) {
      const Se = ye(ue);
      return Se ?? (e ? e.tm(ue) || {} : {});
    }
    function Re(ue) {
      return u.value[ue] || {};
    }
    function be(ue, Se) {
      if (i) {
        const Ut = {
          [ue]: Se
        };
        for (const Ht in Ut) qs(Ut, Ht) && Tx(Ut[Ht]);
        Se = Ut[ue];
      }
      u.value[ue] = Se, S.messages = u.value;
    }
    function xe(ue, Se) {
      u.value[ue] = u.value[ue] || {};
      const Ut = {
        [ue]: Se
      };
      if (i) for (const Ht in Ut) qs(Ut, Ht) && Tx(Ut[Ht]);
      Se = Ut[ue], D_(Se, u.value[ue]), S.messages = u.value;
    }
    function ot(ue) {
      return c.value[ue] || {};
    }
    function G(ue, Se) {
      c.value[ue] = Se, S.datetimeFormats = c.value, N5(S, ue, Se);
    }
    function q(ue, Se) {
      c.value[ue] = Ur(c.value[ue] || {}, Se), S.datetimeFormats = c.value, N5(S, ue, Se);
    }
    function ge(ue) {
      return h.value[ue] || {};
    }
    function Fe(ue, Se) {
      h.value[ue] = Se, S.numberFormats = h.value, M5(S, ue, Se);
    }
    function Lt(ue, Se) {
      h.value[ue] = Ur(h.value[ue] || {}, Se), S.numberFormats = h.value, M5(S, ue, Se);
    }
    V5++, e && sC && ($i(e.locale, (ue) => {
      s && (o.value = ue, S.locale = ue, Ty(S, o.value, l.value));
    }), $i(e.fallbackLocale, (ue) => {
      s && (l.value = ue, S.fallbackLocale = ue, Ty(S, o.value, l.value));
    }));
    const dt = {
      id: V5,
      locale: T,
      fallbackLocale: k,
      get inheritLocale() {
        return s;
      },
      set inheritLocale(ue) {
        s = ue, ue && e && (o.value = e.locale.value, l.value = e.fallbackLocale.value, Ty(S, o.value, l.value));
      },
      get availableLocales() {
        return Object.keys(u.value).sort();
      },
      messages: D,
      get modifiers() {
        return w;
      },
      get pluralRules() {
        return _ || {};
      },
      get isGlobal() {
        return r;
      },
      get missingWarn() {
        return d;
      },
      set missingWarn(ue) {
        d = ue, S.missingWarn = d;
      },
      get fallbackWarn() {
        return f;
      },
      set fallbackWarn(ue) {
        f = ue, S.fallbackWarn = f;
      },
      get fallbackRoot() {
        return p;
      },
      set fallbackRoot(ue) {
        p = ue;
      },
      get fallbackFormat() {
        return g;
      },
      set fallbackFormat(ue) {
        g = ue, S.fallbackFormat = g;
      },
      get warnHtmlMessage() {
        return x;
      },
      set warnHtmlMessage(ue) {
        x = ue, S.warnHtmlMessage = ue;
      },
      get escapeParameter() {
        return b;
      },
      set escapeParameter(ue) {
        b = ue, S.escapeParameter = ue;
      },
      t: F,
      getLocaleMessage: Re,
      setLocaleMessage: be,
      mergeLocaleMessage: xe,
      getPostTranslationHandler: E,
      setPostTranslationHandler: A,
      getMissingHandler: M,
      setMissingHandler: $,
      [fae]: fe
    };
    return dt.datetimeFormats = R, dt.numberFormats = N, dt.rt = O, dt.te = ce, dt.tm = Le, dt.d = z, dt.n = V, dt.getDateTimeFormat = ot, dt.setDateTimeFormat = G, dt.mergeDateTimeFormat = q, dt.getNumberFormat = ge, dt.setNumberFormat = Fe, dt.mergeNumberFormat = Lt, dt[pae] = t, dt[gN] = ve, dt[mN] = ae, dt[vN] = re, dt;
  }
  function Avt(n) {
    const e = Ke(n.locale) ? n.locale : kx, t = Ke(n.fallbackLocale) || Rr(n.fallbackLocale) || en(n.fallbackLocale) || n.fallbackLocale === false ? n.fallbackLocale : e, r = jn(n.missing) ? n.missing : void 0, i = vn(n.silentTranslationWarn) || om(n.silentTranslationWarn) ? !n.silentTranslationWarn : true, a = vn(n.silentFallbackWarn) || om(n.silentFallbackWarn) ? !n.silentFallbackWarn : true, s = vn(n.fallbackRoot) ? n.fallbackRoot : true, o = !!n.formatFallbackMessages, l = en(n.modifiers) ? n.modifiers : {}, u = n.pluralizationRules, c = jn(n.postTranslation) ? n.postTranslation : void 0, h = Ke(n.warnHtmlInMessage) ? n.warnHtmlInMessage !== "off" : true, d = !!n.escapeParameterHtml, f = vn(n.sync) ? n.sync : true;
    let p = n.messages;
    if (en(n.sharedMessages)) {
      const w = n.sharedMessages;
      p = Object.keys(w).reduce((S, I) => {
        const C = S[I] || (S[I] = {});
        return Ur(C, w[I]), S;
      }, p || {});
    }
    const { __i18n: g, __root: m, __injectWithOption: v } = n, y = n.datetimeFormats, x = n.numberFormats, b = n.flatJson;
    return {
      locale: e,
      fallbackLocale: t,
      messages: p,
      flatJson: b,
      datetimeFormats: y,
      numberFormats: x,
      missing: r,
      missingWarn: i,
      fallbackWarn: a,
      fallbackRoot: s,
      fallbackFormat: o,
      modifiers: l,
      pluralRules: u,
      postTranslation: c,
      warnHtmlMessage: h,
      escapeParameter: d,
      messageResolver: n.messageResolver,
      inheritLocale: f,
      __i18n: g,
      __root: m,
      __injectWithOption: v
    };
  }
  function xN(n = {}) {
    const e = l3(Avt(n)), { __extender: t } = n, r = {
      id: e.id,
      get locale() {
        return e.locale.value;
      },
      set locale(i) {
        e.locale.value = i;
      },
      get fallbackLocale() {
        return e.fallbackLocale.value;
      },
      set fallbackLocale(i) {
        e.fallbackLocale.value = i;
      },
      get messages() {
        return e.messages.value;
      },
      get datetimeFormats() {
        return e.datetimeFormats.value;
      },
      get numberFormats() {
        return e.numberFormats.value;
      },
      get availableLocales() {
        return e.availableLocales;
      },
      get missing() {
        return e.getMissingHandler();
      },
      set missing(i) {
        e.setMissingHandler(i);
      },
      get silentTranslationWarn() {
        return vn(e.missingWarn) ? !e.missingWarn : e.missingWarn;
      },
      set silentTranslationWarn(i) {
        e.missingWarn = vn(i) ? !i : i;
      },
      get silentFallbackWarn() {
        return vn(e.fallbackWarn) ? !e.fallbackWarn : e.fallbackWarn;
      },
      set silentFallbackWarn(i) {
        e.fallbackWarn = vn(i) ? !i : i;
      },
      get modifiers() {
        return e.modifiers;
      },
      get formatFallbackMessages() {
        return e.fallbackFormat;
      },
      set formatFallbackMessages(i) {
        e.fallbackFormat = i;
      },
      get postTranslation() {
        return e.getPostTranslationHandler();
      },
      set postTranslation(i) {
        e.setPostTranslationHandler(i);
      },
      get sync() {
        return e.inheritLocale;
      },
      set sync(i) {
        e.inheritLocale = i;
      },
      get warnHtmlInMessage() {
        return e.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(i) {
        e.warnHtmlMessage = i !== "off";
      },
      get escapeParameterHtml() {
        return e.escapeParameter;
      },
      set escapeParameterHtml(i) {
        e.escapeParameter = i;
      },
      get pluralizationRules() {
        return e.pluralRules || {};
      },
      __composer: e,
      t(...i) {
        return Reflect.apply(e.t, e, [
          ...i
        ]);
      },
      rt(...i) {
        return Reflect.apply(e.rt, e, [
          ...i
        ]);
      },
      te(i, a) {
        return e.te(i, a);
      },
      tm(i) {
        return e.tm(i);
      },
      getLocaleMessage(i) {
        return e.getLocaleMessage(i);
      },
      setLocaleMessage(i, a) {
        e.setLocaleMessage(i, a);
      },
      mergeLocaleMessage(i, a) {
        e.mergeLocaleMessage(i, a);
      },
      d(...i) {
        return Reflect.apply(e.d, e, [
          ...i
        ]);
      },
      getDateTimeFormat(i) {
        return e.getDateTimeFormat(i);
      },
      setDateTimeFormat(i, a) {
        e.setDateTimeFormat(i, a);
      },
      mergeDateTimeFormat(i, a) {
        e.mergeDateTimeFormat(i, a);
      },
      n(...i) {
        return Reflect.apply(e.n, e, [
          ...i
        ]);
      },
      getNumberFormat(i) {
        return e.getNumberFormat(i);
      },
      setNumberFormat(i, a) {
        e.setNumberFormat(i, a);
      },
      mergeNumberFormat(i, a) {
        e.mergeNumberFormat(i, a);
      }
    };
    return r.__extender = t, r;
  }
  function Dvt(n, e, t) {
    return {
      beforeCreate() {
        const r = Ha();
        if (!r) throw Ya(Da.UNEXPECTED_ERROR);
        const i = this.$options;
        if (i.i18n) {
          const a = i.i18n;
          if (i.__i18n && (a.__i18n = i.__i18n), a.__root = e, this === this.$root) this.$i18n = G5(n, a);
          else {
            a.__injectWithOption = true, a.__extender = t.__vueI18nExtend, this.$i18n = xN(a);
            const s = this.$i18n;
            s.__extender && (s.__disposer = s.__extender(this.$i18n));
          }
        } else if (i.__i18n) if (this === this.$root) this.$i18n = G5(n, i);
        else {
          this.$i18n = xN({
            __i18n: i.__i18n,
            __injectWithOption: true,
            __extender: t.__vueI18nExtend,
            __root: e
          });
          const a = this.$i18n;
          a.__extender && (a.__disposer = a.__extender(this.$i18n));
        }
        else this.$i18n = n;
        i.__i18nGlobal && mae(e, i, i), this.$t = (...a) => this.$i18n.t(...a), this.$rt = (...a) => this.$i18n.rt(...a), this.$te = (a, s) => this.$i18n.te(a, s), this.$d = (...a) => this.$i18n.d(...a), this.$n = (...a) => this.$i18n.n(...a), this.$tm = (a) => this.$i18n.tm(a), t.__setInstance(r, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const r = Ha();
        if (!r) throw Ya(Da.UNEXPECTED_ERROR);
        const i = this.$i18n;
        delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), t.__deleteInstance(r), delete this.$i18n;
      }
    };
  }
  function G5(n, e) {
    n.locale = e.locale || n.locale, n.fallbackLocale = e.fallbackLocale || n.fallbackLocale, n.missing = e.missing || n.missing, n.silentTranslationWarn = e.silentTranslationWarn || n.silentFallbackWarn, n.silentFallbackWarn = e.silentFallbackWarn || n.silentFallbackWarn, n.formatFallbackMessages = e.formatFallbackMessages || n.formatFallbackMessages, n.postTranslation = e.postTranslation || n.postTranslation, n.warnHtmlInMessage = e.warnHtmlInMessage || n.warnHtmlInMessage, n.escapeParameterHtml = e.escapeParameterHtml || n.escapeParameterHtml, n.sync = e.sync || n.sync, n.__composer[fae](e.pluralizationRules || n.pluralizationRules);
    const t = o3(n.locale, {
      messages: e.messages,
      __i18n: e.__i18n
    });
    return Object.keys(t).forEach((r) => n.mergeLocaleMessage(r, t[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach((r) => n.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach((r) => n.mergeNumberFormat(r, e.numberFormats[r])), n;
  }
  const u3 = {
    tag: {
      type: [
        String,
        Object
      ]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (n) => n === "parent" || n === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  function Rvt({ slots: n }, e) {
    return e.length === 1 && e[0] === "default" ? (n.default ? n.default() : []).reduce((r, i) => [
      ...r,
      ...i.type === _0 ? i.children : [
        i
      ]
    ], []) : e.reduce((t, r) => {
      const i = n[r];
      return i && (t[r] = i()), t;
    }, Bn());
  }
  function vae() {
    return _0;
  }
  const $vt = Rt({
    name: "i18n-t",
    props: Ur({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [
          Number,
          String
        ],
        validator: (n) => Ir(n) || !isNaN(n)
      }
    }, u3),
    setup(n, e) {
      const { slots: t, attrs: r } = e, i = n.i18n || c3({
        useScope: n.scope,
        __useComponent: true
      });
      return () => {
        const a = Object.keys(t).filter((h) => h !== "_"), s = Bn();
        n.locale && (s.locale = n.locale), n.plural !== void 0 && (s.plural = Ke(n.plural) ? +n.plural : n.plural);
        const o = Rvt(e, a), l = i[gN](n.keypath, o, s), u = Ur(Bn(), r), c = Ke(n.tag) || wn(n.tag) ? n.tag : vae();
        return js(c, u, l);
      };
    }
  }), U5 = $vt;
  function Nvt(n) {
    return Rr(n) && !Ke(n[0]);
  }
  function yae(n, e, t, r) {
    const { slots: i, attrs: a } = e;
    return () => {
      const s = {
        part: true
      };
      let o = Bn();
      n.locale && (s.locale = n.locale), Ke(n.format) ? s.key = n.format : wn(n.format) && (Ke(n.format.key) && (s.key = n.format.key), o = Object.keys(n.format).reduce((d, f) => t.includes(f) ? Ur(Bn(), d, {
        [f]: n.format[f]
      }) : d, Bn()));
      const l = r(n.value, s, o);
      let u = [
        s.key
      ];
      Rr(l) ? u = l.map((d, f) => {
        const p = i[d.type], g = p ? p({
          [d.type]: d.value,
          index: f,
          parts: l
        }) : [
          d.value
        ];
        return Nvt(g) && (g[0].key = `${d.type}-${f}`), g;
      }) : Ke(l) && (u = [
        l
      ]);
      const c = Ur(Bn(), a), h = Ke(n.tag) || wn(n.tag) ? n.tag : vae();
      return js(h, c, u);
    };
  }
  const Evt = Rt({
    name: "i18n-n",
    props: Ur({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, u3),
    setup(n, e) {
      const t = n.i18n || c3({
        useScope: n.scope,
        __useComponent: true
      });
      return yae(n, e, cae, (...r) => t[vN](...r));
    }
  }), H5 = Evt;
  function Mvt(n, e) {
    const t = n;
    if (n.mode === "composition") return t.__getInstance(e) || n.global;
    {
      const r = t.__getInstance(e);
      return r != null ? r.__composer : n.global.__composer;
    }
  }
  function Pvt(n) {
    const e = (s) => {
      const { instance: o, value: l } = s;
      if (!o || !o.$) throw Ya(Da.UNEXPECTED_ERROR);
      const u = Mvt(n, o.$), c = X5(l);
      return [
        Reflect.apply(u.t, u, [
          ...Y5(c)
        ]),
        u
      ];
    };
    return {
      created: (s, o) => {
        const [l, u] = e(o);
        sC && n.global === u && (s.__i18nWatcher = $i(u.locale, () => {
          o.instance && o.instance.$forceUpdate();
        })), s.__composer = u, s.textContent = l;
      },
      unmounted: (s) => {
        sC && s.__i18nWatcher && (s.__i18nWatcher(), s.__i18nWatcher = void 0, delete s.__i18nWatcher), s.__composer && (s.__composer = void 0, delete s.__composer);
      },
      beforeUpdate: (s, { value: o }) => {
        if (s.__composer) {
          const l = s.__composer, u = X5(o);
          s.textContent = Reflect.apply(l.t, l, [
            ...Y5(u)
          ]);
        }
      },
      getSSRProps: (s) => {
        const [o] = e(s);
        return {
          textContent: o
        };
      }
    };
  }
  function X5(n) {
    if (Ke(n)) return {
      path: n
    };
    if (en(n)) {
      if (!("path" in n)) throw Ya(Da.REQUIRED_VALUE, "path");
      return n;
    } else throw Ya(Da.INVALID_VALUE);
  }
  function Y5(n) {
    const { path: e, locale: t, args: r, choice: i, plural: a } = n, s = {}, o = r || {};
    return Ke(t) && (s.locale = t), Ir(i) && (s.plural = i), Ir(a) && (s.plural = a), [
      e,
      o,
      s
    ];
  }
  function Lvt(n, e, ...t) {
    const r = en(t[0]) ? t[0] : {};
    (vn(r.globalInstall) ? r.globalInstall : true) && ([
      U5.name,
      "I18nT"
    ].forEach((a) => n.component(a, U5)), [
      H5.name,
      "I18nN"
    ].forEach((a) => n.component(a, H5)), [
      j5.name,
      "I18nD"
    ].forEach((a) => n.component(a, j5))), n.directive("t", Pvt(e));
  }
  const Fvt = Ec("global-vue-i18n");
  function Ovt(n = {}) {
    const e = __VUE_I18N_LEGACY_API__ && vn(n.legacy) ? n.legacy : __VUE_I18N_LEGACY_API__, t = vn(n.globalInjection) ? n.globalInjection : true, r = /* @__PURE__ */ new Map(), [i, a] = Bvt(n, e), s = Ec("");
    function o(h) {
      return r.get(h) || null;
    }
    function l(h, d) {
      r.set(h, d);
    }
    function u(h) {
      r.delete(h);
    }
    const c = {
      get mode() {
        return __VUE_I18N_LEGACY_API__ && e ? "legacy" : "composition";
      },
      async install(h, ...d) {
        if (h.__VUE_I18N_SYMBOL__ = s, h.provide(h.__VUE_I18N_SYMBOL__, c), en(d[0])) {
          const g = d[0];
          c.__composerExtend = g.__composerExtend, c.__vueI18nExtend = g.__vueI18nExtend;
        }
        let f = null;
        !e && t && (f = Yvt(h, c.global)), __VUE_I18N_FULL_INSTALL__ && Lvt(h, c, ...d), __VUE_I18N_LEGACY_API__ && e && h.mixin(Dvt(a, a.__composer, c));
        const p = h.unmount;
        h.unmount = () => {
          f && f(), c.dispose(), p();
        };
      },
      get global() {
        return a;
      },
      dispose() {
        i.stop();
      },
      __instances: r,
      __getInstance: o,
      __setInstance: l,
      __deleteInstance: u
    };
    return c;
  }
  function c3(n = {}) {
    const e = Ha();
    if (e == null) throw Ya(Da.MUST_BE_CALL_SETUP_TOP);
    if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw Ya(Da.NOT_INSTALLED);
    const t = zvt(e), r = Wvt(t), i = gae(e), a = Vvt(n, i);
    if (a === "global") return mae(r, n, i), r;
    if (a === "parent") {
      let l = Gvt(t, e, n.__useComponent);
      return l == null && (l = r), l;
    }
    const s = t;
    let o = s.__getInstance(e);
    if (o == null) {
      const l = Ur({}, n);
      "__i18n" in i && (l.__i18n = i.__i18n), r && (l.__root = r), o = l3(l), s.__composerExtend && (o[yN] = s.__composerExtend(o)), Hvt(s, e, o), s.__setInstance(e, o);
    }
    return o;
  }
  function Bvt(n, e) {
    const t = CN(), r = __VUE_I18N_LEGACY_API__ && e ? t.run(() => xN(n)) : t.run(() => l3(n));
    if (r == null) throw Ya(Da.UNEXPECTED_ERROR);
    return [
      t,
      r
    ];
  }
  function zvt(n) {
    const e = f6(n.isCE ? Fvt : n.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e) throw Ya(n.isCE ? Da.NOT_INSTALLED_WITH_PROVIDE : Da.UNEXPECTED_ERROR);
    return e;
  }
  function Vvt(n, e) {
    return y2(n) ? "__i18n" in e ? "local" : "global" : n.useScope ? n.useScope : "local";
  }
  function Wvt(n) {
    return n.mode === "composition" ? n.global : n.global.__composer;
  }
  function Gvt(n, e, t = false) {
    let r = null;
    const i = e.root;
    let a = Uvt(e, t);
    for (; a != null; ) {
      const s = n;
      if (n.mode === "composition") r = s.__getInstance(a);
      else if (__VUE_I18N_LEGACY_API__) {
        const o = s.__getInstance(a);
        o != null && (r = o.__composer, t && r && !r[pae] && (r = null));
      }
      if (r != null || i === a) break;
      a = a.parent;
    }
    return r;
  }
  function Uvt(n, e = false) {
    return n == null ? null : e && n.vnode.ctx || n.parent;
  }
  function Hvt(n, e, t) {
    cm(() => {
    }, e), lC(() => {
      const r = t;
      n.__deleteInstance(e);
      const i = r[yN];
      i && (i(), delete r[yN]);
    }, e);
  }
  const Xvt = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ], q5 = [
    "t",
    "rt",
    "d",
    "n",
    "tm",
    "te"
  ];
  function Yvt(n, e) {
    const t = /* @__PURE__ */ Object.create(null);
    return Xvt.forEach((i) => {
      const a = Object.getOwnPropertyDescriptor(e, i);
      if (!a) throw Ya(Da.UNEXPECTED_ERROR);
      const s = d6(a.value) ? {
        get() {
          return a.value.value;
        },
        set(o) {
          a.value.value = o;
        }
      } : {
        get() {
          return a.get && a.get();
        }
      };
      Object.defineProperty(t, i, s);
    }), n.config.globalProperties.$i18n = t, q5.forEach((i) => {
      const a = Object.getOwnPropertyDescriptor(e, i);
      if (!a || !a.value) throw Ya(Da.UNEXPECTED_ERROR);
      Object.defineProperty(n.config.globalProperties, `$${i}`, a);
    }), () => {
      delete n.config.globalProperties.$i18n, q5.forEach((i) => {
        delete n.config.globalProperties[`$${i}`];
      });
    };
  }
  const qvt = Rt({
    name: "i18n-d",
    props: Ur({
      value: {
        type: [
          Number,
          Date
        ],
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, u3),
    setup(n, e) {
      const t = n.i18n || c3({
        useScope: n.scope,
        __useComponent: true
      });
      return yae(n, e, uae, (...r) => t[mN](...r));
    }
  }), j5 = qvt;
  Ivt();
  rvt(Omt);
  ivt(evt);
  avt(rae);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const n = Yh();
    n.__INTLIFY__ = true, Bmt(n.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const jvt = h6("app", {
    state: () => ({
      lang: ""
    }),
    actions: {
      setNowLang(n) {
        this.lang = n;
      }
    }
  }), K5 = await Qvt({
    locale: Kvt()
  });
  function Kvt() {
    const n = window.location.href, e = navigator.language, t = eyt(n).lang ?? e;
    return jvt().setNowLang(t), t;
  }
  function Zvt(n) {
    return n.includes("zh");
  }
  async function Qvt(n = {
    locale: "zh-CN"
  }) {
    const e = Ovt({
      legacy: false,
      globalInjection: true,
      fallbackLocale: "zh-CN",
      ...n
    });
    return Jvt(e, n.locale), await Z5(e, "zh-CN"), Zvt(n.locale) || await Z5(e, n.locale), e;
  }
  function Jvt(n, e = "zh-CN") {
    var _a2;
    n.mode === "legacy" ? n.global.locale = e : typeof n.global.locale != "string" && (n.global.locale.value = e), (_a2 = document.querySelector("html")) == null ? void 0 : _a2.setAttribute("lang", e);
  }
  async function Z5(n, e) {
    const t = await Vgt(Object.assign({
      "./locales/en.json": () => $g(() => import("./en-6Y5830hC.js"), []),
      "./locales/zh-CN.json": () => $g(() => import("./zh-CN-HZdoqDhl.js"), [])
    }), `./locales/${e}.json`, 3);
    return n.global.setLocaleMessage(e, t.default), nu();
  }
  function eyt(n) {
    const e = {};
    if (!n || n === "" || typeof n != "string") return e;
    const t = n.split("?")[1];
    return t && t.split("&").forEach((i) => {
      const [a, s] = i.split("=");
      s === void 0 ? e[a] = null : s === "true" ? e[a] = true : s === "false" ? e[a] = false : e[a] = decodeURIComponent(s);
    }), e;
  }
  const tyt = () => {
    const n = Zt(() => J(K5.global.locale)), e = Zt(() => n.value.includes("zh"));
    return {
      t: K5.global.t,
      locale: n,
      isZh: e
    };
  };
  function xae(n) {
    var e, t, r = "";
    if (typeof n == "string" || typeof n == "number") r += n;
    else if (typeof n == "object") if (Array.isArray(n)) {
      var i = n.length;
      for (e = 0; e < i; e++) n[e] && (t = xae(n[e])) && (r && (r += " "), r += t);
    } else for (t in n) n[t] && (r && (r += " "), r += t);
    return r;
  }
  function bae() {
    for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++) (n = arguments[t]) && (e = xae(n)) && (r && (r += " "), r += e);
    return r;
  }
  const Q5 = (n) => typeof n == "boolean" ? `${n}` : n === 0 ? "0" : n, J5 = bae, nyt = (n, e) => (t) => {
    var r;
    if ((e == null ? void 0 : e.variants) == null) return J5(n, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
    const { variants: i, defaultVariants: a } = e, s = Object.keys(i).map((u) => {
      const c = t == null ? void 0 : t[u], h = a == null ? void 0 : a[u];
      if (c === null) return null;
      const d = Q5(c) || Q5(h);
      return i[u][d];
    }), o = t && Object.entries(t).reduce((u, c) => {
      let [h, d] = c;
      return d === void 0 || (u[h] = d), u;
    }, {}), l = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, c) => {
      let { class: h, className: d, ...f } = c;
      return Object.entries(f).every((p) => {
        let [g, m] = p;
        return Array.isArray(m) ? m.includes({
          ...a,
          ...o
        }[g]) : {
          ...a,
          ...o
        }[g] === m;
      }) ? [
        ...u,
        h,
        d
      ] : u;
    }, []);
    return J5(n, s, l, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
  }, h3 = "-", ryt = (n) => {
    const e = ayt(n), { conflictingClassGroups: t, conflictingClassGroupModifiers: r } = n;
    return {
      getClassGroupId: (s) => {
        const o = s.split(h3);
        return o[0] === "" && o.length !== 1 && o.shift(), wae(o, e) || iyt(s);
      },
      getConflictingClassGroupIds: (s, o) => {
        const l = t[s] || [];
        return o && r[s] ? [
          ...l,
          ...r[s]
        ] : l;
      }
    };
  }, wae = (n, e) => {
    var _a2;
    if (n.length === 0) return e.classGroupId;
    const t = n[0], r = e.nextPart.get(t), i = r ? wae(n.slice(1), r) : void 0;
    if (i) return i;
    if (e.validators.length === 0) return;
    const a = n.join(h3);
    return (_a2 = e.validators.find(({ validator: s }) => s(a))) == null ? void 0 : _a2.classGroupId;
  }, e6 = /^\[(.+)\]$/, iyt = (n) => {
    if (e6.test(n)) {
      const e = e6.exec(n)[1], t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
      if (t) return "arbitrary.." + t;
    }
  }, ayt = (n) => {
    const { theme: e, classGroups: t } = n, r = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    for (const i in t) bN(t[i], r, i, e);
    return r;
  }, bN = (n, e, t, r) => {
    n.forEach((i) => {
      if (typeof i == "string") {
        const a = i === "" ? e : t6(e, i);
        a.classGroupId = t;
        return;
      }
      if (typeof i == "function") {
        if (syt(i)) {
          bN(i(r), e, t, r);
          return;
        }
        e.validators.push({
          validator: i,
          classGroupId: t
        });
        return;
      }
      Object.entries(i).forEach(([a, s]) => {
        bN(s, t6(e, a), t, r);
      });
    });
  }, t6 = (n, e) => {
    let t = n;
    return e.split(h3).forEach((r) => {
      t.nextPart.has(r) || t.nextPart.set(r, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      }), t = t.nextPart.get(r);
    }), t;
  }, syt = (n) => n.isThemeGetter, oyt = (n) => {
    if (n < 1) return {
      get: () => {
      },
      set: () => {
      }
    };
    let e = 0, t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
    const i = (a, s) => {
      t.set(a, s), e++, e > n && (e = 0, r = t, t = /* @__PURE__ */ new Map());
    };
    return {
      get(a) {
        let s = t.get(a);
        if (s !== void 0) return s;
        if ((s = r.get(a)) !== void 0) return i(a, s), s;
      },
      set(a, s) {
        t.has(a) ? t.set(a, s) : i(a, s);
      }
    };
  }, wN = "!", _N = ":", lyt = _N.length, uyt = (n) => {
    const { prefix: e, experimentalParseClassName: t } = n;
    let r = (i) => {
      const a = [];
      let s = 0, o = 0, l = 0, u;
      for (let p = 0; p < i.length; p++) {
        let g = i[p];
        if (s === 0 && o === 0) {
          if (g === _N) {
            a.push(i.slice(l, p)), l = p + lyt;
            continue;
          }
          if (g === "/") {
            u = p;
            continue;
          }
        }
        g === "[" ? s++ : g === "]" ? s-- : g === "(" ? o++ : g === ")" && o--;
      }
      const c = a.length === 0 ? i : i.substring(l), h = cyt(c), d = h !== c, f = u && u > l ? u - l : void 0;
      return {
        modifiers: a,
        hasImportantModifier: d,
        baseClassName: h,
        maybePostfixModifierPosition: f
      };
    };
    if (e) {
      const i = e + _N, a = r;
      r = (s) => s.startsWith(i) ? a(s.substring(i.length)) : {
        isExternal: true,
        modifiers: [],
        hasImportantModifier: false,
        baseClassName: s,
        maybePostfixModifierPosition: void 0
      };
    }
    if (t) {
      const i = r;
      r = (a) => t({
        className: a,
        parseClassName: i
      });
    }
    return r;
  }, cyt = (n) => n.endsWith(wN) ? n.substring(0, n.length - 1) : n.startsWith(wN) ? n.substring(1) : n, hyt = (n) => {
    const e = Object.fromEntries(n.orderSensitiveModifiers.map((r) => [
      r,
      true
    ]));
    return (r) => {
      if (r.length <= 1) return r;
      const i = [];
      let a = [];
      return r.forEach((s) => {
        s[0] === "[" || e[s] ? (i.push(...a.sort(), s), a = []) : a.push(s);
      }), i.push(...a.sort()), i;
    };
  }, dyt = (n) => ({
    cache: oyt(n.cacheSize),
    parseClassName: uyt(n),
    sortModifiers: hyt(n),
    ...ryt(n)
  }), fyt = /\s+/, pyt = (n, e) => {
    const { parseClassName: t, getClassGroupId: r, getConflictingClassGroupIds: i, sortModifiers: a } = e, s = [], o = n.trim().split(fyt);
    let l = "";
    for (let u = o.length - 1; u >= 0; u -= 1) {
      const c = o[u], { isExternal: h, modifiers: d, hasImportantModifier: f, baseClassName: p, maybePostfixModifierPosition: g } = t(c);
      if (h) {
        l = c + (l.length > 0 ? " " + l : l);
        continue;
      }
      let m = !!g, v = r(m ? p.substring(0, g) : p);
      if (!v) {
        if (!m) {
          l = c + (l.length > 0 ? " " + l : l);
          continue;
        }
        if (v = r(p), !v) {
          l = c + (l.length > 0 ? " " + l : l);
          continue;
        }
        m = false;
      }
      const y = a(d).join(":"), x = f ? y + wN : y, b = x + v;
      if (s.includes(b)) continue;
      s.push(b);
      const w = i(v, m);
      for (let _ = 0; _ < w.length; ++_) {
        const S = w[_];
        s.push(x + S);
      }
      l = c + (l.length > 0 ? " " + l : l);
    }
    return l;
  };
  function gyt() {
    let n = 0, e, t, r = "";
    for (; n < arguments.length; ) (e = arguments[n++]) && (t = _ae(e)) && (r && (r += " "), r += t);
    return r;
  }
  const _ae = (n) => {
    if (typeof n == "string") return n;
    let e, t = "";
    for (let r = 0; r < n.length; r++) n[r] && (e = _ae(n[r])) && (t && (t += " "), t += e);
    return t;
  };
  function myt(n, ...e) {
    let t, r, i, a = s;
    function s(l) {
      const u = e.reduce((c, h) => h(c), n());
      return t = dyt(u), r = t.cache.get, i = t.cache.set, a = o, o(l);
    }
    function o(l) {
      const u = r(l);
      if (u) return u;
      const c = pyt(l, t);
      return i(l, c), c;
    }
    return function() {
      return a(gyt.apply(null, arguments));
    };
  }
  const Qr = (n) => {
    const e = (t) => t[n] || [];
    return e.isThemeGetter = true, e;
  }, Sae = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, Cae = /^\((?:(\w[\w-]*):)?(.+)\)$/i, vyt = /^\d+\/\d+$/, yyt = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, xyt = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, byt = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, wyt = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, _yt = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Jp = (n) => vyt.test(n), tn = (n) => !!n && !Number.isNaN(Number(n)), fh = (n) => !!n && Number.isInteger(Number(n)), n6 = (n) => n.endsWith("%") && tn(n.slice(0, -1)), Cu = (n) => yyt.test(n), Syt = () => true, Cyt = (n) => xyt.test(n) && !byt.test(n), d3 = () => false, Iyt = (n) => wyt.test(n), kyt = (n) => _yt.test(n), Tyt = (n) => !Ye(n) && !qe(n), Ayt = (n) => zv(n, Tae, d3), Ye = (n) => Sae.test(n), ph = (n) => zv(n, Aae, Cyt), nD = (n) => zv(n, Byt, tn), Dyt = (n) => zv(n, Iae, d3), Ryt = (n) => zv(n, kae, kyt), $yt = (n) => zv(n, d3, Iyt), qe = (n) => Cae.test(n), Ww = (n) => Vv(n, Aae), Nyt = (n) => Vv(n, zyt), Eyt = (n) => Vv(n, Iae), Myt = (n) => Vv(n, Tae), Pyt = (n) => Vv(n, kae), Lyt = (n) => Vv(n, Vyt, true), zv = (n, e, t) => {
    const r = Sae.exec(n);
    return r ? r[1] ? e(r[1]) : t(r[2]) : false;
  }, Vv = (n, e, t = false) => {
    const r = Cae.exec(n);
    return r ? r[1] ? e(r[1]) : t : false;
  }, Iae = (n) => n === "position", Fyt = /* @__PURE__ */ new Set([
    "image",
    "url"
  ]), kae = (n) => Fyt.has(n), Oyt = /* @__PURE__ */ new Set([
    "length",
    "size",
    "percentage"
  ]), Tae = (n) => Oyt.has(n), Aae = (n) => n === "length", Byt = (n) => n === "number", zyt = (n) => n === "family-name", Vyt = (n) => n === "shadow", Wyt = () => {
    const n = Qr("color"), e = Qr("font"), t = Qr("text"), r = Qr("font-weight"), i = Qr("tracking"), a = Qr("leading"), s = Qr("breakpoint"), o = Qr("container"), l = Qr("spacing"), u = Qr("radius"), c = Qr("shadow"), h = Qr("inset-shadow"), d = Qr("drop-shadow"), f = Qr("blur"), p = Qr("perspective"), g = Qr("aspect"), m = Qr("ease"), v = Qr("animate"), y = () => [
      "auto",
      "avoid",
      "all",
      "avoid-page",
      "page",
      "left",
      "right",
      "column"
    ], x = () => [
      "bottom",
      "center",
      "left",
      "left-bottom",
      "left-top",
      "right",
      "right-bottom",
      "right-top",
      "top"
    ], b = () => [
      "auto",
      "hidden",
      "clip",
      "visible",
      "scroll"
    ], w = () => [
      "auto",
      "contain",
      "none"
    ], _ = () => [
      Jp,
      "px",
      "full",
      "auto",
      qe,
      Ye,
      l
    ], S = () => [
      fh,
      "none",
      "subgrid",
      qe,
      Ye
    ], I = () => [
      "auto",
      {
        span: [
          "full",
          fh,
          qe,
          Ye
        ]
      },
      qe,
      Ye
    ], C = () => [
      fh,
      "auto",
      qe,
      Ye
    ], T = () => [
      "auto",
      "min",
      "max",
      "fr",
      qe,
      Ye
    ], k = () => [
      qe,
      Ye,
      l
    ], D = () => [
      "start",
      "end",
      "center",
      "between",
      "around",
      "evenly",
      "stretch",
      "baseline"
    ], R = () => [
      "start",
      "end",
      "center",
      "stretch"
    ], N = () => [
      qe,
      Ye,
      l
    ], E = () => [
      "px",
      ...N()
    ], A = () => [
      "px",
      "auto",
      ...N()
    ], M = () => [
      Jp,
      "auto",
      "px",
      "full",
      "dvw",
      "dvh",
      "lvw",
      "lvh",
      "svw",
      "svh",
      "min",
      "max",
      "fit",
      qe,
      Ye,
      l
    ], $ = () => [
      n,
      qe,
      Ye
    ], L = () => [
      n6,
      ph
    ], F = () => [
      "",
      "none",
      "full",
      u,
      qe,
      Ye
    ], O = () => [
      "",
      tn,
      Ww,
      ph
    ], z = () => [
      "solid",
      "dashed",
      "dotted",
      "double"
    ], V = () => [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ], H = () => [
      "",
      "none",
      f,
      qe,
      Ye
    ], Y = () => [
      "center",
      "top",
      "top-right",
      "right",
      "bottom-right",
      "bottom",
      "bottom-left",
      "left",
      "top-left",
      qe,
      Ye
    ], le = () => [
      "none",
      tn,
      qe,
      Ye
    ], ve = () => [
      "none",
      tn,
      qe,
      Ye
    ], re = () => [
      tn,
      qe,
      Ye
    ], ae = () => [
      Jp,
      "full",
      "px",
      qe,
      Ye,
      l
    ];
    return {
      cacheSize: 500,
      theme: {
        animate: [
          "spin",
          "ping",
          "pulse",
          "bounce"
        ],
        aspect: [
          "video"
        ],
        blur: [
          Cu
        ],
        breakpoint: [
          Cu
        ],
        color: [
          Syt
        ],
        container: [
          Cu
        ],
        "drop-shadow": [
          Cu
        ],
        ease: [
          "in",
          "out",
          "in-out"
        ],
        font: [
          Tyt
        ],
        "font-weight": [
          "thin",
          "extralight",
          "light",
          "normal",
          "medium",
          "semibold",
          "bold",
          "extrabold",
          "black"
        ],
        "inset-shadow": [
          Cu
        ],
        leading: [
          "none",
          "tight",
          "snug",
          "normal",
          "relaxed",
          "loose"
        ],
        perspective: [
          "dramatic",
          "near",
          "normal",
          "midrange",
          "distant",
          "none"
        ],
        radius: [
          Cu
        ],
        shadow: [
          Cu
        ],
        spacing: [
          tn
        ],
        text: [
          Cu
        ],
        tracking: [
          "tighter",
          "tight",
          "normal",
          "wide",
          "wider",
          "widest"
        ]
      },
      classGroups: {
        aspect: [
          {
            aspect: [
              "auto",
              "square",
              Jp,
              Ye,
              qe,
              g
            ]
          }
        ],
        container: [
          "container"
        ],
        columns: [
          {
            columns: [
              tn,
              Ye,
              qe,
              o
            ]
          }
        ],
        "break-after": [
          {
            "break-after": y()
          }
        ],
        "break-before": [
          {
            "break-before": y()
          }
        ],
        "break-inside": [
          {
            "break-inside": [
              "auto",
              "avoid",
              "avoid-page",
              "avoid-column"
            ]
          }
        ],
        "box-decoration": [
          {
            "box-decoration": [
              "slice",
              "clone"
            ]
          }
        ],
        box: [
          {
            box: [
              "border",
              "content"
            ]
          }
        ],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden"
        ],
        sr: [
          "sr-only",
          "not-sr-only"
        ],
        float: [
          {
            float: [
              "right",
              "left",
              "none",
              "start",
              "end"
            ]
          }
        ],
        clear: [
          {
            clear: [
              "left",
              "right",
              "both",
              "none",
              "start",
              "end"
            ]
          }
        ],
        isolation: [
          "isolate",
          "isolation-auto"
        ],
        "object-fit": [
          {
            object: [
              "contain",
              "cover",
              "fill",
              "none",
              "scale-down"
            ]
          }
        ],
        "object-position": [
          {
            object: [
              ...x(),
              Ye,
              qe
            ]
          }
        ],
        overflow: [
          {
            overflow: b()
          }
        ],
        "overflow-x": [
          {
            "overflow-x": b()
          }
        ],
        "overflow-y": [
          {
            "overflow-y": b()
          }
        ],
        overscroll: [
          {
            overscroll: w()
          }
        ],
        "overscroll-x": [
          {
            "overscroll-x": w()
          }
        ],
        "overscroll-y": [
          {
            "overscroll-y": w()
          }
        ],
        position: [
          "static",
          "fixed",
          "absolute",
          "relative",
          "sticky"
        ],
        inset: [
          {
            inset: _()
          }
        ],
        "inset-x": [
          {
            "inset-x": _()
          }
        ],
        "inset-y": [
          {
            "inset-y": _()
          }
        ],
        start: [
          {
            start: _()
          }
        ],
        end: [
          {
            end: _()
          }
        ],
        top: [
          {
            top: _()
          }
        ],
        right: [
          {
            right: _()
          }
        ],
        bottom: [
          {
            bottom: _()
          }
        ],
        left: [
          {
            left: _()
          }
        ],
        visibility: [
          "visible",
          "invisible",
          "collapse"
        ],
        z: [
          {
            z: [
              fh,
              "auto",
              qe,
              Ye
            ]
          }
        ],
        basis: [
          {
            basis: [
              Jp,
              "full",
              "auto",
              qe,
              Ye,
              o,
              l
            ]
          }
        ],
        "flex-direction": [
          {
            flex: [
              "row",
              "row-reverse",
              "col",
              "col-reverse"
            ]
          }
        ],
        "flex-wrap": [
          {
            flex: [
              "nowrap",
              "wrap",
              "wrap-reverse"
            ]
          }
        ],
        flex: [
          {
            flex: [
              tn,
              Jp,
              "auto",
              "initial",
              "none",
              Ye
            ]
          }
        ],
        grow: [
          {
            grow: [
              "",
              tn,
              qe,
              Ye
            ]
          }
        ],
        shrink: [
          {
            shrink: [
              "",
              tn,
              qe,
              Ye
            ]
          }
        ],
        order: [
          {
            order: [
              fh,
              "first",
              "last",
              "none",
              qe,
              Ye
            ]
          }
        ],
        "grid-cols": [
          {
            "grid-cols": S()
          }
        ],
        "col-start-end": [
          {
            col: I()
          }
        ],
        "col-start": [
          {
            "col-start": C()
          }
        ],
        "col-end": [
          {
            "col-end": C()
          }
        ],
        "grid-rows": [
          {
            "grid-rows": S()
          }
        ],
        "row-start-end": [
          {
            row: I()
          }
        ],
        "row-start": [
          {
            "row-start": C()
          }
        ],
        "row-end": [
          {
            "row-end": C()
          }
        ],
        "grid-flow": [
          {
            "grid-flow": [
              "row",
              "col",
              "dense",
              "row-dense",
              "col-dense"
            ]
          }
        ],
        "auto-cols": [
          {
            "auto-cols": T()
          }
        ],
        "auto-rows": [
          {
            "auto-rows": T()
          }
        ],
        gap: [
          {
            gap: k()
          }
        ],
        "gap-x": [
          {
            "gap-x": k()
          }
        ],
        "gap-y": [
          {
            "gap-y": k()
          }
        ],
        "justify-content": [
          {
            justify: [
              ...D(),
              "normal"
            ]
          }
        ],
        "justify-items": [
          {
            "justify-items": [
              ...R(),
              "normal"
            ]
          }
        ],
        "justify-self": [
          {
            "justify-self": [
              "auto",
              ...R()
            ]
          }
        ],
        "align-content": [
          {
            content: [
              "normal",
              ...D()
            ]
          }
        ],
        "align-items": [
          {
            items: [
              ...R(),
              "baseline"
            ]
          }
        ],
        "align-self": [
          {
            self: [
              "auto",
              ...R(),
              "baseline"
            ]
          }
        ],
        "place-content": [
          {
            "place-content": D()
          }
        ],
        "place-items": [
          {
            "place-items": [
              ...R(),
              "baseline"
            ]
          }
        ],
        "place-self": [
          {
            "place-self": [
              "auto",
              ...R()
            ]
          }
        ],
        p: [
          {
            p: E()
          }
        ],
        px: [
          {
            px: E()
          }
        ],
        py: [
          {
            py: E()
          }
        ],
        ps: [
          {
            ps: E()
          }
        ],
        pe: [
          {
            pe: E()
          }
        ],
        pt: [
          {
            pt: E()
          }
        ],
        pr: [
          {
            pr: E()
          }
        ],
        pb: [
          {
            pb: E()
          }
        ],
        pl: [
          {
            pl: E()
          }
        ],
        m: [
          {
            m: A()
          }
        ],
        mx: [
          {
            mx: A()
          }
        ],
        my: [
          {
            my: A()
          }
        ],
        ms: [
          {
            ms: A()
          }
        ],
        me: [
          {
            me: A()
          }
        ],
        mt: [
          {
            mt: A()
          }
        ],
        mr: [
          {
            mr: A()
          }
        ],
        mb: [
          {
            mb: A()
          }
        ],
        ml: [
          {
            ml: A()
          }
        ],
        "space-x": [
          {
            "space-x": N()
          }
        ],
        "space-x-reverse": [
          "space-x-reverse"
        ],
        "space-y": [
          {
            "space-y": N()
          }
        ],
        "space-y-reverse": [
          "space-y-reverse"
        ],
        size: [
          {
            size: M()
          }
        ],
        w: [
          {
            w: [
              o,
              "screen",
              ...M()
            ]
          }
        ],
        "min-w": [
          {
            "min-w": [
              o,
              "screen",
              "none",
              ...M()
            ]
          }
        ],
        "max-w": [
          {
            "max-w": [
              o,
              "screen",
              "none",
              "prose",
              {
                screen: [
                  s
                ]
              },
              ...M()
            ]
          }
        ],
        h: [
          {
            h: [
              "screen",
              ...M()
            ]
          }
        ],
        "min-h": [
          {
            "min-h": [
              "screen",
              "none",
              ...M()
            ]
          }
        ],
        "max-h": [
          {
            "max-h": [
              "screen",
              ...M()
            ]
          }
        ],
        "font-size": [
          {
            text: [
              "base",
              t,
              Ww,
              ph
            ]
          }
        ],
        "font-smoothing": [
          "antialiased",
          "subpixel-antialiased"
        ],
        "font-style": [
          "italic",
          "not-italic"
        ],
        "font-weight": [
          {
            font: [
              r,
              qe,
              nD
            ]
          }
        ],
        "font-stretch": [
          {
            "font-stretch": [
              "ultra-condensed",
              "extra-condensed",
              "condensed",
              "semi-condensed",
              "normal",
              "semi-expanded",
              "expanded",
              "extra-expanded",
              "ultra-expanded",
              n6,
              Ye
            ]
          }
        ],
        "font-family": [
          {
            font: [
              Nyt,
              Ye,
              e
            ]
          }
        ],
        "fvn-normal": [
          "normal-nums"
        ],
        "fvn-ordinal": [
          "ordinal"
        ],
        "fvn-slashed-zero": [
          "slashed-zero"
        ],
        "fvn-figure": [
          "lining-nums",
          "oldstyle-nums"
        ],
        "fvn-spacing": [
          "proportional-nums",
          "tabular-nums"
        ],
        "fvn-fraction": [
          "diagonal-fractions",
          "stacked-fractions"
        ],
        tracking: [
          {
            tracking: [
              i,
              qe,
              Ye
            ]
          }
        ],
        "line-clamp": [
          {
            "line-clamp": [
              tn,
              "none",
              qe,
              nD
            ]
          }
        ],
        leading: [
          {
            leading: [
              qe,
              Ye,
              a,
              l
            ]
          }
        ],
        "list-image": [
          {
            "list-image": [
              "none",
              qe,
              Ye
            ]
          }
        ],
        "list-style-position": [
          {
            list: [
              "inside",
              "outside"
            ]
          }
        ],
        "list-style-type": [
          {
            list: [
              "disc",
              "decimal",
              "none",
              qe,
              Ye
            ]
          }
        ],
        "text-alignment": [
          {
            text: [
              "left",
              "center",
              "right",
              "justify",
              "start",
              "end"
            ]
          }
        ],
        "placeholder-color": [
          {
            placeholder: $()
          }
        ],
        "text-color": [
          {
            text: $()
          }
        ],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline"
        ],
        "text-decoration-style": [
          {
            decoration: [
              ...z(),
              "wavy"
            ]
          }
        ],
        "text-decoration-thickness": [
          {
            decoration: [
              tn,
              "from-font",
              "auto",
              qe,
              ph
            ]
          }
        ],
        "text-decoration-color": [
          {
            decoration: $()
          }
        ],
        "underline-offset": [
          {
            "underline-offset": [
              tn,
              "auto",
              qe,
              Ye
            ]
          }
        ],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case"
        ],
        "text-overflow": [
          "truncate",
          "text-ellipsis",
          "text-clip"
        ],
        "text-wrap": [
          {
            text: [
              "wrap",
              "nowrap",
              "balance",
              "pretty"
            ]
          }
        ],
        indent: [
          {
            indent: [
              "px",
              ...N()
            ]
          }
        ],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              qe,
              Ye
            ]
          }
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces"
            ]
          }
        ],
        break: [
          {
            break: [
              "normal",
              "words",
              "all",
              "keep"
            ]
          }
        ],
        hyphens: [
          {
            hyphens: [
              "none",
              "manual",
              "auto"
            ]
          }
        ],
        content: [
          {
            content: [
              "none",
              qe,
              Ye
            ]
          }
        ],
        "bg-attachment": [
          {
            bg: [
              "fixed",
              "local",
              "scroll"
            ]
          }
        ],
        "bg-clip": [
          {
            "bg-clip": [
              "border",
              "padding",
              "content",
              "text"
            ]
          }
        ],
        "bg-origin": [
          {
            "bg-origin": [
              "border",
              "padding",
              "content"
            ]
          }
        ],
        "bg-position": [
          {
            bg: [
              ...x(),
              Eyt,
              Dyt
            ]
          }
        ],
        "bg-repeat": [
          {
            bg: [
              "no-repeat",
              {
                repeat: [
                  "",
                  "x",
                  "y",
                  "space",
                  "round"
                ]
              }
            ]
          }
        ],
        "bg-size": [
          {
            bg: [
              "auto",
              "cover",
              "contain",
              Myt,
              Ayt
            ]
          }
        ],
        "bg-image": [
          {
            bg: [
              "none",
              {
                linear: [
                  {
                    to: [
                      "t",
                      "tr",
                      "r",
                      "br",
                      "b",
                      "bl",
                      "l",
                      "tl"
                    ]
                  },
                  fh,
                  qe,
                  Ye
                ],
                radial: [
                  "",
                  qe,
                  Ye
                ],
                conic: [
                  fh,
                  qe,
                  Ye
                ]
              },
              Pyt,
              Ryt
            ]
          }
        ],
        "bg-color": [
          {
            bg: $()
          }
        ],
        "gradient-from-pos": [
          {
            from: L()
          }
        ],
        "gradient-via-pos": [
          {
            via: L()
          }
        ],
        "gradient-to-pos": [
          {
            to: L()
          }
        ],
        "gradient-from": [
          {
            from: $()
          }
        ],
        "gradient-via": [
          {
            via: $()
          }
        ],
        "gradient-to": [
          {
            to: $()
          }
        ],
        rounded: [
          {
            rounded: F()
          }
        ],
        "rounded-s": [
          {
            "rounded-s": F()
          }
        ],
        "rounded-e": [
          {
            "rounded-e": F()
          }
        ],
        "rounded-t": [
          {
            "rounded-t": F()
          }
        ],
        "rounded-r": [
          {
            "rounded-r": F()
          }
        ],
        "rounded-b": [
          {
            "rounded-b": F()
          }
        ],
        "rounded-l": [
          {
            "rounded-l": F()
          }
        ],
        "rounded-ss": [
          {
            "rounded-ss": F()
          }
        ],
        "rounded-se": [
          {
            "rounded-se": F()
          }
        ],
        "rounded-ee": [
          {
            "rounded-ee": F()
          }
        ],
        "rounded-es": [
          {
            "rounded-es": F()
          }
        ],
        "rounded-tl": [
          {
            "rounded-tl": F()
          }
        ],
        "rounded-tr": [
          {
            "rounded-tr": F()
          }
        ],
        "rounded-br": [
          {
            "rounded-br": F()
          }
        ],
        "rounded-bl": [
          {
            "rounded-bl": F()
          }
        ],
        "border-w": [
          {
            border: O()
          }
        ],
        "border-w-x": [
          {
            "border-x": O()
          }
        ],
        "border-w-y": [
          {
            "border-y": O()
          }
        ],
        "border-w-s": [
          {
            "border-s": O()
          }
        ],
        "border-w-e": [
          {
            "border-e": O()
          }
        ],
        "border-w-t": [
          {
            "border-t": O()
          }
        ],
        "border-w-r": [
          {
            "border-r": O()
          }
        ],
        "border-w-b": [
          {
            "border-b": O()
          }
        ],
        "border-w-l": [
          {
            "border-l": O()
          }
        ],
        "divide-x": [
          {
            "divide-x": O()
          }
        ],
        "divide-x-reverse": [
          "divide-x-reverse"
        ],
        "divide-y": [
          {
            "divide-y": O()
          }
        ],
        "divide-y-reverse": [
          "divide-y-reverse"
        ],
        "border-style": [
          {
            border: [
              ...z(),
              "hidden",
              "none"
            ]
          }
        ],
        "divide-style": [
          {
            divide: [
              ...z(),
              "hidden",
              "none"
            ]
          }
        ],
        "border-color": [
          {
            border: $()
          }
        ],
        "border-color-x": [
          {
            "border-x": $()
          }
        ],
        "border-color-y": [
          {
            "border-y": $()
          }
        ],
        "border-color-s": [
          {
            "border-s": $()
          }
        ],
        "border-color-e": [
          {
            "border-e": $()
          }
        ],
        "border-color-t": [
          {
            "border-t": $()
          }
        ],
        "border-color-r": [
          {
            "border-r": $()
          }
        ],
        "border-color-b": [
          {
            "border-b": $()
          }
        ],
        "border-color-l": [
          {
            "border-l": $()
          }
        ],
        "divide-color": [
          {
            divide: $()
          }
        ],
        "outline-style": [
          {
            outline: [
              ...z(),
              "none",
              "hidden"
            ]
          }
        ],
        "outline-offset": [
          {
            "outline-offset": [
              tn,
              qe,
              Ye
            ]
          }
        ],
        "outline-w": [
          {
            outline: [
              "",
              tn,
              Ww,
              ph
            ]
          }
        ],
        "outline-color": [
          {
            outline: [
              n
            ]
          }
        ],
        shadow: [
          {
            shadow: [
              "",
              "none",
              c,
              Lyt,
              $yt
            ]
          }
        ],
        "shadow-color": [
          {
            shadow: $()
          }
        ],
        "inset-shadow": [
          {
            "inset-shadow": [
              "none",
              qe,
              Ye,
              h
            ]
          }
        ],
        "inset-shadow-color": [
          {
            "inset-shadow": $()
          }
        ],
        "ring-w": [
          {
            ring: O()
          }
        ],
        "ring-w-inset": [
          "ring-inset"
        ],
        "ring-color": [
          {
            ring: $()
          }
        ],
        "ring-offset-w": [
          {
            "ring-offset": [
              tn,
              ph
            ]
          }
        ],
        "ring-offset-color": [
          {
            "ring-offset": $()
          }
        ],
        "inset-ring-w": [
          {
            "inset-ring": O()
          }
        ],
        "inset-ring-color": [
          {
            "inset-ring": $()
          }
        ],
        opacity: [
          {
            opacity: [
              tn,
              qe,
              Ye
            ]
          }
        ],
        "mix-blend": [
          {
            "mix-blend": [
              ...V(),
              "plus-darker",
              "plus-lighter"
            ]
          }
        ],
        "bg-blend": [
          {
            "bg-blend": V()
          }
        ],
        filter: [
          {
            filter: [
              "",
              "none",
              qe,
              Ye
            ]
          }
        ],
        blur: [
          {
            blur: H()
          }
        ],
        brightness: [
          {
            brightness: [
              tn,
              qe,
              Ye
            ]
          }
        ],
        contrast: [
          {
            contrast: [
              tn,
              qe,
              Ye
            ]
          }
        ],
        "drop-shadow": [
          {
            "drop-shadow": [
              "",
              "none",
              d,
              qe,
              Ye
            ]
          }
        ],
        grayscale: [
          {
            grayscale: [
              "",
              tn,
              qe,
              Ye
            ]
          }
        ],
        "hue-rotate": [
          {
            "hue-rotate": [
              tn,
              qe,
              Ye
            ]
          }
        ],
        invert: [
          {
            invert: [
              "",
              tn,
              qe,
              Ye
            ]
          }
        ],
        saturate: [
          {
            saturate: [
              tn,
              qe,
              Ye
            ]
          }
        ],
        sepia: [
          {
            sepia: [
              "",
              tn,
              qe,
              Ye
            ]
          }
        ],
        "backdrop-filter": [
          {
            "backdrop-filter": [
              "",
              "none",
              qe,
              Ye
            ]
          }
        ],
        "backdrop-blur": [
          {
            "backdrop-blur": H()
          }
        ],
        "backdrop-brightness": [
          {
            "backdrop-brightness": [
              tn,
              qe,
              Ye
            ]
          }
        ],
        "backdrop-contrast": [
          {
            "backdrop-contrast": [
              tn,
              qe,
              Ye
            ]
          }
        ],
        "backdrop-grayscale": [
          {
            "backdrop-grayscale": [
              "",
              tn,
              qe,
              Ye
            ]
          }
        ],
        "backdrop-hue-rotate": [
          {
            "backdrop-hue-rotate": [
              tn,
              qe,
              Ye
            ]
          }
        ],
        "backdrop-invert": [
          {
            "backdrop-invert": [
              "",
              tn,
              qe,
              Ye
            ]
          }
        ],
        "backdrop-opacity": [
          {
            "backdrop-opacity": [
              tn,
              qe,
              Ye
            ]
          }
        ],
        "backdrop-saturate": [
          {
            "backdrop-saturate": [
              tn,
              qe,
              Ye
            ]
          }
        ],
        "backdrop-sepia": [
          {
            "backdrop-sepia": [
              "",
              tn,
              qe,
              Ye
            ]
          }
        ],
        "border-collapse": [
          {
            border: [
              "collapse",
              "separate"
            ]
          }
        ],
        "border-spacing": [
          {
            "border-spacing": N()
          }
        ],
        "border-spacing-x": [
          {
            "border-spacing-x": N()
          }
        ],
        "border-spacing-y": [
          {
            "border-spacing-y": N()
          }
        ],
        "table-layout": [
          {
            table: [
              "auto",
              "fixed"
            ]
          }
        ],
        caption: [
          {
            caption: [
              "top",
              "bottom"
            ]
          }
        ],
        transition: [
          {
            transition: [
              "",
              "all",
              "colors",
              "opacity",
              "shadow",
              "transform",
              "none",
              qe,
              Ye
            ]
          }
        ],
        "transition-behavior": [
          {
            transition: [
              "normal",
              "discrete"
            ]
          }
        ],
        duration: [
          {
            duration: [
              tn,
              "initial",
              qe,
              Ye
            ]
          }
        ],
        ease: [
          {
            ease: [
              "linear",
              "initial",
              m,
              qe,
              Ye
            ]
          }
        ],
        delay: [
          {
            delay: [
              tn,
              qe,
              Ye
            ]
          }
        ],
        animate: [
          {
            animate: [
              "none",
              v,
              qe,
              Ye
            ]
          }
        ],
        backface: [
          {
            backface: [
              "hidden",
              "visible"
            ]
          }
        ],
        perspective: [
          {
            perspective: [
              p,
              qe,
              Ye
            ]
          }
        ],
        "perspective-origin": [
          {
            "perspective-origin": Y()
          }
        ],
        rotate: [
          {
            rotate: le()
          }
        ],
        "rotate-x": [
          {
            "rotate-x": le()
          }
        ],
        "rotate-y": [
          {
            "rotate-y": le()
          }
        ],
        "rotate-z": [
          {
            "rotate-z": le()
          }
        ],
        scale: [
          {
            scale: ve()
          }
        ],
        "scale-x": [
          {
            "scale-x": ve()
          }
        ],
        "scale-y": [
          {
            "scale-y": ve()
          }
        ],
        "scale-z": [
          {
            "scale-z": ve()
          }
        ],
        "scale-3d": [
          "scale-3d"
        ],
        skew: [
          {
            skew: re()
          }
        ],
        "skew-x": [
          {
            "skew-x": re()
          }
        ],
        "skew-y": [
          {
            "skew-y": re()
          }
        ],
        transform: [
          {
            transform: [
              qe,
              Ye,
              "",
              "none",
              "gpu",
              "cpu"
            ]
          }
        ],
        "transform-origin": [
          {
            origin: Y()
          }
        ],
        "transform-style": [
          {
            transform: [
              "3d",
              "flat"
            ]
          }
        ],
        translate: [
          {
            translate: ae()
          }
        ],
        "translate-x": [
          {
            "translate-x": ae()
          }
        ],
        "translate-y": [
          {
            "translate-y": ae()
          }
        ],
        "translate-z": [
          {
            "translate-z": ae()
          }
        ],
        "translate-none": [
          "translate-none"
        ],
        accent: [
          {
            accent: $()
          }
        ],
        appearance: [
          {
            appearance: [
              "none",
              "auto"
            ]
          }
        ],
        "caret-color": [
          {
            caret: $()
          }
        ],
        "color-scheme": [
          {
            scheme: [
              "normal",
              "dark",
              "light",
              "light-dark",
              "only-dark",
              "only-light"
            ]
          }
        ],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              qe,
              Ye
            ]
          }
        ],
        "field-sizing": [
          {
            "field-sizing": [
              "fixed",
              "content"
            ]
          }
        ],
        "pointer-events": [
          {
            "pointer-events": [
              "auto",
              "none"
            ]
          }
        ],
        resize: [
          {
            resize: [
              "none",
              "",
              "y",
              "x"
            ]
          }
        ],
        "scroll-behavior": [
          {
            scroll: [
              "auto",
              "smooth"
            ]
          }
        ],
        "scroll-m": [
          {
            "scroll-m": N()
          }
        ],
        "scroll-mx": [
          {
            "scroll-mx": N()
          }
        ],
        "scroll-my": [
          {
            "scroll-my": N()
          }
        ],
        "scroll-ms": [
          {
            "scroll-ms": N()
          }
        ],
        "scroll-me": [
          {
            "scroll-me": N()
          }
        ],
        "scroll-mt": [
          {
            "scroll-mt": N()
          }
        ],
        "scroll-mr": [
          {
            "scroll-mr": N()
          }
        ],
        "scroll-mb": [
          {
            "scroll-mb": N()
          }
        ],
        "scroll-ml": [
          {
            "scroll-ml": N()
          }
        ],
        "scroll-p": [
          {
            "scroll-p": N()
          }
        ],
        "scroll-px": [
          {
            "scroll-px": N()
          }
        ],
        "scroll-py": [
          {
            "scroll-py": N()
          }
        ],
        "scroll-ps": [
          {
            "scroll-ps": N()
          }
        ],
        "scroll-pe": [
          {
            "scroll-pe": N()
          }
        ],
        "scroll-pt": [
          {
            "scroll-pt": N()
          }
        ],
        "scroll-pr": [
          {
            "scroll-pr": N()
          }
        ],
        "scroll-pb": [
          {
            "scroll-pb": N()
          }
        ],
        "scroll-pl": [
          {
            "scroll-pl": N()
          }
        ],
        "snap-align": [
          {
            snap: [
              "start",
              "end",
              "center",
              "align-none"
            ]
          }
        ],
        "snap-stop": [
          {
            snap: [
              "normal",
              "always"
            ]
          }
        ],
        "snap-type": [
          {
            snap: [
              "none",
              "x",
              "y",
              "both"
            ]
          }
        ],
        "snap-strictness": [
          {
            snap: [
              "mandatory",
              "proximity"
            ]
          }
        ],
        touch: [
          {
            touch: [
              "auto",
              "none",
              "manipulation"
            ]
          }
        ],
        "touch-x": [
          {
            "touch-pan": [
              "x",
              "left",
              "right"
            ]
          }
        ],
        "touch-y": [
          {
            "touch-pan": [
              "y",
              "up",
              "down"
            ]
          }
        ],
        "touch-pz": [
          "touch-pinch-zoom"
        ],
        select: [
          {
            select: [
              "none",
              "text",
              "all",
              "auto"
            ]
          }
        ],
        "will-change": [
          {
            "will-change": [
              "auto",
              "scroll",
              "contents",
              "transform",
              qe,
              Ye
            ]
          }
        ],
        fill: [
          {
            fill: [
              "none",
              ...$()
            ]
          }
        ],
        "stroke-w": [
          {
            stroke: [
              tn,
              Ww,
              ph,
              nD
            ]
          }
        ],
        stroke: [
          {
            stroke: [
              "none",
              ...$()
            ]
          }
        ],
        "forced-color-adjust": [
          {
            "forced-color-adjust": [
              "auto",
              "none"
            ]
          }
        ]
      },
      conflictingClassGroups: {
        overflow: [
          "overflow-x",
          "overflow-y"
        ],
        overscroll: [
          "overscroll-x",
          "overscroll-y"
        ],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left"
        ],
        "inset-x": [
          "right",
          "left"
        ],
        "inset-y": [
          "top",
          "bottom"
        ],
        flex: [
          "basis",
          "grow",
          "shrink"
        ],
        gap: [
          "gap-x",
          "gap-y"
        ],
        p: [
          "px",
          "py",
          "ps",
          "pe",
          "pt",
          "pr",
          "pb",
          "pl"
        ],
        px: [
          "pr",
          "pl"
        ],
        py: [
          "pt",
          "pb"
        ],
        m: [
          "mx",
          "my",
          "ms",
          "me",
          "mt",
          "mr",
          "mb",
          "ml"
        ],
        mx: [
          "mr",
          "ml"
        ],
        my: [
          "mt",
          "mb"
        ],
        size: [
          "w",
          "h"
        ],
        "font-size": [
          "leading"
        ],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction"
        ],
        "fvn-ordinal": [
          "fvn-normal"
        ],
        "fvn-slashed-zero": [
          "fvn-normal"
        ],
        "fvn-figure": [
          "fvn-normal"
        ],
        "fvn-spacing": [
          "fvn-normal"
        ],
        "fvn-fraction": [
          "fvn-normal"
        ],
        "line-clamp": [
          "display",
          "overflow"
        ],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-s": [
          "rounded-ss",
          "rounded-es"
        ],
        "rounded-e": [
          "rounded-se",
          "rounded-ee"
        ],
        "rounded-t": [
          "rounded-tl",
          "rounded-tr"
        ],
        "rounded-r": [
          "rounded-tr",
          "rounded-br"
        ],
        "rounded-b": [
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-l": [
          "rounded-tl",
          "rounded-bl"
        ],
        "border-spacing": [
          "border-spacing-x",
          "border-spacing-y"
        ],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l"
        ],
        "border-w-x": [
          "border-w-r",
          "border-w-l"
        ],
        "border-w-y": [
          "border-w-t",
          "border-w-b"
        ],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l"
        ],
        "border-color-x": [
          "border-color-r",
          "border-color-l"
        ],
        "border-color-y": [
          "border-color-t",
          "border-color-b"
        ],
        translate: [
          "translate-x",
          "translate-y",
          "translate-none"
        ],
        "translate-none": [
          "translate",
          "translate-x",
          "translate-y",
          "translate-z"
        ],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml"
        ],
        "scroll-mx": [
          "scroll-mr",
          "scroll-ml"
        ],
        "scroll-my": [
          "scroll-mt",
          "scroll-mb"
        ],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl"
        ],
        "scroll-px": [
          "scroll-pr",
          "scroll-pl"
        ],
        "scroll-py": [
          "scroll-pt",
          "scroll-pb"
        ],
        touch: [
          "touch-x",
          "touch-y",
          "touch-pz"
        ],
        "touch-x": [
          "touch"
        ],
        "touch-y": [
          "touch"
        ],
        "touch-pz": [
          "touch"
        ]
      },
      conflictingClassGroupModifiers: {
        "font-size": [
          "leading"
        ]
      },
      orderSensitiveModifiers: [
        "before",
        "after",
        "placeholder",
        "file",
        "marker",
        "selection",
        "first-line",
        "first-letter",
        "backdrop",
        "*",
        "**"
      ]
    };
  }, Gyt = myt(Wyt);
  function bi(...n) {
    return Gyt(bae(n));
  }
  function qb(n, e) {
    const t = typeof n == "string" && !e ? `${n}Context` : e, r = Symbol(t);
    return [
      (i) => {
        const a = f6(r, i);
        if (a || a === null) return a;
        throw new Error(`Injection \`${r.toString()}\` not found. Component must be used within ${Array.isArray(n) ? `one of the following components: ${n.join(", ")}` : `\`${n}\``}`);
      },
      (i) => (Cse(r, i), i)
    ];
  }
  function Dae(n, e, t) {
    const r = t.originalEvent.target, i = new CustomEvent(n, {
      bubbles: false,
      cancelable: true,
      detail: t
    });
    e && r.addEventListener(n, e, {
      once: true
    }), r.dispatchEvent(i);
  }
  function Rae(n) {
    return wse() ? (_se(n), true) : false;
  }
  function Uyt(n) {
    let e = false, t;
    const r = CN(true);
    return (...i) => (e || (t = r.run(() => n(...i)), e = true), t);
  }
  function Hyt(n) {
    let e = 0, t, r;
    const i = () => {
      e -= 1, r && e <= 0 && (r.stop(), t = void 0, r = void 0);
    };
    return (...a) => (e += 1, t || (r = CN(true), t = r.run(() => n(...a))), Rae(i), t);
  }
  function f3(n) {
    return typeof n == "function" ? n() : J(n);
  }
  const xp = typeof window < "u" && typeof document < "u";
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const Xyt = (n) => typeof n < "u", Yyt = Object.prototype.toString, qyt = (n) => Yyt.call(n) === "[object Object]", jyt = () => {
  }, r6 = Kyt();
  function Kyt() {
    var n, e;
    return xp && ((n = window == null ? void 0 : window.navigator) == null ? void 0 : n.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
  }
  function Zyt(n) {
    return Ha();
  }
  function Qyt(n, e) {
    Zyt() && bse(n, e);
  }
  function jb(n) {
    var e;
    const t = f3(n);
    return (e = t == null ? void 0 : t.$el) != null ? e : t;
  }
  const p3 = xp ? window : void 0;
  function $ae(...n) {
    let e, t, r, i;
    if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([t, r, i] = n, e = p3) : [e, t, r, i] = n, !e) return jyt;
    Array.isArray(t) || (t = [
      t
    ]), Array.isArray(r) || (r = [
      r
    ]);
    const a = [], s = () => {
      a.forEach((c) => c()), a.length = 0;
    }, o = (c, h, d, f) => (c.addEventListener(h, d, f), () => c.removeEventListener(h, d, f)), l = $i(() => [
      jb(e),
      f3(i)
    ], ([c, h]) => {
      if (s(), !c) return;
      const d = qyt(h) ? {
        ...h
      } : h;
      a.push(...t.flatMap((f) => r.map((p) => o(c, f, p, d))));
    }, {
      immediate: true,
      flush: "post"
    }), u = () => {
      l(), s();
    };
    return Rae(u), u;
  }
  function Jyt(n) {
    return typeof n == "function" ? n : typeof n == "string" ? (e) => e.key === n : Array.isArray(n) ? (e) => n.includes(e.key) : () => true;
  }
  function e0t(...n) {
    let e, t, r = {};
    n.length === 3 ? (e = n[0], t = n[1], r = n[2]) : n.length === 2 ? typeof n[1] == "object" ? (e = true, t = n[0], r = n[1]) : (e = n[0], t = n[1]) : (e = true, t = n[0]);
    const { target: i = p3, eventName: a = "keydown", passive: s = false, dedupe: o = false } = r, l = Jyt(e);
    return $ae(i, a, (u) => {
      u.repeat && f3(o) || l(u) && t(u);
    }, s);
  }
  function t0t() {
    const n = Tt(false), e = Ha();
    return e && cm(() => {
      n.value = true;
    }, e), n;
  }
  function n0t(n) {
    return JSON.parse(JSON.stringify(n));
  }
  function g3(n, e, t, r = {}) {
    var i, a, s;
    const { clone: o = false, passive: l = false, eventName: u, deep: c = false, defaultValue: h, shouldEmit: d } = r, f = Ha(), p = t || (f == null ? void 0 : f.emit) || ((i = f == null ? void 0 : f.$emit) == null ? void 0 : i.bind(f)) || ((s = (a = f == null ? void 0 : f.proxy) == null ? void 0 : a.$emit) == null ? void 0 : s.bind(f == null ? void 0 : f.proxy));
    let g = u;
    e || (e = "modelValue"), g = g || `update:${e.toString()}`;
    const m = (x) => o ? typeof o == "function" ? o(x) : n0t(x) : x, v = () => Xyt(n[e]) ? m(n[e]) : h, y = (x) => {
      d ? d(x) && p(g, x) : p(g, x);
    };
    if (l) {
      const x = v(), b = Tt(x);
      let w = false;
      return $i(() => n[e], (_) => {
        w || (w = true, b.value = m(_), nu(() => w = false));
      }), $i(b, (_) => {
        !w && (_ !== n[e] || c) && y(_);
      }, {
        deep: c
      }), b;
    } else return Zt({
      get() {
        return v();
      },
      set(x) {
        y(x);
      }
    });
  }
  function m3(n) {
    return n ? n.flatMap((e) => e.type === _0 ? m3(e.children) : [
      e
    ]) : [];
  }
  function Zo() {
    let n = document.activeElement;
    if (n == null) return null;
    for (; n != null && n.shadowRoot != null && n.shadowRoot.activeElement != null; ) n = n.shadowRoot.activeElement;
    return n;
  }
  function rD(n) {
    if (n === null || typeof n != "object") return false;
    const e = Object.getPrototypeOf(n);
    return e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.iterator in n ? false : Symbol.toStringTag in n ? Object.prototype.toString.call(n) === "[object Module]" : true;
  }
  function SN(n, e, t = ".", r) {
    if (!rD(e)) return SN(n, {}, t);
    const i = Object.assign({}, e);
    for (const a in n) {
      if (a === "__proto__" || a === "constructor") continue;
      const s = n[a];
      s != null && (Array.isArray(s) && Array.isArray(i[a]) ? i[a] = [
        ...s,
        ...i[a]
      ] : rD(s) && rD(i[a]) ? i[a] = SN(s, i[a], (t ? `${t}.` : "") + a.toString()) : i[a] = s);
    }
    return i;
  }
  function r0t(n) {
    return (...e) => e.reduce((t, r) => SN(t, r, ""), {});
  }
  const i0t = r0t(), [v3, rwt] = qb("ConfigProvider");
  let a0t = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", s0t = (n = 21) => {
    let e = "", t = n;
    for (; t--; ) e += a0t[Math.random() * 64 | 0];
    return e;
  };
  const o0t = Hyt(() => {
    const n = Tt(/* @__PURE__ */ new Map()), e = Tt(), t = Zt(() => {
      for (const s of n.value.values()) if (s) return true;
      return false;
    }), r = v3({
      scrollBody: Tt(true)
    });
    let i = null;
    const a = () => {
      document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = e.value ?? "", r6 && (i == null ? void 0 : i()), e.value = void 0;
    };
    return $i(t, (s, o) => {
      var l;
      if (!xp) return;
      if (!s) {
        o && a();
        return;
      }
      e.value === void 0 && (e.value = document.body.style.overflow);
      const u = window.innerWidth - document.documentElement.clientWidth, c = {
        padding: u,
        margin: 0
      }, h = (l = r.scrollBody) != null && l.value ? typeof r.scrollBody.value == "object" ? i0t({
        padding: r.scrollBody.value.padding === true ? u : r.scrollBody.value.padding,
        margin: r.scrollBody.value.margin === true ? u : r.scrollBody.value.margin
      }, c) : c : {
        padding: 0,
        margin: 0
      };
      u > 0 && (document.body.style.paddingRight = typeof h.padding == "number" ? `${h.padding}px` : String(h.padding), document.body.style.marginRight = typeof h.margin == "number" ? `${h.margin}px` : String(h.margin), document.body.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), r6 && (i = $ae(document, "touchmove", (d) => u0t(d), {
        passive: false
      })), nu(() => {
        document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
      });
    }, {
      immediate: true,
      flush: "sync"
    }), n;
  });
  function l0t(n) {
    const e = s0t(6), t = o0t();
    t.value.set(e, n);
    const r = Zt({
      get: () => t.value.get(e) ?? false,
      set: (i) => t.value.set(e, i)
    });
    return Qyt(() => {
      t.value.delete(e);
    }), r;
  }
  function Nae(n) {
    const e = window.getComputedStyle(n);
    if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && n.clientWidth < n.scrollWidth || e.overflowY === "auto" && n.clientHeight < n.scrollHeight) return true;
    {
      const t = n.parentNode;
      return !t || t.tagName === "BODY" ? false : Nae(t);
    }
  }
  function u0t(n) {
    const e = n || window.event, t = e.target;
    return t instanceof Element && Nae(t) ? false : e.touches.length > 1 ? true : (e.preventDefault && e.cancelable && e.preventDefault(), false);
  }
  function Eae(n) {
    const e = v3({
      dir: Tt("ltr")
    });
    return Zt(() => {
      var t;
      return (n == null ? void 0 : n.value) || ((t = e.dir) == null ? void 0 : t.value) || "ltr";
    });
  }
  function w2(n) {
    const e = Ha(), t = e == null ? void 0 : e.type.emits, r = {};
    return t != null && t.length || console.warn(`No emitted event found. Please check component: ${e == null ? void 0 : e.type.__name}`), t == null ? void 0 : t.forEach((i) => {
      r[gse(p6(i))] = (...a) => n(i, ...a);
    }), r;
  }
  function y3(n) {
    const e = Ha(), t = Object.keys((e == null ? void 0 : e.type.props) ?? {}).reduce((i, a) => {
      const s = (e == null ? void 0 : e.type.props[a]).default;
      return s !== void 0 && (i[a] = s), i;
    }, {}), r = pse(n);
    return Zt(() => {
      const i = {}, a = (e == null ? void 0 : e.vnode.props) ?? {};
      return Object.keys(a).forEach((s) => {
        i[p6(s)] = a[s];
      }), Object.keys({
        ...t,
        ...i
      }).reduce((s, o) => (r.value[o] !== void 0 && (s[o] = r.value[o]), s), {});
    });
  }
  function x3(n, e) {
    const t = y3(n), r = e ? w2(e) : {};
    return Zt(() => ({
      ...t.value,
      ...r
    }));
  }
  function $a() {
    const n = Ha(), e = Tt(), t = Zt(() => {
      var s, o;
      return [
        "#text",
        "#comment"
      ].includes((s = e.value) == null ? void 0 : s.$el.nodeName) ? (o = e.value) == null ? void 0 : o.$el.nextElementSibling : jb(e);
    }), r = Object.assign({}, n.exposed), i = {};
    for (const s in n.props) Object.defineProperty(i, s, {
      enumerable: true,
      configurable: true,
      get: () => n.props[s]
    });
    if (Object.keys(r).length > 0) for (const s in r) Object.defineProperty(i, s, {
      enumerable: true,
      configurable: true,
      get: () => r[s]
    });
    Object.defineProperty(i, "$el", {
      enumerable: true,
      configurable: true,
      get: () => n.vnode.el
    }), n.exposed = i;
    function a(s) {
      e.value = s, !(s instanceof Element || !s) && (Object.defineProperty(i, "$el", {
        enumerable: true,
        configurable: true,
        get: () => s.$el
      }), n.exposed = i);
    }
    return {
      forwardRef: a,
      currentRef: e,
      currentElement: t
    };
  }
  var c0t = function(n) {
    if (typeof document > "u") return null;
    var e = Array.isArray(n) ? n[0] : n;
    return e.ownerDocument.body;
  }, eg = /* @__PURE__ */ new WeakMap(), Gw = /* @__PURE__ */ new WeakMap(), Uw = {}, iD = 0, Mae = function(n) {
    return n && (n.host || Mae(n.parentNode));
  }, h0t = function(n, e) {
    return e.map(function(t) {
      if (n.contains(t)) return t;
      var r = Mae(t);
      return r && n.contains(r) ? r : (console.error("aria-hidden", t, "in not contained inside", n, ". Doing nothing"), null);
    }).filter(function(t) {
      return !!t;
    });
  }, d0t = function(n, e, t, r) {
    var i = h0t(e, Array.isArray(n) ? n : [
      n
    ]);
    Uw[t] || (Uw[t] = /* @__PURE__ */ new WeakMap());
    var a = Uw[t], s = [], o = /* @__PURE__ */ new Set(), l = new Set(i), u = function(h) {
      !h || o.has(h) || (o.add(h), u(h.parentNode));
    };
    i.forEach(u);
    var c = function(h) {
      !h || l.has(h) || Array.prototype.forEach.call(h.children, function(d) {
        if (o.has(d)) c(d);
        else try {
          var f = d.getAttribute(r), p = f !== null && f !== "false", g = (eg.get(d) || 0) + 1, m = (a.get(d) || 0) + 1;
          eg.set(d, g), a.set(d, m), s.push(d), g === 1 && p && Gw.set(d, true), m === 1 && d.setAttribute(t, "true"), p || d.setAttribute(r, "true");
        } catch (v) {
          console.error("aria-hidden: cannot operate on ", d, v);
        }
      });
    };
    return c(e), o.clear(), iD++, function() {
      s.forEach(function(h) {
        var d = eg.get(h) - 1, f = a.get(h) - 1;
        eg.set(h, d), a.set(h, f), d || (Gw.has(h) || h.removeAttribute(r), Gw.delete(h)), f || h.removeAttribute(t);
      }), iD--, iD || (eg = /* @__PURE__ */ new WeakMap(), eg = /* @__PURE__ */ new WeakMap(), Gw = /* @__PURE__ */ new WeakMap(), Uw = {});
    };
  }, f0t = function(n, e, t) {
    t === void 0 && (t = "data-aria-hidden");
    var r = Array.from(Array.isArray(n) ? n : [
      n
    ]), i = c0t(n);
    return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), d0t(r, i, t, "aria-hidden")) : function() {
      return null;
    };
  };
  function p0t(n) {
    let e;
    $i(() => jb(n), (t) => {
      t ? e = f0t(t) : e && e();
    }), lC(() => {
      e && e();
    });
  }
  let g0t = 0;
  function oC(n, e = "radix") {
    const t = v3({
      useId: void 0
    });
    return O3 ? `${e}-${O3()}` : t.useId ? `${e}-${t.useId()}` : `${e}-${++g0t}`;
  }
  function m0t(n, e) {
    const t = Tt(n);
    function r(i) {
      return e[t.value][i] ?? t.value;
    }
    return {
      state: t,
      dispatch: (i) => {
        t.value = r(i);
      }
    };
  }
  const b3 = Rt({
    name: "PrimitiveSlot",
    inheritAttrs: false,
    setup(n, { attrs: e, slots: t }) {
      return () => {
        var r, i;
        if (!t.default) return null;
        const a = m3(t.default()), s = a.findIndex((c) => c.type !== mse);
        if (s === -1) return a;
        const o = a[s];
        (r = o.props) == null || delete r.ref;
        const l = o.props ? Ca(e, o.props) : e;
        e.class && (i = o.props) != null && i.class && delete o.props.class;
        const u = vse(o, l);
        for (const c in l) c.startsWith("on") && (u.props || (u.props = {}), u.props[c] = l[c]);
        return a.length === 1 ? u : (a[s] = u, a);
      };
    }
  }), Ns = Rt({
    name: "Primitive",
    inheritAttrs: false,
    props: {
      asChild: {
        type: Boolean,
        default: false
      },
      as: {
        type: [
          String,
          Object
        ],
        default: "div"
      }
    },
    setup(n, { attrs: e, slots: t }) {
      const r = n.asChild ? "template" : n.as;
      return typeof r == "string" && [
        "area",
        "img",
        "input"
      ].includes(r) ? () => js(r, e) : r !== "template" ? () => js(n.as, e, {
        default: t.default
      }) : () => js(b3, e, {
        default: t.default
      });
    }
  });
  function Pae() {
    const n = Tt(), e = Zt(() => {
      var t, r;
      return [
        "#text",
        "#comment"
      ].includes((t = n.value) == null ? void 0 : t.$el.nodeName) ? (r = n.value) == null ? void 0 : r.$el.nextElementSibling : jb(n);
    });
    return {
      primitiveElement: n,
      currentElement: e
    };
  }
  function v0t(n, e) {
    var t;
    const r = Tt({}), i = Tt("none"), a = Tt(n), s = n.value ? "mounted" : "unmounted";
    let o;
    const l = ((t = e.value) == null ? void 0 : t.ownerDocument.defaultView) ?? p3, { state: u, dispatch: c } = m0t(s, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    }), h = (m) => {
      var v;
      if (xp) {
        const y = new CustomEvent(m, {
          bubbles: false,
          cancelable: false
        });
        (v = e.value) == null || v.dispatchEvent(y);
      }
    };
    $i(n, async (m, v) => {
      var y;
      const x = v !== m;
      if (await nu(), x) {
        const b = i.value, w = Hw(e.value);
        m ? (c("MOUNT"), h("enter"), w === "none" && h("after-enter")) : w === "none" || ((y = r.value) == null ? void 0 : y.display) === "none" ? (c("UNMOUNT"), h("leave"), h("after-leave")) : v && b !== w ? (c("ANIMATION_OUT"), h("leave")) : (c("UNMOUNT"), h("after-leave"));
      }
    }, {
      immediate: true
    });
    const d = (m) => {
      const v = Hw(e.value), y = v.includes(m.animationName), x = u.value === "mounted" ? "enter" : "leave";
      if (m.target === e.value && y && (h(`after-${x}`), c("ANIMATION_END"), !a.value)) {
        const b = e.value.style.animationFillMode;
        e.value.style.animationFillMode = "forwards", o = l == null ? void 0 : l.setTimeout(() => {
          var w;
          ((w = e.value) == null ? void 0 : w.style.animationFillMode) === "forwards" && (e.value.style.animationFillMode = b);
        });
      }
      m.target === e.value && v === "none" && c("ANIMATION_END");
    }, f = (m) => {
      m.target === e.value && (i.value = Hw(e.value));
    }, p = $i(e, (m, v) => {
      m ? (r.value = getComputedStyle(m), m.addEventListener("animationstart", f), m.addEventListener("animationcancel", d), m.addEventListener("animationend", d)) : (c("ANIMATION_END"), o !== void 0 && (l == null ? void 0 : l.clearTimeout(o)), v == null ? void 0 : v.removeEventListener("animationstart", f), v == null ? void 0 : v.removeEventListener("animationcancel", d), v == null ? void 0 : v.removeEventListener("animationend", d));
    }, {
      immediate: true
    }), g = $i(u, () => {
      const m = Hw(e.value);
      i.value = u.value === "mounted" ? m : "none";
    });
    return lC(() => {
      p(), g();
    }), {
      isPresent: Zt(() => [
        "mounted",
        "unmountSuspended"
      ].includes(u.value))
    };
  }
  function Hw(n) {
    return n && getComputedStyle(n).animationName || "none";
  }
  const w3 = Rt({
    name: "Presence",
    props: {
      present: {
        type: Boolean,
        required: true
      },
      forceMount: {
        type: Boolean
      }
    },
    slots: {},
    setup(n, { slots: e, expose: t }) {
      var r;
      const { present: i, forceMount: a } = Ax(n), s = Tt(), { isPresent: o } = v0t(i, s);
      t({
        present: o
      });
      let l = e.default({
        present: o
      });
      l = m3(l || []);
      const u = Ha();
      if (l && (l == null ? void 0 : l.length) > 1) {
        const c = (r = u == null ? void 0 : u.parent) != null && r.type.name ? `<${u.parent.type.name} />` : "component";
        throw new Error([
          `Detected an invalid children for \`${c}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((h) => `  - ${h}`).join(`
`)
        ].join(`
`));
      }
      return () => a.value || i.value || o.value ? js(e.default({
        present: o
      })[0], {
        ref: (c) => {
          const h = jb(c);
          return typeof (h == null ? void 0 : h.hasAttribute) > "u" || (h != null && h.hasAttribute("data-radix-popper-content-wrapper") ? s.value = h.firstElementChild : s.value = h), h;
        }
      }) : null;
    }
  }), [Lc, y0t] = qb("DialogRoot"), x0t = Rt({
    inheritAttrs: false,
    __name: "DialogRoot",
    props: {
      open: {
        type: Boolean,
        default: void 0
      },
      defaultOpen: {
        type: Boolean,
        default: false
      },
      modal: {
        type: Boolean,
        default: true
      }
    },
    emits: [
      "update:open"
    ],
    setup(n, { emit: e }) {
      const t = n, r = g3(t, "open", e, {
        defaultValue: t.defaultOpen,
        passive: t.open === void 0
      }), i = Tt(), a = Tt(), { modal: s } = Ax(t);
      return y0t({
        open: r,
        modal: s,
        openModal: () => {
          r.value = true;
        },
        onOpenChange: (o) => {
          r.value = o;
        },
        onOpenToggle: () => {
          r.value = !r.value;
        },
        contentId: "",
        titleId: "",
        descriptionId: "",
        triggerElement: i,
        contentElement: a
      }), (o, l) => Qt(o.$slots, "default", {
        open: J(r)
      });
    }
  }), b0t = Rt({
    __name: "Teleport",
    props: {
      to: {
        default: "body"
      },
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(n) {
      const e = t0t();
      return (t, r) => J(e) || t.forceMount ? ($t(), kn(xse, {
        key: 0,
        to: t.to,
        disabled: t.disabled
      }, [
        Qt(t.$slots, "default")
      ], 8, [
        "to",
        "disabled"
      ])) : S0("", true);
    }
  }), w0t = Rt({
    __name: "DialogPortal",
    props: {
      to: {},
      disabled: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), kn(J(b0t), IN(kN(e)), {
        default: He(() => [
          Qt(t.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), _0t = "dismissableLayer.pointerDownOutside", S0t = "dismissableLayer.focusOutside";
  function Lae(n, e) {
    const t = e.closest("[data-dismissable-layer]"), r = n.dataset.dismissableLayer === "" ? n : n.querySelector("[data-dismissable-layer]"), i = Array.from(n.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
    return !!(t && r === t || i.indexOf(r) < i.indexOf(t));
  }
  function C0t(n, e) {
    var t;
    const r = ((t = e == null ? void 0 : e.value) == null ? void 0 : t.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = Tt(false), a = Tt(() => {
    });
    return ld((s) => {
      if (!xp) return;
      const o = async (u) => {
        const c = u.target;
        if (e != null && e.value) {
          if (Lae(e.value, c)) {
            i.value = false;
            return;
          }
          if (u.target && !i.value) {
            let h = function() {
              Dae(_0t, n, d);
            };
            const d = {
              originalEvent: u
            };
            u.pointerType === "touch" ? (r.removeEventListener("click", a.value), a.value = h, r.addEventListener("click", a.value, {
              once: true
            })) : h();
          } else r.removeEventListener("click", a.value);
          i.value = false;
        }
      }, l = window.setTimeout(() => {
        r.addEventListener("pointerdown", o);
      }, 0);
      s(() => {
        window.clearTimeout(l), r.removeEventListener("pointerdown", o), r.removeEventListener("click", a.value);
      });
    }), {
      onPointerDownCapture: () => i.value = true
    };
  }
  function I0t(n, e) {
    var t;
    const r = ((t = e == null ? void 0 : e.value) == null ? void 0 : t.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), i = Tt(false);
    return ld((a) => {
      if (!xp) return;
      const s = async (o) => {
        e != null && e.value && (await nu(), !(!e.value || Lae(e.value, o.target)) && o.target && !i.value && Dae(S0t, n, {
          originalEvent: o
        }));
      };
      r.addEventListener("focusin", s), a(() => r.removeEventListener("focusin", s));
    }), {
      onFocusCapture: () => i.value = true,
      onBlurCapture: () => i.value = false
    };
  }
  const _l = g6({
    layersRoot: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  }), k0t = Rt({
    __name: "DismissableLayer",
    props: {
      disableOutsidePointerEvents: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "dismiss"
    ],
    setup(n, { emit: e }) {
      const t = n, r = e, { forwardRef: i, currentElement: a } = $a(), s = Zt(() => {
        var p;
        return ((p = a.value) == null ? void 0 : p.ownerDocument) ?? globalThis.document;
      }), o = Zt(() => _l.layersRoot), l = Zt(() => a.value ? Array.from(o.value).indexOf(a.value) : -1), u = Zt(() => _l.layersWithOutsidePointerEventsDisabled.size > 0), c = Zt(() => {
        const p = Array.from(o.value), [g] = [
          ..._l.layersWithOutsidePointerEventsDisabled
        ].slice(-1), m = p.indexOf(g);
        return l.value >= m;
      }), h = C0t(async (p) => {
        const g = [
          ..._l.branches
        ].some((m) => m == null ? void 0 : m.contains(p.target));
        !c.value || g || (r("pointerDownOutside", p), r("interactOutside", p), await nu(), p.defaultPrevented || r("dismiss"));
      }, a), d = I0t((p) => {
        [
          ..._l.branches
        ].some((g) => g == null ? void 0 : g.contains(p.target)) || (r("focusOutside", p), r("interactOutside", p), p.defaultPrevented || r("dismiss"));
      }, a);
      e0t("Escape", (p) => {
        l.value === o.value.size - 1 && (r("escapeKeyDown", p), p.defaultPrevented || r("dismiss"));
      });
      let f;
      return ld((p) => {
        a.value && (t.disableOutsidePointerEvents && (_l.layersWithOutsidePointerEventsDisabled.size === 0 && (f = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), _l.layersWithOutsidePointerEventsDisabled.add(a.value)), o.value.add(a.value), p(() => {
          t.disableOutsidePointerEvents && _l.layersWithOutsidePointerEventsDisabled.size === 1 && (s.value.body.style.pointerEvents = f);
        }));
      }), ld((p) => {
        p(() => {
          a.value && (o.value.delete(a.value), _l.layersWithOutsidePointerEventsDisabled.delete(a.value));
        });
      }), (p, g) => ($t(), kn(J(Ns), {
        ref: J(i),
        "as-child": p.asChild,
        as: p.as,
        "data-dismissable-layer": "",
        style: m6({
          pointerEvents: u.value ? c.value ? "auto" : "none" : void 0
        }),
        onFocusCapture: J(d).onFocusCapture,
        onBlurCapture: J(d).onBlurCapture,
        onPointerdownCapture: J(h).onPointerDownCapture
      }, {
        default: He(() => [
          Qt(p.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "style",
        "onFocusCapture",
        "onBlurCapture",
        "onPointerdownCapture"
      ]));
    }
  }), aD = "focusScope.autoFocusOnMount", sD = "focusScope.autoFocusOnUnmount", i6 = {
    bubbles: false,
    cancelable: true
  };
  function T0t(n, { select: e = false } = {}) {
    const t = Zo();
    for (const r of n) if (Tu(r, {
      select: e
    }), Zo() !== t) return true;
  }
  function A0t(n) {
    const e = Fae(n), t = a6(e, n), r = a6(e.reverse(), n);
    return [
      t,
      r
    ];
  }
  function Fae(n) {
    const e = [], t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; t.nextNode(); ) e.push(t.currentNode);
    return e;
  }
  function a6(n, e) {
    for (const t of n) if (!D0t(t, {
      upTo: e
    })) return t;
  }
  function D0t(n, { upTo: e }) {
    if (getComputedStyle(n).visibility === "hidden") return true;
    for (; n; ) {
      if (e !== void 0 && n === e) return false;
      if (getComputedStyle(n).display === "none") return true;
      n = n.parentElement;
    }
    return false;
  }
  function R0t(n) {
    return n instanceof HTMLInputElement && "select" in n;
  }
  function Tu(n, { select: e = false } = {}) {
    if (n && n.focus) {
      const t = Zo();
      n.focus({
        preventScroll: true
      }), n !== t && R0t(n) && e && n.select();
    }
  }
  const $0t = Uyt(() => Tt([]));
  function N0t() {
    const n = $0t();
    return {
      add(e) {
        const t = n.value[0];
        e !== t && (t == null ? void 0 : t.pause()), n.value = s6(n.value, e), n.value.unshift(e);
      },
      remove(e) {
        var t;
        n.value = s6(n.value, e), (t = n.value[0]) == null || t.resume();
      }
    };
  }
  function s6(n, e) {
    const t = [
      ...n
    ], r = t.indexOf(e);
    return r !== -1 && t.splice(r, 1), t;
  }
  function E0t(n) {
    return n.filter((e) => e.tagName !== "A");
  }
  const M0t = Rt({
    __name: "FocusScope",
    props: {
      loop: {
        type: Boolean,
        default: false
      },
      trapped: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "mountAutoFocus",
      "unmountAutoFocus"
    ],
    setup(n, { emit: e }) {
      const t = n, r = e, { currentRef: i, currentElement: a } = $a(), s = Tt(null), o = N0t(), l = g6({
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      });
      ld((c) => {
        if (!xp) return;
        const h = a.value;
        if (!t.trapped) return;
        function d(m) {
          if (l.paused || !h) return;
          const v = m.target;
          h.contains(v) ? s.value = v : Tu(s.value, {
            select: true
          });
        }
        function f(m) {
          if (l.paused || !h) return;
          const v = m.relatedTarget;
          v !== null && (h.contains(v) || Tu(s.value, {
            select: true
          }));
        }
        function p(m) {
          h.contains(s.value) || Tu(h);
        }
        document.addEventListener("focusin", d), document.addEventListener("focusout", f);
        const g = new MutationObserver(p);
        h && g.observe(h, {
          childList: true,
          subtree: true
        }), c(() => {
          document.removeEventListener("focusin", d), document.removeEventListener("focusout", f), g.disconnect();
        });
      }), ld(async (c) => {
        const h = a.value;
        if (await nu(), !h) return;
        o.add(l);
        const d = Zo();
        if (!h.contains(d)) {
          const f = new CustomEvent(aD, i6);
          h.addEventListener(aD, (p) => r("mountAutoFocus", p)), h.dispatchEvent(f), f.defaultPrevented || (T0t(E0t(Fae(h)), {
            select: true
          }), Zo() === d && Tu(h));
        }
        c(() => {
          h.removeEventListener(aD, (g) => r("mountAutoFocus", g));
          const f = new CustomEvent(sD, i6), p = (g) => {
            r("unmountAutoFocus", g);
          };
          h.addEventListener(sD, p), h.dispatchEvent(f), setTimeout(() => {
            f.defaultPrevented || Tu(d ?? document.body, {
              select: true
            }), h.removeEventListener(sD, p), o.remove(l);
          }, 0);
        });
      });
      function u(c) {
        if (!t.loop && !t.trapped || l.paused) return;
        const h = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, d = Zo();
        if (h && d) {
          const f = c.currentTarget, [p, g] = A0t(f);
          p && g ? !c.shiftKey && d === g ? (c.preventDefault(), t.loop && Tu(p, {
            select: true
          })) : c.shiftKey && d === p && (c.preventDefault(), t.loop && Tu(g, {
            select: true
          })) : d === f && c.preventDefault();
        }
      }
      return (c, h) => ($t(), kn(J(Ns), {
        ref_key: "currentRef",
        ref: i,
        tabindex: "-1",
        "as-child": c.asChild,
        as: c.as,
        onKeydown: u
      }, {
        default: He(() => [
          Qt(c.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as-child",
        "as"
      ]));
    }
  });
  function P0t(n) {
    return n ? "open" : "closed";
  }
  const Oae = Rt({
    __name: "DialogContentImpl",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: e }) {
      const t = n, r = e, i = Lc(), { forwardRef: a, currentElement: s } = $a();
      return i.titleId || (i.titleId = oC(void 0, "radix-vue-dialog-title")), i.descriptionId || (i.descriptionId = oC(void 0, "radix-vue-dialog-description")), cm(() => {
        i.contentElement = s, Zo() !== document.body && (i.triggerElement.value = Zo());
      }), (o, l) => ($t(), kn(J(M0t), {
        "as-child": "",
        loop: "",
        trapped: t.trapFocus,
        onMountAutoFocus: l[5] || (l[5] = (u) => r("openAutoFocus", u)),
        onUnmountAutoFocus: l[6] || (l[6] = (u) => r("closeAutoFocus", u))
      }, {
        default: He(() => [
          kt(J(k0t), Ca({
            id: J(i).contentId,
            ref: J(a),
            as: o.as,
            "as-child": o.asChild,
            "disable-outside-pointer-events": o.disableOutsidePointerEvents,
            role: "dialog",
            "aria-describedby": J(i).descriptionId,
            "aria-labelledby": J(i).titleId,
            "data-state": J(P0t)(J(i).open.value)
          }, o.$attrs, {
            onDismiss: l[0] || (l[0] = (u) => J(i).onOpenChange(false)),
            onEscapeKeyDown: l[1] || (l[1] = (u) => r("escapeKeyDown", u)),
            onFocusOutside: l[2] || (l[2] = (u) => r("focusOutside", u)),
            onInteractOutside: l[3] || (l[3] = (u) => r("interactOutside", u)),
            onPointerDownOutside: l[4] || (l[4] = (u) => r("pointerDownOutside", u))
          }), {
            default: He(() => [
              Qt(o.$slots, "default")
            ]),
            _: 3
          }, 16, [
            "id",
            "as",
            "as-child",
            "disable-outside-pointer-events",
            "aria-describedby",
            "aria-labelledby",
            "data-state"
          ])
        ]),
        _: 3
      }, 8, [
        "trapped"
      ]));
    }
  }), L0t = Rt({
    __name: "DialogContentModal",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: e }) {
      const t = n, r = e, i = Lc(), a = w2(r), { forwardRef: s, currentElement: o } = $a();
      return p0t(o), (l, u) => ($t(), kn(Oae, Ca({
        ...t,
        ...J(a)
      }, {
        ref: J(s),
        "trap-focus": J(i).open.value,
        "disable-outside-pointer-events": true,
        onCloseAutoFocus: u[0] || (u[0] = (c) => {
          var h;
          c.defaultPrevented || (c.preventDefault(), (h = J(i).triggerElement.value) == null || h.focus());
        }),
        onPointerDownOutside: u[1] || (u[1] = (c) => {
          const h = c.detail.originalEvent, d = h.button === 0 && h.ctrlKey === true;
          (h.button === 2 || d) && c.preventDefault();
        }),
        onFocusOutside: u[2] || (u[2] = (c) => {
          c.preventDefault();
        })
      }), {
        default: He(() => [
          Qt(l.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "trap-focus"
      ]));
    }
  }), F0t = Rt({
    __name: "DialogContentNonModal",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: e }) {
      const t = n, r = w2(e);
      $a();
      const i = Lc(), a = Tt(false), s = Tt(false);
      return (o, l) => ($t(), kn(Oae, Ca({
        ...t,
        ...J(r)
      }, {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: l[0] || (l[0] = (u) => {
          var c;
          u.defaultPrevented || (a.value || (c = J(i).triggerElement.value) == null || c.focus(), u.preventDefault()), a.value = false, s.value = false;
        }),
        onInteractOutside: l[1] || (l[1] = (u) => {
          var c;
          u.defaultPrevented || (a.value = true, u.detail.originalEvent.type === "pointerdown" && (s.value = true));
          const h = u.target;
          (c = J(i).triggerElement.value) != null && c.contains(h) && u.preventDefault(), u.detail.originalEvent.type === "focusin" && s.value && u.preventDefault();
        })
      }), {
        default: He(() => [
          Qt(o.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), O0t = Rt({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: e }) {
      const t = n, r = e, i = Lc(), a = w2(r), { forwardRef: s } = $a();
      return (o, l) => ($t(), kn(J(w3), {
        present: o.forceMount || J(i).open.value
      }, {
        default: He(() => [
          J(i).modal.value ? ($t(), kn(L0t, Ca({
            key: 0,
            ref: J(s)
          }, {
            ...t,
            ...J(a),
            ...o.$attrs
          }), {
            default: He(() => [
              Qt(o.$slots, "default")
            ]),
            _: 3
          }, 16)) : ($t(), kn(F0t, Ca({
            key: 1,
            ref: J(s)
          }, {
            ...t,
            ...J(a),
            ...o.$attrs
          }), {
            default: He(() => [
              Qt(o.$slots, "default")
            ]),
            _: 3
          }, 16))
        ]),
        _: 3
      }, 8, [
        "present"
      ]));
    }
  }), B0t = Rt({
    __name: "DialogOverlayImpl",
    props: {
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(n) {
      const e = Lc();
      return l0t(true), $a(), (t, r) => ($t(), kn(J(Ns), {
        as: t.as,
        "as-child": t.asChild,
        "data-state": J(e).open.value ? "open" : "closed",
        style: {
          "pointer-events": "auto"
        }
      }, {
        default: He(() => [
          Qt(t.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ]));
    }
  }), z0t = Rt({
    __name: "DialogOverlay",
    props: {
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(n) {
      const e = Lc(), { forwardRef: t } = $a();
      return (r, i) => {
        var a;
        return (a = J(e)) != null && a.modal.value ? ($t(), kn(J(w3), {
          key: 0,
          present: r.forceMount || J(e).open.value
        }, {
          default: He(() => [
            kt(B0t, Ca(r.$attrs, {
              ref: J(t),
              as: r.as,
              "as-child": r.asChild
            }), {
              default: He(() => [
                Qt(r.$slots, "default")
              ]),
              _: 3
            }, 16, [
              "as",
              "as-child"
            ])
          ]),
          _: 3
        }, 8, [
          "present"
        ])) : S0("", true);
      };
    }
  }), V0t = Rt({
    __name: "DialogClose",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(n) {
      const e = n;
      $a();
      const t = Lc();
      return (r, i) => ($t(), kn(J(Ns), Ca(e, {
        type: r.as === "button" ? "button" : void 0,
        onClick: i[0] || (i[0] = (a) => J(t).onOpenChange(false))
      }), {
        default: He(() => [
          Qt(r.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "type"
      ]));
    }
  }), W0t = Rt({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {
        default: "h2"
      }
    },
    setup(n) {
      const e = n, t = Lc();
      return $a(), (r, i) => ($t(), kn(J(Ns), Ca(e, {
        id: J(t).titleId
      }), {
        default: He(() => [
          Qt(r.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "id"
      ]));
    }
  }), G0t = "data-radix-vue-collection-item", [_3, U0t] = qb("CollectionProvider");
  function H0t(n = G0t) {
    const e = Tt(/* @__PURE__ */ new Map()), t = Tt(), r = U0t({
      collectionRef: t,
      itemMap: e,
      attrName: n
    }), { getItems: i } = Bae(r), a = Zt(() => Array.from(r.itemMap.value.values())), s = Zt(() => r.itemMap.value.size);
    return {
      getItems: i,
      reactiveItems: a,
      itemMapSize: s
    };
  }
  const X0t = Rt({
    name: "CollectionSlot",
    setup(n, { slots: e }) {
      const t = _3(), { primitiveElement: r, currentElement: i } = Pae();
      return $i(i, () => {
        t.collectionRef.value = i.value;
      }), () => js(b3, {
        ref: r
      }, e);
    }
  }), Y0t = Rt({
    name: "CollectionItem",
    inheritAttrs: false,
    props: {
      value: {
        validator: () => true
      }
    },
    setup(n, { slots: e, attrs: t }) {
      const r = _3(), { primitiveElement: i, currentElement: a } = Pae();
      return ld((s) => {
        if (a.value) {
          const o = Sse(a.value);
          r.itemMap.value.set(o, {
            ref: a.value,
            value: n.value
          }), s(() => r.itemMap.value.delete(o));
        }
      }), () => js(b3, {
        ...t,
        [r.attrName]: "",
        ref: i
      }, e);
    }
  });
  function Bae(n) {
    const e = n ?? _3();
    return {
      getItems: () => {
        const t = e.collectionRef.value;
        if (!t) return [];
        const r = Array.from(t.querySelectorAll(`[${e.attrName}]`));
        return Array.from(e.itemMap.value.values()).sort((i, a) => r.indexOf(i.ref) - r.indexOf(a.ref));
      }
    };
  }
  const q0t = "rovingFocusGroup.onEntryFocus", j0t = {
    bubbles: false,
    cancelable: true
  }, K0t = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function Z0t(n, e) {
    return e !== "rtl" ? n : n === "ArrowLeft" ? "ArrowRight" : n === "ArrowRight" ? "ArrowLeft" : n;
  }
  function Q0t(n, e, t) {
    const r = Z0t(n.key, t);
    if (!(e === "vertical" && [
      "ArrowLeft",
      "ArrowRight"
    ].includes(r)) && !(e === "horizontal" && [
      "ArrowUp",
      "ArrowDown"
    ].includes(r))) return K0t[r];
  }
  function zae(n, e = false) {
    const t = Zo();
    for (const r of n) if (r === t || (r.focus({
      preventScroll: e
    }), Zo() !== t)) return;
  }
  function J0t(n, e) {
    return n.map((t, r) => n[(e + r) % n.length]);
  }
  const [ext, txt] = qb("RovingFocusGroup"), nxt = Rt({
    __name: "RovingFocusGroup",
    props: {
      orientation: {
        default: void 0
      },
      dir: {},
      loop: {
        type: Boolean,
        default: false
      },
      currentTabStopId: {},
      defaultCurrentTabStopId: {},
      preventScrollOnEntryFocus: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "entryFocus",
      "update:currentTabStopId"
    ],
    setup(n, { expose: e, emit: t }) {
      const r = n, i = t, { loop: a, orientation: s, dir: o } = Ax(r), l = Eae(o), u = g3(r, "currentTabStopId", i, {
        defaultValue: r.defaultCurrentTabStopId,
        passive: r.currentTabStopId === void 0
      }), c = Tt(false), h = Tt(false), d = Tt(0), { getItems: f } = H0t();
      function p(m) {
        const v = !h.value;
        if (m.currentTarget && m.target === m.currentTarget && v && !c.value) {
          const y = new CustomEvent(q0t, j0t);
          if (m.currentTarget.dispatchEvent(y), i("entryFocus", y), !y.defaultPrevented) {
            const x = f().map((S) => S.ref).filter((S) => S.dataset.disabled !== ""), b = x.find((S) => S.getAttribute("data-active") === "true"), w = x.find((S) => S.id === u.value), _ = [
              b,
              w,
              ...x
            ].filter(Boolean);
            zae(_, r.preventScrollOnEntryFocus);
          }
        }
        h.value = false;
      }
      function g() {
        setTimeout(() => {
          h.value = false;
        }, 1);
      }
      return e({
        getItems: f
      }), txt({
        loop: a,
        dir: l,
        orientation: s,
        currentTabStopId: u,
        onItemFocus: (m) => {
          u.value = m;
        },
        onItemShiftTab: () => {
          c.value = true;
        },
        onFocusableItemAdd: () => {
          d.value++;
        },
        onFocusableItemRemove: () => {
          d.value--;
        }
      }), (m, v) => ($t(), kn(J(X0t), null, {
        default: He(() => [
          kt(J(Ns), {
            tabindex: c.value || d.value === 0 ? -1 : 0,
            "data-orientation": J(s),
            as: m.as,
            "as-child": m.asChild,
            dir: J(l),
            style: {
              outline: "none"
            },
            onMousedown: v[0] || (v[0] = (y) => h.value = true),
            onMouseup: g,
            onFocus: p,
            onBlur: v[1] || (v[1] = (y) => c.value = false)
          }, {
            default: He(() => [
              Qt(m.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "as",
            "as-child",
            "dir"
          ])
        ]),
        _: 3
      }));
    }
  }), rxt = Rt({
    __name: "RovingFocusItem",
    props: {
      tabStopId: {},
      focusable: {
        type: Boolean,
        default: true
      },
      active: {
        type: Boolean,
        default: true
      },
      allowShiftKey: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "span"
      }
    },
    setup(n) {
      const e = n, t = ext(), r = Zt(() => e.tabStopId || oC()), i = Zt(() => t.currentTabStopId.value === r.value), { getItems: a } = Bae();
      cm(() => {
        e.focusable && t.onFocusableItemAdd();
      }), lC(() => {
        e.focusable && t.onFocusableItemRemove();
      });
      function s(o) {
        if (o.key === "Tab" && o.shiftKey) {
          t.onItemShiftTab();
          return;
        }
        if (o.target !== o.currentTarget) return;
        const l = Q0t(o, t.orientation.value, t.dir.value);
        if (l !== void 0) {
          if (o.metaKey || o.ctrlKey || o.altKey || !e.allowShiftKey && o.shiftKey) return;
          o.preventDefault();
          let u = [
            ...a().map((c) => c.ref).filter((c) => c.dataset.disabled !== "")
          ];
          if (l === "last") u.reverse();
          else if (l === "prev" || l === "next") {
            l === "prev" && u.reverse();
            const c = u.indexOf(o.currentTarget);
            u = t.loop.value ? J0t(u, c + 1) : u.slice(c + 1);
          }
          nu(() => zae(u));
        }
      }
      return (o, l) => ($t(), kn(J(Y0t), null, {
        default: He(() => [
          kt(J(Ns), {
            tabindex: i.value ? 0 : -1,
            "data-orientation": J(t).orientation.value,
            "data-active": o.active,
            "data-disabled": o.focusable ? void 0 : "",
            as: o.as,
            "as-child": o.asChild,
            onMousedown: l[0] || (l[0] = (u) => {
              o.focusable ? J(t).onItemFocus(r.value) : u.preventDefault();
            }),
            onFocus: l[1] || (l[1] = (u) => J(t).onItemFocus(r.value)),
            onKeydown: s
          }, {
            default: He(() => [
              Qt(o.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "data-active",
            "data-disabled",
            "as",
            "as-child"
          ])
        ]),
        _: 3
      }));
    }
  });
  function ixt() {
    if (typeof matchMedia == "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
  ixt();
  const [S3, axt] = qb("TabsRoot"), sxt = Rt({
    __name: "TabsRoot",
    props: {
      defaultValue: {},
      orientation: {
        default: "horizontal"
      },
      dir: {},
      activationMode: {
        default: "automatic"
      },
      modelValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(n, { emit: e }) {
      const t = n, r = e, { orientation: i, dir: a } = Ax(t), s = Eae(a);
      $a();
      const o = g3(t, "modelValue", r, {
        defaultValue: t.defaultValue,
        passive: t.modelValue === void 0
      }), l = Tt();
      return axt({
        modelValue: o,
        changeModelValue: (u) => {
          o.value = u;
        },
        orientation: i,
        dir: s,
        activationMode: t.activationMode,
        baseId: oC(void 0, "radix-vue-tabs"),
        tabsList: l
      }), (u, c) => ($t(), kn(J(Ns), {
        dir: J(s),
        "data-orientation": J(i),
        "as-child": u.asChild,
        as: u.as
      }, {
        default: He(() => [
          Qt(u.$slots, "default", {
            modelValue: J(o)
          })
        ]),
        _: 3
      }, 8, [
        "dir",
        "data-orientation",
        "as-child",
        "as"
      ]));
    }
  }), oxt = Rt({
    __name: "TabsList",
    props: {
      loop: {
        type: Boolean,
        default: true
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(n) {
      const e = n, { loop: t } = Ax(e), { forwardRef: r, currentElement: i } = $a(), a = S3();
      return a.tabsList = i, (s, o) => ($t(), kn(J(nxt), {
        "as-child": "",
        orientation: J(a).orientation.value,
        dir: J(a).dir.value,
        loop: J(t)
      }, {
        default: He(() => [
          kt(J(Ns), {
            ref: J(r),
            role: "tablist",
            "as-child": s.asChild,
            as: s.as,
            "aria-orientation": J(a).orientation.value
          }, {
            default: He(() => [
              Qt(s.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "as-child",
            "as",
            "aria-orientation"
          ])
        ]),
        _: 3
      }, 8, [
        "orientation",
        "dir",
        "loop"
      ]));
    }
  });
  function Vae(n, e) {
    return `${n}-trigger-${e}`;
  }
  function Wae(n, e) {
    return `${n}-content-${e}`;
  }
  const lxt = Rt({
    __name: "TabsContent",
    props: {
      value: {},
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {}
    },
    setup(n) {
      const e = n, { forwardRef: t } = $a(), r = S3(), i = Zt(() => Vae(r.baseId, e.value)), a = Zt(() => Wae(r.baseId, e.value)), s = Zt(() => e.value === r.modelValue.value), o = Tt(s.value);
      return cm(() => {
        requestAnimationFrame(() => {
          o.value = false;
        });
      }), (l, u) => ($t(), kn(J(w3), {
        present: s.value,
        "force-mount": ""
      }, {
        default: He(({ present: c }) => [
          kt(J(Ns), {
            id: a.value,
            ref: J(t),
            "as-child": l.asChild,
            as: l.as,
            role: "tabpanel",
            "data-state": s.value ? "active" : "inactive",
            "data-orientation": J(r).orientation.value,
            "aria-labelledby": i.value,
            hidden: !c.value,
            tabindex: "0",
            style: m6({
              animationDuration: o.value ? "0s" : void 0
            })
          }, {
            default: He(() => [
              l.forceMount || s.value ? Qt(l.$slots, "default", {
                key: 0
              }) : S0("", true)
            ]),
            _: 2
          }, 1032, [
            "id",
            "as-child",
            "as",
            "data-state",
            "data-orientation",
            "aria-labelledby",
            "hidden",
            "style"
          ])
        ]),
        _: 3
      }, 8, [
        "present"
      ]));
    }
  }), uxt = Rt({
    __name: "TabsTrigger",
    props: {
      value: {},
      disabled: {
        type: Boolean,
        default: false
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(n) {
      const e = n, { forwardRef: t } = $a(), r = S3(), i = Zt(() => Vae(r.baseId, e.value)), a = Zt(() => Wae(r.baseId, e.value)), s = Zt(() => e.value === r.modelValue.value);
      return (o, l) => ($t(), kn(J(rxt), {
        "as-child": "",
        focusable: !o.disabled,
        active: s.value
      }, {
        default: He(() => [
          kt(J(Ns), {
            id: i.value,
            ref: J(t),
            role: "tab",
            type: o.as === "button" ? "button" : void 0,
            as: o.as,
            "as-child": o.asChild,
            "aria-selected": s.value ? "true" : "false",
            "aria-controls": a.value,
            "data-state": s.value ? "active" : "inactive",
            disabled: o.disabled,
            "data-disabled": o.disabled ? "" : void 0,
            "data-orientation": J(r).orientation.value,
            onMousedown: l[0] || (l[0] = Ay((u) => {
              !o.disabled && u.ctrlKey === false ? J(r).changeModelValue(o.value) : u.preventDefault();
            }, [
              "left"
            ])),
            onKeydown: l[1] || (l[1] = yse((u) => J(r).changeModelValue(o.value), [
              "enter",
              "space"
            ])),
            onFocus: l[2] || (l[2] = () => {
              const u = J(r).activationMode !== "manual";
              !s.value && !o.disabled && u && J(r).changeModelValue(o.value);
            })
          }, {
            default: He(() => [
              Qt(o.$slots, "default")
            ]),
            _: 3
          }, 8, [
            "id",
            "type",
            "as",
            "as-child",
            "aria-selected",
            "aria-controls",
            "data-state",
            "disabled",
            "data-disabled",
            "data-orientation"
          ])
        ]),
        _: 3
      }, 8, [
        "focusable",
        "active"
      ]));
    }
  }), oD = Rt({
    __name: "Button",
    props: {
      variant: {},
      size: {},
      class: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), kn(J(Ns), {
        as: t.as,
        "as-child": t.asChild,
        class: qa(J(bi)(J(cxt)({
          variant: t.variant,
          size: t.size
        }), e.class))
      }, {
        default: He(() => [
          Qt(t.$slots, "default")
        ]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "class"
      ]));
    }
  }), cxt = nyt("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }), hxt = Rt({
    __name: "Card",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("div", {
        class: qa(J(bi)("rounded-lg border bg-card text-card-foreground shadow-sm", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), lD = Rt({
    __name: "CardContent",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("div", {
        class: qa(J(bi)("p-6 pt-0", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), dxt = Rt({
    __name: "CardHeader",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("div", {
        class: qa(J(bi)("flex flex-col gap-y-1.5 p-6", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), fxt = Rt({
    __name: "Dialog",
    props: {
      open: {
        type: Boolean
      },
      defaultOpen: {
        type: Boolean
      },
      modal: {
        type: Boolean
      }
    },
    emits: [
      "update:open"
    ],
    setup(n, { emit: e }) {
      const i = x3(n, e);
      return (a, s) => ($t(), kn(J(x0t), IN(kN(J(i))), {
        default: He(() => [
          Qt(a.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), pxt = Rt({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean
      },
      trapFocus: {
        type: Boolean
      },
      disableOutsidePointerEvents: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(n, { emit: e }) {
      const t = n, r = e, i = Zt(() => {
        const { class: s, ...o } = t;
        return o;
      }), a = x3(i, r);
      return (s, o) => ($t(), kn(J(w0t), null, {
        default: He(() => [
          kt(J(z0t), {
            class: "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
          }),
          kt(J(O0t), Ca(J(a), {
            class: J(bi)("fixed left-1/2 top-1/2 z-50 grid w-full max-w-lg -translate-x-1/2 -translate-y-1/2 gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", t.class)
          }), {
            default: He(() => [
              Qt(s.$slots, "default"),
              kt(J(V0t), {
                class: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground"
              }, {
                default: He(() => [
                  kt(J(A2e), {
                    class: "w-4 h-4"
                  }),
                  o[0] || (o[0] = Ge("span", {
                    class: "sr-only"
                  }, "Close", -1))
                ]),
                _: 1
              })
            ]),
            _: 3
          }, 16, [
            "class"
          ])
        ]),
        _: 3
      }));
    }
  }), gxt = Rt({
    __name: "DialogHeader",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("div", {
        class: qa(J(bi)("flex flex-col gap-y-1.5 text-center sm:text-left", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), mxt = Rt({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(n) {
      const e = n, t = Zt(() => {
        const { class: i, ...a } = e;
        return a;
      }), r = y3(t);
      return (i, a) => ($t(), kn(J(W0t), Ca(J(r), {
        class: J(bi)("text-lg font-semibold leading-none tracking-tight", e.class)
      }), {
        default: He(() => [
          Qt(i.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  });
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const vxt = (n) => typeof n < "u";
  function yxt(n) {
    return JSON.parse(JSON.stringify(n));
  }
  function xxt(n, e, t, r = {}) {
    var i, a, s;
    const { clone: o = false, passive: l = false, eventName: u, deep: c = false, defaultValue: h, shouldEmit: d } = r, f = Ha(), p = t || (f == null ? void 0 : f.emit) || ((i = f == null ? void 0 : f.$emit) == null ? void 0 : i.bind(f)) || ((s = (a = f == null ? void 0 : f.proxy) == null ? void 0 : a.$emit) == null ? void 0 : s.bind(f == null ? void 0 : f.proxy));
    let g = u;
    g = g || `update:${e.toString()}`;
    const m = (x) => o ? typeof o == "function" ? o(x) : yxt(x) : x, v = () => vxt(n[e]) ? m(n[e]) : h, y = (x) => {
      d ? d(x) && p(g, x) : p(g, x);
    };
    if (l) {
      const x = v(), b = Tt(x);
      let w = false;
      return $i(() => n[e], (_) => {
        w || (w = true, b.value = m(_), nu(() => w = false));
      }), $i(b, (_) => {
        !w && (_ !== n[e] || c) && y(_);
      }, {
        deep: c
      }), b;
    } else return Zt({
      get() {
        return v();
      },
      set(x) {
        y(x);
      }
    });
  }
  const bxt = Rt({
    __name: "Textarea",
    props: {
      class: {},
      defaultValue: {},
      modelValue: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(n, { emit: e }) {
      const t = n, i = xxt(t, "modelValue", e, {
        passive: true,
        defaultValue: t.defaultValue
      });
      return (a, s) => Xw(($t(), Ai("textarea", {
        "onUpdate:modelValue": s[0] || (s[0] = (o) => d6(i) ? i.value = o : null),
        class: qa(J(bi)("flex min-h-20 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t.class))
      }, null, 2)), [
        [
          hD,
          J(i)
        ]
      ]);
    }
  }), wxt = Rt({
    __name: "Tabs",
    props: {
      defaultValue: {},
      orientation: {},
      dir: {},
      activationMode: {},
      modelValue: {},
      asChild: {
        type: Boolean
      },
      as: {}
    },
    emits: [
      "update:modelValue"
    ],
    setup(n, { emit: e }) {
      const i = x3(n, e);
      return (a, s) => ($t(), kn(J(sxt), IN(kN(J(i))), {
        default: He(() => [
          Qt(a.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  }), o6 = Rt({
    __name: "TabsContent",
    props: {
      value: {},
      forceMount: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(n) {
      const e = n, t = Zt(() => {
        const { class: r, ...i } = e;
        return i;
      });
      return (r, i) => ($t(), kn(J(lxt), Ca({
        class: J(bi)("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", e.class)
      }, t.value), {
        default: He(() => [
          Qt(r.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), _xt = Rt({
    __name: "TabsList",
    props: {
      loop: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(n) {
      const e = n, t = Zt(() => {
        const { class: r, ...i } = e;
        return i;
      });
      return (r, i) => ($t(), kn(J(oxt), Ca(t.value, {
        class: J(bi)("inline-flex items-center justify-center rounded-md bg-muted p-1 text-muted-foreground", e.class)
      }), {
        default: He(() => [
          Qt(r.$slots, "default")
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), Sxt = {
    class: "truncate"
  }, l6 = Rt({
    __name: "TabsTrigger",
    props: {
      value: {},
      disabled: {
        type: Boolean
      },
      asChild: {
        type: Boolean
      },
      as: {},
      class: {}
    },
    setup(n) {
      const e = n, t = Zt(() => {
        const { class: i, ...a } = e;
        return a;
      }), r = y3(t);
      return (i, a) => ($t(), kn(J(uxt), Ca(J(r), {
        class: J(bi)("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm", e.class)
      }), {
        default: He(() => [
          Ge("span", Sxt, [
            Qt(i.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, [
        "class"
      ]));
    }
  }), Cxt = {
    class: "relative w-full overflow-auto"
  }, Ixt = Rt({
    __name: "Table",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("div", Cxt, [
        Ge("table", {
          class: qa(J(bi)("w-full caption-bottom text-sm", e.class))
        }, [
          Qt(t.$slots, "default")
        ], 2)
      ]));
    }
  }), kxt = Rt({
    __name: "TableBody",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("tbody", {
        class: qa(J(bi)("[&_tr:last-child]:border-0", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), tg = Rt({
    __name: "TableCell",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("td", {
        class: qa(J(bi)("p-4 align-middle [&:has([role=checkbox])]:pr-0", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), u6 = Rt({
    __name: "TableRow",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("tr", {
        class: qa(J(bi)("border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), ng = Rt({
    __name: "TableHead",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("th", {
        class: qa(J(bi)("h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), Txt = Rt({
    __name: "TableHeader",
    props: {
      class: {}
    },
    setup(n) {
      const e = n;
      return (t, r) => ($t(), Ai("thead", {
        class: qa(J(bi)("[&_tr]:border-b", e.class))
      }, [
        Qt(t.$slots, "default")
      ], 2));
    }
  }), Axt = 1, Dxt = 1e6, Nl = {
    ADD_TOAST: "ADD_TOAST",
    UPDATE_TOAST: "UPDATE_TOAST",
    DISMISS_TOAST: "DISMISS_TOAST",
    REMOVE_TOAST: "REMOVE_TOAST"
  };
  let uD = 0;
  function Rxt() {
    return uD = (uD + 1) % Number.MAX_VALUE, uD.toString();
  }
  const cD = /* @__PURE__ */ new Map();
  function c6(n) {
    if (cD.has(n)) return;
    const e = setTimeout(() => {
      cD.delete(n), w0({
        type: Nl.REMOVE_TOAST,
        toastId: n
      });
    }, Dxt);
    cD.set(n, e);
  }
  const Os = Tt({
    toasts: []
  });
  function w0(n) {
    switch (n.type) {
      case Nl.ADD_TOAST:
        Os.value.toasts = [
          n.toast,
          ...Os.value.toasts
        ].slice(0, Axt);
        break;
      case Nl.UPDATE_TOAST:
        Os.value.toasts = Os.value.toasts.map((e) => e.id === n.toast.id ? {
          ...e,
          ...n.toast
        } : e);
        break;
      case Nl.DISMISS_TOAST: {
        const { toastId: e } = n;
        e ? c6(e) : Os.value.toasts.forEach((t) => {
          c6(t.id);
        }), Os.value.toasts = Os.value.toasts.map((t) => t.id === e || e === void 0 ? {
          ...t,
          open: false
        } : t);
        break;
      }
      case Nl.REMOVE_TOAST:
        n.toastId === void 0 ? Os.value.toasts = [] : Os.value.toasts = Os.value.toasts.filter((e) => e.id !== n.toastId);
        break;
    }
  }
  function $xt() {
    return {
      toasts: Zt(() => Os.value.toasts),
      toast: Nxt,
      dismiss: (n) => w0({
        type: Nl.DISMISS_TOAST,
        toastId: n
      })
    };
  }
  function Nxt(n) {
    const e = Rxt(), t = (i) => w0({
      type: Nl.UPDATE_TOAST,
      toast: {
        ...i,
        id: e
      }
    }), r = () => w0({
      type: Nl.DISMISS_TOAST,
      toastId: e
    });
    return w0({
      type: Nl.ADD_TOAST,
      toast: {
        ...n,
        id: e,
        open: true,
        onOpenChange: (i) => {
          i || r();
        }
      }
    }), {
      id: e,
      dismiss: r,
      update: t
    };
  }
  let Ext, Mxt, Pxt, Lxt, Fxt, Oxt, Bxt, zxt, Vxt, Wxt, Gxt, Uxt, Hxt, Xxt, Yxt, qxt, jxt, Kxt, Zxt, Qxt, Jxt, ebt, tbt, nbt, rbt, ibt, abt, sbt, obt, lbt, ubt, cbt, hbt, dbt, fbt, pbt, gbt, mbt, vbt, ybt, xbt, bbt, wbt, _bt, Sbt, Cbt, Ibt, kbt, Tbt, Abt, Dbt, Rbt, $bt, Nbt, Ebt, Mbt, Pbt, Lbt, Fbt, Obt, Bbt, zbt, Vbt, Wbt, Gbt, Ubt, Hbt;
  Ext = {
    class: "flex flex-col justify-start space-y-4 p-4 max-w-4xl mx-auto w-full"
  };
  Mxt = {
    class: "text-lg font-bold"
  };
  Pxt = {
    class: "text-sm text-gray-600 text-center"
  };
  Lxt = {
    class: "text-primary font-medium hover:underline"
  };
  Fxt = {
    key: 0,
    class: "w-full max-w-2xl mx-auto"
  };
  Oxt = {
    class: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4"
  };
  Bxt = [
    "onClick"
  ];
  zxt = [
    "src",
    "alt"
  ];
  Vxt = {
    class: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-center justify-center"
  };
  Wxt = {
    class: "text-white text-sm truncate max-w-[90%] px-2"
  };
  Gxt = {
    class: "flex flex-col gap-4 items-center justify-center"
  };
  Uxt = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  Hxt = {
    class: "text-sm text-gray-600"
  };
  Xxt = [
    "disabled"
  ];
  Yxt = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  qxt = {
    class: "text-sm text-gray-600"
  };
  jxt = [
    "disabled"
  ];
  Kxt = {
    class: "flex items-center gap-4 w-full max-w-2xl mx-auto"
  };
  Zxt = {
    class: "text-sm text-gray-600"
  };
  Qxt = [
    "disabled"
  ];
  Jxt = {
    class: "flex gap-6"
  };
  ebt = {
    class: "bg-white rounded-xl shadow-sm"
  };
  tbt = {
    class: "mt-6 p-6 bg-gray-50/50 rounded-xl border border-gray-100"
  };
  nbt = {
    class: "border rounded-xl overflow-hidden overflow-x-auto"
  };
  rbt = {
    class: "flex flex-col gap-8 pt-4"
  };
  ibt = {
    class: "relative w-full overflow-hidden rounded-xl shadow-lg bg-gray-50/50"
  };
  abt = [
    "src"
  ];
  sbt = {
    class: "grid grid-cols-2 gap-6 p-6 border rounded-xl bg-gray-50/30"
  };
  obt = {
    class: "space-y-2"
  };
  lbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  ubt = {
    class: "font-medium"
  };
  cbt = {
    class: "space-y-2"
  };
  hbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  dbt = {
    class: "font-medium"
  };
  fbt = {
    class: "space-y-2"
  };
  pbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  gbt = {
    class: "font-medium"
  };
  mbt = {
    class: "space-y-2"
  };
  vbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  ybt = {
    class: "font-medium"
  };
  xbt = {
    class: "space-y-2"
  };
  bbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  wbt = {
    class: "font-medium"
  };
  _bt = {
    class: "space-y-2"
  };
  Sbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  Cbt = {
    class: "font-medium"
  };
  Ibt = {
    class: "space-y-2"
  };
  kbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  Tbt = {
    class: "font-medium"
  };
  Abt = {
    class: "space-y-2"
  };
  Dbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  Rbt = {
    class: "font-medium"
  };
  $bt = {
    class: "space-y-2"
  };
  Nbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  Ebt = {
    class: "font-medium"
  };
  Mbt = {
    class: "space-y-2"
  };
  Pbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  Lbt = {
    class: "font-medium"
  };
  Fbt = {
    class: "space-y-2"
  };
  Obt = {
    class: "text-sm font-semibold text-gray-500"
  };
  Bbt = {
    class: "font-medium"
  };
  zbt = {
    class: "space-y-2"
  };
  Vbt = {
    class: "text-sm font-semibold text-gray-500"
  };
  Wbt = {
    class: "font-medium"
  };
  Gbt = 10;
  Ubt = Rt({
    __name: "ModelPerformanceTest",
    setup(n) {
      const { t: e } = tyt(), { toast: t } = $xt(), r = Tt([]), i = Tt(""), a = Tt([]), s = Tt(false), o = Tt("chart"), l = Tt(false), u = Tt(null), c = Tt(), h = Tt(), d = Tt(), f = Tt(1), p = Tt("webgl"), g = Tt(Gbt), m = zgt(), v = Tt([]), y = Tt(false), x = (R) => {
        const E = R.target.value.split(`
`).filter((A) => A.trim()).map((A) => {
          if (A.includes(".json")) {
            const M = A.split("/");
            return M.slice(0, M.length - 1).join("/");
          }
          return A;
        });
        r.value = E.map((A) => {
          const M = A.split("/");
          return {
            name: M[M.length - 1].split(".")[0],
            url: A
          };
        });
      }, b = (R) => {
        const N = R.target.files;
        N && Array.from(N).forEach((E) => {
          const A = new FileReader();
          A.addEventListener("load", async () => {
            const M = new Image();
            M.src = A.result, await new Promise((L) => {
              M.onload = L;
            });
            const $ = await createImageBitmap(M);
            a.value.push({
              file: E,
              preview: A.result,
              bitmap: $
            });
          }, false), A.readAsDataURL(E);
        });
      }, w = async () => {
        if (!r.value.length || !a.value.length) {
          t({
            variant: "destructive",
            title: e("modelTest.messages.selectModelAndImage")
          });
          return;
        }
        s.value = true, v.value = [], await m.setBackend(p.value);
        try {
          for (const R of r.value) {
            const { name: N, url: E } = R;
            await m.loadModel(E);
            for (const A of a.value) {
              const M = performance.now(), $ = [];
              for (let H = 0; H < f.value; H++) {
                const Y = await S(N, E, A.bitmap, A.file.name);
                $.push(Y);
              }
              const L = Math.round($.reduce((H, Y) => H + Y.inferenceTime, 0) / f.value), F = [];
              for (let H = 0; H < g.value; H++) {
                const Y = await S(N, E, A.bitmap, A.file.name);
                F.push(Y);
              }
              const z = performance.now() - M, V = {
                modelName: N,
                modelUrl: E,
                imageName: A.file.name,
                warmupTime: L,
                inferenceTime: Math.round(F.reduce((H, Y) => H + Y.inferenceTime, 0) / g.value),
                fps: Math.round(F.reduce((H, Y) => H + Y.fps, 0) / g.value),
                detections: F[0].detections,
                batchSize: g.value,
                minInferenceTime: Math.min(...F.map((H) => H.inferenceTime)),
                maxInferenceTime: Math.max(...F.map((H) => H.inferenceTime)),
                totalTime: z,
                warmupResults: $,
                warmupCount: f.value,
                backend: p.value
              };
              v.value.push(V);
            }
          }
          y.value = true, C();
        } catch (R) {
          t({
            variant: "destructive",
            title: e("modelTest.messages.testError"),
            description: R.message
          });
        } finally {
          s.value = false;
        }
      }, _ = () => {
        const R = v.value.map(($) => `${$.modelName},${$.imageName},${$.inferenceTime},${$.minInferenceTime},${$.maxInferenceTime},${$.fps},${g.value}`).join(`
`), N = [
          e("modelTest.tableColumns.model"),
          e("modelTest.tableColumns.image"),
          e("modelTest.tableColumns.inferenceTime"),
          e("modelTest.tableColumns.minInferenceTime"),
          e("modelTest.tableColumns.maxInferenceTime"),
          e("modelTest.tableColumns.fps"),
          e("modelTest.dialog.testCount")
        ].join(","), E = new Blob([
          `${N}
${R}`
        ], {
          type: "text/csv"
        }), A = URL.createObjectURL(E), M = document.createElement("a");
        M.href = A, M.download = `model_performance_${(/* @__PURE__ */ new Date()).toISOString()}.csv`, M.click();
      }, S = async (R, N, E, A) => {
        var _a2;
        const M = performance.now(), L = await ((_a2 = Xh.getInstance().model) == null ? void 0 : _a2.detect(E, {})), O = performance.now() - M;
        return {
          modelName: R,
          modelUrl: N,
          imageName: A,
          inferenceTime: O,
          fps: Math.round(1e3 / O),
          detections: ((L == null ? void 0 : L.boxes.length) ?? 0) / 4
        };
      }, I = (R) => {
        u.value = R, l.value = true;
      }, C = () => {
        if (!c.value) return;
        const R = vfe(c.value), N = {
          tooltip: {
            trigger: "axis",
            backgroundColor: "rgba(255, 255, 255, 0.9)",
            borderColor: "#e5e7eb",
            textStyle: {
              color: "black"
            }
          },
          legend: {
            data: [
              e("modelTest.tableColumns.inferenceTime"),
              e("modelTest.tableColumns.fps")
            ],
            textStyle: {
              color: "black"
            }
          },
          xAxis: {
            type: "category",
            data: v.value.map((E) => E.modelName),
            axisLine: {
              lineStyle: {
                color: "#e5e7eb"
              }
            },
            axisLabel: {
              color: "#000"
            },
            nameTextStyle: {
              color: "#000"
            }
          },
          yAxis: [
            {
              type: "value",
              name: e("modelTest.tableColumns.inferenceTime"),
              axisLine: {
                lineStyle: {
                  color: "#e5e7eb"
                }
              },
              axisLabel: {
                color: "#000"
              },
              splitLine: {
                lineStyle: {
                  color: "#f3f4f6"
                }
              },
              nameTextStyle: {
                color: "#000"
              }
            },
            {
              type: "value",
              name: e("modelTest.tableColumns.fps"),
              axisLine: {
                lineStyle: {
                  color: "#e5e7eb"
                }
              },
              axisLabel: {
                color: "#000"
              },
              splitLine: {
                lineStyle: {
                  color: "#f3f4f6"
                }
              },
              nameTextStyle: {
                color: "#000"
              }
            }
          ],
          series: [
            {
              name: e("modelTest.tableColumns.inferenceTime"),
              type: "bar",
              data: v.value.map((E) => E.inferenceTime),
              itemStyle: {
                color: "#3b82f6"
              },
              emphasis: {
                itemStyle: {
                  color: "#2563eb"
                }
              }
            },
            {
              name: e("modelTest.tableColumns.fps"),
              type: "line",
              yAxisIndex: 1,
              data: v.value.map((E) => E.fps),
              lineStyle: {
                color: "#10b981"
              },
              itemStyle: {
                color: "#10b981"
              },
              emphasis: {
                itemStyle: {
                  color: "#059669"
                }
              }
            }
          ]
        };
        return R.setOption(N), window.addEventListener("resize", () => {
          R.resize();
        }), R;
      };
      $i([
        v
      ], C), $i(o, (R) => {
        R === "chart" && setTimeout(() => {
          C();
        }, 500);
      }), cm(() => C());
      const T = (R) => {
        var _a2;
        const N = new Image();
        N.src = R, (_a2 = window.open("")) == null ? void 0 : _a2.document.write(N.outerHTML);
      }, k = Tt(false), D = (R) => {
        var _a2;
        k.value = false;
        const N = (_a2 = R.dataTransfer) == null ? void 0 : _a2.files;
        N && Array.from(N).filter((E) => E.type.startsWith("image/")).forEach((E) => {
          const A = new FileReader();
          A.addEventListener("load", async () => {
            const M = new Image();
            M.src = A.result, await new Promise((L) => {
              M.onload = L;
            });
            const $ = await createImageBitmap(M);
            a.value.push({
              file: E,
              preview: A.result,
              bitmap: $
            });
          }, false), A.readAsDataURL(E);
        });
      };
      return (R, N) => ($t(), Ai("div", Ext, [
        kt(J(hxt), {
          class: "shadow-lg hover:shadow-2xl transition-all duration-300 rounded-xl overflow-hidden bg-white/50 backdrop-blur-sm border border-gray-100"
        }, {
          default: He(() => [
            kt(J(dxt), null, {
              default: He(() => [
                Ge("h1", Mxt, It(J(e)("modelTest.title")), 1)
              ]),
              _: 1
            }),
            kt(J(lD), null, {
              default: He(() => [
                kt(J(bxt), {
                  modelValue: i.value,
                  "onUpdate:modelValue": N[0] || (N[0] = (E) => i.value = E),
                  rows: "3",
                  class: "w-full max-w-2xl mx-auto transition-all duration-300 hover:shadow-md focus:ring-2 focus:ring-primary/20 rounded-lg",
                  placeholder: J(e)("modelTest.enterModelUrls"),
                  onInput: x
                }, null, 8, [
                  "modelValue",
                  "placeholder"
                ])
              ]),
              _: 1
            }),
            kt(J(lD), {
              class: "space-y-6"
            }, {
              default: He(() => [
                Ge("div", {
                  class: qa([
                    "border-2 border-dashed border-gray-200 rounded-xl p-6 hover:border-primary/60 transition-all duration-300 hover:shadow-md bg-gray-50/50 group max-w-2xl mx-auto",
                    {
                      "border-primary/60 shadow-md": k.value
                    }
                  ]),
                  onDragover: N[4] || (N[4] = Ay(() => {
                  }, [
                    "prevent"
                  ])),
                  onDrop: Ay(D, [
                    "prevent"
                  ])
                }, [
                  Ge("input", {
                    type: "file",
                    accept: "image/*",
                    multiple: "",
                    class: "hidden",
                    ref_key: "fileInput",
                    ref: d,
                    onChange: b
                  }, null, 544),
                  Ge("div", {
                    class: "flex flex-col items-center justify-center h-full cursor-pointer space-y-4",
                    onClick: N[1] || (N[1] = () => d.value.click()),
                    onDragenter: N[2] || (N[2] = Ay((E) => k.value = true, [
                      "prevent"
                    ])),
                    onDragleave: N[3] || (N[3] = Ay((E) => k.value = false, [
                      "prevent"
                    ]))
                  }, [
                    kt(J(T2e), {
                      class: "w-8 h-8 text-primary/70 group-hover:scale-110 transition-transform duration-300"
                    }),
                    Ge("div", Pxt, [
                      Zr(It(J(e)("modelTest.uploadText")) + " ", 1),
                      Ge("span", Lxt, It(J(e)("modelTest.uploadClickText")), 1)
                    ])
                  ], 32)
                ], 34),
                a.value.length > 0 ? ($t(), Ai("div", Fxt, [
                  Ge("div", Oxt, [
                    ($t(true), Ai(_0, null, B3(a.value, (E, A) => ($t(), Ai("div", {
                      key: A,
                      class: "relative group cursor-pointer rounded-lg overflow-hidden shadow-sm hover:shadow-lg transition-all duration-300",
                      onClick: (M) => T(E.preview)
                    }, [
                      Ge("img", {
                        src: E.preview,
                        class: "w-full h-32 object-cover",
                        alt: E.file.name
                      }, null, 8, zxt),
                      Ge("div", Vxt, [
                        Ge("span", Wxt, It(E.file.name), 1)
                      ])
                    ], 8, Bxt))), 128))
                  ])
                ])) : S0("", true)
              ]),
              _: 1
            }),
            kt(J(lD), null, {
              default: He(() => [
                Ge("div", Gxt, [
                  Ge("div", Uxt, [
                    Ge("label", Hxt, It(J(e)("modelTest.warmupCount")) + ":", 1),
                    Xw(Ge("input", {
                      type: "number",
                      "onUpdate:modelValue": N[5] || (N[5] = (E) => f.value = E),
                      min: "1",
                      max: "100",
                      disabled: s.value,
                      class: "w-24 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, null, 8, Xxt), [
                      [
                        hD,
                        f.value
                      ]
                    ])
                  ]),
                  Ge("div", Yxt, [
                    Ge("label", qxt, It(J(e)("modelTest.inferenceCount")) + ":", 1),
                    Xw(Ge("input", {
                      type: "number",
                      "onUpdate:modelValue": N[6] || (N[6] = (E) => g.value = E),
                      min: "1",
                      max: "100",
                      disabled: s.value,
                      class: "w-24 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, null, 8, jxt), [
                      [
                        hD,
                        g.value
                      ]
                    ])
                  ]),
                  Ge("div", Kxt, [
                    Ge("label", Zxt, It(J(e)("modelTest.backend")) + ":", 1),
                    Xw(Ge("select", {
                      "onUpdate:modelValue": N[7] || (N[7] = (E) => p.value = E),
                      disabled: s.value,
                      class: "w-32 px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary/20 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    }, N[10] || (N[10] = [
                      Ge("option", {
                        value: "webgl"
                      }, "WebGL", -1),
                      Ge("option", {
                        value: "webgpu"
                      }, "WebGPU", -1),
                      Ge("option", {
                        value: "wasm"
                      }, "WASM", -1)
                    ]), 8, Qxt), [
                      [
                        Ise,
                        p.value
                      ]
                    ])
                  ]),
                  Ge("div", Jxt, [
                    kt(J(oD), {
                      disabled: s.value || !r.value.length || !a.value.length,
                      class: "min-w-[140px] transition-all duration-300 hover:scale-105 shadow-md hover:shadow-lg disabled:opacity-50",
                      onClick: w
                    }, {
                      default: He(() => [
                        s.value ? ($t(), kn(J(k2e), {
                          key: 0,
                          class: "mr-2 h-4 w-4 animate-spin"
                        })) : S0("", true),
                        Zr(" " + It(J(e)("modelTest.startTest")), 1)
                      ]),
                      _: 1
                    }, 8, [
                      "disabled"
                    ]),
                    kt(J(oD), {
                      variant: "outline",
                      disabled: !y.value,
                      class: "min-w-[140px] transition-all duration-300 hover:scale-105 shadow-sm hover:shadow-md disabled:opacity-50",
                      onClick: _
                    }, {
                      default: He(() => [
                        Zr(It(J(e)("modelTest.exportResults")), 1)
                      ]),
                      _: 1
                    }, 8, [
                      "disabled"
                    ])
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Ge("div", ebt, [
          kt(J(wxt), {
            modelValue: o.value,
            "onUpdate:modelValue": N[8] || (N[8] = (E) => o.value = E),
            class: "w-full"
          }, {
            default: He(() => [
              kt(J(_xt), {
                class: "grid w-full grid-cols-2 p-1 bg-gray-100/50 rounded-lg"
              }, {
                default: He(() => [
                  kt(J(l6), {
                    value: "chart",
                    class: "data-[state=active]:bg-white data-[state=active]:shadow-sm rounded-md transition-all duration-300"
                  }, {
                    default: He(() => [
                      Zr(It(J(e)("modelTest.performanceChart")), 1)
                    ]),
                    _: 1
                  }),
                  kt(J(l6), {
                    value: "table",
                    class: "data-[state=active]:bg-white data-[state=active]:shadow-sm rounded-md transition-all duration-300"
                  }, {
                    default: He(() => [
                      Zr(It(J(e)("modelTest.detailData")), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              kt(J(o6), {
                value: "chart"
              }, {
                default: He(() => [
                  Ge("div", tbt, [
                    Ge("div", {
                      ref_key: "performanceChart",
                      ref: c,
                      class: "h-[500px] w-full"
                    }, null, 512)
                  ])
                ]),
                _: 1
              }),
              kt(J(o6), {
                value: "table"
              }, {
                default: He(() => [
                  Ge("div", nbt, [
                    kt(J(Ixt), {
                      class: "min-w-full table-auto"
                    }, {
                      default: He(() => [
                        kt(J(Txt), null, {
                          default: He(() => [
                            kt(J(u6), {
                              class: "bg-gray-50/70 hover:bg-gray-50/90"
                            }, {
                              default: He(() => [
                                kt(J(ng), {
                                  class: "font-semibold"
                                }, {
                                  default: He(() => [
                                    Zr(It(J(e)("modelTest.tableColumns.model")), 1)
                                  ]),
                                  _: 1
                                }),
                                kt(J(ng), {
                                  class: "font-semibold"
                                }, {
                                  default: He(() => [
                                    Zr(It(J(e)("modelTest.tableColumns.image")), 1)
                                  ]),
                                  _: 1
                                }),
                                kt(J(ng), {
                                  class: "font-semibold"
                                }, {
                                  default: He(() => [
                                    Zr(It(J(e)("modelTest.tableColumns.warmupTime")), 1)
                                  ]),
                                  _: 1
                                }),
                                kt(J(ng), {
                                  class: "font-semibold"
                                }, {
                                  default: He(() => [
                                    Zr(It(J(e)("modelTest.tableColumns.inferenceTime")), 1)
                                  ]),
                                  _: 1
                                }),
                                kt(J(ng), {
                                  class: "font-semibold"
                                }, {
                                  default: He(() => [
                                    Zr(It(J(e)("modelTest.tableColumns.fps")), 1)
                                  ]),
                                  _: 1
                                }),
                                kt(J(ng), {
                                  class: "font-semibold"
                                }, {
                                  default: He(() => [
                                    Zr(It(J(e)("modelTest.tableColumns.actions")), 1)
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        kt(J(kxt), null, {
                          default: He(() => [
                            ($t(true), Ai(_0, null, B3(v.value, (E) => ($t(), kn(J(u6), {
                              key: E.modelName + E.imageName,
                              class: "hover:bg-gray-50/50 transition-colors duration-200"
                            }, {
                              default: He(() => [
                                kt(J(tg), {
                                  class: "font-medium"
                                }, {
                                  default: He(() => [
                                    Zr(It(E.modelName), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                kt(J(tg), null, {
                                  default: He(() => [
                                    Zr(It(E.imageName), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                kt(J(tg), null, {
                                  default: He(() => [
                                    Zr(It(E.warmupTime), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                kt(J(tg), null, {
                                  default: He(() => [
                                    Zr(It(E.inferenceTime), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                kt(J(tg), null, {
                                  default: He(() => [
                                    Zr(It(E.fps), 1)
                                  ]),
                                  _: 2
                                }, 1024),
                                kt(J(tg), null, {
                                  default: He(() => [
                                    kt(J(oD), {
                                      variant: "ghost",
                                      class: "transition-all duration-300 hover:scale-110 hover:text-primary",
                                      onClick: (A) => I(E)
                                    }, {
                                      default: He(() => [
                                        Zr(It(J(e)("modelTest.tableColumns.viewDetail")), 1)
                                      ]),
                                      _: 2
                                    }, 1032, [
                                      "onClick"
                                    ])
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1024))), 128))
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, [
            "modelValue"
          ])
        ]),
        kt(J(fxt), {
          open: l.value,
          "onUpdate:open": N[9] || (N[9] = (E) => l.value = E)
        }, {
          default: He(() => [
            kt(J(pxt), {
              class: "sm:max-w-[800px] rounded-xl overflow-hidden bg-white/95 shadow-xl border border-gray-100/20"
            }, {
              default: He(() => {
                var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p, _q2, _r2;
                return [
                  kt(J(gxt), {
                    class: "border-b pb-4"
                  }, {
                    default: He(() => [
                      kt(J(mxt), {
                        class: "text-xl font-bold"
                      }, {
                        default: He(() => [
                          Zr(It(J(e)("modelTest.dialog.title")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  Ge("div", rbt, [
                    Ge("div", ibt, [
                      Ge("img", {
                        src: (_a2 = u.value) == null ? void 0 : _a2.image,
                        class: "max-w-full h-auto"
                      }, null, 8, abt),
                      Ge("canvas", {
                        ref_key: "detailCanvas",
                        ref: h,
                        class: "max-w-full h-auto absolute top-0 left-0"
                      }, null, 512)
                    ]),
                    Ge("div", sbt, [
                      Ge("div", obt, [
                        Ge("div", lbt, It(J(e)("modelTest.dialog.modelName")), 1),
                        Ge("div", ubt, It((_b2 = u.value) == null ? void 0 : _b2.modelName), 1)
                      ]),
                      Ge("div", cbt, [
                        Ge("div", hbt, It(J(e)("modelTest.dialog.backend")), 1),
                        Ge("div", dbt, It((_c2 = u.value) == null ? void 0 : _c2.backend), 1)
                      ]),
                      Ge("div", fbt, [
                        Ge("div", pbt, It(J(e)("modelTest.dialog.detectionCount")), 1),
                        Ge("div", gbt, It((_d2 = u.value) == null ? void 0 : _d2.detections), 1)
                      ]),
                      Ge("div", mbt, [
                        Ge("div", vbt, It(J(e)("modelTest.warmupCount")), 1),
                        Ge("div", ybt, It((_e2 = u.value) == null ? void 0 : _e2.warmupCount), 1)
                      ]),
                      Ge("div", xbt, [
                        Ge("div", bbt, It(J(e)("modelTest.dialog.testCount")), 1),
                        Ge("div", wbt, It((_f2 = u.value) == null ? void 0 : _f2.batchSize), 1)
                      ]),
                      Ge("div", _bt, [
                        Ge("div", Sbt, It(J(e)("modelTest.dialog.totalCount")), 1),
                        Ge("div", Cbt, It((((_g2 = u.value) == null ? void 0 : _g2.batchSize) ?? 0) + (((_h2 = u.value) == null ? void 0 : _h2.warmupCount) ?? 0)), 1)
                      ]),
                      Ge("div", Ibt, [
                        Ge("div", kbt, It(J(e)("modelTest.dialog.warmupTime")), 1),
                        Ge("div", Tbt, It((_j2 = (_i2 = u.value) == null ? void 0 : _i2.warmupTime) == null ? void 0 : _j2.toFixed(0)) + "ms", 1)
                      ]),
                      Ge("div", Abt, [
                        Ge("div", Dbt, It(J(e)("modelTest.dialog.avgInferenceTime")), 1),
                        Ge("div", Rbt, It((_l2 = (_k2 = u.value) == null ? void 0 : _k2.inferenceTime) == null ? void 0 : _l2.toFixed(0)) + "ms", 1)
                      ]),
                      Ge("div", $bt, [
                        Ge("div", Nbt, It(J(e)("modelTest.dialog.avgFps")), 1),
                        Ge("div", Ebt, It((_m2 = u.value) == null ? void 0 : _m2.fps), 1)
                      ]),
                      Ge("div", Mbt, [
                        Ge("div", Pbt, It(J(e)("modelTest.dialog.minInferenceTime")), 1),
                        Ge("div", Lbt, It((_o2 = (_n2 = u.value) == null ? void 0 : _n2.minInferenceTime) == null ? void 0 : _o2.toFixed(0)) + "ms", 1)
                      ]),
                      Ge("div", Fbt, [
                        Ge("div", Obt, It(J(e)("modelTest.dialog.maxInferenceTime")), 1),
                        Ge("div", Bbt, It((_q2 = (_p = u.value) == null ? void 0 : _p.maxInferenceTime) == null ? void 0 : _q2.toFixed(0)) + "ms", 1)
                      ]),
                      Ge("div", zbt, [
                        Ge("div", Vbt, It(J(e)("modelTest.dialog.totalTime")), 1),
                        Ge("div", Wbt, It(((((_r2 = u.value) == null ? void 0 : _r2.totalTime) ?? 0) / 1e3).toFixed(1)) + "s", 1)
                      ])
                    ])
                  ])
                ];
              }),
              _: 1
            })
          ]),
          _: 1
        }, 8, [
          "open"
        ])
      ]));
    }
  });
  Hbt = kse(Ubt, [
    [
      "__scopeId",
      "data-v-fff56941"
    ]
  ]);
  iwt = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Hbt
  }, Symbol.toStringTag, {
    value: "Module"
  }));
});
export {
  e3 as $,
  Nie as A,
  xa as B,
  yp as C,
  to as D,
  Nn as E,
  co as F,
  m2 as G,
  Hdt as H,
  kH as I,
  am as J,
  vft as K,
  kft as L,
  pn as M,
  Dr as N,
  ri as O,
  Ri as P,
  Rft as Q,
  tN as R,
  Kft as S,
  $w as T,
  Q$ as U,
  AH as V,
  FA as W,
  RH as X,
  qdt as Y,
  Ei as Z,
  rie as _,
  __tla,
  fl as a,
  Eie as a0,
  Gn as a1,
  or as a2,
  Pft as a3,
  npt as a4,
  wpt as a5,
  Spt as a6,
  Apt as a7,
  Rpt as a8,
  $pt as a9,
  YL as aa,
  Nd as ab,
  Egt as ac,
  Mgt as ad,
  rC as ae,
  uN as af,
  dg as ag,
  Agt as ah,
  Yie as ai,
  XH as aj,
  UH as ak,
  fdt as al,
  aC as am,
  gdt as an,
  Kie as ao,
  iwt as ap,
  _x as b,
  T_ as c,
  UL as d,
  $s as e,
  HH as f,
  Yft as g,
  Die as h,
  fie as i,
  mo as j,
  Aie as k,
  bpt as l,
  _pt as m,
  pH as n,
  kpt as o,
  Dpt as p,
  Fie as q,
  Adt as r,
  HL as s,
  Fn as t,
  Cie as u,
  pdt as v,
  Ua as w,
  Ept as x,
  Wl as y,
  eie as z
};
